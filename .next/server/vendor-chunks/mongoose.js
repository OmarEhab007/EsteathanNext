"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/mongoose";
exports.ids = ["vendor-chunks/mongoose"];
exports.modules = {

/***/ "(ssr)/./node_modules/mongoose/index.js":
/*!****************************************!*\
  !*** ./node_modules/mongoose/index.js ***!
  \****************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("/**\n * Export lib/mongoose\n *\n */\n\n\n\nconst mongoose = __webpack_require__(/*! ./lib/ */ \"(ssr)/./node_modules/mongoose/lib/index.js\");\n\nmodule.exports = mongoose;\nmodule.exports[\"default\"] = mongoose;\nmodule.exports.mongoose = mongoose;\n\n// Re-export for ESM support\nmodule.exports.cast = mongoose.cast;\nmodule.exports.STATES = mongoose.STATES;\nmodule.exports.setDriver = mongoose.setDriver;\nmodule.exports.set = mongoose.set;\nmodule.exports.get = mongoose.get;\nmodule.exports.createConnection = mongoose.createConnection;\nmodule.exports.connect = mongoose.connect;\nmodule.exports.disconnect = mongoose.disconnect;\nmodule.exports.startSession = mongoose.startSession;\nmodule.exports.pluralize = mongoose.pluralize;\nmodule.exports.model = mongoose.model;\nmodule.exports.deleteModel = mongoose.deleteModel;\nmodule.exports.modelNames = mongoose.modelNames;\nmodule.exports.plugin = mongoose.plugin;\nmodule.exports.connections = mongoose.connections;\nmodule.exports.version = mongoose.version;\nmodule.exports.Mongoose = mongoose.Mongoose;\nmodule.exports.Schema = mongoose.Schema;\nmodule.exports.SchemaType = mongoose.SchemaType;\nmodule.exports.SchemaTypes = mongoose.SchemaTypes;\nmodule.exports.VirtualType = mongoose.VirtualType;\nmodule.exports.Types = mongoose.Types;\nmodule.exports.Query = mongoose.Query;\nmodule.exports.Model = mongoose.Model;\nmodule.exports.Document = mongoose.Document;\nmodule.exports.ObjectId = mongoose.ObjectId;\nmodule.exports.isValidObjectId = mongoose.isValidObjectId;\nmodule.exports.isObjectIdOrHexString = mongoose.isObjectIdOrHexString;\nmodule.exports.syncIndexes = mongoose.syncIndexes;\nmodule.exports.Decimal128 = mongoose.Decimal128;\nmodule.exports.Mixed = mongoose.Mixed;\nmodule.exports.Date = mongoose.Date;\nmodule.exports.Number = mongoose.Number;\nmodule.exports.Error = mongoose.Error;\nmodule.exports.MongooseError = mongoose.MongooseError;\nmodule.exports.now = mongoose.now;\nmodule.exports.CastError = mongoose.CastError;\nmodule.exports.SchemaTypeOptions = mongoose.SchemaTypeOptions;\nmodule.exports.mongo = mongoose.mongo;\nmodule.exports.mquery = mongoose.mquery;\nmodule.exports.sanitizeFilter = mongoose.sanitizeFilter;\nmodule.exports.trusted = mongoose.trusted;\nmodule.exports.skipMiddlewareFunction = mongoose.skipMiddlewareFunction;\nmodule.exports.overwriteMiddlewareResult = mongoose.overwriteMiddlewareResult;\n\n// The following properties are not exported using ESM because `setDriver()` can mutate these\n// module.exports.connection = mongoose.connection;\n// module.exports.Collection = mongoose.Collection;\n// module.exports.Connection = mongoose.Connection;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbW9uZ29vc2UvaW5kZXguanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7O0FBRWE7O0FBRWIsaUJBQWlCLG1CQUFPLENBQUMsMERBQVE7O0FBRWpDO0FBQ0EseUJBQXNCO0FBQ3RCLHVCQUF1Qjs7QUFFdkI7QUFDQSxtQkFBbUI7QUFDbkIscUJBQXFCO0FBQ3JCLHdCQUF3QjtBQUN4QixrQkFBa0I7QUFDbEIsa0JBQWtCO0FBQ2xCLCtCQUErQjtBQUMvQixzQkFBc0I7QUFDdEIseUJBQXlCO0FBQ3pCLDJCQUEyQjtBQUMzQix3QkFBd0I7QUFDeEIsb0JBQW9CO0FBQ3BCLDBCQUEwQjtBQUMxQix5QkFBeUI7QUFDekIscUJBQXFCO0FBQ3JCLDBCQUEwQjtBQUMxQixzQkFBc0I7QUFDdEIsdUJBQXVCO0FBQ3ZCLHFCQUFxQjtBQUNyQix5QkFBeUI7QUFDekIsMEJBQTBCO0FBQzFCLDBCQUEwQjtBQUMxQixvQkFBb0I7QUFDcEIsb0JBQW9CO0FBQ3BCLG9CQUFvQjtBQUNwQix1QkFBdUI7QUFDdkIsdUJBQXVCO0FBQ3ZCLDhCQUE4QjtBQUM5QixvQ0FBb0M7QUFDcEMsMEJBQTBCO0FBQzFCLHlCQUF5QjtBQUN6QixvQkFBb0I7QUFDcEIsbUJBQW1CO0FBQ25CLHFCQUFxQjtBQUNyQixvQkFBb0I7QUFDcEIsNEJBQTRCO0FBQzVCLGtCQUFrQjtBQUNsQix3QkFBd0I7QUFDeEIsZ0NBQWdDO0FBQ2hDLG9CQUFvQjtBQUNwQixxQkFBcUI7QUFDckIsNkJBQTZCO0FBQzdCLHNCQUFzQjtBQUN0QixxQ0FBcUM7QUFDckMsd0NBQXdDOztBQUV4QztBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL2FwcDEvLi9ub2RlX21vZHVsZXMvbW9uZ29vc2UvaW5kZXguanM/OGMwMiJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEV4cG9ydCBsaWIvbW9uZ29vc2VcbiAqXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG5jb25zdCBtb25nb29zZSA9IHJlcXVpcmUoJy4vbGliLycpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IG1vbmdvb3NlO1xubW9kdWxlLmV4cG9ydHMuZGVmYXVsdCA9IG1vbmdvb3NlO1xubW9kdWxlLmV4cG9ydHMubW9uZ29vc2UgPSBtb25nb29zZTtcblxuLy8gUmUtZXhwb3J0IGZvciBFU00gc3VwcG9ydFxubW9kdWxlLmV4cG9ydHMuY2FzdCA9IG1vbmdvb3NlLmNhc3Q7XG5tb2R1bGUuZXhwb3J0cy5TVEFURVMgPSBtb25nb29zZS5TVEFURVM7XG5tb2R1bGUuZXhwb3J0cy5zZXREcml2ZXIgPSBtb25nb29zZS5zZXREcml2ZXI7XG5tb2R1bGUuZXhwb3J0cy5zZXQgPSBtb25nb29zZS5zZXQ7XG5tb2R1bGUuZXhwb3J0cy5nZXQgPSBtb25nb29zZS5nZXQ7XG5tb2R1bGUuZXhwb3J0cy5jcmVhdGVDb25uZWN0aW9uID0gbW9uZ29vc2UuY3JlYXRlQ29ubmVjdGlvbjtcbm1vZHVsZS5leHBvcnRzLmNvbm5lY3QgPSBtb25nb29zZS5jb25uZWN0O1xubW9kdWxlLmV4cG9ydHMuZGlzY29ubmVjdCA9IG1vbmdvb3NlLmRpc2Nvbm5lY3Q7XG5tb2R1bGUuZXhwb3J0cy5zdGFydFNlc3Npb24gPSBtb25nb29zZS5zdGFydFNlc3Npb247XG5tb2R1bGUuZXhwb3J0cy5wbHVyYWxpemUgPSBtb25nb29zZS5wbHVyYWxpemU7XG5tb2R1bGUuZXhwb3J0cy5tb2RlbCA9IG1vbmdvb3NlLm1vZGVsO1xubW9kdWxlLmV4cG9ydHMuZGVsZXRlTW9kZWwgPSBtb25nb29zZS5kZWxldGVNb2RlbDtcbm1vZHVsZS5leHBvcnRzLm1vZGVsTmFtZXMgPSBtb25nb29zZS5tb2RlbE5hbWVzO1xubW9kdWxlLmV4cG9ydHMucGx1Z2luID0gbW9uZ29vc2UucGx1Z2luO1xubW9kdWxlLmV4cG9ydHMuY29ubmVjdGlvbnMgPSBtb25nb29zZS5jb25uZWN0aW9ucztcbm1vZHVsZS5leHBvcnRzLnZlcnNpb24gPSBtb25nb29zZS52ZXJzaW9uO1xubW9kdWxlLmV4cG9ydHMuTW9uZ29vc2UgPSBtb25nb29zZS5Nb25nb29zZTtcbm1vZHVsZS5leHBvcnRzLlNjaGVtYSA9IG1vbmdvb3NlLlNjaGVtYTtcbm1vZHVsZS5leHBvcnRzLlNjaGVtYVR5cGUgPSBtb25nb29zZS5TY2hlbWFUeXBlO1xubW9kdWxlLmV4cG9ydHMuU2NoZW1hVHlwZXMgPSBtb25nb29zZS5TY2hlbWFUeXBlcztcbm1vZHVsZS5leHBvcnRzLlZpcnR1YWxUeXBlID0gbW9uZ29vc2UuVmlydHVhbFR5cGU7XG5tb2R1bGUuZXhwb3J0cy5UeXBlcyA9IG1vbmdvb3NlLlR5cGVzO1xubW9kdWxlLmV4cG9ydHMuUXVlcnkgPSBtb25nb29zZS5RdWVyeTtcbm1vZHVsZS5leHBvcnRzLk1vZGVsID0gbW9uZ29vc2UuTW9kZWw7XG5tb2R1bGUuZXhwb3J0cy5Eb2N1bWVudCA9IG1vbmdvb3NlLkRvY3VtZW50O1xubW9kdWxlLmV4cG9ydHMuT2JqZWN0SWQgPSBtb25nb29zZS5PYmplY3RJZDtcbm1vZHVsZS5leHBvcnRzLmlzVmFsaWRPYmplY3RJZCA9IG1vbmdvb3NlLmlzVmFsaWRPYmplY3RJZDtcbm1vZHVsZS5leHBvcnRzLmlzT2JqZWN0SWRPckhleFN0cmluZyA9IG1vbmdvb3NlLmlzT2JqZWN0SWRPckhleFN0cmluZztcbm1vZHVsZS5leHBvcnRzLnN5bmNJbmRleGVzID0gbW9uZ29vc2Uuc3luY0luZGV4ZXM7XG5tb2R1bGUuZXhwb3J0cy5EZWNpbWFsMTI4ID0gbW9uZ29vc2UuRGVjaW1hbDEyODtcbm1vZHVsZS5leHBvcnRzLk1peGVkID0gbW9uZ29vc2UuTWl4ZWQ7XG5tb2R1bGUuZXhwb3J0cy5EYXRlID0gbW9uZ29vc2UuRGF0ZTtcbm1vZHVsZS5leHBvcnRzLk51bWJlciA9IG1vbmdvb3NlLk51bWJlcjtcbm1vZHVsZS5leHBvcnRzLkVycm9yID0gbW9uZ29vc2UuRXJyb3I7XG5tb2R1bGUuZXhwb3J0cy5Nb25nb29zZUVycm9yID0gbW9uZ29vc2UuTW9uZ29vc2VFcnJvcjtcbm1vZHVsZS5leHBvcnRzLm5vdyA9IG1vbmdvb3NlLm5vdztcbm1vZHVsZS5leHBvcnRzLkNhc3RFcnJvciA9IG1vbmdvb3NlLkNhc3RFcnJvcjtcbm1vZHVsZS5leHBvcnRzLlNjaGVtYVR5cGVPcHRpb25zID0gbW9uZ29vc2UuU2NoZW1hVHlwZU9wdGlvbnM7XG5tb2R1bGUuZXhwb3J0cy5tb25nbyA9IG1vbmdvb3NlLm1vbmdvO1xubW9kdWxlLmV4cG9ydHMubXF1ZXJ5ID0gbW9uZ29vc2UubXF1ZXJ5O1xubW9kdWxlLmV4cG9ydHMuc2FuaXRpemVGaWx0ZXIgPSBtb25nb29zZS5zYW5pdGl6ZUZpbHRlcjtcbm1vZHVsZS5leHBvcnRzLnRydXN0ZWQgPSBtb25nb29zZS50cnVzdGVkO1xubW9kdWxlLmV4cG9ydHMuc2tpcE1pZGRsZXdhcmVGdW5jdGlvbiA9IG1vbmdvb3NlLnNraXBNaWRkbGV3YXJlRnVuY3Rpb247XG5tb2R1bGUuZXhwb3J0cy5vdmVyd3JpdGVNaWRkbGV3YXJlUmVzdWx0ID0gbW9uZ29vc2Uub3ZlcndyaXRlTWlkZGxld2FyZVJlc3VsdDtcblxuLy8gVGhlIGZvbGxvd2luZyBwcm9wZXJ0aWVzIGFyZSBub3QgZXhwb3J0ZWQgdXNpbmcgRVNNIGJlY2F1c2UgYHNldERyaXZlcigpYCBjYW4gbXV0YXRlIHRoZXNlXG4vLyBtb2R1bGUuZXhwb3J0cy5jb25uZWN0aW9uID0gbW9uZ29vc2UuY29ubmVjdGlvbjtcbi8vIG1vZHVsZS5leHBvcnRzLkNvbGxlY3Rpb24gPSBtb25nb29zZS5Db2xsZWN0aW9uO1xuLy8gbW9kdWxlLmV4cG9ydHMuQ29ubmVjdGlvbiA9IG1vbmdvb3NlLkNvbm5lY3Rpb247XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/mongoose/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/mongoose/lib/aggregate.js":
/*!************************************************!*\
  !*** ./node_modules/mongoose/lib/aggregate.js ***!
  \************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\n\n/*!\n * Module dependencies\n */\n\nconst AggregationCursor = __webpack_require__(/*! ./cursor/aggregationCursor */ \"(ssr)/./node_modules/mongoose/lib/cursor/aggregationCursor.js\");\nconst MongooseError = __webpack_require__(/*! ./error/mongooseError */ \"(ssr)/./node_modules/mongoose/lib/error/mongooseError.js\");\nconst Query = __webpack_require__(/*! ./query */ \"(ssr)/./node_modules/mongoose/lib/query.js\");\nconst { applyGlobalMaxTimeMS, applyGlobalDiskUse } = __webpack_require__(/*! ./helpers/query/applyGlobalOption */ \"(ssr)/./node_modules/mongoose/lib/helpers/query/applyGlobalOption.js\");\nconst clone = __webpack_require__(/*! ./helpers/clone */ \"(ssr)/./node_modules/mongoose/lib/helpers/clone.js\");\nconst getConstructorName = __webpack_require__(/*! ./helpers/getConstructorName */ \"(ssr)/./node_modules/mongoose/lib/helpers/getConstructorName.js\");\nconst prepareDiscriminatorPipeline = __webpack_require__(/*! ./helpers/aggregate/prepareDiscriminatorPipeline */ \"(ssr)/./node_modules/mongoose/lib/helpers/aggregate/prepareDiscriminatorPipeline.js\");\nconst stringifyFunctionOperators = __webpack_require__(/*! ./helpers/aggregate/stringifyFunctionOperators */ \"(ssr)/./node_modules/mongoose/lib/helpers/aggregate/stringifyFunctionOperators.js\");\nconst utils = __webpack_require__(/*! ./utils */ \"(ssr)/./node_modules/mongoose/lib/utils.js\");\nconst read = Query.prototype.read;\nconst readConcern = Query.prototype.readConcern;\n\nconst validRedactStringValues = new Set(['$$DESCEND', '$$PRUNE', '$$KEEP']);\n\n/**\n * Aggregate constructor used for building aggregation pipelines. Do not\n * instantiate this class directly, use [Model.aggregate()](https://mongoosejs.com/docs/api/model.html#Model.aggregate()) instead.\n *\n * #### Example:\n *\n *     const aggregate = Model.aggregate([\n *       { $project: { a: 1, b: 1 } },\n *       { $skip: 5 }\n *     ]);\n *\n *     Model.\n *       aggregate([{ $match: { age: { $gte: 21 }}}]).\n *       unwind('tags').\n *       exec();\n *\n * #### Note:\n *\n * - The documents returned are plain javascript objects, not mongoose documents (since any shape of document can be returned).\n * - Mongoose does **not** cast pipeline stages. The below will **not** work unless `_id` is a string in the database\n *\n *     new Aggregate([{ $match: { _id: '00000000000000000000000a' } }]);\n *     // Do this instead to cast to an ObjectId\n *     new Aggregate([{ $match: { _id: new mongoose.Types.ObjectId('00000000000000000000000a') } }]);\n *\n * @see MongoDB https://www.mongodb.com/docs/manual/applications/aggregation/\n * @see driver https://mongodb.github.io/node-mongodb-native/4.9/classes/Collection.html#aggregate\n * @param {Array} [pipeline] aggregation pipeline as an array of objects\n * @param {Model} [model] the model to use with this aggregate.\n * @api public\n */\n\nfunction Aggregate(pipeline, model) {\n  this._pipeline = [];\n  this._model = model;\n  this.options = {};\n\n  if (arguments.length === 1 && Array.isArray(pipeline)) {\n    this.append.apply(this, pipeline);\n  }\n}\n\n/**\n * Contains options passed down to the [aggregate command](https://www.mongodb.com/docs/manual/reference/command/aggregate/).\n * Supported options are:\n *\n * - [`allowDiskUse`](https://mongoosejs.com/docs/api/aggregate.html#Aggregate.prototype.allowDiskUse())\n * - `bypassDocumentValidation`\n * - [`collation`](https://mongoosejs.com/docs/api/aggregate.html#Aggregate.prototype.collation())\n * - `comment`\n * - [`cursor`](https://mongoosejs.com/docs/api/aggregate.html#Aggregate.prototype.cursor())\n * - [`explain`](https://mongoosejs.com/docs/api/aggregate.html#Aggregate.prototype.explain())\n * - `fieldsAsRaw`\n * - [`hint`](https://mongoosejs.com/docs/api/aggregate.html#Aggregate.prototype.hint())\n * - `let`\n * - `maxTimeMS`\n * - `raw`\n * - [`readConcern`](https://mongoosejs.com/docs/api/aggregate.html#Aggregate.prototype.readConcern())\n * - `readPreference`\n * - [`session`](https://mongoosejs.com/docs/api/aggregate.html#Aggregate.prototype.session())\n * - `writeConcern`\n *\n * @property options\n * @memberOf Aggregate\n * @api public\n */\n\nAggregate.prototype.options;\n\n/**\n * Get/set the model that this aggregation will execute on.\n *\n * #### Example:\n *\n *     const aggregate = MyModel.aggregate([{ $match: { answer: 42 } }]);\n *     aggregate.model() === MyModel; // true\n *\n *     // Change the model. There's rarely any reason to do this.\n *     aggregate.model(SomeOtherModel);\n *     aggregate.model() === SomeOtherModel; // true\n *\n * @param {Model} [model] Set the model associated with this aggregate. If not provided, returns the already stored model.\n * @return {Model}\n * @api public\n */\n\nAggregate.prototype.model = function(model) {\n  if (arguments.length === 0) {\n    return this._model;\n  }\n\n  this._model = model;\n  if (model.schema != null) {\n    if (this.options.readPreference == null &&\n      model.schema.options.read != null) {\n      this.options.readPreference = model.schema.options.read;\n    }\n    if (this.options.collation == null &&\n      model.schema.options.collation != null) {\n      this.options.collation = model.schema.options.collation;\n    }\n  }\n\n  return model;\n};\n\n/**\n * Appends new operators to this aggregate pipeline\n *\n * #### Example:\n *\n *     aggregate.append({ $project: { field: 1 }}, { $limit: 2 });\n *\n *     // or pass an array\n *     const pipeline = [{ $match: { daw: 'Logic Audio X' }} ];\n *     aggregate.append(pipeline);\n *\n * @param {...Object|Object[]} ops operator(s) to append. Can either be a spread of objects or a single parameter of a object array.\n * @return {Aggregate}\n * @api public\n */\n\nAggregate.prototype.append = function() {\n  const args = (arguments.length === 1 && Array.isArray(arguments[0]))\n    ? arguments[0]\n    : [...arguments];\n\n  if (!args.every(isOperator)) {\n    throw new Error('Arguments must be aggregate pipeline operators');\n  }\n\n  this._pipeline = this._pipeline.concat(args);\n\n  return this;\n};\n\n/**\n * Appends a new $addFields operator to this aggregate pipeline.\n * Requires MongoDB v3.4+ to work\n *\n * #### Example:\n *\n *     // adding new fields based on existing fields\n *     aggregate.addFields({\n *         newField: '$b.nested'\n *       , plusTen: { $add: ['$val', 10]}\n *       , sub: {\n *            name: '$a'\n *         }\n *     })\n *\n *     // etc\n *     aggregate.addFields({ salary_k: { $divide: [ \"$salary\", 1000 ] } });\n *\n * @param {Object} arg field specification\n * @see $addFields https://www.mongodb.com/docs/manual/reference/operator/aggregation/addFields/\n * @return {Aggregate}\n * @api public\n */\nAggregate.prototype.addFields = function(arg) {\n  if (typeof arg !== 'object' || arg === null || Array.isArray(arg)) {\n    throw new Error('Invalid addFields() argument. Must be an object');\n  }\n  return this.append({ $addFields: Object.assign({}, arg) });\n};\n\n/**\n * Appends a new $project operator to this aggregate pipeline.\n *\n * Mongoose query [selection syntax](https://mongoosejs.com/docs/api/query.html#Query.prototype.select()) is also supported.\n *\n * #### Example:\n *\n *     // include a, include b, exclude _id\n *     aggregate.project(\"a b -_id\");\n *\n *     // or you may use object notation, useful when\n *     // you have keys already prefixed with a \"-\"\n *     aggregate.project({a: 1, b: 1, _id: 0});\n *\n *     // reshaping documents\n *     aggregate.project({\n *         newField: '$b.nested'\n *       , plusTen: { $add: ['$val', 10]}\n *       , sub: {\n *            name: '$a'\n *         }\n *     })\n *\n *     // etc\n *     aggregate.project({ salary_k: { $divide: [ \"$salary\", 1000 ] } });\n *\n * @param {Object|String} arg field specification\n * @see projection https://www.mongodb.com/docs/manual/reference/aggregation/project/\n * @return {Aggregate}\n * @api public\n */\n\nAggregate.prototype.project = function(arg) {\n  const fields = {};\n\n  if (typeof arg === 'object' && !Array.isArray(arg)) {\n    Object.keys(arg).forEach(function(field) {\n      fields[field] = arg[field];\n    });\n  } else if (arguments.length === 1 && typeof arg === 'string') {\n    arg.split(/\\s+/).forEach(function(field) {\n      if (!field) {\n        return;\n      }\n      const include = field[0] === '-' ? 0 : 1;\n      if (include === 0) {\n        field = field.substring(1);\n      }\n      fields[field] = include;\n    });\n  } else {\n    throw new Error('Invalid project() argument. Must be string or object');\n  }\n\n  return this.append({ $project: fields });\n};\n\n/**\n * Appends a new custom $group operator to this aggregate pipeline.\n *\n * #### Example:\n *\n *     aggregate.group({ _id: \"$department\" });\n *\n * @see $group https://www.mongodb.com/docs/manual/reference/aggregation/group/\n * @method group\n * @memberOf Aggregate\n * @instance\n * @param {Object} arg $group operator contents\n * @return {Aggregate}\n * @api public\n */\n\n/**\n * Appends a new custom $match operator to this aggregate pipeline.\n *\n * #### Example:\n *\n *     aggregate.match({ department: { $in: [ \"sales\", \"engineering\" ] } });\n *\n * @see $match https://www.mongodb.com/docs/manual/reference/aggregation/match/\n * @method match\n * @memberOf Aggregate\n * @instance\n * @param {Object} arg $match operator contents\n * @return {Aggregate}\n * @api public\n */\n\n/**\n * Appends a new $skip operator to this aggregate pipeline.\n *\n * #### Example:\n *\n *     aggregate.skip(10);\n *\n * @see $skip https://www.mongodb.com/docs/manual/reference/aggregation/skip/\n * @method skip\n * @memberOf Aggregate\n * @instance\n * @param {Number} num number of records to skip before next stage\n * @return {Aggregate}\n * @api public\n */\n\n/**\n * Appends a new $limit operator to this aggregate pipeline.\n *\n * #### Example:\n *\n *     aggregate.limit(10);\n *\n * @see $limit https://www.mongodb.com/docs/manual/reference/aggregation/limit/\n * @method limit\n * @memberOf Aggregate\n * @instance\n * @param {Number} num maximum number of records to pass to the next stage\n * @return {Aggregate}\n * @api public\n */\n\n\n/**\n * Appends a new $densify operator to this aggregate pipeline.\n *\n * #### Example:\n *\n *      aggregate.densify({\n *        field: 'timestamp',\n *        range: {\n *          step: 1,\n *          unit: 'hour',\n *          bounds: [new Date('2021-05-18T00:00:00.000Z'), new Date('2021-05-18T08:00:00.000Z')]\n *        }\n *      });\n *\n * @see $densify https://www.mongodb.com/docs/manual/reference/operator/aggregation/densify/\n * @method densify\n * @memberOf Aggregate\n * @instance\n * @param {Object} arg $densify operator contents\n * @return {Aggregate}\n * @api public\n */\n\n/**\n * Appends a new $fill operator to this aggregate pipeline.\n *\n * #### Example:\n *\n *      aggregate.fill({\n *        output: {\n *          bootsSold: { value: 0 },\n *          sandalsSold: { value: 0 },\n *          sneakersSold: { value: 0 }\n *        }\n *      });\n *\n * @see $fill https://www.mongodb.com/docs/manual/reference/operator/aggregation/fill/\n * @method fill\n * @memberOf Aggregate\n * @instance\n * @param {Object} arg $fill operator contents\n * @return {Aggregate}\n * @api public\n */\n\n/**\n * Appends a new $geoNear operator to this aggregate pipeline.\n *\n * #### Note:\n *\n * **MUST** be used as the first operator in the pipeline.\n *\n * #### Example:\n *\n *     aggregate.near({\n *       near: { type: 'Point', coordinates: [40.724, -73.997] },\n *       distanceField: \"dist.calculated\", // required\n *       maxDistance: 0.008,\n *       query: { type: \"public\" },\n *       includeLocs: \"dist.location\",\n *       spherical: true,\n *     });\n *\n * @see $geoNear https://www.mongodb.com/docs/manual/reference/aggregation/geoNear/\n * @method near\n * @memberOf Aggregate\n * @instance\n * @param {Object} arg\n * @return {Aggregate}\n * @api public\n */\n\nAggregate.prototype.near = function(arg) {\n  const op = {};\n  op.$geoNear = arg;\n  return this.append(op);\n};\n\n/*!\n * define methods\n */\n\n'group match skip limit out densify fill'.split(' ').forEach(function($operator) {\n  Aggregate.prototype[$operator] = function(arg) {\n    const op = {};\n    op['$' + $operator] = arg;\n    return this.append(op);\n  };\n});\n\n/**\n * Appends new custom $unwind operator(s) to this aggregate pipeline.\n *\n * Note that the `$unwind` operator requires the path name to start with '$'.\n * Mongoose will prepend '$' if the specified field doesn't start '$'.\n *\n * #### Example:\n *\n *     aggregate.unwind(\"tags\");\n *     aggregate.unwind(\"a\", \"b\", \"c\");\n *     aggregate.unwind({ path: '$tags', preserveNullAndEmptyArrays: true });\n *\n * @see $unwind https://www.mongodb.com/docs/manual/reference/aggregation/unwind/\n * @param {String|Object|String[]|Object[]} fields the field(s) to unwind, either as field names or as [objects with options](https://www.mongodb.com/docs/manual/reference/operator/aggregation/unwind/#document-operand-with-options). If passing a string, prefixing the field name with '$' is optional. If passing an object, `path` must start with '$'.\n * @return {Aggregate}\n * @api public\n */\n\nAggregate.prototype.unwind = function() {\n  const args = [...arguments];\n\n  const res = [];\n  for (const arg of args) {\n    if (arg && typeof arg === 'object') {\n      res.push({ $unwind: arg });\n    } else if (typeof arg === 'string') {\n      res.push({\n        $unwind: (arg[0] === '$') ? arg : '$' + arg\n      });\n    } else {\n      throw new Error('Invalid arg \"' + arg + '\" to unwind(), ' +\n        'must be string or object');\n    }\n  }\n\n  return this.append.apply(this, res);\n};\n\n/**\n * Appends a new $replaceRoot operator to this aggregate pipeline.\n *\n * Note that the `$replaceRoot` operator requires field strings to start with '$'.\n * If you are passing in a string Mongoose will prepend '$' if the specified field doesn't start '$'.\n * If you are passing in an object the strings in your expression will not be altered.\n *\n * #### Example:\n *\n *     aggregate.replaceRoot(\"user\");\n *\n *     aggregate.replaceRoot({ x: { $concat: ['$this', '$that'] } });\n *\n * @see $replaceRoot https://www.mongodb.com/docs/manual/reference/operator/aggregation/replaceRoot\n * @param {String|Object} newRoot the field or document which will become the new root document\n * @return {Aggregate}\n * @api public\n */\n\nAggregate.prototype.replaceRoot = function(newRoot) {\n  let ret;\n\n  if (typeof newRoot === 'string') {\n    ret = newRoot.startsWith('$') ? newRoot : '$' + newRoot;\n  } else {\n    ret = newRoot;\n  }\n\n  return this.append({\n    $replaceRoot: {\n      newRoot: ret\n    }\n  });\n};\n\n/**\n * Appends a new $count operator to this aggregate pipeline.\n *\n * #### Example:\n *\n *     aggregate.count(\"userCount\");\n *\n * @see $count https://www.mongodb.com/docs/manual/reference/operator/aggregation/count\n * @param {String} fieldName The name of the output field which has the count as its value. It must be a non-empty string, must not start with $ and must not contain the . character.\n * @return {Aggregate}\n * @api public\n */\n\nAggregate.prototype.count = function(fieldName) {\n  return this.append({ $count: fieldName });\n};\n\n/**\n * Appends a new $sortByCount operator to this aggregate pipeline. Accepts either a string field name\n * or a pipeline object.\n *\n * Note that the `$sortByCount` operator requires the new root to start with '$'.\n * Mongoose will prepend '$' if the specified field name doesn't start with '$'.\n *\n * #### Example:\n *\n *     aggregate.sortByCount('users');\n *     aggregate.sortByCount({ $mergeObjects: [ \"$employee\", \"$business\" ] })\n *\n * @see $sortByCount https://www.mongodb.com/docs/manual/reference/operator/aggregation/sortByCount/\n * @param {Object|String} arg\n * @return {Aggregate} this\n * @api public\n */\n\nAggregate.prototype.sortByCount = function(arg) {\n  if (arg && typeof arg === 'object') {\n    return this.append({ $sortByCount: arg });\n  } else if (typeof arg === 'string') {\n    return this.append({\n      $sortByCount: (arg[0] === '$') ? arg : '$' + arg\n    });\n  } else {\n    throw new TypeError('Invalid arg \"' + arg + '\" to sortByCount(), ' +\n      'must be string or object');\n  }\n};\n\n/**\n * Appends new custom $lookup operator to this aggregate pipeline.\n *\n * #### Example:\n *\n *     aggregate.lookup({ from: 'users', localField: 'userId', foreignField: '_id', as: 'users' });\n *\n * @see $lookup https://www.mongodb.com/docs/manual/reference/operator/aggregation/lookup/#pipe._S_lookup\n * @param {Object} options to $lookup as described in the above link\n * @return {Aggregate}\n * @api public\n */\n\nAggregate.prototype.lookup = function(options) {\n  return this.append({ $lookup: options });\n};\n\n/**\n * Appends new custom $graphLookup operator(s) to this aggregate pipeline, performing a recursive search on a collection.\n *\n * Note that graphLookup can only consume at most 100MB of memory, and does not allow disk use even if `{ allowDiskUse: true }` is specified.\n *\n * #### Example:\n *\n *      // Suppose we have a collection of courses, where a document might look like `{ _id: 0, name: 'Calculus', prerequisite: 'Trigonometry'}` and `{ _id: 0, name: 'Trigonometry', prerequisite: 'Algebra' }`\n *      aggregate.graphLookup({ from: 'courses', startWith: '$prerequisite', connectFromField: 'prerequisite', connectToField: 'name', as: 'prerequisites', maxDepth: 3 }) // this will recursively search the 'courses' collection up to 3 prerequisites\n *\n * @see $graphLookup https://www.mongodb.com/docs/manual/reference/operator/aggregation/graphLookup/#pipe._S_graphLookup\n * @param {Object} options to $graphLookup as described in the above link\n * @return {Aggregate}\n * @api public\n */\n\nAggregate.prototype.graphLookup = function(options) {\n  const cloneOptions = {};\n  if (options) {\n    if (!utils.isObject(options)) {\n      throw new TypeError('Invalid graphLookup() argument. Must be an object.');\n    }\n\n    utils.mergeClone(cloneOptions, options);\n    const startWith = cloneOptions.startWith;\n\n    if (startWith && typeof startWith === 'string') {\n      cloneOptions.startWith = cloneOptions.startWith.startsWith('$') ?\n        cloneOptions.startWith :\n        '$' + cloneOptions.startWith;\n    }\n\n  }\n  return this.append({ $graphLookup: cloneOptions });\n};\n\n/**\n * Appends new custom $sample operator to this aggregate pipeline.\n *\n * #### Example:\n *\n *     aggregate.sample(3); // Add a pipeline that picks 3 random documents\n *\n * @see $sample https://www.mongodb.com/docs/manual/reference/operator/aggregation/sample/#pipe._S_sample\n * @param {Number} size number of random documents to pick\n * @return {Aggregate}\n * @api public\n */\n\nAggregate.prototype.sample = function(size) {\n  return this.append({ $sample: { size: size } });\n};\n\n/**\n * Appends a new $sort operator to this aggregate pipeline.\n *\n * If an object is passed, values allowed are `asc`, `desc`, `ascending`, `descending`, `1`, and `-1`.\n *\n * If a string is passed, it must be a space delimited list of path names. The sort order of each path is ascending unless the path name is prefixed with `-` which will be treated as descending.\n *\n * #### Example:\n *\n *     // these are equivalent\n *     aggregate.sort({ field: 'asc', test: -1 });\n *     aggregate.sort('field -test');\n *\n * @see $sort https://www.mongodb.com/docs/manual/reference/aggregation/sort/\n * @param {Object|String} arg\n * @return {Aggregate} this\n * @api public\n */\n\nAggregate.prototype.sort = function(arg) {\n  // TODO refactor to reuse the query builder logic\n\n  const sort = {};\n\n  if (getConstructorName(arg) === 'Object') {\n    const desc = ['desc', 'descending', -1];\n    Object.keys(arg).forEach(function(field) {\n      // If sorting by text score, skip coercing into 1/-1\n      if (arg[field] instanceof Object && arg[field].$meta) {\n        sort[field] = arg[field];\n        return;\n      }\n      sort[field] = desc.indexOf(arg[field]) === -1 ? 1 : -1;\n    });\n  } else if (arguments.length === 1 && typeof arg === 'string') {\n    arg.split(/\\s+/).forEach(function(field) {\n      if (!field) {\n        return;\n      }\n      const ascend = field[0] === '-' ? -1 : 1;\n      if (ascend === -1) {\n        field = field.substring(1);\n      }\n      sort[field] = ascend;\n    });\n  } else {\n    throw new TypeError('Invalid sort() argument. Must be a string or object.');\n  }\n\n  return this.append({ $sort: sort });\n};\n\n/**\n * Appends new $unionWith operator to this aggregate pipeline.\n *\n * #### Example:\n *\n *     aggregate.unionWith({ coll: 'users', pipeline: [ { $match: { _id: 1 } } ] });\n *\n * @see $unionWith https://www.mongodb.com/docs/manual/reference/operator/aggregation/unionWith\n * @param {Object} options to $unionWith query as described in the above link\n * @return {Aggregate}\n * @api public\n */\n\nAggregate.prototype.unionWith = function(options) {\n  return this.append({ $unionWith: options });\n};\n\n\n/**\n * Sets the readPreference option for the aggregation query.\n *\n * #### Example:\n *\n *     await Model.aggregate(pipeline).read('primaryPreferred');\n *\n * @param {String|ReadPreference} pref one of the listed preference options or their aliases\n * @param {Array} [tags] optional tags for this query. DEPRECATED\n * @return {Aggregate} this\n * @api public\n * @see mongodb https://www.mongodb.com/docs/manual/applications/replication/#read-preference\n */\n\nAggregate.prototype.read = function(pref, tags) {\n  read.call(this, pref, tags);\n  return this;\n};\n\n/**\n * Sets the readConcern level for the aggregation query.\n *\n * #### Example:\n *\n *     await Model.aggregate(pipeline).readConcern('majority');\n *\n * @param {String} level one of the listed read concern level or their aliases\n * @see mongodb https://www.mongodb.com/docs/manual/reference/read-concern/\n * @return {Aggregate} this\n * @api public\n */\n\nAggregate.prototype.readConcern = function(level) {\n  readConcern.call(this, level);\n  return this;\n};\n\n/**\n * Appends a new $redact operator to this aggregate pipeline.\n *\n * If 3 arguments are supplied, Mongoose will wrap them with if-then-else of $cond operator respectively\n * If `thenExpr` or `elseExpr` is string, make sure it starts with $$, like `$$DESCEND`, `$$PRUNE` or `$$KEEP`.\n *\n * #### Example:\n *\n *     await Model.aggregate(pipeline).redact({\n *       $cond: {\n *         if: { $eq: [ '$level', 5 ] },\n *         then: '$$PRUNE',\n *         else: '$$DESCEND'\n *       }\n *     });\n *\n *     // $redact often comes with $cond operator, you can also use the following syntax provided by mongoose\n *     await Model.aggregate(pipeline).redact({ $eq: [ '$level', 5 ] }, '$$PRUNE', '$$DESCEND');\n *\n * @param {Object} expression redact options or conditional expression\n * @param {String|Object} [thenExpr] true case for the condition\n * @param {String|Object} [elseExpr] false case for the condition\n * @return {Aggregate} this\n * @see $redact https://www.mongodb.com/docs/manual/reference/operator/aggregation/redact/\n * @api public\n */\n\nAggregate.prototype.redact = function(expression, thenExpr, elseExpr) {\n  if (arguments.length === 3) {\n    if ((typeof thenExpr === 'string' && !validRedactStringValues.has(thenExpr)) ||\n      (typeof elseExpr === 'string' && !validRedactStringValues.has(elseExpr))) {\n      throw new Error('If thenExpr or elseExpr is string, it must be either $$DESCEND, $$PRUNE or $$KEEP');\n    }\n\n    expression = {\n      $cond: {\n        if: expression,\n        then: thenExpr,\n        else: elseExpr\n      }\n    };\n  } else if (arguments.length !== 1) {\n    throw new TypeError('Invalid arguments');\n  }\n\n  return this.append({ $redact: expression });\n};\n\n/**\n * Execute the aggregation with explain\n *\n * #### Example:\n *\n *     Model.aggregate(..).explain()\n *\n * @param {String} [verbosity]\n * @return {Promise}\n */\n\nAggregate.prototype.explain = async function explain(verbosity) {\n  if (typeof verbosity === 'function' || typeof arguments[1] === 'function') {\n    throw new MongooseError('Aggregate.prototype.explain() no longer accepts a callback');\n  }\n  const model = this._model;\n\n  if (!this._pipeline.length) {\n    throw new Error('Aggregate has empty pipeline');\n  }\n\n  prepareDiscriminatorPipeline(this._pipeline, this._model.schema);\n\n  await new Promise((resolve, reject) => {\n    model.hooks.execPre('aggregate', this, error => {\n      if (error) {\n        const _opts = { error: error };\n        return model.hooks.execPost('aggregate', this, [null], _opts, error => {\n          reject(error);\n        });\n      } else {\n        resolve();\n      }\n    });\n  });\n\n  const cursor = model.collection.aggregate(this._pipeline, this.options);\n\n  if (verbosity == null) {\n    verbosity = true;\n  }\n\n  let result = null;\n  try {\n    result = await cursor.explain(verbosity);\n  } catch (error) {\n    await new Promise((resolve, reject) => {\n      const _opts = { error: error };\n      model.hooks.execPost('aggregate', this, [null], _opts, error => {\n        if (error) {\n          return reject(error);\n        }\n        return resolve();\n      });\n    });\n  }\n\n  const _opts = { error: null };\n  await new Promise((resolve, reject) => {\n    model.hooks.execPost('aggregate', this, [result], _opts, error => {\n      if (error) {\n        return reject(error);\n      }\n      return resolve();\n    });\n  });\n\n  return result;\n};\n\n/**\n * Sets the allowDiskUse option for the aggregation query\n *\n * #### Example:\n *\n *     await Model.aggregate([{ $match: { foo: 'bar' } }]).allowDiskUse(true);\n *\n * @param {Boolean} value Should tell server it can use hard drive to store data during aggregation.\n * @return {Aggregate} this\n * @see mongodb https://www.mongodb.com/docs/manual/reference/command/aggregate/\n */\n\nAggregate.prototype.allowDiskUse = function(value) {\n  this.options.allowDiskUse = value;\n  return this;\n};\n\n/**\n * Sets the hint option for the aggregation query\n *\n * #### Example:\n *\n *     Model.aggregate(..).hint({ qty: 1, category: 1 }).exec();\n *\n * @param {Object|String} value a hint object or the index name\n * @return {Aggregate} this\n * @see mongodb https://www.mongodb.com/docs/manual/reference/command/aggregate/\n */\n\nAggregate.prototype.hint = function(value) {\n  this.options.hint = value;\n  return this;\n};\n\n/**\n * Sets the session for this aggregation. Useful for [transactions](https://mongoosejs.com/docs/transactions.html).\n *\n * #### Example:\n *\n *     const session = await Model.startSession();\n *     await Model.aggregate(..).session(session);\n *\n * @param {ClientSession} session\n * @return {Aggregate} this\n * @see mongodb https://www.mongodb.com/docs/manual/reference/command/aggregate/\n */\n\nAggregate.prototype.session = function(session) {\n  if (session == null) {\n    delete this.options.session;\n  } else {\n    this.options.session = session;\n  }\n  return this;\n};\n\n/**\n * Lets you set arbitrary options, for middleware or plugins.\n *\n * #### Example:\n *\n *     const agg = Model.aggregate(..).option({ allowDiskUse: true }); // Set the `allowDiskUse` option\n *     agg.options; // `{ allowDiskUse: true }`\n *\n * @param {Object} options keys to merge into current options\n * @param {Number} [options.maxTimeMS] number limits the time this aggregation will run, see [MongoDB docs on `maxTimeMS`](https://www.mongodb.com/docs/manual/reference/operator/meta/maxTimeMS/)\n * @param {Boolean} [options.allowDiskUse] boolean if true, the MongoDB server will use the hard drive to store data during this aggregation\n * @param {Object} [options.collation] object see [`Aggregate.prototype.collation()`](https://mongoosejs.com/docs/api/aggregate.html#Aggregate.prototype.collation())\n * @param {ClientSession} [options.session] ClientSession see [`Aggregate.prototype.session()`](https://mongoosejs.com/docs/api/aggregate.html#Aggregate.prototype.session())\n * @see mongodb https://www.mongodb.com/docs/manual/reference/command/aggregate/\n * @return {Aggregate} this\n * @api public\n */\n\nAggregate.prototype.option = function(value) {\n  for (const key in value) {\n    this.options[key] = value[key];\n  }\n  return this;\n};\n\n/**\n * Sets the `cursor` option and executes this aggregation, returning an aggregation cursor.\n * Cursors are useful if you want to process the results of the aggregation one-at-a-time\n * because the aggregation result is too big to fit into memory.\n *\n * #### Example:\n *\n *     const cursor = Model.aggregate(..).cursor({ batchSize: 1000 });\n *     cursor.eachAsync(function(doc, i) {\n *       // use doc\n *     });\n *\n * @param {Object} options\n * @param {Number} [options.batchSize] set the cursor batch size\n * @param {Boolean} [options.useMongooseAggCursor] use experimental mongoose-specific aggregation cursor (for `eachAsync()` and other query cursor semantics)\n * @return {AggregationCursor} cursor representing this aggregation\n * @api public\n * @see mongodb https://mongodb.github.io/node-mongodb-native/4.9/classes/AggregationCursor.html\n */\n\nAggregate.prototype.cursor = function(options) {\n  this.options.cursor = options || {};\n  return new AggregationCursor(this); // return this;\n};\n\n/**\n * Adds a collation\n *\n * #### Example:\n *\n *     const res = await Model.aggregate(pipeline).collation({ locale: 'en_US', strength: 1 });\n *\n * @param {Object} collation options\n * @return {Aggregate} this\n * @api public\n * @see mongodb https://mongodb.github.io/node-mongodb-native/4.9/interfaces/CollationOptions.html\n */\n\nAggregate.prototype.collation = function(collation) {\n  this.options.collation = collation;\n  return this;\n};\n\n/**\n * Combines multiple aggregation pipelines.\n *\n * #### Example:\n *\n *     const res = await Model.aggregate().facet({\n *       books: [{ groupBy: '$author' }],\n *       price: [{ $bucketAuto: { groupBy: '$price', buckets: 2 } }]\n *     });\n *\n *     // Output: { books: [...], price: [{...}, {...}] }\n *\n * @param {Object} facet options\n * @return {Aggregate} this\n * @see $facet https://www.mongodb.com/docs/manual/reference/operator/aggregation/facet/\n * @api public\n */\n\nAggregate.prototype.facet = function(options) {\n  return this.append({ $facet: options });\n};\n\n/**\n * Helper for [Atlas Text Search](https://www.mongodb.com/docs/atlas/atlas-search/tutorial/)'s\n * `$search` stage.\n *\n * #### Example:\n *\n *     const res = await Model.aggregate().\n *      search({\n *        text: {\n *          query: 'baseball',\n *          path: 'plot'\n *        }\n *      });\n *\n *     // Output: [{ plot: '...', title: '...' }]\n *\n * @param {Object} $search options\n * @return {Aggregate} this\n * @see $search https://www.mongodb.com/docs/atlas/atlas-search/tutorial/\n * @api public\n */\n\nAggregate.prototype.search = function(options) {\n  return this.append({ $search: options });\n};\n\n/**\n * Returns the current pipeline\n *\n * #### Example:\n *\n *     MyModel.aggregate().match({ test: 1 }).pipeline(); // [{ $match: { test: 1 } }]\n *\n * @return {Array} The current pipeline similar to the operation that will be executed\n * @api public\n */\n\nAggregate.prototype.pipeline = function() {\n  return this._pipeline;\n};\n\n/**\n * Executes the aggregate pipeline on the currently bound Model.\n *\n * #### Example:\n *     const result = await aggregate.exec();\n *\n * @return {Promise}\n * @api public\n */\n\nAggregate.prototype.exec = async function exec() {\n  if (!this._model) {\n    throw new Error('Aggregate not bound to any Model');\n  }\n  if (typeof arguments[0] === 'function') {\n    throw new MongooseError('Aggregate.prototype.exec() no longer accepts a callback');\n  }\n  const model = this._model;\n  const collection = this._model.collection;\n\n  applyGlobalMaxTimeMS(this.options, model);\n  applyGlobalDiskUse(this.options, model);\n\n  if (this.options && this.options.cursor) {\n    return new AggregationCursor(this);\n  }\n\n  prepareDiscriminatorPipeline(this._pipeline, this._model.schema);\n  stringifyFunctionOperators(this._pipeline);\n\n  await new Promise((resolve, reject) => {\n    model.hooks.execPre('aggregate', this, error => {\n      if (error) {\n        const _opts = { error: error };\n        return model.hooks.execPost('aggregate', this, [null], _opts, error => {\n          reject(error);\n        });\n      } else {\n        resolve();\n      }\n    });\n  });\n\n  if (!this._pipeline.length) {\n    throw new MongooseError('Aggregate has empty pipeline');\n  }\n\n  const options = clone(this.options || {});\n  let result;\n  try {\n    const cursor = await collection.aggregate(this._pipeline, options);\n    result = await cursor.toArray();\n  } catch (error) {\n    await new Promise((resolve, reject) => {\n      const _opts = { error: error };\n      model.hooks.execPost('aggregate', this, [null], _opts, (error) => {\n        if (error) {\n          return reject(error);\n        }\n\n        resolve();\n      });\n    });\n  }\n\n  const _opts = { error: null };\n  await new Promise((resolve, reject) => {\n    model.hooks.execPost('aggregate', this, [result], _opts, error => {\n      if (error) {\n        return reject(error);\n      }\n      return resolve();\n    });\n  });\n\n  return result;\n};\n\n/**\n * Provides a Promise-like `then` function, which will call `.exec` without a callback\n * Compatible with `await`.\n *\n * #### Example:\n *\n *     Model.aggregate(..).then(successCallback, errorCallback);\n *\n * @param {Function} [resolve] successCallback\n * @param {Function} [reject]  errorCallback\n * @return {Promise}\n */\nAggregate.prototype.then = function(resolve, reject) {\n  return this.exec().then(resolve, reject);\n};\n\n/**\n * Executes the aggregation returning a `Promise` which will be\n * resolved with either the doc(s) or rejected with the error.\n * Like [`.then()`](https://mongoosejs.com/docs/api/query.html#Query.prototype.then), but only takes a rejection handler.\n * Compatible with `await`.\n *\n * @param {Function} [reject]\n * @return {Promise}\n * @api public\n */\n\nAggregate.prototype.catch = function(reject) {\n  return this.exec().then(null, reject);\n};\n\n/**\n * Executes the aggregate returning a `Promise` which will be\n * resolved with `.finally()` chained.\n *\n * More about [Promise `finally()` in JavaScript](https://thecodebarbarian.com/using-promise-finally-in-node-js.html).\n *\n * @param {Function} [onFinally]\n * @return {Promise}\n * @api public\n */\n\nAggregate.prototype.finally = function(onFinally) {\n  return this.exec().finally(onFinally);\n};\n\n/**\n * Returns an asyncIterator for use with [`for/await/of` loops](https://thecodebarbarian.com/getting-started-with-async-iterators-in-node-js)\n * You do not need to call this function explicitly, the JavaScript runtime\n * will call it for you.\n *\n * #### Example:\n *\n *     const agg = Model.aggregate([{ $match: { age: { $gte: 25 } } }]);\n *     for await (const doc of agg) {\n *       console.log(doc.name);\n *     }\n *\n * Node.js 10.x supports async iterators natively without any flags. You can\n * enable async iterators in Node.js 8.x using the [`--harmony_async_iteration` flag](https://github.com/tc39/proposal-async-iteration/issues/117#issuecomment-346695187).\n *\n * **Note:** This function is not set if `Symbol.asyncIterator` is undefined. If\n * `Symbol.asyncIterator` is undefined, that means your Node.js version does not\n * support async iterators.\n *\n * @method [Symbol.asyncIterator]\n * @memberOf Aggregate\n * @instance\n * @api public\n */\n\nif (Symbol.asyncIterator != null) {\n  Aggregate.prototype[Symbol.asyncIterator] = function() {\n    return this.cursor({ useMongooseAggCursor: true }).transformNull()._transformForAsyncIterator();\n  };\n}\n\n/*!\n * Helpers\n */\n\n/**\n * Checks whether an object is likely a pipeline operator\n *\n * @param {Object} obj object to check\n * @return {Boolean}\n * @api private\n */\n\nfunction isOperator(obj) {\n  if (typeof obj !== 'object' || obj === null) {\n    return false;\n  }\n\n  const k = Object.keys(obj);\n\n  return k.length === 1 && k[0][0] === '$';\n}\n\n/**\n * Adds the appropriate `$match` pipeline step to the top of an aggregate's\n * pipeline, should it's model is a non-root discriminator type. This is\n * analogous to the `prepareDiscriminatorCriteria` function in `lib/query.js`.\n *\n * @param {Aggregate} aggregate Aggregate to prepare\n * @api private\n */\n\nAggregate._prepareDiscriminatorPipeline = prepareDiscriminatorPipeline;\n\n/*!\n * Exports\n */\n\nmodule.exports = Aggregate;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbW9uZ29vc2UvbGliL2FnZ3JlZ2F0ZS5qcyIsIm1hcHBpbmdzIjoiQUFBYTs7QUFFYjtBQUNBO0FBQ0E7O0FBRUEsMEJBQTBCLG1CQUFPLENBQUMsaUdBQTRCO0FBQzlELHNCQUFzQixtQkFBTyxDQUFDLHVGQUF1QjtBQUNyRCxjQUFjLG1CQUFPLENBQUMsMkRBQVM7QUFDL0IsUUFBUSwyQ0FBMkMsRUFBRSxtQkFBTyxDQUFDLCtHQUFtQztBQUNoRyxjQUFjLG1CQUFPLENBQUMsMkVBQWlCO0FBQ3ZDLDJCQUEyQixtQkFBTyxDQUFDLHFHQUE4QjtBQUNqRSxxQ0FBcUMsbUJBQU8sQ0FBQyw2SUFBa0Q7QUFDL0YsbUNBQW1DLG1CQUFPLENBQUMseUlBQWdEO0FBQzNGLGNBQWMsbUJBQU8sQ0FBQywyREFBUztBQUMvQjtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxZQUFZLGNBQWM7QUFDckMsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixVQUFVLE9BQU8sWUFBWTtBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLFVBQVUsbUNBQW1DO0FBQ3JFO0FBQ0Esd0JBQXdCLFVBQVUsZ0VBQWdFO0FBQ2xHO0FBQ0E7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQixXQUFXLE9BQU87QUFDbEI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE4QyxVQUFVLGNBQWM7QUFDdEUsc0NBQXNDO0FBQ3RDO0FB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QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLEdBQUc7O0FBRUg7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxVQUFVO0FBQ3JCLFdBQVcsVUFBVTtBQUNyQixZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxVQUFVO0FBQ3JCLFlBQVk7QUFDWjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFVBQVU7QUFDckIsWUFBWTtBQUNaO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDLFVBQVUsT0FBTyxjQUFjO0FBQ3JFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSx5QkFBeUIsNEJBQTRCO0FBQ3JEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixZQUFZO0FBQ1o7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFdBQVc7QUFDdEI7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9hcHAxLy4vbm9kZV9tb2R1bGVzL21vbmdvb3NlL2xpYi9hZ2dyZWdhdGUuanM/NjFhYiJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbi8qIVxuICogTW9kdWxlIGRlcGVuZGVuY2llc1xuICovXG5cbmNvbnN0IEFnZ3JlZ2F0aW9uQ3Vyc29yID0gcmVxdWlyZSgnLi9jdXJzb3IvYWdncmVnYXRpb25DdXJzb3InKTtcbmNvbnN0IE1vbmdvb3NlRXJyb3IgPSByZXF1aXJlKCcuL2Vycm9yL21vbmdvb3NlRXJyb3InKTtcbmNvbnN0IFF1ZXJ5ID0gcmVxdWlyZSgnLi9xdWVyeScpO1xuY29uc3QgeyBhcHBseUdsb2JhbE1heFRpbWVNUywgYXBwbHlHbG9iYWxEaXNrVXNlIH0gPSByZXF1aXJlKCcuL2hlbHBlcnMvcXVlcnkvYXBwbHlHbG9iYWxPcHRpb24nKTtcbmNvbnN0IGNsb25lID0gcmVxdWlyZSgnLi9oZWxwZXJzL2Nsb25lJyk7XG5jb25zdCBnZXRDb25zdHJ1Y3Rvck5hbWUgPSByZXF1aXJlKCcuL2hlbHBlcnMvZ2V0Q29uc3RydWN0b3JOYW1lJyk7XG5jb25zdCBwcmVwYXJlRGlzY3JpbWluYXRvclBpcGVsaW5lID0gcmVxdWlyZSgnLi9oZWxwZXJzL2FnZ3JlZ2F0ZS9wcmVwYXJlRGlzY3JpbWluYXRvclBpcGVsaW5lJyk7XG5jb25zdCBzdHJpbmdpZnlGdW5jdGlvbk9wZXJhdG9ycyA9IHJlcXVpcmUoJy4vaGVscGVycy9hZ2dyZWdhdGUvc3RyaW5naWZ5RnVuY3Rpb25PcGVyYXRvcnMnKTtcbmNvbnN0IHV0aWxzID0gcmVxdWlyZSgnLi91dGlscycpO1xuY29uc3QgcmVhZCA9IFF1ZXJ5LnByb3RvdHlwZS5yZWFkO1xuY29uc3QgcmVhZENvbmNlcm4gPSBRdWVyeS5wcm90b3R5cGUucmVhZENvbmNlcm47XG5cbmNvbnN0IHZhbGlkUmVkYWN0U3RyaW5nVmFsdWVzID0gbmV3IFNldChbJyQkREVTQ0VORCcsICckJFBSVU5FJywgJyQkS0VFUCddKTtcblxuLyoqXG4gKiBBZ2dyZWdhdGUgY29uc3RydWN0b3IgdXNlZCBmb3IgYnVpbGRpbmcgYWdncmVnYXRpb24gcGlwZWxpbmVzLiBEbyBub3RcbiAqIGluc3RhbnRpYXRlIHRoaXMgY2xhc3MgZGlyZWN0bHksIHVzZSBbTW9kZWwuYWdncmVnYXRlKCldKGh0dHBzOi8vbW9uZ29vc2Vqcy5jb20vZG9jcy9hcGkvbW9kZWwuaHRtbCNNb2RlbC5hZ2dyZWdhdGUoKSkgaW5zdGVhZC5cbiAqXG4gKiAjIyMjIEV4YW1wbGU6XG4gKlxuICogICAgIGNvbnN0IGFnZ3JlZ2F0ZSA9IE1vZGVsLmFnZ3JlZ2F0ZShbXG4gKiAgICAgICB7ICRwcm9qZWN0OiB7IGE6IDEsIGI6IDEgfSB9LFxuICogICAgICAgeyAkc2tpcDogNSB9XG4gKiAgICAgXSk7XG4gKlxuICogICAgIE1vZGVsLlxuICogICAgICAgYWdncmVnYXRlKFt7ICRtYXRjaDogeyBhZ2U6IHsgJGd0ZTogMjEgfX19XSkuXG4gKiAgICAgICB1bndpbmQoJ3RhZ3MnKS5cbiAqICAgICAgIGV4ZWMoKTtcbiAqXG4gKiAjIyMjIE5vdGU6XG4gKlxuICogLSBUaGUgZG9jdW1lbnRzIHJldHVybmVkIGFyZSBwbGFpbiBqYXZhc2NyaXB0IG9iamVjdHMsIG5vdCBtb25nb29zZSBkb2N1bWVudHMgKHNpbmNlIGFueSBzaGFwZSBvZiBkb2N1bWVudCBjYW4gYmUgcmV0dXJuZWQpLlxuICogLSBNb25nb29zZSBkb2VzICoqbm90KiogY2FzdCBwaXBlbGluZSBzdGFnZXMuIFRoZSBiZWxvdyB3aWxsICoqbm90Kiogd29yayB1bmxlc3MgYF9pZGAgaXMgYSBzdHJpbmcgaW4gdGhlIGRhdGFiYXNlXG4gKlxuICogICAgIG5ldyBBZ2dyZWdhdGUoW3sgJG1hdGNoOiB7IF9pZDogJzAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwYScgfSB9XSk7XG4gKiAgICAgLy8gRG8gdGhpcyBpbnN0ZWFkIHRvIGNhc3QgdG8gYW4gT2JqZWN0SWRcbiAqICAgICBuZXcgQWdncmVnYXRlKFt7ICRtYXRjaDogeyBfaWQ6IG5ldyBtb25nb29zZS5UeXBlcy5PYmplY3RJZCgnMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDBhJykgfSB9XSk7XG4gKlxuICogQHNlZSBNb25nb0RCIGh0dHBzOi8vd3d3Lm1vbmdvZGIuY29tL2RvY3MvbWFudWFsL2FwcGxpY2F0aW9ucy9hZ2dyZWdhdGlvbi9cbiAqIEBzZWUgZHJpdmVyIGh0dHBzOi8vbW9uZ29kYi5naXRodWIuaW8vbm9kZS1tb25nb2RiLW5hdGl2ZS80LjkvY2xhc3Nlcy9Db2xsZWN0aW9uLmh0bWwjYWdncmVnYXRlXG4gKiBAcGFyYW0ge0FycmF5fSBbcGlwZWxpbmVdIGFnZ3JlZ2F0aW9uIHBpcGVsaW5lIGFzIGFuIGFycmF5IG9mIG9iamVjdHNcbiAqIEBwYXJhbSB7TW9kZWx9IFttb2RlbF0gdGhlIG1vZGVsIHRvIHVzZSB3aXRoIHRoaXMgYWdncmVnYXRlLlxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5mdW5jdGlvbiBBZ2dyZWdhdGUocGlwZWxpbmUsIG1vZGVsKSB7XG4gIHRoaXMuX3BpcGVsaW5lID0gW107XG4gIHRoaXMuX21vZGVsID0gbW9kZWw7XG4gIHRoaXMub3B0aW9ucyA9IHt9O1xuXG4gIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAxICYmIEFycmF5LmlzQXJyYXkocGlwZWxpbmUpKSB7XG4gICAgdGhpcy5hcHBlbmQuYXBwbHkodGhpcywgcGlwZWxpbmUpO1xuICB9XG59XG5cbi8qKlxuICogQ29udGFpbnMgb3B0aW9ucyBwYXNzZWQgZG93biB0byB0aGUgW2FnZ3JlZ2F0ZSBjb21tYW5kXShodHRwczovL3d3dy5tb25nb2RiLmNvbS9kb2NzL21hbnVhbC9yZWZlcmVuY2UvY29tbWFuZC9hZ2dyZWdhdGUvKS5cbiAqIFN1cHBvcnRlZCBvcHRpb25zIGFyZTpcbiAqXG4gKiAtIFtgYWxsb3dEaXNrVXNlYF0oaHR0cHM6Ly9tb25nb29zZWpzLmNvbS9kb2NzL2FwaS9hZ2dyZWdhdGUuaHRtbCNBZ2dyZWdhdGUucHJvdG90eXBlLmFsbG93RGlza1VzZSgpKVxuICogLSBgYnlwYXNzRG9jdW1lbnRWYWxpZGF0aW9uYFxuICogLSBbYGNvbGxhdGlvbmBdKGh0dHBzOi8vbW9uZ29vc2Vqcy5jb20vZG9jcy9hcGkvYWdncmVnYXRlLmh0bWwjQWdncmVnYXRlLnByb3RvdHlwZS5jb2xsYXRpb24oKSlcbiAqIC0gYGNvbW1lbnRgXG4gKiAtIFtgY3Vyc29yYF0oaHR0cHM6Ly9tb25nb29zZWpzLmNvbS9kb2NzL2FwaS9hZ2dyZWdhdGUuaHRtbCNBZ2dyZWdhdGUucHJvdG90eXBlLmN1cnNvcigpKVxuICogLSBbYGV4cGxhaW5gXShodHRwczovL21vbmdvb3NlanMuY29tL2RvY3MvYXBpL2FnZ3JlZ2F0ZS5odG1sI0FnZ3JlZ2F0ZS5wcm90b3R5cGUuZXhwbGFpbigpKVxuICogLSBgZmllbGRzQXNSYXdgXG4gKiAtIFtgaGludGBdKGh0dHBzOi8vbW9uZ29vc2Vqcy5jb20vZG9jcy9hcGkvYWdncmVnYXRlLmh0bWwjQWdncmVnYXRlLnByb3RvdHlwZS5oaW50KCkpXG4gKiAtIGBsZXRgXG4gKiAtIGBtYXhUaW1lTVNgXG4gKiAtIGByYXdgXG4gKiAtIFtgcmVhZENvbmNlcm5gXShodHRwczovL21vbmdvb3NlanMuY29tL2RvY3MvYXBpL2FnZ3JlZ2F0ZS5odG1sI0FnZ3JlZ2F0ZS5wcm90b3R5cGUucmVhZENvbmNlcm4oKSlcbiAqIC0gYHJlYWRQcmVmZXJlbmNlYFxuICogLSBbYHNlc3Npb25gXShodHRwczovL21vbmdvb3NlanMuY29tL2RvY3MvYXBpL2FnZ3JlZ2F0ZS5odG1sI0FnZ3JlZ2F0ZS5wcm90b3R5cGUuc2Vzc2lvbigpKVxuICogLSBgd3JpdGVDb25jZXJuYFxuICpcbiAqIEBwcm9wZXJ0eSBvcHRpb25zXG4gKiBAbWVtYmVyT2YgQWdncmVnYXRlXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbkFnZ3JlZ2F0ZS5wcm90b3R5cGUub3B0aW9ucztcblxuLyoqXG4gKiBHZXQvc2V0IHRoZSBtb2RlbCB0aGF0IHRoaXMgYWdncmVnYXRpb24gd2lsbCBleGVjdXRlIG9uLlxuICpcbiAqICMjIyMgRXhhbXBsZTpcbiAqXG4gKiAgICAgY29uc3QgYWdncmVnYXRlID0gTXlNb2RlbC5hZ2dyZWdhdGUoW3sgJG1hdGNoOiB7IGFuc3dlcjogNDIgfSB9XSk7XG4gKiAgICAgYWdncmVnYXRlLm1vZGVsKCkgPT09IE15TW9kZWw7IC8vIHRydWVcbiAqXG4gKiAgICAgLy8gQ2hhbmdlIHRoZSBtb2RlbC4gVGhlcmUncyByYXJlbHkgYW55IHJlYXNvbiB0byBkbyB0aGlzLlxuICogICAgIGFnZ3JlZ2F0ZS5tb2RlbChTb21lT3RoZXJNb2RlbCk7XG4gKiAgICAgYWdncmVnYXRlLm1vZGVsKCkgPT09IFNvbWVPdGhlck1vZGVsOyAvLyB0cnVlXG4gKlxuICogQHBhcmFtIHtNb2RlbH0gW21vZGVsXSBTZXQgdGhlIG1vZGVsIGFzc29jaWF0ZWQgd2l0aCB0aGlzIGFnZ3JlZ2F0ZS4gSWYgbm90IHByb3ZpZGVkLCByZXR1cm5zIHRoZSBhbHJlYWR5IHN0b3JlZCBtb2RlbC5cbiAqIEByZXR1cm4ge01vZGVsfVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5BZ2dyZWdhdGUucHJvdG90eXBlLm1vZGVsID0gZnVuY3Rpb24obW9kZWwpIHtcbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDApIHtcbiAgICByZXR1cm4gdGhpcy5fbW9kZWw7XG4gIH1cblxuICB0aGlzLl9tb2RlbCA9IG1vZGVsO1xuICBpZiAobW9kZWwuc2NoZW1hICE9IG51bGwpIHtcbiAgICBpZiAodGhpcy5vcHRpb25zLnJlYWRQcmVmZXJlbmNlID09IG51bGwgJiZcbiAgICAgIG1vZGVsLnNjaGVtYS5vcHRpb25zLnJlYWQgIT0gbnVsbCkge1xuICAgICAgdGhpcy5vcHRpb25zLnJlYWRQcmVmZXJlbmNlID0gbW9kZWwuc2NoZW1hLm9wdGlvbnMucmVhZDtcbiAgICB9XG4gICAgaWYgKHRoaXMub3B0aW9ucy5jb2xsYXRpb24gPT0gbnVsbCAmJlxuICAgICAgbW9kZWwuc2NoZW1hLm9wdGlvbnMuY29sbGF0aW9uICE9IG51bGwpIHtcbiAgICAgIHRoaXMub3B0aW9ucy5jb2xsYXRpb24gPSBtb2RlbC5zY2hlbWEub3B0aW9ucy5jb2xsYXRpb247XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG1vZGVsO1xufTtcblxuLyoqXG4gKiBBcHBlbmRzIG5ldyBvcGVyYXRvcnMgdG8gdGhpcyBhZ2dyZWdhdGUgcGlwZWxpbmVcbiAqXG4gKiAjIyMjIEV4YW1wbGU6XG4gKlxuICogICAgIGFnZ3JlZ2F0ZS5hcHBlbmQoeyAkcHJvamVjdDogeyBmaWVsZDogMSB9fSwgeyAkbGltaXQ6IDIgfSk7XG4gKlxuICogICAgIC8vIG9yIHBhc3MgYW4gYXJyYXlcbiAqICAgICBjb25zdCBwaXBlbGluZSA9IFt7ICRtYXRjaDogeyBkYXc6ICdMb2dpYyBBdWRpbyBYJyB9fSBdO1xuICogICAgIGFnZ3JlZ2F0ZS5hcHBlbmQocGlwZWxpbmUpO1xuICpcbiAqIEBwYXJhbSB7Li4uT2JqZWN0fE9iamVjdFtdfSBvcHMgb3BlcmF0b3IocykgdG8gYXBwZW5kLiBDYW4gZWl0aGVyIGJlIGEgc3ByZWFkIG9mIG9iamVjdHMgb3IgYSBzaW5nbGUgcGFyYW1ldGVyIG9mIGEgb2JqZWN0IGFycmF5LlxuICogQHJldHVybiB7QWdncmVnYXRlfVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5BZ2dyZWdhdGUucHJvdG90eXBlLmFwcGVuZCA9IGZ1bmN0aW9uKCkge1xuICBjb25zdCBhcmdzID0gKGFyZ3VtZW50cy5sZW5ndGggPT09IDEgJiYgQXJyYXkuaXNBcnJheShhcmd1bWVudHNbMF0pKVxuICAgID8gYXJndW1lbnRzWzBdXG4gICAgOiBbLi4uYXJndW1lbnRzXTtcblxuICBpZiAoIWFyZ3MuZXZlcnkoaXNPcGVyYXRvcikpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0FyZ3VtZW50cyBtdXN0IGJlIGFnZ3JlZ2F0ZSBwaXBlbGluZSBvcGVyYXRvcnMnKTtcbiAgfVxuXG4gIHRoaXMuX3BpcGVsaW5lID0gdGhpcy5fcGlwZWxpbmUuY29uY2F0KGFyZ3MpO1xuXG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBBcHBlbmRzIGEgbmV3ICRhZGRGaWVsZHMgb3BlcmF0b3IgdG8gdGhpcyBhZ2dyZWdhdGUgcGlwZWxpbmUuXG4gKiBSZXF1aXJlcyBNb25nb0RCIHYzLjQrIHRvIHdvcmtcbiAqXG4gKiAjIyMjIEV4YW1wbGU6XG4gKlxuICogICAgIC8vIGFkZGluZyBuZXcgZmllbGRzIGJhc2VkIG9uIGV4aXN0aW5nIGZpZWxkc1xuICogICAgIGFnZ3JlZ2F0ZS5hZGRGaWVsZHMoe1xuICogICAgICAgICBuZXdGaWVsZDogJyRiLm5lc3RlZCdcbiAqICAgICAgICwgcGx1c1RlbjogeyAkYWRkOiBbJyR2YWwnLCAxMF19XG4gKiAgICAgICAsIHN1Yjoge1xuICogICAgICAgICAgICBuYW1lOiAnJGEnXG4gKiAgICAgICAgIH1cbiAqICAgICB9KVxuICpcbiAqICAgICAvLyBldGNcbiAqICAgICBhZ2dyZWdhdGUuYWRkRmllbGRzKHsgc2FsYXJ5X2s6IHsgJGRpdmlkZTogWyBcIiRzYWxhcnlcIiwgMTAwMCBdIH0gfSk7XG4gKlxuICogQHBhcmFtIHtPYmplY3R9IGFyZyBmaWVsZCBzcGVjaWZpY2F0aW9uXG4gKiBAc2VlICRhZGRGaWVsZHMgaHR0cHM6Ly93d3cubW9uZ29kYi5jb20vZG9jcy9tYW51YWwvcmVmZXJlbmNlL29wZXJhdG9yL2FnZ3JlZ2F0aW9uL2FkZEZpZWxkcy9cbiAqIEByZXR1cm4ge0FnZ3JlZ2F0ZX1cbiAqIEBhcGkgcHVibGljXG4gKi9cbkFnZ3JlZ2F0ZS5wcm90b3R5cGUuYWRkRmllbGRzID0gZnVuY3Rpb24oYXJnKSB7XG4gIGlmICh0eXBlb2YgYXJnICE9PSAnb2JqZWN0JyB8fCBhcmcgPT09IG51bGwgfHwgQXJyYXkuaXNBcnJheShhcmcpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIGFkZEZpZWxkcygpIGFyZ3VtZW50LiBNdXN0IGJlIGFuIG9iamVjdCcpO1xuICB9XG4gIHJldHVybiB0aGlzLmFwcGVuZCh7ICRhZGRGaWVsZHM6IE9iamVjdC5hc3NpZ24oe30sIGFyZykgfSk7XG59O1xuXG4vKipcbiAqIEFwcGVuZHMgYSBuZXcgJHByb2plY3Qgb3BlcmF0b3IgdG8gdGhpcyBhZ2dyZWdhdGUgcGlwZWxpbmUuXG4gKlxuICogTW9uZ29vc2UgcXVlcnkgW3NlbGVjdGlvbiBzeW50YXhdKGh0dHBzOi8vbW9uZ29vc2Vqcy5jb20vZG9jcy9hcGkvcXVlcnkuaHRtbCNRdWVyeS5wcm90b3R5cGUuc2VsZWN0KCkpIGlzIGFsc28gc3VwcG9ydGVkLlxuICpcbiAqICMjIyMgRXhhbXBsZTpcbiAqXG4gKiAgICAgLy8gaW5jbHVkZSBhLCBpbmNsdWRlIGIsIGV4Y2x1ZGUgX2lkXG4gKiAgICAgYWdncmVnYXRlLnByb2plY3QoXCJhIGIgLV9pZFwiKTtcbiAqXG4gKiAgICAgLy8gb3IgeW91IG1heSB1c2Ugb2JqZWN0IG5vdGF0aW9uLCB1c2VmdWwgd2hlblxuICogICAgIC8vIHlvdSBoYXZlIGtleXMgYWxyZWFkeSBwcmVmaXhlZCB3aXRoIGEgXCItXCJcbiAqICAgICBhZ2dyZWdhdGUucHJvamVjdCh7YTogMSwgYjogMSwgX2lkOiAwfSk7XG4gKlxuICogICAgIC8vIHJlc2hhcGluZyBkb2N1bWVudHNcbiAqICAgICBhZ2dyZWdhdGUucHJvamVjdCh7XG4gKiAgICAgICAgIG5ld0ZpZWxkOiAnJGIubmVzdGVkJ1xuICogICAgICAgLCBwbHVzVGVuOiB7ICRhZGQ6IFsnJHZhbCcsIDEwXX1cbiAqICAgICAgICwgc3ViOiB7XG4gKiAgICAgICAgICAgIG5hbWU6ICckYSdcbiAqICAgICAgICAgfVxuICogICAgIH0pXG4gKlxuICogICAgIC8vIGV0Y1xuICogICAgIGFnZ3JlZ2F0ZS5wcm9qZWN0KHsgc2FsYXJ5X2s6IHsgJGRpdmlkZTogWyBcIiRzYWxhcnlcIiwgMTAwMCBdIH0gfSk7XG4gKlxuICogQHBhcmFtIHtPYmplY3R8U3RyaW5nfSBhcmcgZmllbGQgc3BlY2lmaWNhdGlvblxuICogQHNlZSBwcm9qZWN0aW9uIGh0dHBzOi8vd3d3Lm1vbmdvZGIuY29tL2RvY3MvbWFudWFsL3JlZmVyZW5jZS9hZ2dyZWdhdGlvbi9wcm9qZWN0L1xuICogQHJldHVybiB7QWdncmVnYXRlfVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5BZ2dyZWdhdGUucHJvdG90eXBlLnByb2plY3QgPSBmdW5jdGlvbihhcmcpIHtcbiAgY29uc3QgZmllbGRzID0ge307XG5cbiAgaWYgKHR5cGVvZiBhcmcgPT09ICdvYmplY3QnICYmICFBcnJheS5pc0FycmF5KGFyZykpIHtcbiAgICBPYmplY3Qua2V5cyhhcmcpLmZvckVhY2goZnVuY3Rpb24oZmllbGQpIHtcbiAgICAgIGZpZWxkc1tmaWVsZF0gPSBhcmdbZmllbGRdO1xuICAgIH0pO1xuICB9IGVsc2UgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDEgJiYgdHlwZW9mIGFyZyA9PT0gJ3N0cmluZycpIHtcbiAgICBhcmcuc3BsaXQoL1xccysvKS5mb3JFYWNoKGZ1bmN0aW9uKGZpZWxkKSB7XG4gICAgICBpZiAoIWZpZWxkKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGluY2x1ZGUgPSBmaWVsZFswXSA9PT0gJy0nID8gMCA6IDE7XG4gICAgICBpZiAoaW5jbHVkZSA9PT0gMCkge1xuICAgICAgICBmaWVsZCA9IGZpZWxkLnN1YnN0cmluZygxKTtcbiAgICAgIH1cbiAgICAgIGZpZWxkc1tmaWVsZF0gPSBpbmNsdWRlO1xuICAgIH0pO1xuICB9IGVsc2Uge1xuICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBwcm9qZWN0KCkgYXJndW1lbnQuIE11c3QgYmUgc3RyaW5nIG9yIG9iamVjdCcpO1xuICB9XG5cbiAgcmV0dXJuIHRoaXMuYXBwZW5kKHsgJHByb2plY3Q6IGZpZWxkcyB9KTtcbn07XG5cbi8qKlxuICogQXBwZW5kcyBhIG5ldyBjdXN0b20gJGdyb3VwIG9wZXJhdG9yIHRvIHRoaXMgYWdncmVnYXRlIHBpcGVsaW5lLlxuICpcbiAqICMjIyMgRXhhbXBsZTpcbiAqXG4gKiAgICAgYWdncmVnYXRlLmdyb3VwKHsgX2lkOiBcIiRkZXBhcnRtZW50XCIgfSk7XG4gKlxuICogQHNlZSAkZ3JvdXAgaHR0cHM6Ly93d3cubW9uZ29kYi5jb20vZG9jcy9tYW51YWwvcmVmZXJlbmNlL2FnZ3JlZ2F0aW9uL2dyb3VwL1xuICogQG1ldGhvZCBncm91cFxuICogQG1lbWJlck9mIEFnZ3JlZ2F0ZVxuICogQGluc3RhbmNlXG4gKiBAcGFyYW0ge09iamVjdH0gYXJnICRncm91cCBvcGVyYXRvciBjb250ZW50c1xuICogQHJldHVybiB7QWdncmVnYXRlfVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG4vKipcbiAqIEFwcGVuZHMgYSBuZXcgY3VzdG9tICRtYXRjaCBvcGVyYXRvciB0byB0aGlzIGFnZ3JlZ2F0ZSBwaXBlbGluZS5cbiAqXG4gKiAjIyMjIEV4YW1wbGU6XG4gKlxuICogICAgIGFnZ3JlZ2F0ZS5tYXRjaCh7IGRlcGFydG1lbnQ6IHsgJGluOiBbIFwic2FsZXNcIiwgXCJlbmdpbmVlcmluZ1wiIF0gfSB9KTtcbiAqXG4gKiBAc2VlICRtYXRjaCBodHRwczovL3d3dy5tb25nb2RiLmNvbS9kb2NzL21hbnVhbC9yZWZlcmVuY2UvYWdncmVnYXRpb24vbWF0Y2gvXG4gKiBAbWV0aG9kIG1hdGNoXG4gKiBAbWVtYmVyT2YgQWdncmVnYXRlXG4gKiBAaW5zdGFuY2VcbiAqIEBwYXJhbSB7T2JqZWN0fSBhcmcgJG1hdGNoIG9wZXJhdG9yIGNvbnRlbnRzXG4gKiBAcmV0dXJuIHtBZ2dyZWdhdGV9XG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbi8qKlxuICogQXBwZW5kcyBhIG5ldyAkc2tpcCBvcGVyYXRvciB0byB0aGlzIGFnZ3JlZ2F0ZSBwaXBlbGluZS5cbiAqXG4gKiAjIyMjIEV4YW1wbGU6XG4gKlxuICogICAgIGFnZ3JlZ2F0ZS5za2lwKDEwKTtcbiAqXG4gKiBAc2VlICRza2lwIGh0dHBzOi8vd3d3Lm1vbmdvZGIuY29tL2RvY3MvbWFudWFsL3JlZmVyZW5jZS9hZ2dyZWdhdGlvbi9za2lwL1xuICogQG1ldGhvZCBza2lwXG4gKiBAbWVtYmVyT2YgQWdncmVnYXRlXG4gKiBAaW5zdGFuY2VcbiAqIEBwYXJhbSB7TnVtYmVyfSBudW0gbnVtYmVyIG9mIHJlY29yZHMgdG8gc2tpcCBiZWZvcmUgbmV4dCBzdGFnZVxuICogQHJldHVybiB7QWdncmVnYXRlfVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG4vKipcbiAqIEFwcGVuZHMgYSBuZXcgJGxpbWl0IG9wZXJhdG9yIHRvIHRoaXMgYWdncmVnYXRlIHBpcGVsaW5lLlxuICpcbiAqICMjIyMgRXhhbXBsZTpcbiAqXG4gKiAgICAgYWdncmVnYXRlLmxpbWl0KDEwKTtcbiAqXG4gKiBAc2VlICRsaW1pdCBodHRwczovL3d3dy5tb25nb2RiLmNvbS9kb2NzL21hbnVhbC9yZWZlcmVuY2UvYWdncmVnYXRpb24vbGltaXQvXG4gKiBAbWV0aG9kIGxpbWl0XG4gKiBAbWVtYmVyT2YgQWdncmVnYXRlXG4gKiBAaW5zdGFuY2VcbiAqIEBwYXJhbSB7TnVtYmVyfSBudW0gbWF4aW11bSBudW1iZXIgb2YgcmVjb3JkcyB0byBwYXNzIHRvIHRoZSBuZXh0IHN0YWdlXG4gKiBAcmV0dXJuIHtBZ2dyZWdhdGV9XG4gKiBAYXBpIHB1YmxpY1xuICovXG5cblxuLyoqXG4gKiBBcHBlbmRzIGEgbmV3ICRkZW5zaWZ5IG9wZXJhdG9yIHRvIHRoaXMgYWdncmVnYXRlIHBpcGVsaW5lLlxuICpcbiAqICMjIyMgRXhhbXBsZTpcbiAqXG4gKiAgICAgIGFnZ3JlZ2F0ZS5kZW5zaWZ5KHtcbiAqICAgICAgICBmaWVsZDogJ3RpbWVzdGFtcCcsXG4gKiAgICAgICAgcmFuZ2U6IHtcbiAqICAgICAgICAgIHN0ZXA6IDEsXG4gKiAgICAgICAgICB1bml0OiAnaG91cicsXG4gKiAgICAgICAgICBib3VuZHM6IFtuZXcgRGF0ZSgnMjAyMS0wNS0xOFQwMDowMDowMC4wMDBaJyksIG5ldyBEYXRlKCcyMDIxLTA1LTE4VDA4OjAwOjAwLjAwMFonKV1cbiAqICAgICAgICB9XG4gKiAgICAgIH0pO1xuICpcbiAqIEBzZWUgJGRlbnNpZnkgaHR0cHM6Ly93d3cubW9uZ29kYi5jb20vZG9jcy9tYW51YWwvcmVmZXJlbmNlL29wZXJhdG9yL2FnZ3JlZ2F0aW9uL2RlbnNpZnkvXG4gKiBAbWV0aG9kIGRlbnNpZnlcbiAqIEBtZW1iZXJPZiBBZ2dyZWdhdGVcbiAqIEBpbnN0YW5jZVxuICogQHBhcmFtIHtPYmplY3R9IGFyZyAkZGVuc2lmeSBvcGVyYXRvciBjb250ZW50c1xuICogQHJldHVybiB7QWdncmVnYXRlfVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG4vKipcbiAqIEFwcGVuZHMgYSBuZXcgJGZpbGwgb3BlcmF0b3IgdG8gdGhpcyBhZ2dyZWdhdGUgcGlwZWxpbmUuXG4gKlxuICogIyMjIyBFeGFtcGxlOlxuICpcbiAqICAgICAgYWdncmVnYXRlLmZpbGwoe1xuICogICAgICAgIG91dHB1dDoge1xuICogICAgICAgICAgYm9vdHNTb2xkOiB7IHZhbHVlOiAwIH0sXG4gKiAgICAgICAgICBzYW5kYWxzU29sZDogeyB2YWx1ZTogMCB9LFxuICogICAgICAgICAgc25lYWtlcnNTb2xkOiB7IHZhbHVlOiAwIH1cbiAqICAgICAgICB9XG4gKiAgICAgIH0pO1xuICpcbiAqIEBzZWUgJGZpbGwgaHR0cHM6Ly93d3cubW9uZ29kYi5jb20vZG9jcy9tYW51YWwvcmVmZXJlbmNlL29wZXJhdG9yL2FnZ3JlZ2F0aW9uL2ZpbGwvXG4gKiBAbWV0aG9kIGZpbGxcbiAqIEBtZW1iZXJPZiBBZ2dyZWdhdGVcbiAqIEBpbnN0YW5jZVxuICogQHBhcmFtIHtPYmplY3R9IGFyZyAkZmlsbCBvcGVyYXRvciBjb250ZW50c1xuICogQHJldHVybiB7QWdncmVnYXRlfVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG4vKipcbiAqIEFwcGVuZHMgYSBuZXcgJGdlb05lYXIgb3BlcmF0b3IgdG8gdGhpcyBhZ2dyZWdhdGUgcGlwZWxpbmUuXG4gKlxuICogIyMjIyBOb3RlOlxuICpcbiAqICoqTVVTVCoqIGJlIHVzZWQgYXMgdGhlIGZpcnN0IG9wZXJhdG9yIGluIHRoZSBwaXBlbGluZS5cbiAqXG4gKiAjIyMjIEV4YW1wbGU6XG4gKlxuICogICAgIGFnZ3JlZ2F0ZS5uZWFyKHtcbiAqICAgICAgIG5lYXI6IHsgdHlwZTogJ1BvaW50JywgY29vcmRpbmF0ZXM6IFs0MC43MjQsIC03My45OTddIH0sXG4gKiAgICAgICBkaXN0YW5jZUZpZWxkOiBcImRpc3QuY2FsY3VsYXRlZFwiLCAvLyByZXF1aXJlZFxuICogICAgICAgbWF4RGlzdGFuY2U6IDAuMDA4LFxuICogICAgICAgcXVlcnk6IHsgdHlwZTogXCJwdWJsaWNcIiB9LFxuICogICAgICAgaW5jbHVkZUxvY3M6IFwiZGlzdC5sb2NhdGlvblwiLFxuICogICAgICAgc3BoZXJpY2FsOiB0cnVlLFxuICogICAgIH0pO1xuICpcbiAqIEBzZWUgJGdlb05lYXIgaHR0cHM6Ly93d3cubW9uZ29kYi5jb20vZG9jcy9tYW51YWwvcmVmZXJlbmNlL2FnZ3JlZ2F0aW9uL2dlb05lYXIvXG4gKiBAbWV0aG9kIG5lYXJcbiAqIEBtZW1iZXJPZiBBZ2dyZWdhdGVcbiAqIEBpbnN0YW5jZVxuICogQHBhcmFtIHtPYmplY3R9IGFyZ1xuICogQHJldHVybiB7QWdncmVnYXRlfVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5BZ2dyZWdhdGUucHJvdG90eXBlLm5lYXIgPSBmdW5jdGlvbihhcmcpIHtcbiAgY29uc3Qgb3AgPSB7fTtcbiAgb3AuJGdlb05lYXIgPSBhcmc7XG4gIHJldHVybiB0aGlzLmFwcGVuZChvcCk7XG59O1xuXG4vKiFcbiAqIGRlZmluZSBtZXRob2RzXG4gKi9cblxuJ2dyb3VwIG1hdGNoIHNraXAgbGltaXQgb3V0IGRlbnNpZnkgZmlsbCcuc3BsaXQoJyAnKS5mb3JFYWNoKGZ1bmN0aW9uKCRvcGVyYXRvcikge1xuICBBZ2dyZWdhdGUucHJvdG90eXBlWyRvcGVyYXRvcl0gPSBmdW5jdGlvbihhcmcpIHtcbiAgICBjb25zdCBvcCA9IHt9O1xuICAgIG9wWyckJyArICRvcGVyYXRvcl0gPSBhcmc7XG4gICAgcmV0dXJuIHRoaXMuYXBwZW5kKG9wKTtcbiAgfTtcbn0pO1xuXG4vKipcbiAqIEFwcGVuZHMgbmV3IGN1c3RvbSAkdW53aW5kIG9wZXJhdG9yKHMpIHRvIHRoaXMgYWdncmVnYXRlIHBpcGVsaW5lLlxuICpcbiAqIE5vdGUgdGhhdCB0aGUgYCR1bndpbmRgIG9wZXJhdG9yIHJlcXVpcmVzIHRoZSBwYXRoIG5hbWUgdG8gc3RhcnQgd2l0aCAnJCcuXG4gKiBNb25nb29zZSB3aWxsIHByZXBlbmQgJyQnIGlmIHRoZSBzcGVjaWZpZWQgZmllbGQgZG9lc24ndCBzdGFydCAnJCcuXG4gKlxuICogIyMjIyBFeGFtcGxlOlxuICpcbiAqICAgICBhZ2dyZWdhdGUudW53aW5kKFwidGFnc1wiKTtcbiAqICAgICBhZ2dyZWdhdGUudW53aW5kKFwiYVwiLCBcImJcIiwgXCJjXCIpO1xuICogICAgIGFnZ3JlZ2F0ZS51bndpbmQoeyBwYXRoOiAnJHRhZ3MnLCBwcmVzZXJ2ZU51bGxBbmRFbXB0eUFycmF5czogdHJ1ZSB9KTtcbiAqXG4gKiBAc2VlICR1bndpbmQgaHR0cHM6Ly93d3cubW9uZ29kYi5jb20vZG9jcy9tYW51YWwvcmVmZXJlbmNlL2FnZ3JlZ2F0aW9uL3Vud2luZC9cbiAqIEBwYXJhbSB7U3RyaW5nfE9iamVjdHxTdHJpbmdbXXxPYmplY3RbXX0gZmllbGRzIHRoZSBmaWVsZChzKSB0byB1bndpbmQsIGVpdGhlciBhcyBmaWVsZCBuYW1lcyBvciBhcyBbb2JqZWN0cyB3aXRoIG9wdGlvbnNdKGh0dHBzOi8vd3d3Lm1vbmdvZGIuY29tL2RvY3MvbWFudWFsL3JlZmVyZW5jZS9vcGVyYXRvci9hZ2dyZWdhdGlvbi91bndpbmQvI2RvY3VtZW50LW9wZXJhbmQtd2l0aC1vcHRpb25zKS4gSWYgcGFzc2luZyBhIHN0cmluZywgcHJlZml4aW5nIHRoZSBmaWVsZCBuYW1lIHdpdGggJyQnIGlzIG9wdGlvbmFsLiBJZiBwYXNzaW5nIGFuIG9iamVjdCwgYHBhdGhgIG11c3Qgc3RhcnQgd2l0aCAnJCcuXG4gKiBAcmV0dXJuIHtBZ2dyZWdhdGV9XG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbkFnZ3JlZ2F0ZS5wcm90b3R5cGUudW53aW5kID0gZnVuY3Rpb24oKSB7XG4gIGNvbnN0IGFyZ3MgPSBbLi4uYXJndW1lbnRzXTtcblxuICBjb25zdCByZXMgPSBbXTtcbiAgZm9yIChjb25zdCBhcmcgb2YgYXJncykge1xuICAgIGlmIChhcmcgJiYgdHlwZW9mIGFyZyA9PT0gJ29iamVjdCcpIHtcbiAgICAgIHJlcy5wdXNoKHsgJHVud2luZDogYXJnIH0pO1xuICAgIH0gZWxzZSBpZiAodHlwZW9mIGFyZyA9PT0gJ3N0cmluZycpIHtcbiAgICAgIHJlcy5wdXNoKHtcbiAgICAgICAgJHVud2luZDogKGFyZ1swXSA9PT0gJyQnKSA/IGFyZyA6ICckJyArIGFyZ1xuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBhcmcgXCInICsgYXJnICsgJ1wiIHRvIHVud2luZCgpLCAnICtcbiAgICAgICAgJ211c3QgYmUgc3RyaW5nIG9yIG9iamVjdCcpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiB0aGlzLmFwcGVuZC5hcHBseSh0aGlzLCByZXMpO1xufTtcblxuLyoqXG4gKiBBcHBlbmRzIGEgbmV3ICRyZXBsYWNlUm9vdCBvcGVyYXRvciB0byB0aGlzIGFnZ3JlZ2F0ZSBwaXBlbGluZS5cbiAqXG4gKiBOb3RlIHRoYXQgdGhlIGAkcmVwbGFjZVJvb3RgIG9wZXJhdG9yIHJlcXVpcmVzIGZpZWxkIHN0cmluZ3MgdG8gc3RhcnQgd2l0aCAnJCcuXG4gKiBJZiB5b3UgYXJlIHBhc3NpbmcgaW4gYSBzdHJpbmcgTW9uZ29vc2Ugd2lsbCBwcmVwZW5kICckJyBpZiB0aGUgc3BlY2lmaWVkIGZpZWxkIGRvZXNuJ3Qgc3RhcnQgJyQnLlxuICogSWYgeW91IGFyZSBwYXNzaW5nIGluIGFuIG9iamVjdCB0aGUgc3RyaW5ncyBpbiB5b3VyIGV4cHJlc3Npb24gd2lsbCBub3QgYmUgYWx0ZXJlZC5cbiAqXG4gKiAjIyMjIEV4YW1wbGU6XG4gKlxuICogICAgIGFnZ3JlZ2F0ZS5yZXBsYWNlUm9vdChcInVzZXJcIik7XG4gKlxuICogICAgIGFnZ3JlZ2F0ZS5yZXBsYWNlUm9vdCh7IHg6IHsgJGNvbmNhdDogWyckdGhpcycsICckdGhhdCddIH0gfSk7XG4gKlxuICogQHNlZSAkcmVwbGFjZVJvb3QgaHR0cHM6Ly93d3cubW9uZ29kYi5jb20vZG9jcy9tYW51YWwvcmVmZXJlbmNlL29wZXJhdG9yL2FnZ3JlZ2F0aW9uL3JlcGxhY2VSb290XG4gKiBAcGFyYW0ge1N0cmluZ3xPYmplY3R9IG5ld1Jvb3QgdGhlIGZpZWxkIG9yIGRvY3VtZW50IHdoaWNoIHdpbGwgYmVjb21lIHRoZSBuZXcgcm9vdCBkb2N1bWVudFxuICogQHJldHVybiB7QWdncmVnYXRlfVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5BZ2dyZWdhdGUucHJvdG90eXBlLnJlcGxhY2VSb290ID0gZnVuY3Rpb24obmV3Um9vdCkge1xuICBsZXQgcmV0O1xuXG4gIGlmICh0eXBlb2YgbmV3Um9vdCA9PT0gJ3N0cmluZycpIHtcbiAgICByZXQgPSBuZXdSb290LnN0YXJ0c1dpdGgoJyQnKSA/IG5ld1Jvb3QgOiAnJCcgKyBuZXdSb290O1xuICB9IGVsc2Uge1xuICAgIHJldCA9IG5ld1Jvb3Q7XG4gIH1cblxuICByZXR1cm4gdGhpcy5hcHBlbmQoe1xuICAgICRyZXBsYWNlUm9vdDoge1xuICAgICAgbmV3Um9vdDogcmV0XG4gICAgfVxuICB9KTtcbn07XG5cbi8qKlxuICogQXBwZW5kcyBhIG5ldyAkY291bnQgb3BlcmF0b3IgdG8gdGhpcyBhZ2dyZWdhdGUgcGlwZWxpbmUuXG4gKlxuICogIyMjIyBFeGFtcGxlOlxuICpcbiAqICAgICBhZ2dyZWdhdGUuY291bnQoXCJ1c2VyQ291bnRcIik7XG4gKlxuICogQHNlZSAkY291bnQgaHR0cHM6Ly93d3cubW9uZ29kYi5jb20vZG9jcy9tYW51YWwvcmVmZXJlbmNlL29wZXJhdG9yL2FnZ3JlZ2F0aW9uL2NvdW50XG4gKiBAcGFyYW0ge1N0cmluZ30gZmllbGROYW1lIFRoZSBuYW1lIG9mIHRoZSBvdXRwdXQgZmllbGQgd2hpY2ggaGFzIHRoZSBjb3VudCBhcyBpdHMgdmFsdWUuIEl0IG11c3QgYmUgYSBub24tZW1wdHkgc3RyaW5nLCBtdXN0IG5vdCBzdGFydCB3aXRoICQgYW5kIG11c3Qgbm90IGNvbnRhaW4gdGhlIC4gY2hhcmFjdGVyLlxuICogQHJldHVybiB7QWdncmVnYXRlfVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5BZ2dyZWdhdGUucHJvdG90eXBlLmNvdW50ID0gZnVuY3Rpb24oZmllbGROYW1lKSB7XG4gIHJldHVybiB0aGlzLmFwcGVuZCh7ICRjb3VudDogZmllbGROYW1lIH0pO1xufTtcblxuLyoqXG4gKiBBcHBlbmRzIGEgbmV3ICRzb3J0QnlDb3VudCBvcGVyYXRvciB0byB0aGlzIGFnZ3JlZ2F0ZSBwaXBlbGluZS4gQWNjZXB0cyBlaXRoZXIgYSBzdHJpbmcgZmllbGQgbmFtZVxuICogb3IgYSBwaXBlbGluZSBvYmplY3QuXG4gKlxuICogTm90ZSB0aGF0IHRoZSBgJHNvcnRCeUNvdW50YCBvcGVyYXRvciByZXF1aXJlcyB0aGUgbmV3IHJvb3QgdG8gc3RhcnQgd2l0aCAnJCcuXG4gKiBNb25nb29zZSB3aWxsIHByZXBlbmQgJyQnIGlmIHRoZSBzcGVjaWZpZWQgZmllbGQgbmFtZSBkb2Vzbid0IHN0YXJ0IHdpdGggJyQnLlxuICpcbiAqICMjIyMgRXhhbXBsZTpcbiAqXG4gKiAgICAgYWdncmVnYXRlLnNvcnRCeUNvdW50KCd1c2VycycpO1xuICogICAgIGFnZ3JlZ2F0ZS5zb3J0QnlDb3VudCh7ICRtZXJnZU9iamVjdHM6IFsgXCIkZW1wbG95ZWVcIiwgXCIkYnVzaW5lc3NcIiBdIH0pXG4gKlxuICogQHNlZSAkc29ydEJ5Q291bnQgaHR0cHM6Ly93d3cubW9uZ29kYi5jb20vZG9jcy9tYW51YWwvcmVmZXJlbmNlL29wZXJhdG9yL2FnZ3JlZ2F0aW9uL3NvcnRCeUNvdW50L1xuICogQHBhcmFtIHtPYmplY3R8U3RyaW5nfSBhcmdcbiAqIEByZXR1cm4ge0FnZ3JlZ2F0ZX0gdGhpc1xuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5BZ2dyZWdhdGUucHJvdG90eXBlLnNvcnRCeUNvdW50ID0gZnVuY3Rpb24oYXJnKSB7XG4gIGlmIChhcmcgJiYgdHlwZW9mIGFyZyA9PT0gJ29iamVjdCcpIHtcbiAgICByZXR1cm4gdGhpcy5hcHBlbmQoeyAkc29ydEJ5Q291bnQ6IGFyZyB9KTtcbiAgfSBlbHNlIGlmICh0eXBlb2YgYXJnID09PSAnc3RyaW5nJykge1xuICAgIHJldHVybiB0aGlzLmFwcGVuZCh7XG4gICAgICAkc29ydEJ5Q291bnQ6IChhcmdbMF0gPT09ICckJykgPyBhcmcgOiAnJCcgKyBhcmdcbiAgICB9KTtcbiAgfSBlbHNlIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdJbnZhbGlkIGFyZyBcIicgKyBhcmcgKyAnXCIgdG8gc29ydEJ5Q291bnQoKSwgJyArXG4gICAgICAnbXVzdCBiZSBzdHJpbmcgb3Igb2JqZWN0Jyk7XG4gIH1cbn07XG5cbi8qKlxuICogQXBwZW5kcyBuZXcgY3VzdG9tICRsb29rdXAgb3BlcmF0b3IgdG8gdGhpcyBhZ2dyZWdhdGUgcGlwZWxpbmUuXG4gKlxuICogIyMjIyBFeGFtcGxlOlxuICpcbiAqICAgICBhZ2dyZWdhdGUubG9va3VwKHsgZnJvbTogJ3VzZXJzJywgbG9jYWxGaWVsZDogJ3VzZXJJZCcsIGZvcmVpZ25GaWVsZDogJ19pZCcsIGFzOiAndXNlcnMnIH0pO1xuICpcbiAqIEBzZWUgJGxvb2t1cCBodHRwczovL3d3dy5tb25nb2RiLmNvbS9kb2NzL21hbnVhbC9yZWZlcmVuY2Uvb3BlcmF0b3IvYWdncmVnYXRpb24vbG9va3VwLyNwaXBlLl9TX2xvb2t1cFxuICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgdG8gJGxvb2t1cCBhcyBkZXNjcmliZWQgaW4gdGhlIGFib3ZlIGxpbmtcbiAqIEByZXR1cm4ge0FnZ3JlZ2F0ZX1cbiAqIEBhcGkgcHVibGljXG4gKi9cblxuQWdncmVnYXRlLnByb3RvdHlwZS5sb29rdXAgPSBmdW5jdGlvbihvcHRpb25zKSB7XG4gIHJldHVybiB0aGlzLmFwcGVuZCh7ICRsb29rdXA6IG9wdGlvbnMgfSk7XG59O1xuXG4vKipcbiAqIEFwcGVuZHMgbmV3IGN1c3RvbSAkZ3JhcGhMb29rdXAgb3BlcmF0b3IocykgdG8gdGhpcyBhZ2dyZWdhdGUgcGlwZWxpbmUsIHBlcmZvcm1pbmcgYSByZWN1cnNpdmUgc2VhcmNoIG9uIGEgY29sbGVjdGlvbi5cbiAqXG4gKiBOb3RlIHRoYXQgZ3JhcGhMb29rdXAgY2FuIG9ubHkgY29uc3VtZSBhdCBtb3N0IDEwME1CIG9mIG1lbW9yeSwgYW5kIGRvZXMgbm90IGFsbG93IGRpc2sgdXNlIGV2ZW4gaWYgYHsgYWxsb3dEaXNrVXNlOiB0cnVlIH1gIGlzIHNwZWNpZmllZC5cbiAqXG4gKiAjIyMjIEV4YW1wbGU6XG4gKlxuICogICAgICAvLyBTdXBwb3NlIHdlIGhhdmUgYSBjb2xsZWN0aW9uIG9mIGNvdXJzZXMsIHdoZXJlIGEgZG9jdW1lbnQgbWlnaHQgbG9vayBsaWtlIGB7IF9pZDogMCwgbmFtZTogJ0NhbGN1bHVzJywgcHJlcmVxdWlzaXRlOiAnVHJpZ29ub21ldHJ5J31gIGFuZCBgeyBfaWQ6IDAsIG5hbWU6ICdUcmlnb25vbWV0cnknLCBwcmVyZXF1aXNpdGU6ICdBbGdlYnJhJyB9YFxuICogICAgICBhZ2dyZWdhdGUuZ3JhcGhMb29rdXAoeyBmcm9tOiAnY291cnNlcycsIHN0YXJ0V2l0aDogJyRwcmVyZXF1aXNpdGUnLCBjb25uZWN0RnJvbUZpZWxkOiAncHJlcmVxdWlzaXRlJywgY29ubmVjdFRvRmllbGQ6ICduYW1lJywgYXM6ICdwcmVyZXF1aXNpdGVzJywgbWF4RGVwdGg6IDMgfSkgLy8gdGhpcyB3aWxsIHJlY3Vyc2l2ZWx5IHNlYXJjaCB0aGUgJ2NvdXJzZXMnIGNvbGxlY3Rpb24gdXAgdG8gMyBwcmVyZXF1aXNpdGVzXG4gKlxuICogQHNlZSAkZ3JhcGhMb29rdXAgaHR0cHM6Ly93d3cubW9uZ29kYi5jb20vZG9jcy9tYW51YWwvcmVmZXJlbmNlL29wZXJhdG9yL2FnZ3JlZ2F0aW9uL2dyYXBoTG9va3VwLyNwaXBlLl9TX2dyYXBoTG9va3VwXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyB0byAkZ3JhcGhMb29rdXAgYXMgZGVzY3JpYmVkIGluIHRoZSBhYm92ZSBsaW5rXG4gKiBAcmV0dXJuIHtBZ2dyZWdhdGV9XG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbkFnZ3JlZ2F0ZS5wcm90b3R5cGUuZ3JhcGhMb29rdXAgPSBmdW5jdGlvbihvcHRpb25zKSB7XG4gIGNvbnN0IGNsb25lT3B0aW9ucyA9IHt9O1xuICBpZiAob3B0aW9ucykge1xuICAgIGlmICghdXRpbHMuaXNPYmplY3Qob3B0aW9ucykpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0ludmFsaWQgZ3JhcGhMb29rdXAoKSBhcmd1bWVudC4gTXVzdCBiZSBhbiBvYmplY3QuJyk7XG4gICAgfVxuXG4gICAgdXRpbHMubWVyZ2VDbG9uZShjbG9uZU9wdGlvbnMsIG9wdGlvbnMpO1xuICAgIGNvbnN0IHN0YXJ0V2l0aCA9IGNsb25lT3B0aW9ucy5zdGFydFdpdGg7XG5cbiAgICBpZiAoc3RhcnRXaXRoICYmIHR5cGVvZiBzdGFydFdpdGggPT09ICdzdHJpbmcnKSB7XG4gICAgICBjbG9uZU9wdGlvbnMuc3RhcnRXaXRoID0gY2xvbmVPcHRpb25zLnN0YXJ0V2l0aC5zdGFydHNXaXRoKCckJykgP1xuICAgICAgICBjbG9uZU9wdGlvbnMuc3RhcnRXaXRoIDpcbiAgICAgICAgJyQnICsgY2xvbmVPcHRpb25zLnN0YXJ0V2l0aDtcbiAgICB9XG5cbiAgfVxuICByZXR1cm4gdGhpcy5hcHBlbmQoeyAkZ3JhcGhMb29rdXA6IGNsb25lT3B0aW9ucyB9KTtcbn07XG5cbi8qKlxuICogQXBwZW5kcyBuZXcgY3VzdG9tICRzYW1wbGUgb3BlcmF0b3IgdG8gdGhpcyBhZ2dyZWdhdGUgcGlwZWxpbmUuXG4gKlxuICogIyMjIyBFeGFtcGxlOlxuICpcbiAqICAgICBhZ2dyZWdhdGUuc2FtcGxlKDMpOyAvLyBBZGQgYSBwaXBlbGluZSB0aGF0IHBpY2tzIDMgcmFuZG9tIGRvY3VtZW50c1xuICpcbiAqIEBzZWUgJHNhbXBsZSBodHRwczovL3d3dy5tb25nb2RiLmNvbS9kb2NzL21hbnVhbC9yZWZlcmVuY2Uvb3BlcmF0b3IvYWdncmVnYXRpb24vc2FtcGxlLyNwaXBlLl9TX3NhbXBsZVxuICogQHBhcmFtIHtOdW1iZXJ9IHNpemUgbnVtYmVyIG9mIHJhbmRvbSBkb2N1bWVudHMgdG8gcGlja1xuICogQHJldHVybiB7QWdncmVnYXRlfVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5BZ2dyZWdhdGUucHJvdG90eXBlLnNhbXBsZSA9IGZ1bmN0aW9uKHNpemUpIHtcbiAgcmV0dXJuIHRoaXMuYXBwZW5kKHsgJHNhbXBsZTogeyBzaXplOiBzaXplIH0gfSk7XG59O1xuXG4vKipcbiAqIEFwcGVuZHMgYSBuZXcgJHNvcnQgb3BlcmF0b3IgdG8gdGhpcyBhZ2dyZWdhdGUgcGlwZWxpbmUuXG4gKlxuICogSWYgYW4gb2JqZWN0IGlzIHBhc3NlZCwgdmFsdWVzIGFsbG93ZWQgYXJlIGBhc2NgLCBgZGVzY2AsIGBhc2NlbmRpbmdgLCBgZGVzY2VuZGluZ2AsIGAxYCwgYW5kIGAtMWAuXG4gKlxuICogSWYgYSBzdHJpbmcgaXMgcGFzc2VkLCBpdCBtdXN0IGJlIGEgc3BhY2UgZGVsaW1pdGVkIGxpc3Qgb2YgcGF0aCBuYW1lcy4gVGhlIHNvcnQgb3JkZXIgb2YgZWFjaCBwYXRoIGlzIGFzY2VuZGluZyB1bmxlc3MgdGhlIHBhdGggbmFtZSBpcyBwcmVmaXhlZCB3aXRoIGAtYCB3aGljaCB3aWxsIGJlIHRyZWF0ZWQgYXMgZGVzY2VuZGluZy5cbiAqXG4gKiAjIyMjIEV4YW1wbGU6XG4gKlxuICogICAgIC8vIHRoZXNlIGFyZSBlcXVpdmFsZW50XG4gKiAgICAgYWdncmVnYXRlLnNvcnQoeyBmaWVsZDogJ2FzYycsIHRlc3Q6IC0xIH0pO1xuICogICAgIGFnZ3JlZ2F0ZS5zb3J0KCdmaWVsZCAtdGVzdCcpO1xuICpcbiAqIEBzZWUgJHNvcnQgaHR0cHM6Ly93d3cubW9uZ29kYi5jb20vZG9jcy9tYW51YWwvcmVmZXJlbmNlL2FnZ3JlZ2F0aW9uL3NvcnQvXG4gKiBAcGFyYW0ge09iamVjdHxTdHJpbmd9IGFyZ1xuICogQHJldHVybiB7QWdncmVnYXRlfSB0aGlzXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbkFnZ3JlZ2F0ZS5wcm90b3R5cGUuc29ydCA9IGZ1bmN0aW9uKGFyZykge1xuICAvLyBUT0RPIHJlZmFjdG9yIHRvIHJldXNlIHRoZSBxdWVyeSBidWlsZGVyIGxvZ2ljXG5cbiAgY29uc3Qgc29ydCA9IHt9O1xuXG4gIGlmIChnZXRDb25zdHJ1Y3Rvck5hbWUoYXJnKSA9PT0gJ09iamVjdCcpIHtcbiAgICBjb25zdCBkZXNjID0gWydkZXNjJywgJ2Rlc2NlbmRpbmcnLCAtMV07XG4gICAgT2JqZWN0LmtleXMoYXJnKS5mb3JFYWNoKGZ1bmN0aW9uKGZpZWxkKSB7XG4gICAgICAvLyBJZiBzb3J0aW5nIGJ5IHRleHQgc2NvcmUsIHNraXAgY29lcmNpbmcgaW50byAxLy0xXG4gICAgICBpZiAoYXJnW2ZpZWxkXSBpbnN0YW5jZW9mIE9iamVjdCAmJiBhcmdbZmllbGRdLiRtZXRhKSB7XG4gICAgICAgIHNvcnRbZmllbGRdID0gYXJnW2ZpZWxkXTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgc29ydFtmaWVsZF0gPSBkZXNjLmluZGV4T2YoYXJnW2ZpZWxkXSkgPT09IC0xID8gMSA6IC0xO1xuICAgIH0pO1xuICB9IGVsc2UgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDEgJiYgdHlwZW9mIGFyZyA9PT0gJ3N0cmluZycpIHtcbiAgICBhcmcuc3BsaXQoL1xccysvKS5mb3JFYWNoKGZ1bmN0aW9uKGZpZWxkKSB7XG4gICAgICBpZiAoIWZpZWxkKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGFzY2VuZCA9IGZpZWxkWzBdID09PSAnLScgPyAtMSA6IDE7XG4gICAgICBpZiAoYXNjZW5kID09PSAtMSkge1xuICAgICAgICBmaWVsZCA9IGZpZWxkLnN1YnN0cmluZygxKTtcbiAgICAgIH1cbiAgICAgIHNvcnRbZmllbGRdID0gYXNjZW5kO1xuICAgIH0pO1xuICB9IGVsc2Uge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0ludmFsaWQgc29ydCgpIGFyZ3VtZW50LiBNdXN0IGJlIGEgc3RyaW5nIG9yIG9iamVjdC4nKTtcbiAgfVxuXG4gIHJldHVybiB0aGlzLmFwcGVuZCh7ICRzb3J0OiBzb3J0IH0pO1xufTtcblxuLyoqXG4gKiBBcHBlbmRzIG5ldyAkdW5pb25XaXRoIG9wZXJhdG9yIHRvIHRoaXMgYWdncmVnYXRlIHBpcGVsaW5lLlxuICpcbiAqICMjIyMgRXhhbXBsZTpcbiAqXG4gKiAgICAgYWdncmVnYXRlLnVuaW9uV2l0aCh7IGNvbGw6ICd1c2VycycsIHBpcGVsaW5lOiBbIHsgJG1hdGNoOiB7IF9pZDogMSB9IH0gXSB9KTtcbiAqXG4gKiBAc2VlICR1bmlvbldpdGggaHR0cHM6Ly93d3cubW9uZ29kYi5jb20vZG9jcy9tYW51YWwvcmVmZXJlbmNlL29wZXJhdG9yL2FnZ3JlZ2F0aW9uL3VuaW9uV2l0aFxuICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgdG8gJHVuaW9uV2l0aCBxdWVyeSBhcyBkZXNjcmliZWQgaW4gdGhlIGFib3ZlIGxpbmtcbiAqIEByZXR1cm4ge0FnZ3JlZ2F0ZX1cbiAqIEBhcGkgcHVibGljXG4gKi9cblxuQWdncmVnYXRlLnByb3RvdHlwZS51bmlvbldpdGggPSBmdW5jdGlvbihvcHRpb25zKSB7XG4gIHJldHVybiB0aGlzLmFwcGVuZCh7ICR1bmlvbldpdGg6IG9wdGlvbnMgfSk7XG59O1xuXG5cbi8qKlxuICogU2V0cyB0aGUgcmVhZFByZWZlcmVuY2Ugb3B0aW9uIGZvciB0aGUgYWdncmVnYXRpb24gcXVlcnkuXG4gKlxuICogIyMjIyBFeGFtcGxlOlxuICpcbiAqICAgICBhd2FpdCBNb2RlbC5hZ2dyZWdhdGUocGlwZWxpbmUpLnJlYWQoJ3ByaW1hcnlQcmVmZXJyZWQnKTtcbiAqXG4gKiBAcGFyYW0ge1N0cmluZ3xSZWFkUHJlZmVyZW5jZX0gcHJlZiBvbmUgb2YgdGhlIGxpc3RlZCBwcmVmZXJlbmNlIG9wdGlvbnMgb3IgdGhlaXIgYWxpYXNlc1xuICogQHBhcmFtIHtBcnJheX0gW3RhZ3NdIG9wdGlvbmFsIHRhZ3MgZm9yIHRoaXMgcXVlcnkuIERFUFJFQ0FURURcbiAqIEByZXR1cm4ge0FnZ3JlZ2F0ZX0gdGhpc1xuICogQGFwaSBwdWJsaWNcbiAqIEBzZWUgbW9uZ29kYiBodHRwczovL3d3dy5tb25nb2RiLmNvbS9kb2NzL21hbnVhbC9hcHBsaWNhdGlvbnMvcmVwbGljYXRpb24vI3JlYWQtcHJlZmVyZW5jZVxuICovXG5cbkFnZ3JlZ2F0ZS5wcm90b3R5cGUucmVhZCA9IGZ1bmN0aW9uKHByZWYsIHRhZ3MpIHtcbiAgcmVhZC5jYWxsKHRoaXMsIHByZWYsIHRhZ3MpO1xuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogU2V0cyB0aGUgcmVhZENvbmNlcm4gbGV2ZWwgZm9yIHRoZSBhZ2dyZWdhdGlvbiBxdWVyeS5cbiAqXG4gKiAjIyMjIEV4YW1wbGU6XG4gKlxuICogICAgIGF3YWl0IE1vZGVsLmFnZ3JlZ2F0ZShwaXBlbGluZSkucmVhZENvbmNlcm4oJ21ham9yaXR5Jyk7XG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IGxldmVsIG9uZSBvZiB0aGUgbGlzdGVkIHJlYWQgY29uY2VybiBsZXZlbCBvciB0aGVpciBhbGlhc2VzXG4gKiBAc2VlIG1vbmdvZGIgaHR0cHM6Ly93d3cubW9uZ29kYi5jb20vZG9jcy9tYW51YWwvcmVmZXJlbmNlL3JlYWQtY29uY2Vybi9cbiAqIEByZXR1cm4ge0FnZ3JlZ2F0ZX0gdGhpc1xuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5BZ2dyZWdhdGUucHJvdG90eXBlLnJlYWRDb25jZXJuID0gZnVuY3Rpb24obGV2ZWwpIHtcbiAgcmVhZENvbmNlcm4uY2FsbCh0aGlzLCBsZXZlbCk7XG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBBcHBlbmRzIGEgbmV3ICRyZWRhY3Qgb3BlcmF0b3IgdG8gdGhpcyBhZ2dyZWdhdGUgcGlwZWxpbmUuXG4gKlxuICogSWYgMyBhcmd1bWVudHMgYXJlIHN1cHBsaWVkLCBNb25nb29zZSB3aWxsIHdyYXAgdGhlbSB3aXRoIGlmLXRoZW4tZWxzZSBvZiAkY29uZCBvcGVyYXRvciByZXNwZWN0aXZlbHlcbiAqIElmIGB0aGVuRXhwcmAgb3IgYGVsc2VFeHByYCBpcyBzdHJpbmcsIG1ha2Ugc3VyZSBpdCBzdGFydHMgd2l0aCAkJCwgbGlrZSBgJCRERVNDRU5EYCwgYCQkUFJVTkVgIG9yIGAkJEtFRVBgLlxuICpcbiAqICMjIyMgRXhhbXBsZTpcbiAqXG4gKiAgICAgYXdhaXQgTW9kZWwuYWdncmVnYXRlKHBpcGVsaW5lKS5yZWRhY3Qoe1xuICogICAgICAgJGNvbmQ6IHtcbiAqICAgICAgICAgaWY6IHsgJGVxOiBbICckbGV2ZWwnLCA1IF0gfSxcbiAqICAgICAgICAgdGhlbjogJyQkUFJVTkUnLFxuICogICAgICAgICBlbHNlOiAnJCRERVNDRU5EJ1xuICogICAgICAgfVxuICogICAgIH0pO1xuICpcbiAqICAgICAvLyAkcmVkYWN0IG9mdGVuIGNvbWVzIHdpdGggJGNvbmQgb3BlcmF0b3IsIHlvdSBjYW4gYWxzbyB1c2UgdGhlIGZvbGxvd2luZyBzeW50YXggcHJvdmlkZWQgYnkgbW9uZ29vc2VcbiAqICAgICBhd2FpdCBNb2RlbC5hZ2dyZWdhdGUocGlwZWxpbmUpLnJlZGFjdCh7ICRlcTogWyAnJGxldmVsJywgNSBdIH0sICckJFBSVU5FJywgJyQkREVTQ0VORCcpO1xuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBleHByZXNzaW9uIHJlZGFjdCBvcHRpb25zIG9yIGNvbmRpdGlvbmFsIGV4cHJlc3Npb25cbiAqIEBwYXJhbSB7U3RyaW5nfE9iamVjdH0gW3RoZW5FeHByXSB0cnVlIGNhc2UgZm9yIHRoZSBjb25kaXRpb25cbiAqIEBwYXJhbSB7U3RyaW5nfE9iamVjdH0gW2Vsc2VFeHByXSBmYWxzZSBjYXNlIGZvciB0aGUgY29uZGl0aW9uXG4gKiBAcmV0dXJuIHtBZ2dyZWdhdGV9IHRoaXNcbiAqIEBzZWUgJHJlZGFjdCBodHRwczovL3d3dy5tb25nb2RiLmNvbS9kb2NzL21hbnVhbC9yZWZlcmVuY2Uvb3BlcmF0b3IvYWdncmVnYXRpb24vcmVkYWN0L1xuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5BZ2dyZWdhdGUucHJvdG90eXBlLnJlZGFjdCA9IGZ1bmN0aW9uKGV4cHJlc3Npb24sIHRoZW5FeHByLCBlbHNlRXhwcikge1xuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMykge1xuICAgIGlmICgodHlwZW9mIHRoZW5FeHByID09PSAnc3RyaW5nJyAmJiAhdmFsaWRSZWRhY3RTdHJpbmdWYWx1ZXMuaGFzKHRoZW5FeHByKSkgfHxcbiAgICAgICh0eXBlb2YgZWxzZUV4cHIgPT09ICdzdHJpbmcnICYmICF2YWxpZFJlZGFjdFN0cmluZ1ZhbHVlcy5oYXMoZWxzZUV4cHIpKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdJZiB0aGVuRXhwciBvciBlbHNlRXhwciBpcyBzdHJpbmcsIGl0IG11c3QgYmUgZWl0aGVyICQkREVTQ0VORCwgJCRQUlVORSBvciAkJEtFRVAnKTtcbiAgICB9XG5cbiAgICBleHByZXNzaW9uID0ge1xuICAgICAgJGNvbmQ6IHtcbiAgICAgICAgaWY6IGV4cHJlc3Npb24sXG4gICAgICAgIHRoZW46IHRoZW5FeHByLFxuICAgICAgICBlbHNlOiBlbHNlRXhwclxuICAgICAgfVxuICAgIH07XG4gIH0gZWxzZSBpZiAoYXJndW1lbnRzLmxlbmd0aCAhPT0gMSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0ludmFsaWQgYXJndW1lbnRzJyk7XG4gIH1cblxuICByZXR1cm4gdGhpcy5hcHBlbmQoeyAkcmVkYWN0OiBleHByZXNzaW9uIH0pO1xufTtcblxuLyoqXG4gKiBFeGVjdXRlIHRoZSBhZ2dyZWdhdGlvbiB3aXRoIGV4cGxhaW5cbiAqXG4gKiAjIyMjIEV4YW1wbGU6XG4gKlxuICogICAgIE1vZGVsLmFnZ3JlZ2F0ZSguLikuZXhwbGFpbigpXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IFt2ZXJib3NpdHldXG4gKiBAcmV0dXJuIHtQcm9taXNlfVxuICovXG5cbkFnZ3JlZ2F0ZS5wcm90b3R5cGUuZXhwbGFpbiA9IGFzeW5jIGZ1bmN0aW9uIGV4cGxhaW4odmVyYm9zaXR5KSB7XG4gIGlmICh0eXBlb2YgdmVyYm9zaXR5ID09PSAnZnVuY3Rpb24nIHx8IHR5cGVvZiBhcmd1bWVudHNbMV0gPT09ICdmdW5jdGlvbicpIHtcbiAgICB0aHJvdyBuZXcgTW9uZ29vc2VFcnJvcignQWdncmVnYXRlLnByb3RvdHlwZS5leHBsYWluKCkgbm8gbG9uZ2VyIGFjY2VwdHMgYSBjYWxsYmFjaycpO1xuICB9XG4gIGNvbnN0IG1vZGVsID0gdGhpcy5fbW9kZWw7XG5cbiAgaWYgKCF0aGlzLl9waXBlbGluZS5sZW5ndGgpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0FnZ3JlZ2F0ZSBoYXMgZW1wdHkgcGlwZWxpbmUnKTtcbiAgfVxuXG4gIHByZXBhcmVEaXNjcmltaW5hdG9yUGlwZWxpbmUodGhpcy5fcGlwZWxpbmUsIHRoaXMuX21vZGVsLnNjaGVtYSk7XG5cbiAgYXdhaXQgbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgIG1vZGVsLmhvb2tzLmV4ZWNQcmUoJ2FnZ3JlZ2F0ZScsIHRoaXMsIGVycm9yID0+IHtcbiAgICAgIGlmIChlcnJvcikge1xuICAgICAgICBjb25zdCBfb3B0cyA9IHsgZXJyb3I6IGVycm9yIH07XG4gICAgICAgIHJldHVybiBtb2RlbC5ob29rcy5leGVjUG9zdCgnYWdncmVnYXRlJywgdGhpcywgW251bGxdLCBfb3B0cywgZXJyb3IgPT4ge1xuICAgICAgICAgIHJlamVjdChlcnJvcik7XG4gICAgICAgIH0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmVzb2x2ZSgpO1xuICAgICAgfVxuICAgIH0pO1xuICB9KTtcblxuICBjb25zdCBjdXJzb3IgPSBtb2RlbC5jb2xsZWN0aW9uLmFnZ3JlZ2F0ZSh0aGlzLl9waXBlbGluZSwgdGhpcy5vcHRpb25zKTtcblxuICBpZiAodmVyYm9zaXR5ID09IG51bGwpIHtcbiAgICB2ZXJib3NpdHkgPSB0cnVlO1xuICB9XG5cbiAgbGV0IHJlc3VsdCA9IG51bGw7XG4gIHRyeSB7XG4gICAgcmVzdWx0ID0gYXdhaXQgY3Vyc29yLmV4cGxhaW4odmVyYm9zaXR5KTtcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICBhd2FpdCBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICBjb25zdCBfb3B0cyA9IHsgZXJyb3I6IGVycm9yIH07XG4gICAgICBtb2RlbC5ob29rcy5leGVjUG9zdCgnYWdncmVnYXRlJywgdGhpcywgW251bGxdLCBfb3B0cywgZXJyb3IgPT4ge1xuICAgICAgICBpZiAoZXJyb3IpIHtcbiAgICAgICAgICByZXR1cm4gcmVqZWN0KGVycm9yKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzb2x2ZSgpO1xuICAgICAgfSk7XG4gICAgfSk7XG4gIH1cblxuICBjb25zdCBfb3B0cyA9IHsgZXJyb3I6IG51bGwgfTtcbiAgYXdhaXQgbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgIG1vZGVsLmhvb2tzLmV4ZWNQb3N0KCdhZ2dyZWdhdGUnLCB0aGlzLCBbcmVzdWx0XSwgX29wdHMsIGVycm9yID0+IHtcbiAgICAgIGlmIChlcnJvcikge1xuICAgICAgICByZXR1cm4gcmVqZWN0KGVycm9yKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiByZXNvbHZlKCk7XG4gICAgfSk7XG4gIH0pO1xuXG4gIHJldHVybiByZXN1bHQ7XG59O1xuXG4vKipcbiAqIFNldHMgdGhlIGFsbG93RGlza1VzZSBvcHRpb24gZm9yIHRoZSBhZ2dyZWdhdGlvbiBxdWVyeVxuICpcbiAqICMjIyMgRXhhbXBsZTpcbiAqXG4gKiAgICAgYXdhaXQgTW9kZWwuYWdncmVnYXRlKFt7ICRtYXRjaDogeyBmb286ICdiYXInIH0gfV0pLmFsbG93RGlza1VzZSh0cnVlKTtcbiAqXG4gKiBAcGFyYW0ge0Jvb2xlYW59IHZhbHVlIFNob3VsZCB0ZWxsIHNlcnZlciBpdCBjYW4gdXNlIGhhcmQgZHJpdmUgdG8gc3RvcmUgZGF0YSBkdXJpbmcgYWdncmVnYXRpb24uXG4gKiBAcmV0dXJuIHtBZ2dyZWdhdGV9IHRoaXNcbiAqIEBzZWUgbW9uZ29kYiBodHRwczovL3d3dy5tb25nb2RiLmNvbS9kb2NzL21hbnVhbC9yZWZlcmVuY2UvY29tbWFuZC9hZ2dyZWdhdGUvXG4gKi9cblxuQWdncmVnYXRlLnByb3RvdHlwZS5hbGxvd0Rpc2tVc2UgPSBmdW5jdGlvbih2YWx1ZSkge1xuICB0aGlzLm9wdGlvbnMuYWxsb3dEaXNrVXNlID0gdmFsdWU7XG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBTZXRzIHRoZSBoaW50IG9wdGlvbiBmb3IgdGhlIGFnZ3JlZ2F0aW9uIHF1ZXJ5XG4gKlxuICogIyMjIyBFeGFtcGxlOlxuICpcbiAqICAgICBNb2RlbC5hZ2dyZWdhdGUoLi4pLmhpbnQoeyBxdHk6IDEsIGNhdGVnb3J5OiAxIH0pLmV4ZWMoKTtcbiAqXG4gKiBAcGFyYW0ge09iamVjdHxTdHJpbmd9IHZhbHVlIGEgaGludCBvYmplY3Qgb3IgdGhlIGluZGV4IG5hbWVcbiAqIEByZXR1cm4ge0FnZ3JlZ2F0ZX0gdGhpc1xuICogQHNlZSBtb25nb2RiIGh0dHBzOi8vd3d3Lm1vbmdvZGIuY29tL2RvY3MvbWFudWFsL3JlZmVyZW5jZS9jb21tYW5kL2FnZ3JlZ2F0ZS9cbiAqL1xuXG5BZ2dyZWdhdGUucHJvdG90eXBlLmhpbnQgPSBmdW5jdGlvbih2YWx1ZSkge1xuICB0aGlzLm9wdGlvbnMuaGludCA9IHZhbHVlO1xuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogU2V0cyB0aGUgc2Vzc2lvbiBmb3IgdGhpcyBhZ2dyZWdhdGlvbi4gVXNlZnVsIGZvciBbdHJhbnNhY3Rpb25zXShodHRwczovL21vbmdvb3NlanMuY29tL2RvY3MvdHJhbnNhY3Rpb25zLmh0bWwpLlxuICpcbiAqICMjIyMgRXhhbXBsZTpcbiAqXG4gKiAgICAgY29uc3Qgc2Vzc2lvbiA9IGF3YWl0IE1vZGVsLnN0YXJ0U2Vzc2lvbigpO1xuICogICAgIGF3YWl0IE1vZGVsLmFnZ3JlZ2F0ZSguLikuc2Vzc2lvbihzZXNzaW9uKTtcbiAqXG4gKiBAcGFyYW0ge0NsaWVudFNlc3Npb259IHNlc3Npb25cbiAqIEByZXR1cm4ge0FnZ3JlZ2F0ZX0gdGhpc1xuICogQHNlZSBtb25nb2RiIGh0dHBzOi8vd3d3Lm1vbmdvZGIuY29tL2RvY3MvbWFudWFsL3JlZmVyZW5jZS9jb21tYW5kL2FnZ3JlZ2F0ZS9cbiAqL1xuXG5BZ2dyZWdhdGUucHJvdG90eXBlLnNlc3Npb24gPSBmdW5jdGlvbihzZXNzaW9uKSB7XG4gIGlmIChzZXNzaW9uID09IG51bGwpIHtcbiAgICBkZWxldGUgdGhpcy5vcHRpb25zLnNlc3Npb247XG4gIH0gZWxzZSB7XG4gICAgdGhpcy5vcHRpb25zLnNlc3Npb24gPSBzZXNzaW9uO1xuICB9XG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBMZXRzIHlvdSBzZXQgYXJiaXRyYXJ5IG9wdGlvbnMsIGZvciBtaWRkbGV3YXJlIG9yIHBsdWdpbnMuXG4gKlxuICogIyMjIyBFeGFtcGxlOlxuICpcbiAqICAgICBjb25zdCBhZ2cgPSBNb2RlbC5hZ2dyZWdhdGUoLi4pLm9wdGlvbih7IGFsbG93RGlza1VzZTogdHJ1ZSB9KTsgLy8gU2V0IHRoZSBgYWxsb3dEaXNrVXNlYCBvcHRpb25cbiAqICAgICBhZ2cub3B0aW9uczsgLy8gYHsgYWxsb3dEaXNrVXNlOiB0cnVlIH1gXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMga2V5cyB0byBtZXJnZSBpbnRvIGN1cnJlbnQgb3B0aW9uc1xuICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLm1heFRpbWVNU10gbnVtYmVyIGxpbWl0cyB0aGUgdGltZSB0aGlzIGFnZ3JlZ2F0aW9uIHdpbGwgcnVuLCBzZWUgW01vbmdvREIgZG9jcyBvbiBgbWF4VGltZU1TYF0oaHR0cHM6Ly93d3cubW9uZ29kYi5jb20vZG9jcy9tYW51YWwvcmVmZXJlbmNlL29wZXJhdG9yL21ldGEvbWF4VGltZU1TLylcbiAqIEBwYXJhbSB7Qm9vbGVhbn0gW29wdGlvbnMuYWxsb3dEaXNrVXNlXSBib29sZWFuIGlmIHRydWUsIHRoZSBNb25nb0RCIHNlcnZlciB3aWxsIHVzZSB0aGUgaGFyZCBkcml2ZSB0byBzdG9yZSBkYXRhIGR1cmluZyB0aGlzIGFnZ3JlZ2F0aW9uXG4gKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnMuY29sbGF0aW9uXSBvYmplY3Qgc2VlIFtgQWdncmVnYXRlLnByb3RvdHlwZS5jb2xsYXRpb24oKWBdKGh0dHBzOi8vbW9uZ29vc2Vqcy5jb20vZG9jcy9hcGkvYWdncmVnYXRlLmh0bWwjQWdncmVnYXRlLnByb3RvdHlwZS5jb2xsYXRpb24oKSlcbiAqIEBwYXJhbSB7Q2xpZW50U2Vzc2lvbn0gW29wdGlvbnMuc2Vzc2lvbl0gQ2xpZW50U2Vzc2lvbiBzZWUgW2BBZ2dyZWdhdGUucHJvdG90eXBlLnNlc3Npb24oKWBdKGh0dHBzOi8vbW9uZ29vc2Vqcy5jb20vZG9jcy9hcGkvYWdncmVnYXRlLmh0bWwjQWdncmVnYXRlLnByb3RvdHlwZS5zZXNzaW9uKCkpXG4gKiBAc2VlIG1vbmdvZGIgaHR0cHM6Ly93d3cubW9uZ29kYi5jb20vZG9jcy9tYW51YWwvcmVmZXJlbmNlL2NvbW1hbmQvYWdncmVnYXRlL1xuICogQHJldHVybiB7QWdncmVnYXRlfSB0aGlzXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbkFnZ3JlZ2F0ZS5wcm90b3R5cGUub3B0aW9uID0gZnVuY3Rpb24odmFsdWUpIHtcbiAgZm9yIChjb25zdCBrZXkgaW4gdmFsdWUpIHtcbiAgICB0aGlzLm9wdGlvbnNba2V5XSA9IHZhbHVlW2tleV07XG4gIH1cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIFNldHMgdGhlIGBjdXJzb3JgIG9wdGlvbiBhbmQgZXhlY3V0ZXMgdGhpcyBhZ2dyZWdhdGlvbiwgcmV0dXJuaW5nIGFuIGFnZ3JlZ2F0aW9uIGN1cnNvci5cbiAqIEN1cnNvcnMgYXJlIHVzZWZ1bCBpZiB5b3Ugd2FudCB0byBwcm9jZXNzIHRoZSByZXN1bHRzIG9mIHRoZSBhZ2dyZWdhdGlvbiBvbmUtYXQtYS10aW1lXG4gKiBiZWNhdXNlIHRoZSBhZ2dyZWdhdGlvbiByZXN1bHQgaXMgdG9vIGJpZyB0byBmaXQgaW50byBtZW1vcnkuXG4gKlxuICogIyMjIyBFeGFtcGxlOlxuICpcbiAqICAgICBjb25zdCBjdXJzb3IgPSBNb2RlbC5hZ2dyZWdhdGUoLi4pLmN1cnNvcih7IGJhdGNoU2l6ZTogMTAwMCB9KTtcbiAqICAgICBjdXJzb3IuZWFjaEFzeW5jKGZ1bmN0aW9uKGRvYywgaSkge1xuICogICAgICAgLy8gdXNlIGRvY1xuICogICAgIH0pO1xuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zXG4gKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMuYmF0Y2hTaXplXSBzZXQgdGhlIGN1cnNvciBiYXRjaCBzaXplXG4gKiBAcGFyYW0ge0Jvb2xlYW59IFtvcHRpb25zLnVzZU1vbmdvb3NlQWdnQ3Vyc29yXSB1c2UgZXhwZXJpbWVudGFsIG1vbmdvb3NlLXNwZWNpZmljIGFnZ3JlZ2F0aW9uIGN1cnNvciAoZm9yIGBlYWNoQXN5bmMoKWAgYW5kIG90aGVyIHF1ZXJ5IGN1cnNvciBzZW1hbnRpY3MpXG4gKiBAcmV0dXJuIHtBZ2dyZWdhdGlvbkN1cnNvcn0gY3Vyc29yIHJlcHJlc2VudGluZyB0aGlzIGFnZ3JlZ2F0aW9uXG4gKiBAYXBpIHB1YmxpY1xuICogQHNlZSBtb25nb2RiIGh0dHBzOi8vbW9uZ29kYi5naXRodWIuaW8vbm9kZS1tb25nb2RiLW5hdGl2ZS80LjkvY2xhc3Nlcy9BZ2dyZWdhdGlvbkN1cnNvci5odG1sXG4gKi9cblxuQWdncmVnYXRlLnByb3RvdHlwZS5jdXJzb3IgPSBmdW5jdGlvbihvcHRpb25zKSB7XG4gIHRoaXMub3B0aW9ucy5jdXJzb3IgPSBvcHRpb25zIHx8IHt9O1xuICByZXR1cm4gbmV3IEFnZ3JlZ2F0aW9uQ3Vyc29yKHRoaXMpOyAvLyByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogQWRkcyBhIGNvbGxhdGlvblxuICpcbiAqICMjIyMgRXhhbXBsZTpcbiAqXG4gKiAgICAgY29uc3QgcmVzID0gYXdhaXQgTW9kZWwuYWdncmVnYXRlKHBpcGVsaW5lKS5jb2xsYXRpb24oeyBsb2NhbGU6ICdlbl9VUycsIHN0cmVuZ3RoOiAxIH0pO1xuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBjb2xsYXRpb24gb3B0aW9uc1xuICogQHJldHVybiB7QWdncmVnYXRlfSB0aGlzXG4gKiBAYXBpIHB1YmxpY1xuICogQHNlZSBtb25nb2RiIGh0dHBzOi8vbW9uZ29kYi5naXRodWIuaW8vbm9kZS1tb25nb2RiLW5hdGl2ZS80LjkvaW50ZXJmYWNlcy9Db2xsYXRpb25PcHRpb25zLmh0bWxcbiAqL1xuXG5BZ2dyZWdhdGUucHJvdG90eXBlLmNvbGxhdGlvbiA9IGZ1bmN0aW9uKGNvbGxhdGlvbikge1xuICB0aGlzLm9wdGlvbnMuY29sbGF0aW9uID0gY29sbGF0aW9uO1xuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogQ29tYmluZXMgbXVsdGlwbGUgYWdncmVnYXRpb24gcGlwZWxpbmVzLlxuICpcbiAqICMjIyMgRXhhbXBsZTpcbiAqXG4gKiAgICAgY29uc3QgcmVzID0gYXdhaXQgTW9kZWwuYWdncmVnYXRlKCkuZmFjZXQoe1xuICogICAgICAgYm9va3M6IFt7IGdyb3VwQnk6ICckYXV0aG9yJyB9XSxcbiAqICAgICAgIHByaWNlOiBbeyAkYnVja2V0QXV0bzogeyBncm91cEJ5OiAnJHByaWNlJywgYnVja2V0czogMiB9IH1dXG4gKiAgICAgfSk7XG4gKlxuICogICAgIC8vIE91dHB1dDogeyBib29rczogWy4uLl0sIHByaWNlOiBbey4uLn0sIHsuLi59XSB9XG4gKlxuICogQHBhcmFtIHtPYmplY3R9IGZhY2V0IG9wdGlvbnNcbiAqIEByZXR1cm4ge0FnZ3JlZ2F0ZX0gdGhpc1xuICogQHNlZSAkZmFjZXQgaHR0cHM6Ly93d3cubW9uZ29kYi5jb20vZG9jcy9tYW51YWwvcmVmZXJlbmNlL29wZXJhdG9yL2FnZ3JlZ2F0aW9uL2ZhY2V0L1xuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5BZ2dyZWdhdGUucHJvdG90eXBlLmZhY2V0ID0gZnVuY3Rpb24ob3B0aW9ucykge1xuICByZXR1cm4gdGhpcy5hcHBlbmQoeyAkZmFjZXQ6IG9wdGlvbnMgfSk7XG59O1xuXG4vKipcbiAqIEhlbHBlciBmb3IgW0F0bGFzIFRleHQgU2VhcmNoXShodHRwczovL3d3dy5tb25nb2RiLmNvbS9kb2NzL2F0bGFzL2F0bGFzLXNlYXJjaC90dXRvcmlhbC8pJ3NcbiAqIGAkc2VhcmNoYCBzdGFnZS5cbiAqXG4gKiAjIyMjIEV4YW1wbGU6XG4gKlxuICogICAgIGNvbnN0IHJlcyA9IGF3YWl0IE1vZGVsLmFnZ3JlZ2F0ZSgpLlxuICogICAgICBzZWFyY2goe1xuICogICAgICAgIHRleHQ6IHtcbiAqICAgICAgICAgIHF1ZXJ5OiAnYmFzZWJhbGwnLFxuICogICAgICAgICAgcGF0aDogJ3Bsb3QnXG4gKiAgICAgICAgfVxuICogICAgICB9KTtcbiAqXG4gKiAgICAgLy8gT3V0cHV0OiBbeyBwbG90OiAnLi4uJywgdGl0bGU6ICcuLi4nIH1dXG4gKlxuICogQHBhcmFtIHtPYmplY3R9ICRzZWFyY2ggb3B0aW9uc1xuICogQHJldHVybiB7QWdncmVnYXRlfSB0aGlzXG4gKiBAc2VlICRzZWFyY2ggaHR0cHM6Ly93d3cubW9uZ29kYi5jb20vZG9jcy9hdGxhcy9hdGxhcy1zZWFyY2gvdHV0b3JpYWwvXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbkFnZ3JlZ2F0ZS5wcm90b3R5cGUuc2VhcmNoID0gZnVuY3Rpb24ob3B0aW9ucykge1xuICByZXR1cm4gdGhpcy5hcHBlbmQoeyAkc2VhcmNoOiBvcHRpb25zIH0pO1xufTtcblxuLyoqXG4gKiBSZXR1cm5zIHRoZSBjdXJyZW50IHBpcGVsaW5lXG4gKlxuICogIyMjIyBFeGFtcGxlOlxuICpcbiAqICAgICBNeU1vZGVsLmFnZ3JlZ2F0ZSgpLm1hdGNoKHsgdGVzdDogMSB9KS5waXBlbGluZSgpOyAvLyBbeyAkbWF0Y2g6IHsgdGVzdDogMSB9IH1dXG4gKlxuICogQHJldHVybiB7QXJyYXl9IFRoZSBjdXJyZW50IHBpcGVsaW5lIHNpbWlsYXIgdG8gdGhlIG9wZXJhdGlvbiB0aGF0IHdpbGwgYmUgZXhlY3V0ZWRcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuQWdncmVnYXRlLnByb3RvdHlwZS5waXBlbGluZSA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gdGhpcy5fcGlwZWxpbmU7XG59O1xuXG4vKipcbiAqIEV4ZWN1dGVzIHRoZSBhZ2dyZWdhdGUgcGlwZWxpbmUgb24gdGhlIGN1cnJlbnRseSBib3VuZCBNb2RlbC5cbiAqXG4gKiAjIyMjIEV4YW1wbGU6XG4gKiAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgYWdncmVnYXRlLmV4ZWMoKTtcbiAqXG4gKiBAcmV0dXJuIHtQcm9taXNlfVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5BZ2dyZWdhdGUucHJvdG90eXBlLmV4ZWMgPSBhc3luYyBmdW5jdGlvbiBleGVjKCkge1xuICBpZiAoIXRoaXMuX21vZGVsKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdBZ2dyZWdhdGUgbm90IGJvdW5kIHRvIGFueSBNb2RlbCcpO1xuICB9XG4gIGlmICh0eXBlb2YgYXJndW1lbnRzWzBdID09PSAnZnVuY3Rpb24nKSB7XG4gICAgdGhyb3cgbmV3IE1vbmdvb3NlRXJyb3IoJ0FnZ3JlZ2F0ZS5wcm90b3R5cGUuZXhlYygpIG5vIGxvbmdlciBhY2NlcHRzIGEgY2FsbGJhY2snKTtcbiAgfVxuICBjb25zdCBtb2RlbCA9IHRoaXMuX21vZGVsO1xuICBjb25zdCBjb2xsZWN0aW9uID0gdGhpcy5fbW9kZWwuY29sbGVjdGlvbjtcblxuICBhcHBseUdsb2JhbE1heFRpbWVNUyh0aGlzLm9wdGlvbnMsIG1vZGVsKTtcbiAgYXBwbHlHbG9iYWxEaXNrVXNlKHRoaXMub3B0aW9ucywgbW9kZWwpO1xuXG4gIGlmICh0aGlzLm9wdGlvbnMgJiYgdGhpcy5vcHRpb25zLmN1cnNvcikge1xuICAgIHJldHVybiBuZXcgQWdncmVnYXRpb25DdXJzb3IodGhpcyk7XG4gIH1cblxuICBwcmVwYXJlRGlzY3JpbWluYXRvclBpcGVsaW5lKHRoaXMuX3BpcGVsaW5lLCB0aGlzLl9tb2RlbC5zY2hlbWEpO1xuICBzdHJpbmdpZnlGdW5jdGlvbk9wZXJhdG9ycyh0aGlzLl9waXBlbGluZSk7XG5cbiAgYXdhaXQgbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgIG1vZGVsLmhvb2tzLmV4ZWNQcmUoJ2FnZ3JlZ2F0ZScsIHRoaXMsIGVycm9yID0+IHtcbiAgICAgIGlmIChlcnJvcikge1xuICAgICAgICBjb25zdCBfb3B0cyA9IHsgZXJyb3I6IGVycm9yIH07XG4gICAgICAgIHJldHVybiBtb2RlbC5ob29rcy5leGVjUG9zdCgnYWdncmVnYXRlJywgdGhpcywgW251bGxdLCBfb3B0cywgZXJyb3IgPT4ge1xuICAgICAgICAgIHJlamVjdChlcnJvcik7XG4gICAgICAgIH0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmVzb2x2ZSgpO1xuICAgICAgfVxuICAgIH0pO1xuICB9KTtcblxuICBpZiAoIXRoaXMuX3BpcGVsaW5lLmxlbmd0aCkge1xuICAgIHRocm93IG5ldyBNb25nb29zZUVycm9yKCdBZ2dyZWdhdGUgaGFzIGVtcHR5IHBpcGVsaW5lJyk7XG4gIH1cblxuICBjb25zdCBvcHRpb25zID0gY2xvbmUodGhpcy5vcHRpb25zIHx8IHt9KTtcbiAgbGV0IHJlc3VsdDtcbiAgdHJ5IHtcbiAgICBjb25zdCBjdXJzb3IgPSBhd2FpdCBjb2xsZWN0aW9uLmFnZ3JlZ2F0ZSh0aGlzLl9waXBlbGluZSwgb3B0aW9ucyk7XG4gICAgcmVzdWx0ID0gYXdhaXQgY3Vyc29yLnRvQXJyYXkoKTtcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICBhd2FpdCBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICBjb25zdCBfb3B0cyA9IHsgZXJyb3I6IGVycm9yIH07XG4gICAgICBtb2RlbC5ob29rcy5leGVjUG9zdCgnYWdncmVnYXRlJywgdGhpcywgW251bGxdLCBfb3B0cywgKGVycm9yKSA9PiB7XG4gICAgICAgIGlmIChlcnJvcikge1xuICAgICAgICAgIHJldHVybiByZWplY3QoZXJyb3IpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmVzb2x2ZSgpO1xuICAgICAgfSk7XG4gICAgfSk7XG4gIH1cblxuICBjb25zdCBfb3B0cyA9IHsgZXJyb3I6IG51bGwgfTtcbiAgYXdhaXQgbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgIG1vZGVsLmhvb2tzLmV4ZWNQb3N0KCdhZ2dyZWdhdGUnLCB0aGlzLCBbcmVzdWx0XSwgX29wdHMsIGVycm9yID0+IHtcbiAgICAgIGlmIChlcnJvcikge1xuICAgICAgICByZXR1cm4gcmVqZWN0KGVycm9yKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiByZXNvbHZlKCk7XG4gICAgfSk7XG4gIH0pO1xuXG4gIHJldHVybiByZXN1bHQ7XG59O1xuXG4vKipcbiAqIFByb3ZpZGVzIGEgUHJvbWlzZS1saWtlIGB0aGVuYCBmdW5jdGlvbiwgd2hpY2ggd2lsbCBjYWxsIGAuZXhlY2Agd2l0aG91dCBhIGNhbGxiYWNrXG4gKiBDb21wYXRpYmxlIHdpdGggYGF3YWl0YC5cbiAqXG4gKiAjIyMjIEV4YW1wbGU6XG4gKlxuICogICAgIE1vZGVsLmFnZ3JlZ2F0ZSguLikudGhlbihzdWNjZXNzQ2FsbGJhY2ssIGVycm9yQ2FsbGJhY2spO1xuICpcbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtyZXNvbHZlXSBzdWNjZXNzQ2FsbGJhY2tcbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtyZWplY3RdICBlcnJvckNhbGxiYWNrXG4gKiBAcmV0dXJuIHtQcm9taXNlfVxuICovXG5BZ2dyZWdhdGUucHJvdG90eXBlLnRoZW4gPSBmdW5jdGlvbihyZXNvbHZlLCByZWplY3QpIHtcbiAgcmV0dXJuIHRoaXMuZXhlYygpLnRoZW4ocmVzb2x2ZSwgcmVqZWN0KTtcbn07XG5cbi8qKlxuICogRXhlY3V0ZXMgdGhlIGFnZ3JlZ2F0aW9uIHJldHVybmluZyBhIGBQcm9taXNlYCB3aGljaCB3aWxsIGJlXG4gKiByZXNvbHZlZCB3aXRoIGVpdGhlciB0aGUgZG9jKHMpIG9yIHJlamVjdGVkIHdpdGggdGhlIGVycm9yLlxuICogTGlrZSBbYC50aGVuKClgXShodHRwczovL21vbmdvb3NlanMuY29tL2RvY3MvYXBpL3F1ZXJ5Lmh0bWwjUXVlcnkucHJvdG90eXBlLnRoZW4pLCBidXQgb25seSB0YWtlcyBhIHJlamVjdGlvbiBoYW5kbGVyLlxuICogQ29tcGF0aWJsZSB3aXRoIGBhd2FpdGAuXG4gKlxuICogQHBhcmFtIHtGdW5jdGlvbn0gW3JlamVjdF1cbiAqIEByZXR1cm4ge1Byb21pc2V9XG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbkFnZ3JlZ2F0ZS5wcm90b3R5cGUuY2F0Y2ggPSBmdW5jdGlvbihyZWplY3QpIHtcbiAgcmV0dXJuIHRoaXMuZXhlYygpLnRoZW4obnVsbCwgcmVqZWN0KTtcbn07XG5cbi8qKlxuICogRXhlY3V0ZXMgdGhlIGFnZ3JlZ2F0ZSByZXR1cm5pbmcgYSBgUHJvbWlzZWAgd2hpY2ggd2lsbCBiZVxuICogcmVzb2x2ZWQgd2l0aCBgLmZpbmFsbHkoKWAgY2hhaW5lZC5cbiAqXG4gKiBNb3JlIGFib3V0IFtQcm9taXNlIGBmaW5hbGx5KClgIGluIEphdmFTY3JpcHRdKGh0dHBzOi8vdGhlY29kZWJhcmJhcmlhbi5jb20vdXNpbmctcHJvbWlzZS1maW5hbGx5LWluLW5vZGUtanMuaHRtbCkuXG4gKlxuICogQHBhcmFtIHtGdW5jdGlvbn0gW29uRmluYWxseV1cbiAqIEByZXR1cm4ge1Byb21pc2V9XG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbkFnZ3JlZ2F0ZS5wcm90b3R5cGUuZmluYWxseSA9IGZ1bmN0aW9uKG9uRmluYWxseSkge1xuICByZXR1cm4gdGhpcy5leGVjKCkuZmluYWxseShvbkZpbmFsbHkpO1xufTtcblxuLyoqXG4gKiBSZXR1cm5zIGFuIGFzeW5jSXRlcmF0b3IgZm9yIHVzZSB3aXRoIFtgZm9yL2F3YWl0L29mYCBsb29wc10oaHR0cHM6Ly90aGVjb2RlYmFyYmFyaWFuLmNvbS9nZXR0aW5nLXN0YXJ0ZWQtd2l0aC1hc3luYy1pdGVyYXRvcnMtaW4tbm9kZS1qcylcbiAqIFlvdSBkbyBub3QgbmVlZCB0byBjYWxsIHRoaXMgZnVuY3Rpb24gZXhwbGljaXRseSwgdGhlIEphdmFTY3JpcHQgcnVudGltZVxuICogd2lsbCBjYWxsIGl0IGZvciB5b3UuXG4gKlxuICogIyMjIyBFeGFtcGxlOlxuICpcbiAqICAgICBjb25zdCBhZ2cgPSBNb2RlbC5hZ2dyZWdhdGUoW3sgJG1hdGNoOiB7IGFnZTogeyAkZ3RlOiAyNSB9IH0gfV0pO1xuICogICAgIGZvciBhd2FpdCAoY29uc3QgZG9jIG9mIGFnZykge1xuICogICAgICAgY29uc29sZS5sb2coZG9jLm5hbWUpO1xuICogICAgIH1cbiAqXG4gKiBOb2RlLmpzIDEwLnggc3VwcG9ydHMgYXN5bmMgaXRlcmF0b3JzIG5hdGl2ZWx5IHdpdGhvdXQgYW55IGZsYWdzLiBZb3UgY2FuXG4gKiBlbmFibGUgYXN5bmMgaXRlcmF0b3JzIGluIE5vZGUuanMgOC54IHVzaW5nIHRoZSBbYC0taGFybW9ueV9hc3luY19pdGVyYXRpb25gIGZsYWddKGh0dHBzOi8vZ2l0aHViLmNvbS90YzM5L3Byb3Bvc2FsLWFzeW5jLWl0ZXJhdGlvbi9pc3N1ZXMvMTE3I2lzc3VlY29tbWVudC0zNDY2OTUxODcpLlxuICpcbiAqICoqTm90ZToqKiBUaGlzIGZ1bmN0aW9uIGlzIG5vdCBzZXQgaWYgYFN5bWJvbC5hc3luY0l0ZXJhdG9yYCBpcyB1bmRlZmluZWQuIElmXG4gKiBgU3ltYm9sLmFzeW5jSXRlcmF0b3JgIGlzIHVuZGVmaW5lZCwgdGhhdCBtZWFucyB5b3VyIE5vZGUuanMgdmVyc2lvbiBkb2VzIG5vdFxuICogc3VwcG9ydCBhc3luYyBpdGVyYXRvcnMuXG4gKlxuICogQG1ldGhvZCBbU3ltYm9sLmFzeW5jSXRlcmF0b3JdXG4gKiBAbWVtYmVyT2YgQWdncmVnYXRlXG4gKiBAaW5zdGFuY2VcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuaWYgKFN5bWJvbC5hc3luY0l0ZXJhdG9yICE9IG51bGwpIHtcbiAgQWdncmVnYXRlLnByb3RvdHlwZVtTeW1ib2wuYXN5bmNJdGVyYXRvcl0gPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy5jdXJzb3IoeyB1c2VNb25nb29zZUFnZ0N1cnNvcjogdHJ1ZSB9KS50cmFuc2Zvcm1OdWxsKCkuX3RyYW5zZm9ybUZvckFzeW5jSXRlcmF0b3IoKTtcbiAgfTtcbn1cblxuLyohXG4gKiBIZWxwZXJzXG4gKi9cblxuLyoqXG4gKiBDaGVja3Mgd2hldGhlciBhbiBvYmplY3QgaXMgbGlrZWx5IGEgcGlwZWxpbmUgb3BlcmF0b3JcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqIG9iamVjdCB0byBjaGVja1xuICogQHJldHVybiB7Qm9vbGVhbn1cbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmZ1bmN0aW9uIGlzT3BlcmF0b3Iob2JqKSB7XG4gIGlmICh0eXBlb2Ygb2JqICE9PSAnb2JqZWN0JyB8fCBvYmogPT09IG51bGwpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBjb25zdCBrID0gT2JqZWN0LmtleXMob2JqKTtcblxuICByZXR1cm4gay5sZW5ndGggPT09IDEgJiYga1swXVswXSA9PT0gJyQnO1xufVxuXG4vKipcbiAqIEFkZHMgdGhlIGFwcHJvcHJpYXRlIGAkbWF0Y2hgIHBpcGVsaW5lIHN0ZXAgdG8gdGhlIHRvcCBvZiBhbiBhZ2dyZWdhdGUnc1xuICogcGlwZWxpbmUsIHNob3VsZCBpdCdzIG1vZGVsIGlzIGEgbm9uLXJvb3QgZGlzY3JpbWluYXRvciB0eXBlLiBUaGlzIGlzXG4gKiBhbmFsb2dvdXMgdG8gdGhlIGBwcmVwYXJlRGlzY3JpbWluYXRvckNyaXRlcmlhYCBmdW5jdGlvbiBpbiBgbGliL3F1ZXJ5LmpzYC5cbiAqXG4gKiBAcGFyYW0ge0FnZ3JlZ2F0ZX0gYWdncmVnYXRlIEFnZ3JlZ2F0ZSB0byBwcmVwYXJlXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5BZ2dyZWdhdGUuX3ByZXBhcmVEaXNjcmltaW5hdG9yUGlwZWxpbmUgPSBwcmVwYXJlRGlzY3JpbWluYXRvclBpcGVsaW5lO1xuXG4vKiFcbiAqIEV4cG9ydHNcbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IEFnZ3JlZ2F0ZTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/mongoose/lib/aggregate.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/mongoose/lib/browserDocument.js":
/*!******************************************************!*\
  !*** ./node_modules/mongoose/lib/browserDocument.js ***!
  \******************************************************/
/***/ ((module, exports, __webpack_require__) => {

eval("/*!\n * Module dependencies.\n */\n\n\n\nconst NodeJSDocument = __webpack_require__(/*! ./document */ \"(ssr)/./node_modules/mongoose/lib/document.js\");\nconst EventEmitter = (__webpack_require__(/*! events */ \"events\").EventEmitter);\nconst MongooseError = __webpack_require__(/*! ./error/index */ \"(ssr)/./node_modules/mongoose/lib/error/index.js\");\nconst Schema = __webpack_require__(/*! ./schema */ \"(ssr)/./node_modules/mongoose/lib/schema.js\");\nconst ObjectId = __webpack_require__(/*! ./types/objectid */ \"(ssr)/./node_modules/mongoose/lib/types/objectid.js\");\nconst ValidationError = MongooseError.ValidationError;\nconst applyHooks = __webpack_require__(/*! ./helpers/model/applyHooks */ \"(ssr)/./node_modules/mongoose/lib/helpers/model/applyHooks.js\");\nconst isObject = __webpack_require__(/*! ./helpers/isObject */ \"(ssr)/./node_modules/mongoose/lib/helpers/isObject.js\");\n\n/**\n * Document constructor.\n *\n * @param {Object} obj the values to set\n * @param {Object} schema\n * @param {Object} [fields] optional object containing the fields which were selected in the query returning this document and any populated paths data\n * @param {Boolean} [skipId] bool, should we auto create an ObjectId _id\n * @inherits NodeJS EventEmitter https://nodejs.org/api/events.html#class-eventemitter\n * @event `init`: Emitted on a document after it has was retrieved from the db and fully hydrated by Mongoose.\n * @event `save`: Emitted when the document is successfully saved\n * @api private\n */\n\nfunction Document(obj, schema, fields, skipId, skipInit) {\n  if (!(this instanceof Document)) {\n    return new Document(obj, schema, fields, skipId, skipInit);\n  }\n\n  if (isObject(schema) && !schema.instanceOfSchema) {\n    schema = new Schema(schema);\n  }\n\n  // When creating EmbeddedDocument, it already has the schema and he doesn't need the _id\n  schema = this.schema || schema;\n\n  // Generate ObjectId if it is missing, but it requires a scheme\n  if (!this.schema && schema.options._id) {\n    obj = obj || {};\n\n    if (obj._id === undefined) {\n      obj._id = new ObjectId();\n    }\n  }\n\n  if (!schema) {\n    throw new MongooseError.MissingSchemaError();\n  }\n\n  this.$__setSchema(schema);\n\n  NodeJSDocument.call(this, obj, fields, skipId, skipInit);\n\n  applyHooks(this, schema, { decorateDoc: true });\n\n  // apply methods\n  for (const m in schema.methods) {\n    this[m] = schema.methods[m];\n  }\n  // apply statics\n  for (const s in schema.statics) {\n    this[s] = schema.statics[s];\n  }\n}\n\n/*!\n * Inherit from the NodeJS document\n */\n\nDocument.prototype = Object.create(NodeJSDocument.prototype);\nDocument.prototype.constructor = Document;\n\n/*!\n * ignore\n */\n\nDocument.events = new EventEmitter();\n\n/*!\n * Browser doc exposes the event emitter API\n */\n\nDocument.$emitter = new EventEmitter();\n\n['on', 'once', 'emit', 'listeners', 'removeListener', 'setMaxListeners',\n  'removeAllListeners', 'addListener'].forEach(function(emitterFn) {\n  Document[emitterFn] = function() {\n    return Document.$emitter[emitterFn].apply(Document.$emitter, arguments);\n  };\n});\n\n/*!\n * Module exports.\n */\n\nDocument.ValidationError = ValidationError;\nmodule.exports = exports = Document;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbW9uZ29vc2UvbGliL2Jyb3dzZXJEb2N1bWVudC5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7O0FBRWE7O0FBRWIsdUJBQXVCLG1CQUFPLENBQUMsaUVBQVk7QUFDM0MscUJBQXFCLDBEQUE4QjtBQUNuRCxzQkFBc0IsbUJBQU8sQ0FBQyx1RUFBZTtBQUM3QyxlQUFlLG1CQUFPLENBQUMsNkRBQVU7QUFDakMsaUJBQWlCLG1CQUFPLENBQUMsNkVBQWtCO0FBQzNDO0FBQ0EsbUJBQW1CLG1CQUFPLENBQUMsaUdBQTRCO0FBQ3ZELGlCQUFpQixtQkFBTyxDQUFDLGlGQUFvQjs7QUFFN0M7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsV0FBVyxTQUFTO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQSw2QkFBNkIsbUJBQW1COztBQUVoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL2FwcDEvLi9ub2RlX21vZHVsZXMvbW9uZ29vc2UvbGliL2Jyb3dzZXJEb2N1bWVudC5qcz8yY2EyIl0sInNvdXJjZXNDb250ZW50IjpbIi8qIVxuICogTW9kdWxlIGRlcGVuZGVuY2llcy5cbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbmNvbnN0IE5vZGVKU0RvY3VtZW50ID0gcmVxdWlyZSgnLi9kb2N1bWVudCcpO1xuY29uc3QgRXZlbnRFbWl0dGVyID0gcmVxdWlyZSgnZXZlbnRzJykuRXZlbnRFbWl0dGVyO1xuY29uc3QgTW9uZ29vc2VFcnJvciA9IHJlcXVpcmUoJy4vZXJyb3IvaW5kZXgnKTtcbmNvbnN0IFNjaGVtYSA9IHJlcXVpcmUoJy4vc2NoZW1hJyk7XG5jb25zdCBPYmplY3RJZCA9IHJlcXVpcmUoJy4vdHlwZXMvb2JqZWN0aWQnKTtcbmNvbnN0IFZhbGlkYXRpb25FcnJvciA9IE1vbmdvb3NlRXJyb3IuVmFsaWRhdGlvbkVycm9yO1xuY29uc3QgYXBwbHlIb29rcyA9IHJlcXVpcmUoJy4vaGVscGVycy9tb2RlbC9hcHBseUhvb2tzJyk7XG5jb25zdCBpc09iamVjdCA9IHJlcXVpcmUoJy4vaGVscGVycy9pc09iamVjdCcpO1xuXG4vKipcbiAqIERvY3VtZW50IGNvbnN0cnVjdG9yLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmogdGhlIHZhbHVlcyB0byBzZXRcbiAqIEBwYXJhbSB7T2JqZWN0fSBzY2hlbWFcbiAqIEBwYXJhbSB7T2JqZWN0fSBbZmllbGRzXSBvcHRpb25hbCBvYmplY3QgY29udGFpbmluZyB0aGUgZmllbGRzIHdoaWNoIHdlcmUgc2VsZWN0ZWQgaW4gdGhlIHF1ZXJ5IHJldHVybmluZyB0aGlzIGRvY3VtZW50IGFuZCBhbnkgcG9wdWxhdGVkIHBhdGhzIGRhdGFcbiAqIEBwYXJhbSB7Qm9vbGVhbn0gW3NraXBJZF0gYm9vbCwgc2hvdWxkIHdlIGF1dG8gY3JlYXRlIGFuIE9iamVjdElkIF9pZFxuICogQGluaGVyaXRzIE5vZGVKUyBFdmVudEVtaXR0ZXIgaHR0cHM6Ly9ub2RlanMub3JnL2FwaS9ldmVudHMuaHRtbCNjbGFzcy1ldmVudGVtaXR0ZXJcbiAqIEBldmVudCBgaW5pdGA6IEVtaXR0ZWQgb24gYSBkb2N1bWVudCBhZnRlciBpdCBoYXMgd2FzIHJldHJpZXZlZCBmcm9tIHRoZSBkYiBhbmQgZnVsbHkgaHlkcmF0ZWQgYnkgTW9uZ29vc2UuXG4gKiBAZXZlbnQgYHNhdmVgOiBFbWl0dGVkIHdoZW4gdGhlIGRvY3VtZW50IGlzIHN1Y2Nlc3NmdWxseSBzYXZlZFxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZnVuY3Rpb24gRG9jdW1lbnQob2JqLCBzY2hlbWEsIGZpZWxkcywgc2tpcElkLCBza2lwSW5pdCkge1xuICBpZiAoISh0aGlzIGluc3RhbmNlb2YgRG9jdW1lbnQpKSB7XG4gICAgcmV0dXJuIG5ldyBEb2N1bWVudChvYmosIHNjaGVtYSwgZmllbGRzLCBza2lwSWQsIHNraXBJbml0KTtcbiAgfVxuXG4gIGlmIChpc09iamVjdChzY2hlbWEpICYmICFzY2hlbWEuaW5zdGFuY2VPZlNjaGVtYSkge1xuICAgIHNjaGVtYSA9IG5ldyBTY2hlbWEoc2NoZW1hKTtcbiAgfVxuXG4gIC8vIFdoZW4gY3JlYXRpbmcgRW1iZWRkZWREb2N1bWVudCwgaXQgYWxyZWFkeSBoYXMgdGhlIHNjaGVtYSBhbmQgaGUgZG9lc24ndCBuZWVkIHRoZSBfaWRcbiAgc2NoZW1hID0gdGhpcy5zY2hlbWEgfHwgc2NoZW1hO1xuXG4gIC8vIEdlbmVyYXRlIE9iamVjdElkIGlmIGl0IGlzIG1pc3NpbmcsIGJ1dCBpdCByZXF1aXJlcyBhIHNjaGVtZVxuICBpZiAoIXRoaXMuc2NoZW1hICYmIHNjaGVtYS5vcHRpb25zLl9pZCkge1xuICAgIG9iaiA9IG9iaiB8fCB7fTtcblxuICAgIGlmIChvYmouX2lkID09PSB1bmRlZmluZWQpIHtcbiAgICAgIG9iai5faWQgPSBuZXcgT2JqZWN0SWQoKTtcbiAgICB9XG4gIH1cblxuICBpZiAoIXNjaGVtYSkge1xuICAgIHRocm93IG5ldyBNb25nb29zZUVycm9yLk1pc3NpbmdTY2hlbWFFcnJvcigpO1xuICB9XG5cbiAgdGhpcy4kX19zZXRTY2hlbWEoc2NoZW1hKTtcblxuICBOb2RlSlNEb2N1bWVudC5jYWxsKHRoaXMsIG9iaiwgZmllbGRzLCBza2lwSWQsIHNraXBJbml0KTtcblxuICBhcHBseUhvb2tzKHRoaXMsIHNjaGVtYSwgeyBkZWNvcmF0ZURvYzogdHJ1ZSB9KTtcblxuICAvLyBhcHBseSBtZXRob2RzXG4gIGZvciAoY29uc3QgbSBpbiBzY2hlbWEubWV0aG9kcykge1xuICAgIHRoaXNbbV0gPSBzY2hlbWEubWV0aG9kc1ttXTtcbiAgfVxuICAvLyBhcHBseSBzdGF0aWNzXG4gIGZvciAoY29uc3QgcyBpbiBzY2hlbWEuc3RhdGljcykge1xuICAgIHRoaXNbc10gPSBzY2hlbWEuc3RhdGljc1tzXTtcbiAgfVxufVxuXG4vKiFcbiAqIEluaGVyaXQgZnJvbSB0aGUgTm9kZUpTIGRvY3VtZW50XG4gKi9cblxuRG9jdW1lbnQucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShOb2RlSlNEb2N1bWVudC5wcm90b3R5cGUpO1xuRG9jdW1lbnQucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gRG9jdW1lbnQ7XG5cbi8qIVxuICogaWdub3JlXG4gKi9cblxuRG9jdW1lbnQuZXZlbnRzID0gbmV3IEV2ZW50RW1pdHRlcigpO1xuXG4vKiFcbiAqIEJyb3dzZXIgZG9jIGV4cG9zZXMgdGhlIGV2ZW50IGVtaXR0ZXIgQVBJXG4gKi9cblxuRG9jdW1lbnQuJGVtaXR0ZXIgPSBuZXcgRXZlbnRFbWl0dGVyKCk7XG5cblsnb24nLCAnb25jZScsICdlbWl0JywgJ2xpc3RlbmVycycsICdyZW1vdmVMaXN0ZW5lcicsICdzZXRNYXhMaXN0ZW5lcnMnLFxuICAncmVtb3ZlQWxsTGlzdGVuZXJzJywgJ2FkZExpc3RlbmVyJ10uZm9yRWFjaChmdW5jdGlvbihlbWl0dGVyRm4pIHtcbiAgRG9jdW1lbnRbZW1pdHRlckZuXSA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBEb2N1bWVudC4kZW1pdHRlcltlbWl0dGVyRm5dLmFwcGx5KERvY3VtZW50LiRlbWl0dGVyLCBhcmd1bWVudHMpO1xuICB9O1xufSk7XG5cbi8qIVxuICogTW9kdWxlIGV4cG9ydHMuXG4gKi9cblxuRG9jdW1lbnQuVmFsaWRhdGlvbkVycm9yID0gVmFsaWRhdGlvbkVycm9yO1xubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzID0gRG9jdW1lbnQ7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/mongoose/lib/browserDocument.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/mongoose/lib/cast.js":
/*!*******************************************!*\
  !*** ./node_modules/mongoose/lib/cast.js ***!
  \*******************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\n\n/*!\n * Module dependencies.\n */\n\nconst CastError = __webpack_require__(/*! ./error/cast */ \"(ssr)/./node_modules/mongoose/lib/error/cast.js\");\nconst StrictModeError = __webpack_require__(/*! ./error/strict */ \"(ssr)/./node_modules/mongoose/lib/error/strict.js\");\nconst Types = __webpack_require__(/*! ./schema/index */ \"(ssr)/./node_modules/mongoose/lib/schema/index.js\");\nconst cast$expr = __webpack_require__(/*! ./helpers/query/cast$expr */ \"(ssr)/./node_modules/mongoose/lib/helpers/query/cast$expr.js\");\nconst castTextSearch = __webpack_require__(/*! ./schema/operators/text */ \"(ssr)/./node_modules/mongoose/lib/schema/operators/text.js\");\nconst get = __webpack_require__(/*! ./helpers/get */ \"(ssr)/./node_modules/mongoose/lib/helpers/get.js\");\nconst getSchemaDiscriminatorByValue = __webpack_require__(/*! ./helpers/discriminator/getSchemaDiscriminatorByValue */ \"(ssr)/./node_modules/mongoose/lib/helpers/discriminator/getSchemaDiscriminatorByValue.js\");\nconst isOperator = __webpack_require__(/*! ./helpers/query/isOperator */ \"(ssr)/./node_modules/mongoose/lib/helpers/query/isOperator.js\");\nconst util = __webpack_require__(/*! util */ \"util\");\nconst isObject = __webpack_require__(/*! ./helpers/isObject */ \"(ssr)/./node_modules/mongoose/lib/helpers/isObject.js\");\nconst isMongooseObject = __webpack_require__(/*! ./helpers/isMongooseObject */ \"(ssr)/./node_modules/mongoose/lib/helpers/isMongooseObject.js\");\nconst utils = __webpack_require__(/*! ./utils */ \"(ssr)/./node_modules/mongoose/lib/utils.js\");\n\nconst ALLOWED_GEOWITHIN_GEOJSON_TYPES = ['Polygon', 'MultiPolygon'];\n\n/**\n * Handles internal casting for query filters.\n *\n * @param {Schema} schema\n * @param {Object} obj Object to cast\n * @param {Object} [options] the query options\n * @param {Boolean|\"throw\"} [options.strict] Wheter to enable all strict options\n * @param {Boolean|\"throw\"} [options.strictQuery] Enable strict Queries\n * @param {Boolean} [options.upsert]\n * @param {Query} [context] passed to setters\n * @api private\n */\nmodule.exports = function cast(schema, obj, options, context) {\n  if (Array.isArray(obj)) {\n    throw new Error('Query filter must be an object, got an array ', util.inspect(obj));\n  }\n\n  if (obj == null) {\n    return obj;\n  }\n\n  if (schema != null && schema.discriminators != null && obj[schema.options.discriminatorKey] != null) {\n    schema = getSchemaDiscriminatorByValue(schema, obj[schema.options.discriminatorKey]) || schema;\n  }\n\n  const paths = Object.keys(obj);\n  let i = paths.length;\n  let _keys;\n  let any$conditionals;\n  let schematype;\n  let nested;\n  let path;\n  let type;\n  let val;\n\n  options = options || {};\n\n  while (i--) {\n    path = paths[i];\n    val = obj[path];\n\n    if (path === '$or' || path === '$nor' || path === '$and') {\n      if (!Array.isArray(val)) {\n        throw new CastError('Array', val, path);\n      }\n      for (let k = 0; k < val.length; ++k) {\n        if (val[k] == null || typeof val[k] !== 'object') {\n          throw new CastError('Object', val[k], path + '.' + k);\n        }\n        const discriminatorValue = val[k][schema.options.discriminatorKey];\n        if (discriminatorValue == null) {\n          val[k] = cast(schema, val[k], options, context);\n        } else {\n          const discriminatorSchema = getSchemaDiscriminatorByValue(context.schema, discriminatorValue);\n          val[k] = cast(discriminatorSchema ? discriminatorSchema : schema, val[k], options, context);\n        }\n      }\n    } else if (path === '$where') {\n      type = typeof val;\n\n      if (type !== 'string' && type !== 'function') {\n        throw new Error('Must have a string or function for $where');\n      }\n\n      if (type === 'function') {\n        obj[path] = val.toString();\n      }\n\n      continue;\n    } else if (path === '$expr') {\n      val = cast$expr(val, schema);\n      continue;\n    } else if (path === '$elemMatch') {\n      val = cast(schema, val, options, context);\n    } else if (path === '$text') {\n      val = castTextSearch(val, path);\n    } else {\n      if (!schema) {\n        // no casting for Mixed types\n        continue;\n      }\n\n      schematype = schema.path(path);\n\n      // Check for embedded discriminator paths\n      if (!schematype) {\n        const split = path.split('.');\n        let j = split.length;\n        while (j--) {\n          const pathFirstHalf = split.slice(0, j).join('.');\n          const pathLastHalf = split.slice(j).join('.');\n          const _schematype = schema.path(pathFirstHalf);\n          const discriminatorKey = _schematype &&\n            _schematype.schema &&\n            _schematype.schema.options &&\n            _schematype.schema.options.discriminatorKey;\n\n          // gh-6027: if we haven't found the schematype but this path is\n          // underneath an embedded discriminator and the embedded discriminator\n          // key is in the query, use the embedded discriminator schema\n          if (_schematype != null &&\n            (_schematype.schema && _schematype.schema.discriminators) != null &&\n            discriminatorKey != null &&\n            pathLastHalf !== discriminatorKey) {\n            const discriminatorVal = get(obj, pathFirstHalf + '.' + discriminatorKey);\n            const discriminators = _schematype.schema.discriminators;\n            if (typeof discriminatorVal === 'string' && discriminators[discriminatorVal] != null) {\n\n              schematype = discriminators[discriminatorVal].path(pathLastHalf);\n            } else if (discriminatorVal != null &&\n              Object.keys(discriminatorVal).length === 1 &&\n              Array.isArray(discriminatorVal.$in) &&\n              discriminatorVal.$in.length === 1 &&\n              typeof discriminatorVal.$in[0] === 'string' &&\n              discriminators[discriminatorVal.$in[0]] != null) {\n              schematype = discriminators[discriminatorVal.$in[0]].path(pathLastHalf);\n            }\n          }\n        }\n      }\n\n      if (!schematype) {\n        // Handle potential embedded array queries\n        const split = path.split('.');\n        let j = split.length;\n        let pathFirstHalf;\n        let pathLastHalf;\n        let remainingConds;\n\n        // Find the part of the var path that is a path of the Schema\n        while (j--) {\n          pathFirstHalf = split.slice(0, j).join('.');\n          schematype = schema.path(pathFirstHalf);\n          if (schematype) {\n            break;\n          }\n        }\n\n        // If a substring of the input path resolves to an actual real path...\n        if (schematype) {\n          // Apply the casting; similar code for $elemMatch in schema/array.js\n          if (schematype.caster && schematype.caster.schema) {\n            remainingConds = {};\n            pathLastHalf = split.slice(j).join('.');\n            remainingConds[pathLastHalf] = val;\n\n            const ret = cast(schematype.caster.schema, remainingConds, options, context)[pathLastHalf];\n            if (ret === void 0) {\n              delete obj[path];\n            } else {\n              obj[path] = ret;\n            }\n          } else {\n            obj[path] = val;\n          }\n          continue;\n        }\n\n        if (isObject(val)) {\n          // handle geo schemas that use object notation\n          // { loc: { long: Number, lat: Number }\n\n          let geo = '';\n          if (val.$near) {\n            geo = '$near';\n          } else if (val.$nearSphere) {\n            geo = '$nearSphere';\n          } else if (val.$within) {\n            geo = '$within';\n          } else if (val.$geoIntersects) {\n            geo = '$geoIntersects';\n          } else if (val.$geoWithin) {\n            geo = '$geoWithin';\n          }\n\n          if (geo) {\n            const numbertype = new Types.Number('__QueryCasting__');\n            let value = val[geo];\n\n            if (val.$maxDistance != null) {\n              val.$maxDistance = numbertype.castForQuery(\n                null,\n                val.$maxDistance,\n                context\n              );\n            }\n            if (val.$minDistance != null) {\n              val.$minDistance = numbertype.castForQuery(\n                null,\n                val.$minDistance,\n                context\n              );\n            }\n\n            if (geo === '$within') {\n              const withinType = value.$center\n                  || value.$centerSphere\n                  || value.$box\n                  || value.$polygon;\n\n              if (!withinType) {\n                throw new Error('Bad $within parameter: ' + JSON.stringify(val));\n              }\n\n              value = withinType;\n            } else if (geo === '$near' &&\n                typeof value.type === 'string' && Array.isArray(value.coordinates)) {\n              // geojson; cast the coordinates\n              value = value.coordinates;\n            } else if ((geo === '$near' || geo === '$nearSphere' || geo === '$geoIntersects') &&\n                value.$geometry && typeof value.$geometry.type === 'string' &&\n                Array.isArray(value.$geometry.coordinates)) {\n              if (value.$maxDistance != null) {\n                value.$maxDistance = numbertype.castForQuery(\n                  null,\n                  value.$maxDistance,\n                  context\n                );\n              }\n              if (value.$minDistance != null) {\n                value.$minDistance = numbertype.castForQuery(\n                  null,\n                  value.$minDistance,\n                  context\n                );\n              }\n              if (isMongooseObject(value.$geometry)) {\n                value.$geometry = value.$geometry.toObject({\n                  transform: false,\n                  virtuals: false\n                });\n              }\n              value = value.$geometry.coordinates;\n            } else if (geo === '$geoWithin') {\n              if (value.$geometry) {\n                if (isMongooseObject(value.$geometry)) {\n                  value.$geometry = value.$geometry.toObject({ virtuals: false });\n                }\n                const geoWithinType = value.$geometry.type;\n                if (ALLOWED_GEOWITHIN_GEOJSON_TYPES.indexOf(geoWithinType) === -1) {\n                  throw new Error('Invalid geoJSON type for $geoWithin \"' +\n                    geoWithinType + '\", must be \"Polygon\" or \"MultiPolygon\"');\n                }\n                value = value.$geometry.coordinates;\n              } else {\n                value = value.$box || value.$polygon || value.$center ||\n                  value.$centerSphere;\n                if (isMongooseObject(value)) {\n                  value = value.toObject({ virtuals: false });\n                }\n              }\n            }\n\n            _cast(value, numbertype, context);\n            continue;\n          }\n        }\n\n        if (schema.nested[path]) {\n          continue;\n        }\n\n        const strict = 'strict' in options ? options.strict : schema.options.strict;\n        const strictQuery = getStrictQuery(options, schema._userProvidedOptions, schema.options, context);\n        if (options.upsert && strict) {\n          if (strict === 'throw') {\n            throw new StrictModeError(path);\n          }\n          throw new StrictModeError(path, 'Path \"' + path + '\" is not in ' +\n            'schema, strict mode is `true`, and upsert is `true`.');\n        } if (strictQuery === 'throw') {\n          throw new StrictModeError(path, 'Path \"' + path + '\" is not in ' +\n            'schema and strictQuery is \\'throw\\'.');\n        } else if (strictQuery) {\n          delete obj[path];\n        }\n      } else if (val == null) {\n        continue;\n      } else if (utils.isPOJO(val)) {\n        any$conditionals = Object.keys(val).some(isOperator);\n\n        if (!any$conditionals) {\n          obj[path] = schematype.castForQuery(\n            null,\n            val,\n            context\n          );\n        } else {\n          const ks = Object.keys(val);\n          let $cond;\n          let k = ks.length;\n\n          while (k--) {\n            $cond = ks[k];\n            nested = val[$cond];\n            if ($cond === '$elemMatch') {\n              if (nested && schematype != null && schematype.schema != null) {\n                cast(schematype.schema, nested, options, context);\n              } else if (nested && schematype != null && schematype.$isMongooseArray) {\n                if (utils.isPOJO(nested) && nested.$not != null) {\n                  cast(schema, nested, options, context);\n                } else {\n                  val[$cond] = schematype.castForQuery(\n                    $cond,\n                    nested,\n                    context\n                  );\n                }\n              }\n            } else if ($cond === '$not') {\n              if (nested && schematype) {\n                _keys = Object.keys(nested);\n                if (_keys.length && isOperator(_keys[0])) {\n                  for (const key in nested) {\n                    nested[key] = schematype.castForQuery(\n                      key,\n                      nested[key],\n                      context\n                    );\n                  }\n                } else {\n                  val[$cond] = schematype.castForQuery(\n                    $cond,\n                    nested,\n                    context\n                  );\n                }\n                continue;\n              }\n            } else {\n              val[$cond] = schematype.castForQuery(\n                $cond,\n                nested,\n                context\n              );\n            }\n\n          }\n        }\n      } else if (Array.isArray(val) && ['Buffer', 'Array'].indexOf(schematype.instance) === -1) {\n        const casted = [];\n        const valuesArray = val;\n\n        for (const _val of valuesArray) {\n          casted.push(schematype.castForQuery(\n            null,\n            _val,\n            context\n          ));\n        }\n\n        obj[path] = { $in: casted };\n      } else {\n        obj[path] = schematype.castForQuery(\n          null,\n          val,\n          context\n        );\n      }\n    }\n  }\n\n  return obj;\n};\n\nfunction _cast(val, numbertype, context) {\n  if (Array.isArray(val)) {\n    val.forEach(function(item, i) {\n      if (Array.isArray(item) || isObject(item)) {\n        return _cast(item, numbertype, context);\n      }\n      val[i] = numbertype.castForQuery(null, item, context);\n    });\n  } else {\n    const nearKeys = Object.keys(val);\n    let nearLen = nearKeys.length;\n    while (nearLen--) {\n      const nkey = nearKeys[nearLen];\n      const item = val[nkey];\n      if (Array.isArray(item) || isObject(item)) {\n        _cast(item, numbertype, context);\n        val[nkey] = item;\n      } else {\n        val[nkey] = numbertype.castForQuery({ val: item, context: context });\n      }\n    }\n  }\n}\n\nfunction getStrictQuery(queryOptions, schemaUserProvidedOptions, schemaOptions, context) {\n  if ('strictQuery' in queryOptions) {\n    return queryOptions.strictQuery;\n  }\n  if ('strictQuery' in schemaUserProvidedOptions) {\n    return schemaUserProvidedOptions.strictQuery;\n  }\n  const mongooseOptions = context &&\n    context.mongooseCollection &&\n    context.mongooseCollection.conn &&\n    context.mongooseCollection.conn.base &&\n    context.mongooseCollection.conn.base.options;\n  if (mongooseOptions) {\n    if ('strictQuery' in mongooseOptions) {\n      return mongooseOptions.strictQuery;\n    }\n  }\n  return schemaOptions.strictQuery;\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbW9uZ29vc2UvbGliL2Nhc3QuanMiLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWI7QUFDQTtBQUNBOztBQUVBLGtCQUFrQixtQkFBTyxDQUFDLHFFQUFjO0FBQ3hDLHdCQUF3QixtQkFBTyxDQUFDLHlFQUFnQjtBQUNoRCxjQUFjLG1CQUFPLENBQUMseUVBQWdCO0FBQ3RDLGtCQUFrQixtQkFBTyxDQUFDLCtGQUEyQjtBQUNyRCx1QkFBdUIsbUJBQU8sQ0FBQywyRkFBeUI7QUFDeEQsWUFBWSxtQkFBTyxDQUFDLHVFQUFlO0FBQ25DLHNDQUFzQyxtQkFBTyxDQUFDLHVKQUF1RDtBQUNyRyxtQkFBbUIsbUJBQU8sQ0FBQyxpR0FBNEI7QUFDdkQsYUFBYSxtQkFBTyxDQUFDLGtCQUFNO0FBQzNCLGlCQUFpQixtQkFBTyxDQUFDLGlGQUFvQjtBQUM3Qyx5QkFBeUIsbUJBQU8sQ0FBQyxpR0FBNEI7QUFDN0QsY0FBYyxtQkFBTyxDQUFDLDJEQUFTOztBQUUvQjs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixXQUFXLGlCQUFpQjtBQUM1QixXQUFXLGlCQUFpQjtBQUM1QixXQUFXLFNBQVM7QUFDcEIsV0FBVyxPQUFPO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsZ0JBQWdCO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7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O0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9hcHAxLy4vbm9kZV9tb2R1bGVzL21vbmdvb3NlL2xpYi9jYXN0LmpzP2YwZjUiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG4vKiFcbiAqIE1vZHVsZSBkZXBlbmRlbmNpZXMuXG4gKi9cblxuY29uc3QgQ2FzdEVycm9yID0gcmVxdWlyZSgnLi9lcnJvci9jYXN0Jyk7XG5jb25zdCBTdHJpY3RNb2RlRXJyb3IgPSByZXF1aXJlKCcuL2Vycm9yL3N0cmljdCcpO1xuY29uc3QgVHlwZXMgPSByZXF1aXJlKCcuL3NjaGVtYS9pbmRleCcpO1xuY29uc3QgY2FzdCRleHByID0gcmVxdWlyZSgnLi9oZWxwZXJzL3F1ZXJ5L2Nhc3QkZXhwcicpO1xuY29uc3QgY2FzdFRleHRTZWFyY2ggPSByZXF1aXJlKCcuL3NjaGVtYS9vcGVyYXRvcnMvdGV4dCcpO1xuY29uc3QgZ2V0ID0gcmVxdWlyZSgnLi9oZWxwZXJzL2dldCcpO1xuY29uc3QgZ2V0U2NoZW1hRGlzY3JpbWluYXRvckJ5VmFsdWUgPSByZXF1aXJlKCcuL2hlbHBlcnMvZGlzY3JpbWluYXRvci9nZXRTY2hlbWFEaXNjcmltaW5hdG9yQnlWYWx1ZScpO1xuY29uc3QgaXNPcGVyYXRvciA9IHJlcXVpcmUoJy4vaGVscGVycy9xdWVyeS9pc09wZXJhdG9yJyk7XG5jb25zdCB1dGlsID0gcmVxdWlyZSgndXRpbCcpO1xuY29uc3QgaXNPYmplY3QgPSByZXF1aXJlKCcuL2hlbHBlcnMvaXNPYmplY3QnKTtcbmNvbnN0IGlzTW9uZ29vc2VPYmplY3QgPSByZXF1aXJlKCcuL2hlbHBlcnMvaXNNb25nb29zZU9iamVjdCcpO1xuY29uc3QgdXRpbHMgPSByZXF1aXJlKCcuL3V0aWxzJyk7XG5cbmNvbnN0IEFMTE9XRURfR0VPV0lUSElOX0dFT0pTT05fVFlQRVMgPSBbJ1BvbHlnb24nLCAnTXVsdGlQb2x5Z29uJ107XG5cbi8qKlxuICogSGFuZGxlcyBpbnRlcm5hbCBjYXN0aW5nIGZvciBxdWVyeSBmaWx0ZXJzLlxuICpcbiAqIEBwYXJhbSB7U2NoZW1hfSBzY2hlbWFcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmogT2JqZWN0IHRvIGNhc3RcbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gdGhlIHF1ZXJ5IG9wdGlvbnNcbiAqIEBwYXJhbSB7Qm9vbGVhbnxcInRocm93XCJ9IFtvcHRpb25zLnN0cmljdF0gV2hldGVyIHRvIGVuYWJsZSBhbGwgc3RyaWN0IG9wdGlvbnNcbiAqIEBwYXJhbSB7Qm9vbGVhbnxcInRocm93XCJ9IFtvcHRpb25zLnN0cmljdFF1ZXJ5XSBFbmFibGUgc3RyaWN0IFF1ZXJpZXNcbiAqIEBwYXJhbSB7Qm9vbGVhbn0gW29wdGlvbnMudXBzZXJ0XVxuICogQHBhcmFtIHtRdWVyeX0gW2NvbnRleHRdIHBhc3NlZCB0byBzZXR0ZXJzXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBjYXN0KHNjaGVtYSwgb2JqLCBvcHRpb25zLCBjb250ZXh0KSB7XG4gIGlmIChBcnJheS5pc0FycmF5KG9iaikpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1F1ZXJ5IGZpbHRlciBtdXN0IGJlIGFuIG9iamVjdCwgZ290IGFuIGFycmF5ICcsIHV0aWwuaW5zcGVjdChvYmopKTtcbiAgfVxuXG4gIGlmIChvYmogPT0gbnVsbCkge1xuICAgIHJldHVybiBvYmo7XG4gIH1cblxuICBpZiAoc2NoZW1hICE9IG51bGwgJiYgc2NoZW1hLmRpc2NyaW1pbmF0b3JzICE9IG51bGwgJiYgb2JqW3NjaGVtYS5vcHRpb25zLmRpc2NyaW1pbmF0b3JLZXldICE9IG51bGwpIHtcbiAgICBzY2hlbWEgPSBnZXRTY2hlbWFEaXNjcmltaW5hdG9yQnlWYWx1ZShzY2hlbWEsIG9ialtzY2hlbWEub3B0aW9ucy5kaXNjcmltaW5hdG9yS2V5XSkgfHwgc2NoZW1hO1xuICB9XG5cbiAgY29uc3QgcGF0aHMgPSBPYmplY3Qua2V5cyhvYmopO1xuICBsZXQgaSA9IHBhdGhzLmxlbmd0aDtcbiAgbGV0IF9rZXlzO1xuICBsZXQgYW55JGNvbmRpdGlvbmFscztcbiAgbGV0IHNjaGVtYXR5cGU7XG4gIGxldCBuZXN0ZWQ7XG4gIGxldCBwYXRoO1xuICBsZXQgdHlwZTtcbiAgbGV0IHZhbDtcblxuICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcblxuICB3aGlsZSAoaS0tKSB7XG4gICAgcGF0aCA9IHBhdGhzW2ldO1xuICAgIHZhbCA9IG9ialtwYXRoXTtcblxuICAgIGlmIChwYXRoID09PSAnJG9yJyB8fCBwYXRoID09PSAnJG5vcicgfHwgcGF0aCA9PT0gJyRhbmQnKSB7XG4gICAgICBpZiAoIUFycmF5LmlzQXJyYXkodmFsKSkge1xuICAgICAgICB0aHJvdyBuZXcgQ2FzdEVycm9yKCdBcnJheScsIHZhbCwgcGF0aCk7XG4gICAgICB9XG4gICAgICBmb3IgKGxldCBrID0gMDsgayA8IHZhbC5sZW5ndGg7ICsraykge1xuICAgICAgICBpZiAodmFsW2tdID09IG51bGwgfHwgdHlwZW9mIHZhbFtrXSAhPT0gJ29iamVjdCcpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgQ2FzdEVycm9yKCdPYmplY3QnLCB2YWxba10sIHBhdGggKyAnLicgKyBrKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBkaXNjcmltaW5hdG9yVmFsdWUgPSB2YWxba11bc2NoZW1hLm9wdGlvbnMuZGlzY3JpbWluYXRvcktleV07XG4gICAgICAgIGlmIChkaXNjcmltaW5hdG9yVmFsdWUgPT0gbnVsbCkge1xuICAgICAgICAgIHZhbFtrXSA9IGNhc3Qoc2NoZW1hLCB2YWxba10sIG9wdGlvbnMsIGNvbnRleHQpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGNvbnN0IGRpc2NyaW1pbmF0b3JTY2hlbWEgPSBnZXRTY2hlbWFEaXNjcmltaW5hdG9yQnlWYWx1ZShjb250ZXh0LnNjaGVtYSwgZGlzY3JpbWluYXRvclZhbHVlKTtcbiAgICAgICAgICB2YWxba10gPSBjYXN0KGRpc2NyaW1pbmF0b3JTY2hlbWEgPyBkaXNjcmltaW5hdG9yU2NoZW1hIDogc2NoZW1hLCB2YWxba10sIG9wdGlvbnMsIGNvbnRleHQpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChwYXRoID09PSAnJHdoZXJlJykge1xuICAgICAgdHlwZSA9IHR5cGVvZiB2YWw7XG5cbiAgICAgIGlmICh0eXBlICE9PSAnc3RyaW5nJyAmJiB0eXBlICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignTXVzdCBoYXZlIGEgc3RyaW5nIG9yIGZ1bmN0aW9uIGZvciAkd2hlcmUnKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHR5cGUgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgb2JqW3BhdGhdID0gdmFsLnRvU3RyaW5nKCk7XG4gICAgICB9XG5cbiAgICAgIGNvbnRpbnVlO1xuICAgIH0gZWxzZSBpZiAocGF0aCA9PT0gJyRleHByJykge1xuICAgICAgdmFsID0gY2FzdCRleHByKHZhbCwgc2NoZW1hKTtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH0gZWxzZSBpZiAocGF0aCA9PT0gJyRlbGVtTWF0Y2gnKSB7XG4gICAgICB2YWwgPSBjYXN0KHNjaGVtYSwgdmFsLCBvcHRpb25zLCBjb250ZXh0KTtcbiAgICB9IGVsc2UgaWYgKHBhdGggPT09ICckdGV4dCcpIHtcbiAgICAgIHZhbCA9IGNhc3RUZXh0U2VhcmNoKHZhbCwgcGF0aCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmICghc2NoZW1hKSB7XG4gICAgICAgIC8vIG5vIGNhc3RpbmcgZm9yIE1peGVkIHR5cGVzXG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuXG4gICAgICBzY2hlbWF0eXBlID0gc2NoZW1hLnBhdGgocGF0aCk7XG5cbiAgICAgIC8vIENoZWNrIGZvciBlbWJlZGRlZCBkaXNjcmltaW5hdG9yIHBhdGhzXG4gICAgICBpZiAoIXNjaGVtYXR5cGUpIHtcbiAgICAgICAgY29uc3Qgc3BsaXQgPSBwYXRoLnNwbGl0KCcuJyk7XG4gICAgICAgIGxldCBqID0gc3BsaXQubGVuZ3RoO1xuICAgICAgICB3aGlsZSAoai0tKSB7XG4gICAgICAgICAgY29uc3QgcGF0aEZpcnN0SGFsZiA9IHNwbGl0LnNsaWNlKDAsIGopLmpvaW4oJy4nKTtcbiAgICAgICAgICBjb25zdCBwYXRoTGFzdEhhbGYgPSBzcGxpdC5zbGljZShqKS5qb2luKCcuJyk7XG4gICAgICAgICAgY29uc3QgX3NjaGVtYXR5cGUgPSBzY2hlbWEucGF0aChwYXRoRmlyc3RIYWxmKTtcbiAgICAgICAgICBjb25zdCBkaXNjcmltaW5hdG9yS2V5ID0gX3NjaGVtYXR5cGUgJiZcbiAgICAgICAgICAgIF9zY2hlbWF0eXBlLnNjaGVtYSAmJlxuICAgICAgICAgICAgX3NjaGVtYXR5cGUuc2NoZW1hLm9wdGlvbnMgJiZcbiAgICAgICAgICAgIF9zY2hlbWF0eXBlLnNjaGVtYS5vcHRpb25zLmRpc2NyaW1pbmF0b3JLZXk7XG5cbiAgICAgICAgICAvLyBnaC02MDI3OiBpZiB3ZSBoYXZlbid0IGZvdW5kIHRoZSBzY2hlbWF0eXBlIGJ1dCB0aGlzIHBhdGggaXNcbiAgICAgICAgICAvLyB1bmRlcm5lYXRoIGFuIGVtYmVkZGVkIGRpc2NyaW1pbmF0b3IgYW5kIHRoZSBlbWJlZGRlZCBkaXNjcmltaW5hdG9yXG4gICAgICAgICAgLy8ga2V5IGlzIGluIHRoZSBxdWVyeSwgdXNlIHRoZSBlbWJlZGRlZCBkaXNjcmltaW5hdG9yIHNjaGVtYVxuICAgICAgICAgIGlmIChfc2NoZW1hdHlwZSAhPSBudWxsICYmXG4gICAgICAgICAgICAoX3NjaGVtYXR5cGUuc2NoZW1hICYmIF9zY2hlbWF0eXBlLnNjaGVtYS5kaXNjcmltaW5hdG9ycykgIT0gbnVsbCAmJlxuICAgICAgICAgICAgZGlzY3JpbWluYXRvcktleSAhPSBudWxsICYmXG4gICAgICAgICAgICBwYXRoTGFzdEhhbGYgIT09IGRpc2NyaW1pbmF0b3JLZXkpIHtcbiAgICAgICAgICAgIGNvbnN0IGRpc2NyaW1pbmF0b3JWYWwgPSBnZXQob2JqLCBwYXRoRmlyc3RIYWxmICsgJy4nICsgZGlzY3JpbWluYXRvcktleSk7XG4gICAgICAgICAgICBjb25zdCBkaXNjcmltaW5hdG9ycyA9IF9zY2hlbWF0eXBlLnNjaGVtYS5kaXNjcmltaW5hdG9ycztcbiAgICAgICAgICAgIGlmICh0eXBlb2YgZGlzY3JpbWluYXRvclZhbCA9PT0gJ3N0cmluZycgJiYgZGlzY3JpbWluYXRvcnNbZGlzY3JpbWluYXRvclZhbF0gIT0gbnVsbCkge1xuXG4gICAgICAgICAgICAgIHNjaGVtYXR5cGUgPSBkaXNjcmltaW5hdG9yc1tkaXNjcmltaW5hdG9yVmFsXS5wYXRoKHBhdGhMYXN0SGFsZik7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGRpc2NyaW1pbmF0b3JWYWwgIT0gbnVsbCAmJlxuICAgICAgICAgICAgICBPYmplY3Qua2V5cyhkaXNjcmltaW5hdG9yVmFsKS5sZW5ndGggPT09IDEgJiZcbiAgICAgICAgICAgICAgQXJyYXkuaXNBcnJheShkaXNjcmltaW5hdG9yVmFsLiRpbikgJiZcbiAgICAgICAgICAgICAgZGlzY3JpbWluYXRvclZhbC4kaW4ubGVuZ3RoID09PSAxICYmXG4gICAgICAgICAgICAgIHR5cGVvZiBkaXNjcmltaW5hdG9yVmFsLiRpblswXSA9PT0gJ3N0cmluZycgJiZcbiAgICAgICAgICAgICAgZGlzY3JpbWluYXRvcnNbZGlzY3JpbWluYXRvclZhbC4kaW5bMF1dICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgc2NoZW1hdHlwZSA9IGRpc2NyaW1pbmF0b3JzW2Rpc2NyaW1pbmF0b3JWYWwuJGluWzBdXS5wYXRoKHBhdGhMYXN0SGFsZik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmICghc2NoZW1hdHlwZSkge1xuICAgICAgICAvLyBIYW5kbGUgcG90ZW50aWFsIGVtYmVkZGVkIGFycmF5IHF1ZXJpZXNcbiAgICAgICAgY29uc3Qgc3BsaXQgPSBwYXRoLnNwbGl0KCcuJyk7XG4gICAgICAgIGxldCBqID0gc3BsaXQubGVuZ3RoO1xuICAgICAgICBsZXQgcGF0aEZpcnN0SGFsZjtcbiAgICAgICAgbGV0IHBhdGhMYXN0SGFsZjtcbiAgICAgICAgbGV0IHJlbWFpbmluZ0NvbmRzO1xuXG4gICAgICAgIC8vIEZpbmQgdGhlIHBhcnQgb2YgdGhlIHZhciBwYXRoIHRoYXQgaXMgYSBwYXRoIG9mIHRoZSBTY2hlbWFcbiAgICAgICAgd2hpbGUgKGotLSkge1xuICAgICAgICAgIHBhdGhGaXJzdEhhbGYgPSBzcGxpdC5zbGljZSgwLCBqKS5qb2luKCcuJyk7XG4gICAgICAgICAgc2NoZW1hdHlwZSA9IHNjaGVtYS5wYXRoKHBhdGhGaXJzdEhhbGYpO1xuICAgICAgICAgIGlmIChzY2hlbWF0eXBlKSB7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBJZiBhIHN1YnN0cmluZyBvZiB0aGUgaW5wdXQgcGF0aCByZXNvbHZlcyB0byBhbiBhY3R1YWwgcmVhbCBwYXRoLi4uXG4gICAgICAgIGlmIChzY2hlbWF0eXBlKSB7XG4gICAgICAgICAgLy8gQXBwbHkgdGhlIGNhc3Rpbmc7IHNpbWlsYXIgY29kZSBmb3IgJGVsZW1NYXRjaCBpbiBzY2hlbWEvYXJyYXkuanNcbiAgICAgICAgICBpZiAoc2NoZW1hdHlwZS5jYXN0ZXIgJiYgc2NoZW1hdHlwZS5jYXN0ZXIuc2NoZW1hKSB7XG4gICAgICAgICAgICByZW1haW5pbmdDb25kcyA9IHt9O1xuICAgICAgICAgICAgcGF0aExhc3RIYWxmID0gc3BsaXQuc2xpY2Uoaikuam9pbignLicpO1xuICAgICAgICAgICAgcmVtYWluaW5nQ29uZHNbcGF0aExhc3RIYWxmXSA9IHZhbDtcblxuICAgICAgICAgICAgY29uc3QgcmV0ID0gY2FzdChzY2hlbWF0eXBlLmNhc3Rlci5zY2hlbWEsIHJlbWFpbmluZ0NvbmRzLCBvcHRpb25zLCBjb250ZXh0KVtwYXRoTGFzdEhhbGZdO1xuICAgICAgICAgICAgaWYgKHJldCA9PT0gdm9pZCAwKSB7XG4gICAgICAgICAgICAgIGRlbGV0ZSBvYmpbcGF0aF07XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBvYmpbcGF0aF0gPSByZXQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIG9ialtwYXRoXSA9IHZhbDtcbiAgICAgICAgICB9XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoaXNPYmplY3QodmFsKSkge1xuICAgICAgICAgIC8vIGhhbmRsZSBnZW8gc2NoZW1hcyB0aGF0IHVzZSBvYmplY3Qgbm90YXRpb25cbiAgICAgICAgICAvLyB7IGxvYzogeyBsb25nOiBOdW1iZXIsIGxhdDogTnVtYmVyIH1cblxuICAgICAgICAgIGxldCBnZW8gPSAnJztcbiAgICAgICAgICBpZiAodmFsLiRuZWFyKSB7XG4gICAgICAgICAgICBnZW8gPSAnJG5lYXInO1xuICAgICAgICAgIH0gZWxzZSBpZiAodmFsLiRuZWFyU3BoZXJlKSB7XG4gICAgICAgICAgICBnZW8gPSAnJG5lYXJTcGhlcmUnO1xuICAgICAgICAgIH0gZWxzZSBpZiAodmFsLiR3aXRoaW4pIHtcbiAgICAgICAgICAgIGdlbyA9ICckd2l0aGluJztcbiAgICAgICAgICB9IGVsc2UgaWYgKHZhbC4kZ2VvSW50ZXJzZWN0cykge1xuICAgICAgICAgICAgZ2VvID0gJyRnZW9JbnRlcnNlY3RzJztcbiAgICAgICAgICB9IGVsc2UgaWYgKHZhbC4kZ2VvV2l0aGluKSB7XG4gICAgICAgICAgICBnZW8gPSAnJGdlb1dpdGhpbic7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKGdlbykge1xuICAgICAgICAgICAgY29uc3QgbnVtYmVydHlwZSA9IG5ldyBUeXBlcy5OdW1iZXIoJ19fUXVlcnlDYXN0aW5nX18nKTtcbiAgICAgICAgICAgIGxldCB2YWx1ZSA9IHZhbFtnZW9dO1xuXG4gICAgICAgICAgICBpZiAodmFsLiRtYXhEaXN0YW5jZSAhPSBudWxsKSB7XG4gICAgICAgICAgICAgIHZhbC4kbWF4RGlzdGFuY2UgPSBudW1iZXJ0eXBlLmNhc3RGb3JRdWVyeShcbiAgICAgICAgICAgICAgICBudWxsLFxuICAgICAgICAgICAgICAgIHZhbC4kbWF4RGlzdGFuY2UsXG4gICAgICAgICAgICAgICAgY29udGV4dFxuICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHZhbC4kbWluRGlzdGFuY2UgIT0gbnVsbCkge1xuICAgICAgICAgICAgICB2YWwuJG1pbkRpc3RhbmNlID0gbnVtYmVydHlwZS5jYXN0Rm9yUXVlcnkoXG4gICAgICAgICAgICAgICAgbnVsbCxcbiAgICAgICAgICAgICAgICB2YWwuJG1pbkRpc3RhbmNlLFxuICAgICAgICAgICAgICAgIGNvbnRleHRcbiAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKGdlbyA9PT0gJyR3aXRoaW4nKSB7XG4gICAgICAgICAgICAgIGNvbnN0IHdpdGhpblR5cGUgPSB2YWx1ZS4kY2VudGVyXG4gICAgICAgICAgICAgICAgICB8fCB2YWx1ZS4kY2VudGVyU3BoZXJlXG4gICAgICAgICAgICAgICAgICB8fCB2YWx1ZS4kYm94XG4gICAgICAgICAgICAgICAgICB8fCB2YWx1ZS4kcG9seWdvbjtcblxuICAgICAgICAgICAgICBpZiAoIXdpdGhpblR5cGUpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0JhZCAkd2l0aGluIHBhcmFtZXRlcjogJyArIEpTT04uc3RyaW5naWZ5KHZhbCkpO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgdmFsdWUgPSB3aXRoaW5UeXBlO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChnZW8gPT09ICckbmVhcicgJiZcbiAgICAgICAgICAgICAgICB0eXBlb2YgdmFsdWUudHlwZSA9PT0gJ3N0cmluZycgJiYgQXJyYXkuaXNBcnJheSh2YWx1ZS5jb29yZGluYXRlcykpIHtcbiAgICAgICAgICAgICAgLy8gZ2VvanNvbjsgY2FzdCB0aGUgY29vcmRpbmF0ZXNcbiAgICAgICAgICAgICAgdmFsdWUgPSB2YWx1ZS5jb29yZGluYXRlcztcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoKGdlbyA9PT0gJyRuZWFyJyB8fCBnZW8gPT09ICckbmVhclNwaGVyZScgfHwgZ2VvID09PSAnJGdlb0ludGVyc2VjdHMnKSAmJlxuICAgICAgICAgICAgICAgIHZhbHVlLiRnZW9tZXRyeSAmJiB0eXBlb2YgdmFsdWUuJGdlb21ldHJ5LnR5cGUgPT09ICdzdHJpbmcnICYmXG4gICAgICAgICAgICAgICAgQXJyYXkuaXNBcnJheSh2YWx1ZS4kZ2VvbWV0cnkuY29vcmRpbmF0ZXMpKSB7XG4gICAgICAgICAgICAgIGlmICh2YWx1ZS4kbWF4RGlzdGFuY2UgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHZhbHVlLiRtYXhEaXN0YW5jZSA9IG51bWJlcnR5cGUuY2FzdEZvclF1ZXJ5KFxuICAgICAgICAgICAgICAgICAgbnVsbCxcbiAgICAgICAgICAgICAgICAgIHZhbHVlLiRtYXhEaXN0YW5jZSxcbiAgICAgICAgICAgICAgICAgIGNvbnRleHRcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGlmICh2YWx1ZS4kbWluRGlzdGFuY2UgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHZhbHVlLiRtaW5EaXN0YW5jZSA9IG51bWJlcnR5cGUuY2FzdEZvclF1ZXJ5KFxuICAgICAgICAgICAgICAgICAgbnVsbCxcbiAgICAgICAgICAgICAgICAgIHZhbHVlLiRtaW5EaXN0YW5jZSxcbiAgICAgICAgICAgICAgICAgIGNvbnRleHRcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGlmIChpc01vbmdvb3NlT2JqZWN0KHZhbHVlLiRnZW9tZXRyeSkpIHtcbiAgICAgICAgICAgICAgICB2YWx1ZS4kZ2VvbWV0cnkgPSB2YWx1ZS4kZ2VvbWV0cnkudG9PYmplY3Qoe1xuICAgICAgICAgICAgICAgICAgdHJhbnNmb3JtOiBmYWxzZSxcbiAgICAgICAgICAgICAgICAgIHZpcnR1YWxzOiBmYWxzZVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHZhbHVlID0gdmFsdWUuJGdlb21ldHJ5LmNvb3JkaW5hdGVzO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChnZW8gPT09ICckZ2VvV2l0aGluJykge1xuICAgICAgICAgICAgICBpZiAodmFsdWUuJGdlb21ldHJ5KSB7XG4gICAgICAgICAgICAgICAgaWYgKGlzTW9uZ29vc2VPYmplY3QodmFsdWUuJGdlb21ldHJ5KSkge1xuICAgICAgICAgICAgICAgICAgdmFsdWUuJGdlb21ldHJ5ID0gdmFsdWUuJGdlb21ldHJ5LnRvT2JqZWN0KHsgdmlydHVhbHM6IGZhbHNlIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb25zdCBnZW9XaXRoaW5UeXBlID0gdmFsdWUuJGdlb21ldHJ5LnR5cGU7XG4gICAgICAgICAgICAgICAgaWYgKEFMTE9XRURfR0VPV0lUSElOX0dFT0pTT05fVFlQRVMuaW5kZXhPZihnZW9XaXRoaW5UeXBlKSA9PT0gLTEpIHtcbiAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBnZW9KU09OIHR5cGUgZm9yICRnZW9XaXRoaW4gXCInICtcbiAgICAgICAgICAgICAgICAgICAgZ2VvV2l0aGluVHlwZSArICdcIiwgbXVzdCBiZSBcIlBvbHlnb25cIiBvciBcIk11bHRpUG9seWdvblwiJyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHZhbHVlID0gdmFsdWUuJGdlb21ldHJ5LmNvb3JkaW5hdGVzO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHZhbHVlID0gdmFsdWUuJGJveCB8fCB2YWx1ZS4kcG9seWdvbiB8fCB2YWx1ZS4kY2VudGVyIHx8XG4gICAgICAgICAgICAgICAgICB2YWx1ZS4kY2VudGVyU3BoZXJlO1xuICAgICAgICAgICAgICAgIGlmIChpc01vbmdvb3NlT2JqZWN0KHZhbHVlKSkge1xuICAgICAgICAgICAgICAgICAgdmFsdWUgPSB2YWx1ZS50b09iamVjdCh7IHZpcnR1YWxzOiBmYWxzZSB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgX2Nhc3QodmFsdWUsIG51bWJlcnR5cGUsIGNvbnRleHQpO1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHNjaGVtYS5uZXN0ZWRbcGF0aF0pIHtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IHN0cmljdCA9ICdzdHJpY3QnIGluIG9wdGlvbnMgPyBvcHRpb25zLnN0cmljdCA6IHNjaGVtYS5vcHRpb25zLnN0cmljdDtcbiAgICAgICAgY29uc3Qgc3RyaWN0UXVlcnkgPSBnZXRTdHJpY3RRdWVyeShvcHRpb25zLCBzY2hlbWEuX3VzZXJQcm92aWRlZE9wdGlvbnMsIHNjaGVtYS5vcHRpb25zLCBjb250ZXh0KTtcbiAgICAgICAgaWYgKG9wdGlvbnMudXBzZXJ0ICYmIHN0cmljdCkge1xuICAgICAgICAgIGlmIChzdHJpY3QgPT09ICd0aHJvdycpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBTdHJpY3RNb2RlRXJyb3IocGF0aCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHRocm93IG5ldyBTdHJpY3RNb2RlRXJyb3IocGF0aCwgJ1BhdGggXCInICsgcGF0aCArICdcIiBpcyBub3QgaW4gJyArXG4gICAgICAgICAgICAnc2NoZW1hLCBzdHJpY3QgbW9kZSBpcyBgdHJ1ZWAsIGFuZCB1cHNlcnQgaXMgYHRydWVgLicpO1xuICAgICAgICB9IGlmIChzdHJpY3RRdWVyeSA9PT0gJ3Rocm93Jykge1xuICAgICAgICAgIHRocm93IG5ldyBTdHJpY3RNb2RlRXJyb3IocGF0aCwgJ1BhdGggXCInICsgcGF0aCArICdcIiBpcyBub3QgaW4gJyArXG4gICAgICAgICAgICAnc2NoZW1hIGFuZCBzdHJpY3RRdWVyeSBpcyBcXCd0aHJvd1xcJy4nKTtcbiAgICAgICAgfSBlbHNlIGlmIChzdHJpY3RRdWVyeSkge1xuICAgICAgICAgIGRlbGV0ZSBvYmpbcGF0aF07XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAodmFsID09IG51bGwpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9IGVsc2UgaWYgKHV0aWxzLmlzUE9KTyh2YWwpKSB7XG4gICAgICAgIGFueSRjb25kaXRpb25hbHMgPSBPYmplY3Qua2V5cyh2YWwpLnNvbWUoaXNPcGVyYXRvcik7XG5cbiAgICAgICAgaWYgKCFhbnkkY29uZGl0aW9uYWxzKSB7XG4gICAgICAgICAgb2JqW3BhdGhdID0gc2NoZW1hdHlwZS5jYXN0Rm9yUXVlcnkoXG4gICAgICAgICAgICBudWxsLFxuICAgICAgICAgICAgdmFsLFxuICAgICAgICAgICAgY29udGV4dFxuICAgICAgICAgICk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY29uc3Qga3MgPSBPYmplY3Qua2V5cyh2YWwpO1xuICAgICAgICAgIGxldCAkY29uZDtcbiAgICAgICAgICBsZXQgayA9IGtzLmxlbmd0aDtcblxuICAgICAgICAgIHdoaWxlIChrLS0pIHtcbiAgICAgICAgICAgICRjb25kID0ga3Nba107XG4gICAgICAgICAgICBuZXN0ZWQgPSB2YWxbJGNvbmRdO1xuICAgICAgICAgICAgaWYgKCRjb25kID09PSAnJGVsZW1NYXRjaCcpIHtcbiAgICAgICAgICAgICAgaWYgKG5lc3RlZCAmJiBzY2hlbWF0eXBlICE9IG51bGwgJiYgc2NoZW1hdHlwZS5zY2hlbWEgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGNhc3Qoc2NoZW1hdHlwZS5zY2hlbWEsIG5lc3RlZCwgb3B0aW9ucywgY29udGV4dCk7XG4gICAgICAgICAgICAgIH0gZWxzZSBpZiAobmVzdGVkICYmIHNjaGVtYXR5cGUgIT0gbnVsbCAmJiBzY2hlbWF0eXBlLiRpc01vbmdvb3NlQXJyYXkpIHtcbiAgICAgICAgICAgICAgICBpZiAodXRpbHMuaXNQT0pPKG5lc3RlZCkgJiYgbmVzdGVkLiRub3QgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgY2FzdChzY2hlbWEsIG5lc3RlZCwgb3B0aW9ucywgY29udGV4dCk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgIHZhbFskY29uZF0gPSBzY2hlbWF0eXBlLmNhc3RGb3JRdWVyeShcbiAgICAgICAgICAgICAgICAgICAgJGNvbmQsXG4gICAgICAgICAgICAgICAgICAgIG5lc3RlZCxcbiAgICAgICAgICAgICAgICAgICAgY29udGV4dFxuICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSBpZiAoJGNvbmQgPT09ICckbm90Jykge1xuICAgICAgICAgICAgICBpZiAobmVzdGVkICYmIHNjaGVtYXR5cGUpIHtcbiAgICAgICAgICAgICAgICBfa2V5cyA9IE9iamVjdC5rZXlzKG5lc3RlZCk7XG4gICAgICAgICAgICAgICAgaWYgKF9rZXlzLmxlbmd0aCAmJiBpc09wZXJhdG9yKF9rZXlzWzBdKSkge1xuICAgICAgICAgICAgICAgICAgZm9yIChjb25zdCBrZXkgaW4gbmVzdGVkKSB7XG4gICAgICAgICAgICAgICAgICAgIG5lc3RlZFtrZXldID0gc2NoZW1hdHlwZS5jYXN0Rm9yUXVlcnkoXG4gICAgICAgICAgICAgICAgICAgICAga2V5LFxuICAgICAgICAgICAgICAgICAgICAgIG5lc3RlZFtrZXldLFxuICAgICAgICAgICAgICAgICAgICAgIGNvbnRleHRcbiAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgdmFsWyRjb25kXSA9IHNjaGVtYXR5cGUuY2FzdEZvclF1ZXJ5KFxuICAgICAgICAgICAgICAgICAgICAkY29uZCxcbiAgICAgICAgICAgICAgICAgICAgbmVzdGVkLFxuICAgICAgICAgICAgICAgICAgICBjb250ZXh0XG4gICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgdmFsWyRjb25kXSA9IHNjaGVtYXR5cGUuY2FzdEZvclF1ZXJ5KFxuICAgICAgICAgICAgICAgICRjb25kLFxuICAgICAgICAgICAgICAgIG5lc3RlZCxcbiAgICAgICAgICAgICAgICBjb250ZXh0XG4gICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoQXJyYXkuaXNBcnJheSh2YWwpICYmIFsnQnVmZmVyJywgJ0FycmF5J10uaW5kZXhPZihzY2hlbWF0eXBlLmluc3RhbmNlKSA9PT0gLTEpIHtcbiAgICAgICAgY29uc3QgY2FzdGVkID0gW107XG4gICAgICAgIGNvbnN0IHZhbHVlc0FycmF5ID0gdmFsO1xuXG4gICAgICAgIGZvciAoY29uc3QgX3ZhbCBvZiB2YWx1ZXNBcnJheSkge1xuICAgICAgICAgIGNhc3RlZC5wdXNoKHNjaGVtYXR5cGUuY2FzdEZvclF1ZXJ5KFxuICAgICAgICAgICAgbnVsbCxcbiAgICAgICAgICAgIF92YWwsXG4gICAgICAgICAgICBjb250ZXh0XG4gICAgICAgICAgKSk7XG4gICAgICAgIH1cblxuICAgICAgICBvYmpbcGF0aF0gPSB7ICRpbjogY2FzdGVkIH07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBvYmpbcGF0aF0gPSBzY2hlbWF0eXBlLmNhc3RGb3JRdWVyeShcbiAgICAgICAgICBudWxsLFxuICAgICAgICAgIHZhbCxcbiAgICAgICAgICBjb250ZXh0XG4gICAgICAgICk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG9iajtcbn07XG5cbmZ1bmN0aW9uIF9jYXN0KHZhbCwgbnVtYmVydHlwZSwgY29udGV4dCkge1xuICBpZiAoQXJyYXkuaXNBcnJheSh2YWwpKSB7XG4gICAgdmFsLmZvckVhY2goZnVuY3Rpb24oaXRlbSwgaSkge1xuICAgICAgaWYgKEFycmF5LmlzQXJyYXkoaXRlbSkgfHwgaXNPYmplY3QoaXRlbSkpIHtcbiAgICAgICAgcmV0dXJuIF9jYXN0KGl0ZW0sIG51bWJlcnR5cGUsIGNvbnRleHQpO1xuICAgICAgfVxuICAgICAgdmFsW2ldID0gbnVtYmVydHlwZS5jYXN0Rm9yUXVlcnkobnVsbCwgaXRlbSwgY29udGV4dCk7XG4gICAgfSk7XG4gIH0gZWxzZSB7XG4gICAgY29uc3QgbmVhcktleXMgPSBPYmplY3Qua2V5cyh2YWwpO1xuICAgIGxldCBuZWFyTGVuID0gbmVhcktleXMubGVuZ3RoO1xuICAgIHdoaWxlIChuZWFyTGVuLS0pIHtcbiAgICAgIGNvbnN0IG5rZXkgPSBuZWFyS2V5c1tuZWFyTGVuXTtcbiAgICAgIGNvbnN0IGl0ZW0gPSB2YWxbbmtleV07XG4gICAgICBpZiAoQXJyYXkuaXNBcnJheShpdGVtKSB8fCBpc09iamVjdChpdGVtKSkge1xuICAgICAgICBfY2FzdChpdGVtLCBudW1iZXJ0eXBlLCBjb250ZXh0KTtcbiAgICAgICAgdmFsW25rZXldID0gaXRlbTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhbFtua2V5XSA9IG51bWJlcnR5cGUuY2FzdEZvclF1ZXJ5KHsgdmFsOiBpdGVtLCBjb250ZXh0OiBjb250ZXh0IH0pO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBnZXRTdHJpY3RRdWVyeShxdWVyeU9wdGlvbnMsIHNjaGVtYVVzZXJQcm92aWRlZE9wdGlvbnMsIHNjaGVtYU9wdGlvbnMsIGNvbnRleHQpIHtcbiAgaWYgKCdzdHJpY3RRdWVyeScgaW4gcXVlcnlPcHRpb25zKSB7XG4gICAgcmV0dXJuIHF1ZXJ5T3B0aW9ucy5zdHJpY3RRdWVyeTtcbiAgfVxuICBpZiAoJ3N0cmljdFF1ZXJ5JyBpbiBzY2hlbWFVc2VyUHJvdmlkZWRPcHRpb25zKSB7XG4gICAgcmV0dXJuIHNjaGVtYVVzZXJQcm92aWRlZE9wdGlvbnMuc3RyaWN0UXVlcnk7XG4gIH1cbiAgY29uc3QgbW9uZ29vc2VPcHRpb25zID0gY29udGV4dCAmJlxuICAgIGNvbnRleHQubW9uZ29vc2VDb2xsZWN0aW9uICYmXG4gICAgY29udGV4dC5tb25nb29zZUNvbGxlY3Rpb24uY29ubiAmJlxuICAgIGNvbnRleHQubW9uZ29vc2VDb2xsZWN0aW9uLmNvbm4uYmFzZSAmJlxuICAgIGNvbnRleHQubW9uZ29vc2VDb2xsZWN0aW9uLmNvbm4uYmFzZS5vcHRpb25zO1xuICBpZiAobW9uZ29vc2VPcHRpb25zKSB7XG4gICAgaWYgKCdzdHJpY3RRdWVyeScgaW4gbW9uZ29vc2VPcHRpb25zKSB7XG4gICAgICByZXR1cm4gbW9uZ29vc2VPcHRpb25zLnN0cmljdFF1ZXJ5O1xuICAgIH1cbiAgfVxuICByZXR1cm4gc2NoZW1hT3B0aW9ucy5zdHJpY3RRdWVyeTtcbn1cbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/mongoose/lib/cast.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/mongoose/lib/cast/bigint.js":
/*!**************************************************!*\
  !*** ./node_modules/mongoose/lib/cast/bigint.js ***!
  \**************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\n\nconst assert = __webpack_require__(/*! assert */ \"assert\");\nconst { Long } = __webpack_require__(/*! bson */ \"(ssr)/./node_modules/bson/lib/bson.cjs\");\n\n/**\n * Given a value, cast it to a BigInt, or throw an `Error` if the value\n * cannot be casted. `null` and `undefined` are considered valid.\n *\n * @param {Any} value\n * @return {Number}\n * @throws {Error} if `value` is not one of the allowed values\n * @api private\n */\n\nmodule.exports = function castBigInt(val) {\n  if (val == null) {\n    return val;\n  }\n  if (val === '') {\n    return null;\n  }\n  if (typeof val === 'bigint') {\n    return val;\n  }\n\n  if (val instanceof Long) {\n    return val.toBigInt();\n  }\n\n  if (typeof val === 'string' || typeof val === 'number') {\n    return BigInt(val);\n  }\n\n  assert.ok(false);\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbW9uZ29vc2UvbGliL2Nhc3QvYmlnaW50LmpzIiwibWFwcGluZ3MiOiJBQUFhOztBQUViLGVBQWUsbUJBQU8sQ0FBQyxzQkFBUTtBQUMvQixRQUFRLE9BQU8sRUFBRSxtQkFBTyxDQUFDLG9EQUFNOztBQUUvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsS0FBSztBQUNoQixZQUFZO0FBQ1osWUFBWSxPQUFPO0FBQ25CO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vYXBwMS8uL25vZGVfbW9kdWxlcy9tb25nb29zZS9saWIvY2FzdC9iaWdpbnQuanM/OGI4ZCJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbmNvbnN0IGFzc2VydCA9IHJlcXVpcmUoJ2Fzc2VydCcpO1xuY29uc3QgeyBMb25nIH0gPSByZXF1aXJlKCdic29uJyk7XG5cbi8qKlxuICogR2l2ZW4gYSB2YWx1ZSwgY2FzdCBpdCB0byBhIEJpZ0ludCwgb3IgdGhyb3cgYW4gYEVycm9yYCBpZiB0aGUgdmFsdWVcbiAqIGNhbm5vdCBiZSBjYXN0ZWQuIGBudWxsYCBhbmQgYHVuZGVmaW5lZGAgYXJlIGNvbnNpZGVyZWQgdmFsaWQuXG4gKlxuICogQHBhcmFtIHtBbnl9IHZhbHVlXG4gKiBAcmV0dXJuIHtOdW1iZXJ9XG4gKiBAdGhyb3dzIHtFcnJvcn0gaWYgYHZhbHVlYCBpcyBub3Qgb25lIG9mIHRoZSBhbGxvd2VkIHZhbHVlc1xuICogQGFwaSBwcml2YXRlXG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBjYXN0QmlnSW50KHZhbCkge1xuICBpZiAodmFsID09IG51bGwpIHtcbiAgICByZXR1cm4gdmFsO1xuICB9XG4gIGlmICh2YWwgPT09ICcnKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgaWYgKHR5cGVvZiB2YWwgPT09ICdiaWdpbnQnKSB7XG4gICAgcmV0dXJuIHZhbDtcbiAgfVxuXG4gIGlmICh2YWwgaW5zdGFuY2VvZiBMb25nKSB7XG4gICAgcmV0dXJuIHZhbC50b0JpZ0ludCgpO1xuICB9XG5cbiAgaWYgKHR5cGVvZiB2YWwgPT09ICdzdHJpbmcnIHx8IHR5cGVvZiB2YWwgPT09ICdudW1iZXInKSB7XG4gICAgcmV0dXJuIEJpZ0ludCh2YWwpO1xuICB9XG5cbiAgYXNzZXJ0Lm9rKGZhbHNlKTtcbn07XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/mongoose/lib/cast/bigint.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/mongoose/lib/cast/boolean.js":
/*!***************************************************!*\
  !*** ./node_modules/mongoose/lib/cast/boolean.js ***!
  \***************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\n\nconst CastError = __webpack_require__(/*! ../error/cast */ \"(ssr)/./node_modules/mongoose/lib/error/cast.js\");\n\n/**\n * Given a value, cast it to a boolean, or throw a `CastError` if the value\n * cannot be casted. `null` and `undefined` are considered valid.\n *\n * @param {Any} value\n * @param {String} [path] optional the path to set on the CastError\n * @return {Boolean|null|undefined}\n * @throws {CastError} if `value` is not one of the allowed values\n * @api private\n */\n\nmodule.exports = function castBoolean(value, path) {\n  if (module.exports.convertToTrue.has(value)) {\n    return true;\n  }\n  if (module.exports.convertToFalse.has(value)) {\n    return false;\n  }\n\n  if (value == null) {\n    return value;\n  }\n\n  throw new CastError('boolean', value, path);\n};\n\nmodule.exports.convertToTrue = new Set([true, 'true', 1, '1', 'yes']);\nmodule.exports.convertToFalse = new Set([false, 'false', 0, '0', 'no']);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbW9uZ29vc2UvbGliL2Nhc3QvYm9vbGVhbi5qcyIsIm1hcHBpbmdzIjoiQUFBYTs7QUFFYixrQkFBa0IsbUJBQU8sQ0FBQyxzRUFBZTs7QUFFekM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLEtBQUs7QUFDaEIsV0FBVyxRQUFRO0FBQ25CLFlBQVk7QUFDWixZQUFZLFdBQVc7QUFDdkI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSw0QkFBNEI7QUFDNUIsNkJBQTZCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vYXBwMS8uL25vZGVfbW9kdWxlcy9tb25nb29zZS9saWIvY2FzdC9ib29sZWFuLmpzPzIzNDciXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG5jb25zdCBDYXN0RXJyb3IgPSByZXF1aXJlKCcuLi9lcnJvci9jYXN0Jyk7XG5cbi8qKlxuICogR2l2ZW4gYSB2YWx1ZSwgY2FzdCBpdCB0byBhIGJvb2xlYW4sIG9yIHRocm93IGEgYENhc3RFcnJvcmAgaWYgdGhlIHZhbHVlXG4gKiBjYW5ub3QgYmUgY2FzdGVkLiBgbnVsbGAgYW5kIGB1bmRlZmluZWRgIGFyZSBjb25zaWRlcmVkIHZhbGlkLlxuICpcbiAqIEBwYXJhbSB7QW55fSB2YWx1ZVxuICogQHBhcmFtIHtTdHJpbmd9IFtwYXRoXSBvcHRpb25hbCB0aGUgcGF0aCB0byBzZXQgb24gdGhlIENhc3RFcnJvclxuICogQHJldHVybiB7Qm9vbGVhbnxudWxsfHVuZGVmaW5lZH1cbiAqIEB0aHJvd3Mge0Nhc3RFcnJvcn0gaWYgYHZhbHVlYCBpcyBub3Qgb25lIG9mIHRoZSBhbGxvd2VkIHZhbHVlc1xuICogQGFwaSBwcml2YXRlXG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBjYXN0Qm9vbGVhbih2YWx1ZSwgcGF0aCkge1xuICBpZiAobW9kdWxlLmV4cG9ydHMuY29udmVydFRvVHJ1ZS5oYXModmFsdWUpKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgaWYgKG1vZHVsZS5leHBvcnRzLmNvbnZlcnRUb0ZhbHNlLmhhcyh2YWx1ZSkpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBpZiAodmFsdWUgPT0gbnVsbCkge1xuICAgIHJldHVybiB2YWx1ZTtcbiAgfVxuXG4gIHRocm93IG5ldyBDYXN0RXJyb3IoJ2Jvb2xlYW4nLCB2YWx1ZSwgcGF0aCk7XG59O1xuXG5tb2R1bGUuZXhwb3J0cy5jb252ZXJ0VG9UcnVlID0gbmV3IFNldChbdHJ1ZSwgJ3RydWUnLCAxLCAnMScsICd5ZXMnXSk7XG5tb2R1bGUuZXhwb3J0cy5jb252ZXJ0VG9GYWxzZSA9IG5ldyBTZXQoW2ZhbHNlLCAnZmFsc2UnLCAwLCAnMCcsICdubyddKTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/mongoose/lib/cast/boolean.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/mongoose/lib/cast/date.js":
/*!************************************************!*\
  !*** ./node_modules/mongoose/lib/cast/date.js ***!
  \************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\n\nconst assert = __webpack_require__(/*! assert */ \"assert\");\n\nmodule.exports = function castDate(value) {\n  // Support empty string because of empty form values. Originally introduced\n  // in https://github.com/Automattic/mongoose/commit/efc72a1898fc3c33a319d915b8c5463a22938dfe\n  if (value == null || value === '') {\n    return null;\n  }\n\n  if (value instanceof Date) {\n    assert.ok(!isNaN(value.valueOf()));\n\n    return value;\n  }\n\n  let date;\n\n  assert.ok(typeof value !== 'boolean');\n\n  if (value instanceof Number || typeof value === 'number') {\n    date = new Date(value);\n  } else if (typeof value === 'string' && !isNaN(Number(value)) && (Number(value) >= 275761 || Number(value) < -271820)) {\n    // string representation of milliseconds take this path\n    date = new Date(Number(value));\n  } else if (typeof value.valueOf === 'function') {\n    // support for moment.js. This is also the path strings will take because\n    // strings have a `valueOf()`\n    date = new Date(value.valueOf());\n  } else {\n    // fallback\n    date = new Date(value);\n  }\n\n  if (!isNaN(date.valueOf())) {\n    return date;\n  }\n\n  assert.ok(false);\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbW9uZ29vc2UvbGliL2Nhc3QvZGF0ZS5qcyIsIm1hcHBpbmdzIjoiQUFBYTs7QUFFYixlQUFlLG1CQUFPLENBQUMsc0JBQVE7O0FBRS9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9hcHAxLy4vbm9kZV9tb2R1bGVzL21vbmdvb3NlL2xpYi9jYXN0L2RhdGUuanM/NjcwNSJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbmNvbnN0IGFzc2VydCA9IHJlcXVpcmUoJ2Fzc2VydCcpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGNhc3REYXRlKHZhbHVlKSB7XG4gIC8vIFN1cHBvcnQgZW1wdHkgc3RyaW5nIGJlY2F1c2Ugb2YgZW1wdHkgZm9ybSB2YWx1ZXMuIE9yaWdpbmFsbHkgaW50cm9kdWNlZFxuICAvLyBpbiBodHRwczovL2dpdGh1Yi5jb20vQXV0b21hdHRpYy9tb25nb29zZS9jb21taXQvZWZjNzJhMTg5OGZjM2MzM2EzMTlkOTE1YjhjNTQ2M2EyMjkzOGRmZVxuICBpZiAodmFsdWUgPT0gbnVsbCB8fCB2YWx1ZSA9PT0gJycpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIGlmICh2YWx1ZSBpbnN0YW5jZW9mIERhdGUpIHtcbiAgICBhc3NlcnQub2soIWlzTmFOKHZhbHVlLnZhbHVlT2YoKSkpO1xuXG4gICAgcmV0dXJuIHZhbHVlO1xuICB9XG5cbiAgbGV0IGRhdGU7XG5cbiAgYXNzZXJ0Lm9rKHR5cGVvZiB2YWx1ZSAhPT0gJ2Jvb2xlYW4nKTtcblxuICBpZiAodmFsdWUgaW5zdGFuY2VvZiBOdW1iZXIgfHwgdHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJykge1xuICAgIGRhdGUgPSBuZXcgRGF0ZSh2YWx1ZSk7XG4gIH0gZWxzZSBpZiAodHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJyAmJiAhaXNOYU4oTnVtYmVyKHZhbHVlKSkgJiYgKE51bWJlcih2YWx1ZSkgPj0gMjc1NzYxIHx8IE51bWJlcih2YWx1ZSkgPCAtMjcxODIwKSkge1xuICAgIC8vIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiBtaWxsaXNlY29uZHMgdGFrZSB0aGlzIHBhdGhcbiAgICBkYXRlID0gbmV3IERhdGUoTnVtYmVyKHZhbHVlKSk7XG4gIH0gZWxzZSBpZiAodHlwZW9mIHZhbHVlLnZhbHVlT2YgPT09ICdmdW5jdGlvbicpIHtcbiAgICAvLyBzdXBwb3J0IGZvciBtb21lbnQuanMuIFRoaXMgaXMgYWxzbyB0aGUgcGF0aCBzdHJpbmdzIHdpbGwgdGFrZSBiZWNhdXNlXG4gICAgLy8gc3RyaW5ncyBoYXZlIGEgYHZhbHVlT2YoKWBcbiAgICBkYXRlID0gbmV3IERhdGUodmFsdWUudmFsdWVPZigpKTtcbiAgfSBlbHNlIHtcbiAgICAvLyBmYWxsYmFja1xuICAgIGRhdGUgPSBuZXcgRGF0ZSh2YWx1ZSk7XG4gIH1cblxuICBpZiAoIWlzTmFOKGRhdGUudmFsdWVPZigpKSkge1xuICAgIHJldHVybiBkYXRlO1xuICB9XG5cbiAgYXNzZXJ0Lm9rKGZhbHNlKTtcbn07XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/mongoose/lib/cast/date.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/mongoose/lib/cast/decimal128.js":
/*!******************************************************!*\
  !*** ./node_modules/mongoose/lib/cast/decimal128.js ***!
  \******************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\n\nconst Decimal128Type = __webpack_require__(/*! ../types/decimal128 */ \"(ssr)/./node_modules/mongoose/lib/types/decimal128.js\");\nconst assert = __webpack_require__(/*! assert */ \"assert\");\n\nmodule.exports = function castDecimal128(value) {\n  if (value == null) {\n    return value;\n  }\n\n  if (typeof value === 'object' && typeof value.$numberDecimal === 'string') {\n    return Decimal128Type.fromString(value.$numberDecimal);\n  }\n\n  if (value instanceof Decimal128Type) {\n    return value;\n  }\n\n  if (typeof value === 'string') {\n    return Decimal128Type.fromString(value);\n  }\n\n  if (typeof Buffer === 'function' && Buffer.isBuffer(value)) {\n    return new Decimal128Type(value);\n  }\n  if (typeof Uint8Array === 'function' && value instanceof Uint8Array) {\n    return new Decimal128Type(value);\n  }\n\n  if (typeof value === 'number') {\n    return Decimal128Type.fromString(String(value));\n  }\n\n  if (typeof value.valueOf === 'function' && typeof value.valueOf() === 'string') {\n    return Decimal128Type.fromString(value.valueOf());\n  }\n\n  assert.ok(false);\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbW9uZ29vc2UvbGliL2Nhc3QvZGVjaW1hbDEyOC5qcyIsIm1hcHBpbmdzIjoiQUFBYTs7QUFFYix1QkFBdUIsbUJBQU8sQ0FBQyxrRkFBcUI7QUFDcEQsZUFBZSxtQkFBTyxDQUFDLHNCQUFROztBQUUvQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vYXBwMS8uL25vZGVfbW9kdWxlcy9tb25nb29zZS9saWIvY2FzdC9kZWNpbWFsMTI4LmpzP2UyOTEiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG5jb25zdCBEZWNpbWFsMTI4VHlwZSA9IHJlcXVpcmUoJy4uL3R5cGVzL2RlY2ltYWwxMjgnKTtcbmNvbnN0IGFzc2VydCA9IHJlcXVpcmUoJ2Fzc2VydCcpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGNhc3REZWNpbWFsMTI4KHZhbHVlKSB7XG4gIGlmICh2YWx1ZSA9PSBudWxsKSB7XG4gICAgcmV0dXJuIHZhbHVlO1xuICB9XG5cbiAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIHZhbHVlLiRudW1iZXJEZWNpbWFsID09PSAnc3RyaW5nJykge1xuICAgIHJldHVybiBEZWNpbWFsMTI4VHlwZS5mcm9tU3RyaW5nKHZhbHVlLiRudW1iZXJEZWNpbWFsKTtcbiAgfVxuXG4gIGlmICh2YWx1ZSBpbnN0YW5jZW9mIERlY2ltYWwxMjhUeXBlKSB7XG4gICAgcmV0dXJuIHZhbHVlO1xuICB9XG5cbiAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycpIHtcbiAgICByZXR1cm4gRGVjaW1hbDEyOFR5cGUuZnJvbVN0cmluZyh2YWx1ZSk7XG4gIH1cblxuICBpZiAodHlwZW9mIEJ1ZmZlciA9PT0gJ2Z1bmN0aW9uJyAmJiBCdWZmZXIuaXNCdWZmZXIodmFsdWUpKSB7XG4gICAgcmV0dXJuIG5ldyBEZWNpbWFsMTI4VHlwZSh2YWx1ZSk7XG4gIH1cbiAgaWYgKHR5cGVvZiBVaW50OEFycmF5ID09PSAnZnVuY3Rpb24nICYmIHZhbHVlIGluc3RhbmNlb2YgVWludDhBcnJheSkge1xuICAgIHJldHVybiBuZXcgRGVjaW1hbDEyOFR5cGUodmFsdWUpO1xuICB9XG5cbiAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcicpIHtcbiAgICByZXR1cm4gRGVjaW1hbDEyOFR5cGUuZnJvbVN0cmluZyhTdHJpbmcodmFsdWUpKTtcbiAgfVxuXG4gIGlmICh0eXBlb2YgdmFsdWUudmFsdWVPZiA9PT0gJ2Z1bmN0aW9uJyAmJiB0eXBlb2YgdmFsdWUudmFsdWVPZigpID09PSAnc3RyaW5nJykge1xuICAgIHJldHVybiBEZWNpbWFsMTI4VHlwZS5mcm9tU3RyaW5nKHZhbHVlLnZhbHVlT2YoKSk7XG4gIH1cblxuICBhc3NlcnQub2soZmFsc2UpO1xufTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/mongoose/lib/cast/decimal128.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/mongoose/lib/cast/number.js":
/*!**************************************************!*\
  !*** ./node_modules/mongoose/lib/cast/number.js ***!
  \**************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\n\nconst assert = __webpack_require__(/*! assert */ \"assert\");\n\n/**\n * Given a value, cast it to a number, or throw an `Error` if the value\n * cannot be casted. `null` and `undefined` are considered valid.\n *\n * @param {Any} value\n * @return {Number}\n * @throws {Error} if `value` is not one of the allowed values\n * @api private\n */\n\nmodule.exports = function castNumber(val) {\n  if (val == null) {\n    return val;\n  }\n  if (val === '') {\n    return null;\n  }\n\n  if (typeof val === 'string' || typeof val === 'boolean') {\n    val = Number(val);\n  }\n\n  assert.ok(!isNaN(val));\n  if (val instanceof Number) {\n    return val.valueOf();\n  }\n  if (typeof val === 'number') {\n    return val;\n  }\n  if (!Array.isArray(val) && typeof val.valueOf === 'function') {\n    return Number(val.valueOf());\n  }\n  if (val.toString && !Array.isArray(val) && val.toString() == Number(val)) {\n    return Number(val);\n  }\n\n  assert.ok(false);\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbW9uZ29vc2UvbGliL2Nhc3QvbnVtYmVyLmpzIiwibWFwcGluZ3MiOiJBQUFhOztBQUViLGVBQWUsbUJBQU8sQ0FBQyxzQkFBUTs7QUFFL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLEtBQUs7QUFDaEIsWUFBWTtBQUNaLFlBQVksT0FBTztBQUNuQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vYXBwMS8uL25vZGVfbW9kdWxlcy9tb25nb29zZS9saWIvY2FzdC9udW1iZXIuanM/ZTNiNSJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbmNvbnN0IGFzc2VydCA9IHJlcXVpcmUoJ2Fzc2VydCcpO1xuXG4vKipcbiAqIEdpdmVuIGEgdmFsdWUsIGNhc3QgaXQgdG8gYSBudW1iZXIsIG9yIHRocm93IGFuIGBFcnJvcmAgaWYgdGhlIHZhbHVlXG4gKiBjYW5ub3QgYmUgY2FzdGVkLiBgbnVsbGAgYW5kIGB1bmRlZmluZWRgIGFyZSBjb25zaWRlcmVkIHZhbGlkLlxuICpcbiAqIEBwYXJhbSB7QW55fSB2YWx1ZVxuICogQHJldHVybiB7TnVtYmVyfVxuICogQHRocm93cyB7RXJyb3J9IGlmIGB2YWx1ZWAgaXMgbm90IG9uZSBvZiB0aGUgYWxsb3dlZCB2YWx1ZXNcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gY2FzdE51bWJlcih2YWwpIHtcbiAgaWYgKHZhbCA9PSBudWxsKSB7XG4gICAgcmV0dXJuIHZhbDtcbiAgfVxuICBpZiAodmFsID09PSAnJykge1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgaWYgKHR5cGVvZiB2YWwgPT09ICdzdHJpbmcnIHx8IHR5cGVvZiB2YWwgPT09ICdib29sZWFuJykge1xuICAgIHZhbCA9IE51bWJlcih2YWwpO1xuICB9XG5cbiAgYXNzZXJ0Lm9rKCFpc05hTih2YWwpKTtcbiAgaWYgKHZhbCBpbnN0YW5jZW9mIE51bWJlcikge1xuICAgIHJldHVybiB2YWwudmFsdWVPZigpO1xuICB9XG4gIGlmICh0eXBlb2YgdmFsID09PSAnbnVtYmVyJykge1xuICAgIHJldHVybiB2YWw7XG4gIH1cbiAgaWYgKCFBcnJheS5pc0FycmF5KHZhbCkgJiYgdHlwZW9mIHZhbC52YWx1ZU9mID09PSAnZnVuY3Rpb24nKSB7XG4gICAgcmV0dXJuIE51bWJlcih2YWwudmFsdWVPZigpKTtcbiAgfVxuICBpZiAodmFsLnRvU3RyaW5nICYmICFBcnJheS5pc0FycmF5KHZhbCkgJiYgdmFsLnRvU3RyaW5nKCkgPT0gTnVtYmVyKHZhbCkpIHtcbiAgICByZXR1cm4gTnVtYmVyKHZhbCk7XG4gIH1cblxuICBhc3NlcnQub2soZmFsc2UpO1xufTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/mongoose/lib/cast/number.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/mongoose/lib/cast/objectid.js":
/*!****************************************************!*\
  !*** ./node_modules/mongoose/lib/cast/objectid.js ***!
  \****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\n\nconst isBsonType = __webpack_require__(/*! ../helpers/isBsonType */ \"(ssr)/./node_modules/mongoose/lib/helpers/isBsonType.js\");\nconst ObjectId = __webpack_require__(/*! ../types/objectid */ \"(ssr)/./node_modules/mongoose/lib/types/objectid.js\");\n\nmodule.exports = function castObjectId(value) {\n  if (value == null) {\n    return value;\n  }\n\n  if (isBsonType(value, 'ObjectId')) {\n    return value;\n  }\n\n  if (value._id) {\n    if (isBsonType(value._id, 'ObjectId')) {\n      return value._id;\n    }\n    if (value._id.toString instanceof Function) {\n      return new ObjectId(value._id.toString());\n    }\n  }\n\n  if (value.toString instanceof Function) {\n    return new ObjectId(value.toString());\n  }\n\n  return new ObjectId(value);\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbW9uZ29vc2UvbGliL2Nhc3Qvb2JqZWN0aWQuanMiLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWIsbUJBQW1CLG1CQUFPLENBQUMsc0ZBQXVCO0FBQ2xELGlCQUFpQixtQkFBTyxDQUFDLDhFQUFtQjs7QUFFNUM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9hcHAxLy4vbm9kZV9tb2R1bGVzL21vbmdvb3NlL2xpYi9jYXN0L29iamVjdGlkLmpzPzI3N2EiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG5jb25zdCBpc0Jzb25UeXBlID0gcmVxdWlyZSgnLi4vaGVscGVycy9pc0Jzb25UeXBlJyk7XG5jb25zdCBPYmplY3RJZCA9IHJlcXVpcmUoJy4uL3R5cGVzL29iamVjdGlkJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gY2FzdE9iamVjdElkKHZhbHVlKSB7XG4gIGlmICh2YWx1ZSA9PSBudWxsKSB7XG4gICAgcmV0dXJuIHZhbHVlO1xuICB9XG5cbiAgaWYgKGlzQnNvblR5cGUodmFsdWUsICdPYmplY3RJZCcpKSB7XG4gICAgcmV0dXJuIHZhbHVlO1xuICB9XG5cbiAgaWYgKHZhbHVlLl9pZCkge1xuICAgIGlmIChpc0Jzb25UeXBlKHZhbHVlLl9pZCwgJ09iamVjdElkJykpIHtcbiAgICAgIHJldHVybiB2YWx1ZS5faWQ7XG4gICAgfVxuICAgIGlmICh2YWx1ZS5faWQudG9TdHJpbmcgaW5zdGFuY2VvZiBGdW5jdGlvbikge1xuICAgICAgcmV0dXJuIG5ldyBPYmplY3RJZCh2YWx1ZS5faWQudG9TdHJpbmcoKSk7XG4gICAgfVxuICB9XG5cbiAgaWYgKHZhbHVlLnRvU3RyaW5nIGluc3RhbmNlb2YgRnVuY3Rpb24pIHtcbiAgICByZXR1cm4gbmV3IE9iamVjdElkKHZhbHVlLnRvU3RyaW5nKCkpO1xuICB9XG5cbiAgcmV0dXJuIG5ldyBPYmplY3RJZCh2YWx1ZSk7XG59O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/mongoose/lib/cast/objectid.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/mongoose/lib/cast/string.js":
/*!**************************************************!*\
  !*** ./node_modules/mongoose/lib/cast/string.js ***!
  \**************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\n\nconst CastError = __webpack_require__(/*! ../error/cast */ \"(ssr)/./node_modules/mongoose/lib/error/cast.js\");\n\n/**\n * Given a value, cast it to a string, or throw a `CastError` if the value\n * cannot be casted. `null` and `undefined` are considered valid.\n *\n * @param {Any} value\n * @param {String} [path] optional the path to set on the CastError\n * @return {string|null|undefined}\n * @throws {CastError}\n * @api private\n */\n\nmodule.exports = function castString(value, path) {\n  // If null or undefined\n  if (value == null) {\n    return value;\n  }\n\n  // handle documents being passed\n  if (value._id && typeof value._id === 'string') {\n    return value._id;\n  }\n\n  // Re: gh-647 and gh-3030, we're ok with casting using `toString()`\n  // **unless** its the default Object.toString, because \"[object Object]\"\n  // doesn't really qualify as useful data\n  if (value.toString &&\n      value.toString !== Object.prototype.toString &&\n      !Array.isArray(value)) {\n    return value.toString();\n  }\n\n  throw new CastError('string', value, path);\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbW9uZ29vc2UvbGliL2Nhc3Qvc3RyaW5nLmpzIiwibWFwcGluZ3MiOiJBQUFhOztBQUViLGtCQUFrQixtQkFBTyxDQUFDLHNFQUFlOztBQUV6QztBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsS0FBSztBQUNoQixXQUFXLFFBQVE7QUFDbkIsWUFBWTtBQUNaLFlBQVk7QUFDWjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vYXBwMS8uL25vZGVfbW9kdWxlcy9tb25nb29zZS9saWIvY2FzdC9zdHJpbmcuanM/NzRlYiJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbmNvbnN0IENhc3RFcnJvciA9IHJlcXVpcmUoJy4uL2Vycm9yL2Nhc3QnKTtcblxuLyoqXG4gKiBHaXZlbiBhIHZhbHVlLCBjYXN0IGl0IHRvIGEgc3RyaW5nLCBvciB0aHJvdyBhIGBDYXN0RXJyb3JgIGlmIHRoZSB2YWx1ZVxuICogY2Fubm90IGJlIGNhc3RlZC4gYG51bGxgIGFuZCBgdW5kZWZpbmVkYCBhcmUgY29uc2lkZXJlZCB2YWxpZC5cbiAqXG4gKiBAcGFyYW0ge0FueX0gdmFsdWVcbiAqIEBwYXJhbSB7U3RyaW5nfSBbcGF0aF0gb3B0aW9uYWwgdGhlIHBhdGggdG8gc2V0IG9uIHRoZSBDYXN0RXJyb3JcbiAqIEByZXR1cm4ge3N0cmluZ3xudWxsfHVuZGVmaW5lZH1cbiAqIEB0aHJvd3Mge0Nhc3RFcnJvcn1cbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gY2FzdFN0cmluZyh2YWx1ZSwgcGF0aCkge1xuICAvLyBJZiBudWxsIG9yIHVuZGVmaW5lZFxuICBpZiAodmFsdWUgPT0gbnVsbCkge1xuICAgIHJldHVybiB2YWx1ZTtcbiAgfVxuXG4gIC8vIGhhbmRsZSBkb2N1bWVudHMgYmVpbmcgcGFzc2VkXG4gIGlmICh2YWx1ZS5faWQgJiYgdHlwZW9mIHZhbHVlLl9pZCA9PT0gJ3N0cmluZycpIHtcbiAgICByZXR1cm4gdmFsdWUuX2lkO1xuICB9XG5cbiAgLy8gUmU6IGdoLTY0NyBhbmQgZ2gtMzAzMCwgd2UncmUgb2sgd2l0aCBjYXN0aW5nIHVzaW5nIGB0b1N0cmluZygpYFxuICAvLyAqKnVubGVzcyoqIGl0cyB0aGUgZGVmYXVsdCBPYmplY3QudG9TdHJpbmcsIGJlY2F1c2UgXCJbb2JqZWN0IE9iamVjdF1cIlxuICAvLyBkb2Vzbid0IHJlYWxseSBxdWFsaWZ5IGFzIHVzZWZ1bCBkYXRhXG4gIGlmICh2YWx1ZS50b1N0cmluZyAmJlxuICAgICAgdmFsdWUudG9TdHJpbmcgIT09IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcgJiZcbiAgICAgICFBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgIHJldHVybiB2YWx1ZS50b1N0cmluZygpO1xuICB9XG5cbiAgdGhyb3cgbmV3IENhc3RFcnJvcignc3RyaW5nJywgdmFsdWUsIHBhdGgpO1xufTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/mongoose/lib/cast/string.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/mongoose/lib/collection.js":
/*!*************************************************!*\
  !*** ./node_modules/mongoose/lib/collection.js ***!
  \*************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\n\n/*!\n * Module dependencies.\n */\n\nconst EventEmitter = (__webpack_require__(/*! events */ \"events\").EventEmitter);\nconst STATES = __webpack_require__(/*! ./connectionState */ \"(ssr)/./node_modules/mongoose/lib/connectionState.js\");\nconst immediate = __webpack_require__(/*! ./helpers/immediate */ \"(ssr)/./node_modules/mongoose/lib/helpers/immediate.js\");\n\n/**\n * Abstract Collection constructor\n *\n * This is the base class that drivers inherit from and implement.\n *\n * @param {String} name name of the collection\n * @param {Connection} conn A MongooseConnection instance\n * @param {Object} [opts] optional collection options\n * @api public\n */\n\nfunction Collection(name, conn, opts) {\n  if (opts === void 0) {\n    opts = {};\n  }\n\n  this.opts = opts;\n  this.name = name;\n  this.collectionName = name;\n  this.conn = conn;\n  this.queue = [];\n  this.buffer = true;\n  this.emitter = new EventEmitter();\n\n  if (STATES.connected === this.conn.readyState) {\n    this.onOpen();\n  }\n}\n\n/**\n * The collection name\n *\n * @api public\n * @property name\n */\n\nCollection.prototype.name;\n\n/**\n * The collection name\n *\n * @api public\n * @property collectionName\n */\n\nCollection.prototype.collectionName;\n\n/**\n * The Connection instance\n *\n * @api public\n * @property conn\n */\n\nCollection.prototype.conn;\n\n/**\n * Called when the database connects\n *\n * @api private\n */\n\nCollection.prototype.onOpen = function() {\n  this.buffer = false;\n  immediate(() => this.doQueue());\n};\n\n/**\n * Called when the database disconnects\n *\n * @api private\n */\n\nCollection.prototype.onClose = function() {};\n\n/**\n * Queues a method for later execution when its\n * database connection opens.\n *\n * @param {String} name name of the method to queue\n * @param {Array} args arguments to pass to the method when executed\n * @api private\n */\n\nCollection.prototype.addQueue = function(name, args) {\n  this.queue.push([name, args]);\n  return this;\n};\n\n/**\n * Removes a queued method\n *\n * @param {String} name name of the method to queue\n * @param {Array} args arguments to pass to the method when executed\n * @api private\n */\n\nCollection.prototype.removeQueue = function(name, args) {\n  const index = this.queue.findIndex(v => v[0] === name && v[1] === args);\n  if (index === -1) {\n    return false;\n  }\n  this.queue.splice(index, 1);\n  return true;\n};\n\n/**\n * Executes all queued methods and clears the queue.\n *\n * @api private\n */\n\nCollection.prototype.doQueue = function() {\n  for (const method of this.queue) {\n    if (typeof method[0] === 'function') {\n      method[0].apply(this, method[1]);\n    } else {\n      this[method[0]].apply(this, method[1]);\n    }\n  }\n  this.queue = [];\n  const _this = this;\n  immediate(function() {\n    _this.emitter.emit('queue');\n  });\n  return this;\n};\n\n/**\n * Abstract method that drivers must implement.\n */\n\nCollection.prototype.ensureIndex = function() {\n  throw new Error('Collection#ensureIndex unimplemented by driver');\n};\n\n/**\n * Abstract method that drivers must implement.\n */\n\nCollection.prototype.createIndex = function() {\n  throw new Error('Collection#createIndex unimplemented by driver');\n};\n\n/**\n * Abstract method that drivers must implement.\n */\n\nCollection.prototype.findAndModify = function() {\n  throw new Error('Collection#findAndModify unimplemented by driver');\n};\n\n/**\n * Abstract method that drivers must implement.\n */\n\nCollection.prototype.findOneAndUpdate = function() {\n  throw new Error('Collection#findOneAndUpdate unimplemented by driver');\n};\n\n/**\n * Abstract method that drivers must implement.\n */\n\nCollection.prototype.findOneAndDelete = function() {\n  throw new Error('Collection#findOneAndDelete unimplemented by driver');\n};\n\n/**\n * Abstract method that drivers must implement.\n */\n\nCollection.prototype.findOneAndReplace = function() {\n  throw new Error('Collection#findOneAndReplace unimplemented by driver');\n};\n\n/**\n * Abstract method that drivers must implement.\n */\n\nCollection.prototype.findOne = function() {\n  throw new Error('Collection#findOne unimplemented by driver');\n};\n\n/**\n * Abstract method that drivers must implement.\n */\n\nCollection.prototype.find = function() {\n  throw new Error('Collection#find unimplemented by driver');\n};\n\n/**\n * Abstract method that drivers must implement.\n */\n\nCollection.prototype.insert = function() {\n  throw new Error('Collection#insert unimplemented by driver');\n};\n\n/**\n * Abstract method that drivers must implement.\n */\n\nCollection.prototype.insertOne = function() {\n  throw new Error('Collection#insertOne unimplemented by driver');\n};\n\n/**\n * Abstract method that drivers must implement.\n */\n\nCollection.prototype.insertMany = function() {\n  throw new Error('Collection#insertMany unimplemented by driver');\n};\n\n/**\n * Abstract method that drivers must implement.\n */\n\nCollection.prototype.save = function() {\n  throw new Error('Collection#save unimplemented by driver');\n};\n\n/**\n * Abstract method that drivers must implement.\n */\n\nCollection.prototype.updateOne = function() {\n  throw new Error('Collection#updateOne unimplemented by driver');\n};\n\n/**\n * Abstract method that drivers must implement.\n */\n\nCollection.prototype.updateMany = function() {\n  throw new Error('Collection#updateMany unimplemented by driver');\n};\n\n/**\n * Abstract method that drivers must implement.\n */\n\nCollection.prototype.deleteOne = function() {\n  throw new Error('Collection#deleteOne unimplemented by driver');\n};\n\n/**\n * Abstract method that drivers must implement.\n */\n\nCollection.prototype.deleteMany = function() {\n  throw new Error('Collection#deleteMany unimplemented by driver');\n};\n\n/**\n * Abstract method that drivers must implement.\n */\n\nCollection.prototype.getIndexes = function() {\n  throw new Error('Collection#getIndexes unimplemented by driver');\n};\n\n/**\n * Abstract method that drivers must implement.\n */\n\nCollection.prototype.watch = function() {\n  throw new Error('Collection#watch unimplemented by driver');\n};\n\n/*!\n * ignore\n */\n\nCollection.prototype._shouldBufferCommands = function _shouldBufferCommands() {\n  const opts = this.opts;\n\n  if (opts.bufferCommands != null) {\n    return opts.bufferCommands;\n  }\n  if (opts && opts.schemaUserProvidedOptions != null && opts.schemaUserProvidedOptions.bufferCommands != null) {\n    return opts.schemaUserProvidedOptions.bufferCommands;\n  }\n\n  return this.conn._shouldBufferCommands();\n};\n\n/*!\n * ignore\n */\n\nCollection.prototype._getBufferTimeoutMS = function _getBufferTimeoutMS() {\n  const conn = this.conn;\n  const opts = this.opts;\n\n  if (opts.bufferTimeoutMS != null) {\n    return opts.bufferTimeoutMS;\n  }\n  if (opts && opts.schemaUserProvidedOptions != null && opts.schemaUserProvidedOptions.bufferTimeoutMS != null) {\n    return opts.schemaUserProvidedOptions.bufferTimeoutMS;\n  }\n  if (conn.config.bufferTimeoutMS != null) {\n    return conn.config.bufferTimeoutMS;\n  }\n  if (conn.base != null && conn.base.get('bufferTimeoutMS') != null) {\n    return conn.base.get('bufferTimeoutMS');\n  }\n  return 10000;\n};\n\n/*!\n * Module exports.\n */\n\nmodule.exports = Collection;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbW9uZ29vc2UvbGliL2NvbGxlY3Rpb24uanMiLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWI7QUFDQTtBQUNBOztBQUVBLHFCQUFxQiwwREFBOEI7QUFDbkQsZUFBZSxtQkFBTyxDQUFDLCtFQUFtQjtBQUMxQyxrQkFBa0IsbUJBQU8sQ0FBQyxtRkFBcUI7O0FBRS9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsV0FBVyxZQUFZO0FBQ3ZCLFdBQVcsUUFBUTtBQUNuQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLE9BQU87QUFDbEI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsV0FBVyxPQUFPO0FBQ2xCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSIsInNvdXJjZXMiOlsid2VicGFjazovL2FwcDEvLi9ub2RlX21vZHVsZXMvbW9uZ29vc2UvbGliL2NvbGxlY3Rpb24uanM/NWViNyJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbi8qIVxuICogTW9kdWxlIGRlcGVuZGVuY2llcy5cbiAqL1xuXG5jb25zdCBFdmVudEVtaXR0ZXIgPSByZXF1aXJlKCdldmVudHMnKS5FdmVudEVtaXR0ZXI7XG5jb25zdCBTVEFURVMgPSByZXF1aXJlKCcuL2Nvbm5lY3Rpb25TdGF0ZScpO1xuY29uc3QgaW1tZWRpYXRlID0gcmVxdWlyZSgnLi9oZWxwZXJzL2ltbWVkaWF0ZScpO1xuXG4vKipcbiAqIEFic3RyYWN0IENvbGxlY3Rpb24gY29uc3RydWN0b3JcbiAqXG4gKiBUaGlzIGlzIHRoZSBiYXNlIGNsYXNzIHRoYXQgZHJpdmVycyBpbmhlcml0IGZyb20gYW5kIGltcGxlbWVudC5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gbmFtZSBuYW1lIG9mIHRoZSBjb2xsZWN0aW9uXG4gKiBAcGFyYW0ge0Nvbm5lY3Rpb259IGNvbm4gQSBNb25nb29zZUNvbm5lY3Rpb24gaW5zdGFuY2VcbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0c10gb3B0aW9uYWwgY29sbGVjdGlvbiBvcHRpb25zXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmZ1bmN0aW9uIENvbGxlY3Rpb24obmFtZSwgY29ubiwgb3B0cykge1xuICBpZiAob3B0cyA9PT0gdm9pZCAwKSB7XG4gICAgb3B0cyA9IHt9O1xuICB9XG5cbiAgdGhpcy5vcHRzID0gb3B0cztcbiAgdGhpcy5uYW1lID0gbmFtZTtcbiAgdGhpcy5jb2xsZWN0aW9uTmFtZSA9IG5hbWU7XG4gIHRoaXMuY29ubiA9IGNvbm47XG4gIHRoaXMucXVldWUgPSBbXTtcbiAgdGhpcy5idWZmZXIgPSB0cnVlO1xuICB0aGlzLmVtaXR0ZXIgPSBuZXcgRXZlbnRFbWl0dGVyKCk7XG5cbiAgaWYgKFNUQVRFUy5jb25uZWN0ZWQgPT09IHRoaXMuY29ubi5yZWFkeVN0YXRlKSB7XG4gICAgdGhpcy5vbk9wZW4oKTtcbiAgfVxufVxuXG4vKipcbiAqIFRoZSBjb2xsZWN0aW9uIG5hbWVcbiAqXG4gKiBAYXBpIHB1YmxpY1xuICogQHByb3BlcnR5IG5hbWVcbiAqL1xuXG5Db2xsZWN0aW9uLnByb3RvdHlwZS5uYW1lO1xuXG4vKipcbiAqIFRoZSBjb2xsZWN0aW9uIG5hbWVcbiAqXG4gKiBAYXBpIHB1YmxpY1xuICogQHByb3BlcnR5IGNvbGxlY3Rpb25OYW1lXG4gKi9cblxuQ29sbGVjdGlvbi5wcm90b3R5cGUuY29sbGVjdGlvbk5hbWU7XG5cbi8qKlxuICogVGhlIENvbm5lY3Rpb24gaW5zdGFuY2VcbiAqXG4gKiBAYXBpIHB1YmxpY1xuICogQHByb3BlcnR5IGNvbm5cbiAqL1xuXG5Db2xsZWN0aW9uLnByb3RvdHlwZS5jb25uO1xuXG4vKipcbiAqIENhbGxlZCB3aGVuIHRoZSBkYXRhYmFzZSBjb25uZWN0c1xuICpcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbkNvbGxlY3Rpb24ucHJvdG90eXBlLm9uT3BlbiA9IGZ1bmN0aW9uKCkge1xuICB0aGlzLmJ1ZmZlciA9IGZhbHNlO1xuICBpbW1lZGlhdGUoKCkgPT4gdGhpcy5kb1F1ZXVlKCkpO1xufTtcblxuLyoqXG4gKiBDYWxsZWQgd2hlbiB0aGUgZGF0YWJhc2UgZGlzY29ubmVjdHNcbiAqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5Db2xsZWN0aW9uLnByb3RvdHlwZS5vbkNsb3NlID0gZnVuY3Rpb24oKSB7fTtcblxuLyoqXG4gKiBRdWV1ZXMgYSBtZXRob2QgZm9yIGxhdGVyIGV4ZWN1dGlvbiB3aGVuIGl0c1xuICogZGF0YWJhc2UgY29ubmVjdGlvbiBvcGVucy5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gbmFtZSBuYW1lIG9mIHRoZSBtZXRob2QgdG8gcXVldWVcbiAqIEBwYXJhbSB7QXJyYXl9IGFyZ3MgYXJndW1lbnRzIHRvIHBhc3MgdG8gdGhlIG1ldGhvZCB3aGVuIGV4ZWN1dGVkXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5Db2xsZWN0aW9uLnByb3RvdHlwZS5hZGRRdWV1ZSA9IGZ1bmN0aW9uKG5hbWUsIGFyZ3MpIHtcbiAgdGhpcy5xdWV1ZS5wdXNoKFtuYW1lLCBhcmdzXSk7XG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBSZW1vdmVzIGEgcXVldWVkIG1ldGhvZFxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lIG5hbWUgb2YgdGhlIG1ldGhvZCB0byBxdWV1ZVxuICogQHBhcmFtIHtBcnJheX0gYXJncyBhcmd1bWVudHMgdG8gcGFzcyB0byB0aGUgbWV0aG9kIHdoZW4gZXhlY3V0ZWRcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbkNvbGxlY3Rpb24ucHJvdG90eXBlLnJlbW92ZVF1ZXVlID0gZnVuY3Rpb24obmFtZSwgYXJncykge1xuICBjb25zdCBpbmRleCA9IHRoaXMucXVldWUuZmluZEluZGV4KHYgPT4gdlswXSA9PT0gbmFtZSAmJiB2WzFdID09PSBhcmdzKTtcbiAgaWYgKGluZGV4ID09PSAtMSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICB0aGlzLnF1ZXVlLnNwbGljZShpbmRleCwgMSk7XG4gIHJldHVybiB0cnVlO1xufTtcblxuLyoqXG4gKiBFeGVjdXRlcyBhbGwgcXVldWVkIG1ldGhvZHMgYW5kIGNsZWFycyB0aGUgcXVldWUuXG4gKlxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuQ29sbGVjdGlvbi5wcm90b3R5cGUuZG9RdWV1ZSA9IGZ1bmN0aW9uKCkge1xuICBmb3IgKGNvbnN0IG1ldGhvZCBvZiB0aGlzLnF1ZXVlKSB7XG4gICAgaWYgKHR5cGVvZiBtZXRob2RbMF0gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIG1ldGhvZFswXS5hcHBseSh0aGlzLCBtZXRob2RbMV0pO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzW21ldGhvZFswXV0uYXBwbHkodGhpcywgbWV0aG9kWzFdKTtcbiAgICB9XG4gIH1cbiAgdGhpcy5xdWV1ZSA9IFtdO1xuICBjb25zdCBfdGhpcyA9IHRoaXM7XG4gIGltbWVkaWF0ZShmdW5jdGlvbigpIHtcbiAgICBfdGhpcy5lbWl0dGVyLmVtaXQoJ3F1ZXVlJyk7XG4gIH0pO1xuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogQWJzdHJhY3QgbWV0aG9kIHRoYXQgZHJpdmVycyBtdXN0IGltcGxlbWVudC5cbiAqL1xuXG5Db2xsZWN0aW9uLnByb3RvdHlwZS5lbnN1cmVJbmRleCA9IGZ1bmN0aW9uKCkge1xuICB0aHJvdyBuZXcgRXJyb3IoJ0NvbGxlY3Rpb24jZW5zdXJlSW5kZXggdW5pbXBsZW1lbnRlZCBieSBkcml2ZXInKTtcbn07XG5cbi8qKlxuICogQWJzdHJhY3QgbWV0aG9kIHRoYXQgZHJpdmVycyBtdXN0IGltcGxlbWVudC5cbiAqL1xuXG5Db2xsZWN0aW9uLnByb3RvdHlwZS5jcmVhdGVJbmRleCA9IGZ1bmN0aW9uKCkge1xuICB0aHJvdyBuZXcgRXJyb3IoJ0NvbGxlY3Rpb24jY3JlYXRlSW5kZXggdW5pbXBsZW1lbnRlZCBieSBkcml2ZXInKTtcbn07XG5cbi8qKlxuICogQWJzdHJhY3QgbWV0aG9kIHRoYXQgZHJpdmVycyBtdXN0IGltcGxlbWVudC5cbiAqL1xuXG5Db2xsZWN0aW9uLnByb3RvdHlwZS5maW5kQW5kTW9kaWZ5ID0gZnVuY3Rpb24oKSB7XG4gIHRocm93IG5ldyBFcnJvcignQ29sbGVjdGlvbiNmaW5kQW5kTW9kaWZ5IHVuaW1wbGVtZW50ZWQgYnkgZHJpdmVyJyk7XG59O1xuXG4vKipcbiAqIEFic3RyYWN0IG1ldGhvZCB0aGF0IGRyaXZlcnMgbXVzdCBpbXBsZW1lbnQuXG4gKi9cblxuQ29sbGVjdGlvbi5wcm90b3R5cGUuZmluZE9uZUFuZFVwZGF0ZSA9IGZ1bmN0aW9uKCkge1xuICB0aHJvdyBuZXcgRXJyb3IoJ0NvbGxlY3Rpb24jZmluZE9uZUFuZFVwZGF0ZSB1bmltcGxlbWVudGVkIGJ5IGRyaXZlcicpO1xufTtcblxuLyoqXG4gKiBBYnN0cmFjdCBtZXRob2QgdGhhdCBkcml2ZXJzIG11c3QgaW1wbGVtZW50LlxuICovXG5cbkNvbGxlY3Rpb24ucHJvdG90eXBlLmZpbmRPbmVBbmREZWxldGUgPSBmdW5jdGlvbigpIHtcbiAgdGhyb3cgbmV3IEVycm9yKCdDb2xsZWN0aW9uI2ZpbmRPbmVBbmREZWxldGUgdW5pbXBsZW1lbnRlZCBieSBkcml2ZXInKTtcbn07XG5cbi8qKlxuICogQWJzdHJhY3QgbWV0aG9kIHRoYXQgZHJpdmVycyBtdXN0IGltcGxlbWVudC5cbiAqL1xuXG5Db2xsZWN0aW9uLnByb3RvdHlwZS5maW5kT25lQW5kUmVwbGFjZSA9IGZ1bmN0aW9uKCkge1xuICB0aHJvdyBuZXcgRXJyb3IoJ0NvbGxlY3Rpb24jZmluZE9uZUFuZFJlcGxhY2UgdW5pbXBsZW1lbnRlZCBieSBkcml2ZXInKTtcbn07XG5cbi8qKlxuICogQWJzdHJhY3QgbWV0aG9kIHRoYXQgZHJpdmVycyBtdXN0IGltcGxlbWVudC5cbiAqL1xuXG5Db2xsZWN0aW9uLnByb3RvdHlwZS5maW5kT25lID0gZnVuY3Rpb24oKSB7XG4gIHRocm93IG5ldyBFcnJvcignQ29sbGVjdGlvbiNmaW5kT25lIHVuaW1wbGVtZW50ZWQgYnkgZHJpdmVyJyk7XG59O1xuXG4vKipcbiAqIEFic3RyYWN0IG1ldGhvZCB0aGF0IGRyaXZlcnMgbXVzdCBpbXBsZW1lbnQuXG4gKi9cblxuQ29sbGVjdGlvbi5wcm90b3R5cGUuZmluZCA9IGZ1bmN0aW9uKCkge1xuICB0aHJvdyBuZXcgRXJyb3IoJ0NvbGxlY3Rpb24jZmluZCB1bmltcGxlbWVudGVkIGJ5IGRyaXZlcicpO1xufTtcblxuLyoqXG4gKiBBYnN0cmFjdCBtZXRob2QgdGhhdCBkcml2ZXJzIG11c3QgaW1wbGVtZW50LlxuICovXG5cbkNvbGxlY3Rpb24ucHJvdG90eXBlLmluc2VydCA9IGZ1bmN0aW9uKCkge1xuICB0aHJvdyBuZXcgRXJyb3IoJ0NvbGxlY3Rpb24jaW5zZXJ0IHVuaW1wbGVtZW50ZWQgYnkgZHJpdmVyJyk7XG59O1xuXG4vKipcbiAqIEFic3RyYWN0IG1ldGhvZCB0aGF0IGRyaXZlcnMgbXVzdCBpbXBsZW1lbnQuXG4gKi9cblxuQ29sbGVjdGlvbi5wcm90b3R5cGUuaW5zZXJ0T25lID0gZnVuY3Rpb24oKSB7XG4gIHRocm93IG5ldyBFcnJvcignQ29sbGVjdGlvbiNpbnNlcnRPbmUgdW5pbXBsZW1lbnRlZCBieSBkcml2ZXInKTtcbn07XG5cbi8qKlxuICogQWJzdHJhY3QgbWV0aG9kIHRoYXQgZHJpdmVycyBtdXN0IGltcGxlbWVudC5cbiAqL1xuXG5Db2xsZWN0aW9uLnByb3RvdHlwZS5pbnNlcnRNYW55ID0gZnVuY3Rpb24oKSB7XG4gIHRocm93IG5ldyBFcnJvcignQ29sbGVjdGlvbiNpbnNlcnRNYW55IHVuaW1wbGVtZW50ZWQgYnkgZHJpdmVyJyk7XG59O1xuXG4vKipcbiAqIEFic3RyYWN0IG1ldGhvZCB0aGF0IGRyaXZlcnMgbXVzdCBpbXBsZW1lbnQuXG4gKi9cblxuQ29sbGVjdGlvbi5wcm90b3R5cGUuc2F2ZSA9IGZ1bmN0aW9uKCkge1xuICB0aHJvdyBuZXcgRXJyb3IoJ0NvbGxlY3Rpb24jc2F2ZSB1bmltcGxlbWVudGVkIGJ5IGRyaXZlcicpO1xufTtcblxuLyoqXG4gKiBBYnN0cmFjdCBtZXRob2QgdGhhdCBkcml2ZXJzIG11c3QgaW1wbGVtZW50LlxuICovXG5cbkNvbGxlY3Rpb24ucHJvdG90eXBlLnVwZGF0ZU9uZSA9IGZ1bmN0aW9uKCkge1xuICB0aHJvdyBuZXcgRXJyb3IoJ0NvbGxlY3Rpb24jdXBkYXRlT25lIHVuaW1wbGVtZW50ZWQgYnkgZHJpdmVyJyk7XG59O1xuXG4vKipcbiAqIEFic3RyYWN0IG1ldGhvZCB0aGF0IGRyaXZlcnMgbXVzdCBpbXBsZW1lbnQuXG4gKi9cblxuQ29sbGVjdGlvbi5wcm90b3R5cGUudXBkYXRlTWFueSA9IGZ1bmN0aW9uKCkge1xuICB0aHJvdyBuZXcgRXJyb3IoJ0NvbGxlY3Rpb24jdXBkYXRlTWFueSB1bmltcGxlbWVudGVkIGJ5IGRyaXZlcicpO1xufTtcblxuLyoqXG4gKiBBYnN0cmFjdCBtZXRob2QgdGhhdCBkcml2ZXJzIG11c3QgaW1wbGVtZW50LlxuICovXG5cbkNvbGxlY3Rpb24ucHJvdG90eXBlLmRlbGV0ZU9uZSA9IGZ1bmN0aW9uKCkge1xuICB0aHJvdyBuZXcgRXJyb3IoJ0NvbGxlY3Rpb24jZGVsZXRlT25lIHVuaW1wbGVtZW50ZWQgYnkgZHJpdmVyJyk7XG59O1xuXG4vKipcbiAqIEFic3RyYWN0IG1ldGhvZCB0aGF0IGRyaXZlcnMgbXVzdCBpbXBsZW1lbnQuXG4gKi9cblxuQ29sbGVjdGlvbi5wcm90b3R5cGUuZGVsZXRlTWFueSA9IGZ1bmN0aW9uKCkge1xuICB0aHJvdyBuZXcgRXJyb3IoJ0NvbGxlY3Rpb24jZGVsZXRlTWFueSB1bmltcGxlbWVudGVkIGJ5IGRyaXZlcicpO1xufTtcblxuLyoqXG4gKiBBYnN0cmFjdCBtZXRob2QgdGhhdCBkcml2ZXJzIG11c3QgaW1wbGVtZW50LlxuICovXG5cbkNvbGxlY3Rpb24ucHJvdG90eXBlLmdldEluZGV4ZXMgPSBmdW5jdGlvbigpIHtcbiAgdGhyb3cgbmV3IEVycm9yKCdDb2xsZWN0aW9uI2dldEluZGV4ZXMgdW5pbXBsZW1lbnRlZCBieSBkcml2ZXInKTtcbn07XG5cbi8qKlxuICogQWJzdHJhY3QgbWV0aG9kIHRoYXQgZHJpdmVycyBtdXN0IGltcGxlbWVudC5cbiAqL1xuXG5Db2xsZWN0aW9uLnByb3RvdHlwZS53YXRjaCA9IGZ1bmN0aW9uKCkge1xuICB0aHJvdyBuZXcgRXJyb3IoJ0NvbGxlY3Rpb24jd2F0Y2ggdW5pbXBsZW1lbnRlZCBieSBkcml2ZXInKTtcbn07XG5cbi8qIVxuICogaWdub3JlXG4gKi9cblxuQ29sbGVjdGlvbi5wcm90b3R5cGUuX3Nob3VsZEJ1ZmZlckNvbW1hbmRzID0gZnVuY3Rpb24gX3Nob3VsZEJ1ZmZlckNvbW1hbmRzKCkge1xuICBjb25zdCBvcHRzID0gdGhpcy5vcHRzO1xuXG4gIGlmIChvcHRzLmJ1ZmZlckNvbW1hbmRzICE9IG51bGwpIHtcbiAgICByZXR1cm4gb3B0cy5idWZmZXJDb21tYW5kcztcbiAgfVxuICBpZiAob3B0cyAmJiBvcHRzLnNjaGVtYVVzZXJQcm92aWRlZE9wdGlvbnMgIT0gbnVsbCAmJiBvcHRzLnNjaGVtYVVzZXJQcm92aWRlZE9wdGlvbnMuYnVmZmVyQ29tbWFuZHMgIT0gbnVsbCkge1xuICAgIHJldHVybiBvcHRzLnNjaGVtYVVzZXJQcm92aWRlZE9wdGlvbnMuYnVmZmVyQ29tbWFuZHM7XG4gIH1cblxuICByZXR1cm4gdGhpcy5jb25uLl9zaG91bGRCdWZmZXJDb21tYW5kcygpO1xufTtcblxuLyohXG4gKiBpZ25vcmVcbiAqL1xuXG5Db2xsZWN0aW9uLnByb3RvdHlwZS5fZ2V0QnVmZmVyVGltZW91dE1TID0gZnVuY3Rpb24gX2dldEJ1ZmZlclRpbWVvdXRNUygpIHtcbiAgY29uc3QgY29ubiA9IHRoaXMuY29ubjtcbiAgY29uc3Qgb3B0cyA9IHRoaXMub3B0cztcblxuICBpZiAob3B0cy5idWZmZXJUaW1lb3V0TVMgIT0gbnVsbCkge1xuICAgIHJldHVybiBvcHRzLmJ1ZmZlclRpbWVvdXRNUztcbiAgfVxuICBpZiAob3B0cyAmJiBvcHRzLnNjaGVtYVVzZXJQcm92aWRlZE9wdGlvbnMgIT0gbnVsbCAmJiBvcHRzLnNjaGVtYVVzZXJQcm92aWRlZE9wdGlvbnMuYnVmZmVyVGltZW91dE1TICE9IG51bGwpIHtcbiAgICByZXR1cm4gb3B0cy5zY2hlbWFVc2VyUHJvdmlkZWRPcHRpb25zLmJ1ZmZlclRpbWVvdXRNUztcbiAgfVxuICBpZiAoY29ubi5jb25maWcuYnVmZmVyVGltZW91dE1TICE9IG51bGwpIHtcbiAgICByZXR1cm4gY29ubi5jb25maWcuYnVmZmVyVGltZW91dE1TO1xuICB9XG4gIGlmIChjb25uLmJhc2UgIT0gbnVsbCAmJiBjb25uLmJhc2UuZ2V0KCdidWZmZXJUaW1lb3V0TVMnKSAhPSBudWxsKSB7XG4gICAgcmV0dXJuIGNvbm4uYmFzZS5nZXQoJ2J1ZmZlclRpbWVvdXRNUycpO1xuICB9XG4gIHJldHVybiAxMDAwMDtcbn07XG5cbi8qIVxuICogTW9kdWxlIGV4cG9ydHMuXG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSBDb2xsZWN0aW9uO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/mongoose/lib/collection.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/mongoose/lib/connection.js":
/*!*************************************************!*\
  !*** ./node_modules/mongoose/lib/connection.js ***!
  \*************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\n\n/*!\n * Module dependencies.\n */\n\nconst ChangeStream = __webpack_require__(/*! ./cursor/changeStream */ \"(ssr)/./node_modules/mongoose/lib/cursor/changeStream.js\");\nconst EventEmitter = (__webpack_require__(/*! events */ \"events\").EventEmitter);\nconst Schema = __webpack_require__(/*! ./schema */ \"(ssr)/./node_modules/mongoose/lib/schema.js\");\nconst STATES = __webpack_require__(/*! ./connectionState */ \"(ssr)/./node_modules/mongoose/lib/connectionState.js\");\nconst MongooseError = __webpack_require__(/*! ./error/index */ \"(ssr)/./node_modules/mongoose/lib/error/index.js\");\nconst ServerSelectionError = __webpack_require__(/*! ./error/serverSelection */ \"(ssr)/./node_modules/mongoose/lib/error/serverSelection.js\");\nconst SyncIndexesError = __webpack_require__(/*! ./error/syncIndexes */ \"(ssr)/./node_modules/mongoose/lib/error/syncIndexes.js\");\nconst applyPlugins = __webpack_require__(/*! ./helpers/schema/applyPlugins */ \"(ssr)/./node_modules/mongoose/lib/helpers/schema/applyPlugins.js\");\nconst clone = __webpack_require__(/*! ./helpers/clone */ \"(ssr)/./node_modules/mongoose/lib/helpers/clone.js\");\nconst driver = __webpack_require__(/*! ./driver */ \"(ssr)/./node_modules/mongoose/lib/driver.js\");\nconst get = __webpack_require__(/*! ./helpers/get */ \"(ssr)/./node_modules/mongoose/lib/helpers/get.js\");\nconst immediate = __webpack_require__(/*! ./helpers/immediate */ \"(ssr)/./node_modules/mongoose/lib/helpers/immediate.js\");\nconst utils = __webpack_require__(/*! ./utils */ \"(ssr)/./node_modules/mongoose/lib/utils.js\");\nconst CreateCollectionsError = __webpack_require__(/*! ./error/createCollectionsError */ \"(ssr)/./node_modules/mongoose/lib/error/createCollectionsError.js\");\n\nconst arrayAtomicsSymbol = (__webpack_require__(/*! ./helpers/symbols */ \"(ssr)/./node_modules/mongoose/lib/helpers/symbols.js\").arrayAtomicsSymbol);\nconst sessionNewDocuments = (__webpack_require__(/*! ./helpers/symbols */ \"(ssr)/./node_modules/mongoose/lib/helpers/symbols.js\").sessionNewDocuments);\n\n/**\n * A list of authentication mechanisms that don't require a password for authentication.\n * This is used by the authMechanismDoesNotRequirePassword method.\n *\n * @api private\n */\nconst noPasswordAuthMechanisms = [\n  'MONGODB-X509'\n];\n\n/**\n * Connection constructor\n *\n * For practical reasons, a Connection equals a Db.\n *\n * @param {Mongoose} base a mongoose instance\n * @inherits NodeJS EventEmitter https://nodejs.org/api/events.html#class-eventemitter\n * @event `connecting`: Emitted when `connection.openUri()` is executed on this connection.\n * @event `connected`: Emitted when this connection successfully connects to the db. May be emitted _multiple_ times in `reconnected` scenarios.\n * @event `open`: Emitted after we `connected` and `onOpen` is executed on all of this connection's models.\n * @event `disconnecting`: Emitted when `connection.close()` was executed.\n * @event `disconnected`: Emitted after getting disconnected from the db.\n * @event `close`: Emitted after we `disconnected` and `onClose` executed on all of this connection's models.\n * @event `reconnected`: Emitted after we `connected` and subsequently `disconnected`, followed by successfully another successful connection.\n * @event `error`: Emitted when an error occurs on this connection.\n * @event `fullsetup`: Emitted after the driver has connected to primary and all secondaries if specified in the connection string.\n * @api public\n */\n\nfunction Connection(base) {\n  this.base = base;\n  this.collections = {};\n  this.models = {};\n  this.config = {};\n  this.replica = false;\n  this.options = null;\n  this.otherDbs = []; // FIXME: To be replaced with relatedDbs\n  this.relatedDbs = {}; // Hashmap of other dbs that share underlying connection\n  this.states = STATES;\n  this._readyState = STATES.disconnected;\n  this._closeCalled = false;\n  this._hasOpened = false;\n  this.plugins = [];\n  if (typeof base === 'undefined' || !base.connections.length) {\n    this.id = 0;\n  } else {\n    this.id = base.nextConnectionId;\n  }\n  this._queue = [];\n}\n\n/*!\n * Inherit from EventEmitter\n */\n\nObject.setPrototypeOf(Connection.prototype, EventEmitter.prototype);\n\n/**\n * Connection ready state\n *\n * - 0 = disconnected\n * - 1 = connected\n * - 2 = connecting\n * - 3 = disconnecting\n *\n * Each state change emits its associated event name.\n *\n * #### Example:\n *\n *     conn.on('connected', callback);\n *     conn.on('disconnected', callback);\n *\n * @property readyState\n * @memberOf Connection\n * @instance\n * @api public\n */\n\nObject.defineProperty(Connection.prototype, 'readyState', {\n  get: function() {\n    return this._readyState;\n  },\n  set: function(val) {\n    if (!(val in STATES)) {\n      throw new Error('Invalid connection state: ' + val);\n    }\n\n    if (this._readyState !== val) {\n      this._readyState = val;\n      // [legacy] loop over the otherDbs on this connection and change their state\n      for (const db of this.otherDbs) {\n        db.readyState = val;\n      }\n\n      if (STATES.connected === val) {\n        this._hasOpened = true;\n      }\n\n      this.emit(STATES[val]);\n    }\n  }\n});\n\n/**\n * Gets the value of the option `key`. Equivalent to `conn.options[key]`\n *\n * #### Example:\n *\n *     conn.get('test'); // returns the 'test' value\n *\n * @param {String} key\n * @method get\n * @api public\n */\n\nConnection.prototype.get = function(key) {\n  if (this.config.hasOwnProperty(key)) {\n    return this.config[key];\n  }\n\n  return get(this.options, key);\n};\n\n/**\n * Sets the value of the option `key`. Equivalent to `conn.options[key] = val`\n *\n * Supported options include:\n *\n * - `maxTimeMS`: Set [`maxTimeMS`](https://mongoosejs.com/docs/api/query.html#Query.prototype.maxTimeMS()) for all queries on this connection.\n * - 'debug': If `true`, prints the operations mongoose sends to MongoDB to the console. If a writable stream is passed, it will log to that stream, without colorization. If a callback function is passed, it will receive the collection name, the method name, then all arugments passed to the method. For example, if you wanted to replicate the default logging, you could output from the callback `Mongoose: ${collectionName}.${methodName}(${methodArgs.join(', ')})`.\n *\n * #### Example:\n *\n *     conn.set('test', 'foo');\n *     conn.get('test'); // 'foo'\n *     conn.options.test; // 'foo'\n *\n * @param {String} key\n * @param {Any} val\n * @method set\n * @api public\n */\n\nConnection.prototype.set = function(key, val) {\n  if (this.config.hasOwnProperty(key)) {\n    this.config[key] = val;\n    return val;\n  }\n\n  this.options = this.options || {};\n  this.options[key] = val;\n  return val;\n};\n\n/**\n * A hash of the collections associated with this connection\n *\n * @property collections\n * @memberOf Connection\n * @instance\n * @api public\n */\n\nConnection.prototype.collections;\n\n/**\n * The name of the database this connection points to.\n *\n * #### Example:\n *\n *     mongoose.createConnection('mongodb://127.0.0.1:27017/mydb').name; // \"mydb\"\n *\n * @property name\n * @memberOf Connection\n * @instance\n * @api public\n */\n\nConnection.prototype.name;\n\n/**\n * A [POJO](https://masteringjs.io/tutorials/fundamentals/pojo) containing\n * a map from model names to models. Contains all models that have been\n * added to this connection using [`Connection#model()`](https://mongoosejs.com/docs/api/connection.html#Connection.prototype.model()).\n *\n * #### Example:\n *\n *     const conn = mongoose.createConnection();\n *     const Test = conn.model('Test', mongoose.Schema({ name: String }));\n *\n *     Object.keys(conn.models).length; // 1\n *     conn.models.Test === Test; // true\n *\n * @property models\n * @memberOf Connection\n * @instance\n * @api public\n */\n\nConnection.prototype.models;\n\n/**\n * A number identifier for this connection. Used for debugging when\n * you have [multiple connections](https://mongoosejs.com/docs/connections.html#multiple_connections).\n *\n * #### Example:\n *\n *     // The default connection has `id = 0`\n *     mongoose.connection.id; // 0\n *\n *     // If you create a new connection, Mongoose increments id\n *     const conn = mongoose.createConnection();\n *     conn.id; // 1\n *\n * @property id\n * @memberOf Connection\n * @instance\n * @api public\n */\n\nConnection.prototype.id;\n\n/**\n * The plugins that will be applied to all models created on this connection.\n *\n * #### Example:\n *\n *     const db = mongoose.createConnection('mongodb://127.0.0.1:27017/mydb');\n *     db.plugin(() => console.log('Applied'));\n *     db.plugins.length; // 1\n *\n *     db.model('Test', new Schema({})); // Prints \"Applied\"\n *\n * @property plugins\n * @memberOf Connection\n * @instance\n * @api public\n */\n\nObject.defineProperty(Connection.prototype, 'plugins', {\n  configurable: false,\n  enumerable: true,\n  writable: true\n});\n\n/**\n * The host name portion of the URI. If multiple hosts, such as a replica set,\n * this will contain the first host name in the URI\n *\n * #### Example:\n *\n *     mongoose.createConnection('mongodb://127.0.0.1:27017/mydb').host; // \"127.0.0.1\"\n *\n * @property host\n * @memberOf Connection\n * @instance\n * @api public\n */\n\nObject.defineProperty(Connection.prototype, 'host', {\n  configurable: true,\n  enumerable: true,\n  writable: true\n});\n\n/**\n * The port portion of the URI. If multiple hosts, such as a replica set,\n * this will contain the port from the first host name in the URI.\n *\n * #### Example:\n *\n *     mongoose.createConnection('mongodb://127.0.0.1:27017/mydb').port; // 27017\n *\n * @property port\n * @memberOf Connection\n * @instance\n * @api public\n */\n\nObject.defineProperty(Connection.prototype, 'port', {\n  configurable: true,\n  enumerable: true,\n  writable: true\n});\n\n/**\n * The username specified in the URI\n *\n * #### Example:\n *\n *     mongoose.createConnection('mongodb://val:psw@127.0.0.1:27017/mydb').user; // \"val\"\n *\n * @property user\n * @memberOf Connection\n * @instance\n * @api public\n */\n\nObject.defineProperty(Connection.prototype, 'user', {\n  configurable: true,\n  enumerable: true,\n  writable: true\n});\n\n/**\n * The password specified in the URI\n *\n * #### Example:\n *\n *     mongoose.createConnection('mongodb://val:psw@127.0.0.1:27017/mydb').pass; // \"psw\"\n *\n * @property pass\n * @memberOf Connection\n * @instance\n * @api public\n */\n\nObject.defineProperty(Connection.prototype, 'pass', {\n  configurable: true,\n  enumerable: true,\n  writable: true\n});\n\n/**\n * The mongodb.Db instance, set when the connection is opened\n *\n * @property db\n * @memberOf Connection\n * @instance\n * @api public\n */\n\nConnection.prototype.db;\n\n/**\n * The MongoClient instance this connection uses to talk to MongoDB. Mongoose automatically sets this property\n * when the connection is opened.\n *\n * @property client\n * @memberOf Connection\n * @instance\n * @api public\n */\n\nConnection.prototype.client;\n\n/**\n * A hash of the global options that are associated with this connection\n *\n * @property config\n * @memberOf Connection\n * @instance\n * @api public\n */\n\nConnection.prototype.config;\n\n/**\n * Helper for `createCollection()`. Will explicitly create the given collection\n * with specified options. Used to create [capped collections](https://www.mongodb.com/docs/manual/core/capped-collections/)\n * and [views](https://www.mongodb.com/docs/manual/core/views/) from mongoose.\n *\n * Options are passed down without modification to the [MongoDB driver's `createCollection()` function](https://mongodb.github.io/node-mongodb-native/4.9/classes/Db.html#createCollection)\n *\n * @method createCollection\n * @param {string} collection The collection to create\n * @param {Object} [options] see [MongoDB driver docs](https://mongodb.github.io/node-mongodb-native/4.9/classes/Db.html#createCollection)\n * @return {Promise}\n * @api public\n */\n\nConnection.prototype.createCollection = async function createCollection(collection, options) {\n  if (typeof options === 'function' || (arguments.length >= 3 && typeof arguments[2] === 'function')) {\n    throw new MongooseError('Connection.prototype.createCollection() no longer accepts a callback');\n  }\n\n  if ((this.readyState === STATES.connecting || this.readyState === STATES.disconnected) && this._shouldBufferCommands()) {\n    await new Promise(resolve => {\n      this._queue.push({ fn: resolve });\n    });\n  }\n\n  return this.db.createCollection(collection, options);\n};\n\n/**\n * Calls `createCollection()` on a models in a series.\n *\n * @method createCollections\n * @param {Boolean} continueOnError When true, will continue to create collections and create a new error class for the collections that errored.\n * @returns {Promise}\n * @api public\n */\n\nConnection.prototype.createCollections = async function createCollections(options = {}) {\n  const result = {};\n  const errorsMap = { };\n\n  const { continueOnError } = options;\n  delete options.continueOnError;\n  for (const model of Object.values(this.models)) {\n    try {\n      result[model.modelName] = await model.createCollection({});\n    } catch (err) {\n      if (!continueOnError) {\n        errorsMap[model.modelName] = err;\n        break;\n      } else {\n        result[model.modelName] = err;\n      }\n    }\n  }\n\n  if (!continueOnError && Object.keys(errorsMap).length) {\n    const message = Object.entries(errorsMap).map(([modelName, err]) => `${modelName}: ${err.message}`).join(', ');\n    const createCollectionsError = new CreateCollectionsError(message, errorsMap);\n    throw createCollectionsError;\n  }\n  return result;\n};\n\n/**\n * _Requires MongoDB >= 3.6.0._ Starts a [MongoDB session](https://www.mongodb.com/docs/manual/release-notes/3.6/#client-sessions)\n * for benefits like causal consistency, [retryable writes](https://www.mongodb.com/docs/manual/core/retryable-writes/),\n * and [transactions](https://thecodebarbarian.com/a-node-js-perspective-on-mongodb-4-transactions.html).\n *\n * #### Example:\n *\n *     const session = await conn.startSession();\n *     let doc = await Person.findOne({ name: 'Ned Stark' }, null, { session });\n *     await doc.remove();\n *     // `doc` will always be null, even if reading from a replica set\n *     // secondary. Without causal consistency, it is possible to\n *     // get a doc back from the below query if the query reads from a\n *     // secondary that is experiencing replication lag.\n *     doc = await Person.findOne({ name: 'Ned Stark' }, null, { session, readPreference: 'secondary' });\n *\n *\n * @method startSession\n * @param {Object} [options] see the [mongodb driver options](https://mongodb.github.io/node-mongodb-native/4.9/classes/MongoClient.html#startSession)\n * @param {Boolean} [options.causalConsistency=true] set to false to disable causal consistency\n * @return {Promise<ClientSession>} promise that resolves to a MongoDB driver `ClientSession`\n * @api public\n */\n\nConnection.prototype.startSession = async function startSession(options) {\n  if (arguments.length >= 2 && typeof arguments[1] === 'function') {\n    throw new MongooseError('Connection.prototype.startSession() no longer accepts a callback');\n  }\n\n  if ((this.readyState === STATES.connecting || this.readyState === STATES.disconnected) && this._shouldBufferCommands()) {\n    await new Promise(resolve => {\n      this._queue.push({ fn: resolve });\n    });\n  }\n\n  const session = this.client.startSession(options);\n  return session;\n};\n\n/**\n * _Requires MongoDB >= 3.6.0._ Executes the wrapped async function\n * in a transaction. Mongoose will commit the transaction if the\n * async function executes successfully and attempt to retry if\n * there was a retriable error.\n *\n * Calls the MongoDB driver's [`session.withTransaction()`](https://mongodb.github.io/node-mongodb-native/4.9/classes/ClientSession.html#withTransaction),\n * but also handles resetting Mongoose document state as shown below.\n *\n * #### Example:\n *\n *     const doc = new Person({ name: 'Will Riker' });\n *     await db.transaction(async function setRank(session) {\n *       doc.rank = 'Captain';\n *       await doc.save({ session });\n *       doc.isNew; // false\n *\n *       // Throw an error to abort the transaction\n *       throw new Error('Oops!');\n *     },{ readPreference: 'primary' }).catch(() => {});\n *\n *     // true, `transaction()` reset the document's state because the\n *     // transaction was aborted.\n *     doc.isNew;\n *\n * @method transaction\n * @param {Function} fn Function to execute in a transaction\n * @param {mongodb.TransactionOptions} [options] Optional settings for the transaction\n * @return {Promise<Any>} promise that is fulfilled if Mongoose successfully committed the transaction, or rejects if the transaction was aborted or if Mongoose failed to commit the transaction. If fulfilled, the promise resolves to a MongoDB command result.\n * @api public\n */\n\nConnection.prototype.transaction = function transaction(fn, options) {\n  return this.startSession().then(session => {\n    session[sessionNewDocuments] = new Map();\n    return session.withTransaction(() => _wrapUserTransaction(fn, session), options).\n      then(res => {\n        delete session[sessionNewDocuments];\n        return res;\n      }).\n      catch(err => {\n        delete session[sessionNewDocuments];\n        throw err;\n      }).\n      finally(() => {\n        session.endSession().catch(() => {});\n      });\n  });\n};\n\n/*!\n * Reset document state in between transaction retries re: gh-13698\n */\n\nasync function _wrapUserTransaction(fn, session) {\n  try {\n    const res = await fn(session);\n    return res;\n  } catch (err) {\n    _resetSessionDocuments(session);\n    throw err;\n  }\n}\n\n/*!\n * If transaction was aborted, we need to reset newly inserted documents' `isNew`.\n */\nfunction _resetSessionDocuments(session) {\n  for (const doc of session[sessionNewDocuments].keys()) {\n    const state = session[sessionNewDocuments].get(doc);\n    if (state.hasOwnProperty('isNew')) {\n      doc.$isNew = state.isNew;\n    }\n    if (state.hasOwnProperty('versionKey')) {\n      doc.set(doc.schema.options.versionKey, state.versionKey);\n    }\n\n    if (state.modifiedPaths.length > 0 && doc.$__.activePaths.states.modify == null) {\n      doc.$__.activePaths.states.modify = {};\n    }\n    for (const path of state.modifiedPaths) {\n      const currentState = doc.$__.activePaths.paths[path];\n      if (currentState != null) {\n        delete doc.$__.activePaths[currentState][path];\n      }\n      doc.$__.activePaths.paths[path] = 'modify';\n      doc.$__.activePaths.states.modify[path] = true;\n    }\n\n    for (const path of state.atomics.keys()) {\n      const val = doc.$__getValue(path);\n      if (val == null) {\n        continue;\n      }\n      val[arrayAtomicsSymbol] = state.atomics.get(path);\n    }\n  }\n}\n\n/**\n * Helper for `dropCollection()`. Will delete the given collection, including\n * all documents and indexes.\n *\n * @method dropCollection\n * @param {string} collection The collection to delete\n * @return {Promise}\n * @api public\n */\n\nConnection.prototype.dropCollection = async function dropCollection(collection) {\n  if (arguments.length >= 2 && typeof arguments[1] === 'function') {\n    throw new MongooseError('Connection.prototype.dropCollection() no longer accepts a callback');\n  }\n\n  if ((this.readyState === STATES.connecting || this.readyState === STATES.disconnected) && this._shouldBufferCommands()) {\n    await new Promise(resolve => {\n      this._queue.push({ fn: resolve });\n    });\n  }\n\n  return this.db.dropCollection(collection);\n};\n\n/**\n * Helper for `dropDatabase()`. Deletes the given database, including all\n * collections, documents, and indexes.\n *\n * #### Example:\n *\n *     const conn = mongoose.createConnection('mongodb://127.0.0.1:27017/mydb');\n *     // Deletes the entire 'mydb' database\n *     await conn.dropDatabase();\n *\n * @method dropDatabase\n * @return {Promise}\n * @api public\n */\n\nConnection.prototype.dropDatabase = async function dropDatabase() {\n  if (arguments.length >= 1 && typeof arguments[0] === 'function') {\n    throw new MongooseError('Connection.prototype.dropDatabase() no longer accepts a callback');\n  }\n\n  if ((this.readyState === STATES.connecting || this.readyState === STATES.disconnected) && this._shouldBufferCommands()) {\n    await new Promise(resolve => {\n      this._queue.push({ fn: resolve });\n    });\n  }\n\n  // If `dropDatabase()` is called, this model's collection will not be\n  // init-ed. It is sufficiently common to call `dropDatabase()` after\n  // `mongoose.connect()` but before creating models that we want to\n  // support this. See gh-6796\n  for (const model of Object.values(this.models)) {\n    delete model.$init;\n  }\n\n  return this.db.dropDatabase();\n};\n\n/*!\n * ignore\n */\n\nConnection.prototype._shouldBufferCommands = function _shouldBufferCommands() {\n  if (this.config.bufferCommands != null) {\n    return this.config.bufferCommands;\n  }\n  if (this.base.get('bufferCommands') != null) {\n    return this.base.get('bufferCommands');\n  }\n  return true;\n};\n\n/**\n * error\n *\n * Graceful error handling, passes error to callback\n * if available, else emits error on the connection.\n *\n * @param {Error} err\n * @param {Function} callback optional\n * @emits \"error\" Emits the `error` event with the given `err`, unless a callback is specified\n * @returns {Promise|null} Returns a rejected Promise if no `callback` is given.\n * @api private\n */\n\nConnection.prototype.error = function(err, callback) {\n  if (callback) {\n    callback(err);\n    return null;\n  }\n  if (this.listeners('error').length > 0) {\n    this.emit('error', err);\n  }\n  return Promise.reject(err);\n};\n\n/**\n * Called when the connection is opened\n *\n * @api private\n */\n\nConnection.prototype.onOpen = function() {\n  this.readyState = STATES.connected;\n\n  for (const d of this._queue) {\n    d.fn.apply(d.ctx, d.args);\n  }\n  this._queue = [];\n\n  // avoid having the collection subscribe to our event emitter\n  // to prevent 0.3 warning\n  for (const i in this.collections) {\n    if (utils.object.hasOwnProperty(this.collections, i)) {\n      this.collections[i].onOpen();\n    }\n  }\n\n  this.emit('open');\n};\n\n/**\n * Opens the connection with a URI using `MongoClient.connect()`.\n *\n * @param {String} uri The URI to connect with.\n * @param {Object} [options] Passed on to [`MongoClient.connect`](https://mongodb.github.io/node-mongodb-native/4.9/classes/MongoClient.html#connect-1)\n * @param {Boolean} [options.bufferCommands=true] Mongoose specific option. Set to false to [disable buffering](https://mongoosejs.com/docs/faq.html#callback_never_executes) on all models associated with this connection.\n * @param {Number} [options.bufferTimeoutMS=10000] Mongoose specific option. If `bufferCommands` is true, Mongoose will throw an error after `bufferTimeoutMS` if the operation is still buffered.\n * @param {String} [options.dbName] The name of the database we want to use. If not provided, use database name from connection string.\n * @param {String} [options.user] username for authentication, equivalent to `options.auth.user`. Maintained for backwards compatibility.\n * @param {String} [options.pass] password for authentication, equivalent to `options.auth.password`. Maintained for backwards compatibility.\n * @param {Number} [options.maxPoolSize=100] The maximum number of sockets the MongoDB driver will keep open for this connection. Keep in mind that MongoDB only allows one operation per socket at a time, so you may want to increase this if you find you have a few slow queries that are blocking faster queries from proceeding. See [Slow Trains in MongoDB and Node.js](https://thecodebarbarian.com/slow-trains-in-mongodb-and-nodejs).\n * @param {Number} [options.minPoolSize=0] The minimum number of sockets the MongoDB driver will keep open for this connection. Keep in mind that MongoDB only allows one operation per socket at a time, so you may want to increase this if you find you have a few slow queries that are blocking faster queries from proceeding. See [Slow Trains in MongoDB and Node.js](https://thecodebarbarian.com/slow-trains-in-mongodb-and-nodejs).\n * @param {Number} [options.serverSelectionTimeoutMS] If `useUnifiedTopology = true`, the MongoDB driver will try to find a server to send any given operation to, and keep retrying for `serverSelectionTimeoutMS` milliseconds before erroring out. If not set, the MongoDB driver defaults to using `30000` (30 seconds).\n * @param {Number} [options.heartbeatFrequencyMS] If `useUnifiedTopology = true`, the MongoDB driver sends a heartbeat every `heartbeatFrequencyMS` to check on the status of the connection. A heartbeat is subject to `serverSelectionTimeoutMS`, so the MongoDB driver will retry failed heartbeats for up to 30 seconds by default. Mongoose only emits a `'disconnected'` event after a heartbeat has failed, so you may want to decrease this setting to reduce the time between when your server goes down and when Mongoose emits `'disconnected'`. We recommend you do **not** set this setting below 1000, too many heartbeats can lead to performance degradation.\n * @param {Boolean} [options.autoIndex=true] Mongoose-specific option. Set to false to disable automatic index creation for all models associated with this connection.\n * @param {Class} [options.promiseLibrary] Sets the [underlying driver's promise library](https://mongodb.github.io/node-mongodb-native/4.9/interfaces/MongoClientOptions.html#promiseLibrary).\n * @param {Number} [options.socketTimeoutMS=0] How long the MongoDB driver will wait before killing a socket due to inactivity _after initial connection_. A socket may be inactive because of either no activity or a long-running operation. `socketTimeoutMS` defaults to 0, which means Node.js will not time out the socket due to inactivity. This option is passed to [Node.js `socket#setTimeout()` function](https://nodejs.org/api/net.html#net_socket_settimeout_timeout_callback) after the MongoDB driver successfully completes.\n * @param {Number} [options.family=0] Passed transparently to [Node.js' `dns.lookup()`](https://nodejs.org/api/dns.html#dns_dns_lookup_hostname_options_callback) function. May be either `0, `4`, or `6`. `4` means use IPv4 only, `6` means use IPv6 only, `0` means try both.\n * @param {Boolean} [options.autoCreate=false] Set to `true` to make Mongoose automatically call `createCollection()` on every model created on this connection.\n * @returns {Promise<Connection>}\n * @api public\n */\n\nConnection.prototype.openUri = async function openUri(uri, options) {\n  if (this.readyState === STATES.connecting || this.readyState === STATES.connected) {\n    if (this._connectionString === uri) {\n      return this;\n    }\n  }\n\n  this._closeCalled = false;\n\n  // Internal option to skip `await this.$initialConnection` in\n  // this function for `createConnection()`. Because otherwise\n  // `createConnection()` would have an uncatchable error.\n  let _fireAndForget = false;\n  if (options && '_fireAndForget' in options) {\n    _fireAndForget = options._fireAndForget;\n    delete options._fireAndForget;\n  }\n\n  try {\n    _validateArgs.apply(arguments);\n  } catch (err) {\n    if (_fireAndForget) {\n      throw err;\n    }\n    this.$initialConnection = Promise.reject(err);\n    throw err;\n  }\n\n  this.$initialConnection = this.createClient(uri, options).\n    then(() => this).\n    catch(err => {\n      this.readyState = STATES.disconnected;\n      if (this.listeners('error').length > 0) {\n        immediate(() => this.emit('error', err));\n      }\n      throw err;\n    });\n\n  for (const model of Object.values(this.models)) {\n    // Errors handled internally, so safe to ignore error\n    model.init().catch(function $modelInitNoop() {});\n  }\n\n  // `createConnection()` calls this `openUri()` function without\n  // awaiting on the result, so we set this option to rely on\n  // `asPromise()` to handle any errors.\n  if (_fireAndForget) {\n    return this;\n  }\n\n  try {\n    await this.$initialConnection;\n  } catch (err) {\n    throw _handleConnectionErrors(err);\n  }\n\n  return this;\n};\n\n/*!\n * ignore\n */\n\nfunction _validateArgs(uri, options, callback) {\n  if (typeof options === 'function' && callback == null) {\n    throw new MongooseError('Connection.prototype.openUri() no longer accepts a callback');\n  } else if (typeof callback === 'function') {\n    throw new MongooseError('Connection.prototype.openUri() no longer accepts a callback');\n  }\n}\n\n/*!\n * ignore\n */\n\nfunction _handleConnectionErrors(err) {\n  if (err?.name === 'MongoServerSelectionError') {\n    const originalError = err;\n    err = new ServerSelectionError();\n    err.assimilateError(originalError);\n  }\n\n  return err;\n}\n\n/**\n * Destroy the connection. Similar to [`.close`](https://mongoosejs.com/docs/api/connection.html#Connection.prototype.close()),\n * but also removes the connection from Mongoose's `connections` list and prevents the\n * connection from ever being re-opened.\n *\n * @param {Boolean} [force]\n * @returns {Promise}\n */\n\nConnection.prototype.destroy = async function destroy(force) {\n  if (typeof force === 'function' || (arguments.length === 2 && typeof arguments[1] === 'function')) {\n    throw new MongooseError('Connection.prototype.destroy() no longer accepts a callback');\n  }\n\n  if (force != null && typeof force === 'object') {\n    this.$wasForceClosed = !!force.force;\n  } else {\n    this.$wasForceClosed = !!force;\n  }\n\n  return this._close(force, true);\n};\n\n/**\n * Closes the connection\n *\n * @param {Boolean} [force] optional\n * @return {Promise}\n * @api public\n */\n\nConnection.prototype.close = async function close(force) {\n  if (typeof force === 'function' || (arguments.length === 2 && typeof arguments[1] === 'function')) {\n    throw new MongooseError('Connection.prototype.close() no longer accepts a callback');\n  }\n\n  if (force != null && typeof force === 'object') {\n    this.$wasForceClosed = !!force.force;\n  } else {\n    this.$wasForceClosed = !!force;\n  }\n\n  for (const model of Object.values(this.models)) {\n    // If manually disconnecting, make sure to clear each model's `$init`\n    // promise, so Mongoose knows to re-run `init()` in case the\n    // connection is re-opened. See gh-12047.\n    delete model.$init;\n  }\n\n  return this._close(force, false);\n};\n\n/**\n * Handles closing the connection\n *\n * @param {Boolean} force\n * @param {Boolean} destroy\n * @returns {Connection} this\n * @api private\n */\nConnection.prototype._close = async function _close(force, destroy) {\n  const _this = this;\n  const closeCalled = this._closeCalled;\n  this._closeCalled = true;\n  this._destroyCalled = destroy;\n  if (this.client != null) {\n    this.client._closeCalled = true;\n    this.client._destroyCalled = destroy;\n  }\n\n  const conn = this;\n  switch (this.readyState) {\n    case STATES.disconnected:\n      if (destroy && this.base.connections.indexOf(conn) !== -1) {\n        this.base.connections.splice(this.base.connections.indexOf(conn), 1);\n      }\n      if (!closeCalled) {\n        await this.doClose(force);\n        this.onClose(force);\n      }\n      break;\n\n    case STATES.connected:\n      this.readyState = STATES.disconnecting;\n      await this.doClose(force);\n      if (destroy && _this.base.connections.indexOf(conn) !== -1) {\n        this.base.connections.splice(this.base.connections.indexOf(conn), 1);\n      }\n      this.onClose(force);\n\n      break;\n    case STATES.connecting:\n      return new Promise((resolve, reject) => {\n        const _rerunClose = () => {\n          this.removeListener('open', _rerunClose);\n          this.removeListener('error', _rerunClose);\n          if (destroy) {\n            this.destroy(force).then(resolve, reject);\n          } else {\n            this.close(force).then(resolve, reject);\n          }\n        };\n\n        this.once('open', _rerunClose);\n        this.once('error', _rerunClose);\n      });\n\n    case STATES.disconnecting:\n      return new Promise(resolve => {\n        this.once('close', () => {\n          if (destroy && this.base.connections.indexOf(conn) !== -1) {\n            this.base.connections.splice(this.base.connections.indexOf(conn), 1);\n          }\n          resolve();\n        });\n      });\n  }\n\n  return this;\n};\n\n/**\n * Abstract method that drivers must implement.\n *\n * @api private\n */\n\nConnection.prototype.doClose = function() {\n  throw new Error('Connection#doClose unimplemented by driver');\n};\n\n/**\n * Called when the connection closes\n *\n * @api private\n */\n\nConnection.prototype.onClose = function(force) {\n  this.readyState = STATES.disconnected;\n\n  // avoid having the collection subscribe to our event emitter\n  // to prevent 0.3 warning\n  for (const i in this.collections) {\n    if (utils.object.hasOwnProperty(this.collections, i)) {\n      this.collections[i].onClose(force);\n    }\n  }\n\n  this.emit('close', force);\n\n  for (const db of this.otherDbs) {\n    this._destroyCalled ? db.destroy({ force: force, skipCloseClient: true }) : db.close({ force: force, skipCloseClient: true });\n  }\n};\n\n/**\n * Retrieves a raw collection instance, creating it if not cached.\n * This method returns a thin wrapper around a [MongoDB Node.js driver collection]([MongoDB Node.js driver collection](https://mongodb.github.io/node-mongodb-native/Next/classes/Collection.html)).\n * Using a Collection bypasses Mongoose middleware, validation, and casting,\n * letting you use [MongoDB Node.js driver](https://mongodb.github.io/node-mongodb-native/) functionality directly.\n *\n * @param {String} name of the collection\n * @param {Object} [options] optional collection options\n * @return {Collection} collection instance\n * @api public\n */\n\nConnection.prototype.collection = function(name, options) {\n  const defaultOptions = {\n    autoIndex: this.config.autoIndex != null ? this.config.autoIndex : this.base.options.autoIndex,\n    autoCreate: this.config.autoCreate != null ? this.config.autoCreate : this.base.options.autoCreate\n  };\n  options = Object.assign({}, defaultOptions, options ? clone(options) : {});\n  options.$wasForceClosed = this.$wasForceClosed;\n  const Collection = this.base && this.base.__driver && this.base.__driver.Collection || driver.get().Collection;\n  if (!(name in this.collections)) {\n    this.collections[name] = new Collection(name, this, options);\n  }\n  return this.collections[name];\n};\n\n/**\n * Declares a plugin executed on all schemas you pass to `conn.model()`\n *\n * Equivalent to calling `.plugin(fn)` on each schema you create.\n *\n * #### Example:\n *\n *     const db = mongoose.createConnection('mongodb://127.0.0.1:27017/mydb');\n *     db.plugin(() => console.log('Applied'));\n *     db.plugins.length; // 1\n *\n *     db.model('Test', new Schema({})); // Prints \"Applied\"\n *\n * @param {Function} fn plugin callback\n * @param {Object} [opts] optional options\n * @return {Connection} this\n * @see plugins https://mongoosejs.com/docs/plugins.html\n * @api public\n */\n\nConnection.prototype.plugin = function(fn, opts) {\n  this.plugins.push([fn, opts]);\n  return this;\n};\n\n/**\n * Defines or retrieves a model.\n *\n *     const mongoose = require('mongoose');\n *     const db = mongoose.createConnection(..);\n *     db.model('Venue', new Schema(..));\n *     const Ticket = db.model('Ticket', new Schema(..));\n *     const Venue = db.model('Venue');\n *\n * _When no `collection` argument is passed, Mongoose produces a collection name by passing the model `name` to the `utils.toCollectionName` method. This method pluralizes the name. If you don't like this behavior, either pass a collection name or set your schemas collection name option._\n *\n * #### Example:\n *\n *     const schema = new Schema({ name: String }, { collection: 'actor' });\n *\n *     // or\n *\n *     schema.set('collection', 'actor');\n *\n *     // or\n *\n *     const collectionName = 'actor'\n *     const M = conn.model('Actor', schema, collectionName)\n *\n * @param {String|Function} name the model name or class extending Model\n * @param {Schema} [schema] a schema. necessary when defining a model\n * @param {String} [collection] name of mongodb collection (optional) if not given it will be induced from model name\n * @param {Object} [options]\n * @param {Boolean} [options.overwriteModels=false] If true, overwrite existing models with the same name to avoid `OverwriteModelError`\n * @see Mongoose#model https://mongoosejs.com/docs/api/mongoose.html#Mongoose.prototype.model()\n * @return {Model} The compiled model\n * @api public\n */\n\nConnection.prototype.model = function(name, schema, collection, options) {\n  if (!(this instanceof Connection)) {\n    throw new MongooseError('`connection.model()` should not be run with ' +\n      '`new`. If you are doing `new db.model(foo)(bar)`, use ' +\n      '`db.model(foo)(bar)` instead');\n  }\n\n  let fn;\n  if (typeof name === 'function') {\n    fn = name;\n    name = fn.name;\n  }\n\n  // collection name discovery\n  if (typeof schema === 'string') {\n    collection = schema;\n    schema = false;\n  }\n\n  if (utils.isObject(schema)) {\n    if (!schema.instanceOfSchema) {\n      schema = new Schema(schema);\n    } else if (!(schema instanceof this.base.Schema)) {\n      schema = schema._clone(this.base.Schema);\n    }\n  }\n  if (schema && !schema.instanceOfSchema) {\n    throw new Error('The 2nd parameter to `mongoose.model()` should be a ' +\n      'schema or a POJO');\n  }\n\n  const defaultOptions = { cache: false, overwriteModels: this.base.options.overwriteModels };\n  const opts = Object.assign(defaultOptions, options, { connection: this });\n  if (this.models[name] && !collection && opts.overwriteModels !== true) {\n    // model exists but we are not subclassing with custom collection\n    if (schema && schema.instanceOfSchema && schema !== this.models[name].schema) {\n      throw new MongooseError.OverwriteModelError(name);\n    }\n    return this.models[name];\n  }\n\n  let model;\n\n  if (schema && schema.instanceOfSchema) {\n    applyPlugins(schema, this.plugins, null, '$connectionPluginsApplied');\n\n    // compile a model\n    model = this.base._model(fn || name, schema, collection, opts);\n\n    // only the first model with this name is cached to allow\n    // for one-offs with custom collection names etc.\n    if (!this.models[name]) {\n      this.models[name] = model;\n    }\n\n    // Errors handled internally, so safe to ignore error\n    model.init().catch(function $modelInitNoop() {});\n\n    return model;\n  }\n\n  if (this.models[name] && collection) {\n    // subclassing current model with alternate collection\n    model = this.models[name];\n    schema = model.prototype.schema;\n    const sub = model.__subclass(this, schema, collection);\n    // do not cache the sub model\n    return sub;\n  }\n\n  if (arguments.length === 1) {\n    model = this.models[name];\n    if (!model) {\n      throw new MongooseError.MissingSchemaError(name);\n    }\n    return model;\n  }\n\n  if (!model) {\n    throw new MongooseError.MissingSchemaError(name);\n  }\n\n  if (this === model.prototype.db\n      && (!collection || collection === model.collection.name)) {\n    // model already uses this connection.\n\n    // only the first model with this name is cached to allow\n    // for one-offs with custom collection names etc.\n    if (!this.models[name]) {\n      this.models[name] = model;\n    }\n\n    return model;\n  }\n  this.models[name] = model.__subclass(this, schema, collection);\n  return this.models[name];\n};\n\n/**\n * Removes the model named `name` from this connection, if it exists. You can\n * use this function to clean up any models you created in your tests to\n * prevent OverwriteModelErrors.\n *\n * #### Example:\n *\n *     conn.model('User', new Schema({ name: String }));\n *     console.log(conn.model('User')); // Model object\n *     conn.deleteModel('User');\n *     console.log(conn.model('User')); // undefined\n *\n *     // Usually useful in a Mocha `afterEach()` hook\n *     afterEach(function() {\n *       conn.deleteModel(/.+/); // Delete every model\n *     });\n *\n * @api public\n * @param {String|RegExp} name if string, the name of the model to remove. If regexp, removes all models whose name matches the regexp.\n * @return {Connection} this\n */\n\nConnection.prototype.deleteModel = function(name) {\n  if (typeof name === 'string') {\n    const model = this.model(name);\n    if (model == null) {\n      return this;\n    }\n    const collectionName = model.collection.name;\n    delete this.models[name];\n    delete this.collections[collectionName];\n\n    this.emit('deleteModel', model);\n  } else if (name instanceof RegExp) {\n    const pattern = name;\n    const names = this.modelNames();\n    for (const name of names) {\n      if (pattern.test(name)) {\n        this.deleteModel(name);\n      }\n    }\n  } else {\n    throw new Error('First parameter to `deleteModel()` must be a string ' +\n      'or regexp, got \"' + name + '\"');\n  }\n\n  return this;\n};\n\n/**\n * Watches the entire underlying database for changes. Similar to\n * [`Model.watch()`](https://mongoosejs.com/docs/api/model.html#Model.watch()).\n *\n * This function does **not** trigger any middleware. In particular, it\n * does **not** trigger aggregate middleware.\n *\n * The ChangeStream object is an event emitter that emits the following events:\n *\n * - 'change': A change occurred, see below example\n * - 'error': An unrecoverable error occurred. In particular, change streams currently error out if they lose connection to the replica set primary. Follow [this GitHub issue](https://github.com/Automattic/mongoose/issues/6799) for updates.\n * - 'end': Emitted if the underlying stream is closed\n * - 'close': Emitted if the underlying stream is closed\n *\n * #### Example:\n *\n *     const User = conn.model('User', new Schema({ name: String }));\n *\n *     const changeStream = conn.watch().on('change', data => console.log(data));\n *\n *     // Triggers a 'change' event on the change stream.\n *     await User.create({ name: 'test' });\n *\n * @api public\n * @param {Array} [pipeline]\n * @param {Object} [options] passed without changes to [the MongoDB driver's `Db#watch()` function](https://mongodb.github.io/node-mongodb-native/4.9/classes/Db.html#watch)\n * @return {ChangeStream} mongoose-specific change stream wrapper, inherits from EventEmitter\n */\n\nConnection.prototype.watch = function(pipeline, options) {\n  const changeStreamThunk = cb => {\n    immediate(() => {\n      if (this.readyState === STATES.connecting) {\n        this.once('open', function() {\n          const driverChangeStream = this.db.watch(pipeline, options);\n          cb(null, driverChangeStream);\n        });\n      } else {\n        const driverChangeStream = this.db.watch(pipeline, options);\n        cb(null, driverChangeStream);\n      }\n    });\n  };\n\n  const changeStream = new ChangeStream(changeStreamThunk, pipeline, options);\n  return changeStream;\n};\n\n/**\n * Returns a promise that resolves when this connection\n * successfully connects to MongoDB, or rejects if this connection failed\n * to connect.\n *\n * #### Example:\n *\n *     const conn = await mongoose.createConnection('mongodb://127.0.0.1:27017/test').\n *       asPromise();\n *     conn.readyState; // 1, means Mongoose is connected\n *\n * @api public\n * @return {Promise}\n */\n\nConnection.prototype.asPromise = async function asPromise() {\n  try {\n    await this.$initialConnection;\n    return this;\n  } catch (err) {\n    throw _handleConnectionErrors(err);\n  }\n};\n\n/**\n * Returns an array of model names created on this connection.\n * @api public\n * @return {String[]}\n */\n\nConnection.prototype.modelNames = function() {\n  return Object.keys(this.models);\n};\n\n/**\n * Returns if the connection requires authentication after it is opened. Generally if a\n * username and password are both provided than authentication is needed, but in some cases a\n * password is not required.\n *\n * @api private\n * @return {Boolean} true if the connection should be authenticated after it is opened, otherwise false.\n */\nConnection.prototype.shouldAuthenticate = function() {\n  return this.user != null &&\n    (this.pass != null || this.authMechanismDoesNotRequirePassword());\n};\n\n/**\n * Returns a boolean value that specifies if the current authentication mechanism needs a\n * password to authenticate according to the auth objects passed into the openUri methods.\n *\n * @api private\n * @return {Boolean} true if the authentication mechanism specified in the options object requires\n *  a password, otherwise false.\n */\nConnection.prototype.authMechanismDoesNotRequirePassword = function() {\n  if (this.options && this.options.auth) {\n    return noPasswordAuthMechanisms.indexOf(this.options.auth.authMechanism) >= 0;\n  }\n  return true;\n};\n\n/**\n * Returns a boolean value that specifies if the provided objects object provides enough\n * data to authenticate with. Generally this is true if the username and password are both specified\n * but in some authentication methods, a password is not required for authentication so only a username\n * is required.\n *\n * @param {Object} [options] the options object passed into the openUri methods.\n * @api private\n * @return {Boolean} true if the provided options object provides enough data to authenticate with,\n *   otherwise false.\n */\nConnection.prototype.optionsProvideAuthenticationData = function(options) {\n  return (options) &&\n      (options.user) &&\n      ((options.pass) || this.authMechanismDoesNotRequirePassword());\n};\n\n/**\n * Returns the [MongoDB driver `MongoClient`](https://mongodb.github.io/node-mongodb-native/4.9/classes/MongoClient.html) instance\n * that this connection uses to talk to MongoDB.\n *\n * #### Example:\n *\n *     const conn = await mongoose.createConnection('mongodb://127.0.0.1:27017/test').\n *       asPromise();\n *\n *     conn.getClient(); // MongoClient { ... }\n *\n * @api public\n * @return {MongoClient}\n */\n\nConnection.prototype.getClient = function getClient() {\n  return this.client;\n};\n\n/**\n * Set the [MongoDB driver `MongoClient`](https://mongodb.github.io/node-mongodb-native/4.9/classes/MongoClient.html) instance\n * that this connection uses to talk to MongoDB. This is useful if you already have a MongoClient instance, and want to\n * reuse it.\n *\n * #### Example:\n *\n *     const client = await mongodb.MongoClient.connect('mongodb://127.0.0.1:27017/test');\n *\n *     const conn = mongoose.createConnection().setClient(client);\n *\n *     conn.getClient(); // MongoClient { ... }\n *     conn.readyState; // 1, means 'CONNECTED'\n *\n * @api public\n * @param {MongClient} client The Client to set to be used.\n * @return {Connection} this\n */\n\nConnection.prototype.setClient = function setClient() {\n  throw new MongooseError('Connection#setClient not implemented by driver');\n};\n\n/*!\n * Called internally by `openUri()` to create a MongoClient instance.\n */\n\nConnection.prototype.createClient = function createClient() {\n  throw new MongooseError('Connection#createClient not implemented by driver');\n};\n\n/**\n * Syncs all the indexes for the models registered with this connection.\n *\n * @param {Object} [options]\n * @param {Boolean} [options.continueOnError] `false` by default. If set to `true`, mongoose will not throw an error if one model syncing failed, and will return an object where the keys are the names of the models, and the values are the results/errors for each model.\n * @return {Promise<Object>} Returns a Promise, when the Promise resolves the value is a list of the dropped indexes.\n */\nConnection.prototype.syncIndexes = async function syncIndexes(options = {}) {\n  const result = {};\n  const errorsMap = { };\n\n  const { continueOnError } = options;\n  delete options.continueOnError;\n\n  for (const model of Object.values(this.models)) {\n    try {\n      result[model.modelName] = await model.syncIndexes(options);\n    } catch (err) {\n      if (!continueOnError) {\n        errorsMap[model.modelName] = err;\n        break;\n      } else {\n        result[model.modelName] = err;\n      }\n    }\n  }\n\n  if (!continueOnError && Object.keys(errorsMap).length) {\n    const message = Object.entries(errorsMap).map(([modelName, err]) => `${modelName}: ${err.message}`).join(', ');\n    const syncIndexesError = new SyncIndexesError(message, errorsMap);\n    throw syncIndexesError;\n  }\n\n  return result;\n};\n\n/**\n * Switches to a different database using the same [connection pool](https://mongoosejs.com/docs/api/connectionshtml#connection_pools).\n *\n * Returns a new connection object, with the new db.\n *\n * #### Example:\n *\n *     // Connect to `initialdb` first\n *     const conn = await mongoose.createConnection('mongodb://127.0.0.1:27017/initialdb').asPromise();\n *\n *     // Creates an un-cached connection to `mydb`\n *     const db = conn.useDb('mydb');\n *     // Creates a cached connection to `mydb2`. All calls to `conn.useDb('mydb2', { useCache: true })` will return the same\n *     // connection instance as opposed to creating a new connection instance\n *     const db2 = conn.useDb('mydb2', { useCache: true });\n *\n * @method useDb\n * @memberOf Connection\n * @param {String} name The database name\n * @param {Object} [options]\n * @param {Boolean} [options.useCache=false] If true, cache results so calling `useDb()` multiple times with the same name only creates 1 connection object.\n * @param {Boolean} [options.noListener=false] If true, the connection object will not make the db listen to events on the original connection. See [issue #9961](https://github.com/Automattic/mongoose/issues/9961).\n * @return {Connection} New Connection Object\n * @api public\n */\n\n/**\n * Removes the database connection with the given name created with with `useDb()`.\n *\n * Throws an error if the database connection was not found.\n *\n * #### Example:\n *\n *     // Connect to `initialdb` first\n *     const conn = await mongoose.createConnection('mongodb://127.0.0.1:27017/initialdb').asPromise();\n *\n *     // Creates an un-cached connection to `mydb`\n *     const db = conn.useDb('mydb');\n *\n *     // Closes `db`, and removes `db` from `conn.relatedDbs` and `conn.otherDbs`\n *     await conn.removeDb('mydb');\n *\n * @method removeDb\n * @memberOf Connection\n * @param {String} name The database name\n * @return {Connection} this\n * @api public\n */\n\n/*!\n * Module exports.\n */\n\nConnection.STATES = STATES;\nmodule.exports = Connection;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbW9uZ29vc2UvbGliL2Nvbm5lY3Rpb24uanMiLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWI7QUFDQTtBQUNBOztBQUVBLHFCQUFxQixtQkFBTyxDQUFDLHVGQUF1QjtBQUNwRCxxQkFBcUIsMERBQThCO0FBQ25ELGVBQWUsbUJBQU8sQ0FBQyw2REFBVTtBQUNqQyxlQUFlLG1CQUFPLENBQUMsK0VBQW1CO0FBQzFDLHNCQUFzQixtQkFBTyxDQUFDLHVFQUFlO0FBQzdDLDZCQUE2QixtQkFBTyxDQUFDLDJGQUF5QjtBQUM5RCx5QkFBeUIsbUJBQU8sQ0FBQyxtRkFBcUI7QUFDdEQscUJBQXFCLG1CQUFPLENBQUMsdUdBQStCO0FBQzVELGNBQWMsbUJBQU8sQ0FBQywyRUFBaUI7QUFDdkMsZUFBZSxtQkFBTyxDQUFDLDZEQUFVO0FBQ2pDLFlBQVksbUJBQU8sQ0FBQyx1RUFBZTtBQUNuQyxrQkFBa0IsbUJBQU8sQ0FBQyxtRkFBcUI7QUFDL0MsY0FBYyxtQkFBTyxDQUFDLDJEQUFTO0FBQy9CLCtCQUErQixtQkFBTyxDQUFDLHlHQUFnQzs7QUFFdkUsMkJBQTJCLHlIQUErQztBQUMxRSw0QkFBNEIsMEhBQWdEOztBQUU1RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsVUFBVTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEIsd0JBQXdCO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBLFdBQVcsUUFBUTtBQUNuQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5WkFBeVosZUFBZSxHQUFHLFdBQVcsR0FBRyxzQkFBc0I7QUFDL2M7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekIsMEJBQTBCO0FBQzFCO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFdBQVcsS0FBSztBQUNoQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5RUFBeUU7QUFDekU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5REFBeUQsY0FBYztBQUN2RTtBQUNBLHdDQUF3QztBQUN4QyxrQ0FBa0M7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCO0FBQy9CO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEI7QUFDMUI7QUFDQSxxQ0FBcUMsSUFBSTtBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlFQUF5RTtBQUN6RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlFQUF5RTtBQUN6RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpRkFBaUY7QUFDakY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUZBQWlGO0FBQ2pGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixZQUFZO0FBQ1o7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EseUJBQXlCLGFBQWE7QUFDdEMsS0FBSztBQUNMOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFNBQVM7QUFDcEIsYUFBYTtBQUNiO0FBQ0E7O0FBRUEsc0ZBQXNGO0FBQ3RGO0FBQ0E7O0FBRUEsVUFBVSxrQkFBa0I7QUFDNUI7QUFDQTtBQUNBO0FBQ0EsK0RBQStEO0FBQy9ELE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSwyRUFBMkUsVUFBVSxJQUFJLFlBQVk7QUFDckc7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0NBQXdDLG1CQUFtQixVQUFVLFNBQVM7QUFDOUU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQyxtQkFBbUIsVUFBVSxzQ0FBc0M7QUFDdkc7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFdBQVcsU0FBUztBQUNwQixZQUFZLHdCQUF3QjtBQUNwQztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSx5QkFBeUIsYUFBYTtBQUN0QyxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0Msb0JBQW9CO0FBQ3BEO0FBQ0E7QUFDQSwwQkFBMEIsU0FBUztBQUNuQyxvQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0EsUUFBUSxHQUFHLDJCQUEyQixnQkFBZ0I7QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxVQUFVO0FBQ3JCLFdBQVcsNEJBQTRCO0FBQ3ZDLFlBQVksY0FBYztBQUMxQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLDJDQUEyQztBQUMzQyxPQUFPO0FBQ1AsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixZQUFZO0FBQ1o7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EseUJBQXlCLGFBQWE7QUFDdEMsS0FBSztBQUNMOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSx5QkFBeUIsYUFBYTtBQUN0QyxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQixXQUFXLFVBQVU7QUFDckI7QUFDQSxhQUFhLGNBQWM7QUFDM0I7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsU0FBUztBQUNwQixXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsU0FBUztBQUNwQixXQUFXLE9BQU87QUFDbEIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixXQUFXLFNBQVM7QUFDcEIsYUFBYTtBQUNiO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBLG1EQUFtRDtBQUNuRDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFNBQVM7QUFDcEIsYUFBYTtBQUNiOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsU0FBUztBQUNwQixZQUFZO0FBQ1o7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxTQUFTO0FBQ3BCLFdBQVcsU0FBUztBQUNwQixhQUFhLFlBQVk7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxPQUFPOztBQUVQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULE9BQU87QUFDUDs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLHVDQUF1QyxxQ0FBcUMsZUFBZSxxQ0FBcUM7QUFDaEk7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLFlBQVksWUFBWTtBQUN4QjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsK0NBQStDO0FBQzNFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQjtBQUMxQjtBQUNBLHFDQUFxQyxJQUFJO0FBQ3pDO0FBQ0EsV0FBVyxVQUFVO0FBQ3JCLFdBQVcsUUFBUTtBQUNuQixZQUFZLFlBQVk7QUFDeEI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DLGNBQWMsSUFBSSxxQkFBcUI7QUFDMUU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLGlCQUFpQjtBQUM1QixXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixXQUFXLFNBQVM7QUFDcEI7QUFDQSxZQUFZLE9BQU87QUFDbkI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSwyQkFBMkI7QUFDM0Isd0RBQXdELGtCQUFrQjtBQUMxRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLG1EQUFtRDs7QUFFbkQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDLGNBQWM7QUFDckQsd0NBQXdDO0FBQ3hDO0FBQ0Esd0NBQXdDO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQztBQUNqQyxRQUFRO0FBQ1I7QUFDQTtBQUNBLFdBQVcsZUFBZTtBQUMxQixZQUFZLFlBQVk7QUFDeEI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0RBQW9ELGNBQWM7QUFDbEU7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsY0FBYztBQUN6QztBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsUUFBUTtBQUNuQixZQUFZLGNBQWM7QUFDMUI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCO0FBQ3hCO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxTQUFTO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksU0FBUztBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQjtBQUNBLFlBQVksU0FBUztBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsaUJBQWlCO0FBQzFDO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsaUJBQWlCO0FBQzFDLHdCQUF3QjtBQUN4QjtBQUNBO0FBQ0EsV0FBVyxZQUFZO0FBQ3ZCLFlBQVksWUFBWTtBQUN4Qjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsV0FBVyxTQUFTO0FBQ3BCLFlBQVksaUJBQWlCO0FBQzdCO0FBQ0EsMEVBQTBFO0FBQzFFO0FBQ0E7O0FBRUEsVUFBVSxrQkFBa0I7QUFDNUI7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDJFQUEyRSxVQUFVLElBQUksWUFBWTtBQUNyRztBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzRkFBc0YsZ0JBQWdCO0FBQ3RHO0FBQ0EseUNBQXlDLGdCQUFnQjtBQUN6RDtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsU0FBUztBQUNwQixXQUFXLFNBQVM7QUFDcEIsWUFBWSxZQUFZO0FBQ3hCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFlBQVksWUFBWTtBQUN4QjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vYXBwMS8uL25vZGVfbW9kdWxlcy9tb25nb29zZS9saWIvY29ubmVjdGlvbi5qcz9lNDhmIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxuLyohXG4gKiBNb2R1bGUgZGVwZW5kZW5jaWVzLlxuICovXG5cbmNvbnN0IENoYW5nZVN0cmVhbSA9IHJlcXVpcmUoJy4vY3Vyc29yL2NoYW5nZVN0cmVhbScpO1xuY29uc3QgRXZlbnRFbWl0dGVyID0gcmVxdWlyZSgnZXZlbnRzJykuRXZlbnRFbWl0dGVyO1xuY29uc3QgU2NoZW1hID0gcmVxdWlyZSgnLi9zY2hlbWEnKTtcbmNvbnN0IFNUQVRFUyA9IHJlcXVpcmUoJy4vY29ubmVjdGlvblN0YXRlJyk7XG5jb25zdCBNb25nb29zZUVycm9yID0gcmVxdWlyZSgnLi9lcnJvci9pbmRleCcpO1xuY29uc3QgU2VydmVyU2VsZWN0aW9uRXJyb3IgPSByZXF1aXJlKCcuL2Vycm9yL3NlcnZlclNlbGVjdGlvbicpO1xuY29uc3QgU3luY0luZGV4ZXNFcnJvciA9IHJlcXVpcmUoJy4vZXJyb3Ivc3luY0luZGV4ZXMnKTtcbmNvbnN0IGFwcGx5UGx1Z2lucyA9IHJlcXVpcmUoJy4vaGVscGVycy9zY2hlbWEvYXBwbHlQbHVnaW5zJyk7XG5jb25zdCBjbG9uZSA9IHJlcXVpcmUoJy4vaGVscGVycy9jbG9uZScpO1xuY29uc3QgZHJpdmVyID0gcmVxdWlyZSgnLi9kcml2ZXInKTtcbmNvbnN0IGdldCA9IHJlcXVpcmUoJy4vaGVscGVycy9nZXQnKTtcbmNvbnN0IGltbWVkaWF0ZSA9IHJlcXVpcmUoJy4vaGVscGVycy9pbW1lZGlhdGUnKTtcbmNvbnN0IHV0aWxzID0gcmVxdWlyZSgnLi91dGlscycpO1xuY29uc3QgQ3JlYXRlQ29sbGVjdGlvbnNFcnJvciA9IHJlcXVpcmUoJy4vZXJyb3IvY3JlYXRlQ29sbGVjdGlvbnNFcnJvcicpO1xuXG5jb25zdCBhcnJheUF0b21pY3NTeW1ib2wgPSByZXF1aXJlKCcuL2hlbHBlcnMvc3ltYm9scycpLmFycmF5QXRvbWljc1N5bWJvbDtcbmNvbnN0IHNlc3Npb25OZXdEb2N1bWVudHMgPSByZXF1aXJlKCcuL2hlbHBlcnMvc3ltYm9scycpLnNlc3Npb25OZXdEb2N1bWVudHM7XG5cbi8qKlxuICogQSBsaXN0IG9mIGF1dGhlbnRpY2F0aW9uIG1lY2hhbmlzbXMgdGhhdCBkb24ndCByZXF1aXJlIGEgcGFzc3dvcmQgZm9yIGF1dGhlbnRpY2F0aW9uLlxuICogVGhpcyBpcyB1c2VkIGJ5IHRoZSBhdXRoTWVjaGFuaXNtRG9lc05vdFJlcXVpcmVQYXNzd29yZCBtZXRob2QuXG4gKlxuICogQGFwaSBwcml2YXRlXG4gKi9cbmNvbnN0IG5vUGFzc3dvcmRBdXRoTWVjaGFuaXNtcyA9IFtcbiAgJ01PTkdPREItWDUwOSdcbl07XG5cbi8qKlxuICogQ29ubmVjdGlvbiBjb25zdHJ1Y3RvclxuICpcbiAqIEZvciBwcmFjdGljYWwgcmVhc29ucywgYSBDb25uZWN0aW9uIGVxdWFscyBhIERiLlxuICpcbiAqIEBwYXJhbSB7TW9uZ29vc2V9IGJhc2UgYSBtb25nb29zZSBpbnN0YW5jZVxuICogQGluaGVyaXRzIE5vZGVKUyBFdmVudEVtaXR0ZXIgaHR0cHM6Ly9ub2RlanMub3JnL2FwaS9ldmVudHMuaHRtbCNjbGFzcy1ldmVudGVtaXR0ZXJcbiAqIEBldmVudCBgY29ubmVjdGluZ2A6IEVtaXR0ZWQgd2hlbiBgY29ubmVjdGlvbi5vcGVuVXJpKClgIGlzIGV4ZWN1dGVkIG9uIHRoaXMgY29ubmVjdGlvbi5cbiAqIEBldmVudCBgY29ubmVjdGVkYDogRW1pdHRlZCB3aGVuIHRoaXMgY29ubmVjdGlvbiBzdWNjZXNzZnVsbHkgY29ubmVjdHMgdG8gdGhlIGRiLiBNYXkgYmUgZW1pdHRlZCBfbXVsdGlwbGVfIHRpbWVzIGluIGByZWNvbm5lY3RlZGAgc2NlbmFyaW9zLlxuICogQGV2ZW50IGBvcGVuYDogRW1pdHRlZCBhZnRlciB3ZSBgY29ubmVjdGVkYCBhbmQgYG9uT3BlbmAgaXMgZXhlY3V0ZWQgb24gYWxsIG9mIHRoaXMgY29ubmVjdGlvbidzIG1vZGVscy5cbiAqIEBldmVudCBgZGlzY29ubmVjdGluZ2A6IEVtaXR0ZWQgd2hlbiBgY29ubmVjdGlvbi5jbG9zZSgpYCB3YXMgZXhlY3V0ZWQuXG4gKiBAZXZlbnQgYGRpc2Nvbm5lY3RlZGA6IEVtaXR0ZWQgYWZ0ZXIgZ2V0dGluZyBkaXNjb25uZWN0ZWQgZnJvbSB0aGUgZGIuXG4gKiBAZXZlbnQgYGNsb3NlYDogRW1pdHRlZCBhZnRlciB3ZSBgZGlzY29ubmVjdGVkYCBhbmQgYG9uQ2xvc2VgIGV4ZWN1dGVkIG9uIGFsbCBvZiB0aGlzIGNvbm5lY3Rpb24ncyBtb2RlbHMuXG4gKiBAZXZlbnQgYHJlY29ubmVjdGVkYDogRW1pdHRlZCBhZnRlciB3ZSBgY29ubmVjdGVkYCBhbmQgc3Vic2VxdWVudGx5IGBkaXNjb25uZWN0ZWRgLCBmb2xsb3dlZCBieSBzdWNjZXNzZnVsbHkgYW5vdGhlciBzdWNjZXNzZnVsIGNvbm5lY3Rpb24uXG4gKiBAZXZlbnQgYGVycm9yYDogRW1pdHRlZCB3aGVuIGFuIGVycm9yIG9jY3VycyBvbiB0aGlzIGNvbm5lY3Rpb24uXG4gKiBAZXZlbnQgYGZ1bGxzZXR1cGA6IEVtaXR0ZWQgYWZ0ZXIgdGhlIGRyaXZlciBoYXMgY29ubmVjdGVkIHRvIHByaW1hcnkgYW5kIGFsbCBzZWNvbmRhcmllcyBpZiBzcGVjaWZpZWQgaW4gdGhlIGNvbm5lY3Rpb24gc3RyaW5nLlxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5mdW5jdGlvbiBDb25uZWN0aW9uKGJhc2UpIHtcbiAgdGhpcy5iYXNlID0gYmFzZTtcbiAgdGhpcy5jb2xsZWN0aW9ucyA9IHt9O1xuICB0aGlzLm1vZGVscyA9IHt9O1xuICB0aGlzLmNvbmZpZyA9IHt9O1xuICB0aGlzLnJlcGxpY2EgPSBmYWxzZTtcbiAgdGhpcy5vcHRpb25zID0gbnVsbDtcbiAgdGhpcy5vdGhlckRicyA9IFtdOyAvLyBGSVhNRTogVG8gYmUgcmVwbGFjZWQgd2l0aCByZWxhdGVkRGJzXG4gIHRoaXMucmVsYXRlZERicyA9IHt9OyAvLyBIYXNobWFwIG9mIG90aGVyIGRicyB0aGF0IHNoYXJlIHVuZGVybHlpbmcgY29ubmVjdGlvblxuICB0aGlzLnN0YXRlcyA9IFNUQVRFUztcbiAgdGhpcy5fcmVhZHlTdGF0ZSA9IFNUQVRFUy5kaXNjb25uZWN0ZWQ7XG4gIHRoaXMuX2Nsb3NlQ2FsbGVkID0gZmFsc2U7XG4gIHRoaXMuX2hhc09wZW5lZCA9IGZhbHNlO1xuICB0aGlzLnBsdWdpbnMgPSBbXTtcbiAgaWYgKHR5cGVvZiBiYXNlID09PSAndW5kZWZpbmVkJyB8fCAhYmFzZS5jb25uZWN0aW9ucy5sZW5ndGgpIHtcbiAgICB0aGlzLmlkID0gMDtcbiAgfSBlbHNlIHtcbiAgICB0aGlzLmlkID0gYmFzZS5uZXh0Q29ubmVjdGlvbklkO1xuICB9XG4gIHRoaXMuX3F1ZXVlID0gW107XG59XG5cbi8qIVxuICogSW5oZXJpdCBmcm9tIEV2ZW50RW1pdHRlclxuICovXG5cbk9iamVjdC5zZXRQcm90b3R5cGVPZihDb25uZWN0aW9uLnByb3RvdHlwZSwgRXZlbnRFbWl0dGVyLnByb3RvdHlwZSk7XG5cbi8qKlxuICogQ29ubmVjdGlvbiByZWFkeSBzdGF0ZVxuICpcbiAqIC0gMCA9IGRpc2Nvbm5lY3RlZFxuICogLSAxID0gY29ubmVjdGVkXG4gKiAtIDIgPSBjb25uZWN0aW5nXG4gKiAtIDMgPSBkaXNjb25uZWN0aW5nXG4gKlxuICogRWFjaCBzdGF0ZSBjaGFuZ2UgZW1pdHMgaXRzIGFzc29jaWF0ZWQgZXZlbnQgbmFtZS5cbiAqXG4gKiAjIyMjIEV4YW1wbGU6XG4gKlxuICogICAgIGNvbm4ub24oJ2Nvbm5lY3RlZCcsIGNhbGxiYWNrKTtcbiAqICAgICBjb25uLm9uKCdkaXNjb25uZWN0ZWQnLCBjYWxsYmFjayk7XG4gKlxuICogQHByb3BlcnR5IHJlYWR5U3RhdGVcbiAqIEBtZW1iZXJPZiBDb25uZWN0aW9uXG4gKiBAaW5zdGFuY2VcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KENvbm5lY3Rpb24ucHJvdG90eXBlLCAncmVhZHlTdGF0ZScsIHtcbiAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy5fcmVhZHlTdGF0ZTtcbiAgfSxcbiAgc2V0OiBmdW5jdGlvbih2YWwpIHtcbiAgICBpZiAoISh2YWwgaW4gU1RBVEVTKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIGNvbm5lY3Rpb24gc3RhdGU6ICcgKyB2YWwpO1xuICAgIH1cblxuICAgIGlmICh0aGlzLl9yZWFkeVN0YXRlICE9PSB2YWwpIHtcbiAgICAgIHRoaXMuX3JlYWR5U3RhdGUgPSB2YWw7XG4gICAgICAvLyBbbGVnYWN5XSBsb29wIG92ZXIgdGhlIG90aGVyRGJzIG9uIHRoaXMgY29ubmVjdGlvbiBhbmQgY2hhbmdlIHRoZWlyIHN0YXRlXG4gICAgICBmb3IgKGNvbnN0IGRiIG9mIHRoaXMub3RoZXJEYnMpIHtcbiAgICAgICAgZGIucmVhZHlTdGF0ZSA9IHZhbDtcbiAgICAgIH1cblxuICAgICAgaWYgKFNUQVRFUy5jb25uZWN0ZWQgPT09IHZhbCkge1xuICAgICAgICB0aGlzLl9oYXNPcGVuZWQgPSB0cnVlO1xuICAgICAgfVxuXG4gICAgICB0aGlzLmVtaXQoU1RBVEVTW3ZhbF0pO1xuICAgIH1cbiAgfVxufSk7XG5cbi8qKlxuICogR2V0cyB0aGUgdmFsdWUgb2YgdGhlIG9wdGlvbiBga2V5YC4gRXF1aXZhbGVudCB0byBgY29ubi5vcHRpb25zW2tleV1gXG4gKlxuICogIyMjIyBFeGFtcGxlOlxuICpcbiAqICAgICBjb25uLmdldCgndGVzdCcpOyAvLyByZXR1cm5zIHRoZSAndGVzdCcgdmFsdWVcbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30ga2V5XG4gKiBAbWV0aG9kIGdldFxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5Db25uZWN0aW9uLnByb3RvdHlwZS5nZXQgPSBmdW5jdGlvbihrZXkpIHtcbiAgaWYgKHRoaXMuY29uZmlnLmhhc093blByb3BlcnR5KGtleSkpIHtcbiAgICByZXR1cm4gdGhpcy5jb25maWdba2V5XTtcbiAgfVxuXG4gIHJldHVybiBnZXQodGhpcy5vcHRpb25zLCBrZXkpO1xufTtcblxuLyoqXG4gKiBTZXRzIHRoZSB2YWx1ZSBvZiB0aGUgb3B0aW9uIGBrZXlgLiBFcXVpdmFsZW50IHRvIGBjb25uLm9wdGlvbnNba2V5XSA9IHZhbGBcbiAqXG4gKiBTdXBwb3J0ZWQgb3B0aW9ucyBpbmNsdWRlOlxuICpcbiAqIC0gYG1heFRpbWVNU2A6IFNldCBbYG1heFRpbWVNU2BdKGh0dHBzOi8vbW9uZ29vc2Vqcy5jb20vZG9jcy9hcGkvcXVlcnkuaHRtbCNRdWVyeS5wcm90b3R5cGUubWF4VGltZU1TKCkpIGZvciBhbGwgcXVlcmllcyBvbiB0aGlzIGNvbm5lY3Rpb24uXG4gKiAtICdkZWJ1Zyc6IElmIGB0cnVlYCwgcHJpbnRzIHRoZSBvcGVyYXRpb25zIG1vbmdvb3NlIHNlbmRzIHRvIE1vbmdvREIgdG8gdGhlIGNvbnNvbGUuIElmIGEgd3JpdGFibGUgc3RyZWFtIGlzIHBhc3NlZCwgaXQgd2lsbCBsb2cgdG8gdGhhdCBzdHJlYW0sIHdpdGhvdXQgY29sb3JpemF0aW9uLiBJZiBhIGNhbGxiYWNrIGZ1bmN0aW9uIGlzIHBhc3NlZCwgaXQgd2lsbCByZWNlaXZlIHRoZSBjb2xsZWN0aW9uIG5hbWUsIHRoZSBtZXRob2QgbmFtZSwgdGhlbiBhbGwgYXJ1Z21lbnRzIHBhc3NlZCB0byB0aGUgbWV0aG9kLiBGb3IgZXhhbXBsZSwgaWYgeW91IHdhbnRlZCB0byByZXBsaWNhdGUgdGhlIGRlZmF1bHQgbG9nZ2luZywgeW91IGNvdWxkIG91dHB1dCBmcm9tIHRoZSBjYWxsYmFjayBgTW9uZ29vc2U6ICR7Y29sbGVjdGlvbk5hbWV9LiR7bWV0aG9kTmFtZX0oJHttZXRob2RBcmdzLmpvaW4oJywgJyl9KWAuXG4gKlxuICogIyMjIyBFeGFtcGxlOlxuICpcbiAqICAgICBjb25uLnNldCgndGVzdCcsICdmb28nKTtcbiAqICAgICBjb25uLmdldCgndGVzdCcpOyAvLyAnZm9vJ1xuICogICAgIGNvbm4ub3B0aW9ucy50ZXN0OyAvLyAnZm9vJ1xuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBrZXlcbiAqIEBwYXJhbSB7QW55fSB2YWxcbiAqIEBtZXRob2Qgc2V0XG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbkNvbm5lY3Rpb24ucHJvdG90eXBlLnNldCA9IGZ1bmN0aW9uKGtleSwgdmFsKSB7XG4gIGlmICh0aGlzLmNvbmZpZy5oYXNPd25Qcm9wZXJ0eShrZXkpKSB7XG4gICAgdGhpcy5jb25maWdba2V5XSA9IHZhbDtcbiAgICByZXR1cm4gdmFsO1xuICB9XG5cbiAgdGhpcy5vcHRpb25zID0gdGhpcy5vcHRpb25zIHx8IHt9O1xuICB0aGlzLm9wdGlvbnNba2V5XSA9IHZhbDtcbiAgcmV0dXJuIHZhbDtcbn07XG5cbi8qKlxuICogQSBoYXNoIG9mIHRoZSBjb2xsZWN0aW9ucyBhc3NvY2lhdGVkIHdpdGggdGhpcyBjb25uZWN0aW9uXG4gKlxuICogQHByb3BlcnR5IGNvbGxlY3Rpb25zXG4gKiBAbWVtYmVyT2YgQ29ubmVjdGlvblxuICogQGluc3RhbmNlXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbkNvbm5lY3Rpb24ucHJvdG90eXBlLmNvbGxlY3Rpb25zO1xuXG4vKipcbiAqIFRoZSBuYW1lIG9mIHRoZSBkYXRhYmFzZSB0aGlzIGNvbm5lY3Rpb24gcG9pbnRzIHRvLlxuICpcbiAqICMjIyMgRXhhbXBsZTpcbiAqXG4gKiAgICAgbW9uZ29vc2UuY3JlYXRlQ29ubmVjdGlvbignbW9uZ29kYjovLzEyNy4wLjAuMToyNzAxNy9teWRiJykubmFtZTsgLy8gXCJteWRiXCJcbiAqXG4gKiBAcHJvcGVydHkgbmFtZVxuICogQG1lbWJlck9mIENvbm5lY3Rpb25cbiAqIEBpbnN0YW5jZVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5Db25uZWN0aW9uLnByb3RvdHlwZS5uYW1lO1xuXG4vKipcbiAqIEEgW1BPSk9dKGh0dHBzOi8vbWFzdGVyaW5nanMuaW8vdHV0b3JpYWxzL2Z1bmRhbWVudGFscy9wb2pvKSBjb250YWluaW5nXG4gKiBhIG1hcCBmcm9tIG1vZGVsIG5hbWVzIHRvIG1vZGVscy4gQ29udGFpbnMgYWxsIG1vZGVscyB0aGF0IGhhdmUgYmVlblxuICogYWRkZWQgdG8gdGhpcyBjb25uZWN0aW9uIHVzaW5nIFtgQ29ubmVjdGlvbiNtb2RlbCgpYF0oaHR0cHM6Ly9tb25nb29zZWpzLmNvbS9kb2NzL2FwaS9jb25uZWN0aW9uLmh0bWwjQ29ubmVjdGlvbi5wcm90b3R5cGUubW9kZWwoKSkuXG4gKlxuICogIyMjIyBFeGFtcGxlOlxuICpcbiAqICAgICBjb25zdCBjb25uID0gbW9uZ29vc2UuY3JlYXRlQ29ubmVjdGlvbigpO1xuICogICAgIGNvbnN0IFRlc3QgPSBjb25uLm1vZGVsKCdUZXN0JywgbW9uZ29vc2UuU2NoZW1hKHsgbmFtZTogU3RyaW5nIH0pKTtcbiAqXG4gKiAgICAgT2JqZWN0LmtleXMoY29ubi5tb2RlbHMpLmxlbmd0aDsgLy8gMVxuICogICAgIGNvbm4ubW9kZWxzLlRlc3QgPT09IFRlc3Q7IC8vIHRydWVcbiAqXG4gKiBAcHJvcGVydHkgbW9kZWxzXG4gKiBAbWVtYmVyT2YgQ29ubmVjdGlvblxuICogQGluc3RhbmNlXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbkNvbm5lY3Rpb24ucHJvdG90eXBlLm1vZGVscztcblxuLyoqXG4gKiBBIG51bWJlciBpZGVudGlmaWVyIGZvciB0aGlzIGNvbm5lY3Rpb24uIFVzZWQgZm9yIGRlYnVnZ2luZyB3aGVuXG4gKiB5b3UgaGF2ZSBbbXVsdGlwbGUgY29ubmVjdGlvbnNdKGh0dHBzOi8vbW9uZ29vc2Vqcy5jb20vZG9jcy9jb25uZWN0aW9ucy5odG1sI211bHRpcGxlX2Nvbm5lY3Rpb25zKS5cbiAqXG4gKiAjIyMjIEV4YW1wbGU6XG4gKlxuICogICAgIC8vIFRoZSBkZWZhdWx0IGNvbm5lY3Rpb24gaGFzIGBpZCA9IDBgXG4gKiAgICAgbW9uZ29vc2UuY29ubmVjdGlvbi5pZDsgLy8gMFxuICpcbiAqICAgICAvLyBJZiB5b3UgY3JlYXRlIGEgbmV3IGNvbm5lY3Rpb24sIE1vbmdvb3NlIGluY3JlbWVudHMgaWRcbiAqICAgICBjb25zdCBjb25uID0gbW9uZ29vc2UuY3JlYXRlQ29ubmVjdGlvbigpO1xuICogICAgIGNvbm4uaWQ7IC8vIDFcbiAqXG4gKiBAcHJvcGVydHkgaWRcbiAqIEBtZW1iZXJPZiBDb25uZWN0aW9uXG4gKiBAaW5zdGFuY2VcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuQ29ubmVjdGlvbi5wcm90b3R5cGUuaWQ7XG5cbi8qKlxuICogVGhlIHBsdWdpbnMgdGhhdCB3aWxsIGJlIGFwcGxpZWQgdG8gYWxsIG1vZGVscyBjcmVhdGVkIG9uIHRoaXMgY29ubmVjdGlvbi5cbiAqXG4gKiAjIyMjIEV4YW1wbGU6XG4gKlxuICogICAgIGNvbnN0IGRiID0gbW9uZ29vc2UuY3JlYXRlQ29ubmVjdGlvbignbW9uZ29kYjovLzEyNy4wLjAuMToyNzAxNy9teWRiJyk7XG4gKiAgICAgZGIucGx1Z2luKCgpID0+IGNvbnNvbGUubG9nKCdBcHBsaWVkJykpO1xuICogICAgIGRiLnBsdWdpbnMubGVuZ3RoOyAvLyAxXG4gKlxuICogICAgIGRiLm1vZGVsKCdUZXN0JywgbmV3IFNjaGVtYSh7fSkpOyAvLyBQcmludHMgXCJBcHBsaWVkXCJcbiAqXG4gKiBAcHJvcGVydHkgcGx1Z2luc1xuICogQG1lbWJlck9mIENvbm5lY3Rpb25cbiAqIEBpbnN0YW5jZVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoQ29ubmVjdGlvbi5wcm90b3R5cGUsICdwbHVnaW5zJywge1xuICBjb25maWd1cmFibGU6IGZhbHNlLFxuICBlbnVtZXJhYmxlOiB0cnVlLFxuICB3cml0YWJsZTogdHJ1ZVxufSk7XG5cbi8qKlxuICogVGhlIGhvc3QgbmFtZSBwb3J0aW9uIG9mIHRoZSBVUkkuIElmIG11bHRpcGxlIGhvc3RzLCBzdWNoIGFzIGEgcmVwbGljYSBzZXQsXG4gKiB0aGlzIHdpbGwgY29udGFpbiB0aGUgZmlyc3QgaG9zdCBuYW1lIGluIHRoZSBVUklcbiAqXG4gKiAjIyMjIEV4YW1wbGU6XG4gKlxuICogICAgIG1vbmdvb3NlLmNyZWF0ZUNvbm5lY3Rpb24oJ21vbmdvZGI6Ly8xMjcuMC4wLjE6MjcwMTcvbXlkYicpLmhvc3Q7IC8vIFwiMTI3LjAuMC4xXCJcbiAqXG4gKiBAcHJvcGVydHkgaG9zdFxuICogQG1lbWJlck9mIENvbm5lY3Rpb25cbiAqIEBpbnN0YW5jZVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoQ29ubmVjdGlvbi5wcm90b3R5cGUsICdob3N0Jywge1xuICBjb25maWd1cmFibGU6IHRydWUsXG4gIGVudW1lcmFibGU6IHRydWUsXG4gIHdyaXRhYmxlOiB0cnVlXG59KTtcblxuLyoqXG4gKiBUaGUgcG9ydCBwb3J0aW9uIG9mIHRoZSBVUkkuIElmIG11bHRpcGxlIGhvc3RzLCBzdWNoIGFzIGEgcmVwbGljYSBzZXQsXG4gKiB0aGlzIHdpbGwgY29udGFpbiB0aGUgcG9ydCBmcm9tIHRoZSBmaXJzdCBob3N0IG5hbWUgaW4gdGhlIFVSSS5cbiAqXG4gKiAjIyMjIEV4YW1wbGU6XG4gKlxuICogICAgIG1vbmdvb3NlLmNyZWF0ZUNvbm5lY3Rpb24oJ21vbmdvZGI6Ly8xMjcuMC4wLjE6MjcwMTcvbXlkYicpLnBvcnQ7IC8vIDI3MDE3XG4gKlxuICogQHByb3BlcnR5IHBvcnRcbiAqIEBtZW1iZXJPZiBDb25uZWN0aW9uXG4gKiBAaW5zdGFuY2VcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KENvbm5lY3Rpb24ucHJvdG90eXBlLCAncG9ydCcsIHtcbiAgY29uZmlndXJhYmxlOiB0cnVlLFxuICBlbnVtZXJhYmxlOiB0cnVlLFxuICB3cml0YWJsZTogdHJ1ZVxufSk7XG5cbi8qKlxuICogVGhlIHVzZXJuYW1lIHNwZWNpZmllZCBpbiB0aGUgVVJJXG4gKlxuICogIyMjIyBFeGFtcGxlOlxuICpcbiAqICAgICBtb25nb29zZS5jcmVhdGVDb25uZWN0aW9uKCdtb25nb2RiOi8vdmFsOnBzd0AxMjcuMC4wLjE6MjcwMTcvbXlkYicpLnVzZXI7IC8vIFwidmFsXCJcbiAqXG4gKiBAcHJvcGVydHkgdXNlclxuICogQG1lbWJlck9mIENvbm5lY3Rpb25cbiAqIEBpbnN0YW5jZVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoQ29ubmVjdGlvbi5wcm90b3R5cGUsICd1c2VyJywge1xuICBjb25maWd1cmFibGU6IHRydWUsXG4gIGVudW1lcmFibGU6IHRydWUsXG4gIHdyaXRhYmxlOiB0cnVlXG59KTtcblxuLyoqXG4gKiBUaGUgcGFzc3dvcmQgc3BlY2lmaWVkIGluIHRoZSBVUklcbiAqXG4gKiAjIyMjIEV4YW1wbGU6XG4gKlxuICogICAgIG1vbmdvb3NlLmNyZWF0ZUNvbm5lY3Rpb24oJ21vbmdvZGI6Ly92YWw6cHN3QDEyNy4wLjAuMToyNzAxNy9teWRiJykucGFzczsgLy8gXCJwc3dcIlxuICpcbiAqIEBwcm9wZXJ0eSBwYXNzXG4gKiBAbWVtYmVyT2YgQ29ubmVjdGlvblxuICogQGluc3RhbmNlXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShDb25uZWN0aW9uLnByb3RvdHlwZSwgJ3Bhc3MnLCB7XG4gIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgd3JpdGFibGU6IHRydWVcbn0pO1xuXG4vKipcbiAqIFRoZSBtb25nb2RiLkRiIGluc3RhbmNlLCBzZXQgd2hlbiB0aGUgY29ubmVjdGlvbiBpcyBvcGVuZWRcbiAqXG4gKiBAcHJvcGVydHkgZGJcbiAqIEBtZW1iZXJPZiBDb25uZWN0aW9uXG4gKiBAaW5zdGFuY2VcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuQ29ubmVjdGlvbi5wcm90b3R5cGUuZGI7XG5cbi8qKlxuICogVGhlIE1vbmdvQ2xpZW50IGluc3RhbmNlIHRoaXMgY29ubmVjdGlvbiB1c2VzIHRvIHRhbGsgdG8gTW9uZ29EQi4gTW9uZ29vc2UgYXV0b21hdGljYWxseSBzZXRzIHRoaXMgcHJvcGVydHlcbiAqIHdoZW4gdGhlIGNvbm5lY3Rpb24gaXMgb3BlbmVkLlxuICpcbiAqIEBwcm9wZXJ0eSBjbGllbnRcbiAqIEBtZW1iZXJPZiBDb25uZWN0aW9uXG4gKiBAaW5zdGFuY2VcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuQ29ubmVjdGlvbi5wcm90b3R5cGUuY2xpZW50O1xuXG4vKipcbiAqIEEgaGFzaCBvZiB0aGUgZ2xvYmFsIG9wdGlvbnMgdGhhdCBhcmUgYXNzb2NpYXRlZCB3aXRoIHRoaXMgY29ubmVjdGlvblxuICpcbiAqIEBwcm9wZXJ0eSBjb25maWdcbiAqIEBtZW1iZXJPZiBDb25uZWN0aW9uXG4gKiBAaW5zdGFuY2VcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuQ29ubmVjdGlvbi5wcm90b3R5cGUuY29uZmlnO1xuXG4vKipcbiAqIEhlbHBlciBmb3IgYGNyZWF0ZUNvbGxlY3Rpb24oKWAuIFdpbGwgZXhwbGljaXRseSBjcmVhdGUgdGhlIGdpdmVuIGNvbGxlY3Rpb25cbiAqIHdpdGggc3BlY2lmaWVkIG9wdGlvbnMuIFVzZWQgdG8gY3JlYXRlIFtjYXBwZWQgY29sbGVjdGlvbnNdKGh0dHBzOi8vd3d3Lm1vbmdvZGIuY29tL2RvY3MvbWFudWFsL2NvcmUvY2FwcGVkLWNvbGxlY3Rpb25zLylcbiAqIGFuZCBbdmlld3NdKGh0dHBzOi8vd3d3Lm1vbmdvZGIuY29tL2RvY3MvbWFudWFsL2NvcmUvdmlld3MvKSBmcm9tIG1vbmdvb3NlLlxuICpcbiAqIE9wdGlvbnMgYXJlIHBhc3NlZCBkb3duIHdpdGhvdXQgbW9kaWZpY2F0aW9uIHRvIHRoZSBbTW9uZ29EQiBkcml2ZXIncyBgY3JlYXRlQ29sbGVjdGlvbigpYCBmdW5jdGlvbl0oaHR0cHM6Ly9tb25nb2RiLmdpdGh1Yi5pby9ub2RlLW1vbmdvZGItbmF0aXZlLzQuOS9jbGFzc2VzL0RiLmh0bWwjY3JlYXRlQ29sbGVjdGlvbilcbiAqXG4gKiBAbWV0aG9kIGNyZWF0ZUNvbGxlY3Rpb25cbiAqIEBwYXJhbSB7c3RyaW5nfSBjb2xsZWN0aW9uIFRoZSBjb2xsZWN0aW9uIHRvIGNyZWF0ZVxuICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSBzZWUgW01vbmdvREIgZHJpdmVyIGRvY3NdKGh0dHBzOi8vbW9uZ29kYi5naXRodWIuaW8vbm9kZS1tb25nb2RiLW5hdGl2ZS80LjkvY2xhc3Nlcy9EYi5odG1sI2NyZWF0ZUNvbGxlY3Rpb24pXG4gKiBAcmV0dXJuIHtQcm9taXNlfVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5Db25uZWN0aW9uLnByb3RvdHlwZS5jcmVhdGVDb2xsZWN0aW9uID0gYXN5bmMgZnVuY3Rpb24gY3JlYXRlQ29sbGVjdGlvbihjb2xsZWN0aW9uLCBvcHRpb25zKSB7XG4gIGlmICh0eXBlb2Ygb3B0aW9ucyA9PT0gJ2Z1bmN0aW9uJyB8fCAoYXJndW1lbnRzLmxlbmd0aCA+PSAzICYmIHR5cGVvZiBhcmd1bWVudHNbMl0gPT09ICdmdW5jdGlvbicpKSB7XG4gICAgdGhyb3cgbmV3IE1vbmdvb3NlRXJyb3IoJ0Nvbm5lY3Rpb24ucHJvdG90eXBlLmNyZWF0ZUNvbGxlY3Rpb24oKSBubyBsb25nZXIgYWNjZXB0cyBhIGNhbGxiYWNrJyk7XG4gIH1cblxuICBpZiAoKHRoaXMucmVhZHlTdGF0ZSA9PT0gU1RBVEVTLmNvbm5lY3RpbmcgfHwgdGhpcy5yZWFkeVN0YXRlID09PSBTVEFURVMuZGlzY29ubmVjdGVkKSAmJiB0aGlzLl9zaG91bGRCdWZmZXJDb21tYW5kcygpKSB7XG4gICAgYXdhaXQgbmV3IFByb21pc2UocmVzb2x2ZSA9PiB7XG4gICAgICB0aGlzLl9xdWV1ZS5wdXNoKHsgZm46IHJlc29sdmUgfSk7XG4gICAgfSk7XG4gIH1cblxuICByZXR1cm4gdGhpcy5kYi5jcmVhdGVDb2xsZWN0aW9uKGNvbGxlY3Rpb24sIG9wdGlvbnMpO1xufTtcblxuLyoqXG4gKiBDYWxscyBgY3JlYXRlQ29sbGVjdGlvbigpYCBvbiBhIG1vZGVscyBpbiBhIHNlcmllcy5cbiAqXG4gKiBAbWV0aG9kIGNyZWF0ZUNvbGxlY3Rpb25zXG4gKiBAcGFyYW0ge0Jvb2xlYW59IGNvbnRpbnVlT25FcnJvciBXaGVuIHRydWUsIHdpbGwgY29udGludWUgdG8gY3JlYXRlIGNvbGxlY3Rpb25zIGFuZCBjcmVhdGUgYSBuZXcgZXJyb3IgY2xhc3MgZm9yIHRoZSBjb2xsZWN0aW9ucyB0aGF0IGVycm9yZWQuXG4gKiBAcmV0dXJucyB7UHJvbWlzZX1cbiAqIEBhcGkgcHVibGljXG4gKi9cblxuQ29ubmVjdGlvbi5wcm90b3R5cGUuY3JlYXRlQ29sbGVjdGlvbnMgPSBhc3luYyBmdW5jdGlvbiBjcmVhdGVDb2xsZWN0aW9ucyhvcHRpb25zID0ge30pIHtcbiAgY29uc3QgcmVzdWx0ID0ge307XG4gIGNvbnN0IGVycm9yc01hcCA9IHsgfTtcblxuICBjb25zdCB7IGNvbnRpbnVlT25FcnJvciB9ID0gb3B0aW9ucztcbiAgZGVsZXRlIG9wdGlvbnMuY29udGludWVPbkVycm9yO1xuICBmb3IgKGNvbnN0IG1vZGVsIG9mIE9iamVjdC52YWx1ZXModGhpcy5tb2RlbHMpKSB7XG4gICAgdHJ5IHtcbiAgICAgIHJlc3VsdFttb2RlbC5tb2RlbE5hbWVdID0gYXdhaXQgbW9kZWwuY3JlYXRlQ29sbGVjdGlvbih7fSk7XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICBpZiAoIWNvbnRpbnVlT25FcnJvcikge1xuICAgICAgICBlcnJvcnNNYXBbbW9kZWwubW9kZWxOYW1lXSA9IGVycjtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXN1bHRbbW9kZWwubW9kZWxOYW1lXSA9IGVycjtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBpZiAoIWNvbnRpbnVlT25FcnJvciAmJiBPYmplY3Qua2V5cyhlcnJvcnNNYXApLmxlbmd0aCkge1xuICAgIGNvbnN0IG1lc3NhZ2UgPSBPYmplY3QuZW50cmllcyhlcnJvcnNNYXApLm1hcCgoW21vZGVsTmFtZSwgZXJyXSkgPT4gYCR7bW9kZWxOYW1lfTogJHtlcnIubWVzc2FnZX1gKS5qb2luKCcsICcpO1xuICAgIGNvbnN0IGNyZWF0ZUNvbGxlY3Rpb25zRXJyb3IgPSBuZXcgQ3JlYXRlQ29sbGVjdGlvbnNFcnJvcihtZXNzYWdlLCBlcnJvcnNNYXApO1xuICAgIHRocm93IGNyZWF0ZUNvbGxlY3Rpb25zRXJyb3I7XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn07XG5cbi8qKlxuICogX1JlcXVpcmVzIE1vbmdvREIgPj0gMy42LjAuXyBTdGFydHMgYSBbTW9uZ29EQiBzZXNzaW9uXShodHRwczovL3d3dy5tb25nb2RiLmNvbS9kb2NzL21hbnVhbC9yZWxlYXNlLW5vdGVzLzMuNi8jY2xpZW50LXNlc3Npb25zKVxuICogZm9yIGJlbmVmaXRzIGxpa2UgY2F1c2FsIGNvbnNpc3RlbmN5LCBbcmV0cnlhYmxlIHdyaXRlc10oaHR0cHM6Ly93d3cubW9uZ29kYi5jb20vZG9jcy9tYW51YWwvY29yZS9yZXRyeWFibGUtd3JpdGVzLyksXG4gKiBhbmQgW3RyYW5zYWN0aW9uc10oaHR0cHM6Ly90aGVjb2RlYmFyYmFyaWFuLmNvbS9hLW5vZGUtanMtcGVyc3BlY3RpdmUtb24tbW9uZ29kYi00LXRyYW5zYWN0aW9ucy5odG1sKS5cbiAqXG4gKiAjIyMjIEV4YW1wbGU6XG4gKlxuICogICAgIGNvbnN0IHNlc3Npb24gPSBhd2FpdCBjb25uLnN0YXJ0U2Vzc2lvbigpO1xuICogICAgIGxldCBkb2MgPSBhd2FpdCBQZXJzb24uZmluZE9uZSh7IG5hbWU6ICdOZWQgU3RhcmsnIH0sIG51bGwsIHsgc2Vzc2lvbiB9KTtcbiAqICAgICBhd2FpdCBkb2MucmVtb3ZlKCk7XG4gKiAgICAgLy8gYGRvY2Agd2lsbCBhbHdheXMgYmUgbnVsbCwgZXZlbiBpZiByZWFkaW5nIGZyb20gYSByZXBsaWNhIHNldFxuICogICAgIC8vIHNlY29uZGFyeS4gV2l0aG91dCBjYXVzYWwgY29uc2lzdGVuY3ksIGl0IGlzIHBvc3NpYmxlIHRvXG4gKiAgICAgLy8gZ2V0IGEgZG9jIGJhY2sgZnJvbSB0aGUgYmVsb3cgcXVlcnkgaWYgdGhlIHF1ZXJ5IHJlYWRzIGZyb20gYVxuICogICAgIC8vIHNlY29uZGFyeSB0aGF0IGlzIGV4cGVyaWVuY2luZyByZXBsaWNhdGlvbiBsYWcuXG4gKiAgICAgZG9jID0gYXdhaXQgUGVyc29uLmZpbmRPbmUoeyBuYW1lOiAnTmVkIFN0YXJrJyB9LCBudWxsLCB7IHNlc3Npb24sIHJlYWRQcmVmZXJlbmNlOiAnc2Vjb25kYXJ5JyB9KTtcbiAqXG4gKlxuICogQG1ldGhvZCBzdGFydFNlc3Npb25cbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gc2VlIHRoZSBbbW9uZ29kYiBkcml2ZXIgb3B0aW9uc10oaHR0cHM6Ly9tb25nb2RiLmdpdGh1Yi5pby9ub2RlLW1vbmdvZGItbmF0aXZlLzQuOS9jbGFzc2VzL01vbmdvQ2xpZW50Lmh0bWwjc3RhcnRTZXNzaW9uKVxuICogQHBhcmFtIHtCb29sZWFufSBbb3B0aW9ucy5jYXVzYWxDb25zaXN0ZW5jeT10cnVlXSBzZXQgdG8gZmFsc2UgdG8gZGlzYWJsZSBjYXVzYWwgY29uc2lzdGVuY3lcbiAqIEByZXR1cm4ge1Byb21pc2U8Q2xpZW50U2Vzc2lvbj59IHByb21pc2UgdGhhdCByZXNvbHZlcyB0byBhIE1vbmdvREIgZHJpdmVyIGBDbGllbnRTZXNzaW9uYFxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5Db25uZWN0aW9uLnByb3RvdHlwZS5zdGFydFNlc3Npb24gPSBhc3luYyBmdW5jdGlvbiBzdGFydFNlc3Npb24ob3B0aW9ucykge1xuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA+PSAyICYmIHR5cGVvZiBhcmd1bWVudHNbMV0gPT09ICdmdW5jdGlvbicpIHtcbiAgICB0aHJvdyBuZXcgTW9uZ29vc2VFcnJvcignQ29ubmVjdGlvbi5wcm90b3R5cGUuc3RhcnRTZXNzaW9uKCkgbm8gbG9uZ2VyIGFjY2VwdHMgYSBjYWxsYmFjaycpO1xuICB9XG5cbiAgaWYgKCh0aGlzLnJlYWR5U3RhdGUgPT09IFNUQVRFUy5jb25uZWN0aW5nIHx8IHRoaXMucmVhZHlTdGF0ZSA9PT0gU1RBVEVTLmRpc2Nvbm5lY3RlZCkgJiYgdGhpcy5fc2hvdWxkQnVmZmVyQ29tbWFuZHMoKSkge1xuICAgIGF3YWl0IG5ldyBQcm9taXNlKHJlc29sdmUgPT4ge1xuICAgICAgdGhpcy5fcXVldWUucHVzaCh7IGZuOiByZXNvbHZlIH0pO1xuICAgIH0pO1xuICB9XG5cbiAgY29uc3Qgc2Vzc2lvbiA9IHRoaXMuY2xpZW50LnN0YXJ0U2Vzc2lvbihvcHRpb25zKTtcbiAgcmV0dXJuIHNlc3Npb247XG59O1xuXG4vKipcbiAqIF9SZXF1aXJlcyBNb25nb0RCID49IDMuNi4wLl8gRXhlY3V0ZXMgdGhlIHdyYXBwZWQgYXN5bmMgZnVuY3Rpb25cbiAqIGluIGEgdHJhbnNhY3Rpb24uIE1vbmdvb3NlIHdpbGwgY29tbWl0IHRoZSB0cmFuc2FjdGlvbiBpZiB0aGVcbiAqIGFzeW5jIGZ1bmN0aW9uIGV4ZWN1dGVzIHN1Y2Nlc3NmdWxseSBhbmQgYXR0ZW1wdCB0byByZXRyeSBpZlxuICogdGhlcmUgd2FzIGEgcmV0cmlhYmxlIGVycm9yLlxuICpcbiAqIENhbGxzIHRoZSBNb25nb0RCIGRyaXZlcidzIFtgc2Vzc2lvbi53aXRoVHJhbnNhY3Rpb24oKWBdKGh0dHBzOi8vbW9uZ29kYi5naXRodWIuaW8vbm9kZS1tb25nb2RiLW5hdGl2ZS80LjkvY2xhc3Nlcy9DbGllbnRTZXNzaW9uLmh0bWwjd2l0aFRyYW5zYWN0aW9uKSxcbiAqIGJ1dCBhbHNvIGhhbmRsZXMgcmVzZXR0aW5nIE1vbmdvb3NlIGRvY3VtZW50IHN0YXRlIGFzIHNob3duIGJlbG93LlxuICpcbiAqICMjIyMgRXhhbXBsZTpcbiAqXG4gKiAgICAgY29uc3QgZG9jID0gbmV3IFBlcnNvbih7IG5hbWU6ICdXaWxsIFJpa2VyJyB9KTtcbiAqICAgICBhd2FpdCBkYi50cmFuc2FjdGlvbihhc3luYyBmdW5jdGlvbiBzZXRSYW5rKHNlc3Npb24pIHtcbiAqICAgICAgIGRvYy5yYW5rID0gJ0NhcHRhaW4nO1xuICogICAgICAgYXdhaXQgZG9jLnNhdmUoeyBzZXNzaW9uIH0pO1xuICogICAgICAgZG9jLmlzTmV3OyAvLyBmYWxzZVxuICpcbiAqICAgICAgIC8vIFRocm93IGFuIGVycm9yIHRvIGFib3J0IHRoZSB0cmFuc2FjdGlvblxuICogICAgICAgdGhyb3cgbmV3IEVycm9yKCdPb3BzIScpO1xuICogICAgIH0seyByZWFkUHJlZmVyZW5jZTogJ3ByaW1hcnknIH0pLmNhdGNoKCgpID0+IHt9KTtcbiAqXG4gKiAgICAgLy8gdHJ1ZSwgYHRyYW5zYWN0aW9uKClgIHJlc2V0IHRoZSBkb2N1bWVudCdzIHN0YXRlIGJlY2F1c2UgdGhlXG4gKiAgICAgLy8gdHJhbnNhY3Rpb24gd2FzIGFib3J0ZWQuXG4gKiAgICAgZG9jLmlzTmV3O1xuICpcbiAqIEBtZXRob2QgdHJhbnNhY3Rpb25cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuIEZ1bmN0aW9uIHRvIGV4ZWN1dGUgaW4gYSB0cmFuc2FjdGlvblxuICogQHBhcmFtIHttb25nb2RiLlRyYW5zYWN0aW9uT3B0aW9uc30gW29wdGlvbnNdIE9wdGlvbmFsIHNldHRpbmdzIGZvciB0aGUgdHJhbnNhY3Rpb25cbiAqIEByZXR1cm4ge1Byb21pc2U8QW55Pn0gcHJvbWlzZSB0aGF0IGlzIGZ1bGZpbGxlZCBpZiBNb25nb29zZSBzdWNjZXNzZnVsbHkgY29tbWl0dGVkIHRoZSB0cmFuc2FjdGlvbiwgb3IgcmVqZWN0cyBpZiB0aGUgdHJhbnNhY3Rpb24gd2FzIGFib3J0ZWQgb3IgaWYgTW9uZ29vc2UgZmFpbGVkIHRvIGNvbW1pdCB0aGUgdHJhbnNhY3Rpb24uIElmIGZ1bGZpbGxlZCwgdGhlIHByb21pc2UgcmVzb2x2ZXMgdG8gYSBNb25nb0RCIGNvbW1hbmQgcmVzdWx0LlxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5Db25uZWN0aW9uLnByb3RvdHlwZS50cmFuc2FjdGlvbiA9IGZ1bmN0aW9uIHRyYW5zYWN0aW9uKGZuLCBvcHRpb25zKSB7XG4gIHJldHVybiB0aGlzLnN0YXJ0U2Vzc2lvbigpLnRoZW4oc2Vzc2lvbiA9PiB7XG4gICAgc2Vzc2lvbltzZXNzaW9uTmV3RG9jdW1lbnRzXSA9IG5ldyBNYXAoKTtcbiAgICByZXR1cm4gc2Vzc2lvbi53aXRoVHJhbnNhY3Rpb24oKCkgPT4gX3dyYXBVc2VyVHJhbnNhY3Rpb24oZm4sIHNlc3Npb24pLCBvcHRpb25zKS5cbiAgICAgIHRoZW4ocmVzID0+IHtcbiAgICAgICAgZGVsZXRlIHNlc3Npb25bc2Vzc2lvbk5ld0RvY3VtZW50c107XG4gICAgICAgIHJldHVybiByZXM7XG4gICAgICB9KS5cbiAgICAgIGNhdGNoKGVyciA9PiB7XG4gICAgICAgIGRlbGV0ZSBzZXNzaW9uW3Nlc3Npb25OZXdEb2N1bWVudHNdO1xuICAgICAgICB0aHJvdyBlcnI7XG4gICAgICB9KS5cbiAgICAgIGZpbmFsbHkoKCkgPT4ge1xuICAgICAgICBzZXNzaW9uLmVuZFNlc3Npb24oKS5jYXRjaCgoKSA9PiB7fSk7XG4gICAgICB9KTtcbiAgfSk7XG59O1xuXG4vKiFcbiAqIFJlc2V0IGRvY3VtZW50IHN0YXRlIGluIGJldHdlZW4gdHJhbnNhY3Rpb24gcmV0cmllcyByZTogZ2gtMTM2OThcbiAqL1xuXG5hc3luYyBmdW5jdGlvbiBfd3JhcFVzZXJUcmFuc2FjdGlvbihmbiwgc2Vzc2lvbikge1xuICB0cnkge1xuICAgIGNvbnN0IHJlcyA9IGF3YWl0IGZuKHNlc3Npb24pO1xuICAgIHJldHVybiByZXM7XG4gIH0gY2F0Y2ggKGVycikge1xuICAgIF9yZXNldFNlc3Npb25Eb2N1bWVudHMoc2Vzc2lvbik7XG4gICAgdGhyb3cgZXJyO1xuICB9XG59XG5cbi8qIVxuICogSWYgdHJhbnNhY3Rpb24gd2FzIGFib3J0ZWQsIHdlIG5lZWQgdG8gcmVzZXQgbmV3bHkgaW5zZXJ0ZWQgZG9jdW1lbnRzJyBgaXNOZXdgLlxuICovXG5mdW5jdGlvbiBfcmVzZXRTZXNzaW9uRG9jdW1lbnRzKHNlc3Npb24pIHtcbiAgZm9yIChjb25zdCBkb2Mgb2Ygc2Vzc2lvbltzZXNzaW9uTmV3RG9jdW1lbnRzXS5rZXlzKCkpIHtcbiAgICBjb25zdCBzdGF0ZSA9IHNlc3Npb25bc2Vzc2lvbk5ld0RvY3VtZW50c10uZ2V0KGRvYyk7XG4gICAgaWYgKHN0YXRlLmhhc093blByb3BlcnR5KCdpc05ldycpKSB7XG4gICAgICBkb2MuJGlzTmV3ID0gc3RhdGUuaXNOZXc7XG4gICAgfVxuICAgIGlmIChzdGF0ZS5oYXNPd25Qcm9wZXJ0eSgndmVyc2lvbktleScpKSB7XG4gICAgICBkb2Muc2V0KGRvYy5zY2hlbWEub3B0aW9ucy52ZXJzaW9uS2V5LCBzdGF0ZS52ZXJzaW9uS2V5KTtcbiAgICB9XG5cbiAgICBpZiAoc3RhdGUubW9kaWZpZWRQYXRocy5sZW5ndGggPiAwICYmIGRvYy4kX18uYWN0aXZlUGF0aHMuc3RhdGVzLm1vZGlmeSA9PSBudWxsKSB7XG4gICAgICBkb2MuJF9fLmFjdGl2ZVBhdGhzLnN0YXRlcy5tb2RpZnkgPSB7fTtcbiAgICB9XG4gICAgZm9yIChjb25zdCBwYXRoIG9mIHN0YXRlLm1vZGlmaWVkUGF0aHMpIHtcbiAgICAgIGNvbnN0IGN1cnJlbnRTdGF0ZSA9IGRvYy4kX18uYWN0aXZlUGF0aHMucGF0aHNbcGF0aF07XG4gICAgICBpZiAoY3VycmVudFN0YXRlICE9IG51bGwpIHtcbiAgICAgICAgZGVsZXRlIGRvYy4kX18uYWN0aXZlUGF0aHNbY3VycmVudFN0YXRlXVtwYXRoXTtcbiAgICAgIH1cbiAgICAgIGRvYy4kX18uYWN0aXZlUGF0aHMucGF0aHNbcGF0aF0gPSAnbW9kaWZ5JztcbiAgICAgIGRvYy4kX18uYWN0aXZlUGF0aHMuc3RhdGVzLm1vZGlmeVtwYXRoXSA9IHRydWU7XG4gICAgfVxuXG4gICAgZm9yIChjb25zdCBwYXRoIG9mIHN0YXRlLmF0b21pY3Mua2V5cygpKSB7XG4gICAgICBjb25zdCB2YWwgPSBkb2MuJF9fZ2V0VmFsdWUocGF0aCk7XG4gICAgICBpZiAodmFsID09IG51bGwpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICB2YWxbYXJyYXlBdG9taWNzU3ltYm9sXSA9IHN0YXRlLmF0b21pY3MuZ2V0KHBhdGgpO1xuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIEhlbHBlciBmb3IgYGRyb3BDb2xsZWN0aW9uKClgLiBXaWxsIGRlbGV0ZSB0aGUgZ2l2ZW4gY29sbGVjdGlvbiwgaW5jbHVkaW5nXG4gKiBhbGwgZG9jdW1lbnRzIGFuZCBpbmRleGVzLlxuICpcbiAqIEBtZXRob2QgZHJvcENvbGxlY3Rpb25cbiAqIEBwYXJhbSB7c3RyaW5nfSBjb2xsZWN0aW9uIFRoZSBjb2xsZWN0aW9uIHRvIGRlbGV0ZVxuICogQHJldHVybiB7UHJvbWlzZX1cbiAqIEBhcGkgcHVibGljXG4gKi9cblxuQ29ubmVjdGlvbi5wcm90b3R5cGUuZHJvcENvbGxlY3Rpb24gPSBhc3luYyBmdW5jdGlvbiBkcm9wQ29sbGVjdGlvbihjb2xsZWN0aW9uKSB7XG4gIGlmIChhcmd1bWVudHMubGVuZ3RoID49IDIgJiYgdHlwZW9mIGFyZ3VtZW50c1sxXSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHRocm93IG5ldyBNb25nb29zZUVycm9yKCdDb25uZWN0aW9uLnByb3RvdHlwZS5kcm9wQ29sbGVjdGlvbigpIG5vIGxvbmdlciBhY2NlcHRzIGEgY2FsbGJhY2snKTtcbiAgfVxuXG4gIGlmICgodGhpcy5yZWFkeVN0YXRlID09PSBTVEFURVMuY29ubmVjdGluZyB8fCB0aGlzLnJlYWR5U3RhdGUgPT09IFNUQVRFUy5kaXNjb25uZWN0ZWQpICYmIHRoaXMuX3Nob3VsZEJ1ZmZlckNvbW1hbmRzKCkpIHtcbiAgICBhd2FpdCBuZXcgUHJvbWlzZShyZXNvbHZlID0+IHtcbiAgICAgIHRoaXMuX3F1ZXVlLnB1c2goeyBmbjogcmVzb2x2ZSB9KTtcbiAgICB9KTtcbiAgfVxuXG4gIHJldHVybiB0aGlzLmRiLmRyb3BDb2xsZWN0aW9uKGNvbGxlY3Rpb24pO1xufTtcblxuLyoqXG4gKiBIZWxwZXIgZm9yIGBkcm9wRGF0YWJhc2UoKWAuIERlbGV0ZXMgdGhlIGdpdmVuIGRhdGFiYXNlLCBpbmNsdWRpbmcgYWxsXG4gKiBjb2xsZWN0aW9ucywgZG9jdW1lbnRzLCBhbmQgaW5kZXhlcy5cbiAqXG4gKiAjIyMjIEV4YW1wbGU6XG4gKlxuICogICAgIGNvbnN0IGNvbm4gPSBtb25nb29zZS5jcmVhdGVDb25uZWN0aW9uKCdtb25nb2RiOi8vMTI3LjAuMC4xOjI3MDE3L215ZGInKTtcbiAqICAgICAvLyBEZWxldGVzIHRoZSBlbnRpcmUgJ215ZGInIGRhdGFiYXNlXG4gKiAgICAgYXdhaXQgY29ubi5kcm9wRGF0YWJhc2UoKTtcbiAqXG4gKiBAbWV0aG9kIGRyb3BEYXRhYmFzZVxuICogQHJldHVybiB7UHJvbWlzZX1cbiAqIEBhcGkgcHVibGljXG4gKi9cblxuQ29ubmVjdGlvbi5wcm90b3R5cGUuZHJvcERhdGFiYXNlID0gYXN5bmMgZnVuY3Rpb24gZHJvcERhdGFiYXNlKCkge1xuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA+PSAxICYmIHR5cGVvZiBhcmd1bWVudHNbMF0gPT09ICdmdW5jdGlvbicpIHtcbiAgICB0aHJvdyBuZXcgTW9uZ29vc2VFcnJvcignQ29ubmVjdGlvbi5wcm90b3R5cGUuZHJvcERhdGFiYXNlKCkgbm8gbG9uZ2VyIGFjY2VwdHMgYSBjYWxsYmFjaycpO1xuICB9XG5cbiAgaWYgKCh0aGlzLnJlYWR5U3RhdGUgPT09IFNUQVRFUy5jb25uZWN0aW5nIHx8IHRoaXMucmVhZHlTdGF0ZSA9PT0gU1RBVEVTLmRpc2Nvbm5lY3RlZCkgJiYgdGhpcy5fc2hvdWxkQnVmZmVyQ29tbWFuZHMoKSkge1xuICAgIGF3YWl0IG5ldyBQcm9taXNlKHJlc29sdmUgPT4ge1xuICAgICAgdGhpcy5fcXVldWUucHVzaCh7IGZuOiByZXNvbHZlIH0pO1xuICAgIH0pO1xuICB9XG5cbiAgLy8gSWYgYGRyb3BEYXRhYmFzZSgpYCBpcyBjYWxsZWQsIHRoaXMgbW9kZWwncyBjb2xsZWN0aW9uIHdpbGwgbm90IGJlXG4gIC8vIGluaXQtZWQuIEl0IGlzIHN1ZmZpY2llbnRseSBjb21tb24gdG8gY2FsbCBgZHJvcERhdGFiYXNlKClgIGFmdGVyXG4gIC8vIGBtb25nb29zZS5jb25uZWN0KClgIGJ1dCBiZWZvcmUgY3JlYXRpbmcgbW9kZWxzIHRoYXQgd2Ugd2FudCB0b1xuICAvLyBzdXBwb3J0IHRoaXMuIFNlZSBnaC02Nzk2XG4gIGZvciAoY29uc3QgbW9kZWwgb2YgT2JqZWN0LnZhbHVlcyh0aGlzLm1vZGVscykpIHtcbiAgICBkZWxldGUgbW9kZWwuJGluaXQ7XG4gIH1cblxuICByZXR1cm4gdGhpcy5kYi5kcm9wRGF0YWJhc2UoKTtcbn07XG5cbi8qIVxuICogaWdub3JlXG4gKi9cblxuQ29ubmVjdGlvbi5wcm90b3R5cGUuX3Nob3VsZEJ1ZmZlckNvbW1hbmRzID0gZnVuY3Rpb24gX3Nob3VsZEJ1ZmZlckNvbW1hbmRzKCkge1xuICBpZiAodGhpcy5jb25maWcuYnVmZmVyQ29tbWFuZHMgIT0gbnVsbCkge1xuICAgIHJldHVybiB0aGlzLmNvbmZpZy5idWZmZXJDb21tYW5kcztcbiAgfVxuICBpZiAodGhpcy5iYXNlLmdldCgnYnVmZmVyQ29tbWFuZHMnKSAhPSBudWxsKSB7XG4gICAgcmV0dXJuIHRoaXMuYmFzZS5nZXQoJ2J1ZmZlckNvbW1hbmRzJyk7XG4gIH1cbiAgcmV0dXJuIHRydWU7XG59O1xuXG4vKipcbiAqIGVycm9yXG4gKlxuICogR3JhY2VmdWwgZXJyb3IgaGFuZGxpbmcsIHBhc3NlcyBlcnJvciB0byBjYWxsYmFja1xuICogaWYgYXZhaWxhYmxlLCBlbHNlIGVtaXRzIGVycm9yIG9uIHRoZSBjb25uZWN0aW9uLlxuICpcbiAqIEBwYXJhbSB7RXJyb3J9IGVyclxuICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2sgb3B0aW9uYWxcbiAqIEBlbWl0cyBcImVycm9yXCIgRW1pdHMgdGhlIGBlcnJvcmAgZXZlbnQgd2l0aCB0aGUgZ2l2ZW4gYGVycmAsIHVubGVzcyBhIGNhbGxiYWNrIGlzIHNwZWNpZmllZFxuICogQHJldHVybnMge1Byb21pc2V8bnVsbH0gUmV0dXJucyBhIHJlamVjdGVkIFByb21pc2UgaWYgbm8gYGNhbGxiYWNrYCBpcyBnaXZlbi5cbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbkNvbm5lY3Rpb24ucHJvdG90eXBlLmVycm9yID0gZnVuY3Rpb24oZXJyLCBjYWxsYmFjaykge1xuICBpZiAoY2FsbGJhY2spIHtcbiAgICBjYWxsYmFjayhlcnIpO1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIGlmICh0aGlzLmxpc3RlbmVycygnZXJyb3InKS5sZW5ndGggPiAwKSB7XG4gICAgdGhpcy5lbWl0KCdlcnJvcicsIGVycik7XG4gIH1cbiAgcmV0dXJuIFByb21pc2UucmVqZWN0KGVycik7XG59O1xuXG4vKipcbiAqIENhbGxlZCB3aGVuIHRoZSBjb25uZWN0aW9uIGlzIG9wZW5lZFxuICpcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbkNvbm5lY3Rpb24ucHJvdG90eXBlLm9uT3BlbiA9IGZ1bmN0aW9uKCkge1xuICB0aGlzLnJlYWR5U3RhdGUgPSBTVEFURVMuY29ubmVjdGVkO1xuXG4gIGZvciAoY29uc3QgZCBvZiB0aGlzLl9xdWV1ZSkge1xuICAgIGQuZm4uYXBwbHkoZC5jdHgsIGQuYXJncyk7XG4gIH1cbiAgdGhpcy5fcXVldWUgPSBbXTtcblxuICAvLyBhdm9pZCBoYXZpbmcgdGhlIGNvbGxlY3Rpb24gc3Vic2NyaWJlIHRvIG91ciBldmVudCBlbWl0dGVyXG4gIC8vIHRvIHByZXZlbnQgMC4zIHdhcm5pbmdcbiAgZm9yIChjb25zdCBpIGluIHRoaXMuY29sbGVjdGlvbnMpIHtcbiAgICBpZiAodXRpbHMub2JqZWN0Lmhhc093blByb3BlcnR5KHRoaXMuY29sbGVjdGlvbnMsIGkpKSB7XG4gICAgICB0aGlzLmNvbGxlY3Rpb25zW2ldLm9uT3BlbigpO1xuICAgIH1cbiAgfVxuXG4gIHRoaXMuZW1pdCgnb3BlbicpO1xufTtcblxuLyoqXG4gKiBPcGVucyB0aGUgY29ubmVjdGlvbiB3aXRoIGEgVVJJIHVzaW5nIGBNb25nb0NsaWVudC5jb25uZWN0KClgLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSB1cmkgVGhlIFVSSSB0byBjb25uZWN0IHdpdGguXG4gKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdIFBhc3NlZCBvbiB0byBbYE1vbmdvQ2xpZW50LmNvbm5lY3RgXShodHRwczovL21vbmdvZGIuZ2l0aHViLmlvL25vZGUtbW9uZ29kYi1uYXRpdmUvNC45L2NsYXNzZXMvTW9uZ29DbGllbnQuaHRtbCNjb25uZWN0LTEpXG4gKiBAcGFyYW0ge0Jvb2xlYW59IFtvcHRpb25zLmJ1ZmZlckNvbW1hbmRzPXRydWVdIE1vbmdvb3NlIHNwZWNpZmljIG9wdGlvbi4gU2V0IHRvIGZhbHNlIHRvIFtkaXNhYmxlIGJ1ZmZlcmluZ10oaHR0cHM6Ly9tb25nb29zZWpzLmNvbS9kb2NzL2ZhcS5odG1sI2NhbGxiYWNrX25ldmVyX2V4ZWN1dGVzKSBvbiBhbGwgbW9kZWxzIGFzc29jaWF0ZWQgd2l0aCB0aGlzIGNvbm5lY3Rpb24uXG4gKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMuYnVmZmVyVGltZW91dE1TPTEwMDAwXSBNb25nb29zZSBzcGVjaWZpYyBvcHRpb24uIElmIGBidWZmZXJDb21tYW5kc2AgaXMgdHJ1ZSwgTW9uZ29vc2Ugd2lsbCB0aHJvdyBhbiBlcnJvciBhZnRlciBgYnVmZmVyVGltZW91dE1TYCBpZiB0aGUgb3BlcmF0aW9uIGlzIHN0aWxsIGJ1ZmZlcmVkLlxuICogQHBhcmFtIHtTdHJpbmd9IFtvcHRpb25zLmRiTmFtZV0gVGhlIG5hbWUgb2YgdGhlIGRhdGFiYXNlIHdlIHdhbnQgdG8gdXNlLiBJZiBub3QgcHJvdmlkZWQsIHVzZSBkYXRhYmFzZSBuYW1lIGZyb20gY29ubmVjdGlvbiBzdHJpbmcuXG4gKiBAcGFyYW0ge1N0cmluZ30gW29wdGlvbnMudXNlcl0gdXNlcm5hbWUgZm9yIGF1dGhlbnRpY2F0aW9uLCBlcXVpdmFsZW50IHRvIGBvcHRpb25zLmF1dGgudXNlcmAuIE1haW50YWluZWQgZm9yIGJhY2t3YXJkcyBjb21wYXRpYmlsaXR5LlxuICogQHBhcmFtIHtTdHJpbmd9IFtvcHRpb25zLnBhc3NdIHBhc3N3b3JkIGZvciBhdXRoZW50aWNhdGlvbiwgZXF1aXZhbGVudCB0byBgb3B0aW9ucy5hdXRoLnBhc3N3b3JkYC4gTWFpbnRhaW5lZCBmb3IgYmFja3dhcmRzIGNvbXBhdGliaWxpdHkuXG4gKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMubWF4UG9vbFNpemU9MTAwXSBUaGUgbWF4aW11bSBudW1iZXIgb2Ygc29ja2V0cyB0aGUgTW9uZ29EQiBkcml2ZXIgd2lsbCBrZWVwIG9wZW4gZm9yIHRoaXMgY29ubmVjdGlvbi4gS2VlcCBpbiBtaW5kIHRoYXQgTW9uZ29EQiBvbmx5IGFsbG93cyBvbmUgb3BlcmF0aW9uIHBlciBzb2NrZXQgYXQgYSB0aW1lLCBzbyB5b3UgbWF5IHdhbnQgdG8gaW5jcmVhc2UgdGhpcyBpZiB5b3UgZmluZCB5b3UgaGF2ZSBhIGZldyBzbG93IHF1ZXJpZXMgdGhhdCBhcmUgYmxvY2tpbmcgZmFzdGVyIHF1ZXJpZXMgZnJvbSBwcm9jZWVkaW5nLiBTZWUgW1Nsb3cgVHJhaW5zIGluIE1vbmdvREIgYW5kIE5vZGUuanNdKGh0dHBzOi8vdGhlY29kZWJhcmJhcmlhbi5jb20vc2xvdy10cmFpbnMtaW4tbW9uZ29kYi1hbmQtbm9kZWpzKS5cbiAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy5taW5Qb29sU2l6ZT0wXSBUaGUgbWluaW11bSBudW1iZXIgb2Ygc29ja2V0cyB0aGUgTW9uZ29EQiBkcml2ZXIgd2lsbCBrZWVwIG9wZW4gZm9yIHRoaXMgY29ubmVjdGlvbi4gS2VlcCBpbiBtaW5kIHRoYXQgTW9uZ29EQiBvbmx5IGFsbG93cyBvbmUgb3BlcmF0aW9uIHBlciBzb2NrZXQgYXQgYSB0aW1lLCBzbyB5b3UgbWF5IHdhbnQgdG8gaW5jcmVhc2UgdGhpcyBpZiB5b3UgZmluZCB5b3UgaGF2ZSBhIGZldyBzbG93IHF1ZXJpZXMgdGhhdCBhcmUgYmxvY2tpbmcgZmFzdGVyIHF1ZXJpZXMgZnJvbSBwcm9jZWVkaW5nLiBTZWUgW1Nsb3cgVHJhaW5zIGluIE1vbmdvREIgYW5kIE5vZGUuanNdKGh0dHBzOi8vdGhlY29kZWJhcmJhcmlhbi5jb20vc2xvdy10cmFpbnMtaW4tbW9uZ29kYi1hbmQtbm9kZWpzKS5cbiAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy5zZXJ2ZXJTZWxlY3Rpb25UaW1lb3V0TVNdIElmIGB1c2VVbmlmaWVkVG9wb2xvZ3kgPSB0cnVlYCwgdGhlIE1vbmdvREIgZHJpdmVyIHdpbGwgdHJ5IHRvIGZpbmQgYSBzZXJ2ZXIgdG8gc2VuZCBhbnkgZ2l2ZW4gb3BlcmF0aW9uIHRvLCBhbmQga2VlcCByZXRyeWluZyBmb3IgYHNlcnZlclNlbGVjdGlvblRpbWVvdXRNU2AgbWlsbGlzZWNvbmRzIGJlZm9yZSBlcnJvcmluZyBvdXQuIElmIG5vdCBzZXQsIHRoZSBNb25nb0RCIGRyaXZlciBkZWZhdWx0cyB0byB1c2luZyBgMzAwMDBgICgzMCBzZWNvbmRzKS5cbiAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy5oZWFydGJlYXRGcmVxdWVuY3lNU10gSWYgYHVzZVVuaWZpZWRUb3BvbG9neSA9IHRydWVgLCB0aGUgTW9uZ29EQiBkcml2ZXIgc2VuZHMgYSBoZWFydGJlYXQgZXZlcnkgYGhlYXJ0YmVhdEZyZXF1ZW5jeU1TYCB0byBjaGVjayBvbiB0aGUgc3RhdHVzIG9mIHRoZSBjb25uZWN0aW9uLiBBIGhlYXJ0YmVhdCBpcyBzdWJqZWN0IHRvIGBzZXJ2ZXJTZWxlY3Rpb25UaW1lb3V0TVNgLCBzbyB0aGUgTW9uZ29EQiBkcml2ZXIgd2lsbCByZXRyeSBmYWlsZWQgaGVhcnRiZWF0cyBmb3IgdXAgdG8gMzAgc2Vjb25kcyBieSBkZWZhdWx0LiBNb25nb29zZSBvbmx5IGVtaXRzIGEgYCdkaXNjb25uZWN0ZWQnYCBldmVudCBhZnRlciBhIGhlYXJ0YmVhdCBoYXMgZmFpbGVkLCBzbyB5b3UgbWF5IHdhbnQgdG8gZGVjcmVhc2UgdGhpcyBzZXR0aW5nIHRvIHJlZHVjZSB0aGUgdGltZSBiZXR3ZWVuIHdoZW4geW91ciBzZXJ2ZXIgZ29lcyBkb3duIGFuZCB3aGVuIE1vbmdvb3NlIGVtaXRzIGAnZGlzY29ubmVjdGVkJ2AuIFdlIHJlY29tbWVuZCB5b3UgZG8gKipub3QqKiBzZXQgdGhpcyBzZXR0aW5nIGJlbG93IDEwMDAsIHRvbyBtYW55IGhlYXJ0YmVhdHMgY2FuIGxlYWQgdG8gcGVyZm9ybWFuY2UgZGVncmFkYXRpb24uXG4gKiBAcGFyYW0ge0Jvb2xlYW59IFtvcHRpb25zLmF1dG9JbmRleD10cnVlXSBNb25nb29zZS1zcGVjaWZpYyBvcHRpb24uIFNldCB0byBmYWxzZSB0byBkaXNhYmxlIGF1dG9tYXRpYyBpbmRleCBjcmVhdGlvbiBmb3IgYWxsIG1vZGVscyBhc3NvY2lhdGVkIHdpdGggdGhpcyBjb25uZWN0aW9uLlxuICogQHBhcmFtIHtDbGFzc30gW29wdGlvbnMucHJvbWlzZUxpYnJhcnldIFNldHMgdGhlIFt1bmRlcmx5aW5nIGRyaXZlcidzIHByb21pc2UgbGlicmFyeV0oaHR0cHM6Ly9tb25nb2RiLmdpdGh1Yi5pby9ub2RlLW1vbmdvZGItbmF0aXZlLzQuOS9pbnRlcmZhY2VzL01vbmdvQ2xpZW50T3B0aW9ucy5odG1sI3Byb21pc2VMaWJyYXJ5KS5cbiAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy5zb2NrZXRUaW1lb3V0TVM9MF0gSG93IGxvbmcgdGhlIE1vbmdvREIgZHJpdmVyIHdpbGwgd2FpdCBiZWZvcmUga2lsbGluZyBhIHNvY2tldCBkdWUgdG8gaW5hY3Rpdml0eSBfYWZ0ZXIgaW5pdGlhbCBjb25uZWN0aW9uXy4gQSBzb2NrZXQgbWF5IGJlIGluYWN0aXZlIGJlY2F1c2Ugb2YgZWl0aGVyIG5vIGFjdGl2aXR5IG9yIGEgbG9uZy1ydW5uaW5nIG9wZXJhdGlvbi4gYHNvY2tldFRpbWVvdXRNU2AgZGVmYXVsdHMgdG8gMCwgd2hpY2ggbWVhbnMgTm9kZS5qcyB3aWxsIG5vdCB0aW1lIG91dCB0aGUgc29ja2V0IGR1ZSB0byBpbmFjdGl2aXR5LiBUaGlzIG9wdGlvbiBpcyBwYXNzZWQgdG8gW05vZGUuanMgYHNvY2tldCNzZXRUaW1lb3V0KClgIGZ1bmN0aW9uXShodHRwczovL25vZGVqcy5vcmcvYXBpL25ldC5odG1sI25ldF9zb2NrZXRfc2V0dGltZW91dF90aW1lb3V0X2NhbGxiYWNrKSBhZnRlciB0aGUgTW9uZ29EQiBkcml2ZXIgc3VjY2Vzc2Z1bGx5IGNvbXBsZXRlcy5cbiAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy5mYW1pbHk9MF0gUGFzc2VkIHRyYW5zcGFyZW50bHkgdG8gW05vZGUuanMnIGBkbnMubG9va3VwKClgXShodHRwczovL25vZGVqcy5vcmcvYXBpL2Rucy5odG1sI2Ruc19kbnNfbG9va3VwX2hvc3RuYW1lX29wdGlvbnNfY2FsbGJhY2spIGZ1bmN0aW9uLiBNYXkgYmUgZWl0aGVyIGAwLCBgNGAsIG9yIGA2YC4gYDRgIG1lYW5zIHVzZSBJUHY0IG9ubHksIGA2YCBtZWFucyB1c2UgSVB2NiBvbmx5LCBgMGAgbWVhbnMgdHJ5IGJvdGguXG4gKiBAcGFyYW0ge0Jvb2xlYW59IFtvcHRpb25zLmF1dG9DcmVhdGU9ZmFsc2VdIFNldCB0byBgdHJ1ZWAgdG8gbWFrZSBNb25nb29zZSBhdXRvbWF0aWNhbGx5IGNhbGwgYGNyZWF0ZUNvbGxlY3Rpb24oKWAgb24gZXZlcnkgbW9kZWwgY3JlYXRlZCBvbiB0aGlzIGNvbm5lY3Rpb24uXG4gKiBAcmV0dXJucyB7UHJvbWlzZTxDb25uZWN0aW9uPn1cbiAqIEBhcGkgcHVibGljXG4gKi9cblxuQ29ubmVjdGlvbi5wcm90b3R5cGUub3BlblVyaSA9IGFzeW5jIGZ1bmN0aW9uIG9wZW5VcmkodXJpLCBvcHRpb25zKSB7XG4gIGlmICh0aGlzLnJlYWR5U3RhdGUgPT09IFNUQVRFUy5jb25uZWN0aW5nIHx8IHRoaXMucmVhZHlTdGF0ZSA9PT0gU1RBVEVTLmNvbm5lY3RlZCkge1xuICAgIGlmICh0aGlzLl9jb25uZWN0aW9uU3RyaW5nID09PSB1cmkpIHtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgfVxuXG4gIHRoaXMuX2Nsb3NlQ2FsbGVkID0gZmFsc2U7XG5cbiAgLy8gSW50ZXJuYWwgb3B0aW9uIHRvIHNraXAgYGF3YWl0IHRoaXMuJGluaXRpYWxDb25uZWN0aW9uYCBpblxuICAvLyB0aGlzIGZ1bmN0aW9uIGZvciBgY3JlYXRlQ29ubmVjdGlvbigpYC4gQmVjYXVzZSBvdGhlcndpc2VcbiAgLy8gYGNyZWF0ZUNvbm5lY3Rpb24oKWAgd291bGQgaGF2ZSBhbiB1bmNhdGNoYWJsZSBlcnJvci5cbiAgbGV0IF9maXJlQW5kRm9yZ2V0ID0gZmFsc2U7XG4gIGlmIChvcHRpb25zICYmICdfZmlyZUFuZEZvcmdldCcgaW4gb3B0aW9ucykge1xuICAgIF9maXJlQW5kRm9yZ2V0ID0gb3B0aW9ucy5fZmlyZUFuZEZvcmdldDtcbiAgICBkZWxldGUgb3B0aW9ucy5fZmlyZUFuZEZvcmdldDtcbiAgfVxuXG4gIHRyeSB7XG4gICAgX3ZhbGlkYXRlQXJncy5hcHBseShhcmd1bWVudHMpO1xuICB9IGNhdGNoIChlcnIpIHtcbiAgICBpZiAoX2ZpcmVBbmRGb3JnZXQpIHtcbiAgICAgIHRocm93IGVycjtcbiAgICB9XG4gICAgdGhpcy4kaW5pdGlhbENvbm5lY3Rpb24gPSBQcm9taXNlLnJlamVjdChlcnIpO1xuICAgIHRocm93IGVycjtcbiAgfVxuXG4gIHRoaXMuJGluaXRpYWxDb25uZWN0aW9uID0gdGhpcy5jcmVhdGVDbGllbnQodXJpLCBvcHRpb25zKS5cbiAgICB0aGVuKCgpID0+IHRoaXMpLlxuICAgIGNhdGNoKGVyciA9PiB7XG4gICAgICB0aGlzLnJlYWR5U3RhdGUgPSBTVEFURVMuZGlzY29ubmVjdGVkO1xuICAgICAgaWYgKHRoaXMubGlzdGVuZXJzKCdlcnJvcicpLmxlbmd0aCA+IDApIHtcbiAgICAgICAgaW1tZWRpYXRlKCgpID0+IHRoaXMuZW1pdCgnZXJyb3InLCBlcnIpKTtcbiAgICAgIH1cbiAgICAgIHRocm93IGVycjtcbiAgICB9KTtcblxuICBmb3IgKGNvbnN0IG1vZGVsIG9mIE9iamVjdC52YWx1ZXModGhpcy5tb2RlbHMpKSB7XG4gICAgLy8gRXJyb3JzIGhhbmRsZWQgaW50ZXJuYWxseSwgc28gc2FmZSB0byBpZ25vcmUgZXJyb3JcbiAgICBtb2RlbC5pbml0KCkuY2F0Y2goZnVuY3Rpb24gJG1vZGVsSW5pdE5vb3AoKSB7fSk7XG4gIH1cblxuICAvLyBgY3JlYXRlQ29ubmVjdGlvbigpYCBjYWxscyB0aGlzIGBvcGVuVXJpKClgIGZ1bmN0aW9uIHdpdGhvdXRcbiAgLy8gYXdhaXRpbmcgb24gdGhlIHJlc3VsdCwgc28gd2Ugc2V0IHRoaXMgb3B0aW9uIHRvIHJlbHkgb25cbiAgLy8gYGFzUHJvbWlzZSgpYCB0byBoYW5kbGUgYW55IGVycm9ycy5cbiAgaWYgKF9maXJlQW5kRm9yZ2V0KSB7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICB0cnkge1xuICAgIGF3YWl0IHRoaXMuJGluaXRpYWxDb25uZWN0aW9uO1xuICB9IGNhdGNoIChlcnIpIHtcbiAgICB0aHJvdyBfaGFuZGxlQ29ubmVjdGlvbkVycm9ycyhlcnIpO1xuICB9XG5cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKiFcbiAqIGlnbm9yZVxuICovXG5cbmZ1bmN0aW9uIF92YWxpZGF0ZUFyZ3ModXJpLCBvcHRpb25zLCBjYWxsYmFjaykge1xuICBpZiAodHlwZW9mIG9wdGlvbnMgPT09ICdmdW5jdGlvbicgJiYgY2FsbGJhY2sgPT0gbnVsbCkge1xuICAgIHRocm93IG5ldyBNb25nb29zZUVycm9yKCdDb25uZWN0aW9uLnByb3RvdHlwZS5vcGVuVXJpKCkgbm8gbG9uZ2VyIGFjY2VwdHMgYSBjYWxsYmFjaycpO1xuICB9IGVsc2UgaWYgKHR5cGVvZiBjYWxsYmFjayA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHRocm93IG5ldyBNb25nb29zZUVycm9yKCdDb25uZWN0aW9uLnByb3RvdHlwZS5vcGVuVXJpKCkgbm8gbG9uZ2VyIGFjY2VwdHMgYSBjYWxsYmFjaycpO1xuICB9XG59XG5cbi8qIVxuICogaWdub3JlXG4gKi9cblxuZnVuY3Rpb24gX2hhbmRsZUNvbm5lY3Rpb25FcnJvcnMoZXJyKSB7XG4gIGlmIChlcnI/Lm5hbWUgPT09ICdNb25nb1NlcnZlclNlbGVjdGlvbkVycm9yJykge1xuICAgIGNvbnN0IG9yaWdpbmFsRXJyb3IgPSBlcnI7XG4gICAgZXJyID0gbmV3IFNlcnZlclNlbGVjdGlvbkVycm9yKCk7XG4gICAgZXJyLmFzc2ltaWxhdGVFcnJvcihvcmlnaW5hbEVycm9yKTtcbiAgfVxuXG4gIHJldHVybiBlcnI7XG59XG5cbi8qKlxuICogRGVzdHJveSB0aGUgY29ubmVjdGlvbi4gU2ltaWxhciB0byBbYC5jbG9zZWBdKGh0dHBzOi8vbW9uZ29vc2Vqcy5jb20vZG9jcy9hcGkvY29ubmVjdGlvbi5odG1sI0Nvbm5lY3Rpb24ucHJvdG90eXBlLmNsb3NlKCkpLFxuICogYnV0IGFsc28gcmVtb3ZlcyB0aGUgY29ubmVjdGlvbiBmcm9tIE1vbmdvb3NlJ3MgYGNvbm5lY3Rpb25zYCBsaXN0IGFuZCBwcmV2ZW50cyB0aGVcbiAqIGNvbm5lY3Rpb24gZnJvbSBldmVyIGJlaW5nIHJlLW9wZW5lZC5cbiAqXG4gKiBAcGFyYW0ge0Jvb2xlYW59IFtmb3JjZV1cbiAqIEByZXR1cm5zIHtQcm9taXNlfVxuICovXG5cbkNvbm5lY3Rpb24ucHJvdG90eXBlLmRlc3Ryb3kgPSBhc3luYyBmdW5jdGlvbiBkZXN0cm95KGZvcmNlKSB7XG4gIGlmICh0eXBlb2YgZm9yY2UgPT09ICdmdW5jdGlvbicgfHwgKGFyZ3VtZW50cy5sZW5ndGggPT09IDIgJiYgdHlwZW9mIGFyZ3VtZW50c1sxXSA9PT0gJ2Z1bmN0aW9uJykpIHtcbiAgICB0aHJvdyBuZXcgTW9uZ29vc2VFcnJvcignQ29ubmVjdGlvbi5wcm90b3R5cGUuZGVzdHJveSgpIG5vIGxvbmdlciBhY2NlcHRzIGEgY2FsbGJhY2snKTtcbiAgfVxuXG4gIGlmIChmb3JjZSAhPSBudWxsICYmIHR5cGVvZiBmb3JjZSA9PT0gJ29iamVjdCcpIHtcbiAgICB0aGlzLiR3YXNGb3JjZUNsb3NlZCA9ICEhZm9yY2UuZm9yY2U7XG4gIH0gZWxzZSB7XG4gICAgdGhpcy4kd2FzRm9yY2VDbG9zZWQgPSAhIWZvcmNlO1xuICB9XG5cbiAgcmV0dXJuIHRoaXMuX2Nsb3NlKGZvcmNlLCB0cnVlKTtcbn07XG5cbi8qKlxuICogQ2xvc2VzIHRoZSBjb25uZWN0aW9uXG4gKlxuICogQHBhcmFtIHtCb29sZWFufSBbZm9yY2VdIG9wdGlvbmFsXG4gKiBAcmV0dXJuIHtQcm9taXNlfVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5Db25uZWN0aW9uLnByb3RvdHlwZS5jbG9zZSA9IGFzeW5jIGZ1bmN0aW9uIGNsb3NlKGZvcmNlKSB7XG4gIGlmICh0eXBlb2YgZm9yY2UgPT09ICdmdW5jdGlvbicgfHwgKGFyZ3VtZW50cy5sZW5ndGggPT09IDIgJiYgdHlwZW9mIGFyZ3VtZW50c1sxXSA9PT0gJ2Z1bmN0aW9uJykpIHtcbiAgICB0aHJvdyBuZXcgTW9uZ29vc2VFcnJvcignQ29ubmVjdGlvbi5wcm90b3R5cGUuY2xvc2UoKSBubyBsb25nZXIgYWNjZXB0cyBhIGNhbGxiYWNrJyk7XG4gIH1cblxuICBpZiAoZm9yY2UgIT0gbnVsbCAmJiB0eXBlb2YgZm9yY2UgPT09ICdvYmplY3QnKSB7XG4gICAgdGhpcy4kd2FzRm9yY2VDbG9zZWQgPSAhIWZvcmNlLmZvcmNlO1xuICB9IGVsc2Uge1xuICAgIHRoaXMuJHdhc0ZvcmNlQ2xvc2VkID0gISFmb3JjZTtcbiAgfVxuXG4gIGZvciAoY29uc3QgbW9kZWwgb2YgT2JqZWN0LnZhbHVlcyh0aGlzLm1vZGVscykpIHtcbiAgICAvLyBJZiBtYW51YWxseSBkaXNjb25uZWN0aW5nLCBtYWtlIHN1cmUgdG8gY2xlYXIgZWFjaCBtb2RlbCdzIGAkaW5pdGBcbiAgICAvLyBwcm9taXNlLCBzbyBNb25nb29zZSBrbm93cyB0byByZS1ydW4gYGluaXQoKWAgaW4gY2FzZSB0aGVcbiAgICAvLyBjb25uZWN0aW9uIGlzIHJlLW9wZW5lZC4gU2VlIGdoLTEyMDQ3LlxuICAgIGRlbGV0ZSBtb2RlbC4kaW5pdDtcbiAgfVxuXG4gIHJldHVybiB0aGlzLl9jbG9zZShmb3JjZSwgZmFsc2UpO1xufTtcblxuLyoqXG4gKiBIYW5kbGVzIGNsb3NpbmcgdGhlIGNvbm5lY3Rpb25cbiAqXG4gKiBAcGFyYW0ge0Jvb2xlYW59IGZvcmNlXG4gKiBAcGFyYW0ge0Jvb2xlYW59IGRlc3Ryb3lcbiAqIEByZXR1cm5zIHtDb25uZWN0aW9ufSB0aGlzXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuQ29ubmVjdGlvbi5wcm90b3R5cGUuX2Nsb3NlID0gYXN5bmMgZnVuY3Rpb24gX2Nsb3NlKGZvcmNlLCBkZXN0cm95KSB7XG4gIGNvbnN0IF90aGlzID0gdGhpcztcbiAgY29uc3QgY2xvc2VDYWxsZWQgPSB0aGlzLl9jbG9zZUNhbGxlZDtcbiAgdGhpcy5fY2xvc2VDYWxsZWQgPSB0cnVlO1xuICB0aGlzLl9kZXN0cm95Q2FsbGVkID0gZGVzdHJveTtcbiAgaWYgKHRoaXMuY2xpZW50ICE9IG51bGwpIHtcbiAgICB0aGlzLmNsaWVudC5fY2xvc2VDYWxsZWQgPSB0cnVlO1xuICAgIHRoaXMuY2xpZW50Ll9kZXN0cm95Q2FsbGVkID0gZGVzdHJveTtcbiAgfVxuXG4gIGNvbnN0IGNvbm4gPSB0aGlzO1xuICBzd2l0Y2ggKHRoaXMucmVhZHlTdGF0ZSkge1xuICAgIGNhc2UgU1RBVEVTLmRpc2Nvbm5lY3RlZDpcbiAgICAgIGlmIChkZXN0cm95ICYmIHRoaXMuYmFzZS5jb25uZWN0aW9ucy5pbmRleE9mKGNvbm4pICE9PSAtMSkge1xuICAgICAgICB0aGlzLmJhc2UuY29ubmVjdGlvbnMuc3BsaWNlKHRoaXMuYmFzZS5jb25uZWN0aW9ucy5pbmRleE9mKGNvbm4pLCAxKTtcbiAgICAgIH1cbiAgICAgIGlmICghY2xvc2VDYWxsZWQpIHtcbiAgICAgICAgYXdhaXQgdGhpcy5kb0Nsb3NlKGZvcmNlKTtcbiAgICAgICAgdGhpcy5vbkNsb3NlKGZvcmNlKTtcbiAgICAgIH1cbiAgICAgIGJyZWFrO1xuXG4gICAgY2FzZSBTVEFURVMuY29ubmVjdGVkOlxuICAgICAgdGhpcy5yZWFkeVN0YXRlID0gU1RBVEVTLmRpc2Nvbm5lY3Rpbmc7XG4gICAgICBhd2FpdCB0aGlzLmRvQ2xvc2UoZm9yY2UpO1xuICAgICAgaWYgKGRlc3Ryb3kgJiYgX3RoaXMuYmFzZS5jb25uZWN0aW9ucy5pbmRleE9mKGNvbm4pICE9PSAtMSkge1xuICAgICAgICB0aGlzLmJhc2UuY29ubmVjdGlvbnMuc3BsaWNlKHRoaXMuYmFzZS5jb25uZWN0aW9ucy5pbmRleE9mKGNvbm4pLCAxKTtcbiAgICAgIH1cbiAgICAgIHRoaXMub25DbG9zZShmb3JjZSk7XG5cbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgU1RBVEVTLmNvbm5lY3Rpbmc6XG4gICAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICBjb25zdCBfcmVydW5DbG9zZSA9ICgpID0+IHtcbiAgICAgICAgICB0aGlzLnJlbW92ZUxpc3RlbmVyKCdvcGVuJywgX3JlcnVuQ2xvc2UpO1xuICAgICAgICAgIHRoaXMucmVtb3ZlTGlzdGVuZXIoJ2Vycm9yJywgX3JlcnVuQ2xvc2UpO1xuICAgICAgICAgIGlmIChkZXN0cm95KSB7XG4gICAgICAgICAgICB0aGlzLmRlc3Ryb3koZm9yY2UpLnRoZW4ocmVzb2x2ZSwgcmVqZWN0KTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5jbG9zZShmb3JjZSkudGhlbihyZXNvbHZlLCByZWplY3QpO1xuICAgICAgICAgIH1cbiAgICAgICAgfTtcblxuICAgICAgICB0aGlzLm9uY2UoJ29wZW4nLCBfcmVydW5DbG9zZSk7XG4gICAgICAgIHRoaXMub25jZSgnZXJyb3InLCBfcmVydW5DbG9zZSk7XG4gICAgICB9KTtcblxuICAgIGNhc2UgU1RBVEVTLmRpc2Nvbm5lY3Rpbmc6XG4gICAgICByZXR1cm4gbmV3IFByb21pc2UocmVzb2x2ZSA9PiB7XG4gICAgICAgIHRoaXMub25jZSgnY2xvc2UnLCAoKSA9PiB7XG4gICAgICAgICAgaWYgKGRlc3Ryb3kgJiYgdGhpcy5iYXNlLmNvbm5lY3Rpb25zLmluZGV4T2YoY29ubikgIT09IC0xKSB7XG4gICAgICAgICAgICB0aGlzLmJhc2UuY29ubmVjdGlvbnMuc3BsaWNlKHRoaXMuYmFzZS5jb25uZWN0aW9ucy5pbmRleE9mKGNvbm4pLCAxKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmVzb2x2ZSgpO1xuICAgICAgICB9KTtcbiAgICAgIH0pO1xuICB9XG5cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIEFic3RyYWN0IG1ldGhvZCB0aGF0IGRyaXZlcnMgbXVzdCBpbXBsZW1lbnQuXG4gKlxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuQ29ubmVjdGlvbi5wcm90b3R5cGUuZG9DbG9zZSA9IGZ1bmN0aW9uKCkge1xuICB0aHJvdyBuZXcgRXJyb3IoJ0Nvbm5lY3Rpb24jZG9DbG9zZSB1bmltcGxlbWVudGVkIGJ5IGRyaXZlcicpO1xufTtcblxuLyoqXG4gKiBDYWxsZWQgd2hlbiB0aGUgY29ubmVjdGlvbiBjbG9zZXNcbiAqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5Db25uZWN0aW9uLnByb3RvdHlwZS5vbkNsb3NlID0gZnVuY3Rpb24oZm9yY2UpIHtcbiAgdGhpcy5yZWFkeVN0YXRlID0gU1RBVEVTLmRpc2Nvbm5lY3RlZDtcblxuICAvLyBhdm9pZCBoYXZpbmcgdGhlIGNvbGxlY3Rpb24gc3Vic2NyaWJlIHRvIG91ciBldmVudCBlbWl0dGVyXG4gIC8vIHRvIHByZXZlbnQgMC4zIHdhcm5pbmdcbiAgZm9yIChjb25zdCBpIGluIHRoaXMuY29sbGVjdGlvbnMpIHtcbiAgICBpZiAodXRpbHMub2JqZWN0Lmhhc093blByb3BlcnR5KHRoaXMuY29sbGVjdGlvbnMsIGkpKSB7XG4gICAgICB0aGlzLmNvbGxlY3Rpb25zW2ldLm9uQ2xvc2UoZm9yY2UpO1xuICAgIH1cbiAgfVxuXG4gIHRoaXMuZW1pdCgnY2xvc2UnLCBmb3JjZSk7XG5cbiAgZm9yIChjb25zdCBkYiBvZiB0aGlzLm90aGVyRGJzKSB7XG4gICAgdGhpcy5fZGVzdHJveUNhbGxlZCA/IGRiLmRlc3Ryb3koeyBmb3JjZTogZm9yY2UsIHNraXBDbG9zZUNsaWVudDogdHJ1ZSB9KSA6IGRiLmNsb3NlKHsgZm9yY2U6IGZvcmNlLCBza2lwQ2xvc2VDbGllbnQ6IHRydWUgfSk7XG4gIH1cbn07XG5cbi8qKlxuICogUmV0cmlldmVzIGEgcmF3IGNvbGxlY3Rpb24gaW5zdGFuY2UsIGNyZWF0aW5nIGl0IGlmIG5vdCBjYWNoZWQuXG4gKiBUaGlzIG1ldGhvZCByZXR1cm5zIGEgdGhpbiB3cmFwcGVyIGFyb3VuZCBhIFtNb25nb0RCIE5vZGUuanMgZHJpdmVyIGNvbGxlY3Rpb25dKFtNb25nb0RCIE5vZGUuanMgZHJpdmVyIGNvbGxlY3Rpb25dKGh0dHBzOi8vbW9uZ29kYi5naXRodWIuaW8vbm9kZS1tb25nb2RiLW5hdGl2ZS9OZXh0L2NsYXNzZXMvQ29sbGVjdGlvbi5odG1sKSkuXG4gKiBVc2luZyBhIENvbGxlY3Rpb24gYnlwYXNzZXMgTW9uZ29vc2UgbWlkZGxld2FyZSwgdmFsaWRhdGlvbiwgYW5kIGNhc3RpbmcsXG4gKiBsZXR0aW5nIHlvdSB1c2UgW01vbmdvREIgTm9kZS5qcyBkcml2ZXJdKGh0dHBzOi8vbW9uZ29kYi5naXRodWIuaW8vbm9kZS1tb25nb2RiLW5hdGl2ZS8pIGZ1bmN0aW9uYWxpdHkgZGlyZWN0bHkuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IG5hbWUgb2YgdGhlIGNvbGxlY3Rpb25cbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gb3B0aW9uYWwgY29sbGVjdGlvbiBvcHRpb25zXG4gKiBAcmV0dXJuIHtDb2xsZWN0aW9ufSBjb2xsZWN0aW9uIGluc3RhbmNlXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbkNvbm5lY3Rpb24ucHJvdG90eXBlLmNvbGxlY3Rpb24gPSBmdW5jdGlvbihuYW1lLCBvcHRpb25zKSB7XG4gIGNvbnN0IGRlZmF1bHRPcHRpb25zID0ge1xuICAgIGF1dG9JbmRleDogdGhpcy5jb25maWcuYXV0b0luZGV4ICE9IG51bGwgPyB0aGlzLmNvbmZpZy5hdXRvSW5kZXggOiB0aGlzLmJhc2Uub3B0aW9ucy5hdXRvSW5kZXgsXG4gICAgYXV0b0NyZWF0ZTogdGhpcy5jb25maWcuYXV0b0NyZWF0ZSAhPSBudWxsID8gdGhpcy5jb25maWcuYXV0b0NyZWF0ZSA6IHRoaXMuYmFzZS5vcHRpb25zLmF1dG9DcmVhdGVcbiAgfTtcbiAgb3B0aW9ucyA9IE9iamVjdC5hc3NpZ24oe30sIGRlZmF1bHRPcHRpb25zLCBvcHRpb25zID8gY2xvbmUob3B0aW9ucykgOiB7fSk7XG4gIG9wdGlvbnMuJHdhc0ZvcmNlQ2xvc2VkID0gdGhpcy4kd2FzRm9yY2VDbG9zZWQ7XG4gIGNvbnN0IENvbGxlY3Rpb24gPSB0aGlzLmJhc2UgJiYgdGhpcy5iYXNlLl9fZHJpdmVyICYmIHRoaXMuYmFzZS5fX2RyaXZlci5Db2xsZWN0aW9uIHx8IGRyaXZlci5nZXQoKS5Db2xsZWN0aW9uO1xuICBpZiAoIShuYW1lIGluIHRoaXMuY29sbGVjdGlvbnMpKSB7XG4gICAgdGhpcy5jb2xsZWN0aW9uc1tuYW1lXSA9IG5ldyBDb2xsZWN0aW9uKG5hbWUsIHRoaXMsIG9wdGlvbnMpO1xuICB9XG4gIHJldHVybiB0aGlzLmNvbGxlY3Rpb25zW25hbWVdO1xufTtcblxuLyoqXG4gKiBEZWNsYXJlcyBhIHBsdWdpbiBleGVjdXRlZCBvbiBhbGwgc2NoZW1hcyB5b3UgcGFzcyB0byBgY29ubi5tb2RlbCgpYFxuICpcbiAqIEVxdWl2YWxlbnQgdG8gY2FsbGluZyBgLnBsdWdpbihmbilgIG9uIGVhY2ggc2NoZW1hIHlvdSBjcmVhdGUuXG4gKlxuICogIyMjIyBFeGFtcGxlOlxuICpcbiAqICAgICBjb25zdCBkYiA9IG1vbmdvb3NlLmNyZWF0ZUNvbm5lY3Rpb24oJ21vbmdvZGI6Ly8xMjcuMC4wLjE6MjcwMTcvbXlkYicpO1xuICogICAgIGRiLnBsdWdpbigoKSA9PiBjb25zb2xlLmxvZygnQXBwbGllZCcpKTtcbiAqICAgICBkYi5wbHVnaW5zLmxlbmd0aDsgLy8gMVxuICpcbiAqICAgICBkYi5tb2RlbCgnVGVzdCcsIG5ldyBTY2hlbWEoe30pKTsgLy8gUHJpbnRzIFwiQXBwbGllZFwiXG4gKlxuICogQHBhcmFtIHtGdW5jdGlvbn0gZm4gcGx1Z2luIGNhbGxiYWNrXG4gKiBAcGFyYW0ge09iamVjdH0gW29wdHNdIG9wdGlvbmFsIG9wdGlvbnNcbiAqIEByZXR1cm4ge0Nvbm5lY3Rpb259IHRoaXNcbiAqIEBzZWUgcGx1Z2lucyBodHRwczovL21vbmdvb3NlanMuY29tL2RvY3MvcGx1Z2lucy5odG1sXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbkNvbm5lY3Rpb24ucHJvdG90eXBlLnBsdWdpbiA9IGZ1bmN0aW9uKGZuLCBvcHRzKSB7XG4gIHRoaXMucGx1Z2lucy5wdXNoKFtmbiwgb3B0c10pO1xuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogRGVmaW5lcyBvciByZXRyaWV2ZXMgYSBtb2RlbC5cbiAqXG4gKiAgICAgY29uc3QgbW9uZ29vc2UgPSByZXF1aXJlKCdtb25nb29zZScpO1xuICogICAgIGNvbnN0IGRiID0gbW9uZ29vc2UuY3JlYXRlQ29ubmVjdGlvbiguLik7XG4gKiAgICAgZGIubW9kZWwoJ1ZlbnVlJywgbmV3IFNjaGVtYSguLikpO1xuICogICAgIGNvbnN0IFRpY2tldCA9IGRiLm1vZGVsKCdUaWNrZXQnLCBuZXcgU2NoZW1hKC4uKSk7XG4gKiAgICAgY29uc3QgVmVudWUgPSBkYi5tb2RlbCgnVmVudWUnKTtcbiAqXG4gKiBfV2hlbiBubyBgY29sbGVjdGlvbmAgYXJndW1lbnQgaXMgcGFzc2VkLCBNb25nb29zZSBwcm9kdWNlcyBhIGNvbGxlY3Rpb24gbmFtZSBieSBwYXNzaW5nIHRoZSBtb2RlbCBgbmFtZWAgdG8gdGhlIGB1dGlscy50b0NvbGxlY3Rpb25OYW1lYCBtZXRob2QuIFRoaXMgbWV0aG9kIHBsdXJhbGl6ZXMgdGhlIG5hbWUuIElmIHlvdSBkb24ndCBsaWtlIHRoaXMgYmVoYXZpb3IsIGVpdGhlciBwYXNzIGEgY29sbGVjdGlvbiBuYW1lIG9yIHNldCB5b3VyIHNjaGVtYXMgY29sbGVjdGlvbiBuYW1lIG9wdGlvbi5fXG4gKlxuICogIyMjIyBFeGFtcGxlOlxuICpcbiAqICAgICBjb25zdCBzY2hlbWEgPSBuZXcgU2NoZW1hKHsgbmFtZTogU3RyaW5nIH0sIHsgY29sbGVjdGlvbjogJ2FjdG9yJyB9KTtcbiAqXG4gKiAgICAgLy8gb3JcbiAqXG4gKiAgICAgc2NoZW1hLnNldCgnY29sbGVjdGlvbicsICdhY3RvcicpO1xuICpcbiAqICAgICAvLyBvclxuICpcbiAqICAgICBjb25zdCBjb2xsZWN0aW9uTmFtZSA9ICdhY3RvcidcbiAqICAgICBjb25zdCBNID0gY29ubi5tb2RlbCgnQWN0b3InLCBzY2hlbWEsIGNvbGxlY3Rpb25OYW1lKVxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfEZ1bmN0aW9ufSBuYW1lIHRoZSBtb2RlbCBuYW1lIG9yIGNsYXNzIGV4dGVuZGluZyBNb2RlbFxuICogQHBhcmFtIHtTY2hlbWF9IFtzY2hlbWFdIGEgc2NoZW1hLiBuZWNlc3Nhcnkgd2hlbiBkZWZpbmluZyBhIG1vZGVsXG4gKiBAcGFyYW0ge1N0cmluZ30gW2NvbGxlY3Rpb25dIG5hbWUgb2YgbW9uZ29kYiBjb2xsZWN0aW9uIChvcHRpb25hbCkgaWYgbm90IGdpdmVuIGl0IHdpbGwgYmUgaW5kdWNlZCBmcm9tIG1vZGVsIG5hbWVcbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc11cbiAqIEBwYXJhbSB7Qm9vbGVhbn0gW29wdGlvbnMub3ZlcndyaXRlTW9kZWxzPWZhbHNlXSBJZiB0cnVlLCBvdmVyd3JpdGUgZXhpc3RpbmcgbW9kZWxzIHdpdGggdGhlIHNhbWUgbmFtZSB0byBhdm9pZCBgT3ZlcndyaXRlTW9kZWxFcnJvcmBcbiAqIEBzZWUgTW9uZ29vc2UjbW9kZWwgaHR0cHM6Ly9tb25nb29zZWpzLmNvbS9kb2NzL2FwaS9tb25nb29zZS5odG1sI01vbmdvb3NlLnByb3RvdHlwZS5tb2RlbCgpXG4gKiBAcmV0dXJuIHtNb2RlbH0gVGhlIGNvbXBpbGVkIG1vZGVsXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbkNvbm5lY3Rpb24ucHJvdG90eXBlLm1vZGVsID0gZnVuY3Rpb24obmFtZSwgc2NoZW1hLCBjb2xsZWN0aW9uLCBvcHRpb25zKSB7XG4gIGlmICghKHRoaXMgaW5zdGFuY2VvZiBDb25uZWN0aW9uKSkge1xuICAgIHRocm93IG5ldyBNb25nb29zZUVycm9yKCdgY29ubmVjdGlvbi5tb2RlbCgpYCBzaG91bGQgbm90IGJlIHJ1biB3aXRoICcgK1xuICAgICAgJ2BuZXdgLiBJZiB5b3UgYXJlIGRvaW5nIGBuZXcgZGIubW9kZWwoZm9vKShiYXIpYCwgdXNlICcgK1xuICAgICAgJ2BkYi5tb2RlbChmb28pKGJhcilgIGluc3RlYWQnKTtcbiAgfVxuXG4gIGxldCBmbjtcbiAgaWYgKHR5cGVvZiBuYW1lID09PSAnZnVuY3Rpb24nKSB7XG4gICAgZm4gPSBuYW1lO1xuICAgIG5hbWUgPSBmbi5uYW1lO1xuICB9XG5cbiAgLy8gY29sbGVjdGlvbiBuYW1lIGRpc2NvdmVyeVxuICBpZiAodHlwZW9mIHNjaGVtYSA9PT0gJ3N0cmluZycpIHtcbiAgICBjb2xsZWN0aW9uID0gc2NoZW1hO1xuICAgIHNjaGVtYSA9IGZhbHNlO1xuICB9XG5cbiAgaWYgKHV0aWxzLmlzT2JqZWN0KHNjaGVtYSkpIHtcbiAgICBpZiAoIXNjaGVtYS5pbnN0YW5jZU9mU2NoZW1hKSB7XG4gICAgICBzY2hlbWEgPSBuZXcgU2NoZW1hKHNjaGVtYSk7XG4gICAgfSBlbHNlIGlmICghKHNjaGVtYSBpbnN0YW5jZW9mIHRoaXMuYmFzZS5TY2hlbWEpKSB7XG4gICAgICBzY2hlbWEgPSBzY2hlbWEuX2Nsb25lKHRoaXMuYmFzZS5TY2hlbWEpO1xuICAgIH1cbiAgfVxuICBpZiAoc2NoZW1hICYmICFzY2hlbWEuaW5zdGFuY2VPZlNjaGVtYSkge1xuICAgIHRocm93IG5ldyBFcnJvcignVGhlIDJuZCBwYXJhbWV0ZXIgdG8gYG1vbmdvb3NlLm1vZGVsKClgIHNob3VsZCBiZSBhICcgK1xuICAgICAgJ3NjaGVtYSBvciBhIFBPSk8nKTtcbiAgfVxuXG4gIGNvbnN0IGRlZmF1bHRPcHRpb25zID0geyBjYWNoZTogZmFsc2UsIG92ZXJ3cml0ZU1vZGVsczogdGhpcy5iYXNlLm9wdGlvbnMub3ZlcndyaXRlTW9kZWxzIH07XG4gIGNvbnN0IG9wdHMgPSBPYmplY3QuYXNzaWduKGRlZmF1bHRPcHRpb25zLCBvcHRpb25zLCB7IGNvbm5lY3Rpb246IHRoaXMgfSk7XG4gIGlmICh0aGlzLm1vZGVsc1tuYW1lXSAmJiAhY29sbGVjdGlvbiAmJiBvcHRzLm92ZXJ3cml0ZU1vZGVscyAhPT0gdHJ1ZSkge1xuICAgIC8vIG1vZGVsIGV4aXN0cyBidXQgd2UgYXJlIG5vdCBzdWJjbGFzc2luZyB3aXRoIGN1c3RvbSBjb2xsZWN0aW9uXG4gICAgaWYgKHNjaGVtYSAmJiBzY2hlbWEuaW5zdGFuY2VPZlNjaGVtYSAmJiBzY2hlbWEgIT09IHRoaXMubW9kZWxzW25hbWVdLnNjaGVtYSkge1xuICAgICAgdGhyb3cgbmV3IE1vbmdvb3NlRXJyb3IuT3ZlcndyaXRlTW9kZWxFcnJvcihuYW1lKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMubW9kZWxzW25hbWVdO1xuICB9XG5cbiAgbGV0IG1vZGVsO1xuXG4gIGlmIChzY2hlbWEgJiYgc2NoZW1hLmluc3RhbmNlT2ZTY2hlbWEpIHtcbiAgICBhcHBseVBsdWdpbnMoc2NoZW1hLCB0aGlzLnBsdWdpbnMsIG51bGwsICckY29ubmVjdGlvblBsdWdpbnNBcHBsaWVkJyk7XG5cbiAgICAvLyBjb21waWxlIGEgbW9kZWxcbiAgICBtb2RlbCA9IHRoaXMuYmFzZS5fbW9kZWwoZm4gfHwgbmFtZSwgc2NoZW1hLCBjb2xsZWN0aW9uLCBvcHRzKTtcblxuICAgIC8vIG9ubHkgdGhlIGZpcnN0IG1vZGVsIHdpdGggdGhpcyBuYW1lIGlzIGNhY2hlZCB0byBhbGxvd1xuICAgIC8vIGZvciBvbmUtb2ZmcyB3aXRoIGN1c3RvbSBjb2xsZWN0aW9uIG5hbWVzIGV0Yy5cbiAgICBpZiAoIXRoaXMubW9kZWxzW25hbWVdKSB7XG4gICAgICB0aGlzLm1vZGVsc1tuYW1lXSA9IG1vZGVsO1xuICAgIH1cblxuICAgIC8vIEVycm9ycyBoYW5kbGVkIGludGVybmFsbHksIHNvIHNhZmUgdG8gaWdub3JlIGVycm9yXG4gICAgbW9kZWwuaW5pdCgpLmNhdGNoKGZ1bmN0aW9uICRtb2RlbEluaXROb29wKCkge30pO1xuXG4gICAgcmV0dXJuIG1vZGVsO1xuICB9XG5cbiAgaWYgKHRoaXMubW9kZWxzW25hbWVdICYmIGNvbGxlY3Rpb24pIHtcbiAgICAvLyBzdWJjbGFzc2luZyBjdXJyZW50IG1vZGVsIHdpdGggYWx0ZXJuYXRlIGNvbGxlY3Rpb25cbiAgICBtb2RlbCA9IHRoaXMubW9kZWxzW25hbWVdO1xuICAgIHNjaGVtYSA9IG1vZGVsLnByb3RvdHlwZS5zY2hlbWE7XG4gICAgY29uc3Qgc3ViID0gbW9kZWwuX19zdWJjbGFzcyh0aGlzLCBzY2hlbWEsIGNvbGxlY3Rpb24pO1xuICAgIC8vIGRvIG5vdCBjYWNoZSB0aGUgc3ViIG1vZGVsXG4gICAgcmV0dXJuIHN1YjtcbiAgfVxuXG4gIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAxKSB7XG4gICAgbW9kZWwgPSB0aGlzLm1vZGVsc1tuYW1lXTtcbiAgICBpZiAoIW1vZGVsKSB7XG4gICAgICB0aHJvdyBuZXcgTW9uZ29vc2VFcnJvci5NaXNzaW5nU2NoZW1hRXJyb3IobmFtZSk7XG4gICAgfVxuICAgIHJldHVybiBtb2RlbDtcbiAgfVxuXG4gIGlmICghbW9kZWwpIHtcbiAgICB0aHJvdyBuZXcgTW9uZ29vc2VFcnJvci5NaXNzaW5nU2NoZW1hRXJyb3IobmFtZSk7XG4gIH1cblxuICBpZiAodGhpcyA9PT0gbW9kZWwucHJvdG90eXBlLmRiXG4gICAgICAmJiAoIWNvbGxlY3Rpb24gfHwgY29sbGVjdGlvbiA9PT0gbW9kZWwuY29sbGVjdGlvbi5uYW1lKSkge1xuICAgIC8vIG1vZGVsIGFscmVhZHkgdXNlcyB0aGlzIGNvbm5lY3Rpb24uXG5cbiAgICAvLyBvbmx5IHRoZSBmaXJzdCBtb2RlbCB3aXRoIHRoaXMgbmFtZSBpcyBjYWNoZWQgdG8gYWxsb3dcbiAgICAvLyBmb3Igb25lLW9mZnMgd2l0aCBjdXN0b20gY29sbGVjdGlvbiBuYW1lcyBldGMuXG4gICAgaWYgKCF0aGlzLm1vZGVsc1tuYW1lXSkge1xuICAgICAgdGhpcy5tb2RlbHNbbmFtZV0gPSBtb2RlbDtcbiAgICB9XG5cbiAgICByZXR1cm4gbW9kZWw7XG4gIH1cbiAgdGhpcy5tb2RlbHNbbmFtZV0gPSBtb2RlbC5fX3N1YmNsYXNzKHRoaXMsIHNjaGVtYSwgY29sbGVjdGlvbik7XG4gIHJldHVybiB0aGlzLm1vZGVsc1tuYW1lXTtcbn07XG5cbi8qKlxuICogUmVtb3ZlcyB0aGUgbW9kZWwgbmFtZWQgYG5hbWVgIGZyb20gdGhpcyBjb25uZWN0aW9uLCBpZiBpdCBleGlzdHMuIFlvdSBjYW5cbiAqIHVzZSB0aGlzIGZ1bmN0aW9uIHRvIGNsZWFuIHVwIGFueSBtb2RlbHMgeW91IGNyZWF0ZWQgaW4geW91ciB0ZXN0cyB0b1xuICogcHJldmVudCBPdmVyd3JpdGVNb2RlbEVycm9ycy5cbiAqXG4gKiAjIyMjIEV4YW1wbGU6XG4gKlxuICogICAgIGNvbm4ubW9kZWwoJ1VzZXInLCBuZXcgU2NoZW1hKHsgbmFtZTogU3RyaW5nIH0pKTtcbiAqICAgICBjb25zb2xlLmxvZyhjb25uLm1vZGVsKCdVc2VyJykpOyAvLyBNb2RlbCBvYmplY3RcbiAqICAgICBjb25uLmRlbGV0ZU1vZGVsKCdVc2VyJyk7XG4gKiAgICAgY29uc29sZS5sb2coY29ubi5tb2RlbCgnVXNlcicpKTsgLy8gdW5kZWZpbmVkXG4gKlxuICogICAgIC8vIFVzdWFsbHkgdXNlZnVsIGluIGEgTW9jaGEgYGFmdGVyRWFjaCgpYCBob29rXG4gKiAgICAgYWZ0ZXJFYWNoKGZ1bmN0aW9uKCkge1xuICogICAgICAgY29ubi5kZWxldGVNb2RlbCgvLisvKTsgLy8gRGVsZXRlIGV2ZXJ5IG1vZGVsXG4gKiAgICAgfSk7XG4gKlxuICogQGFwaSBwdWJsaWNcbiAqIEBwYXJhbSB7U3RyaW5nfFJlZ0V4cH0gbmFtZSBpZiBzdHJpbmcsIHRoZSBuYW1lIG9mIHRoZSBtb2RlbCB0byByZW1vdmUuIElmIHJlZ2V4cCwgcmVtb3ZlcyBhbGwgbW9kZWxzIHdob3NlIG5hbWUgbWF0Y2hlcyB0aGUgcmVnZXhwLlxuICogQHJldHVybiB7Q29ubmVjdGlvbn0gdGhpc1xuICovXG5cbkNvbm5lY3Rpb24ucHJvdG90eXBlLmRlbGV0ZU1vZGVsID0gZnVuY3Rpb24obmFtZSkge1xuICBpZiAodHlwZW9mIG5hbWUgPT09ICdzdHJpbmcnKSB7XG4gICAgY29uc3QgbW9kZWwgPSB0aGlzLm1vZGVsKG5hbWUpO1xuICAgIGlmIChtb2RlbCA9PSBudWxsKSB7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgY29uc3QgY29sbGVjdGlvbk5hbWUgPSBtb2RlbC5jb2xsZWN0aW9uLm5hbWU7XG4gICAgZGVsZXRlIHRoaXMubW9kZWxzW25hbWVdO1xuICAgIGRlbGV0ZSB0aGlzLmNvbGxlY3Rpb25zW2NvbGxlY3Rpb25OYW1lXTtcblxuICAgIHRoaXMuZW1pdCgnZGVsZXRlTW9kZWwnLCBtb2RlbCk7XG4gIH0gZWxzZSBpZiAobmFtZSBpbnN0YW5jZW9mIFJlZ0V4cCkge1xuICAgIGNvbnN0IHBhdHRlcm4gPSBuYW1lO1xuICAgIGNvbnN0IG5hbWVzID0gdGhpcy5tb2RlbE5hbWVzKCk7XG4gICAgZm9yIChjb25zdCBuYW1lIG9mIG5hbWVzKSB7XG4gICAgICBpZiAocGF0dGVybi50ZXN0KG5hbWUpKSB7XG4gICAgICAgIHRoaXMuZGVsZXRlTW9kZWwobmFtZSk7XG4gICAgICB9XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHRocm93IG5ldyBFcnJvcignRmlyc3QgcGFyYW1ldGVyIHRvIGBkZWxldGVNb2RlbCgpYCBtdXN0IGJlIGEgc3RyaW5nICcgK1xuICAgICAgJ29yIHJlZ2V4cCwgZ290IFwiJyArIG5hbWUgKyAnXCInKTtcbiAgfVxuXG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBXYXRjaGVzIHRoZSBlbnRpcmUgdW5kZXJseWluZyBkYXRhYmFzZSBmb3IgY2hhbmdlcy4gU2ltaWxhciB0b1xuICogW2BNb2RlbC53YXRjaCgpYF0oaHR0cHM6Ly9tb25nb29zZWpzLmNvbS9kb2NzL2FwaS9tb2RlbC5odG1sI01vZGVsLndhdGNoKCkpLlxuICpcbiAqIFRoaXMgZnVuY3Rpb24gZG9lcyAqKm5vdCoqIHRyaWdnZXIgYW55IG1pZGRsZXdhcmUuIEluIHBhcnRpY3VsYXIsIGl0XG4gKiBkb2VzICoqbm90KiogdHJpZ2dlciBhZ2dyZWdhdGUgbWlkZGxld2FyZS5cbiAqXG4gKiBUaGUgQ2hhbmdlU3RyZWFtIG9iamVjdCBpcyBhbiBldmVudCBlbWl0dGVyIHRoYXQgZW1pdHMgdGhlIGZvbGxvd2luZyBldmVudHM6XG4gKlxuICogLSAnY2hhbmdlJzogQSBjaGFuZ2Ugb2NjdXJyZWQsIHNlZSBiZWxvdyBleGFtcGxlXG4gKiAtICdlcnJvcic6IEFuIHVucmVjb3ZlcmFibGUgZXJyb3Igb2NjdXJyZWQuIEluIHBhcnRpY3VsYXIsIGNoYW5nZSBzdHJlYW1zIGN1cnJlbnRseSBlcnJvciBvdXQgaWYgdGhleSBsb3NlIGNvbm5lY3Rpb24gdG8gdGhlIHJlcGxpY2Egc2V0IHByaW1hcnkuIEZvbGxvdyBbdGhpcyBHaXRIdWIgaXNzdWVdKGh0dHBzOi8vZ2l0aHViLmNvbS9BdXRvbWF0dGljL21vbmdvb3NlL2lzc3Vlcy82Nzk5KSBmb3IgdXBkYXRlcy5cbiAqIC0gJ2VuZCc6IEVtaXR0ZWQgaWYgdGhlIHVuZGVybHlpbmcgc3RyZWFtIGlzIGNsb3NlZFxuICogLSAnY2xvc2UnOiBFbWl0dGVkIGlmIHRoZSB1bmRlcmx5aW5nIHN0cmVhbSBpcyBjbG9zZWRcbiAqXG4gKiAjIyMjIEV4YW1wbGU6XG4gKlxuICogICAgIGNvbnN0IFVzZXIgPSBjb25uLm1vZGVsKCdVc2VyJywgbmV3IFNjaGVtYSh7IG5hbWU6IFN0cmluZyB9KSk7XG4gKlxuICogICAgIGNvbnN0IGNoYW5nZVN0cmVhbSA9IGNvbm4ud2F0Y2goKS5vbignY2hhbmdlJywgZGF0YSA9PiBjb25zb2xlLmxvZyhkYXRhKSk7XG4gKlxuICogICAgIC8vIFRyaWdnZXJzIGEgJ2NoYW5nZScgZXZlbnQgb24gdGhlIGNoYW5nZSBzdHJlYW0uXG4gKiAgICAgYXdhaXQgVXNlci5jcmVhdGUoeyBuYW1lOiAndGVzdCcgfSk7XG4gKlxuICogQGFwaSBwdWJsaWNcbiAqIEBwYXJhbSB7QXJyYXl9IFtwaXBlbGluZV1cbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gcGFzc2VkIHdpdGhvdXQgY2hhbmdlcyB0byBbdGhlIE1vbmdvREIgZHJpdmVyJ3MgYERiI3dhdGNoKClgIGZ1bmN0aW9uXShodHRwczovL21vbmdvZGIuZ2l0aHViLmlvL25vZGUtbW9uZ29kYi1uYXRpdmUvNC45L2NsYXNzZXMvRGIuaHRtbCN3YXRjaClcbiAqIEByZXR1cm4ge0NoYW5nZVN0cmVhbX0gbW9uZ29vc2Utc3BlY2lmaWMgY2hhbmdlIHN0cmVhbSB3cmFwcGVyLCBpbmhlcml0cyBmcm9tIEV2ZW50RW1pdHRlclxuICovXG5cbkNvbm5lY3Rpb24ucHJvdG90eXBlLndhdGNoID0gZnVuY3Rpb24ocGlwZWxpbmUsIG9wdGlvbnMpIHtcbiAgY29uc3QgY2hhbmdlU3RyZWFtVGh1bmsgPSBjYiA9PiB7XG4gICAgaW1tZWRpYXRlKCgpID0+IHtcbiAgICAgIGlmICh0aGlzLnJlYWR5U3RhdGUgPT09IFNUQVRFUy5jb25uZWN0aW5nKSB7XG4gICAgICAgIHRoaXMub25jZSgnb3BlbicsIGZ1bmN0aW9uKCkge1xuICAgICAgICAgIGNvbnN0IGRyaXZlckNoYW5nZVN0cmVhbSA9IHRoaXMuZGIud2F0Y2gocGlwZWxpbmUsIG9wdGlvbnMpO1xuICAgICAgICAgIGNiKG51bGwsIGRyaXZlckNoYW5nZVN0cmVhbSk7XG4gICAgICAgIH0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc3QgZHJpdmVyQ2hhbmdlU3RyZWFtID0gdGhpcy5kYi53YXRjaChwaXBlbGluZSwgb3B0aW9ucyk7XG4gICAgICAgIGNiKG51bGwsIGRyaXZlckNoYW5nZVN0cmVhbSk7XG4gICAgICB9XG4gICAgfSk7XG4gIH07XG5cbiAgY29uc3QgY2hhbmdlU3RyZWFtID0gbmV3IENoYW5nZVN0cmVhbShjaGFuZ2VTdHJlYW1UaHVuaywgcGlwZWxpbmUsIG9wdGlvbnMpO1xuICByZXR1cm4gY2hhbmdlU3RyZWFtO1xufTtcblxuLyoqXG4gKiBSZXR1cm5zIGEgcHJvbWlzZSB0aGF0IHJlc29sdmVzIHdoZW4gdGhpcyBjb25uZWN0aW9uXG4gKiBzdWNjZXNzZnVsbHkgY29ubmVjdHMgdG8gTW9uZ29EQiwgb3IgcmVqZWN0cyBpZiB0aGlzIGNvbm5lY3Rpb24gZmFpbGVkXG4gKiB0byBjb25uZWN0LlxuICpcbiAqICMjIyMgRXhhbXBsZTpcbiAqXG4gKiAgICAgY29uc3QgY29ubiA9IGF3YWl0IG1vbmdvb3NlLmNyZWF0ZUNvbm5lY3Rpb24oJ21vbmdvZGI6Ly8xMjcuMC4wLjE6MjcwMTcvdGVzdCcpLlxuICogICAgICAgYXNQcm9taXNlKCk7XG4gKiAgICAgY29ubi5yZWFkeVN0YXRlOyAvLyAxLCBtZWFucyBNb25nb29zZSBpcyBjb25uZWN0ZWRcbiAqXG4gKiBAYXBpIHB1YmxpY1xuICogQHJldHVybiB7UHJvbWlzZX1cbiAqL1xuXG5Db25uZWN0aW9uLnByb3RvdHlwZS5hc1Byb21pc2UgPSBhc3luYyBmdW5jdGlvbiBhc1Byb21pc2UoKSB7XG4gIHRyeSB7XG4gICAgYXdhaXQgdGhpcy4kaW5pdGlhbENvbm5lY3Rpb247XG4gICAgcmV0dXJuIHRoaXM7XG4gIH0gY2F0Y2ggKGVycikge1xuICAgIHRocm93IF9oYW5kbGVDb25uZWN0aW9uRXJyb3JzKGVycik7XG4gIH1cbn07XG5cbi8qKlxuICogUmV0dXJucyBhbiBhcnJheSBvZiBtb2RlbCBuYW1lcyBjcmVhdGVkIG9uIHRoaXMgY29ubmVjdGlvbi5cbiAqIEBhcGkgcHVibGljXG4gKiBAcmV0dXJuIHtTdHJpbmdbXX1cbiAqL1xuXG5Db25uZWN0aW9uLnByb3RvdHlwZS5tb2RlbE5hbWVzID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiBPYmplY3Qua2V5cyh0aGlzLm1vZGVscyk7XG59O1xuXG4vKipcbiAqIFJldHVybnMgaWYgdGhlIGNvbm5lY3Rpb24gcmVxdWlyZXMgYXV0aGVudGljYXRpb24gYWZ0ZXIgaXQgaXMgb3BlbmVkLiBHZW5lcmFsbHkgaWYgYVxuICogdXNlcm5hbWUgYW5kIHBhc3N3b3JkIGFyZSBib3RoIHByb3ZpZGVkIHRoYW4gYXV0aGVudGljYXRpb24gaXMgbmVlZGVkLCBidXQgaW4gc29tZSBjYXNlcyBhXG4gKiBwYXNzd29yZCBpcyBub3QgcmVxdWlyZWQuXG4gKlxuICogQGFwaSBwcml2YXRlXG4gKiBAcmV0dXJuIHtCb29sZWFufSB0cnVlIGlmIHRoZSBjb25uZWN0aW9uIHNob3VsZCBiZSBhdXRoZW50aWNhdGVkIGFmdGVyIGl0IGlzIG9wZW5lZCwgb3RoZXJ3aXNlIGZhbHNlLlxuICovXG5Db25uZWN0aW9uLnByb3RvdHlwZS5zaG91bGRBdXRoZW50aWNhdGUgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHRoaXMudXNlciAhPSBudWxsICYmXG4gICAgKHRoaXMucGFzcyAhPSBudWxsIHx8IHRoaXMuYXV0aE1lY2hhbmlzbURvZXNOb3RSZXF1aXJlUGFzc3dvcmQoKSk7XG59O1xuXG4vKipcbiAqIFJldHVybnMgYSBib29sZWFuIHZhbHVlIHRoYXQgc3BlY2lmaWVzIGlmIHRoZSBjdXJyZW50IGF1dGhlbnRpY2F0aW9uIG1lY2hhbmlzbSBuZWVkcyBhXG4gKiBwYXNzd29yZCB0byBhdXRoZW50aWNhdGUgYWNjb3JkaW5nIHRvIHRoZSBhdXRoIG9iamVjdHMgcGFzc2VkIGludG8gdGhlIG9wZW5VcmkgbWV0aG9kcy5cbiAqXG4gKiBAYXBpIHByaXZhdGVcbiAqIEByZXR1cm4ge0Jvb2xlYW59IHRydWUgaWYgdGhlIGF1dGhlbnRpY2F0aW9uIG1lY2hhbmlzbSBzcGVjaWZpZWQgaW4gdGhlIG9wdGlvbnMgb2JqZWN0IHJlcXVpcmVzXG4gKiAgYSBwYXNzd29yZCwgb3RoZXJ3aXNlIGZhbHNlLlxuICovXG5Db25uZWN0aW9uLnByb3RvdHlwZS5hdXRoTWVjaGFuaXNtRG9lc05vdFJlcXVpcmVQYXNzd29yZCA9IGZ1bmN0aW9uKCkge1xuICBpZiAodGhpcy5vcHRpb25zICYmIHRoaXMub3B0aW9ucy5hdXRoKSB7XG4gICAgcmV0dXJuIG5vUGFzc3dvcmRBdXRoTWVjaGFuaXNtcy5pbmRleE9mKHRoaXMub3B0aW9ucy5hdXRoLmF1dGhNZWNoYW5pc20pID49IDA7XG4gIH1cbiAgcmV0dXJuIHRydWU7XG59O1xuXG4vKipcbiAqIFJldHVybnMgYSBib29sZWFuIHZhbHVlIHRoYXQgc3BlY2lmaWVzIGlmIHRoZSBwcm92aWRlZCBvYmplY3RzIG9iamVjdCBwcm92aWRlcyBlbm91Z2hcbiAqIGRhdGEgdG8gYXV0aGVudGljYXRlIHdpdGguIEdlbmVyYWxseSB0aGlzIGlzIHRydWUgaWYgdGhlIHVzZXJuYW1lIGFuZCBwYXNzd29yZCBhcmUgYm90aCBzcGVjaWZpZWRcbiAqIGJ1dCBpbiBzb21lIGF1dGhlbnRpY2F0aW9uIG1ldGhvZHMsIGEgcGFzc3dvcmQgaXMgbm90IHJlcXVpcmVkIGZvciBhdXRoZW50aWNhdGlvbiBzbyBvbmx5IGEgdXNlcm5hbWVcbiAqIGlzIHJlcXVpcmVkLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gdGhlIG9wdGlvbnMgb2JqZWN0IHBhc3NlZCBpbnRvIHRoZSBvcGVuVXJpIG1ldGhvZHMuXG4gKiBAYXBpIHByaXZhdGVcbiAqIEByZXR1cm4ge0Jvb2xlYW59IHRydWUgaWYgdGhlIHByb3ZpZGVkIG9wdGlvbnMgb2JqZWN0IHByb3ZpZGVzIGVub3VnaCBkYXRhIHRvIGF1dGhlbnRpY2F0ZSB3aXRoLFxuICogICBvdGhlcndpc2UgZmFsc2UuXG4gKi9cbkNvbm5lY3Rpb24ucHJvdG90eXBlLm9wdGlvbnNQcm92aWRlQXV0aGVudGljYXRpb25EYXRhID0gZnVuY3Rpb24ob3B0aW9ucykge1xuICByZXR1cm4gKG9wdGlvbnMpICYmXG4gICAgICAob3B0aW9ucy51c2VyKSAmJlxuICAgICAgKChvcHRpb25zLnBhc3MpIHx8IHRoaXMuYXV0aE1lY2hhbmlzbURvZXNOb3RSZXF1aXJlUGFzc3dvcmQoKSk7XG59O1xuXG4vKipcbiAqIFJldHVybnMgdGhlIFtNb25nb0RCIGRyaXZlciBgTW9uZ29DbGllbnRgXShodHRwczovL21vbmdvZGIuZ2l0aHViLmlvL25vZGUtbW9uZ29kYi1uYXRpdmUvNC45L2NsYXNzZXMvTW9uZ29DbGllbnQuaHRtbCkgaW5zdGFuY2VcbiAqIHRoYXQgdGhpcyBjb25uZWN0aW9uIHVzZXMgdG8gdGFsayB0byBNb25nb0RCLlxuICpcbiAqICMjIyMgRXhhbXBsZTpcbiAqXG4gKiAgICAgY29uc3QgY29ubiA9IGF3YWl0IG1vbmdvb3NlLmNyZWF0ZUNvbm5lY3Rpb24oJ21vbmdvZGI6Ly8xMjcuMC4wLjE6MjcwMTcvdGVzdCcpLlxuICogICAgICAgYXNQcm9taXNlKCk7XG4gKlxuICogICAgIGNvbm4uZ2V0Q2xpZW50KCk7IC8vIE1vbmdvQ2xpZW50IHsgLi4uIH1cbiAqXG4gKiBAYXBpIHB1YmxpY1xuICogQHJldHVybiB7TW9uZ29DbGllbnR9XG4gKi9cblxuQ29ubmVjdGlvbi5wcm90b3R5cGUuZ2V0Q2xpZW50ID0gZnVuY3Rpb24gZ2V0Q2xpZW50KCkge1xuICByZXR1cm4gdGhpcy5jbGllbnQ7XG59O1xuXG4vKipcbiAqIFNldCB0aGUgW01vbmdvREIgZHJpdmVyIGBNb25nb0NsaWVudGBdKGh0dHBzOi8vbW9uZ29kYi5naXRodWIuaW8vbm9kZS1tb25nb2RiLW5hdGl2ZS80LjkvY2xhc3Nlcy9Nb25nb0NsaWVudC5odG1sKSBpbnN0YW5jZVxuICogdGhhdCB0aGlzIGNvbm5lY3Rpb24gdXNlcyB0byB0YWxrIHRvIE1vbmdvREIuIFRoaXMgaXMgdXNlZnVsIGlmIHlvdSBhbHJlYWR5IGhhdmUgYSBNb25nb0NsaWVudCBpbnN0YW5jZSwgYW5kIHdhbnQgdG9cbiAqIHJldXNlIGl0LlxuICpcbiAqICMjIyMgRXhhbXBsZTpcbiAqXG4gKiAgICAgY29uc3QgY2xpZW50ID0gYXdhaXQgbW9uZ29kYi5Nb25nb0NsaWVudC5jb25uZWN0KCdtb25nb2RiOi8vMTI3LjAuMC4xOjI3MDE3L3Rlc3QnKTtcbiAqXG4gKiAgICAgY29uc3QgY29ubiA9IG1vbmdvb3NlLmNyZWF0ZUNvbm5lY3Rpb24oKS5zZXRDbGllbnQoY2xpZW50KTtcbiAqXG4gKiAgICAgY29ubi5nZXRDbGllbnQoKTsgLy8gTW9uZ29DbGllbnQgeyAuLi4gfVxuICogICAgIGNvbm4ucmVhZHlTdGF0ZTsgLy8gMSwgbWVhbnMgJ0NPTk5FQ1RFRCdcbiAqXG4gKiBAYXBpIHB1YmxpY1xuICogQHBhcmFtIHtNb25nQ2xpZW50fSBjbGllbnQgVGhlIENsaWVudCB0byBzZXQgdG8gYmUgdXNlZC5cbiAqIEByZXR1cm4ge0Nvbm5lY3Rpb259IHRoaXNcbiAqL1xuXG5Db25uZWN0aW9uLnByb3RvdHlwZS5zZXRDbGllbnQgPSBmdW5jdGlvbiBzZXRDbGllbnQoKSB7XG4gIHRocm93IG5ldyBNb25nb29zZUVycm9yKCdDb25uZWN0aW9uI3NldENsaWVudCBub3QgaW1wbGVtZW50ZWQgYnkgZHJpdmVyJyk7XG59O1xuXG4vKiFcbiAqIENhbGxlZCBpbnRlcm5hbGx5IGJ5IGBvcGVuVXJpKClgIHRvIGNyZWF0ZSBhIE1vbmdvQ2xpZW50IGluc3RhbmNlLlxuICovXG5cbkNvbm5lY3Rpb24ucHJvdG90eXBlLmNyZWF0ZUNsaWVudCA9IGZ1bmN0aW9uIGNyZWF0ZUNsaWVudCgpIHtcbiAgdGhyb3cgbmV3IE1vbmdvb3NlRXJyb3IoJ0Nvbm5lY3Rpb24jY3JlYXRlQ2xpZW50IG5vdCBpbXBsZW1lbnRlZCBieSBkcml2ZXInKTtcbn07XG5cbi8qKlxuICogU3luY3MgYWxsIHRoZSBpbmRleGVzIGZvciB0aGUgbW9kZWxzIHJlZ2lzdGVyZWQgd2l0aCB0aGlzIGNvbm5lY3Rpb24uXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXVxuICogQHBhcmFtIHtCb29sZWFufSBbb3B0aW9ucy5jb250aW51ZU9uRXJyb3JdIGBmYWxzZWAgYnkgZGVmYXVsdC4gSWYgc2V0IHRvIGB0cnVlYCwgbW9uZ29vc2Ugd2lsbCBub3QgdGhyb3cgYW4gZXJyb3IgaWYgb25lIG1vZGVsIHN5bmNpbmcgZmFpbGVkLCBhbmQgd2lsbCByZXR1cm4gYW4gb2JqZWN0IHdoZXJlIHRoZSBrZXlzIGFyZSB0aGUgbmFtZXMgb2YgdGhlIG1vZGVscywgYW5kIHRoZSB2YWx1ZXMgYXJlIHRoZSByZXN1bHRzL2Vycm9ycyBmb3IgZWFjaCBtb2RlbC5cbiAqIEByZXR1cm4ge1Byb21pc2U8T2JqZWN0Pn0gUmV0dXJucyBhIFByb21pc2UsIHdoZW4gdGhlIFByb21pc2UgcmVzb2x2ZXMgdGhlIHZhbHVlIGlzIGEgbGlzdCBvZiB0aGUgZHJvcHBlZCBpbmRleGVzLlxuICovXG5Db25uZWN0aW9uLnByb3RvdHlwZS5zeW5jSW5kZXhlcyA9IGFzeW5jIGZ1bmN0aW9uIHN5bmNJbmRleGVzKG9wdGlvbnMgPSB7fSkge1xuICBjb25zdCByZXN1bHQgPSB7fTtcbiAgY29uc3QgZXJyb3JzTWFwID0geyB9O1xuXG4gIGNvbnN0IHsgY29udGludWVPbkVycm9yIH0gPSBvcHRpb25zO1xuICBkZWxldGUgb3B0aW9ucy5jb250aW51ZU9uRXJyb3I7XG5cbiAgZm9yIChjb25zdCBtb2RlbCBvZiBPYmplY3QudmFsdWVzKHRoaXMubW9kZWxzKSkge1xuICAgIHRyeSB7XG4gICAgICByZXN1bHRbbW9kZWwubW9kZWxOYW1lXSA9IGF3YWl0IG1vZGVsLnN5bmNJbmRleGVzKG9wdGlvbnMpO1xuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgaWYgKCFjb250aW51ZU9uRXJyb3IpIHtcbiAgICAgICAgZXJyb3JzTWFwW21vZGVsLm1vZGVsTmFtZV0gPSBlcnI7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmVzdWx0W21vZGVsLm1vZGVsTmFtZV0gPSBlcnI7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgaWYgKCFjb250aW51ZU9uRXJyb3IgJiYgT2JqZWN0LmtleXMoZXJyb3JzTWFwKS5sZW5ndGgpIHtcbiAgICBjb25zdCBtZXNzYWdlID0gT2JqZWN0LmVudHJpZXMoZXJyb3JzTWFwKS5tYXAoKFttb2RlbE5hbWUsIGVycl0pID0+IGAke21vZGVsTmFtZX06ICR7ZXJyLm1lc3NhZ2V9YCkuam9pbignLCAnKTtcbiAgICBjb25zdCBzeW5jSW5kZXhlc0Vycm9yID0gbmV3IFN5bmNJbmRleGVzRXJyb3IobWVzc2FnZSwgZXJyb3JzTWFwKTtcbiAgICB0aHJvdyBzeW5jSW5kZXhlc0Vycm9yO1xuICB9XG5cbiAgcmV0dXJuIHJlc3VsdDtcbn07XG5cbi8qKlxuICogU3dpdGNoZXMgdG8gYSBkaWZmZXJlbnQgZGF0YWJhc2UgdXNpbmcgdGhlIHNhbWUgW2Nvbm5lY3Rpb24gcG9vbF0oaHR0cHM6Ly9tb25nb29zZWpzLmNvbS9kb2NzL2FwaS9jb25uZWN0aW9uc2h0bWwjY29ubmVjdGlvbl9wb29scykuXG4gKlxuICogUmV0dXJucyBhIG5ldyBjb25uZWN0aW9uIG9iamVjdCwgd2l0aCB0aGUgbmV3IGRiLlxuICpcbiAqICMjIyMgRXhhbXBsZTpcbiAqXG4gKiAgICAgLy8gQ29ubmVjdCB0byBgaW5pdGlhbGRiYCBmaXJzdFxuICogICAgIGNvbnN0IGNvbm4gPSBhd2FpdCBtb25nb29zZS5jcmVhdGVDb25uZWN0aW9uKCdtb25nb2RiOi8vMTI3LjAuMC4xOjI3MDE3L2luaXRpYWxkYicpLmFzUHJvbWlzZSgpO1xuICpcbiAqICAgICAvLyBDcmVhdGVzIGFuIHVuLWNhY2hlZCBjb25uZWN0aW9uIHRvIGBteWRiYFxuICogICAgIGNvbnN0IGRiID0gY29ubi51c2VEYignbXlkYicpO1xuICogICAgIC8vIENyZWF0ZXMgYSBjYWNoZWQgY29ubmVjdGlvbiB0byBgbXlkYjJgLiBBbGwgY2FsbHMgdG8gYGNvbm4udXNlRGIoJ215ZGIyJywgeyB1c2VDYWNoZTogdHJ1ZSB9KWAgd2lsbCByZXR1cm4gdGhlIHNhbWVcbiAqICAgICAvLyBjb25uZWN0aW9uIGluc3RhbmNlIGFzIG9wcG9zZWQgdG8gY3JlYXRpbmcgYSBuZXcgY29ubmVjdGlvbiBpbnN0YW5jZVxuICogICAgIGNvbnN0IGRiMiA9IGNvbm4udXNlRGIoJ215ZGIyJywgeyB1c2VDYWNoZTogdHJ1ZSB9KTtcbiAqXG4gKiBAbWV0aG9kIHVzZURiXG4gKiBAbWVtYmVyT2YgQ29ubmVjdGlvblxuICogQHBhcmFtIHtTdHJpbmd9IG5hbWUgVGhlIGRhdGFiYXNlIG5hbWVcbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc11cbiAqIEBwYXJhbSB7Qm9vbGVhbn0gW29wdGlvbnMudXNlQ2FjaGU9ZmFsc2VdIElmIHRydWUsIGNhY2hlIHJlc3VsdHMgc28gY2FsbGluZyBgdXNlRGIoKWAgbXVsdGlwbGUgdGltZXMgd2l0aCB0aGUgc2FtZSBuYW1lIG9ubHkgY3JlYXRlcyAxIGNvbm5lY3Rpb24gb2JqZWN0LlxuICogQHBhcmFtIHtCb29sZWFufSBbb3B0aW9ucy5ub0xpc3RlbmVyPWZhbHNlXSBJZiB0cnVlLCB0aGUgY29ubmVjdGlvbiBvYmplY3Qgd2lsbCBub3QgbWFrZSB0aGUgZGIgbGlzdGVuIHRvIGV2ZW50cyBvbiB0aGUgb3JpZ2luYWwgY29ubmVjdGlvbi4gU2VlIFtpc3N1ZSAjOTk2MV0oaHR0cHM6Ly9naXRodWIuY29tL0F1dG9tYXR0aWMvbW9uZ29vc2UvaXNzdWVzLzk5NjEpLlxuICogQHJldHVybiB7Q29ubmVjdGlvbn0gTmV3IENvbm5lY3Rpb24gT2JqZWN0XG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbi8qKlxuICogUmVtb3ZlcyB0aGUgZGF0YWJhc2UgY29ubmVjdGlvbiB3aXRoIHRoZSBnaXZlbiBuYW1lIGNyZWF0ZWQgd2l0aCB3aXRoIGB1c2VEYigpYC5cbiAqXG4gKiBUaHJvd3MgYW4gZXJyb3IgaWYgdGhlIGRhdGFiYXNlIGNvbm5lY3Rpb24gd2FzIG5vdCBmb3VuZC5cbiAqXG4gKiAjIyMjIEV4YW1wbGU6XG4gKlxuICogICAgIC8vIENvbm5lY3QgdG8gYGluaXRpYWxkYmAgZmlyc3RcbiAqICAgICBjb25zdCBjb25uID0gYXdhaXQgbW9uZ29vc2UuY3JlYXRlQ29ubmVjdGlvbignbW9uZ29kYjovLzEyNy4wLjAuMToyNzAxNy9pbml0aWFsZGInKS5hc1Byb21pc2UoKTtcbiAqXG4gKiAgICAgLy8gQ3JlYXRlcyBhbiB1bi1jYWNoZWQgY29ubmVjdGlvbiB0byBgbXlkYmBcbiAqICAgICBjb25zdCBkYiA9IGNvbm4udXNlRGIoJ215ZGInKTtcbiAqXG4gKiAgICAgLy8gQ2xvc2VzIGBkYmAsIGFuZCByZW1vdmVzIGBkYmAgZnJvbSBgY29ubi5yZWxhdGVkRGJzYCBhbmQgYGNvbm4ub3RoZXJEYnNgXG4gKiAgICAgYXdhaXQgY29ubi5yZW1vdmVEYignbXlkYicpO1xuICpcbiAqIEBtZXRob2QgcmVtb3ZlRGJcbiAqIEBtZW1iZXJPZiBDb25uZWN0aW9uXG4gKiBAcGFyYW0ge1N0cmluZ30gbmFtZSBUaGUgZGF0YWJhc2UgbmFtZVxuICogQHJldHVybiB7Q29ubmVjdGlvbn0gdGhpc1xuICogQGFwaSBwdWJsaWNcbiAqL1xuXG4vKiFcbiAqIE1vZHVsZSBleHBvcnRzLlxuICovXG5cbkNvbm5lY3Rpb24uU1RBVEVTID0gU1RBVEVTO1xubW9kdWxlLmV4cG9ydHMgPSBDb25uZWN0aW9uO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/mongoose/lib/connection.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/mongoose/lib/connectionState.js":
/*!******************************************************!*\
  !*** ./node_modules/mongoose/lib/connectionState.js ***!
  \******************************************************/
/***/ ((module, exports) => {

eval("\n/*!\n * Connection states\n */\n\n\n\nconst STATES = module.exports = exports = Object.create(null);\n\nconst disconnected = 'disconnected';\nconst connected = 'connected';\nconst connecting = 'connecting';\nconst disconnecting = 'disconnecting';\nconst uninitialized = 'uninitialized';\n\nSTATES[0] = disconnected;\nSTATES[1] = connected;\nSTATES[2] = connecting;\nSTATES[3] = disconnecting;\nSTATES[99] = uninitialized;\n\nSTATES[disconnected] = 0;\nSTATES[connected] = 1;\nSTATES[connecting] = 2;\nSTATES[disconnecting] = 3;\nSTATES[uninitialized] = 99;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbW9uZ29vc2UvbGliL2Nvbm5lY3Rpb25TdGF0ZS5qcyIsIm1hcHBpbmdzIjoiO0FBQ0E7QUFDQTtBQUNBOztBQUVhOztBQUViOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vYXBwMS8uL25vZGVfbW9kdWxlcy9tb25nb29zZS9saWIvY29ubmVjdGlvblN0YXRlLmpzP2E5NzAiXSwic291cmNlc0NvbnRlbnQiOlsiXG4vKiFcbiAqIENvbm5lY3Rpb24gc3RhdGVzXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG5jb25zdCBTVEFURVMgPSBtb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuXG5jb25zdCBkaXNjb25uZWN0ZWQgPSAnZGlzY29ubmVjdGVkJztcbmNvbnN0IGNvbm5lY3RlZCA9ICdjb25uZWN0ZWQnO1xuY29uc3QgY29ubmVjdGluZyA9ICdjb25uZWN0aW5nJztcbmNvbnN0IGRpc2Nvbm5lY3RpbmcgPSAnZGlzY29ubmVjdGluZyc7XG5jb25zdCB1bmluaXRpYWxpemVkID0gJ3VuaW5pdGlhbGl6ZWQnO1xuXG5TVEFURVNbMF0gPSBkaXNjb25uZWN0ZWQ7XG5TVEFURVNbMV0gPSBjb25uZWN0ZWQ7XG5TVEFURVNbMl0gPSBjb25uZWN0aW5nO1xuU1RBVEVTWzNdID0gZGlzY29ubmVjdGluZztcblNUQVRFU1s5OV0gPSB1bmluaXRpYWxpemVkO1xuXG5TVEFURVNbZGlzY29ubmVjdGVkXSA9IDA7XG5TVEFURVNbY29ubmVjdGVkXSA9IDE7XG5TVEFURVNbY29ubmVjdGluZ10gPSAyO1xuU1RBVEVTW2Rpc2Nvbm5lY3RpbmddID0gMztcblNUQVRFU1t1bmluaXRpYWxpemVkXSA9IDk5O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/mongoose/lib/connectionState.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/mongoose/lib/cursor/aggregationCursor.js":
/*!***************************************************************!*\
  !*** ./node_modules/mongoose/lib/cursor/aggregationCursor.js ***!
  \***************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("/*!\n * Module dependencies.\n */\n\n\n\nconst MongooseError = __webpack_require__(/*! ../error/mongooseError */ \"(ssr)/./node_modules/mongoose/lib/error/mongooseError.js\");\nconst Readable = (__webpack_require__(/*! stream */ \"stream\").Readable);\nconst eachAsync = __webpack_require__(/*! ../helpers/cursor/eachAsync */ \"(ssr)/./node_modules/mongoose/lib/helpers/cursor/eachAsync.js\");\nconst immediate = __webpack_require__(/*! ../helpers/immediate */ \"(ssr)/./node_modules/mongoose/lib/helpers/immediate.js\");\nconst util = __webpack_require__(/*! util */ \"util\");\n\n/**\n * An AggregationCursor is a concurrency primitive for processing aggregation\n * results one document at a time. It is analogous to QueryCursor.\n *\n * An AggregationCursor fulfills the Node.js streams3 API,\n * in addition to several other mechanisms for loading documents from MongoDB\n * one at a time.\n *\n * Creating an AggregationCursor executes the model's pre aggregate hooks,\n * but **not** the model's post aggregate hooks.\n *\n * Unless you're an advanced user, do **not** instantiate this class directly.\n * Use [`Aggregate#cursor()`](https://mongoosejs.com/docs/api/aggregate.html#Aggregate.prototype.cursor()) instead.\n *\n * @param {Aggregate} agg\n * @inherits Readable https://nodejs.org/api/stream.html#class-streamreadable\n * @event `cursor`: Emitted when the cursor is created\n * @event `error`: Emitted when an error occurred\n * @event `data`: Emitted when the stream is flowing and the next doc is ready\n * @event `end`: Emitted when the stream is exhausted\n * @api public\n */\n\nfunction AggregationCursor(agg) {\n  // set autoDestroy=true because on node 12 it's by default false\n  // gh-10902 need autoDestroy to destroy correctly and emit 'close' event\n  Readable.call(this, { autoDestroy: true, objectMode: true });\n\n  this.cursor = null;\n  this.agg = agg;\n  this._transforms = [];\n  const model = agg._model;\n  delete agg.options.cursor.useMongooseAggCursor;\n  this._mongooseOptions = {};\n\n  _init(model, this, agg);\n}\n\nutil.inherits(AggregationCursor, Readable);\n\n/*!\n * ignore\n */\n\nfunction _init(model, c, agg) {\n  if (!model.collection.buffer) {\n    model.hooks.execPre('aggregate', agg, function() {\n      c.cursor = model.collection.aggregate(agg._pipeline, agg.options || {});\n      c.emit('cursor', c.cursor);\n    });\n  } else {\n    model.collection.emitter.once('queue', function() {\n      model.hooks.execPre('aggregate', agg, function() {\n        c.cursor = model.collection.aggregate(agg._pipeline, agg.options || {});\n        c.emit('cursor', c.cursor);\n      });\n    });\n  }\n}\n\n/**\n * Necessary to satisfy the Readable API\n * @method _read\n * @memberOf AggregationCursor\n * @instance\n * @api private\n */\n\nAggregationCursor.prototype._read = function() {\n  const _this = this;\n  _next(this, function(error, doc) {\n    if (error) {\n      return _this.emit('error', error);\n    }\n    if (!doc) {\n      _this.push(null);\n      _this.cursor.close(function(error) {\n        if (error) {\n          return _this.emit('error', error);\n        }\n      });\n      return;\n    }\n    _this.push(doc);\n  });\n};\n\nif (Symbol.asyncIterator != null) {\n  const msg = 'Mongoose does not support using async iterators with an ' +\n    'existing aggregation cursor. See https://bit.ly/mongoose-async-iterate-aggregation';\n\n  AggregationCursor.prototype[Symbol.asyncIterator] = function() {\n    throw new MongooseError(msg);\n  };\n}\n\n/**\n * Registers a transform function which subsequently maps documents retrieved\n * via the streams interface or `.next()`\n *\n * #### Example:\n *\n *     // Map documents returned by `data` events\n *     Thing.\n *       find({ name: /^hello/ }).\n *       cursor().\n *       map(function (doc) {\n *        doc.foo = \"bar\";\n *        return doc;\n *       })\n *       on('data', function(doc) { console.log(doc.foo); });\n *\n *     // Or map documents returned by `.next()`\n *     const cursor = Thing.find({ name: /^hello/ }).\n *       cursor().\n *       map(function (doc) {\n *         doc.foo = \"bar\";\n *         return doc;\n *       });\n *     cursor.next(function(error, doc) {\n *       console.log(doc.foo);\n *     });\n *\n * @param {Function} fn\n * @return {AggregationCursor}\n * @memberOf AggregationCursor\n * @api public\n * @method map\n */\n\nObject.defineProperty(AggregationCursor.prototype, 'map', {\n  value: function(fn) {\n    this._transforms.push(fn);\n    return this;\n  },\n  enumerable: true,\n  configurable: true,\n  writable: true\n});\n\n/**\n * Marks this cursor as errored\n * @method _markError\n * @instance\n * @memberOf AggregationCursor\n * @api private\n */\n\nAggregationCursor.prototype._markError = function(error) {\n  this._error = error;\n  return this;\n};\n\n/**\n * Marks this cursor as closed. Will stop streaming and subsequent calls to\n * `next()` will error.\n *\n * @param {Function} callback\n * @return {Promise}\n * @api public\n * @method close\n * @emits close\n * @see AggregationCursor.close https://mongodb.github.io/node-mongodb-native/4.9/classes/AggregationCursor.html#close\n */\n\nAggregationCursor.prototype.close = async function close() {\n  if (typeof arguments[0] === 'function') {\n    throw new MongooseError('AggregationCursor.prototype.close() no longer accepts a callback');\n  }\n  try {\n    await this.cursor.close();\n  } catch (error) {\n    this.listeners('error').length > 0 && this.emit('error', error);\n    throw error;\n  }\n  this.emit('close');\n};\n\n/**\n * Get the next document from this cursor. Will return `null` when there are\n * no documents left.\n *\n * @return {Promise}\n * @api public\n * @method next\n */\n\nAggregationCursor.prototype.next = async function next() {\n  if (typeof arguments[0] === 'function') {\n    throw new MongooseError('AggregationCursor.prototype.next() no longer accepts a callback');\n  }\n  return new Promise((resolve, reject) => {\n    _next(this, (err, res) => {\n      if (err != null) {\n        return reject(err);\n      }\n      resolve(res);\n    });\n  });\n};\n\n/**\n * Execute `fn` for every document in the cursor. If `fn` returns a promise,\n * will wait for the promise to resolve before iterating on to the next one.\n * Returns a promise that resolves when done.\n *\n * @param {Function} fn\n * @param {Object} [options]\n * @param {Number} [options.parallel] the number of promises to execute in parallel. Defaults to 1.\n * @param {Function} [callback] executed when all docs have been processed\n * @return {Promise}\n * @api public\n * @method eachAsync\n */\n\nAggregationCursor.prototype.eachAsync = function(fn, opts, callback) {\n  const _this = this;\n  if (typeof opts === 'function') {\n    callback = opts;\n    opts = {};\n  }\n  opts = opts || {};\n\n  return eachAsync(function(cb) { return _next(_this, cb); }, fn, opts, callback);\n};\n\n/**\n * Returns an asyncIterator for use with [`for/await/of` loops](https://thecodebarbarian.com/getting-started-with-async-iterators-in-node-js)\n * You do not need to call this function explicitly, the JavaScript runtime\n * will call it for you.\n *\n * #### Example:\n *\n *     // Async iterator without explicitly calling `cursor()`. Mongoose still\n *     // creates an AggregationCursor instance internally.\n *     const agg = Model.aggregate([{ $match: { age: { $gte: 25 } } }]);\n *     for await (const doc of agg) {\n *       console.log(doc.name);\n *     }\n *\n *     // You can also use an AggregationCursor instance for async iteration\n *     const cursor = Model.aggregate([{ $match: { age: { $gte: 25 } } }]).cursor();\n *     for await (const doc of cursor) {\n *       console.log(doc.name);\n *     }\n *\n * Node.js 10.x supports async iterators natively without any flags. You can\n * enable async iterators in Node.js 8.x using the [`--harmony_async_iteration` flag](https://github.com/tc39/proposal-async-iteration/issues/117#issuecomment-346695187).\n *\n * **Note:** This function is not set if `Symbol.asyncIterator` is undefined. If\n * `Symbol.asyncIterator` is undefined, that means your Node.js version does not\n * support async iterators.\n *\n * @method [Symbol.asyncIterator]\n * @memberOf AggregationCursor\n * @instance\n * @api public\n */\n\nif (Symbol.asyncIterator != null) {\n  AggregationCursor.prototype[Symbol.asyncIterator] = function() {\n    return this.transformNull()._transformForAsyncIterator();\n  };\n}\n\n/*!\n * ignore\n */\n\nAggregationCursor.prototype._transformForAsyncIterator = function() {\n  if (this._transforms.indexOf(_transformForAsyncIterator) === -1) {\n    this.map(_transformForAsyncIterator);\n  }\n  return this;\n};\n\n/*!\n * ignore\n */\n\nAggregationCursor.prototype.transformNull = function(val) {\n  if (arguments.length === 0) {\n    val = true;\n  }\n  this._mongooseOptions.transformNull = val;\n  return this;\n};\n\n/*!\n * ignore\n */\n\nfunction _transformForAsyncIterator(doc) {\n  return doc == null ? { done: true } : { value: doc, done: false };\n}\n\n/**\n * Adds a [cursor flag](https://mongodb.github.io/node-mongodb-native/4.9/classes/AggregationCursor.html#addCursorFlag).\n * Useful for setting the `noCursorTimeout` and `tailable` flags.\n *\n * @param {String} flag\n * @param {Boolean} value\n * @return {AggregationCursor} this\n * @api public\n * @method addCursorFlag\n */\n\nAggregationCursor.prototype.addCursorFlag = function(flag, value) {\n  const _this = this;\n  _waitForCursor(this, function() {\n    _this.cursor.addCursorFlag(flag, value);\n  });\n  return this;\n};\n\n/*!\n * ignore\n */\n\nfunction _waitForCursor(ctx, cb) {\n  if (ctx.cursor) {\n    return cb();\n  }\n  ctx.once('cursor', function() {\n    cb();\n  });\n}\n\n/**\n * Get the next doc from the underlying cursor and mongooseify it\n * (populate, etc.)\n * @param {Any} ctx\n * @param {Function} cb\n * @api private\n */\n\nfunction _next(ctx, cb) {\n  let callback = cb;\n  if (ctx._transforms.length) {\n    callback = function(err, doc) {\n      if (err || (doc === null && !ctx._mongooseOptions.transformNull)) {\n        return cb(err, doc);\n      }\n      cb(err, ctx._transforms.reduce(function(doc, fn) {\n        return fn(doc);\n      }, doc));\n    };\n  }\n\n  if (ctx._error) {\n    return immediate(function() {\n      callback(ctx._error);\n    });\n  }\n\n  if (ctx.cursor) {\n    return ctx.cursor.next().then(\n      doc => {\n        if (!doc) {\n          return callback(null, null);\n        }\n\n        callback(null, doc);\n      },\n      err => callback(err)\n    );\n  } else {\n    ctx.once('cursor', function() {\n      _next(ctx, cb);\n    });\n  }\n}\n\nmodule.exports = AggregationCursor;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbW9uZ29vc2UvbGliL2N1cnNvci9hZ2dyZWdhdGlvbkN1cnNvci5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7O0FBRWE7O0FBRWIsc0JBQXNCLG1CQUFPLENBQUMsd0ZBQXdCO0FBQ3RELGlCQUFpQixzREFBMEI7QUFDM0Msa0JBQWtCLG1CQUFPLENBQUMsa0dBQTZCO0FBQ3ZELGtCQUFrQixtQkFBTyxDQUFDLG9GQUFzQjtBQUNoRCxhQUFhLG1CQUFPLENBQUMsa0JBQU07O0FBRTNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFdBQVc7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLHFDQUFxQzs7QUFFN0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLDRFQUE0RTtBQUM1RTtBQUNBLEtBQUs7QUFDTCxJQUFJO0FBQ0o7QUFDQTtBQUNBLDhFQUE4RTtBQUM5RTtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLGdCQUFnQjtBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVixvQ0FBb0MsdUJBQXVCO0FBQzNEO0FBQ0E7QUFDQSxtQ0FBbUMsZ0JBQWdCO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQSxXQUFXLFVBQVU7QUFDckIsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFVBQVU7QUFDckIsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxVQUFVO0FBQ3JCLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsV0FBVyxVQUFVO0FBQ3JCLFlBQVk7QUFDWjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsa0NBQWtDLDBCQUEwQjtBQUM1RDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0MsVUFBVSxPQUFPLGNBQWM7QUFDckU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlDQUF5QyxVQUFVLE9BQU8sY0FBYztBQUN4RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHlCQUF5QixhQUFhLElBQUk7QUFDMUM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsV0FBVyxTQUFTO0FBQ3BCLFlBQVksbUJBQW1CO0FBQy9CO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxLQUFLO0FBQ2hCLFdBQVcsVUFBVTtBQUNyQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUEiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9hcHAxLy4vbm9kZV9tb2R1bGVzL21vbmdvb3NlL2xpYi9jdXJzb3IvYWdncmVnYXRpb25DdXJzb3IuanM/N2RhOSJdLCJzb3VyY2VzQ29udGVudCI6WyIvKiFcbiAqIE1vZHVsZSBkZXBlbmRlbmNpZXMuXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG5jb25zdCBNb25nb29zZUVycm9yID0gcmVxdWlyZSgnLi4vZXJyb3IvbW9uZ29vc2VFcnJvcicpO1xuY29uc3QgUmVhZGFibGUgPSByZXF1aXJlKCdzdHJlYW0nKS5SZWFkYWJsZTtcbmNvbnN0IGVhY2hBc3luYyA9IHJlcXVpcmUoJy4uL2hlbHBlcnMvY3Vyc29yL2VhY2hBc3luYycpO1xuY29uc3QgaW1tZWRpYXRlID0gcmVxdWlyZSgnLi4vaGVscGVycy9pbW1lZGlhdGUnKTtcbmNvbnN0IHV0aWwgPSByZXF1aXJlKCd1dGlsJyk7XG5cbi8qKlxuICogQW4gQWdncmVnYXRpb25DdXJzb3IgaXMgYSBjb25jdXJyZW5jeSBwcmltaXRpdmUgZm9yIHByb2Nlc3NpbmcgYWdncmVnYXRpb25cbiAqIHJlc3VsdHMgb25lIGRvY3VtZW50IGF0IGEgdGltZS4gSXQgaXMgYW5hbG9nb3VzIHRvIFF1ZXJ5Q3Vyc29yLlxuICpcbiAqIEFuIEFnZ3JlZ2F0aW9uQ3Vyc29yIGZ1bGZpbGxzIHRoZSBOb2RlLmpzIHN0cmVhbXMzIEFQSSxcbiAqIGluIGFkZGl0aW9uIHRvIHNldmVyYWwgb3RoZXIgbWVjaGFuaXNtcyBmb3IgbG9hZGluZyBkb2N1bWVudHMgZnJvbSBNb25nb0RCXG4gKiBvbmUgYXQgYSB0aW1lLlxuICpcbiAqIENyZWF0aW5nIGFuIEFnZ3JlZ2F0aW9uQ3Vyc29yIGV4ZWN1dGVzIHRoZSBtb2RlbCdzIHByZSBhZ2dyZWdhdGUgaG9va3MsXG4gKiBidXQgKipub3QqKiB0aGUgbW9kZWwncyBwb3N0IGFnZ3JlZ2F0ZSBob29rcy5cbiAqXG4gKiBVbmxlc3MgeW91J3JlIGFuIGFkdmFuY2VkIHVzZXIsIGRvICoqbm90KiogaW5zdGFudGlhdGUgdGhpcyBjbGFzcyBkaXJlY3RseS5cbiAqIFVzZSBbYEFnZ3JlZ2F0ZSNjdXJzb3IoKWBdKGh0dHBzOi8vbW9uZ29vc2Vqcy5jb20vZG9jcy9hcGkvYWdncmVnYXRlLmh0bWwjQWdncmVnYXRlLnByb3RvdHlwZS5jdXJzb3IoKSkgaW5zdGVhZC5cbiAqXG4gKiBAcGFyYW0ge0FnZ3JlZ2F0ZX0gYWdnXG4gKiBAaW5oZXJpdHMgUmVhZGFibGUgaHR0cHM6Ly9ub2RlanMub3JnL2FwaS9zdHJlYW0uaHRtbCNjbGFzcy1zdHJlYW1yZWFkYWJsZVxuICogQGV2ZW50IGBjdXJzb3JgOiBFbWl0dGVkIHdoZW4gdGhlIGN1cnNvciBpcyBjcmVhdGVkXG4gKiBAZXZlbnQgYGVycm9yYDogRW1pdHRlZCB3aGVuIGFuIGVycm9yIG9jY3VycmVkXG4gKiBAZXZlbnQgYGRhdGFgOiBFbWl0dGVkIHdoZW4gdGhlIHN0cmVhbSBpcyBmbG93aW5nIGFuZCB0aGUgbmV4dCBkb2MgaXMgcmVhZHlcbiAqIEBldmVudCBgZW5kYDogRW1pdHRlZCB3aGVuIHRoZSBzdHJlYW0gaXMgZXhoYXVzdGVkXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmZ1bmN0aW9uIEFnZ3JlZ2F0aW9uQ3Vyc29yKGFnZykge1xuICAvLyBzZXQgYXV0b0Rlc3Ryb3k9dHJ1ZSBiZWNhdXNlIG9uIG5vZGUgMTIgaXQncyBieSBkZWZhdWx0IGZhbHNlXG4gIC8vIGdoLTEwOTAyIG5lZWQgYXV0b0Rlc3Ryb3kgdG8gZGVzdHJveSBjb3JyZWN0bHkgYW5kIGVtaXQgJ2Nsb3NlJyBldmVudFxuICBSZWFkYWJsZS5jYWxsKHRoaXMsIHsgYXV0b0Rlc3Ryb3k6IHRydWUsIG9iamVjdE1vZGU6IHRydWUgfSk7XG5cbiAgdGhpcy5jdXJzb3IgPSBudWxsO1xuICB0aGlzLmFnZyA9IGFnZztcbiAgdGhpcy5fdHJhbnNmb3JtcyA9IFtdO1xuICBjb25zdCBtb2RlbCA9IGFnZy5fbW9kZWw7XG4gIGRlbGV0ZSBhZ2cub3B0aW9ucy5jdXJzb3IudXNlTW9uZ29vc2VBZ2dDdXJzb3I7XG4gIHRoaXMuX21vbmdvb3NlT3B0aW9ucyA9IHt9O1xuXG4gIF9pbml0KG1vZGVsLCB0aGlzLCBhZ2cpO1xufVxuXG51dGlsLmluaGVyaXRzKEFnZ3JlZ2F0aW9uQ3Vyc29yLCBSZWFkYWJsZSk7XG5cbi8qIVxuICogaWdub3JlXG4gKi9cblxuZnVuY3Rpb24gX2luaXQobW9kZWwsIGMsIGFnZykge1xuICBpZiAoIW1vZGVsLmNvbGxlY3Rpb24uYnVmZmVyKSB7XG4gICAgbW9kZWwuaG9va3MuZXhlY1ByZSgnYWdncmVnYXRlJywgYWdnLCBmdW5jdGlvbigpIHtcbiAgICAgIGMuY3Vyc29yID0gbW9kZWwuY29sbGVjdGlvbi5hZ2dyZWdhdGUoYWdnLl9waXBlbGluZSwgYWdnLm9wdGlvbnMgfHwge30pO1xuICAgICAgYy5lbWl0KCdjdXJzb3InLCBjLmN1cnNvcik7XG4gICAgfSk7XG4gIH0gZWxzZSB7XG4gICAgbW9kZWwuY29sbGVjdGlvbi5lbWl0dGVyLm9uY2UoJ3F1ZXVlJywgZnVuY3Rpb24oKSB7XG4gICAgICBtb2RlbC5ob29rcy5leGVjUHJlKCdhZ2dyZWdhdGUnLCBhZ2csIGZ1bmN0aW9uKCkge1xuICAgICAgICBjLmN1cnNvciA9IG1vZGVsLmNvbGxlY3Rpb24uYWdncmVnYXRlKGFnZy5fcGlwZWxpbmUsIGFnZy5vcHRpb25zIHx8IHt9KTtcbiAgICAgICAgYy5lbWl0KCdjdXJzb3InLCBjLmN1cnNvcik7XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfVxufVxuXG4vKipcbiAqIE5lY2Vzc2FyeSB0byBzYXRpc2Z5IHRoZSBSZWFkYWJsZSBBUElcbiAqIEBtZXRob2QgX3JlYWRcbiAqIEBtZW1iZXJPZiBBZ2dyZWdhdGlvbkN1cnNvclxuICogQGluc3RhbmNlXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5BZ2dyZWdhdGlvbkN1cnNvci5wcm90b3R5cGUuX3JlYWQgPSBmdW5jdGlvbigpIHtcbiAgY29uc3QgX3RoaXMgPSB0aGlzO1xuICBfbmV4dCh0aGlzLCBmdW5jdGlvbihlcnJvciwgZG9jKSB7XG4gICAgaWYgKGVycm9yKSB7XG4gICAgICByZXR1cm4gX3RoaXMuZW1pdCgnZXJyb3InLCBlcnJvcik7XG4gICAgfVxuICAgIGlmICghZG9jKSB7XG4gICAgICBfdGhpcy5wdXNoKG51bGwpO1xuICAgICAgX3RoaXMuY3Vyc29yLmNsb3NlKGZ1bmN0aW9uKGVycm9yKSB7XG4gICAgICAgIGlmIChlcnJvcikge1xuICAgICAgICAgIHJldHVybiBfdGhpcy5lbWl0KCdlcnJvcicsIGVycm9yKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIF90aGlzLnB1c2goZG9jKTtcbiAgfSk7XG59O1xuXG5pZiAoU3ltYm9sLmFzeW5jSXRlcmF0b3IgIT0gbnVsbCkge1xuICBjb25zdCBtc2cgPSAnTW9uZ29vc2UgZG9lcyBub3Qgc3VwcG9ydCB1c2luZyBhc3luYyBpdGVyYXRvcnMgd2l0aCBhbiAnICtcbiAgICAnZXhpc3RpbmcgYWdncmVnYXRpb24gY3Vyc29yLiBTZWUgaHR0cHM6Ly9iaXQubHkvbW9uZ29vc2UtYXN5bmMtaXRlcmF0ZS1hZ2dyZWdhdGlvbic7XG5cbiAgQWdncmVnYXRpb25DdXJzb3IucHJvdG90eXBlW1N5bWJvbC5hc3luY0l0ZXJhdG9yXSA9IGZ1bmN0aW9uKCkge1xuICAgIHRocm93IG5ldyBNb25nb29zZUVycm9yKG1zZyk7XG4gIH07XG59XG5cbi8qKlxuICogUmVnaXN0ZXJzIGEgdHJhbnNmb3JtIGZ1bmN0aW9uIHdoaWNoIHN1YnNlcXVlbnRseSBtYXBzIGRvY3VtZW50cyByZXRyaWV2ZWRcbiAqIHZpYSB0aGUgc3RyZWFtcyBpbnRlcmZhY2Ugb3IgYC5uZXh0KClgXG4gKlxuICogIyMjIyBFeGFtcGxlOlxuICpcbiAqICAgICAvLyBNYXAgZG9jdW1lbnRzIHJldHVybmVkIGJ5IGBkYXRhYCBldmVudHNcbiAqICAgICBUaGluZy5cbiAqICAgICAgIGZpbmQoeyBuYW1lOiAvXmhlbGxvLyB9KS5cbiAqICAgICAgIGN1cnNvcigpLlxuICogICAgICAgbWFwKGZ1bmN0aW9uIChkb2MpIHtcbiAqICAgICAgICBkb2MuZm9vID0gXCJiYXJcIjtcbiAqICAgICAgICByZXR1cm4gZG9jO1xuICogICAgICAgfSlcbiAqICAgICAgIG9uKCdkYXRhJywgZnVuY3Rpb24oZG9jKSB7IGNvbnNvbGUubG9nKGRvYy5mb28pOyB9KTtcbiAqXG4gKiAgICAgLy8gT3IgbWFwIGRvY3VtZW50cyByZXR1cm5lZCBieSBgLm5leHQoKWBcbiAqICAgICBjb25zdCBjdXJzb3IgPSBUaGluZy5maW5kKHsgbmFtZTogL15oZWxsby8gfSkuXG4gKiAgICAgICBjdXJzb3IoKS5cbiAqICAgICAgIG1hcChmdW5jdGlvbiAoZG9jKSB7XG4gKiAgICAgICAgIGRvYy5mb28gPSBcImJhclwiO1xuICogICAgICAgICByZXR1cm4gZG9jO1xuICogICAgICAgfSk7XG4gKiAgICAgY3Vyc29yLm5leHQoZnVuY3Rpb24oZXJyb3IsIGRvYykge1xuICogICAgICAgY29uc29sZS5sb2coZG9jLmZvbyk7XG4gKiAgICAgfSk7XG4gKlxuICogQHBhcmFtIHtGdW5jdGlvbn0gZm5cbiAqIEByZXR1cm4ge0FnZ3JlZ2F0aW9uQ3Vyc29yfVxuICogQG1lbWJlck9mIEFnZ3JlZ2F0aW9uQ3Vyc29yXG4gKiBAYXBpIHB1YmxpY1xuICogQG1ldGhvZCBtYXBcbiAqL1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoQWdncmVnYXRpb25DdXJzb3IucHJvdG90eXBlLCAnbWFwJywge1xuICB2YWx1ZTogZnVuY3Rpb24oZm4pIHtcbiAgICB0aGlzLl90cmFuc2Zvcm1zLnB1c2goZm4pO1xuICAgIHJldHVybiB0aGlzO1xuICB9LFxuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBjb25maWd1cmFibGU6IHRydWUsXG4gIHdyaXRhYmxlOiB0cnVlXG59KTtcblxuLyoqXG4gKiBNYXJrcyB0aGlzIGN1cnNvciBhcyBlcnJvcmVkXG4gKiBAbWV0aG9kIF9tYXJrRXJyb3JcbiAqIEBpbnN0YW5jZVxuICogQG1lbWJlck9mIEFnZ3JlZ2F0aW9uQ3Vyc29yXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5BZ2dyZWdhdGlvbkN1cnNvci5wcm90b3R5cGUuX21hcmtFcnJvciA9IGZ1bmN0aW9uKGVycm9yKSB7XG4gIHRoaXMuX2Vycm9yID0gZXJyb3I7XG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBNYXJrcyB0aGlzIGN1cnNvciBhcyBjbG9zZWQuIFdpbGwgc3RvcCBzdHJlYW1pbmcgYW5kIHN1YnNlcXVlbnQgY2FsbHMgdG9cbiAqIGBuZXh0KClgIHdpbGwgZXJyb3IuXG4gKlxuICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2tcbiAqIEByZXR1cm4ge1Byb21pc2V9XG4gKiBAYXBpIHB1YmxpY1xuICogQG1ldGhvZCBjbG9zZVxuICogQGVtaXRzIGNsb3NlXG4gKiBAc2VlIEFnZ3JlZ2F0aW9uQ3Vyc29yLmNsb3NlIGh0dHBzOi8vbW9uZ29kYi5naXRodWIuaW8vbm9kZS1tb25nb2RiLW5hdGl2ZS80LjkvY2xhc3Nlcy9BZ2dyZWdhdGlvbkN1cnNvci5odG1sI2Nsb3NlXG4gKi9cblxuQWdncmVnYXRpb25DdXJzb3IucHJvdG90eXBlLmNsb3NlID0gYXN5bmMgZnVuY3Rpb24gY2xvc2UoKSB7XG4gIGlmICh0eXBlb2YgYXJndW1lbnRzWzBdID09PSAnZnVuY3Rpb24nKSB7XG4gICAgdGhyb3cgbmV3IE1vbmdvb3NlRXJyb3IoJ0FnZ3JlZ2F0aW9uQ3Vyc29yLnByb3RvdHlwZS5jbG9zZSgpIG5vIGxvbmdlciBhY2NlcHRzIGEgY2FsbGJhY2snKTtcbiAgfVxuICB0cnkge1xuICAgIGF3YWl0IHRoaXMuY3Vyc29yLmNsb3NlKCk7XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgdGhpcy5saXN0ZW5lcnMoJ2Vycm9yJykubGVuZ3RoID4gMCAmJiB0aGlzLmVtaXQoJ2Vycm9yJywgZXJyb3IpO1xuICAgIHRocm93IGVycm9yO1xuICB9XG4gIHRoaXMuZW1pdCgnY2xvc2UnKTtcbn07XG5cbi8qKlxuICogR2V0IHRoZSBuZXh0IGRvY3VtZW50IGZyb20gdGhpcyBjdXJzb3IuIFdpbGwgcmV0dXJuIGBudWxsYCB3aGVuIHRoZXJlIGFyZVxuICogbm8gZG9jdW1lbnRzIGxlZnQuXG4gKlxuICogQHJldHVybiB7UHJvbWlzZX1cbiAqIEBhcGkgcHVibGljXG4gKiBAbWV0aG9kIG5leHRcbiAqL1xuXG5BZ2dyZWdhdGlvbkN1cnNvci5wcm90b3R5cGUubmV4dCA9IGFzeW5jIGZ1bmN0aW9uIG5leHQoKSB7XG4gIGlmICh0eXBlb2YgYXJndW1lbnRzWzBdID09PSAnZnVuY3Rpb24nKSB7XG4gICAgdGhyb3cgbmV3IE1vbmdvb3NlRXJyb3IoJ0FnZ3JlZ2F0aW9uQ3Vyc29yLnByb3RvdHlwZS5uZXh0KCkgbm8gbG9uZ2VyIGFjY2VwdHMgYSBjYWxsYmFjaycpO1xuICB9XG4gIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgX25leHQodGhpcywgKGVyciwgcmVzKSA9PiB7XG4gICAgICBpZiAoZXJyICE9IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIHJlamVjdChlcnIpO1xuICAgICAgfVxuICAgICAgcmVzb2x2ZShyZXMpO1xuICAgIH0pO1xuICB9KTtcbn07XG5cbi8qKlxuICogRXhlY3V0ZSBgZm5gIGZvciBldmVyeSBkb2N1bWVudCBpbiB0aGUgY3Vyc29yLiBJZiBgZm5gIHJldHVybnMgYSBwcm9taXNlLFxuICogd2lsbCB3YWl0IGZvciB0aGUgcHJvbWlzZSB0byByZXNvbHZlIGJlZm9yZSBpdGVyYXRpbmcgb24gdG8gdGhlIG5leHQgb25lLlxuICogUmV0dXJucyBhIHByb21pc2UgdGhhdCByZXNvbHZlcyB3aGVuIGRvbmUuXG4gKlxuICogQHBhcmFtIHtGdW5jdGlvbn0gZm5cbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc11cbiAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy5wYXJhbGxlbF0gdGhlIG51bWJlciBvZiBwcm9taXNlcyB0byBleGVjdXRlIGluIHBhcmFsbGVsLiBEZWZhdWx0cyB0byAxLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gW2NhbGxiYWNrXSBleGVjdXRlZCB3aGVuIGFsbCBkb2NzIGhhdmUgYmVlbiBwcm9jZXNzZWRcbiAqIEByZXR1cm4ge1Byb21pc2V9XG4gKiBAYXBpIHB1YmxpY1xuICogQG1ldGhvZCBlYWNoQXN5bmNcbiAqL1xuXG5BZ2dyZWdhdGlvbkN1cnNvci5wcm90b3R5cGUuZWFjaEFzeW5jID0gZnVuY3Rpb24oZm4sIG9wdHMsIGNhbGxiYWNrKSB7XG4gIGNvbnN0IF90aGlzID0gdGhpcztcbiAgaWYgKHR5cGVvZiBvcHRzID09PSAnZnVuY3Rpb24nKSB7XG4gICAgY2FsbGJhY2sgPSBvcHRzO1xuICAgIG9wdHMgPSB7fTtcbiAgfVxuICBvcHRzID0gb3B0cyB8fCB7fTtcblxuICByZXR1cm4gZWFjaEFzeW5jKGZ1bmN0aW9uKGNiKSB7IHJldHVybiBfbmV4dChfdGhpcywgY2IpOyB9LCBmbiwgb3B0cywgY2FsbGJhY2spO1xufTtcblxuLyoqXG4gKiBSZXR1cm5zIGFuIGFzeW5jSXRlcmF0b3IgZm9yIHVzZSB3aXRoIFtgZm9yL2F3YWl0L29mYCBsb29wc10oaHR0cHM6Ly90aGVjb2RlYmFyYmFyaWFuLmNvbS9nZXR0aW5nLXN0YXJ0ZWQtd2l0aC1hc3luYy1pdGVyYXRvcnMtaW4tbm9kZS1qcylcbiAqIFlvdSBkbyBub3QgbmVlZCB0byBjYWxsIHRoaXMgZnVuY3Rpb24gZXhwbGljaXRseSwgdGhlIEphdmFTY3JpcHQgcnVudGltZVxuICogd2lsbCBjYWxsIGl0IGZvciB5b3UuXG4gKlxuICogIyMjIyBFeGFtcGxlOlxuICpcbiAqICAgICAvLyBBc3luYyBpdGVyYXRvciB3aXRob3V0IGV4cGxpY2l0bHkgY2FsbGluZyBgY3Vyc29yKClgLiBNb25nb29zZSBzdGlsbFxuICogICAgIC8vIGNyZWF0ZXMgYW4gQWdncmVnYXRpb25DdXJzb3IgaW5zdGFuY2UgaW50ZXJuYWxseS5cbiAqICAgICBjb25zdCBhZ2cgPSBNb2RlbC5hZ2dyZWdhdGUoW3sgJG1hdGNoOiB7IGFnZTogeyAkZ3RlOiAyNSB9IH0gfV0pO1xuICogICAgIGZvciBhd2FpdCAoY29uc3QgZG9jIG9mIGFnZykge1xuICogICAgICAgY29uc29sZS5sb2coZG9jLm5hbWUpO1xuICogICAgIH1cbiAqXG4gKiAgICAgLy8gWW91IGNhbiBhbHNvIHVzZSBhbiBBZ2dyZWdhdGlvbkN1cnNvciBpbnN0YW5jZSBmb3IgYXN5bmMgaXRlcmF0aW9uXG4gKiAgICAgY29uc3QgY3Vyc29yID0gTW9kZWwuYWdncmVnYXRlKFt7ICRtYXRjaDogeyBhZ2U6IHsgJGd0ZTogMjUgfSB9IH1dKS5jdXJzb3IoKTtcbiAqICAgICBmb3IgYXdhaXQgKGNvbnN0IGRvYyBvZiBjdXJzb3IpIHtcbiAqICAgICAgIGNvbnNvbGUubG9nKGRvYy5uYW1lKTtcbiAqICAgICB9XG4gKlxuICogTm9kZS5qcyAxMC54IHN1cHBvcnRzIGFzeW5jIGl0ZXJhdG9ycyBuYXRpdmVseSB3aXRob3V0IGFueSBmbGFncy4gWW91IGNhblxuICogZW5hYmxlIGFzeW5jIGl0ZXJhdG9ycyBpbiBOb2RlLmpzIDgueCB1c2luZyB0aGUgW2AtLWhhcm1vbnlfYXN5bmNfaXRlcmF0aW9uYCBmbGFnXShodHRwczovL2dpdGh1Yi5jb20vdGMzOS9wcm9wb3NhbC1hc3luYy1pdGVyYXRpb24vaXNzdWVzLzExNyNpc3N1ZWNvbW1lbnQtMzQ2Njk1MTg3KS5cbiAqXG4gKiAqKk5vdGU6KiogVGhpcyBmdW5jdGlvbiBpcyBub3Qgc2V0IGlmIGBTeW1ib2wuYXN5bmNJdGVyYXRvcmAgaXMgdW5kZWZpbmVkLiBJZlxuICogYFN5bWJvbC5hc3luY0l0ZXJhdG9yYCBpcyB1bmRlZmluZWQsIHRoYXQgbWVhbnMgeW91ciBOb2RlLmpzIHZlcnNpb24gZG9lcyBub3RcbiAqIHN1cHBvcnQgYXN5bmMgaXRlcmF0b3JzLlxuICpcbiAqIEBtZXRob2QgW1N5bWJvbC5hc3luY0l0ZXJhdG9yXVxuICogQG1lbWJlck9mIEFnZ3JlZ2F0aW9uQ3Vyc29yXG4gKiBAaW5zdGFuY2VcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuaWYgKFN5bWJvbC5hc3luY0l0ZXJhdG9yICE9IG51bGwpIHtcbiAgQWdncmVnYXRpb25DdXJzb3IucHJvdG90eXBlW1N5bWJvbC5hc3luY0l0ZXJhdG9yXSA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLnRyYW5zZm9ybU51bGwoKS5fdHJhbnNmb3JtRm9yQXN5bmNJdGVyYXRvcigpO1xuICB9O1xufVxuXG4vKiFcbiAqIGlnbm9yZVxuICovXG5cbkFnZ3JlZ2F0aW9uQ3Vyc29yLnByb3RvdHlwZS5fdHJhbnNmb3JtRm9yQXN5bmNJdGVyYXRvciA9IGZ1bmN0aW9uKCkge1xuICBpZiAodGhpcy5fdHJhbnNmb3Jtcy5pbmRleE9mKF90cmFuc2Zvcm1Gb3JBc3luY0l0ZXJhdG9yKSA9PT0gLTEpIHtcbiAgICB0aGlzLm1hcChfdHJhbnNmb3JtRm9yQXN5bmNJdGVyYXRvcik7XG4gIH1cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKiFcbiAqIGlnbm9yZVxuICovXG5cbkFnZ3JlZ2F0aW9uQ3Vyc29yLnByb3RvdHlwZS50cmFuc2Zvcm1OdWxsID0gZnVuY3Rpb24odmFsKSB7XG4gIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAwKSB7XG4gICAgdmFsID0gdHJ1ZTtcbiAgfVxuICB0aGlzLl9tb25nb29zZU9wdGlvbnMudHJhbnNmb3JtTnVsbCA9IHZhbDtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKiFcbiAqIGlnbm9yZVxuICovXG5cbmZ1bmN0aW9uIF90cmFuc2Zvcm1Gb3JBc3luY0l0ZXJhdG9yKGRvYykge1xuICByZXR1cm4gZG9jID09IG51bGwgPyB7IGRvbmU6IHRydWUgfSA6IHsgdmFsdWU6IGRvYywgZG9uZTogZmFsc2UgfTtcbn1cblxuLyoqXG4gKiBBZGRzIGEgW2N1cnNvciBmbGFnXShodHRwczovL21vbmdvZGIuZ2l0aHViLmlvL25vZGUtbW9uZ29kYi1uYXRpdmUvNC45L2NsYXNzZXMvQWdncmVnYXRpb25DdXJzb3IuaHRtbCNhZGRDdXJzb3JGbGFnKS5cbiAqIFVzZWZ1bCBmb3Igc2V0dGluZyB0aGUgYG5vQ3Vyc29yVGltZW91dGAgYW5kIGB0YWlsYWJsZWAgZmxhZ3MuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IGZsYWdcbiAqIEBwYXJhbSB7Qm9vbGVhbn0gdmFsdWVcbiAqIEByZXR1cm4ge0FnZ3JlZ2F0aW9uQ3Vyc29yfSB0aGlzXG4gKiBAYXBpIHB1YmxpY1xuICogQG1ldGhvZCBhZGRDdXJzb3JGbGFnXG4gKi9cblxuQWdncmVnYXRpb25DdXJzb3IucHJvdG90eXBlLmFkZEN1cnNvckZsYWcgPSBmdW5jdGlvbihmbGFnLCB2YWx1ZSkge1xuICBjb25zdCBfdGhpcyA9IHRoaXM7XG4gIF93YWl0Rm9yQ3Vyc29yKHRoaXMsIGZ1bmN0aW9uKCkge1xuICAgIF90aGlzLmN1cnNvci5hZGRDdXJzb3JGbGFnKGZsYWcsIHZhbHVlKTtcbiAgfSk7XG4gIHJldHVybiB0aGlzO1xufTtcblxuLyohXG4gKiBpZ25vcmVcbiAqL1xuXG5mdW5jdGlvbiBfd2FpdEZvckN1cnNvcihjdHgsIGNiKSB7XG4gIGlmIChjdHguY3Vyc29yKSB7XG4gICAgcmV0dXJuIGNiKCk7XG4gIH1cbiAgY3R4Lm9uY2UoJ2N1cnNvcicsIGZ1bmN0aW9uKCkge1xuICAgIGNiKCk7XG4gIH0pO1xufVxuXG4vKipcbiAqIEdldCB0aGUgbmV4dCBkb2MgZnJvbSB0aGUgdW5kZXJseWluZyBjdXJzb3IgYW5kIG1vbmdvb3NlaWZ5IGl0XG4gKiAocG9wdWxhdGUsIGV0Yy4pXG4gKiBAcGFyYW0ge0FueX0gY3R4XG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYlxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZnVuY3Rpb24gX25leHQoY3R4LCBjYikge1xuICBsZXQgY2FsbGJhY2sgPSBjYjtcbiAgaWYgKGN0eC5fdHJhbnNmb3Jtcy5sZW5ndGgpIHtcbiAgICBjYWxsYmFjayA9IGZ1bmN0aW9uKGVyciwgZG9jKSB7XG4gICAgICBpZiAoZXJyIHx8IChkb2MgPT09IG51bGwgJiYgIWN0eC5fbW9uZ29vc2VPcHRpb25zLnRyYW5zZm9ybU51bGwpKSB7XG4gICAgICAgIHJldHVybiBjYihlcnIsIGRvYyk7XG4gICAgICB9XG4gICAgICBjYihlcnIsIGN0eC5fdHJhbnNmb3Jtcy5yZWR1Y2UoZnVuY3Rpb24oZG9jLCBmbikge1xuICAgICAgICByZXR1cm4gZm4oZG9jKTtcbiAgICAgIH0sIGRvYykpO1xuICAgIH07XG4gIH1cblxuICBpZiAoY3R4Ll9lcnJvcikge1xuICAgIHJldHVybiBpbW1lZGlhdGUoZnVuY3Rpb24oKSB7XG4gICAgICBjYWxsYmFjayhjdHguX2Vycm9yKTtcbiAgICB9KTtcbiAgfVxuXG4gIGlmIChjdHguY3Vyc29yKSB7XG4gICAgcmV0dXJuIGN0eC5jdXJzb3IubmV4dCgpLnRoZW4oXG4gICAgICBkb2MgPT4ge1xuICAgICAgICBpZiAoIWRvYykge1xuICAgICAgICAgIHJldHVybiBjYWxsYmFjayhudWxsLCBudWxsKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNhbGxiYWNrKG51bGwsIGRvYyk7XG4gICAgICB9LFxuICAgICAgZXJyID0+IGNhbGxiYWNrKGVycilcbiAgICApO1xuICB9IGVsc2Uge1xuICAgIGN0eC5vbmNlKCdjdXJzb3InLCBmdW5jdGlvbigpIHtcbiAgICAgIF9uZXh0KGN0eCwgY2IpO1xuICAgIH0pO1xuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gQWdncmVnYXRpb25DdXJzb3I7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/mongoose/lib/cursor/aggregationCursor.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/mongoose/lib/cursor/changeStream.js":
/*!**********************************************************!*\
  !*** ./node_modules/mongoose/lib/cursor/changeStream.js ***!
  \**********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\n\n/*!\n * Module dependencies.\n */\n\nconst EventEmitter = (__webpack_require__(/*! events */ \"events\").EventEmitter);\n\n/*!\n * ignore\n */\n\nconst driverChangeStreamEvents = ['close', 'change', 'end', 'error', 'resumeTokenChanged'];\n\n/*!\n * ignore\n */\n\nclass ChangeStream extends EventEmitter {\n  constructor(changeStreamThunk, pipeline, options) {\n    super();\n\n    this.driverChangeStream = null;\n    this.closed = false;\n    this.bindedEvents = false;\n    this.pipeline = pipeline;\n    this.options = options;\n\n    if (options && options.hydrate && !options.model) {\n      throw new Error(\n        'Cannot create change stream with `hydrate: true` ' +\n        'unless calling `Model.watch()`'\n      );\n    }\n\n    // This wrapper is necessary because of buffering.\n    changeStreamThunk((err, driverChangeStream) => {\n      if (err != null) {\n        this.emit('error', err);\n        return;\n      }\n\n      this.driverChangeStream = driverChangeStream;\n      this.emit('ready');\n    });\n  }\n\n  _bindEvents() {\n    if (this.bindedEvents) {\n      return;\n    }\n\n    this.bindedEvents = true;\n\n    if (this.driverChangeStream == null) {\n      this.once('ready', () => {\n        this.driverChangeStream.on('close', () => {\n          this.closed = true;\n        });\n\n        driverChangeStreamEvents.forEach(ev => {\n          this.driverChangeStream.on(ev, data => {\n            // Sometimes Node driver still polls after close, so\n            // avoid any uncaught exceptions due to closed change streams\n            // See tests for gh-7022\n            if (ev === 'error' && this.closed) {\n              return;\n            }\n            if (data != null && data.fullDocument != null && this.options && this.options.hydrate) {\n              data.fullDocument = this.options.model.hydrate(data.fullDocument);\n            }\n            this.emit(ev, data);\n          });\n        });\n      });\n\n      return;\n    }\n\n    this.driverChangeStream.on('close', () => {\n      this.closed = true;\n    });\n\n    driverChangeStreamEvents.forEach(ev => {\n      this.driverChangeStream.on(ev, data => {\n        // Sometimes Node driver still polls after close, so\n        // avoid any uncaught exceptions due to closed change streams\n        // See tests for gh-7022\n        if (ev === 'error' && this.closed) {\n          return;\n        }\n        if (data != null && data.fullDocument != null && this.options && this.options.hydrate) {\n          data.fullDocument = this.options.model.hydrate(data.fullDocument);\n        }\n        this.emit(ev, data);\n      });\n    });\n  }\n\n  hasNext(cb) {\n    return this.driverChangeStream.hasNext(cb);\n  }\n\n  next(cb) {\n    if (this.options && this.options.hydrate) {\n      if (cb != null) {\n        const originalCb = cb;\n        cb = (err, data) => {\n          if (err != null) {\n            return originalCb(err);\n          }\n          if (data.fullDocument != null) {\n            data.fullDocument = this.options.model.hydrate(data.fullDocument);\n          }\n          return originalCb(null, data);\n        };\n      }\n\n      let maybePromise = this.driverChangeStream.next(cb);\n      if (maybePromise && typeof maybePromise.then === 'function') {\n        maybePromise = maybePromise.then(data => {\n          if (data.fullDocument != null) {\n            data.fullDocument = this.options.model.hydrate(data.fullDocument);\n          }\n          return data;\n        });\n      }\n      return maybePromise;\n    }\n\n    return this.driverChangeStream.next(cb);\n  }\n\n  addListener(event, handler) {\n    this._bindEvents();\n    return super.addListener(event, handler);\n  }\n\n  on(event, handler) {\n    this._bindEvents();\n    return super.on(event, handler);\n  }\n\n  once(event, handler) {\n    this._bindEvents();\n    return super.once(event, handler);\n  }\n\n  _queue(cb) {\n    this.once('ready', () => cb());\n  }\n\n  close() {\n    this.closed = true;\n    if (this.driverChangeStream) {\n      this.driverChangeStream.close();\n    }\n  }\n}\n\n/*!\n * ignore\n */\n\nmodule.exports = ChangeStream;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbW9uZ29vc2UvbGliL2N1cnNvci9jaGFuZ2VTdHJlYW0uanMiLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWI7QUFDQTtBQUNBOztBQUVBLHFCQUFxQiwwREFBOEI7O0FBRW5EO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1gsU0FBUztBQUNULE9BQU87O0FBRVA7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9hcHAxLy4vbm9kZV9tb2R1bGVzL21vbmdvb3NlL2xpYi9jdXJzb3IvY2hhbmdlU3RyZWFtLmpzPzY3YzkiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG4vKiFcbiAqIE1vZHVsZSBkZXBlbmRlbmNpZXMuXG4gKi9cblxuY29uc3QgRXZlbnRFbWl0dGVyID0gcmVxdWlyZSgnZXZlbnRzJykuRXZlbnRFbWl0dGVyO1xuXG4vKiFcbiAqIGlnbm9yZVxuICovXG5cbmNvbnN0IGRyaXZlckNoYW5nZVN0cmVhbUV2ZW50cyA9IFsnY2xvc2UnLCAnY2hhbmdlJywgJ2VuZCcsICdlcnJvcicsICdyZXN1bWVUb2tlbkNoYW5nZWQnXTtcblxuLyohXG4gKiBpZ25vcmVcbiAqL1xuXG5jbGFzcyBDaGFuZ2VTdHJlYW0gZXh0ZW5kcyBFdmVudEVtaXR0ZXIge1xuICBjb25zdHJ1Y3RvcihjaGFuZ2VTdHJlYW1UaHVuaywgcGlwZWxpbmUsIG9wdGlvbnMpIHtcbiAgICBzdXBlcigpO1xuXG4gICAgdGhpcy5kcml2ZXJDaGFuZ2VTdHJlYW0gPSBudWxsO1xuICAgIHRoaXMuY2xvc2VkID0gZmFsc2U7XG4gICAgdGhpcy5iaW5kZWRFdmVudHMgPSBmYWxzZTtcbiAgICB0aGlzLnBpcGVsaW5lID0gcGlwZWxpbmU7XG4gICAgdGhpcy5vcHRpb25zID0gb3B0aW9ucztcblxuICAgIGlmIChvcHRpb25zICYmIG9wdGlvbnMuaHlkcmF0ZSAmJiAhb3B0aW9ucy5tb2RlbCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAnQ2Fubm90IGNyZWF0ZSBjaGFuZ2Ugc3RyZWFtIHdpdGggYGh5ZHJhdGU6IHRydWVgICcgK1xuICAgICAgICAndW5sZXNzIGNhbGxpbmcgYE1vZGVsLndhdGNoKClgJ1xuICAgICAgKTtcbiAgICB9XG5cbiAgICAvLyBUaGlzIHdyYXBwZXIgaXMgbmVjZXNzYXJ5IGJlY2F1c2Ugb2YgYnVmZmVyaW5nLlxuICAgIGNoYW5nZVN0cmVhbVRodW5rKChlcnIsIGRyaXZlckNoYW5nZVN0cmVhbSkgPT4ge1xuICAgICAgaWYgKGVyciAhPSBudWxsKSB7XG4gICAgICAgIHRoaXMuZW1pdCgnZXJyb3InLCBlcnIpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHRoaXMuZHJpdmVyQ2hhbmdlU3RyZWFtID0gZHJpdmVyQ2hhbmdlU3RyZWFtO1xuICAgICAgdGhpcy5lbWl0KCdyZWFkeScpO1xuICAgIH0pO1xuICB9XG5cbiAgX2JpbmRFdmVudHMoKSB7XG4gICAgaWYgKHRoaXMuYmluZGVkRXZlbnRzKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdGhpcy5iaW5kZWRFdmVudHMgPSB0cnVlO1xuXG4gICAgaWYgKHRoaXMuZHJpdmVyQ2hhbmdlU3RyZWFtID09IG51bGwpIHtcbiAgICAgIHRoaXMub25jZSgncmVhZHknLCAoKSA9PiB7XG4gICAgICAgIHRoaXMuZHJpdmVyQ2hhbmdlU3RyZWFtLm9uKCdjbG9zZScsICgpID0+IHtcbiAgICAgICAgICB0aGlzLmNsb3NlZCA9IHRydWU7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGRyaXZlckNoYW5nZVN0cmVhbUV2ZW50cy5mb3JFYWNoKGV2ID0+IHtcbiAgICAgICAgICB0aGlzLmRyaXZlckNoYW5nZVN0cmVhbS5vbihldiwgZGF0YSA9PiB7XG4gICAgICAgICAgICAvLyBTb21ldGltZXMgTm9kZSBkcml2ZXIgc3RpbGwgcG9sbHMgYWZ0ZXIgY2xvc2UsIHNvXG4gICAgICAgICAgICAvLyBhdm9pZCBhbnkgdW5jYXVnaHQgZXhjZXB0aW9ucyBkdWUgdG8gY2xvc2VkIGNoYW5nZSBzdHJlYW1zXG4gICAgICAgICAgICAvLyBTZWUgdGVzdHMgZm9yIGdoLTcwMjJcbiAgICAgICAgICAgIGlmIChldiA9PT0gJ2Vycm9yJyAmJiB0aGlzLmNsb3NlZCkge1xuICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZGF0YSAhPSBudWxsICYmIGRhdGEuZnVsbERvY3VtZW50ICE9IG51bGwgJiYgdGhpcy5vcHRpb25zICYmIHRoaXMub3B0aW9ucy5oeWRyYXRlKSB7XG4gICAgICAgICAgICAgIGRhdGEuZnVsbERvY3VtZW50ID0gdGhpcy5vcHRpb25zLm1vZGVsLmh5ZHJhdGUoZGF0YS5mdWxsRG9jdW1lbnQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5lbWl0KGV2LCBkYXRhKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgICB9KTtcblxuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHRoaXMuZHJpdmVyQ2hhbmdlU3RyZWFtLm9uKCdjbG9zZScsICgpID0+IHtcbiAgICAgIHRoaXMuY2xvc2VkID0gdHJ1ZTtcbiAgICB9KTtcblxuICAgIGRyaXZlckNoYW5nZVN0cmVhbUV2ZW50cy5mb3JFYWNoKGV2ID0+IHtcbiAgICAgIHRoaXMuZHJpdmVyQ2hhbmdlU3RyZWFtLm9uKGV2LCBkYXRhID0+IHtcbiAgICAgICAgLy8gU29tZXRpbWVzIE5vZGUgZHJpdmVyIHN0aWxsIHBvbGxzIGFmdGVyIGNsb3NlLCBzb1xuICAgICAgICAvLyBhdm9pZCBhbnkgdW5jYXVnaHQgZXhjZXB0aW9ucyBkdWUgdG8gY2xvc2VkIGNoYW5nZSBzdHJlYW1zXG4gICAgICAgIC8vIFNlZSB0ZXN0cyBmb3IgZ2gtNzAyMlxuICAgICAgICBpZiAoZXYgPT09ICdlcnJvcicgJiYgdGhpcy5jbG9zZWQpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGRhdGEgIT0gbnVsbCAmJiBkYXRhLmZ1bGxEb2N1bWVudCAhPSBudWxsICYmIHRoaXMub3B0aW9ucyAmJiB0aGlzLm9wdGlvbnMuaHlkcmF0ZSkge1xuICAgICAgICAgIGRhdGEuZnVsbERvY3VtZW50ID0gdGhpcy5vcHRpb25zLm1vZGVsLmh5ZHJhdGUoZGF0YS5mdWxsRG9jdW1lbnQpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuZW1pdChldiwgZGF0YSk7XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfVxuXG4gIGhhc05leHQoY2IpIHtcbiAgICByZXR1cm4gdGhpcy5kcml2ZXJDaGFuZ2VTdHJlYW0uaGFzTmV4dChjYik7XG4gIH1cblxuICBuZXh0KGNiKSB7XG4gICAgaWYgKHRoaXMub3B0aW9ucyAmJiB0aGlzLm9wdGlvbnMuaHlkcmF0ZSkge1xuICAgICAgaWYgKGNiICE9IG51bGwpIHtcbiAgICAgICAgY29uc3Qgb3JpZ2luYWxDYiA9IGNiO1xuICAgICAgICBjYiA9IChlcnIsIGRhdGEpID0+IHtcbiAgICAgICAgICBpZiAoZXJyICE9IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiBvcmlnaW5hbENiKGVycik7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChkYXRhLmZ1bGxEb2N1bWVudCAhPSBudWxsKSB7XG4gICAgICAgICAgICBkYXRhLmZ1bGxEb2N1bWVudCA9IHRoaXMub3B0aW9ucy5tb2RlbC5oeWRyYXRlKGRhdGEuZnVsbERvY3VtZW50KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIG9yaWdpbmFsQ2IobnVsbCwgZGF0YSk7XG4gICAgICAgIH07XG4gICAgICB9XG5cbiAgICAgIGxldCBtYXliZVByb21pc2UgPSB0aGlzLmRyaXZlckNoYW5nZVN0cmVhbS5uZXh0KGNiKTtcbiAgICAgIGlmIChtYXliZVByb21pc2UgJiYgdHlwZW9mIG1heWJlUHJvbWlzZS50aGVuID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIG1heWJlUHJvbWlzZSA9IG1heWJlUHJvbWlzZS50aGVuKGRhdGEgPT4ge1xuICAgICAgICAgIGlmIChkYXRhLmZ1bGxEb2N1bWVudCAhPSBudWxsKSB7XG4gICAgICAgICAgICBkYXRhLmZ1bGxEb2N1bWVudCA9IHRoaXMub3B0aW9ucy5tb2RlbC5oeWRyYXRlKGRhdGEuZnVsbERvY3VtZW50KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIGRhdGE7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG1heWJlUHJvbWlzZTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5kcml2ZXJDaGFuZ2VTdHJlYW0ubmV4dChjYik7XG4gIH1cblxuICBhZGRMaXN0ZW5lcihldmVudCwgaGFuZGxlcikge1xuICAgIHRoaXMuX2JpbmRFdmVudHMoKTtcbiAgICByZXR1cm4gc3VwZXIuYWRkTGlzdGVuZXIoZXZlbnQsIGhhbmRsZXIpO1xuICB9XG5cbiAgb24oZXZlbnQsIGhhbmRsZXIpIHtcbiAgICB0aGlzLl9iaW5kRXZlbnRzKCk7XG4gICAgcmV0dXJuIHN1cGVyLm9uKGV2ZW50LCBoYW5kbGVyKTtcbiAgfVxuXG4gIG9uY2UoZXZlbnQsIGhhbmRsZXIpIHtcbiAgICB0aGlzLl9iaW5kRXZlbnRzKCk7XG4gICAgcmV0dXJuIHN1cGVyLm9uY2UoZXZlbnQsIGhhbmRsZXIpO1xuICB9XG5cbiAgX3F1ZXVlKGNiKSB7XG4gICAgdGhpcy5vbmNlKCdyZWFkeScsICgpID0+IGNiKCkpO1xuICB9XG5cbiAgY2xvc2UoKSB7XG4gICAgdGhpcy5jbG9zZWQgPSB0cnVlO1xuICAgIGlmICh0aGlzLmRyaXZlckNoYW5nZVN0cmVhbSkge1xuICAgICAgdGhpcy5kcml2ZXJDaGFuZ2VTdHJlYW0uY2xvc2UoKTtcbiAgICB9XG4gIH1cbn1cblxuLyohXG4gKiBpZ25vcmVcbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IENoYW5nZVN0cmVhbTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/mongoose/lib/cursor/changeStream.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/mongoose/lib/cursor/queryCursor.js":
/*!*********************************************************!*\
  !*** ./node_modules/mongoose/lib/cursor/queryCursor.js ***!
  \*********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("/*!\n * Module dependencies.\n */\n\n\n\nconst MongooseError = __webpack_require__(/*! ../error/mongooseError */ \"(ssr)/./node_modules/mongoose/lib/error/mongooseError.js\");\nconst Readable = (__webpack_require__(/*! stream */ \"stream\").Readable);\nconst eachAsync = __webpack_require__(/*! ../helpers/cursor/eachAsync */ \"(ssr)/./node_modules/mongoose/lib/helpers/cursor/eachAsync.js\");\nconst helpers = __webpack_require__(/*! ../queryHelpers */ \"(ssr)/./node_modules/mongoose/lib/queryHelpers.js\");\nconst kareem = __webpack_require__(/*! kareem */ \"(ssr)/./node_modules/kareem/index.js\");\nconst immediate = __webpack_require__(/*! ../helpers/immediate */ \"(ssr)/./node_modules/mongoose/lib/helpers/immediate.js\");\nconst util = __webpack_require__(/*! util */ \"util\");\n\n/**\n * A QueryCursor is a concurrency primitive for processing query results\n * one document at a time. A QueryCursor fulfills the Node.js streams3 API,\n * in addition to several other mechanisms for loading documents from MongoDB\n * one at a time.\n *\n * QueryCursors execute the model's pre `find` hooks before loading any documents\n * from MongoDB, and the model's post `find` hooks after loading each document.\n *\n * Unless you're an advanced user, do **not** instantiate this class directly.\n * Use [`Query#cursor()`](https://mongoosejs.com/docs/api/query.html#Query.prototype.cursor()) instead.\n *\n * @param {Query} query\n * @param {Object} options query options passed to `.find()`\n * @inherits Readable https://nodejs.org/api/stream.html#class-streamreadable\n * @event `cursor`: Emitted when the cursor is created\n * @event `error`: Emitted when an error occurred\n * @event `data`: Emitted when the stream is flowing and the next doc is ready\n * @event `end`: Emitted when the stream is exhausted\n * @api public\n */\n\nfunction QueryCursor(query) {\n  // set autoDestroy=true because on node 12 it's by default false\n  // gh-10902 need autoDestroy to destroy correctly and emit 'close' event\n  Readable.call(this, { autoDestroy: true, objectMode: true });\n\n  this.cursor = null;\n  this.skipped = false;\n  this.query = query;\n  const model = query.model;\n  this._mongooseOptions = {};\n  this._transforms = [];\n  this.model = model;\n  this.options = {};\n  model.hooks.execPre('find', query, (err) => {\n    if (err != null) {\n      if (err instanceof kareem.skipWrappedFunction) {\n        const resultValue = err.args[0];\n        if (resultValue != null && (!Array.isArray(resultValue) || resultValue.length)) {\n          const err = new MongooseError(\n            'Cannot `skipMiddlewareFunction()` with a value when using ' +\n            '`.find().cursor()`, value must be nullish or empty array, got \"' +\n            util.inspect(resultValue) +\n            '\".'\n          );\n          this._markError(err);\n          this.listeners('error').length > 0 && this.emit('error', err);\n          return;\n        }\n        this.skipped = true;\n        this.emit('cursor', null);\n        return;\n      }\n      this._markError(err);\n      this.listeners('error').length > 0 && this.emit('error', err);\n      return;\n    }\n    Object.assign(this.options, query._optionsForExec());\n    this._transforms = this._transforms.concat(query._transforms.slice());\n    if (this.options.transform) {\n      this._transforms.push(this.options.transform);\n    }\n    // Re: gh-8039, you need to set the `cursor.batchSize` option, top-level\n    // `batchSize` option doesn't work.\n    if (this.options.batchSize) {\n      // Max out the number of documents we'll populate in parallel at 5000.\n      this.options._populateBatchSize = Math.min(this.options.batchSize, 5000);\n    }\n\n    if (model.collection._shouldBufferCommands() && model.collection.buffer) {\n      model.collection.queue.push([\n        () => _getRawCursor(query, this)\n      ]);\n    } else {\n      _getRawCursor(query, this);\n    }\n  });\n}\n\nutil.inherits(QueryCursor, Readable);\n\n/*!\n * ignore\n */\n\nfunction _getRawCursor(query, queryCursor) {\n  try {\n    const cursor = query.model.collection.find(query._conditions, queryCursor.options);\n    queryCursor.cursor = cursor;\n    queryCursor.emit('cursor', cursor);\n  } catch (err) {\n    queryCursor._markError(err);\n    queryCursor.listeners('error').length > 0 && queryCursor.emit('error', queryCursor._error);\n  }\n}\n\n/**\n * Necessary to satisfy the Readable API\n * @method _read\n * @memberOf QueryCursor\n * @instance\n * @api private\n */\n\nQueryCursor.prototype._read = function() {\n  _next(this, (error, doc) => {\n    if (error) {\n      return this.emit('error', error);\n    }\n    if (!doc) {\n      this.push(null);\n      this.cursor.close(function(error) {\n        if (error) {\n          return this.emit('error', error);\n        }\n      });\n      return;\n    }\n    this.push(doc);\n  });\n};\n\n/**\n * Registers a transform function which subsequently maps documents retrieved\n * via the streams interface or `.next()`\n *\n * #### Example:\n *\n *     // Map documents returned by `data` events\n *     Thing.\n *       find({ name: /^hello/ }).\n *       cursor().\n *       map(function (doc) {\n *        doc.foo = \"bar\";\n *        return doc;\n *       })\n *       on('data', function(doc) { console.log(doc.foo); });\n *\n *     // Or map documents returned by `.next()`\n *     const cursor = Thing.find({ name: /^hello/ }).\n *       cursor().\n *       map(function (doc) {\n *         doc.foo = \"bar\";\n *         return doc;\n *       });\n *     cursor.next(function(error, doc) {\n *       console.log(doc.foo);\n *     });\n *\n * @param {Function} fn\n * @return {QueryCursor}\n * @memberOf QueryCursor\n * @api public\n * @method map\n */\n\nObject.defineProperty(QueryCursor.prototype, 'map', {\n  value: function(fn) {\n    this._transforms.push(fn);\n    return this;\n  },\n  enumerable: true,\n  configurable: true,\n  writable: true\n});\n\n/**\n * Marks this cursor as errored\n * @method _markError\n * @memberOf QueryCursor\n * @instance\n * @api private\n */\n\nQueryCursor.prototype._markError = function(error) {\n  this._error = error;\n  return this;\n};\n\n/**\n * Marks this cursor as closed. Will stop streaming and subsequent calls to\n * `next()` will error.\n *\n * @return {Promise}\n * @api public\n * @method close\n * @emits close\n * @see AggregationCursor.close https://mongodb.github.io/node-mongodb-native/4.9/classes/AggregationCursor.html#close\n */\n\nQueryCursor.prototype.close = async function close() {\n  if (typeof arguments[0] === 'function') {\n    throw new MongooseError('QueryCursor.prototype.close() no longer accepts a callback');\n  }\n  try {\n    await this.cursor.close();\n    this.emit('close');\n  } catch (error) {\n    this.listeners('error').length > 0 && this.emit('error', error);\n    throw error;\n  }\n};\n\n/**\n * Rewind this cursor to its uninitialized state. Any options that are present on the cursor will\n * remain in effect. Iterating this cursor will cause new queries to be sent to the server, even\n * if the resultant data has already been retrieved by this cursor.\n *\n * @return {AggregationCursor} this\n * @api public\n * @method rewind\n */\n\nQueryCursor.prototype.rewind = function() {\n  _waitForCursor(this, () => {\n    this.cursor.rewind();\n  });\n  return this;\n};\n\n/**\n * Get the next document from this cursor. Will return `null` when there are\n * no documents left.\n *\n * @return {Promise}\n * @api public\n * @method next\n */\n\nQueryCursor.prototype.next = async function next() {\n  if (arguments[0] === 'function') {\n    throw new MongooseError('QueryCursor.prototype.next() no longer accepts a callback');\n  }\n  return new Promise((resolve, reject) => {\n    _next(this, function(error, doc) {\n      if (error) {\n        return reject(error);\n      }\n      resolve(doc);\n    });\n  });\n};\n\n/**\n * Execute `fn` for every document in the cursor. If `fn` returns a promise,\n * will wait for the promise to resolve before iterating on to the next one.\n * Returns a promise that resolves when done.\n *\n * #### Example:\n *\n *     // Iterate over documents asynchronously\n *     Thing.\n *       find({ name: /^hello/ }).\n *       cursor().\n *       eachAsync(async function (doc, i) {\n *         doc.foo = doc.bar + i;\n *         await doc.save();\n *       })\n *\n * @param {Function} fn\n * @param {Object} [options]\n * @param {Number} [options.parallel] the number of promises to execute in parallel. Defaults to 1.\n * @param {Number} [options.batchSize] if set, will call `fn()` with arrays of documents with length at most `batchSize`\n * @param {Boolean} [options.continueOnError=false] if true, `eachAsync()` iterates through all docs even if `fn` throws an error. If false, `eachAsync()` throws an error immediately if the given function `fn()` throws an error.\n * @param {Function} [callback] executed when all docs have been processed\n * @return {Promise}\n * @api public\n * @method eachAsync\n */\n\nQueryCursor.prototype.eachAsync = function(fn, opts, callback) {\n  if (typeof opts === 'function') {\n    callback = opts;\n    opts = {};\n  }\n  opts = opts || {};\n\n  return eachAsync((cb) => _next(this, cb), fn, opts, callback);\n};\n\n/**\n * The `options` passed in to the `QueryCursor` constructor.\n *\n * @api public\n * @property options\n */\n\nQueryCursor.prototype.options;\n\n/**\n * Adds a [cursor flag](https://mongodb.github.io/node-mongodb-native/4.9/classes/FindCursor.html#addCursorFlag).\n * Useful for setting the `noCursorTimeout` and `tailable` flags.\n *\n * @param {String} flag\n * @param {Boolean} value\n * @return {AggregationCursor} this\n * @api public\n * @method addCursorFlag\n */\n\nQueryCursor.prototype.addCursorFlag = function(flag, value) {\n  _waitForCursor(this, () => {\n    this.cursor.addCursorFlag(flag, value);\n  });\n  return this;\n};\n\n/*!\n * ignore\n */\n\nQueryCursor.prototype.transformNull = function(val) {\n  if (arguments.length === 0) {\n    val = true;\n  }\n  this._mongooseOptions.transformNull = val;\n  return this;\n};\n\n/*!\n * ignore\n */\n\nQueryCursor.prototype._transformForAsyncIterator = function() {\n  if (this._transforms.indexOf(_transformForAsyncIterator) === -1) {\n    this.map(_transformForAsyncIterator);\n  }\n  return this;\n};\n\n/**\n * Returns an asyncIterator for use with [`for/await/of` loops](https://thecodebarbarian.com/getting-started-with-async-iterators-in-node-js).\n * You do not need to call this function explicitly, the JavaScript runtime\n * will call it for you.\n *\n * #### Example:\n *\n *     // Works without using `cursor()`\n *     for await (const doc of Model.find([{ $sort: { name: 1 } }])) {\n *       console.log(doc.name);\n *     }\n *\n *     // Can also use `cursor()`\n *     for await (const doc of Model.find([{ $sort: { name: 1 } }]).cursor()) {\n *       console.log(doc.name);\n *     }\n *\n * Node.js 10.x supports async iterators natively without any flags. You can\n * enable async iterators in Node.js 8.x using the [`--harmony_async_iteration` flag](https://github.com/tc39/proposal-async-iteration/issues/117#issuecomment-346695187).\n *\n * **Note:** This function is not if `Symbol.asyncIterator` is undefined. If\n * `Symbol.asyncIterator` is undefined, that means your Node.js version does not\n * support async iterators.\n *\n * @method [Symbol.asyncIterator]\n * @memberOf QueryCursor\n * @instance\n * @api public\n */\n\nif (Symbol.asyncIterator != null) {\n  QueryCursor.prototype[Symbol.asyncIterator] = function() {\n    return this.transformNull()._transformForAsyncIterator();\n  };\n}\n\n/*!\n * ignore\n */\n\nfunction _transformForAsyncIterator(doc) {\n  return doc == null ? { done: true } : { value: doc, done: false };\n}\n\n/**\n * Get the next doc from the underlying cursor and mongooseify it\n * (populate, etc.)\n * @param {Any} ctx\n * @param {Function} cb\n * @api private\n */\n\nfunction _next(ctx, cb) {\n  let callback = cb;\n  if (ctx._transforms.length) {\n    callback = function(err, doc) {\n      if (err || (doc === null && !ctx._mongooseOptions.transformNull)) {\n        return cb(err, doc);\n      }\n      cb(err, ctx._transforms.reduce(function(doc, fn) {\n        return fn.call(ctx, doc);\n      }, doc));\n    };\n  }\n\n  if (ctx._error) {\n    return immediate(function() {\n      callback(ctx._error);\n    });\n  }\n  if (ctx.skipped) {\n    return immediate(() => callback(null, null));\n  }\n\n  if (ctx.cursor) {\n    if (ctx.query._mongooseOptions.populate && !ctx._pop) {\n      ctx._pop = helpers.preparePopulationOptionsMQ(ctx.query,\n        ctx.query._mongooseOptions);\n      ctx._pop.__noPromise = true;\n    }\n    if (ctx.query._mongooseOptions.populate && ctx.options._populateBatchSize > 1) {\n      if (ctx._batchDocs && ctx._batchDocs.length) {\n        // Return a cached populated doc\n        return _nextDoc(ctx, ctx._batchDocs.shift(), ctx._pop, callback);\n      } else if (ctx._batchExhausted) {\n        // Internal cursor reported no more docs. Act the same here\n        return callback(null, null);\n      } else {\n        // Request as many docs as batchSize, to populate them also in batch\n        ctx._batchDocs = [];\n        ctx.cursor.next().then(\n          res => { _onNext.call({ ctx, callback }, null, res); },\n          err => { _onNext.call({ ctx, callback }, err); }\n        );\n        return;\n      }\n    } else {\n      return ctx.cursor.next().then(\n        doc => {\n          if (!doc) {\n            callback(null, null);\n            return;\n          }\n\n          if (!ctx.query._mongooseOptions.populate) {\n            return _nextDoc(ctx, doc, null, callback);\n          }\n\n          ctx.query.model.populate(doc, ctx._pop).then(\n            doc => {\n              _nextDoc(ctx, doc, ctx._pop, callback);\n            },\n            err => {\n              callback(err);\n            }\n          );\n        },\n        error => {\n          callback(error);\n        }\n      );\n    }\n  } else {\n    ctx.once('error', cb);\n\n    ctx.once('cursor', function(cursor) {\n      ctx.removeListener('error', cb);\n      if (cursor == null) {\n        if (ctx.skipped) {\n          return cb(null, null);\n        }\n        return;\n      }\n      _next(ctx, cb);\n    });\n  }\n}\n\n/*!\n * ignore\n */\n\nfunction _onNext(error, doc) {\n  if (error) {\n    return this.callback(error);\n  }\n  if (!doc) {\n    this.ctx._batchExhausted = true;\n    return _populateBatch.call(this);\n  }\n\n  this.ctx._batchDocs.push(doc);\n\n  if (this.ctx._batchDocs.length < this.ctx.options._populateBatchSize) {\n    // If both `batchSize` and `_populateBatchSize` are huge, calling `next()` repeatedly may\n    // cause a stack overflow. So make sure we clear the stack regularly.\n    if (this.ctx._batchDocs.length > 0 && this.ctx._batchDocs.length % 1000 === 0) {\n      return immediate(() => this.ctx.cursor.next().then(\n        res => { _onNext.call(this, null, res); },\n        err => { _onNext.call(this, err); }\n      ));\n    }\n    this.ctx.cursor.next().then(\n      res => { _onNext.call(this, null, res); },\n      err => { _onNext.call(this, err); }\n    );\n  } else {\n    _populateBatch.call(this);\n  }\n}\n\n/*!\n * ignore\n */\n\nfunction _populateBatch() {\n  if (!this.ctx._batchDocs.length) {\n    return this.callback(null, null);\n  }\n  this.ctx.query.model.populate(this.ctx._batchDocs, this.ctx._pop).then(\n    () => {\n      _nextDoc(this.ctx, this.ctx._batchDocs.shift(), this.ctx._pop, this.callback);\n    },\n    err => {\n      this.callback(err);\n    }\n  );\n}\n\n/*!\n * ignore\n */\n\nfunction _nextDoc(ctx, doc, pop, callback) {\n  if (ctx.query._mongooseOptions.lean) {\n    return ctx.model.hooks.execPost('find', ctx.query, [[doc]], err => {\n      if (err != null) {\n        return callback(err);\n      }\n      callback(null, doc);\n    });\n  }\n\n  const { model, _fields, _userProvidedFields, options } = ctx.query;\n  helpers.createModelAndInit(model, doc, _fields, _userProvidedFields, options, pop, (err, doc) => {\n    if (err != null) {\n      return callback(err);\n    }\n    ctx.model.hooks.execPost('find', ctx.query, [[doc]], err => {\n      if (err != null) {\n        return callback(err);\n      }\n      callback(null, doc);\n    });\n  });\n}\n\n/*!\n * ignore\n */\n\nfunction _waitForCursor(ctx, cb) {\n  if (ctx.cursor) {\n    return cb();\n  }\n  ctx.once('cursor', function(cursor) {\n    if (cursor == null) {\n      return;\n    }\n    cb();\n  });\n}\n\nmodule.exports = QueryCursor;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbW9uZ29vc2UvbGliL2N1cnNvci9xdWVyeUN1cnNvci5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7O0FBRWE7O0FBRWIsc0JBQXNCLG1CQUFPLENBQUMsd0ZBQXdCO0FBQ3RELGlCQUFpQixzREFBMEI7QUFDM0Msa0JBQWtCLG1CQUFPLENBQUMsa0dBQTZCO0FBQ3ZELGdCQUFnQixtQkFBTyxDQUFDLDBFQUFpQjtBQUN6QyxlQUFlLG1CQUFPLENBQUMsb0RBQVE7QUFDL0Isa0JBQWtCLG1CQUFPLENBQUMsb0ZBQXNCO0FBQ2hELGFBQWEsbUJBQU8sQ0FBQyxrQkFBTTs7QUFFM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsUUFBUTtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IscUNBQXFDOztBQUU3RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FB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QUFtQixlQUFlLGVBQWUsZUFBZTtBQUNoRSxtQkFBbUIsZUFBZSxlQUFlO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsZ0NBQWdDO0FBQ2pELGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQSxlQUFlLGdDQUFnQztBQUMvQyxlQUFlO0FBQ2Y7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQSxVQUFVLCtDQUErQztBQUN6RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUEiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9hcHAxLy4vbm9kZV9tb2R1bGVzL21vbmdvb3NlL2xpYi9jdXJzb3IvcXVlcnlDdXJzb3IuanM/NDg2YiJdLCJzb3VyY2VzQ29udGVudCI6WyIvKiFcbiAqIE1vZHVsZSBkZXBlbmRlbmNpZXMuXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG5jb25zdCBNb25nb29zZUVycm9yID0gcmVxdWlyZSgnLi4vZXJyb3IvbW9uZ29vc2VFcnJvcicpO1xuY29uc3QgUmVhZGFibGUgPSByZXF1aXJlKCdzdHJlYW0nKS5SZWFkYWJsZTtcbmNvbnN0IGVhY2hBc3luYyA9IHJlcXVpcmUoJy4uL2hlbHBlcnMvY3Vyc29yL2VhY2hBc3luYycpO1xuY29uc3QgaGVscGVycyA9IHJlcXVpcmUoJy4uL3F1ZXJ5SGVscGVycycpO1xuY29uc3Qga2FyZWVtID0gcmVxdWlyZSgna2FyZWVtJyk7XG5jb25zdCBpbW1lZGlhdGUgPSByZXF1aXJlKCcuLi9oZWxwZXJzL2ltbWVkaWF0ZScpO1xuY29uc3QgdXRpbCA9IHJlcXVpcmUoJ3V0aWwnKTtcblxuLyoqXG4gKiBBIFF1ZXJ5Q3Vyc29yIGlzIGEgY29uY3VycmVuY3kgcHJpbWl0aXZlIGZvciBwcm9jZXNzaW5nIHF1ZXJ5IHJlc3VsdHNcbiAqIG9uZSBkb2N1bWVudCBhdCBhIHRpbWUuIEEgUXVlcnlDdXJzb3IgZnVsZmlsbHMgdGhlIE5vZGUuanMgc3RyZWFtczMgQVBJLFxuICogaW4gYWRkaXRpb24gdG8gc2V2ZXJhbCBvdGhlciBtZWNoYW5pc21zIGZvciBsb2FkaW5nIGRvY3VtZW50cyBmcm9tIE1vbmdvREJcbiAqIG9uZSBhdCBhIHRpbWUuXG4gKlxuICogUXVlcnlDdXJzb3JzIGV4ZWN1dGUgdGhlIG1vZGVsJ3MgcHJlIGBmaW5kYCBob29rcyBiZWZvcmUgbG9hZGluZyBhbnkgZG9jdW1lbnRzXG4gKiBmcm9tIE1vbmdvREIsIGFuZCB0aGUgbW9kZWwncyBwb3N0IGBmaW5kYCBob29rcyBhZnRlciBsb2FkaW5nIGVhY2ggZG9jdW1lbnQuXG4gKlxuICogVW5sZXNzIHlvdSdyZSBhbiBhZHZhbmNlZCB1c2VyLCBkbyAqKm5vdCoqIGluc3RhbnRpYXRlIHRoaXMgY2xhc3MgZGlyZWN0bHkuXG4gKiBVc2UgW2BRdWVyeSNjdXJzb3IoKWBdKGh0dHBzOi8vbW9uZ29vc2Vqcy5jb20vZG9jcy9hcGkvcXVlcnkuaHRtbCNRdWVyeS5wcm90b3R5cGUuY3Vyc29yKCkpIGluc3RlYWQuXG4gKlxuICogQHBhcmFtIHtRdWVyeX0gcXVlcnlcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIHF1ZXJ5IG9wdGlvbnMgcGFzc2VkIHRvIGAuZmluZCgpYFxuICogQGluaGVyaXRzIFJlYWRhYmxlIGh0dHBzOi8vbm9kZWpzLm9yZy9hcGkvc3RyZWFtLmh0bWwjY2xhc3Mtc3RyZWFtcmVhZGFibGVcbiAqIEBldmVudCBgY3Vyc29yYDogRW1pdHRlZCB3aGVuIHRoZSBjdXJzb3IgaXMgY3JlYXRlZFxuICogQGV2ZW50IGBlcnJvcmA6IEVtaXR0ZWQgd2hlbiBhbiBlcnJvciBvY2N1cnJlZFxuICogQGV2ZW50IGBkYXRhYDogRW1pdHRlZCB3aGVuIHRoZSBzdHJlYW0gaXMgZmxvd2luZyBhbmQgdGhlIG5leHQgZG9jIGlzIHJlYWR5XG4gKiBAZXZlbnQgYGVuZGA6IEVtaXR0ZWQgd2hlbiB0aGUgc3RyZWFtIGlzIGV4aGF1c3RlZFxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5mdW5jdGlvbiBRdWVyeUN1cnNvcihxdWVyeSkge1xuICAvLyBzZXQgYXV0b0Rlc3Ryb3k9dHJ1ZSBiZWNhdXNlIG9uIG5vZGUgMTIgaXQncyBieSBkZWZhdWx0IGZhbHNlXG4gIC8vIGdoLTEwOTAyIG5lZWQgYXV0b0Rlc3Ryb3kgdG8gZGVzdHJveSBjb3JyZWN0bHkgYW5kIGVtaXQgJ2Nsb3NlJyBldmVudFxuICBSZWFkYWJsZS5jYWxsKHRoaXMsIHsgYXV0b0Rlc3Ryb3k6IHRydWUsIG9iamVjdE1vZGU6IHRydWUgfSk7XG5cbiAgdGhpcy5jdXJzb3IgPSBudWxsO1xuICB0aGlzLnNraXBwZWQgPSBmYWxzZTtcbiAgdGhpcy5xdWVyeSA9IHF1ZXJ5O1xuICBjb25zdCBtb2RlbCA9IHF1ZXJ5Lm1vZGVsO1xuICB0aGlzLl9tb25nb29zZU9wdGlvbnMgPSB7fTtcbiAgdGhpcy5fdHJhbnNmb3JtcyA9IFtdO1xuICB0aGlzLm1vZGVsID0gbW9kZWw7XG4gIHRoaXMub3B0aW9ucyA9IHt9O1xuICBtb2RlbC5ob29rcy5leGVjUHJlKCdmaW5kJywgcXVlcnksIChlcnIpID0+IHtcbiAgICBpZiAoZXJyICE9IG51bGwpIHtcbiAgICAgIGlmIChlcnIgaW5zdGFuY2VvZiBrYXJlZW0uc2tpcFdyYXBwZWRGdW5jdGlvbikge1xuICAgICAgICBjb25zdCByZXN1bHRWYWx1ZSA9IGVyci5hcmdzWzBdO1xuICAgICAgICBpZiAocmVzdWx0VmFsdWUgIT0gbnVsbCAmJiAoIUFycmF5LmlzQXJyYXkocmVzdWx0VmFsdWUpIHx8IHJlc3VsdFZhbHVlLmxlbmd0aCkpIHtcbiAgICAgICAgICBjb25zdCBlcnIgPSBuZXcgTW9uZ29vc2VFcnJvcihcbiAgICAgICAgICAgICdDYW5ub3QgYHNraXBNaWRkbGV3YXJlRnVuY3Rpb24oKWAgd2l0aCBhIHZhbHVlIHdoZW4gdXNpbmcgJyArXG4gICAgICAgICAgICAnYC5maW5kKCkuY3Vyc29yKClgLCB2YWx1ZSBtdXN0IGJlIG51bGxpc2ggb3IgZW1wdHkgYXJyYXksIGdvdCBcIicgK1xuICAgICAgICAgICAgdXRpbC5pbnNwZWN0KHJlc3VsdFZhbHVlKSArXG4gICAgICAgICAgICAnXCIuJ1xuICAgICAgICAgICk7XG4gICAgICAgICAgdGhpcy5fbWFya0Vycm9yKGVycik7XG4gICAgICAgICAgdGhpcy5saXN0ZW5lcnMoJ2Vycm9yJykubGVuZ3RoID4gMCAmJiB0aGlzLmVtaXQoJ2Vycm9yJywgZXJyKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5za2lwcGVkID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5lbWl0KCdjdXJzb3InLCBudWxsKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgdGhpcy5fbWFya0Vycm9yKGVycik7XG4gICAgICB0aGlzLmxpc3RlbmVycygnZXJyb3InKS5sZW5ndGggPiAwICYmIHRoaXMuZW1pdCgnZXJyb3InLCBlcnIpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBPYmplY3QuYXNzaWduKHRoaXMub3B0aW9ucywgcXVlcnkuX29wdGlvbnNGb3JFeGVjKCkpO1xuICAgIHRoaXMuX3RyYW5zZm9ybXMgPSB0aGlzLl90cmFuc2Zvcm1zLmNvbmNhdChxdWVyeS5fdHJhbnNmb3Jtcy5zbGljZSgpKTtcbiAgICBpZiAodGhpcy5vcHRpb25zLnRyYW5zZm9ybSkge1xuICAgICAgdGhpcy5fdHJhbnNmb3Jtcy5wdXNoKHRoaXMub3B0aW9ucy50cmFuc2Zvcm0pO1xuICAgIH1cbiAgICAvLyBSZTogZ2gtODAzOSwgeW91IG5lZWQgdG8gc2V0IHRoZSBgY3Vyc29yLmJhdGNoU2l6ZWAgb3B0aW9uLCB0b3AtbGV2ZWxcbiAgICAvLyBgYmF0Y2hTaXplYCBvcHRpb24gZG9lc24ndCB3b3JrLlxuICAgIGlmICh0aGlzLm9wdGlvbnMuYmF0Y2hTaXplKSB7XG4gICAgICAvLyBNYXggb3V0IHRoZSBudW1iZXIgb2YgZG9jdW1lbnRzIHdlJ2xsIHBvcHVsYXRlIGluIHBhcmFsbGVsIGF0IDUwMDAuXG4gICAgICB0aGlzLm9wdGlvbnMuX3BvcHVsYXRlQmF0Y2hTaXplID0gTWF0aC5taW4odGhpcy5vcHRpb25zLmJhdGNoU2l6ZSwgNTAwMCk7XG4gICAgfVxuXG4gICAgaWYgKG1vZGVsLmNvbGxlY3Rpb24uX3Nob3VsZEJ1ZmZlckNvbW1hbmRzKCkgJiYgbW9kZWwuY29sbGVjdGlvbi5idWZmZXIpIHtcbiAgICAgIG1vZGVsLmNvbGxlY3Rpb24ucXVldWUucHVzaChbXG4gICAgICAgICgpID0+IF9nZXRSYXdDdXJzb3IocXVlcnksIHRoaXMpXG4gICAgICBdKTtcbiAgICB9IGVsc2Uge1xuICAgICAgX2dldFJhd0N1cnNvcihxdWVyeSwgdGhpcyk7XG4gICAgfVxuICB9KTtcbn1cblxudXRpbC5pbmhlcml0cyhRdWVyeUN1cnNvciwgUmVhZGFibGUpO1xuXG4vKiFcbiAqIGlnbm9yZVxuICovXG5cbmZ1bmN0aW9uIF9nZXRSYXdDdXJzb3IocXVlcnksIHF1ZXJ5Q3Vyc29yKSB7XG4gIHRyeSB7XG4gICAgY29uc3QgY3Vyc29yID0gcXVlcnkubW9kZWwuY29sbGVjdGlvbi5maW5kKHF1ZXJ5Ll9jb25kaXRpb25zLCBxdWVyeUN1cnNvci5vcHRpb25zKTtcbiAgICBxdWVyeUN1cnNvci5jdXJzb3IgPSBjdXJzb3I7XG4gICAgcXVlcnlDdXJzb3IuZW1pdCgnY3Vyc29yJywgY3Vyc29yKTtcbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgcXVlcnlDdXJzb3IuX21hcmtFcnJvcihlcnIpO1xuICAgIHF1ZXJ5Q3Vyc29yLmxpc3RlbmVycygnZXJyb3InKS5sZW5ndGggPiAwICYmIHF1ZXJ5Q3Vyc29yLmVtaXQoJ2Vycm9yJywgcXVlcnlDdXJzb3IuX2Vycm9yKTtcbiAgfVxufVxuXG4vKipcbiAqIE5lY2Vzc2FyeSB0byBzYXRpc2Z5IHRoZSBSZWFkYWJsZSBBUElcbiAqIEBtZXRob2QgX3JlYWRcbiAqIEBtZW1iZXJPZiBRdWVyeUN1cnNvclxuICogQGluc3RhbmNlXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5RdWVyeUN1cnNvci5wcm90b3R5cGUuX3JlYWQgPSBmdW5jdGlvbigpIHtcbiAgX25leHQodGhpcywgKGVycm9yLCBkb2MpID0+IHtcbiAgICBpZiAoZXJyb3IpIHtcbiAgICAgIHJldHVybiB0aGlzLmVtaXQoJ2Vycm9yJywgZXJyb3IpO1xuICAgIH1cbiAgICBpZiAoIWRvYykge1xuICAgICAgdGhpcy5wdXNoKG51bGwpO1xuICAgICAgdGhpcy5jdXJzb3IuY2xvc2UoZnVuY3Rpb24oZXJyb3IpIHtcbiAgICAgICAgaWYgKGVycm9yKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuZW1pdCgnZXJyb3InLCBlcnJvcik7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLnB1c2goZG9jKTtcbiAgfSk7XG59O1xuXG4vKipcbiAqIFJlZ2lzdGVycyBhIHRyYW5zZm9ybSBmdW5jdGlvbiB3aGljaCBzdWJzZXF1ZW50bHkgbWFwcyBkb2N1bWVudHMgcmV0cmlldmVkXG4gKiB2aWEgdGhlIHN0cmVhbXMgaW50ZXJmYWNlIG9yIGAubmV4dCgpYFxuICpcbiAqICMjIyMgRXhhbXBsZTpcbiAqXG4gKiAgICAgLy8gTWFwIGRvY3VtZW50cyByZXR1cm5lZCBieSBgZGF0YWAgZXZlbnRzXG4gKiAgICAgVGhpbmcuXG4gKiAgICAgICBmaW5kKHsgbmFtZTogL15oZWxsby8gfSkuXG4gKiAgICAgICBjdXJzb3IoKS5cbiAqICAgICAgIG1hcChmdW5jdGlvbiAoZG9jKSB7XG4gKiAgICAgICAgZG9jLmZvbyA9IFwiYmFyXCI7XG4gKiAgICAgICAgcmV0dXJuIGRvYztcbiAqICAgICAgIH0pXG4gKiAgICAgICBvbignZGF0YScsIGZ1bmN0aW9uKGRvYykgeyBjb25zb2xlLmxvZyhkb2MuZm9vKTsgfSk7XG4gKlxuICogICAgIC8vIE9yIG1hcCBkb2N1bWVudHMgcmV0dXJuZWQgYnkgYC5uZXh0KClgXG4gKiAgICAgY29uc3QgY3Vyc29yID0gVGhpbmcuZmluZCh7IG5hbWU6IC9eaGVsbG8vIH0pLlxuICogICAgICAgY3Vyc29yKCkuXG4gKiAgICAgICBtYXAoZnVuY3Rpb24gKGRvYykge1xuICogICAgICAgICBkb2MuZm9vID0gXCJiYXJcIjtcbiAqICAgICAgICAgcmV0dXJuIGRvYztcbiAqICAgICAgIH0pO1xuICogICAgIGN1cnNvci5uZXh0KGZ1bmN0aW9uKGVycm9yLCBkb2MpIHtcbiAqICAgICAgIGNvbnNvbGUubG9nKGRvYy5mb28pO1xuICogICAgIH0pO1xuICpcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuXG4gKiBAcmV0dXJuIHtRdWVyeUN1cnNvcn1cbiAqIEBtZW1iZXJPZiBRdWVyeUN1cnNvclxuICogQGFwaSBwdWJsaWNcbiAqIEBtZXRob2QgbWFwXG4gKi9cblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KFF1ZXJ5Q3Vyc29yLnByb3RvdHlwZSwgJ21hcCcsIHtcbiAgdmFsdWU6IGZ1bmN0aW9uKGZuKSB7XG4gICAgdGhpcy5fdHJhbnNmb3Jtcy5wdXNoKGZuKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfSxcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgY29uZmlndXJhYmxlOiB0cnVlLFxuICB3cml0YWJsZTogdHJ1ZVxufSk7XG5cbi8qKlxuICogTWFya3MgdGhpcyBjdXJzb3IgYXMgZXJyb3JlZFxuICogQG1ldGhvZCBfbWFya0Vycm9yXG4gKiBAbWVtYmVyT2YgUXVlcnlDdXJzb3JcbiAqIEBpbnN0YW5jZVxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuUXVlcnlDdXJzb3IucHJvdG90eXBlLl9tYXJrRXJyb3IgPSBmdW5jdGlvbihlcnJvcikge1xuICB0aGlzLl9lcnJvciA9IGVycm9yO1xuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogTWFya3MgdGhpcyBjdXJzb3IgYXMgY2xvc2VkLiBXaWxsIHN0b3Agc3RyZWFtaW5nIGFuZCBzdWJzZXF1ZW50IGNhbGxzIHRvXG4gKiBgbmV4dCgpYCB3aWxsIGVycm9yLlxuICpcbiAqIEByZXR1cm4ge1Byb21pc2V9XG4gKiBAYXBpIHB1YmxpY1xuICogQG1ldGhvZCBjbG9zZVxuICogQGVtaXRzIGNsb3NlXG4gKiBAc2VlIEFnZ3JlZ2F0aW9uQ3Vyc29yLmNsb3NlIGh0dHBzOi8vbW9uZ29kYi5naXRodWIuaW8vbm9kZS1tb25nb2RiLW5hdGl2ZS80LjkvY2xhc3Nlcy9BZ2dyZWdhdGlvbkN1cnNvci5odG1sI2Nsb3NlXG4gKi9cblxuUXVlcnlDdXJzb3IucHJvdG90eXBlLmNsb3NlID0gYXN5bmMgZnVuY3Rpb24gY2xvc2UoKSB7XG4gIGlmICh0eXBlb2YgYXJndW1lbnRzWzBdID09PSAnZnVuY3Rpb24nKSB7XG4gICAgdGhyb3cgbmV3IE1vbmdvb3NlRXJyb3IoJ1F1ZXJ5Q3Vyc29yLnByb3RvdHlwZS5jbG9zZSgpIG5vIGxvbmdlciBhY2NlcHRzIGEgY2FsbGJhY2snKTtcbiAgfVxuICB0cnkge1xuICAgIGF3YWl0IHRoaXMuY3Vyc29yLmNsb3NlKCk7XG4gICAgdGhpcy5lbWl0KCdjbG9zZScpO1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIHRoaXMubGlzdGVuZXJzKCdlcnJvcicpLmxlbmd0aCA+IDAgJiYgdGhpcy5lbWl0KCdlcnJvcicsIGVycm9yKTtcbiAgICB0aHJvdyBlcnJvcjtcbiAgfVxufTtcblxuLyoqXG4gKiBSZXdpbmQgdGhpcyBjdXJzb3IgdG8gaXRzIHVuaW5pdGlhbGl6ZWQgc3RhdGUuIEFueSBvcHRpb25zIHRoYXQgYXJlIHByZXNlbnQgb24gdGhlIGN1cnNvciB3aWxsXG4gKiByZW1haW4gaW4gZWZmZWN0LiBJdGVyYXRpbmcgdGhpcyBjdXJzb3Igd2lsbCBjYXVzZSBuZXcgcXVlcmllcyB0byBiZSBzZW50IHRvIHRoZSBzZXJ2ZXIsIGV2ZW5cbiAqIGlmIHRoZSByZXN1bHRhbnQgZGF0YSBoYXMgYWxyZWFkeSBiZWVuIHJldHJpZXZlZCBieSB0aGlzIGN1cnNvci5cbiAqXG4gKiBAcmV0dXJuIHtBZ2dyZWdhdGlvbkN1cnNvcn0gdGhpc1xuICogQGFwaSBwdWJsaWNcbiAqIEBtZXRob2QgcmV3aW5kXG4gKi9cblxuUXVlcnlDdXJzb3IucHJvdG90eXBlLnJld2luZCA9IGZ1bmN0aW9uKCkge1xuICBfd2FpdEZvckN1cnNvcih0aGlzLCAoKSA9PiB7XG4gICAgdGhpcy5jdXJzb3IucmV3aW5kKCk7XG4gIH0pO1xuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogR2V0IHRoZSBuZXh0IGRvY3VtZW50IGZyb20gdGhpcyBjdXJzb3IuIFdpbGwgcmV0dXJuIGBudWxsYCB3aGVuIHRoZXJlIGFyZVxuICogbm8gZG9jdW1lbnRzIGxlZnQuXG4gKlxuICogQHJldHVybiB7UHJvbWlzZX1cbiAqIEBhcGkgcHVibGljXG4gKiBAbWV0aG9kIG5leHRcbiAqL1xuXG5RdWVyeUN1cnNvci5wcm90b3R5cGUubmV4dCA9IGFzeW5jIGZ1bmN0aW9uIG5leHQoKSB7XG4gIGlmIChhcmd1bWVudHNbMF0gPT09ICdmdW5jdGlvbicpIHtcbiAgICB0aHJvdyBuZXcgTW9uZ29vc2VFcnJvcignUXVlcnlDdXJzb3IucHJvdG90eXBlLm5leHQoKSBubyBsb25nZXIgYWNjZXB0cyBhIGNhbGxiYWNrJyk7XG4gIH1cbiAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICBfbmV4dCh0aGlzLCBmdW5jdGlvbihlcnJvciwgZG9jKSB7XG4gICAgICBpZiAoZXJyb3IpIHtcbiAgICAgICAgcmV0dXJuIHJlamVjdChlcnJvcik7XG4gICAgICB9XG4gICAgICByZXNvbHZlKGRvYyk7XG4gICAgfSk7XG4gIH0pO1xufTtcblxuLyoqXG4gKiBFeGVjdXRlIGBmbmAgZm9yIGV2ZXJ5IGRvY3VtZW50IGluIHRoZSBjdXJzb3IuIElmIGBmbmAgcmV0dXJucyBhIHByb21pc2UsXG4gKiB3aWxsIHdhaXQgZm9yIHRoZSBwcm9taXNlIHRvIHJlc29sdmUgYmVmb3JlIGl0ZXJhdGluZyBvbiB0byB0aGUgbmV4dCBvbmUuXG4gKiBSZXR1cm5zIGEgcHJvbWlzZSB0aGF0IHJlc29sdmVzIHdoZW4gZG9uZS5cbiAqXG4gKiAjIyMjIEV4YW1wbGU6XG4gKlxuICogICAgIC8vIEl0ZXJhdGUgb3ZlciBkb2N1bWVudHMgYXN5bmNocm9ub3VzbHlcbiAqICAgICBUaGluZy5cbiAqICAgICAgIGZpbmQoeyBuYW1lOiAvXmhlbGxvLyB9KS5cbiAqICAgICAgIGN1cnNvcigpLlxuICogICAgICAgZWFjaEFzeW5jKGFzeW5jIGZ1bmN0aW9uIChkb2MsIGkpIHtcbiAqICAgICAgICAgZG9jLmZvbyA9IGRvYy5iYXIgKyBpO1xuICogICAgICAgICBhd2FpdCBkb2Muc2F2ZSgpO1xuICogICAgICAgfSlcbiAqXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmblxuICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXVxuICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLnBhcmFsbGVsXSB0aGUgbnVtYmVyIG9mIHByb21pc2VzIHRvIGV4ZWN1dGUgaW4gcGFyYWxsZWwuIERlZmF1bHRzIHRvIDEuXG4gKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMuYmF0Y2hTaXplXSBpZiBzZXQsIHdpbGwgY2FsbCBgZm4oKWAgd2l0aCBhcnJheXMgb2YgZG9jdW1lbnRzIHdpdGggbGVuZ3RoIGF0IG1vc3QgYGJhdGNoU2l6ZWBcbiAqIEBwYXJhbSB7Qm9vbGVhbn0gW29wdGlvbnMuY29udGludWVPbkVycm9yPWZhbHNlXSBpZiB0cnVlLCBgZWFjaEFzeW5jKClgIGl0ZXJhdGVzIHRocm91Z2ggYWxsIGRvY3MgZXZlbiBpZiBgZm5gIHRocm93cyBhbiBlcnJvci4gSWYgZmFsc2UsIGBlYWNoQXN5bmMoKWAgdGhyb3dzIGFuIGVycm9yIGltbWVkaWF0ZWx5IGlmIHRoZSBnaXZlbiBmdW5jdGlvbiBgZm4oKWAgdGhyb3dzIGFuIGVycm9yLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gW2NhbGxiYWNrXSBleGVjdXRlZCB3aGVuIGFsbCBkb2NzIGhhdmUgYmVlbiBwcm9jZXNzZWRcbiAqIEByZXR1cm4ge1Byb21pc2V9XG4gKiBAYXBpIHB1YmxpY1xuICogQG1ldGhvZCBlYWNoQXN5bmNcbiAqL1xuXG5RdWVyeUN1cnNvci5wcm90b3R5cGUuZWFjaEFzeW5jID0gZnVuY3Rpb24oZm4sIG9wdHMsIGNhbGxiYWNrKSB7XG4gIGlmICh0eXBlb2Ygb3B0cyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIGNhbGxiYWNrID0gb3B0cztcbiAgICBvcHRzID0ge307XG4gIH1cbiAgb3B0cyA9IG9wdHMgfHwge307XG5cbiAgcmV0dXJuIGVhY2hBc3luYygoY2IpID0+IF9uZXh0KHRoaXMsIGNiKSwgZm4sIG9wdHMsIGNhbGxiYWNrKTtcbn07XG5cbi8qKlxuICogVGhlIGBvcHRpb25zYCBwYXNzZWQgaW4gdG8gdGhlIGBRdWVyeUN1cnNvcmAgY29uc3RydWN0b3IuXG4gKlxuICogQGFwaSBwdWJsaWNcbiAqIEBwcm9wZXJ0eSBvcHRpb25zXG4gKi9cblxuUXVlcnlDdXJzb3IucHJvdG90eXBlLm9wdGlvbnM7XG5cbi8qKlxuICogQWRkcyBhIFtjdXJzb3IgZmxhZ10oaHR0cHM6Ly9tb25nb2RiLmdpdGh1Yi5pby9ub2RlLW1vbmdvZGItbmF0aXZlLzQuOS9jbGFzc2VzL0ZpbmRDdXJzb3IuaHRtbCNhZGRDdXJzb3JGbGFnKS5cbiAqIFVzZWZ1bCBmb3Igc2V0dGluZyB0aGUgYG5vQ3Vyc29yVGltZW91dGAgYW5kIGB0YWlsYWJsZWAgZmxhZ3MuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IGZsYWdcbiAqIEBwYXJhbSB7Qm9vbGVhbn0gdmFsdWVcbiAqIEByZXR1cm4ge0FnZ3JlZ2F0aW9uQ3Vyc29yfSB0aGlzXG4gKiBAYXBpIHB1YmxpY1xuICogQG1ldGhvZCBhZGRDdXJzb3JGbGFnXG4gKi9cblxuUXVlcnlDdXJzb3IucHJvdG90eXBlLmFkZEN1cnNvckZsYWcgPSBmdW5jdGlvbihmbGFnLCB2YWx1ZSkge1xuICBfd2FpdEZvckN1cnNvcih0aGlzLCAoKSA9PiB7XG4gICAgdGhpcy5jdXJzb3IuYWRkQ3Vyc29yRmxhZyhmbGFnLCB2YWx1ZSk7XG4gIH0pO1xuICByZXR1cm4gdGhpcztcbn07XG5cbi8qIVxuICogaWdub3JlXG4gKi9cblxuUXVlcnlDdXJzb3IucHJvdG90eXBlLnRyYW5zZm9ybU51bGwgPSBmdW5jdGlvbih2YWwpIHtcbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDApIHtcbiAgICB2YWwgPSB0cnVlO1xuICB9XG4gIHRoaXMuX21vbmdvb3NlT3B0aW9ucy50cmFuc2Zvcm1OdWxsID0gdmFsO1xuICByZXR1cm4gdGhpcztcbn07XG5cbi8qIVxuICogaWdub3JlXG4gKi9cblxuUXVlcnlDdXJzb3IucHJvdG90eXBlLl90cmFuc2Zvcm1Gb3JBc3luY0l0ZXJhdG9yID0gZnVuY3Rpb24oKSB7XG4gIGlmICh0aGlzLl90cmFuc2Zvcm1zLmluZGV4T2YoX3RyYW5zZm9ybUZvckFzeW5jSXRlcmF0b3IpID09PSAtMSkge1xuICAgIHRoaXMubWFwKF90cmFuc2Zvcm1Gb3JBc3luY0l0ZXJhdG9yKTtcbiAgfVxuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogUmV0dXJucyBhbiBhc3luY0l0ZXJhdG9yIGZvciB1c2Ugd2l0aCBbYGZvci9hd2FpdC9vZmAgbG9vcHNdKGh0dHBzOi8vdGhlY29kZWJhcmJhcmlhbi5jb20vZ2V0dGluZy1zdGFydGVkLXdpdGgtYXN5bmMtaXRlcmF0b3JzLWluLW5vZGUtanMpLlxuICogWW91IGRvIG5vdCBuZWVkIHRvIGNhbGwgdGhpcyBmdW5jdGlvbiBleHBsaWNpdGx5LCB0aGUgSmF2YVNjcmlwdCBydW50aW1lXG4gKiB3aWxsIGNhbGwgaXQgZm9yIHlvdS5cbiAqXG4gKiAjIyMjIEV4YW1wbGU6XG4gKlxuICogICAgIC8vIFdvcmtzIHdpdGhvdXQgdXNpbmcgYGN1cnNvcigpYFxuICogICAgIGZvciBhd2FpdCAoY29uc3QgZG9jIG9mIE1vZGVsLmZpbmQoW3sgJHNvcnQ6IHsgbmFtZTogMSB9IH1dKSkge1xuICogICAgICAgY29uc29sZS5sb2coZG9jLm5hbWUpO1xuICogICAgIH1cbiAqXG4gKiAgICAgLy8gQ2FuIGFsc28gdXNlIGBjdXJzb3IoKWBcbiAqICAgICBmb3IgYXdhaXQgKGNvbnN0IGRvYyBvZiBNb2RlbC5maW5kKFt7ICRzb3J0OiB7IG5hbWU6IDEgfSB9XSkuY3Vyc29yKCkpIHtcbiAqICAgICAgIGNvbnNvbGUubG9nKGRvYy5uYW1lKTtcbiAqICAgICB9XG4gKlxuICogTm9kZS5qcyAxMC54IHN1cHBvcnRzIGFzeW5jIGl0ZXJhdG9ycyBuYXRpdmVseSB3aXRob3V0IGFueSBmbGFncy4gWW91IGNhblxuICogZW5hYmxlIGFzeW5jIGl0ZXJhdG9ycyBpbiBOb2RlLmpzIDgueCB1c2luZyB0aGUgW2AtLWhhcm1vbnlfYXN5bmNfaXRlcmF0aW9uYCBmbGFnXShodHRwczovL2dpdGh1Yi5jb20vdGMzOS9wcm9wb3NhbC1hc3luYy1pdGVyYXRpb24vaXNzdWVzLzExNyNpc3N1ZWNvbW1lbnQtMzQ2Njk1MTg3KS5cbiAqXG4gKiAqKk5vdGU6KiogVGhpcyBmdW5jdGlvbiBpcyBub3QgaWYgYFN5bWJvbC5hc3luY0l0ZXJhdG9yYCBpcyB1bmRlZmluZWQuIElmXG4gKiBgU3ltYm9sLmFzeW5jSXRlcmF0b3JgIGlzIHVuZGVmaW5lZCwgdGhhdCBtZWFucyB5b3VyIE5vZGUuanMgdmVyc2lvbiBkb2VzIG5vdFxuICogc3VwcG9ydCBhc3luYyBpdGVyYXRvcnMuXG4gKlxuICogQG1ldGhvZCBbU3ltYm9sLmFzeW5jSXRlcmF0b3JdXG4gKiBAbWVtYmVyT2YgUXVlcnlDdXJzb3JcbiAqIEBpbnN0YW5jZVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5pZiAoU3ltYm9sLmFzeW5jSXRlcmF0b3IgIT0gbnVsbCkge1xuICBRdWVyeUN1cnNvci5wcm90b3R5cGVbU3ltYm9sLmFzeW5jSXRlcmF0b3JdID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMudHJhbnNmb3JtTnVsbCgpLl90cmFuc2Zvcm1Gb3JBc3luY0l0ZXJhdG9yKCk7XG4gIH07XG59XG5cbi8qIVxuICogaWdub3JlXG4gKi9cblxuZnVuY3Rpb24gX3RyYW5zZm9ybUZvckFzeW5jSXRlcmF0b3IoZG9jKSB7XG4gIHJldHVybiBkb2MgPT0gbnVsbCA/IHsgZG9uZTogdHJ1ZSB9IDogeyB2YWx1ZTogZG9jLCBkb25lOiBmYWxzZSB9O1xufVxuXG4vKipcbiAqIEdldCB0aGUgbmV4dCBkb2MgZnJvbSB0aGUgdW5kZXJseWluZyBjdXJzb3IgYW5kIG1vbmdvb3NlaWZ5IGl0XG4gKiAocG9wdWxhdGUsIGV0Yy4pXG4gKiBAcGFyYW0ge0FueX0gY3R4XG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYlxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZnVuY3Rpb24gX25leHQoY3R4LCBjYikge1xuICBsZXQgY2FsbGJhY2sgPSBjYjtcbiAgaWYgKGN0eC5fdHJhbnNmb3Jtcy5sZW5ndGgpIHtcbiAgICBjYWxsYmFjayA9IGZ1bmN0aW9uKGVyciwgZG9jKSB7XG4gICAgICBpZiAoZXJyIHx8IChkb2MgPT09IG51bGwgJiYgIWN0eC5fbW9uZ29vc2VPcHRpb25zLnRyYW5zZm9ybU51bGwpKSB7XG4gICAgICAgIHJldHVybiBjYihlcnIsIGRvYyk7XG4gICAgICB9XG4gICAgICBjYihlcnIsIGN0eC5fdHJhbnNmb3Jtcy5yZWR1Y2UoZnVuY3Rpb24oZG9jLCBmbikge1xuICAgICAgICByZXR1cm4gZm4uY2FsbChjdHgsIGRvYyk7XG4gICAgICB9LCBkb2MpKTtcbiAgICB9O1xuICB9XG5cbiAgaWYgKGN0eC5fZXJyb3IpIHtcbiAgICByZXR1cm4gaW1tZWRpYXRlKGZ1bmN0aW9uKCkge1xuICAgICAgY2FsbGJhY2soY3R4Ll9lcnJvcik7XG4gICAgfSk7XG4gIH1cbiAgaWYgKGN0eC5za2lwcGVkKSB7XG4gICAgcmV0dXJuIGltbWVkaWF0ZSgoKSA9PiBjYWxsYmFjayhudWxsLCBudWxsKSk7XG4gIH1cblxuICBpZiAoY3R4LmN1cnNvcikge1xuICAgIGlmIChjdHgucXVlcnkuX21vbmdvb3NlT3B0aW9ucy5wb3B1bGF0ZSAmJiAhY3R4Ll9wb3ApIHtcbiAgICAgIGN0eC5fcG9wID0gaGVscGVycy5wcmVwYXJlUG9wdWxhdGlvbk9wdGlvbnNNUShjdHgucXVlcnksXG4gICAgICAgIGN0eC5xdWVyeS5fbW9uZ29vc2VPcHRpb25zKTtcbiAgICAgIGN0eC5fcG9wLl9fbm9Qcm9taXNlID0gdHJ1ZTtcbiAgICB9XG4gICAgaWYgKGN0eC5xdWVyeS5fbW9uZ29vc2VPcHRpb25zLnBvcHVsYXRlICYmIGN0eC5vcHRpb25zLl9wb3B1bGF0ZUJhdGNoU2l6ZSA+IDEpIHtcbiAgICAgIGlmIChjdHguX2JhdGNoRG9jcyAmJiBjdHguX2JhdGNoRG9jcy5sZW5ndGgpIHtcbiAgICAgICAgLy8gUmV0dXJuIGEgY2FjaGVkIHBvcHVsYXRlZCBkb2NcbiAgICAgICAgcmV0dXJuIF9uZXh0RG9jKGN0eCwgY3R4Ll9iYXRjaERvY3Muc2hpZnQoKSwgY3R4Ll9wb3AsIGNhbGxiYWNrKTtcbiAgICAgIH0gZWxzZSBpZiAoY3R4Ll9iYXRjaEV4aGF1c3RlZCkge1xuICAgICAgICAvLyBJbnRlcm5hbCBjdXJzb3IgcmVwb3J0ZWQgbm8gbW9yZSBkb2NzLiBBY3QgdGhlIHNhbWUgaGVyZVxuICAgICAgICByZXR1cm4gY2FsbGJhY2sobnVsbCwgbnVsbCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBSZXF1ZXN0IGFzIG1hbnkgZG9jcyBhcyBiYXRjaFNpemUsIHRvIHBvcHVsYXRlIHRoZW0gYWxzbyBpbiBiYXRjaFxuICAgICAgICBjdHguX2JhdGNoRG9jcyA9IFtdO1xuICAgICAgICBjdHguY3Vyc29yLm5leHQoKS50aGVuKFxuICAgICAgICAgIHJlcyA9PiB7IF9vbk5leHQuY2FsbCh7IGN0eCwgY2FsbGJhY2sgfSwgbnVsbCwgcmVzKTsgfSxcbiAgICAgICAgICBlcnIgPT4geyBfb25OZXh0LmNhbGwoeyBjdHgsIGNhbGxiYWNrIH0sIGVycik7IH1cbiAgICAgICAgKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gY3R4LmN1cnNvci5uZXh0KCkudGhlbihcbiAgICAgICAgZG9jID0+IHtcbiAgICAgICAgICBpZiAoIWRvYykge1xuICAgICAgICAgICAgY2FsbGJhY2sobnVsbCwgbnVsbCk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKCFjdHgucXVlcnkuX21vbmdvb3NlT3B0aW9ucy5wb3B1bGF0ZSkge1xuICAgICAgICAgICAgcmV0dXJuIF9uZXh0RG9jKGN0eCwgZG9jLCBudWxsLCBjYWxsYmFjayk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgY3R4LnF1ZXJ5Lm1vZGVsLnBvcHVsYXRlKGRvYywgY3R4Ll9wb3ApLnRoZW4oXG4gICAgICAgICAgICBkb2MgPT4ge1xuICAgICAgICAgICAgICBfbmV4dERvYyhjdHgsIGRvYywgY3R4Ll9wb3AsIGNhbGxiYWNrKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBlcnIgPT4ge1xuICAgICAgICAgICAgICBjYWxsYmFjayhlcnIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICk7XG4gICAgICAgIH0sXG4gICAgICAgIGVycm9yID0+IHtcbiAgICAgICAgICBjYWxsYmFjayhlcnJvcik7XG4gICAgICAgIH1cbiAgICAgICk7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGN0eC5vbmNlKCdlcnJvcicsIGNiKTtcblxuICAgIGN0eC5vbmNlKCdjdXJzb3InLCBmdW5jdGlvbihjdXJzb3IpIHtcbiAgICAgIGN0eC5yZW1vdmVMaXN0ZW5lcignZXJyb3InLCBjYik7XG4gICAgICBpZiAoY3Vyc29yID09IG51bGwpIHtcbiAgICAgICAgaWYgKGN0eC5za2lwcGVkKSB7XG4gICAgICAgICAgcmV0dXJuIGNiKG51bGwsIG51bGwpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIF9uZXh0KGN0eCwgY2IpO1xuICAgIH0pO1xuICB9XG59XG5cbi8qIVxuICogaWdub3JlXG4gKi9cblxuZnVuY3Rpb24gX29uTmV4dChlcnJvciwgZG9jKSB7XG4gIGlmIChlcnJvcikge1xuICAgIHJldHVybiB0aGlzLmNhbGxiYWNrKGVycm9yKTtcbiAgfVxuICBpZiAoIWRvYykge1xuICAgIHRoaXMuY3R4Ll9iYXRjaEV4aGF1c3RlZCA9IHRydWU7XG4gICAgcmV0dXJuIF9wb3B1bGF0ZUJhdGNoLmNhbGwodGhpcyk7XG4gIH1cblxuICB0aGlzLmN0eC5fYmF0Y2hEb2NzLnB1c2goZG9jKTtcblxuICBpZiAodGhpcy5jdHguX2JhdGNoRG9jcy5sZW5ndGggPCB0aGlzLmN0eC5vcHRpb25zLl9wb3B1bGF0ZUJhdGNoU2l6ZSkge1xuICAgIC8vIElmIGJvdGggYGJhdGNoU2l6ZWAgYW5kIGBfcG9wdWxhdGVCYXRjaFNpemVgIGFyZSBodWdlLCBjYWxsaW5nIGBuZXh0KClgIHJlcGVhdGVkbHkgbWF5XG4gICAgLy8gY2F1c2UgYSBzdGFjayBvdmVyZmxvdy4gU28gbWFrZSBzdXJlIHdlIGNsZWFyIHRoZSBzdGFjayByZWd1bGFybHkuXG4gICAgaWYgKHRoaXMuY3R4Ll9iYXRjaERvY3MubGVuZ3RoID4gMCAmJiB0aGlzLmN0eC5fYmF0Y2hEb2NzLmxlbmd0aCAlIDEwMDAgPT09IDApIHtcbiAgICAgIHJldHVybiBpbW1lZGlhdGUoKCkgPT4gdGhpcy5jdHguY3Vyc29yLm5leHQoKS50aGVuKFxuICAgICAgICByZXMgPT4geyBfb25OZXh0LmNhbGwodGhpcywgbnVsbCwgcmVzKTsgfSxcbiAgICAgICAgZXJyID0+IHsgX29uTmV4dC5jYWxsKHRoaXMsIGVycik7IH1cbiAgICAgICkpO1xuICAgIH1cbiAgICB0aGlzLmN0eC5jdXJzb3IubmV4dCgpLnRoZW4oXG4gICAgICByZXMgPT4geyBfb25OZXh0LmNhbGwodGhpcywgbnVsbCwgcmVzKTsgfSxcbiAgICAgIGVyciA9PiB7IF9vbk5leHQuY2FsbCh0aGlzLCBlcnIpOyB9XG4gICAgKTtcbiAgfSBlbHNlIHtcbiAgICBfcG9wdWxhdGVCYXRjaC5jYWxsKHRoaXMpO1xuICB9XG59XG5cbi8qIVxuICogaWdub3JlXG4gKi9cblxuZnVuY3Rpb24gX3BvcHVsYXRlQmF0Y2goKSB7XG4gIGlmICghdGhpcy5jdHguX2JhdGNoRG9jcy5sZW5ndGgpIHtcbiAgICByZXR1cm4gdGhpcy5jYWxsYmFjayhudWxsLCBudWxsKTtcbiAgfVxuICB0aGlzLmN0eC5xdWVyeS5tb2RlbC5wb3B1bGF0ZSh0aGlzLmN0eC5fYmF0Y2hEb2NzLCB0aGlzLmN0eC5fcG9wKS50aGVuKFxuICAgICgpID0+IHtcbiAgICAgIF9uZXh0RG9jKHRoaXMuY3R4LCB0aGlzLmN0eC5fYmF0Y2hEb2NzLnNoaWZ0KCksIHRoaXMuY3R4Ll9wb3AsIHRoaXMuY2FsbGJhY2spO1xuICAgIH0sXG4gICAgZXJyID0+IHtcbiAgICAgIHRoaXMuY2FsbGJhY2soZXJyKTtcbiAgICB9XG4gICk7XG59XG5cbi8qIVxuICogaWdub3JlXG4gKi9cblxuZnVuY3Rpb24gX25leHREb2MoY3R4LCBkb2MsIHBvcCwgY2FsbGJhY2spIHtcbiAgaWYgKGN0eC5xdWVyeS5fbW9uZ29vc2VPcHRpb25zLmxlYW4pIHtcbiAgICByZXR1cm4gY3R4Lm1vZGVsLmhvb2tzLmV4ZWNQb3N0KCdmaW5kJywgY3R4LnF1ZXJ5LCBbW2RvY11dLCBlcnIgPT4ge1xuICAgICAgaWYgKGVyciAhPSBudWxsKSB7XG4gICAgICAgIHJldHVybiBjYWxsYmFjayhlcnIpO1xuICAgICAgfVxuICAgICAgY2FsbGJhY2sobnVsbCwgZG9jKTtcbiAgICB9KTtcbiAgfVxuXG4gIGNvbnN0IHsgbW9kZWwsIF9maWVsZHMsIF91c2VyUHJvdmlkZWRGaWVsZHMsIG9wdGlvbnMgfSA9IGN0eC5xdWVyeTtcbiAgaGVscGVycy5jcmVhdGVNb2RlbEFuZEluaXQobW9kZWwsIGRvYywgX2ZpZWxkcywgX3VzZXJQcm92aWRlZEZpZWxkcywgb3B0aW9ucywgcG9wLCAoZXJyLCBkb2MpID0+IHtcbiAgICBpZiAoZXJyICE9IG51bGwpIHtcbiAgICAgIHJldHVybiBjYWxsYmFjayhlcnIpO1xuICAgIH1cbiAgICBjdHgubW9kZWwuaG9va3MuZXhlY1Bvc3QoJ2ZpbmQnLCBjdHgucXVlcnksIFtbZG9jXV0sIGVyciA9PiB7XG4gICAgICBpZiAoZXJyICE9IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIGNhbGxiYWNrKGVycik7XG4gICAgICB9XG4gICAgICBjYWxsYmFjayhudWxsLCBkb2MpO1xuICAgIH0pO1xuICB9KTtcbn1cblxuLyohXG4gKiBpZ25vcmVcbiAqL1xuXG5mdW5jdGlvbiBfd2FpdEZvckN1cnNvcihjdHgsIGNiKSB7XG4gIGlmIChjdHguY3Vyc29yKSB7XG4gICAgcmV0dXJuIGNiKCk7XG4gIH1cbiAgY3R4Lm9uY2UoJ2N1cnNvcicsIGZ1bmN0aW9uKGN1cnNvcikge1xuICAgIGlmIChjdXJzb3IgPT0gbnVsbCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjYigpO1xuICB9KTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBRdWVyeUN1cnNvcjtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/mongoose/lib/cursor/queryCursor.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/mongoose/lib/document.js":
/*!***********************************************!*\
  !*** ./node_modules/mongoose/lib/document.js ***!
  \***********************************************/
/***/ ((module, exports, __webpack_require__) => {

eval("\n\n/*!\n * Module dependencies.\n */\n\nconst EventEmitter = (__webpack_require__(/*! events */ \"events\").EventEmitter);\nconst InternalCache = __webpack_require__(/*! ./internal */ \"(ssr)/./node_modules/mongoose/lib/internal.js\");\nconst MongooseError = __webpack_require__(/*! ./error/index */ \"(ssr)/./node_modules/mongoose/lib/error/index.js\");\nconst MixedSchema = __webpack_require__(/*! ./schema/mixed */ \"(ssr)/./node_modules/mongoose/lib/schema/mixed.js\");\nconst ObjectExpectedError = __webpack_require__(/*! ./error/objectExpected */ \"(ssr)/./node_modules/mongoose/lib/error/objectExpected.js\");\nconst ObjectParameterError = __webpack_require__(/*! ./error/objectParameter */ \"(ssr)/./node_modules/mongoose/lib/error/objectParameter.js\");\nconst ParallelValidateError = __webpack_require__(/*! ./error/parallelValidate */ \"(ssr)/./node_modules/mongoose/lib/error/parallelValidate.js\");\nconst Schema = __webpack_require__(/*! ./schema */ \"(ssr)/./node_modules/mongoose/lib/schema.js\");\nconst StrictModeError = __webpack_require__(/*! ./error/strict */ \"(ssr)/./node_modules/mongoose/lib/error/strict.js\");\nconst ValidationError = __webpack_require__(/*! ./error/validation */ \"(ssr)/./node_modules/mongoose/lib/error/validation.js\");\nconst ValidatorError = __webpack_require__(/*! ./error/validator */ \"(ssr)/./node_modules/mongoose/lib/error/validator.js\");\nconst $__hasIncludedChildren = __webpack_require__(/*! ./helpers/projection/hasIncludedChildren */ \"(ssr)/./node_modules/mongoose/lib/helpers/projection/hasIncludedChildren.js\");\nconst applyDefaults = __webpack_require__(/*! ./helpers/document/applyDefaults */ \"(ssr)/./node_modules/mongoose/lib/helpers/document/applyDefaults.js\");\nconst cleanModifiedSubpaths = __webpack_require__(/*! ./helpers/document/cleanModifiedSubpaths */ \"(ssr)/./node_modules/mongoose/lib/helpers/document/cleanModifiedSubpaths.js\");\nconst clone = __webpack_require__(/*! ./helpers/clone */ \"(ssr)/./node_modules/mongoose/lib/helpers/clone.js\");\nconst compile = (__webpack_require__(/*! ./helpers/document/compile */ \"(ssr)/./node_modules/mongoose/lib/helpers/document/compile.js\").compile);\nconst defineKey = (__webpack_require__(/*! ./helpers/document/compile */ \"(ssr)/./node_modules/mongoose/lib/helpers/document/compile.js\").defineKey);\nconst flatten = (__webpack_require__(/*! ./helpers/common */ \"(ssr)/./node_modules/mongoose/lib/helpers/common.js\").flatten);\nconst get = __webpack_require__(/*! ./helpers/get */ \"(ssr)/./node_modules/mongoose/lib/helpers/get.js\");\nconst getEmbeddedDiscriminatorPath = __webpack_require__(/*! ./helpers/document/getEmbeddedDiscriminatorPath */ \"(ssr)/./node_modules/mongoose/lib/helpers/document/getEmbeddedDiscriminatorPath.js\");\nconst getKeysInSchemaOrder = __webpack_require__(/*! ./helpers/schema/getKeysInSchemaOrder */ \"(ssr)/./node_modules/mongoose/lib/helpers/schema/getKeysInSchemaOrder.js\");\nconst getSubdocumentStrictValue = __webpack_require__(/*! ./helpers/schema/getSubdocumentStrictValue */ \"(ssr)/./node_modules/mongoose/lib/helpers/schema/getSubdocumentStrictValue.js\");\nconst handleSpreadDoc = __webpack_require__(/*! ./helpers/document/handleSpreadDoc */ \"(ssr)/./node_modules/mongoose/lib/helpers/document/handleSpreadDoc.js\");\nconst immediate = __webpack_require__(/*! ./helpers/immediate */ \"(ssr)/./node_modules/mongoose/lib/helpers/immediate.js\");\nconst isDefiningProjection = __webpack_require__(/*! ./helpers/projection/isDefiningProjection */ \"(ssr)/./node_modules/mongoose/lib/helpers/projection/isDefiningProjection.js\");\nconst isExclusive = __webpack_require__(/*! ./helpers/projection/isExclusive */ \"(ssr)/./node_modules/mongoose/lib/helpers/projection/isExclusive.js\");\nconst inspect = (__webpack_require__(/*! util */ \"util\").inspect);\nconst internalToObjectOptions = (__webpack_require__(/*! ./options */ \"(ssr)/./node_modules/mongoose/lib/options.js\").internalToObjectOptions);\nconst markArraySubdocsPopulated = __webpack_require__(/*! ./helpers/populate/markArraySubdocsPopulated */ \"(ssr)/./node_modules/mongoose/lib/helpers/populate/markArraySubdocsPopulated.js\");\nconst minimize = __webpack_require__(/*! ./helpers/minimize */ \"(ssr)/./node_modules/mongoose/lib/helpers/minimize.js\");\nconst mpath = __webpack_require__(/*! mpath */ \"(ssr)/./node_modules/mpath/index.js\");\nconst queryhelpers = __webpack_require__(/*! ./queryHelpers */ \"(ssr)/./node_modules/mongoose/lib/queryHelpers.js\");\nconst utils = __webpack_require__(/*! ./utils */ \"(ssr)/./node_modules/mongoose/lib/utils.js\");\nconst isPromise = __webpack_require__(/*! ./helpers/isPromise */ \"(ssr)/./node_modules/mongoose/lib/helpers/isPromise.js\");\n\nconst deepEqual = utils.deepEqual;\nconst isMongooseObject = utils.isMongooseObject;\n\nconst arrayAtomicsBackupSymbol = (__webpack_require__(/*! ./helpers/symbols */ \"(ssr)/./node_modules/mongoose/lib/helpers/symbols.js\").arrayAtomicsBackupSymbol);\nconst arrayAtomicsSymbol = (__webpack_require__(/*! ./helpers/symbols */ \"(ssr)/./node_modules/mongoose/lib/helpers/symbols.js\").arrayAtomicsSymbol);\nconst documentArrayParent = (__webpack_require__(/*! ./helpers/symbols */ \"(ssr)/./node_modules/mongoose/lib/helpers/symbols.js\").documentArrayParent);\nconst documentIsModified = (__webpack_require__(/*! ./helpers/symbols */ \"(ssr)/./node_modules/mongoose/lib/helpers/symbols.js\").documentIsModified);\nconst documentModifiedPaths = (__webpack_require__(/*! ./helpers/symbols */ \"(ssr)/./node_modules/mongoose/lib/helpers/symbols.js\").documentModifiedPaths);\nconst documentSchemaSymbol = (__webpack_require__(/*! ./helpers/symbols */ \"(ssr)/./node_modules/mongoose/lib/helpers/symbols.js\").documentSchemaSymbol);\nconst getSymbol = (__webpack_require__(/*! ./helpers/symbols */ \"(ssr)/./node_modules/mongoose/lib/helpers/symbols.js\").getSymbol);\nconst populateModelSymbol = (__webpack_require__(/*! ./helpers/symbols */ \"(ssr)/./node_modules/mongoose/lib/helpers/symbols.js\").populateModelSymbol);\nconst scopeSymbol = (__webpack_require__(/*! ./helpers/symbols */ \"(ssr)/./node_modules/mongoose/lib/helpers/symbols.js\").scopeSymbol);\nconst schemaMixedSymbol = (__webpack_require__(/*! ./schema/symbols */ \"(ssr)/./node_modules/mongoose/lib/schema/symbols.js\").schemaMixedSymbol);\nconst parentPaths = __webpack_require__(/*! ./helpers/path/parentPaths */ \"(ssr)/./node_modules/mongoose/lib/helpers/path/parentPaths.js\");\nconst getDeepestSubdocumentForPath = __webpack_require__(/*! ./helpers/document/getDeepestSubdocumentForPath */ \"(ssr)/./node_modules/mongoose/lib/helpers/document/getDeepestSubdocumentForPath.js\");\nconst sessionNewDocuments = (__webpack_require__(/*! ./helpers/symbols */ \"(ssr)/./node_modules/mongoose/lib/helpers/symbols.js\").sessionNewDocuments);\n\nlet DocumentArray;\nlet MongooseArray;\nlet Embedded;\n\nconst specialProperties = utils.specialProperties;\n\n/**\n * The core Mongoose document constructor. You should not call this directly,\n * the Mongoose [Model constructor](./api/model.html#Model) calls this for you.\n *\n * @param {Object} obj the values to set\n * @param {Object} [fields] optional object containing the fields which were selected in the query returning this document and any populated paths data\n * @param {Object} [options] various configuration options for the document\n * @param {Boolean} [options.defaults=true] if `false`, skip applying default values to this document.\n * @inherits NodeJS EventEmitter https://nodejs.org/api/events.html#class-eventemitter\n * @event `init`: Emitted on a document after it has been retrieved from the db and fully hydrated by Mongoose.\n * @event `save`: Emitted when the document is successfully saved\n * @api private\n */\n\nfunction Document(obj, fields, skipId, options) {\n  if (typeof skipId === 'object' && skipId != null) {\n    options = skipId;\n    skipId = options.skipId;\n  }\n  options = Object.assign({}, options);\n\n  // Support `browserDocument.js` syntax\n  if (this.$__schema == null) {\n    const _schema = utils.isObject(fields) && !fields.instanceOfSchema ?\n      new Schema(fields) :\n      fields;\n    this.$__setSchema(_schema);\n    fields = skipId;\n    skipId = options;\n    options = arguments[4] || {};\n  }\n\n  this.$__ = new InternalCache();\n\n  // Avoid setting `isNew` to `true`, because it is `true` by default\n  if (options.isNew != null && options.isNew !== true) {\n    this.$isNew = options.isNew;\n  }\n\n  if (options.priorDoc != null) {\n    this.$__.priorDoc = options.priorDoc;\n  }\n\n  if (skipId) {\n    this.$__.skipId = skipId;\n  }\n\n  if (obj != null && typeof obj !== 'object') {\n    throw new ObjectParameterError(obj, 'obj', 'Document');\n  }\n\n  let defaults = true;\n  if (options.defaults !== undefined) {\n    this.$__.defaults = options.defaults;\n    defaults = options.defaults;\n  }\n\n  const schema = this.$__schema;\n\n  if (typeof fields === 'boolean' || fields === 'throw') {\n    if (fields !== true) {\n      this.$__.strictMode = fields;\n    }\n    fields = undefined;\n  } else if (schema.options.strict !== true) {\n    this.$__.strictMode = schema.options.strict;\n  }\n\n  const requiredPaths = schema.requiredPaths(true);\n  for (const path of requiredPaths) {\n    this.$__.activePaths.require(path);\n  }\n\n  let exclude = null;\n\n  // determine if this doc is a result of a query with\n  // excluded fields\n  if (utils.isPOJO(fields) && Object.keys(fields).length > 0) {\n    exclude = isExclusive(fields);\n    this.$__.selected = fields;\n    this.$__.exclude = exclude;\n  }\n\n  const hasIncludedChildren = exclude === false && fields ?\n    $__hasIncludedChildren(fields) :\n    null;\n\n  if (this._doc == null) {\n    this.$__buildDoc(obj, fields, skipId, exclude, hasIncludedChildren, false);\n\n    // By default, defaults get applied **before** setting initial values\n    // Re: gh-6155\n    if (defaults) {\n      applyDefaults(this, fields, exclude, hasIncludedChildren, true, null);\n    }\n  }\n  if (obj) {\n    // Skip set hooks\n    if (this.$__original_set) {\n      this.$__original_set(obj, undefined, true, options);\n    } else {\n      this.$set(obj, undefined, true, options);\n    }\n\n    if (obj instanceof Document) {\n      this.$isNew = obj.$isNew;\n    }\n  }\n\n  // Function defaults get applied **after** setting initial values so they\n  // see the full doc rather than an empty one, unless they opt out.\n  // Re: gh-3781, gh-6155\n  if (options.willInit && defaults) {\n    if (options.skipDefaults) {\n      this.$__.skipDefaults = options.skipDefaults;\n    }\n  } else if (defaults) {\n    applyDefaults(this, fields, exclude, hasIncludedChildren, false, options.skipDefaults);\n  }\n\n  if (!this.$__.strictMode && obj) {\n    const _this = this;\n    const keys = Object.keys(this._doc);\n\n    keys.forEach(function(key) {\n      // Avoid methods, virtuals, existing fields, and `$` keys. The latter is to avoid overwriting\n      // Mongoose internals.\n      if (!(key in schema.tree) && !(key in schema.methods) && !(key in schema.virtuals) && !key.startsWith('$')) {\n        defineKey({ prop: key, subprops: null, prototype: _this });\n      }\n    });\n  }\n\n  applyQueue(this);\n}\n\nDocument.prototype.$isMongooseDocumentPrototype = true;\n\n/**\n * Boolean flag specifying if the document is new. If you create a document\n * using `new`, this document will be considered \"new\". `$isNew` is how\n * Mongoose determines whether `save()` should use `insertOne()` to create\n * a new document or `updateOne()` to update an existing document.\n *\n * #### Example:\n *\n *     const user = new User({ name: 'John Smith' });\n *     user.$isNew; // true\n *\n *     await user.save(); // Sends an `insertOne` to MongoDB\n *\n * On the other hand, if you load an existing document from the database\n * using `findOne()` or another [query operation](https://mongoosejs.com/docs/queries.html),\n * `$isNew` will be false.\n *\n * #### Example:\n *\n *     const user = await User.findOne({ name: 'John Smith' });\n *     user.$isNew; // false\n *\n * Mongoose sets `$isNew` to `false` immediately after `save()` succeeds.\n * That means Mongoose sets `$isNew` to false **before** `post('save')` hooks run.\n * In `post('save')` hooks, `$isNew` will be `false` if `save()` succeeded.\n *\n * #### Example:\n *\n *     userSchema.post('save', function() {\n *       this.$isNew; // false\n *     });\n *     await User.create({ name: 'John Smith' });\n *\n * For subdocuments, `$isNew` is true if either the parent has `$isNew` set,\n * or if you create a new subdocument.\n *\n * #### Example:\n *\n *     // Assume `Group` has a document array `users`\n *     const group = await Group.findOne();\n *     group.users[0].$isNew; // false\n *\n *     group.users.push({ name: 'John Smith' });\n *     group.users[1].$isNew; // true\n *\n * @api public\n * @property $isNew\n * @memberOf Document\n * @instance\n */\n\nObject.defineProperty(Document.prototype, 'isNew', {\n  get: function() {\n    return this.$isNew;\n  },\n  set: function(value) {\n    this.$isNew = value;\n  }\n});\n\n/**\n * Hash containing current validation errors.\n *\n * @api public\n * @property errors\n * @memberOf Document\n * @instance\n */\n\nObject.defineProperty(Document.prototype, 'errors', {\n  get: function() {\n    return this.$errors;\n  },\n  set: function(value) {\n    this.$errors = value;\n  }\n});\n\n/*!\n * ignore\n */\n\nDocument.prototype.$isNew = true;\n\n/*!\n * Document exposes the NodeJS event emitter API, so you can use\n * `on`, `once`, etc.\n */\nutils.each(\n  ['on', 'once', 'emit', 'listeners', 'removeListener', 'setMaxListeners',\n    'removeAllListeners', 'addListener'],\n  function(emitterFn) {\n    Document.prototype[emitterFn] = function() {\n      // Delay creating emitter until necessary because emitters take up a lot of memory,\n      // especially for subdocuments.\n      if (!this.$__.emitter) {\n        if (emitterFn === 'emit') {\n          return;\n        }\n        this.$__.emitter = new EventEmitter();\n        this.$__.emitter.setMaxListeners(0);\n      }\n      return this.$__.emitter[emitterFn].apply(this.$__.emitter, arguments);\n    };\n    Document.prototype[`$${emitterFn}`] = Document.prototype[emitterFn];\n  });\n\nDocument.prototype.constructor = Document;\n\nfor (const i in EventEmitter.prototype) {\n  Document[i] = EventEmitter.prototype[i];\n}\n\n/**\n * The document's internal schema.\n *\n * @api private\n * @property schema\n * @memberOf Document\n * @instance\n */\n\nDocument.prototype.$__schema;\n\n/**\n * The document's schema.\n *\n * @api public\n * @property schema\n * @memberOf Document\n * @instance\n */\n\nDocument.prototype.schema;\n\n/**\n * Empty object that you can use for storing properties on the document. This\n * is handy for passing data to middleware without conflicting with Mongoose\n * internals.\n *\n * #### Example:\n *\n *     schema.pre('save', function() {\n *       // Mongoose will set `isNew` to `false` if `save()` succeeds\n *       this.$locals.wasNew = this.isNew;\n *     });\n *\n *     schema.post('save', function() {\n *       // Prints true if `isNew` was set before `save()`\n *       console.log(this.$locals.wasNew);\n *     });\n *\n * @api public\n * @property $locals\n * @memberOf Document\n * @instance\n */\n\nObject.defineProperty(Document.prototype, '$locals', {\n  configurable: false,\n  enumerable: false,\n  get: function() {\n    if (this.$__.locals == null) {\n      this.$__.locals = {};\n    }\n    return this.$__.locals;\n  },\n  set: function(v) {\n    this.$__.locals = v;\n  }\n});\n\n/**\n * Legacy alias for `$isNew`.\n *\n * @api public\n * @property isNew\n * @memberOf Document\n * @see $isNew https://mongoosejs.com/docs/api/document.html#Document.prototype.$isNew\n * @instance\n */\n\nDocument.prototype.isNew;\n\n/**\n * Set this property to add additional query filters when Mongoose saves this document and `isNew` is false.\n *\n * #### Example:\n *\n *     // Make sure `save()` never updates a soft deleted document.\n *     schema.pre('save', function() {\n *       this.$where = { isDeleted: false };\n *     });\n *\n * @api public\n * @property $where\n * @memberOf Document\n * @instance\n */\n\nObject.defineProperty(Document.prototype, '$where', {\n  configurable: false,\n  enumerable: false,\n  writable: true\n});\n\n/**\n * The string version of this documents _id.\n *\n * #### Note:\n *\n * This getter exists on all documents by default. The getter can be disabled by setting the `id` [option](https://mongoosejs.com/docs/guide.html#id) of its `Schema` to false at construction time.\n *\n *     new Schema({ name: String }, { id: false });\n *\n * @api public\n * @see Schema options https://mongoosejs.com/docs/guide.html#options\n * @property id\n * @memberOf Document\n * @instance\n */\n\nDocument.prototype.id;\n\n/**\n * Hash containing current validation $errors.\n *\n * @api public\n * @property $errors\n * @memberOf Document\n * @instance\n */\n\nDocument.prototype.$errors;\n\n/**\n * A string containing the current operation that Mongoose is executing\n * on this document. May be `null`, `'save'`, `'validate'`, or `'remove'`.\n *\n * #### Example:\n *\n *     const doc = new Model({ name: 'test' });\n *     doc.$op; // null\n *\n *     const promise = doc.save();\n *     doc.$op; // 'save'\n *\n *     await promise;\n *     doc.$op; // null\n *\n * @api public\n * @property $op\n * @memberOf Document\n * @instance\n */\n\nObject.defineProperty(Document.prototype, '$op', {\n  get: function() {\n    return this.$__.op || null;\n  },\n  set: function(value) {\n    this.$__.op = value;\n  }\n});\n\n/*!\n * ignore\n */\n\nfunction $applyDefaultsToNested(val, path, doc) {\n  if (val == null) {\n    return;\n  }\n\n  const paths = Object.keys(doc.$__schema.paths);\n  const plen = paths.length;\n\n  const pathPieces = path.indexOf('.') === -1 ? [path] : path.split('.');\n\n  for (let i = 0; i < plen; ++i) {\n    let curPath = '';\n    const p = paths[i];\n\n    if (!p.startsWith(path + '.')) {\n      continue;\n    }\n\n    const type = doc.$__schema.paths[p];\n    const pieces = type.splitPath().slice(pathPieces.length);\n    const len = pieces.length;\n\n    if (type.defaultValue === void 0) {\n      continue;\n    }\n\n    let cur = val;\n\n    for (let j = 0; j < len; ++j) {\n      if (cur == null) {\n        break;\n      }\n\n      const piece = pieces[j];\n\n      if (j === len - 1) {\n        if (cur[piece] !== void 0) {\n          break;\n        }\n\n        try {\n          const def = type.getDefault(doc, false);\n          if (def !== void 0) {\n            cur[piece] = def;\n          }\n        } catch (err) {\n          doc.invalidate(path + '.' + curPath, err);\n          break;\n        }\n\n        break;\n      }\n\n      curPath += (!curPath.length ? '' : '.') + piece;\n\n      cur[piece] = cur[piece] || {};\n      cur = cur[piece];\n    }\n  }\n}\n\n/**\n * Builds the default doc structure\n *\n * @param {Object} obj\n * @param {Object} [fields]\n * @param {Boolean} [skipId]\n * @param {Boolean} [exclude]\n * @param {Object} [hasIncludedChildren]\n * @api private\n * @method $__buildDoc\n * @memberOf Document\n * @instance\n */\n\nDocument.prototype.$__buildDoc = function(obj, fields, skipId, exclude, hasIncludedChildren) {\n  const doc = {};\n\n  const paths = Object.keys(this.$__schema.paths).\n    // Don't build up any paths that are underneath a map, we don't know\n    // what the keys will be\n    filter(p => !p.includes('$*'));\n  const plen = paths.length;\n  let ii = 0;\n\n  for (; ii < plen; ++ii) {\n    const p = paths[ii];\n\n    if (p === '_id') {\n      if (skipId) {\n        continue;\n      }\n      if (obj && '_id' in obj) {\n        continue;\n      }\n    }\n\n    const path = this.$__schema.paths[p].splitPath();\n    const len = path.length;\n    const last = len - 1;\n    let curPath = '';\n    let doc_ = doc;\n    let included = false;\n\n    for (let i = 0; i < len; ++i) {\n      const piece = path[i];\n\n      if (!curPath.length) {\n        curPath = piece;\n      } else {\n        curPath += '.' + piece;\n      }\n\n      // support excluding intermediary levels\n      if (exclude === true) {\n        if (curPath in fields) {\n          break;\n        }\n      } else if (exclude === false && fields && !included) {\n        if (curPath in fields) {\n          included = true;\n        } else if (!hasIncludedChildren[curPath]) {\n          break;\n        }\n      }\n\n      if (i < last) {\n        doc_ = doc_[piece] || (doc_[piece] = {});\n      }\n    }\n  }\n\n  this._doc = doc;\n};\n\n/*!\n * Converts to POJO when you use the document for querying\n */\n\nDocument.prototype.toBSON = function() {\n  return this.toObject(internalToObjectOptions);\n};\n\n/**\n * Initializes the document without setters or marking anything modified.\n *\n * Called internally after a document is returned from mongodb. Normally,\n * you do **not** need to call this function on your own.\n *\n * This function triggers `init` [middleware](https://mongoosejs.com/docs/middleware.html).\n * Note that `init` hooks are [synchronous](https://mongoosejs.com/docs/middleware.html#synchronous).\n *\n * @param {Object} doc document returned by mongo\n * @param {Object} [opts]\n * @param {Function} [fn]\n * @api public\n * @memberOf Document\n * @instance\n */\n\nDocument.prototype.init = function(doc, opts, fn) {\n  if (typeof opts === 'function') {\n    fn = opts;\n    opts = null;\n  }\n\n  this.$__init(doc, opts);\n\n  if (fn) {\n    fn(null, this);\n  }\n\n  return this;\n};\n\n/**\n * Alias for [`.init`](https://mongoosejs.com/docs/api/document.html#Document.prototype.init())\n *\n * @api public\n */\n\nDocument.prototype.$init = function() {\n  return this.constructor.prototype.init.apply(this, arguments);\n};\n\n/**\n * Internal \"init\" function\n *\n * @param {Document} doc\n * @param {Object} [opts]\n * @returns {Document} this\n * @api private\n */\n\nDocument.prototype.$__init = function(doc, opts) {\n  this.$isNew = false;\n  opts = opts || {};\n\n  // handle docs with populated paths\n  // If doc._id is not null or undefined\n  if (doc._id != null && opts.populated && opts.populated.length) {\n    const id = String(doc._id);\n    for (const item of opts.populated) {\n      if (item.isVirtual) {\n        this.$populated(item.path, utils.getValue(item.path, doc), item);\n      } else {\n        this.$populated(item.path, item._docs[id], item);\n      }\n\n      if (item._childDocs == null) {\n        continue;\n      }\n      for (const child of item._childDocs) {\n        if (child == null || child.$__ == null) {\n          continue;\n        }\n        child.$__.parent = this;\n      }\n      item._childDocs = [];\n    }\n  }\n\n  init(this, doc, this._doc, opts);\n\n  markArraySubdocsPopulated(this, opts.populated);\n\n  this.$emit('init', this);\n  this.constructor.emit('init', this);\n\n  const hasIncludedChildren = this.$__.exclude === false && this.$__.selected ?\n    $__hasIncludedChildren(this.$__.selected) :\n    null;\n\n  applyDefaults(this, this.$__.selected, this.$__.exclude, hasIncludedChildren, false, this.$__.skipDefaults);\n\n  return this;\n};\n\n/**\n * Init helper.\n *\n * @param {Object} self document instance\n * @param {Object} obj raw mongodb doc\n * @param {Object} doc object we are initializing\n * @param {Object} [opts] Optional Options\n * @param {Boolean} [opts.setters] Call `applySetters` instead of `cast`\n * @param {String} [prefix] Prefix to add to each path\n * @api private\n */\n\nfunction init(self, obj, doc, opts, prefix) {\n  prefix = prefix || '';\n\n  if (obj.$__ != null) {\n    obj = obj._doc;\n  }\n  const keys = Object.keys(obj);\n  const len = keys.length;\n  let schemaType;\n  let path;\n  let i;\n  let index = 0;\n  const strict = self.$__.strictMode;\n  const docSchema = self.$__schema;\n\n  while (index < len) {\n    _init(index++);\n  }\n\n  function _init(index) {\n    i = keys[index];\n    // avoid prototype pollution\n    if (i === '__proto__' || i === 'constructor') {\n      return;\n    }\n    path = prefix + i;\n    schemaType = docSchema.path(path);\n\n    // Should still work if not a model-level discriminator, but should not be\n    // necessary. This is *only* to catch the case where we queried using the\n    // base model and the discriminated model has a projection\n    if (docSchema.$isRootDiscriminator && !self.$__isSelected(path)) {\n      return;\n    }\n\n    if (!schemaType && utils.isPOJO(obj[i])) {\n      // assume nested object\n      if (!doc[i]) {\n        doc[i] = {};\n        if (!strict && !(i in docSchema.tree) && !(i in docSchema.methods) && !(i in docSchema.virtuals)) {\n          self[i] = doc[i];\n        }\n      }\n      init(self, obj[i], doc[i], opts, path + '.');\n    } else if (!schemaType) {\n      doc[i] = obj[i];\n      if (!strict && !prefix) {\n        self[i] = obj[i];\n      }\n    } else {\n      // Retain order when overwriting defaults\n      if (doc.hasOwnProperty(i) && obj[i] !== void 0) {\n        delete doc[i];\n      }\n      if (obj[i] === null) {\n        doc[i] = schemaType._castNullish(null);\n      } else if (obj[i] !== undefined) {\n        const wasPopulated = obj[i].$__ == null ? null : obj[i].$__.wasPopulated;\n\n        if (schemaType && !wasPopulated) {\n          try {\n            if (opts && opts.setters) {\n              // Call applySetters with `init = false` because otherwise setters are a noop\n              const overrideInit = false;\n              doc[i] = schemaType.applySetters(obj[i], self, overrideInit);\n            } else {\n              doc[i] = schemaType.cast(obj[i], self, true);\n            }\n          } catch (e) {\n            self.invalidate(e.path, new ValidatorError({\n              path: e.path,\n              message: e.message,\n              type: 'cast',\n              value: e.value,\n              reason: e\n            }));\n          }\n        } else {\n          doc[i] = obj[i];\n        }\n      }\n      // mark as hydrated\n      if (!self.$isModified(path)) {\n        self.$__.activePaths.init(path);\n      }\n    }\n  }\n}\n\n/**\n * Sends an updateOne command with this document `_id` as the query selector.\n *\n * #### Example:\n *\n *     weirdCar.updateOne({$inc: {wheels:1}}, { w: 1 }, callback);\n *\n * #### Valid options:\n *\n *  - same as in [Model.updateOne](https://mongoosejs.com/docs/api/model.html#Model.updateOne)\n *\n * @see Model.updateOne https://mongoosejs.com/docs/api/model.html#Model.updateOne\n * @param {Object} doc\n * @param {Object} [options] optional see [`Query.prototype.setOptions()`](https://mongoosejs.com/docs/api/query.html#Query.prototype.setOptions())\n * @param {Object} [options.lean] if truthy, mongoose will return the document as a plain JavaScript object rather than a mongoose document. See [`Query.lean()`](https://mongoosejs.com/docs/api/query.html#Query.prototype.lean()) and the [Mongoose lean tutorial](https://mongoosejs.com/docs/tutorials/lean.html).\n * @param {Boolean|String} [options.strict] overwrites the schema's [strict mode option](https://mongoosejs.com/docs/guide.html#strict)\n * @param {Boolean} [options.timestamps=null] If set to `false` and [schema-level timestamps](https://mongoosejs.com/docs/guide.html#timestamps) are enabled, skip timestamps for this update. Note that this allows you to overwrite timestamps. Does nothing if schema-level timestamps are not set.\n * @param {Function} [callback]\n * @return {Query}\n * @api public\n * @memberOf Document\n * @instance\n */\n\nDocument.prototype.updateOne = function updateOne(doc, options, callback) {\n  const query = this.constructor.updateOne({ _id: this._id }, doc, options);\n  const self = this;\n  query.pre(function queryPreUpdateOne(cb) {\n    self.constructor._middleware.execPre('updateOne', self, [self], cb);\n  });\n  query.post(function queryPostUpdateOne(cb) {\n    self.constructor._middleware.execPost('updateOne', self, [self], {}, cb);\n  });\n\n  if (this.$session() != null) {\n    if (!('session' in query.options)) {\n      query.options.session = this.$session();\n    }\n  }\n\n  if (callback != null) {\n    return query.exec(callback);\n  }\n\n  return query;\n};\n\n/**\n * Sends a replaceOne command with this document `_id` as the query selector.\n *\n * #### Valid options:\n *\n *  - same as in [Model.replaceOne](https://mongoosejs.com/docs/api/model.html#Model.replaceOne())\n *\n * @see Model.replaceOne https://mongoosejs.com/docs/api/model.html#Model.replaceOne()\n * @param {Object} doc\n * @param {Object} [options]\n * @param {Function} [callback]\n * @return {Query}\n * @api public\n * @memberOf Document\n * @instance\n */\n\nDocument.prototype.replaceOne = function replaceOne() {\n  const args = [...arguments];\n  args.unshift({ _id: this._id });\n  return this.constructor.replaceOne.apply(this.constructor, args);\n};\n\n/**\n * Getter/setter around the session associated with this document. Used to\n * automatically set `session` if you `save()` a doc that you got from a\n * query with an associated session.\n *\n * #### Example:\n *\n *     const session = MyModel.startSession();\n *     const doc = await MyModel.findOne().session(session);\n *     doc.$session() === session; // true\n *     doc.$session(null);\n *     doc.$session() === null; // true\n *\n * If this is a top-level document, setting the session propagates to all child\n * docs.\n *\n * @param {ClientSession} [session] overwrite the current session\n * @return {ClientSession}\n * @method $session\n * @api public\n * @memberOf Document\n */\n\nDocument.prototype.$session = function $session(session) {\n  if (arguments.length === 0) {\n    if (this.$__.session != null && this.$__.session.hasEnded) {\n      this.$__.session = null;\n      return null;\n    }\n    return this.$__.session;\n  }\n\n  if (session != null && session.hasEnded) {\n    throw new MongooseError('Cannot set a document\\'s session to a session that has ended. Make sure you haven\\'t ' +\n      'called `endSession()` on the session you are passing to `$session()`.');\n  }\n\n  if (session == null && this.$__.session == null) {\n    return;\n  }\n\n  this.$__.session = session;\n\n  if (!this.$isSubdocument) {\n    const subdocs = this.$getAllSubdocs();\n    for (const child of subdocs) {\n      child.$session(session);\n    }\n  }\n\n  return session;\n};\n\n/**\n * Getter/setter around whether this document will apply timestamps by\n * default when using `save()` and `bulkSave()`.\n *\n * #### Example:\n *\n *     const TestModel = mongoose.model('Test', new Schema({ name: String }, { timestamps: true }));\n *     const doc = new TestModel({ name: 'John Smith' });\n *\n *     doc.$timestamps(); // true\n *\n *     doc.$timestamps(false);\n *     await doc.save(); // Does **not** apply timestamps\n *\n * @param {Boolean} [value] overwrite the current session\n * @return {Document|boolean|undefined} When used as a getter (no argument), a boolean will be returned indicating the timestamps option state or if unset \"undefined\" will be used, otherwise will return \"this\"\n * @method $timestamps\n * @api public\n * @memberOf Document\n */\n\nDocument.prototype.$timestamps = function $timestamps(value) {\n  if (arguments.length === 0) {\n    if (this.$__.timestamps != null) {\n      return this.$__.timestamps;\n    }\n\n    if (this.$__schema) {\n      return this.$__schema.options.timestamps;\n    }\n\n    return undefined;\n  }\n\n  const currentValue = this.$timestamps();\n  if (value !== currentValue) {\n    this.$__.timestamps = value;\n  }\n\n  return this;\n};\n\n/**\n * Overwrite all values in this document with the values of `obj`, except\n * for immutable properties. Behaves similarly to `set()`, except for it\n * unsets all properties that aren't in `obj`.\n *\n * @param {Object} obj the object to overwrite this document with\n * @method overwrite\n * @memberOf Document\n * @instance\n * @api public\n * @return {Document} this\n */\n\nDocument.prototype.overwrite = function overwrite(obj) {\n  const keys = Array.from(new Set(Object.keys(this._doc).concat(Object.keys(obj))));\n\n  for (const key of keys) {\n    if (key === '_id') {\n      continue;\n    }\n    // Explicitly skip version key\n    if (this.$__schema.options.versionKey && key === this.$__schema.options.versionKey) {\n      continue;\n    }\n    if (this.$__schema.options.discriminatorKey && key === this.$__schema.options.discriminatorKey) {\n      continue;\n    }\n    this.$set(key, obj[key]);\n  }\n\n  return this;\n};\n\n/**\n * Alias for `set()`, used internally to avoid conflicts\n *\n * @param {String|Object} path path or object of key/vals to set\n * @param {Any} val the value to set\n * @param {Schema|String|Number|Buffer|*} [type] optionally specify a type for \"on-the-fly\" attributes\n * @param {Object} [options] optionally specify options that modify the behavior of the set\n * @param {Boolean} [options.merge=false] if true, setting a [nested path](https://mongoosejs.com/docs/subdocs.html#subdocuments-versus-nested-paths) will merge existing values rather than overwrite the whole object. So `doc.set('nested', { a: 1, b: 2 })` becomes `doc.set('nested.a', 1); doc.set('nested.b', 2);`\n * @return {Document} this\n * @method $set\n * @memberOf Document\n * @instance\n * @api public\n */\n\nDocument.prototype.$set = function $set(path, val, type, options) {\n  if (utils.isPOJO(type)) {\n    options = type;\n    type = undefined;\n  }\n\n  const merge = options && options.merge;\n  const adhoc = type && type !== true;\n  const constructing = type === true;\n  let adhocs;\n  let keys;\n  let i = 0;\n  let pathtype;\n  let key;\n  let prefix;\n\n  const userSpecifiedStrict = options && 'strict' in options;\n  let strict = userSpecifiedStrict\n    ? options.strict\n    : this.$__.strictMode;\n\n  if (adhoc) {\n    adhocs = this.$__.adhocPaths || (this.$__.adhocPaths = {});\n    adhocs[path] = this.$__schema.interpretAsType(path, type, this.$__schema.options);\n  }\n\n  if (path == null) {\n    [path, val] = [val, path];\n  } else if (typeof path !== 'string') {\n    // new Document({ key: val })\n    if (path instanceof Document) {\n      if (path.$__isNested) {\n        path = path.toObject();\n      } else {\n        path = path._doc;\n      }\n    }\n    if (path == null) {\n      [path, val] = [val, path];\n    }\n\n    prefix = val ? val + '.' : '';\n    keys = getKeysInSchemaOrder(this.$__schema, path);\n\n    const len = keys.length;\n\n    // `_skipMinimizeTopLevel` is because we may have deleted the top-level\n    // nested key to ensure key order.\n    const _skipMinimizeTopLevel = options && options._skipMinimizeTopLevel || false;\n    if (len === 0 && _skipMinimizeTopLevel) {\n      delete options._skipMinimizeTopLevel;\n      if (val) {\n        this.$set(val, {});\n      }\n      return this;\n    }\n\n    options = Object.assign({}, options, { _skipMinimizeTopLevel: false });\n\n    for (let i = 0; i < len; ++i) {\n      key = keys[i];\n      const pathName = prefix ? prefix + key : key;\n      pathtype = this.$__schema.pathType(pathName);\n      const valForKey = path[key];\n\n      // On initial set, delete any nested keys if we're going to overwrite\n      // them to ensure we keep the user's key order.\n      if (type === true &&\n          !prefix &&\n          valForKey != null &&\n          pathtype === 'nested' &&\n          this._doc[key] != null) {\n        delete this._doc[key];\n      }\n\n      if (utils.isNonBuiltinObject(valForKey) && pathtype === 'nested') {\n        this.$set(pathName, valForKey, constructing, Object.assign({}, options, { _skipMarkModified: true }));\n        $applyDefaultsToNested(this.$get(pathName), pathName, this);\n        continue;\n      } else if (strict) {\n        // Don't overwrite defaults with undefined keys (gh-3981) (gh-9039)\n        if (constructing && valForKey === void 0 &&\n            this.$get(pathName) !== void 0) {\n          continue;\n        }\n\n        if (pathtype === 'adhocOrUndefined') {\n          pathtype = getEmbeddedDiscriminatorPath(this, pathName, { typeOnly: true });\n        }\n\n        if (pathtype === 'real' || pathtype === 'virtual') {\n          this.$set(pathName, valForKey, constructing, options);\n        } else if (pathtype === 'nested' && valForKey instanceof Document) {\n          this.$set(pathName,\n            valForKey.toObject({ transform: false }), constructing, options);\n        } else if (strict === 'throw') {\n          if (pathtype === 'nested') {\n            throw new ObjectExpectedError(key, valForKey);\n          } else {\n            throw new StrictModeError(key);\n          }\n        }\n      } else if (valForKey !== void 0) {\n        this.$set(pathName, valForKey, constructing, options);\n      }\n    }\n\n    // Ensure all properties are in correct order\n    const orderedDoc = {};\n    const orderedKeys = Object.keys(this.$__schema.tree);\n    for (let i = 0, len = orderedKeys.length; i < len; ++i) {\n      (key = orderedKeys[i]) &&\n      (this._doc.hasOwnProperty(key)) &&\n      (orderedDoc[key] = undefined);\n    }\n    this._doc = Object.assign(orderedDoc, this._doc);\n\n    return this;\n  }\n\n  let pathType = this.$__schema.pathType(path);\n  let parts = null;\n  if (pathType === 'adhocOrUndefined') {\n    parts = path.indexOf('.') === -1 ? [path] : path.split('.');\n    pathType = getEmbeddedDiscriminatorPath(this, parts, { typeOnly: true });\n  }\n  if (pathType === 'adhocOrUndefined' && !userSpecifiedStrict) {\n    // May be path underneath non-strict schema\n    if (parts == null) {\n      parts = path.indexOf('.') === -1 ? [path] : path.split('.');\n    }\n    const subdocStrict = getSubdocumentStrictValue(this.$__schema, parts);\n    if (subdocStrict !== undefined) {\n      strict = subdocStrict;\n    }\n  }\n\n  // Assume this is a Mongoose document that was copied into a POJO using\n  // `Object.assign()` or `{...doc}`\n  val = handleSpreadDoc(val);\n\n  // if this doc is being constructed we should not trigger getters\n  const priorVal = (() => {\n    if (this.$__.priorDoc != null) {\n      return this.$__.priorDoc.$__getValue(path);\n    }\n    if (constructing) {\n      return void 0;\n    }\n    return this.$__getValue(path);\n  })();\n\n  if (pathType === 'nested' && val) {\n    if (typeof val === 'object' && val != null) {\n      if (val.$__ != null) {\n        val = val.toObject(internalToObjectOptions);\n      }\n      if (val == null) {\n        this.invalidate(path, new MongooseError.CastError('Object', val, path));\n        return this;\n      }\n      const wasModified = this.$isModified(path);\n      const hasInitialVal = this.$__.savedState != null && this.$__.savedState.hasOwnProperty(path);\n      if (this.$__.savedState != null && !this.$isNew && !this.$__.savedState.hasOwnProperty(path)) {\n        const initialVal = this.$__getValue(path);\n        this.$__.savedState[path] = initialVal;\n\n        const keys = Object.keys(initialVal || {});\n        for (const key of keys) {\n          this.$__.savedState[path + '.' + key] = initialVal[key];\n        }\n      }\n\n      if (!merge) {\n        this.$__setValue(path, null);\n        cleanModifiedSubpaths(this, path);\n      } else {\n        return this.$set(val, path, constructing);\n      }\n\n      const keys = getKeysInSchemaOrder(this.$__schema, val, path);\n\n      this.$__setValue(path, {});\n      for (const key of keys) {\n        this.$set(path + '.' + key, val[key], constructing, { ...options, _skipMarkModified: true });\n      }\n      if (priorVal != null &&\n          (!wasModified || hasInitialVal) &&\n          utils.deepEqual(hasInitialVal ? this.$__.savedState[path] : priorVal, val)) {\n        this.unmarkModified(path);\n      } else {\n        this.markModified(path);\n      }\n      return this;\n    }\n    this.invalidate(path, new MongooseError.CastError('Object', val, path));\n    return this;\n  }\n\n  let schema;\n  if (parts == null) {\n    parts = path.indexOf('.') === -1 ? [path] : path.split('.');\n  }\n\n  // Might need to change path for top-level alias\n  if (typeof this.$__schema.aliases[parts[0]] === 'string') {\n    parts[0] = this.$__schema.aliases[parts[0]];\n  }\n\n  if (pathType === 'adhocOrUndefined' && strict) {\n    // check for roots that are Mixed types\n    let mixed;\n\n    for (i = 0; i < parts.length; ++i) {\n      const subpath = parts.slice(0, i + 1).join('.');\n\n      // If path is underneath a virtual, bypass everything and just set it.\n      if (i + 1 < parts.length && this.$__schema.pathType(subpath) === 'virtual') {\n        mpath.set(path, val, this);\n        return this;\n      }\n\n      schema = this.$__schema.path(subpath);\n      if (schema == null) {\n        continue;\n      }\n\n      if (schema instanceof MixedSchema) {\n        // allow changes to sub paths of mixed types\n        mixed = true;\n        break;\n      } else if (schema.$isSchemaMap && schema.$__schemaType instanceof MixedSchema && i < parts.length - 1) {\n        // Map of mixed and not the last element in the path resolves to mixed\n        mixed = true;\n        schema = schema.$__schemaType;\n        break;\n      }\n    }\n\n    if (schema == null) {\n      // Check for embedded discriminators\n      schema = getEmbeddedDiscriminatorPath(this, path);\n    }\n\n    if (!mixed && !schema) {\n      if (strict === 'throw') {\n        throw new StrictModeError(path);\n      }\n      return this;\n    }\n  } else if (pathType === 'virtual') {\n    schema = this.$__schema.virtualpath(path);\n    schema.applySetters(val, this);\n    return this;\n  } else {\n    schema = this.$__path(path);\n  }\n\n  // gh-4578, if setting a deeply nested path that doesn't exist yet, create it\n  let cur = this._doc;\n  let curPath = '';\n  for (i = 0; i < parts.length - 1; ++i) {\n    cur = cur[parts[i]];\n    curPath += (curPath.length !== 0 ? '.' : '') + parts[i];\n    if (!cur) {\n      this.$set(curPath, {});\n      // Hack re: gh-5800. If nested field is not selected, it probably exists\n      // so `MongoServerError: cannot use the part (nested of nested.num) to\n      // traverse the element ({nested: null})` is not likely. If user gets\n      // that error, its their fault for now. We should reconsider disallowing\n      // modifying not selected paths for 6.x\n      if (!this.$__isSelected(curPath)) {\n        this.unmarkModified(curPath);\n      }\n      cur = this.$__getValue(curPath);\n    }\n  }\n\n  let pathToMark;\n\n  // When using the $set operator the path to the field must already exist.\n  // Else mongodb throws: \"LEFT_SUBFIELD only supports Object\"\n\n  if (parts.length <= 1) {\n    pathToMark = path;\n  } else {\n    const len = parts.length;\n    for (i = 0; i < len; ++i) {\n      const subpath = parts.slice(0, i + 1).join('.');\n      if (this.$get(subpath, null, { getters: false }) === null) {\n        pathToMark = subpath;\n        break;\n      }\n    }\n\n    if (!pathToMark) {\n      pathToMark = path;\n    }\n  }\n\n  if (!schema) {\n    this.$__set(pathToMark, path, options, constructing, parts, schema, val, priorVal);\n\n    if (pathType === 'nested' && val == null) {\n      cleanModifiedSubpaths(this, path);\n    }\n    return this;\n  }\n\n  // If overwriting a subdocument path, make sure to clear out\n  // any errors _before_ setting, so new errors that happen\n  // get persisted. Re: #9080\n  if (schema.$isSingleNested || schema.$isMongooseArray) {\n    _markValidSubpaths(this, path);\n  }\n\n  if (val != null && merge && schema.$isSingleNested) {\n    if (val instanceof Document) {\n      val = val.toObject({ virtuals: false, transform: false });\n    }\n    const keys = Object.keys(val);\n    for (const key of keys) {\n      this.$set(path + '.' + key, val[key], constructing, options);\n    }\n\n    return this;\n  }\n\n  let shouldSet = true;\n  try {\n    // If the user is trying to set a ref path to a document with\n    // the correct model name, treat it as populated\n    const refMatches = (() => {\n      if (schema.options == null) {\n        return false;\n      }\n      if (!(val instanceof Document)) {\n        return false;\n      }\n      const model = val.constructor;\n\n      // Check ref\n      const ref = schema.options.ref;\n      if (ref != null && (ref === model.modelName || ref === model.baseModelName)) {\n        return true;\n      }\n\n      // Check refPath\n      const refPath = schema.options.refPath;\n      if (refPath == null) {\n        return false;\n      }\n      const modelName = val.get(refPath);\n      return modelName === model.modelName || modelName === model.baseModelName;\n    })();\n\n    let didPopulate = false;\n    if (refMatches && val instanceof Document && (!val.$__.wasPopulated || utils.deepEqual(val.$__.wasPopulated.value, val._id))) {\n      const unpopulatedValue = (schema && schema.$isSingleNested) ? schema.cast(val, this) : val._id;\n      this.$populated(path, unpopulatedValue, { [populateModelSymbol]: val.constructor });\n      val.$__.wasPopulated = { value: unpopulatedValue };\n      didPopulate = true;\n    }\n\n    let popOpts;\n    const typeKey = this.$__schema.options.typeKey;\n    if (schema.options &&\n        Array.isArray(schema.options[typeKey]) &&\n        schema.options[typeKey].length &&\n        schema.options[typeKey][0].ref &&\n        _isManuallyPopulatedArray(val, schema.options[typeKey][0].ref)) {\n      popOpts = { [populateModelSymbol]: val[0].constructor };\n      this.$populated(path, val.map(function(v) { return v._id; }), popOpts);\n\n      for (const doc of val) {\n        doc.$__.wasPopulated = { value: doc._id };\n      }\n      didPopulate = true;\n    }\n\n    if (!refMatches || !schema.$isSingleNested || !val.$__) {\n      // If this path is underneath a single nested schema, we'll call the setter\n      // later in `$__set()` because we don't take `_doc` when we iterate through\n      // a single nested doc. That's to make sure we get the correct context.\n      // Otherwise we would double-call the setter, see gh-7196.\n      let setterContext = this;\n      if (this.$__schema.singleNestedPaths[path] != null && parts.length > 1) {\n        setterContext = getDeepestSubdocumentForPath(this, parts, this.schema);\n      }\n      if (options != null && options.overwriteImmutable) {\n        val = schema.applySetters(val, setterContext, false, priorVal, { overwriteImmutable: true });\n      } else {\n        val = schema.applySetters(val, setterContext, false, priorVal);\n      }\n    }\n\n    if (Array.isArray(val) &&\n        !Array.isArray(schema) &&\n        schema.$isMongooseDocumentArray &&\n        val.length !== 0 &&\n        val[0] != null &&\n        val[0].$__ != null &&\n        val[0].$__.populated != null) {\n      const populatedPaths = Object.keys(val[0].$__.populated);\n      for (const populatedPath of populatedPaths) {\n        this.$populated(path + '.' + populatedPath,\n          val.map(v => v.$populated(populatedPath)),\n          val[0].$__.populated[populatedPath].options);\n      }\n      didPopulate = true;\n    }\n\n    if (!didPopulate && this.$__.populated) {\n      // If this array partially contains populated documents, convert them\n      // all to ObjectIds re: #8443\n      if (Array.isArray(val) && this.$__.populated[path]) {\n        for (let i = 0; i < val.length; ++i) {\n          if (val[i] instanceof Document) {\n            val.set(i, val[i]._id, true);\n          }\n        }\n      }\n      delete this.$__.populated[path];\n    }\n\n    if (val != null && schema.$isSingleNested) {\n      _checkImmutableSubpaths(val, schema, priorVal);\n    }\n\n    this.$markValid(path);\n  } catch (e) {\n    if (e instanceof MongooseError.StrictModeError && e.isImmutableError) {\n      this.invalidate(path, e);\n    } else if (e instanceof MongooseError.CastError) {\n      this.invalidate(e.path, e);\n      if (e.$originalErrorPath) {\n        this.invalidate(path,\n          new MongooseError.CastError(schema.instance, val, path, e.$originalErrorPath));\n      }\n    } else {\n      this.invalidate(path,\n        new MongooseError.CastError(schema.instance, val, path, e));\n    }\n    shouldSet = false;\n  }\n\n  if (shouldSet) {\n    let savedState = null;\n    let savedStatePath = null;\n    if (!constructing) {\n      const doc = this.$isSubdocument ? this.ownerDocument() : this;\n      savedState = doc.$__.savedState;\n      savedStatePath = this.$isSubdocument ? this.$__.fullPath + '.' + path : path;\n      doc.$__saveInitialState(savedStatePath);\n    }\n\n    this.$__set(pathToMark, path, options, constructing, parts, schema, val, priorVal);\n\n    const isInTransaction = !!this.$__.session?.transaction;\n    const isModifiedWithinTransaction = this.$__.session &&\n      this.$__.session[sessionNewDocuments] &&\n      this.$__.session[sessionNewDocuments].has(this) &&\n      this.$__.session[sessionNewDocuments].get(this).modifiedPaths &&\n      !this.$__.session[sessionNewDocuments].get(this).modifiedPaths.has(savedStatePath);\n    if (savedState != null &&\n        savedState.hasOwnProperty(savedStatePath) &&\n        (!isInTransaction || isModifiedWithinTransaction) &&\n        utils.deepEqual(val, savedState[savedStatePath])) {\n      this.unmarkModified(path);\n    }\n  }\n\n  if (schema.$isSingleNested && (this.isDirectModified(path) || val == null)) {\n    cleanModifiedSubpaths(this, path);\n  }\n\n  return this;\n};\n\n/*!\n * ignore\n */\n\nfunction _isManuallyPopulatedArray(val, ref) {\n  if (!Array.isArray(val)) {\n    return false;\n  }\n  if (val.length === 0) {\n    return false;\n  }\n\n  for (const el of val) {\n    if (!(el instanceof Document)) {\n      return false;\n    }\n    const modelName = el.constructor.modelName;\n    if (modelName == null) {\n      return false;\n    }\n    if (el.constructor.modelName != ref && el.constructor.baseModelName != ref) {\n      return false;\n    }\n  }\n\n  return true;\n}\n\n/**\n * Sets the value of a path, or many paths.\n * Alias for [`.$set`](https://mongoosejs.com/docs/api/document.html#Document.prototype.$set()).\n *\n * #### Example:\n *\n *     // path, value\n *     doc.set(path, value)\n *\n *     // object\n *     doc.set({\n *         path  : value\n *       , path2 : {\n *            path  : value\n *         }\n *     })\n *\n *     // on-the-fly cast to number\n *     doc.set(path, value, Number)\n *\n *     // on-the-fly cast to string\n *     doc.set(path, value, String)\n *\n *     // changing strict mode behavior\n *     doc.set(path, value, { strict: false });\n *\n * @param {String|Object} path path or object of key/vals to set\n * @param {Any} val the value to set\n * @param {Schema|String|Number|Buffer|*} [type] optionally specify a type for \"on-the-fly\" attributes\n * @param {Object} [options] optionally specify options that modify the behavior of the set\n * @return {Document} this\n * @api public\n * @method set\n * @memberOf Document\n * @instance\n */\n\nDocument.prototype.set = Document.prototype.$set;\n\n/**\n * Determine if we should mark this change as modified.\n *\n * @param {never} pathToMark UNUSED\n * @param {String|Symbol} path\n * @param {Object} options\n * @param {Any} constructing\n * @param {never} parts UNUSED\n * @param {Schema} schema\n * @param {Any} val\n * @param {Any} priorVal\n * @return {Boolean}\n * @api private\n * @method $__shouldModify\n * @memberOf Document\n * @instance\n */\n\nDocument.prototype.$__shouldModify = function(pathToMark, path, options, constructing, parts, schema, val, priorVal) {\n  if (options && options._skipMarkModified) {\n    return false;\n  }\n  if (this.$isNew) {\n    return true;\n  }\n  // Is path already modified? If so, always modify. We may unmark modified later.\n  if (path in this.$__.activePaths.getStatePaths('modify')) {\n    return true;\n  }\n\n  if (val === void 0 && !this.$__isSelected(path)) {\n    // when a path is not selected in a query, its initial\n    // value will be undefined.\n    return true;\n  }\n\n  if (val === void 0 && path in this.$__.activePaths.getStatePaths('default')) {\n    // we're just unsetting the default value which was never saved\n    return false;\n  }\n\n  // gh-3992: if setting a populated field to a doc, don't mark modified\n  // if they have the same _id\n  if (this.$populated(path) &&\n      val instanceof Document &&\n      deepEqual(val._id, priorVal)) {\n    return false;\n  }\n\n  if (!deepEqual(val, priorVal !== undefined ? priorVal : utils.getValue(path, this))) {\n    return true;\n  }\n\n  if (!constructing &&\n      val !== null &&\n      val !== undefined &&\n      path in this.$__.activePaths.getStatePaths('default') &&\n      deepEqual(val, schema.getDefault(this, constructing))) {\n    // a path with a default was $unset on the server\n    // and the user is setting it to the same value again\n    return true;\n  }\n  return false;\n};\n\n/**\n * Handles the actual setting of the value and marking the path modified if appropriate.\n *\n * @param {String} pathToMark\n * @param {String|Symbol} path\n * @param {Object} options\n * @param {Any} constructing\n * @param {Array} parts\n * @param {Schema} schema\n * @param {Any} val\n * @param {Any} priorVal\n * @api private\n * @method $__set\n * @memberOf Document\n * @instance\n */\n\nDocument.prototype.$__set = function(pathToMark, path, options, constructing, parts, schema, val, priorVal) {\n  Embedded = Embedded || __webpack_require__(/*! ./types/arraySubdocument */ \"(ssr)/./node_modules/mongoose/lib/types/arraySubdocument.js\");\n\n  const shouldModify = this.$__shouldModify(pathToMark, path, options, constructing, parts,\n    schema, val, priorVal);\n\n  if (shouldModify) {\n    if (this.$__.primitiveAtomics && this.$__.primitiveAtomics[path]) {\n      delete this.$__.primitiveAtomics[path];\n      if (Object.keys(this.$__.primitiveAtomics).length === 0) {\n        delete this.$__.primitiveAtomics;\n      }\n    }\n    this.markModified(pathToMark);\n\n    // handle directly setting arrays (gh-1126)\n    MongooseArray || (MongooseArray = __webpack_require__(/*! ./types/array */ \"(ssr)/./node_modules/mongoose/lib/types/array/index.js\"));\n    if (val && utils.isMongooseArray(val)) {\n      val._registerAtomic('$set', val);\n\n      // Update embedded document parent references (gh-5189)\n      if (utils.isMongooseDocumentArray(val)) {\n        val.forEach(function(item) {\n          item && item.__parentArray && (item.__parentArray = val);\n        });\n      }\n    }\n  } else if (Array.isArray(val) && Array.isArray(priorVal) && utils.isMongooseArray(val) && utils.isMongooseArray(priorVal)) {\n    val[arrayAtomicsSymbol] = priorVal[arrayAtomicsSymbol];\n    val[arrayAtomicsBackupSymbol] = priorVal[arrayAtomicsBackupSymbol];\n    if (utils.isMongooseDocumentArray(val)) {\n      val.forEach(doc => {\n        if (doc != null) {\n          doc.$isNew = false;\n        }\n      });\n    }\n  }\n\n  let obj = this._doc;\n  let i = 0;\n  const l = parts.length;\n  let cur = '';\n\n  for (; i < l; i++) {\n    const next = i + 1;\n    const last = next === l;\n    cur += (cur ? '.' + parts[i] : parts[i]);\n    if (specialProperties.has(parts[i])) {\n      return;\n    }\n\n    if (last) {\n      if (obj instanceof Map) {\n        obj.set(parts[i], val);\n      } else if (obj.$isSingleNested) {\n        if (!(parts[i] in obj)) {\n          obj[parts[i]] = val;\n          obj._doc[parts[i]] = val;\n        } else {\n          obj._doc[parts[i]] = val;\n        }\n      } else {\n        obj[parts[i]] = val;\n      }\n    } else {\n      const isMap = obj instanceof Map;\n      let value = isMap ? obj.get(parts[i]) : obj[parts[i]];\n      if (utils.isPOJO(value)) {\n        obj = value;\n      } else if (value && value instanceof Embedded) {\n        obj = value;\n      } else if (value && !Array.isArray(value) && value.$isSingleNested) {\n        obj = value;\n      } else if (value && Array.isArray(value)) {\n        obj = value;\n      } else if (value == null) {\n        value = {};\n        if (isMap) {\n          obj.set(parts[i], value);\n        } else {\n          obj[parts[i]] = value;\n        }\n        obj = value;\n      } else {\n        obj = value;\n      }\n    }\n  }\n};\n\n/**\n * Gets a raw value from a path (no getters)\n *\n * @param {String} path\n * @return {Any} Returns the value from the given `path`.\n * @api private\n */\n\nDocument.prototype.$__getValue = function(path) {\n  return utils.getValue(path, this._doc);\n};\n\n/**\n * Increments the numeric value at `path` by the given `val`.\n * When you call `save()` on this document, Mongoose will send a\n * [`$inc`](https://www.mongodb.com/docs/manual/reference/operator/update/inc/)\n * as opposed to a `$set`.\n *\n * #### Example:\n *\n *     const schema = new Schema({ counter: Number });\n *     const Test = db.model('Test', schema);\n *\n *     const doc = await Test.create({ counter: 0 });\n *     doc.$inc('counter', 2);\n *     await doc.save(); // Sends a `{ $inc: { counter: 2 } }` to MongoDB\n *     doc.counter; // 2\n *\n *     doc.counter += 2;\n *     await doc.save(); // Sends a `{ $set: { counter: 2 } }` to MongoDB\n *\n * @param {String|Array} path path or paths to update\n * @param {Number} val increment `path` by this value\n * @return {Document} this\n */\n\nDocument.prototype.$inc = function $inc(path, val) {\n  if (val == null) {\n    val = 1;\n  }\n\n  if (Array.isArray(path)) {\n    path.forEach((p) => this.$inc(p, val));\n    return this;\n  }\n\n  const schemaType = this.$__path(path);\n  if (schemaType == null) {\n    if (this.$__.strictMode === 'throw') {\n      throw new StrictModeError(path);\n    } else if (this.$__.strictMode === true) {\n      return this;\n    }\n  } else if (schemaType.instance !== 'Number') {\n    this.invalidate(path, new MongooseError.CastError(schemaType.instance, val, path));\n    return this;\n  }\n\n  const currentValue = this.$__getValue(path) || 0;\n  let shouldSet = false;\n  let valToSet = null;\n  let valToInc = val;\n\n  try {\n    val = schemaType.cast(val);\n    valToSet = schemaType.applySetters(currentValue + val, this);\n    valToInc = valToSet - currentValue;\n    shouldSet = true;\n  } catch (err) {\n    this.invalidate(path, new MongooseError.CastError('number', val, path, err));\n  }\n\n  if (shouldSet) {\n    this.$__.primitiveAtomics = this.$__.primitiveAtomics || {};\n    if (this.$__.primitiveAtomics[path] == null) {\n      this.$__.primitiveAtomics[path] = { $inc: valToInc };\n    } else {\n      this.$__.primitiveAtomics[path].$inc += valToInc;\n    }\n    this.markModified(path);\n    this.$__setValue(path, valToSet);\n  }\n\n  return this;\n};\n\n/**\n * Sets a raw value for a path (no casting, setters, transformations)\n *\n * @param {String} path\n * @param {Object} value\n * @return {Document} this\n * @api private\n */\n\nDocument.prototype.$__setValue = function(path, val) {\n  utils.setValue(path, val, this._doc);\n  return this;\n};\n\n/**\n * Returns the value of a path.\n *\n * #### Example:\n *\n *     // path\n *     doc.get('age') // 47\n *\n *     // dynamic casting to a string\n *     doc.get('age', String) // \"47\"\n *\n * @param {String} path\n * @param {Schema|String|Number|Buffer|*} [type] optionally specify a type for on-the-fly attributes\n * @param {Object} [options]\n * @param {Boolean} [options.virtuals=false] Apply virtuals before getting this path\n * @param {Boolean} [options.getters=true] If false, skip applying getters and just get the raw value\n * @return {Any}\n * @api public\n */\n\nDocument.prototype.get = function(path, type, options) {\n  let adhoc;\n  if (options == null) {\n    options = {};\n  }\n  if (type) {\n    adhoc = this.$__schema.interpretAsType(path, type, this.$__schema.options);\n  }\n  const noDottedPath = options.noDottedPath;\n\n  // Fast path if we know we're just accessing top-level path on the document:\n  // just get the schema path, avoid `$__path()` because that does string manipulation\n  let schema = noDottedPath ? this.$__schema.paths[path] : this.$__path(path);\n  if (schema == null) {\n    schema = this.$__schema.virtualpath(path);\n\n    if (schema != null) {\n      return schema.applyGetters(void 0, this);\n    }\n  }\n\n  if (noDottedPath) {\n    let obj = this._doc[path];\n    if (adhoc) {\n      obj = adhoc.cast(obj);\n    }\n    if (schema != null && options.getters !== false) {\n      return schema.applyGetters(obj, this);\n    }\n    return obj;\n  }\n\n  if (schema != null && schema.instance === 'Mixed') {\n    const virtual = this.$__schema.virtualpath(path);\n    if (virtual != null) {\n      schema = virtual;\n    }\n  }\n\n  const hasDot = path.indexOf('.') !== -1;\n  let obj = this._doc;\n\n  const pieces = hasDot ? path.split('.') : [path];\n  // Might need to change path for top-level alias\n  if (typeof this.$__schema.aliases[pieces[0]] === 'string') {\n    pieces[0] = this.$__schema.aliases[pieces[0]];\n  }\n\n  for (let i = 0, l = pieces.length; i < l; i++) {\n    if (obj && obj._doc) {\n      obj = obj._doc;\n    }\n\n    if (obj == null) {\n      obj = void 0;\n    } else if (obj instanceof Map) {\n      obj = obj.get(pieces[i], { getters: false });\n    } else if (i === l - 1) {\n      obj = utils.getValue(pieces[i], obj);\n    } else {\n      obj = obj[pieces[i]];\n    }\n  }\n\n  if (adhoc) {\n    obj = adhoc.cast(obj);\n  }\n\n  if (schema != null && options.getters !== false) {\n    obj = schema.applyGetters(obj, this);\n  } else if (this.$__schema.nested[path] && options.virtuals) {\n    // Might need to apply virtuals if this is a nested path\n    return applyVirtuals(this, clone(obj) || {}, { path: path });\n  }\n\n  return obj;\n};\n\n/*!\n * ignore\n */\n\nDocument.prototype[getSymbol] = Document.prototype.get;\nDocument.prototype.$get = Document.prototype.get;\n\n/**\n * Returns the schematype for the given `path`.\n *\n * @param {String} path\n * @return {SchemaPath}\n * @api private\n * @method $__path\n * @memberOf Document\n * @instance\n */\n\nDocument.prototype.$__path = function(path) {\n  const adhocs = this.$__.adhocPaths;\n  const adhocType = adhocs && adhocs.hasOwnProperty(path) ? adhocs[path] : null;\n\n  if (adhocType) {\n    return adhocType;\n  }\n  return this.$__schema.path(path);\n};\n\n/**\n * Marks the path as having pending changes to write to the db.\n *\n * _Very helpful when using [Mixed](https://mongoosejs.com/docs/schematypes.html#mixed) types._\n *\n * #### Example:\n *\n *     doc.mixed.type = 'changed';\n *     doc.markModified('mixed.type');\n *     doc.save() // changes to mixed.type are now persisted\n *\n * @param {String} path the path to mark modified\n * @param {Document} [scope] the scope to run validators with\n * @api public\n */\n\nDocument.prototype.markModified = function(path, scope) {\n  this.$__saveInitialState(path);\n\n  this.$__.activePaths.modify(path);\n  if (scope != null && !this.$isSubdocument) {\n    this.$__.pathsToScopes = this.$__pathsToScopes || {};\n    this.$__.pathsToScopes[path] = scope;\n  }\n};\n\n/*!\n * ignore\n */\n\nDocument.prototype.$__saveInitialState = function $__saveInitialState(path) {\n  const savedState = this.$__.savedState;\n  const savedStatePath = path;\n  if (savedState != null) {\n    const firstDot = savedStatePath.indexOf('.');\n    const topLevelPath = firstDot === -1 ? savedStatePath : savedStatePath.slice(0, firstDot);\n    if (!savedState.hasOwnProperty(topLevelPath)) {\n      savedState[topLevelPath] = clone(this.$__getValue(topLevelPath));\n    }\n  }\n};\n\n/**\n * Clears the modified state on the specified path.\n *\n * #### Example:\n *\n *     doc.foo = 'bar';\n *     doc.unmarkModified('foo');\n *     doc.save(); // changes to foo will not be persisted\n *\n * @param {String} path the path to unmark modified\n * @api public\n */\n\nDocument.prototype.unmarkModified = function(path) {\n  this.$__.activePaths.init(path);\n  if (this.$__.pathsToScopes != null) {\n    delete this.$__.pathsToScopes[path];\n  }\n};\n\n/**\n * Don't run validation on this path or persist changes to this path.\n *\n * #### Example:\n *\n *     doc.foo = null;\n *     doc.$ignore('foo');\n *     doc.save(); // changes to foo will not be persisted and validators won't be run\n *\n * @memberOf Document\n * @instance\n * @method $ignore\n * @param {String} path the path to ignore\n * @api public\n */\n\nDocument.prototype.$ignore = function(path) {\n  this.$__.activePaths.ignore(path);\n};\n\n/**\n * Returns the list of paths that have been directly modified. A direct\n * modified path is a path that you explicitly set, whether via `doc.foo = 'bar'`,\n * `Object.assign(doc, { foo: 'bar' })`, or `doc.set('foo', 'bar')`.\n *\n * A path `a` may be in `modifiedPaths()` but not in `directModifiedPaths()`\n * because a child of `a` was directly modified.\n *\n * #### Example:\n *\n *     const schema = new Schema({ foo: String, nested: { bar: String } });\n *     const Model = mongoose.model('Test', schema);\n *     await Model.create({ foo: 'original', nested: { bar: 'original' } });\n *\n *     const doc = await Model.findOne();\n *     doc.nested.bar = 'modified';\n *     doc.directModifiedPaths(); // ['nested.bar']\n *     doc.modifiedPaths(); // ['nested', 'nested.bar']\n *\n * @return {String[]}\n * @api public\n */\n\nDocument.prototype.directModifiedPaths = function() {\n  return Object.keys(this.$__.activePaths.getStatePaths('modify'));\n};\n\n/**\n * Returns true if the given path is nullish or only contains empty objects.\n * Useful for determining whether this subdoc will get stripped out by the\n * [minimize option](https://mongoosejs.com/docs/guide.html#minimize).\n *\n * #### Example:\n *\n *     const schema = new Schema({ nested: { foo: String } });\n *     const Model = mongoose.model('Test', schema);\n *     const doc = new Model({});\n *     doc.$isEmpty('nested'); // true\n *     doc.nested.$isEmpty(); // true\n *\n *     doc.nested.foo = 'bar';\n *     doc.$isEmpty('nested'); // false\n *     doc.nested.$isEmpty(); // false\n *\n * @param {String} [path]\n * @memberOf Document\n * @instance\n * @api public\n * @method $isEmpty\n * @return {Boolean}\n */\n\nDocument.prototype.$isEmpty = function(path) {\n  const isEmptyOptions = {\n    minimize: true,\n    virtuals: false,\n    getters: false,\n    transform: false\n  };\n\n  if (arguments.length !== 0) {\n    const v = this.$get(path);\n    if (v == null) {\n      return true;\n    }\n    if (typeof v !== 'object') {\n      return false;\n    }\n    if (utils.isPOJO(v)) {\n      return _isEmpty(v);\n    }\n    return Object.keys(v.toObject(isEmptyOptions)).length === 0;\n  }\n\n  return Object.keys(this.toObject(isEmptyOptions)).length === 0;\n};\n\n/*!\n * ignore\n */\n\nfunction _isEmpty(v) {\n  if (v == null) {\n    return true;\n  }\n  if (typeof v !== 'object' || Array.isArray(v)) {\n    return false;\n  }\n  for (const key of Object.keys(v)) {\n    if (!_isEmpty(v[key])) {\n      return false;\n    }\n  }\n  return true;\n}\n\n/**\n * Returns the list of paths that have been modified.\n *\n * @param {Object} [options]\n * @param {Boolean} [options.includeChildren=false] if true, returns children of modified paths as well. For example, if false, the list of modified paths for `doc.colors = { primary: 'blue' };` will **not** contain `colors.primary`. If true, `modifiedPaths()` will return an array that contains `colors.primary`.\n * @return {String[]}\n * @api public\n */\n\nDocument.prototype.modifiedPaths = function(options) {\n  options = options || {};\n\n  const directModifiedPaths = Object.keys(this.$__.activePaths.getStatePaths('modify'));\n  const result = new Set();\n\n  let i = 0;\n  let j = 0;\n  const len = directModifiedPaths.length;\n\n  for (i = 0; i < len; ++i) {\n    const path = directModifiedPaths[i];\n    const parts = parentPaths(path);\n    const pLen = parts.length;\n\n    for (j = 0; j < pLen; ++j) {\n      result.add(parts[j]);\n    }\n\n    if (!options.includeChildren) {\n      continue;\n    }\n\n    let ii = 0;\n    let cur = this.$get(path);\n    if (typeof cur === 'object' && cur !== null) {\n      if (cur._doc) {\n        cur = cur._doc;\n      }\n      const len = cur.length;\n      if (Array.isArray(cur)) {\n        for (ii = 0; ii < len; ++ii) {\n          const subPath = path + '.' + ii;\n          if (!result.has(subPath)) {\n            result.add(subPath);\n            if (cur[ii] != null && cur[ii].$__) {\n              const modified = cur[ii].modifiedPaths();\n              let iii = 0;\n              const iiiLen = modified.length;\n              for (iii = 0; iii < iiiLen; ++iii) {\n                result.add(subPath + '.' + modified[iii]);\n              }\n            }\n          }\n        }\n      } else {\n        const keys = Object.keys(cur);\n        let ii = 0;\n        const len = keys.length;\n        for (ii = 0; ii < len; ++ii) {\n          result.add(path + '.' + keys[ii]);\n        }\n      }\n    }\n  }\n  return Array.from(result);\n};\n\nDocument.prototype[documentModifiedPaths] = Document.prototype.modifiedPaths;\n\n/**\n * Returns true if any of the given paths is modified, else false. If no arguments, returns `true` if any path\n * in this document is modified.\n *\n * If `path` is given, checks if a path or any full path containing `path` as part of its path chain has been modified.\n *\n * #### Example:\n *\n *     doc.set('documents.0.title', 'changed');\n *     doc.isModified()                      // true\n *     doc.isModified('documents')           // true\n *     doc.isModified('documents.0.title')   // true\n *     doc.isModified('documents otherProp') // true\n *     doc.isDirectModified('documents')     // false\n *\n * @param {String} [path] optional\n * @return {Boolean}\n * @api public\n */\n\nDocument.prototype.isModified = function(paths, modifiedPaths) {\n  if (paths) {\n    const directModifiedPathsObj = this.$__.activePaths.states.modify;\n    if (directModifiedPathsObj == null) {\n      return false;\n    }\n\n    if (typeof paths === 'string') {\n      paths = paths.indexOf(' ') === -1 ? [paths] : paths.split(' ');\n    }\n\n    for (const path of paths) {\n      if (directModifiedPathsObj[path] != null) {\n        return true;\n      }\n    }\n\n    const modified = modifiedPaths || this[documentModifiedPaths]();\n    const isModifiedChild = paths.some(function(path) {\n      return !!~modified.indexOf(path);\n    });\n\n    const directModifiedPaths = Object.keys(directModifiedPathsObj);\n    return isModifiedChild || paths.some(function(path) {\n      return directModifiedPaths.some(function(mod) {\n        return mod === path || path.startsWith(mod + '.');\n      });\n    });\n  }\n\n  return this.$__.activePaths.some('modify');\n};\n\n/**\n * Alias of [`.isModified`](https://mongoosejs.com/docs/api/document.html#Document.prototype.isModified())\n *\n * @method $isModified\n * @memberOf Document\n * @api public\n */\n\nDocument.prototype.$isModified = Document.prototype.isModified;\n\nDocument.prototype[documentIsModified] = Document.prototype.isModified;\n\n/**\n * Checks if a path is set to its default.\n *\n * #### Example:\n *\n *     MyModel = mongoose.model('test', { name: { type: String, default: 'Val '} });\n *     const m = new MyModel();\n *     m.$isDefault('name'); // true\n *\n * @memberOf Document\n * @instance\n * @method $isDefault\n * @param {String} [path]\n * @return {Boolean}\n * @api public\n */\n\nDocument.prototype.$isDefault = function(path) {\n  if (path == null) {\n    return this.$__.activePaths.some('default');\n  }\n\n  if (typeof path === 'string' && path.indexOf(' ') === -1) {\n    return this.$__.activePaths.getStatePaths('default').hasOwnProperty(path);\n  }\n\n  let paths = path;\n  if (!Array.isArray(paths)) {\n    paths = paths.split(' ');\n  }\n\n  return paths.some(path => this.$__.activePaths.getStatePaths('default').hasOwnProperty(path));\n};\n\n/**\n * Getter/setter, determines whether the document was removed or not.\n *\n * #### Example:\n *\n *     const product = await product.remove();\n *     product.$isDeleted(); // true\n *     product.remove(); // no-op, doesn't send anything to the db\n *\n *     product.$isDeleted(false);\n *     product.$isDeleted(); // false\n *     product.remove(); // will execute a remove against the db\n *\n *\n * @param {Boolean} [val] optional, overrides whether mongoose thinks the doc is deleted\n * @return {Boolean|Document} whether mongoose thinks this doc is deleted.\n * @method $isDeleted\n * @memberOf Document\n * @instance\n * @api public\n */\n\nDocument.prototype.$isDeleted = function(val) {\n  if (arguments.length === 0) {\n    return !!this.$__.isDeleted;\n  }\n\n  this.$__.isDeleted = !!val;\n  return this;\n};\n\n/**\n * Returns true if `path` was directly set and modified, else false.\n *\n * #### Example:\n *\n *     doc.set('documents.0.title', 'changed');\n *     doc.isDirectModified('documents.0.title') // true\n *     doc.isDirectModified('documents') // false\n *\n * @param {String|String[]} [path]\n * @return {Boolean}\n * @api public\n */\n\nDocument.prototype.isDirectModified = function(path) {\n  if (path == null) {\n    return this.$__.activePaths.some('modify');\n  }\n\n  if (typeof path === 'string' && path.indexOf(' ') === -1) {\n    return this.$__.activePaths.getStatePaths('modify').hasOwnProperty(path);\n  }\n\n  let paths = path;\n  if (!Array.isArray(paths)) {\n    paths = paths.split(' ');\n  }\n\n  return paths.some(path => this.$__.activePaths.getStatePaths('modify').hasOwnProperty(path));\n};\n\n/**\n * Checks if `path` is in the `init` state, that is, it was set by `Document#init()` and not modified since.\n *\n * @param {String} [path]\n * @return {Boolean}\n * @api public\n */\n\nDocument.prototype.isInit = function(path) {\n  if (path == null) {\n    return this.$__.activePaths.some('init');\n  }\n\n  if (typeof path === 'string' && path.indexOf(' ') === -1) {\n    return this.$__.activePaths.getStatePaths('init').hasOwnProperty(path);\n  }\n\n  let paths = path;\n  if (!Array.isArray(paths)) {\n    paths = paths.split(' ');\n  }\n\n  return paths.some(path => this.$__.activePaths.getStatePaths('init').hasOwnProperty(path));\n};\n\n/**\n * Checks if `path` was selected in the source query which initialized this document.\n *\n * #### Example:\n *\n *     const doc = await Thing.findOne().select('name');\n *     doc.isSelected('name') // true\n *     doc.isSelected('age')  // false\n *\n * @param {String|String[]} path\n * @return {Boolean}\n * @api public\n */\n\nDocument.prototype.isSelected = function isSelected(path) {\n  if (this.$__.selected == null) {\n    return true;\n  }\n  if (!path) {\n    return false;\n  }\n  if (path === '_id') {\n    return this.$__.selected._id !== 0;\n  }\n\n  if (path.indexOf(' ') !== -1) {\n    path = path.split(' ');\n  }\n  if (Array.isArray(path)) {\n    return path.some(p => this.$__isSelected(p));\n  }\n\n  const paths = Object.keys(this.$__.selected);\n  let inclusive = null;\n\n  if (paths.length === 1 && paths[0] === '_id') {\n    // only _id was selected.\n    return this.$__.selected._id === 0;\n  }\n\n  for (const cur of paths) {\n    if (cur === '_id') {\n      continue;\n    }\n    if (!isDefiningProjection(this.$__.selected[cur])) {\n      continue;\n    }\n    inclusive = !!this.$__.selected[cur];\n    break;\n  }\n\n  if (inclusive === null) {\n    return true;\n  }\n\n  if (path in this.$__.selected) {\n    return inclusive;\n  }\n\n  const pathDot = path + '.';\n\n  for (const cur of paths) {\n    if (cur === '_id') {\n      continue;\n    }\n\n    if (cur.startsWith(pathDot)) {\n      return inclusive || cur !== pathDot;\n    }\n\n    if (pathDot.startsWith(cur + '.')) {\n      return inclusive;\n    }\n  }\n  return !inclusive;\n};\n\nDocument.prototype.$__isSelected = Document.prototype.isSelected;\n\n/**\n * Checks if `path` was explicitly selected. If no projection, always returns\n * true.\n *\n * #### Example:\n *\n *     Thing.findOne().select('nested.name').exec(function (err, doc) {\n *        doc.isDirectSelected('nested.name') // true\n *        doc.isDirectSelected('nested.otherName') // false\n *        doc.isDirectSelected('nested')  // false\n *     })\n *\n * @param {String} path\n * @return {Boolean}\n * @api public\n */\n\nDocument.prototype.isDirectSelected = function isDirectSelected(path) {\n  if (this.$__.selected == null) {\n    return true;\n  }\n\n  if (path === '_id') {\n    return this.$__.selected._id !== 0;\n  }\n\n  if (path.indexOf(' ') !== -1) {\n    path = path.split(' ');\n  }\n  if (Array.isArray(path)) {\n    return path.some(p => this.isDirectSelected(p));\n  }\n\n  const paths = Object.keys(this.$__.selected);\n  let inclusive = null;\n\n  if (paths.length === 1 && paths[0] === '_id') {\n    // only _id was selected.\n    return this.$__.selected._id === 0;\n  }\n\n  for (const cur of paths) {\n    if (cur === '_id') {\n      continue;\n    }\n    if (!isDefiningProjection(this.$__.selected[cur])) {\n      continue;\n    }\n    inclusive = !!this.$__.selected[cur];\n    break;\n  }\n\n  if (inclusive === null) {\n    return true;\n  }\n\n  if (this.$__.selected.hasOwnProperty(path)) {\n    return inclusive;\n  }\n\n  return !inclusive;\n};\n\n/**\n * Executes registered validation rules for this document.\n *\n * #### Note:\n *\n * This method is called `pre` save and if a validation rule is violated, [save](https://mongoosejs.com/docs/api/model.html#Model.prototype.save()) is aborted and the error is thrown.\n *\n * #### Example:\n *\n *     await doc.validate({ validateModifiedOnly: false, pathsToSkip: ['name', 'email']});\n *\n * @param {Array|String} [pathsToValidate] list of paths to validate. If set, Mongoose will validate only the modified paths that are in the given list.\n * @param {Object} [options] internal options\n * @param {Boolean} [options.validateModifiedOnly=false] if `true` mongoose validates only modified paths.\n * @param {Array|string} [options.pathsToSkip] list of paths to skip. If set, Mongoose will validate every modified path that is not in this list.\n * @return {Promise} Returns a Promise.\n * @api public\n */\n\nDocument.prototype.validate = async function validate(pathsToValidate, options) {\n  if (typeof pathsToValidate === 'function' || typeof options === 'function' || typeof arguments[2] === 'function') {\n    throw new MongooseError('Document.prototype.validate() no longer accepts a callback');\n  }\n  let parallelValidate;\n  this.$op = 'validate';\n\n  if (this.$isSubdocument != null) {\n    // Skip parallel validate check for subdocuments\n  } else if (this.$__.validating) {\n    parallelValidate = new ParallelValidateError(this, {\n      parentStack: options && options.parentStack,\n      conflictStack: this.$__.validating.stack\n    });\n  } else {\n    this.$__.validating = new ParallelValidateError(this, { parentStack: options && options.parentStack });\n  }\n\n  if (arguments.length === 1) {\n    if (typeof arguments[0] === 'object' && !Array.isArray(arguments[0])) {\n      options = arguments[0];\n      pathsToValidate = null;\n    }\n  }\n  if (options && typeof options.pathsToSkip === 'string') {\n    const isOnePathOnly = options.pathsToSkip.indexOf(' ') === -1;\n    options.pathsToSkip = isOnePathOnly ? [options.pathsToSkip] : options.pathsToSkip.split(' ');\n  }\n\n  if (parallelValidate != null) {\n    throw parallelValidate;\n  }\n\n  return new Promise((resolve, reject) => {\n    this.$__validate(pathsToValidate, options, (error) => {\n      this.$op = null;\n      this.$__.validating = null;\n      if (error != null) {\n        return reject(error);\n      }\n      resolve();\n    });\n  });\n};\n\n/**\n * Alias of [`.validate`](https://mongoosejs.com/docs/api/document.html#Document.prototype.validate())\n *\n * @method $validate\n * @memberOf Document\n * @api public\n */\n\nDocument.prototype.$validate = Document.prototype.validate;\n\n/*!\n * ignore\n */\n\nfunction _evaluateRequiredFunctions(doc) {\n  const requiredFields = Object.keys(doc.$__.activePaths.getStatePaths('require'));\n  let i = 0;\n  const len = requiredFields.length;\n  for (i = 0; i < len; ++i) {\n    const path = requiredFields[i];\n\n    const p = doc.$__schema.path(path);\n\n    if (p != null && typeof p.originalRequiredValue === 'function') {\n      doc.$__.cachedRequired = doc.$__.cachedRequired || {};\n      try {\n        doc.$__.cachedRequired[path] = p.originalRequiredValue.call(doc, doc);\n      } catch (err) {\n        doc.invalidate(path, err);\n      }\n    }\n  }\n}\n\n/*!\n * ignore\n */\n\nfunction _getPathsToValidate(doc, pathsToValidate, pathsToSkip) {\n  const doValidateOptions = {};\n\n  _evaluateRequiredFunctions(doc);\n  // only validate required fields when necessary\n  let paths = new Set(Object.keys(doc.$__.activePaths.getStatePaths('require')).filter(function(path) {\n    if (!doc.$__isSelected(path) && !doc.$isModified(path)) {\n      return false;\n    }\n    if (doc.$__.cachedRequired != null && path in doc.$__.cachedRequired) {\n      return doc.$__.cachedRequired[path];\n    }\n    return true;\n  }));\n\n  Object.keys(doc.$__.activePaths.getStatePaths('init')).forEach(addToPaths);\n  Object.keys(doc.$__.activePaths.getStatePaths('modify')).forEach(addToPaths);\n  Object.keys(doc.$__.activePaths.getStatePaths('default')).forEach(addToPaths);\n  function addToPaths(p) { paths.add(p); }\n\n  const subdocs = doc.$getAllSubdocs();\n  const modifiedPaths = doc.modifiedPaths();\n  for (const subdoc of subdocs) {\n    if (subdoc.$basePath) {\n      const fullPathToSubdoc = subdoc.$isSingleNested ? subdoc.$__pathRelativeToParent() : subdoc.$__fullPathWithIndexes();\n\n      // Remove child paths for now, because we'll be validating the whole\n      // subdoc.\n      // The following is a faster take on looping through every path in `paths`\n      // and checking if the path starts with `fullPathToSubdoc` re: gh-13191\n      for (const modifiedPath of subdoc.modifiedPaths()) {\n        paths.delete(fullPathToSubdoc + '.' + modifiedPath);\n      }\n\n      if (doc.$isModified(fullPathToSubdoc, modifiedPaths) &&\n            !doc.isDirectModified(fullPathToSubdoc) &&\n            !doc.$isDefault(fullPathToSubdoc)) {\n        paths.add(fullPathToSubdoc);\n        if (doc.$__.pathsToScopes == null) {\n          doc.$__.pathsToScopes = {};\n        }\n        doc.$__.pathsToScopes[fullPathToSubdoc] = subdoc.$isDocumentArrayElement ?\n          subdoc.__parentArray :\n          subdoc.$parent();\n\n        doValidateOptions[fullPathToSubdoc] = { skipSchemaValidators: true };\n        if (subdoc.$isDocumentArrayElement && subdoc.__index != null) {\n          doValidateOptions[fullPathToSubdoc].index = subdoc.__index;\n        }\n      }\n    }\n  }\n\n  for (const path of paths) {\n    const _pathType = doc.$__schema.path(path);\n    if (!_pathType) {\n      continue;\n    }\n\n    if (_pathType.$isMongooseDocumentArray) {\n      for (const p of paths) {\n        if (p == null || p.startsWith(_pathType.path + '.')) {\n          paths.delete(p);\n        }\n      }\n    }\n\n    // Optimization: if primitive path with no validators, or array of primitives\n    // with no validators, skip validating this path entirely.\n    if (!_pathType.caster && _pathType.validators.length === 0 && !_pathType.$parentSchemaDocArray) {\n      paths.delete(path);\n    } else if (_pathType.$isMongooseArray &&\n      !_pathType.$isMongooseDocumentArray && // Skip document arrays...\n      !_pathType.$embeddedSchemaType.$isMongooseArray && // and arrays of arrays\n      _pathType.validators.length === 0 && // and arrays with top-level validators\n      _pathType.$embeddedSchemaType.validators.length === 0) {\n      paths.delete(path);\n    }\n  }\n\n  for (const path of paths) {\n    // Single nested paths (paths embedded under single nested subdocs) will\n    // be validated on their own when we call `validate()` on the subdoc itself.\n    // Re: gh-8468\n    if (doc.$__schema.singleNestedPaths.hasOwnProperty(path)) {\n      paths.delete(path);\n      continue;\n    }\n  }\n\n  if (Array.isArray(pathsToValidate)) {\n    paths = _handlePathsToValidate(paths, pathsToValidate);\n  } else if (Array.isArray(pathsToSkip)) {\n    paths = _handlePathsToSkip(paths, pathsToSkip);\n  }\n\n  // from here on we're not removing items from paths\n\n  // gh-661: if a whole array is modified, make sure to run validation on all\n  // the children as well\n  for (const path of paths) {\n    const _pathType = doc.$__schema.path(path);\n    if (!_pathType) {\n      continue;\n    }\n\n    if (!_pathType.$isMongooseArray ||\n        // To avoid potential performance issues, skip doc arrays whose children\n        // are not required. `getPositionalPathType()` may be slow, so avoid\n        // it unless we have a case of #6364\n        (!Array.isArray(_pathType) &&\n          _pathType.$isMongooseDocumentArray &&\n          !(_pathType && _pathType.schemaOptions && _pathType.schemaOptions.required))) {\n      continue;\n    }\n\n    // gh-11380: optimization. If the array isn't a document array and there's no validators\n    // on the array type, there's no need to run validation on the individual array elements.\n    if (_pathType.$isMongooseArray &&\n        !_pathType.$isMongooseDocumentArray && // Skip document arrays...\n        !_pathType.$embeddedSchemaType.$isMongooseArray && // and arrays of arrays\n        _pathType.$embeddedSchemaType.validators.length === 0) {\n      continue;\n    }\n\n    const val = doc.$__getValue(path);\n    _pushNestedArrayPaths(val, paths, path);\n  }\n\n  function _pushNestedArrayPaths(val, paths, path) {\n    if (val != null) {\n      const numElements = val.length;\n      for (let j = 0; j < numElements; ++j) {\n        if (Array.isArray(val[j])) {\n          _pushNestedArrayPaths(val[j], paths, path + '.' + j);\n        } else {\n          paths.add(path + '.' + j);\n        }\n      }\n    }\n  }\n\n  const flattenOptions = { skipArrays: true };\n  for (const pathToCheck of paths) {\n    if (doc.$__schema.nested[pathToCheck]) {\n      let _v = doc.$__getValue(pathToCheck);\n      if (isMongooseObject(_v)) {\n        _v = _v.toObject({ transform: false });\n      }\n      const flat = flatten(_v, pathToCheck, flattenOptions, doc.$__schema);\n      Object.keys(flat).forEach(addToPaths);\n    }\n  }\n\n  for (const path of paths) {\n    const _pathType = doc.$__schema.path(path);\n\n    if (!_pathType) {\n      continue;\n    }\n\n    // If underneath a document array, may need to re-validate the parent\n    // array re: gh-6818. Do this _after_ adding subpaths, because\n    // we don't want to add every array subpath.\n    if (_pathType.$parentSchemaDocArray && typeof _pathType.$parentSchemaDocArray.path === 'string') {\n      paths.add(_pathType.$parentSchemaDocArray.path);\n    }\n\n    if (!_pathType.$isSchemaMap) {\n      continue;\n    }\n\n    const val = doc.$__getValue(path);\n    if (val == null) {\n      continue;\n    }\n    for (const key of val.keys()) {\n      paths.add(path + '.' + key);\n    }\n  }\n\n  paths = Array.from(paths);\n  return [paths, doValidateOptions];\n}\n\n/*!\n * ignore\n */\n\nDocument.prototype.$__validate = function(pathsToValidate, options, callback) {\n  if (typeof pathsToValidate === 'function') {\n    callback = pathsToValidate;\n    options = null;\n    pathsToValidate = null;\n  } else if (typeof options === 'function') {\n    callback = options;\n    options = null;\n  }\n\n  const hasValidateModifiedOnlyOption = options &&\n      (typeof options === 'object') &&\n      ('validateModifiedOnly' in options);\n\n  const pathsToSkip = (options && options.pathsToSkip) || null;\n\n  let shouldValidateModifiedOnly;\n  if (hasValidateModifiedOnlyOption) {\n    shouldValidateModifiedOnly = !!options.validateModifiedOnly;\n  } else {\n    shouldValidateModifiedOnly = this.$__schema.options.validateModifiedOnly;\n  }\n\n  const _this = this;\n  const _complete = () => {\n    let validationError = this.$__.validationError;\n    this.$__.validationError = null;\n    this.$__.validating = null;\n\n    if (shouldValidateModifiedOnly && validationError != null) {\n      // Remove any validation errors that aren't from modified paths\n      const errors = Object.keys(validationError.errors);\n      for (const errPath of errors) {\n        if (!this.$isModified(errPath)) {\n          delete validationError.errors[errPath];\n        }\n      }\n      if (Object.keys(validationError.errors).length === 0) {\n        validationError = void 0;\n      }\n    }\n\n    this.$__.cachedRequired = {};\n    this.$emit('validate', _this);\n    this.constructor.emit('validate', _this);\n\n    if (validationError) {\n      for (const key in validationError.errors) {\n        // Make sure cast errors persist\n        if (!this[documentArrayParent] &&\n            validationError.errors[key] instanceof MongooseError.CastError) {\n          this.invalidate(key, validationError.errors[key]);\n        }\n      }\n\n      return validationError;\n    }\n  };\n\n  // only validate required fields when necessary\n  const pathDetails = _getPathsToValidate(this, pathsToValidate, pathsToSkip);\n  const paths = shouldValidateModifiedOnly ?\n    pathDetails[0].filter((path) => this.$isModified(path)) :\n    pathDetails[0];\n  const doValidateOptionsByPath = pathDetails[1];\n  if (typeof pathsToValidate === 'string') {\n    pathsToValidate = pathsToValidate.split(' ');\n  }\n\n  if (paths.length === 0) {\n    return immediate(function() {\n      const error = _complete();\n      if (error) {\n        return _this.$__schema.s.hooks.execPost('validate:error', _this, [_this], { error: error }, function(error) {\n          callback(error);\n        });\n      }\n      callback(null, _this);\n    });\n  }\n\n  const validated = {};\n  let total = 0;\n\n  for (const path of paths) {\n    validatePath(path);\n  }\n\n  function validatePath(path) {\n    if (path == null || validated[path]) {\n      return;\n    }\n\n    validated[path] = true;\n    total++;\n\n    immediate(function() {\n      const schemaType = _this.$__schema.path(path);\n\n      if (!schemaType) {\n        return --total || complete();\n      }\n\n      // If user marked as invalid or there was a cast error, don't validate\n      if (!_this.$isValid(path)) {\n        --total || complete();\n        return;\n      }\n\n      // If setting a path under a mixed path, avoid using the mixed path validator (gh-10141)\n      if (schemaType[schemaMixedSymbol] != null && path !== schemaType.path) {\n        return --total || complete();\n      }\n\n      let val = _this.$__getValue(path);\n\n      // If you `populate()` and get back a null value, required validators\n      // shouldn't fail (gh-8018). We should always fall back to the populated\n      // value.\n      let pop;\n      if ((pop = _this.$populated(path))) {\n        val = pop;\n      } else if (val != null && val.$__ != null && val.$__.wasPopulated) {\n        // Array paths, like `somearray.1`, do not show up as populated with `$populated()`,\n        // so in that case pull out the document's id\n        val = val._id;\n      }\n      const scope = _this.$__.pathsToScopes != null && path in _this.$__.pathsToScopes ?\n        _this.$__.pathsToScopes[path] :\n        _this;\n\n      const doValidateOptions = {\n        ...doValidateOptionsByPath[path],\n        path: path,\n        validateModifiedOnly: shouldValidateModifiedOnly\n      };\n\n      schemaType.doValidate(val, function(err) {\n        if (err) {\n          const isSubdoc = schemaType.$isSingleNested ||\n              schemaType.$isArraySubdocument ||\n              schemaType.$isMongooseDocumentArray;\n          if (isSubdoc && err instanceof ValidationError) {\n            return --total || complete();\n          }\n          _this.invalidate(path, err, undefined, true);\n        }\n        --total || complete();\n      }, scope, doValidateOptions);\n    });\n  }\n\n  function complete() {\n    const error = _complete();\n    if (error) {\n      return _this.$__schema.s.hooks.execPost('validate:error', _this, [_this], { error: error }, function(error) {\n        callback(error);\n      });\n    }\n    callback(null, _this);\n  }\n\n};\n\n/*!\n * ignore\n */\n\nfunction _handlePathsToValidate(paths, pathsToValidate) {\n  const _pathsToValidate = new Set(pathsToValidate);\n  const parentPaths = new Map([]);\n  for (const path of pathsToValidate) {\n    if (path.indexOf('.') === -1) {\n      continue;\n    }\n    const pieces = path.split('.');\n    let cur = pieces[0];\n    for (let i = 1; i < pieces.length; ++i) {\n      // Since we skip subpaths under single nested subdocs to\n      // avoid double validation, we need to add back the\n      // single nested subpath if the user asked for it (gh-8626)\n      parentPaths.set(cur, path);\n      cur = cur + '.' + pieces[i];\n    }\n  }\n\n  const ret = new Set();\n  for (const path of paths) {\n    if (_pathsToValidate.has(path)) {\n      ret.add(path);\n    } else if (parentPaths.has(path)) {\n      ret.add(parentPaths.get(path));\n    }\n  }\n  return ret;\n}\n\n/*!\n * ignore\n */\n\nfunction _handlePathsToSkip(paths, pathsToSkip) {\n  pathsToSkip = new Set(pathsToSkip);\n  paths = Array.from(paths).filter(p => !pathsToSkip.has(p));\n  return new Set(paths);\n}\n\n/**\n * Executes registered validation rules (skipping asynchronous validators) for this document.\n *\n * #### Note:\n *\n * This method is useful if you need synchronous validation.\n *\n * #### Example:\n *\n *     const err = doc.validateSync();\n *     if (err) {\n *       handleError(err);\n *     } else {\n *       // validation passed\n *     }\n *\n * @param {Array|string} [pathsToValidate] only validate the given paths\n * @param {Object} [options] options for validation\n * @param {Boolean} [options.validateModifiedOnly=false] If `true`, Mongoose will only validate modified paths, as opposed to modified paths and `required` paths.\n * @param {Array|string} [options.pathsToSkip] list of paths to skip. If set, Mongoose will validate every modified path that is not in this list.\n * @return {ValidationError|undefined} ValidationError if there are errors during validation, or undefined if there is no error.\n * @api public\n */\n\nDocument.prototype.validateSync = function(pathsToValidate, options) {\n  const _this = this;\n\n  if (arguments.length === 1 && typeof arguments[0] === 'object' && !Array.isArray(arguments[0])) {\n    options = arguments[0];\n    pathsToValidate = null;\n  }\n\n  const hasValidateModifiedOnlyOption = options &&\n      (typeof options === 'object') &&\n      ('validateModifiedOnly' in options);\n\n  let shouldValidateModifiedOnly;\n  if (hasValidateModifiedOnlyOption) {\n    shouldValidateModifiedOnly = !!options.validateModifiedOnly;\n  } else {\n    shouldValidateModifiedOnly = this.$__schema.options.validateModifiedOnly;\n  }\n\n  let pathsToSkip = options && options.pathsToSkip;\n\n  if (typeof pathsToValidate === 'string') {\n    const isOnePathOnly = pathsToValidate.indexOf(' ') === -1;\n    pathsToValidate = isOnePathOnly ? [pathsToValidate] : pathsToValidate.split(' ');\n  } else if (typeof pathsToSkip === 'string' && pathsToSkip.indexOf(' ') !== -1) {\n    pathsToSkip = pathsToSkip.split(' ');\n  }\n\n  // only validate required fields when necessary\n  const pathDetails = _getPathsToValidate(this, pathsToValidate, pathsToSkip);\n  const paths = shouldValidateModifiedOnly ?\n    pathDetails[0].filter((path) => this.$isModified(path)) :\n    pathDetails[0];\n  const skipSchemaValidators = pathDetails[1];\n\n  const validating = {};\n\n  for (let i = 0, len = paths.length; i < len; ++i) {\n    const path = paths[i];\n\n    if (validating[path]) {\n      continue;\n    }\n\n    validating[path] = true;\n\n    const p = _this.$__schema.path(path);\n    if (!p) {\n      continue;\n    }\n    if (!_this.$isValid(path)) {\n      continue;\n    }\n\n    const val = _this.$__getValue(path);\n    const err = p.doValidateSync(val, _this, {\n      skipSchemaValidators: skipSchemaValidators[path],\n      path: path,\n      validateModifiedOnly: shouldValidateModifiedOnly\n    });\n    if (err) {\n      const isSubdoc = p.$isSingleNested ||\n        p.$isArraySubdocument ||\n        p.$isMongooseDocumentArray;\n      if (isSubdoc && err instanceof ValidationError) {\n        continue;\n      }\n      _this.invalidate(path, err, undefined, true);\n    }\n  }\n\n  const err = _this.$__.validationError;\n  _this.$__.validationError = undefined;\n  _this.$emit('validate', _this);\n  _this.constructor.emit('validate', _this);\n\n  if (err) {\n    for (const key in err.errors) {\n      // Make sure cast errors persist\n      if (err.errors[key] instanceof MongooseError.CastError) {\n        _this.invalidate(key, err.errors[key]);\n      }\n    }\n  }\n\n  return err;\n};\n\n/**\n * Marks a path as invalid, causing validation to fail.\n *\n * The `errorMsg` argument will become the message of the `ValidationError`.\n *\n * The `value` argument (if passed) will be available through the `ValidationError.value` property.\n *\n *     doc.invalidate('size', 'must be less than 20', 14);\n *\n *     doc.validate(function (err) {\n *       console.log(err)\n *       // prints\n *       { message: 'Validation failed',\n *         name: 'ValidationError',\n *         errors:\n *          { size:\n *             { message: 'must be less than 20',\n *               name: 'ValidatorError',\n *               path: 'size',\n *               type: 'user defined',\n *               value: 14 } } }\n *     })\n *\n * @param {String} path the field to invalidate. For array elements, use the `array.i.field` syntax, where `i` is the 0-based index in the array.\n * @param {String|Error} err the error which states the reason `path` was invalid\n * @param {Object|String|Number|any} val optional invalid value\n * @param {String} [kind] optional `kind` property for the error\n * @return {ValidationError} the current ValidationError, with all currently invalidated paths\n * @api public\n */\n\nDocument.prototype.invalidate = function(path, err, val, kind) {\n  if (!this.$__.validationError) {\n    this.$__.validationError = new ValidationError(this);\n  }\n\n  if (this.$__.validationError.errors[path]) {\n    return;\n  }\n\n  if (!err || typeof err === 'string') {\n    err = new ValidatorError({\n      path: path,\n      message: err,\n      type: kind || 'user defined',\n      value: val\n    });\n  }\n\n  if (this.$__.validationError === err) {\n    return this.$__.validationError;\n  }\n\n  this.$__.validationError.addError(path, err);\n  return this.$__.validationError;\n};\n\n/**\n * Marks a path as valid, removing existing validation errors.\n *\n * @param {String} path the field to mark as valid\n * @api public\n * @memberOf Document\n * @instance\n * @method $markValid\n */\n\nDocument.prototype.$markValid = function(path) {\n  if (!this.$__.validationError || !this.$__.validationError.errors[path]) {\n    return;\n  }\n\n  delete this.$__.validationError.errors[path];\n  if (Object.keys(this.$__.validationError.errors).length === 0) {\n    this.$__.validationError = null;\n  }\n};\n\n/*!\n * ignore\n */\n\nfunction _markValidSubpaths(doc, path) {\n  if (!doc.$__.validationError) {\n    return;\n  }\n\n  const keys = Object.keys(doc.$__.validationError.errors);\n  for (const key of keys) {\n    if (key.startsWith(path + '.')) {\n      delete doc.$__.validationError.errors[key];\n    }\n  }\n  if (Object.keys(doc.$__.validationError.errors).length === 0) {\n    doc.$__.validationError = null;\n  }\n}\n\n/*!\n * ignore\n */\n\nfunction _checkImmutableSubpaths(subdoc, schematype, priorVal) {\n  const schema = schematype.schema;\n  if (schema == null) {\n    return;\n  }\n\n  for (const key of Object.keys(schema.paths)) {\n    const path = schema.paths[key];\n    if (path.$immutableSetter == null) {\n      continue;\n    }\n    const oldVal = priorVal == null ? void 0 : priorVal.$__getValue(key);\n    // Calling immutableSetter with `oldVal` even though it expects `newVal`\n    // is intentional. That's because `$immutableSetter` compares its param\n    // to the current value.\n    path.$immutableSetter.call(subdoc, oldVal);\n  }\n}\n\n/**\n * Saves this document by inserting a new document into the database if [document.isNew](https://mongoosejs.com/docs/api/document.html#Document.prototype.isNew()) is `true`,\n * or sends an [updateOne](https://mongoosejs.com/docs/api/document.html#Document.prototype.updateOne()) operation **only** with the modifications to the database, it does not replace the whole document in the latter case.\n *\n * #### Example:\n *\n *     product.sold = Date.now();\n *     product = await product.save();\n *\n * If save is successful, the returned promise will fulfill with the document\n * saved.\n *\n * #### Example:\n *\n *     const newProduct = await product.save();\n *     newProduct === product; // true\n *\n * @param {Object} [options] options optional options\n * @param {Session} [options.session=null] the [session](https://www.mongodb.com/docs/manual/reference/server-sessions/) associated with this save operation. If not specified, defaults to the [document's associated session](https://mongoosejs.com/docs/api/document.html#Document.prototype.$session()).\n * @param {Object} [options.safe] (DEPRECATED) overrides [schema's safe option](https://mongoosejs.com/docs/guide.html#safe). Use the `w` option instead.\n * @param {Boolean} [options.validateBeforeSave] set to false to save without validating.\n * @param {Boolean} [options.validateModifiedOnly=false] If `true`, Mongoose will only validate modified paths, as opposed to modified paths and `required` paths.\n * @param {Number|String} [options.w] set the [write concern](https://www.mongodb.com/docs/manual/reference/write-concern/#w-option). Overrides the [schema-level `writeConcern` option](https://mongoosejs.com/docs/guide.html#writeConcern)\n * @param {Boolean} [options.j] set to true for MongoDB to wait until this `save()` has been [journaled before resolving the returned promise](https://www.mongodb.com/docs/manual/reference/write-concern/#j-option). Overrides the [schema-level `writeConcern` option](https://mongoosejs.com/docs/guide.html#writeConcern)\n * @param {Number} [options.wtimeout] sets a [timeout for the write concern](https://www.mongodb.com/docs/manual/reference/write-concern/#wtimeout). Overrides the [schema-level `writeConcern` option](https://mongoosejs.com/docs/guide.html#writeConcern).\n * @param {Boolean} [options.checkKeys=true] the MongoDB driver prevents you from saving keys that start with '$' or contain '.' by default. Set this option to `false` to skip that check. See [restrictions on field names](https://www.mongodb.com/docs/manual/reference/limits/#Restrictions-on-Field-Names)\n * @param {Boolean} [options.timestamps=true] if `false` and [timestamps](https://mongoosejs.com/docs/guide.html#timestamps) are enabled, skip timestamps for this `save()`.\n * @param {Function} [fn] optional callback\n * @method save\n * @memberOf Document\n * @instance\n * @throws {DocumentNotFoundError} if this [save updates an existing document](https://mongoosejs.com/docs/api/document.html#Document.prototype.isNew()) but the document doesn't exist in the database. For example, you will get this error if the document is [deleted between when you retrieved the document and when you saved it](documents.html#updating).\n * @return {Promise|undefined} Returns undefined if used with callback or a Promise otherwise.\n * @api public\n * @see middleware https://mongoosejs.com/docs/middleware.html\n */\n\n/**\n * Checks if a path is invalid\n *\n * @param {String|String[]} [path] the field to check. If unset will always return \"false\"\n * @method $isValid\n * @memberOf Document\n * @instance\n * @api private\n */\n\nDocument.prototype.$isValid = function(path) {\n  if (this.$__.validationError == null || Object.keys(this.$__.validationError.errors).length === 0) {\n    return true;\n  }\n  if (path == null) {\n    return false;\n  }\n\n  if (path.indexOf(' ') !== -1) {\n    path = path.split(' ');\n  }\n  if (Array.isArray(path)) {\n    return path.some(p => this.$__.validationError.errors[p] == null);\n  }\n\n  return this.$__.validationError.errors[path] == null;\n};\n\n/**\n * Resets the internal modified state of this document.\n *\n * @api private\n * @return {Document} this\n * @method $__reset\n * @memberOf Document\n * @instance\n */\n\nDocument.prototype.$__reset = function reset() {\n  let _this = this;\n\n  // Skip for subdocuments\n  const subdocs = this.$parent() === this ? this.$getAllSubdocs() : [];\n  const resetArrays = new Set();\n  for (const subdoc of subdocs) {\n    const fullPathWithIndexes = subdoc.$__fullPathWithIndexes();\n    subdoc.$__reset();\n    if (this.isModified(fullPathWithIndexes) || isParentInit(fullPathWithIndexes)) {\n      if (subdoc.$isDocumentArrayElement) {\n        resetArrays.add(subdoc.parentArray());\n      } else {\n        const parent = subdoc.$parent();\n        if (parent === this) {\n          this.$__.activePaths.clearPath(subdoc.$basePath);\n        } else if (parent != null && parent.$isSubdocument) {\n          // If map path underneath subdocument, may end up with a case where\n          // map path is modified but parent still needs to be reset. See gh-10295\n          parent.$__reset();\n        }\n      }\n    }\n  }\n\n  for (const array of resetArrays) {\n    this.$__.activePaths.clearPath(array.$path());\n    array[arrayAtomicsBackupSymbol] = array[arrayAtomicsSymbol];\n    array[arrayAtomicsSymbol] = {};\n  }\n\n  function isParentInit(path) {\n    path = path.indexOf('.') === -1 ? [path] : path.split('.');\n    let cur = '';\n    for (let i = 0; i < path.length; ++i) {\n      cur += (cur.length ? '.' : '') + path[i];\n      if (_this.$__.activePaths[cur] === 'init') {\n        return true;\n      }\n    }\n\n    return false;\n  }\n\n  // clear atomics\n  this.$__dirty().forEach(function(dirt) {\n    const type = dirt.value;\n\n    if (type && type[arrayAtomicsSymbol]) {\n      type[arrayAtomicsBackupSymbol] = type[arrayAtomicsSymbol];\n      type[arrayAtomicsSymbol] = {};\n    }\n  });\n\n  this.$__.backup = {};\n  this.$__.backup.activePaths = {\n    modify: Object.assign({}, this.$__.activePaths.getStatePaths('modify')),\n    default: Object.assign({}, this.$__.activePaths.getStatePaths('default'))\n  };\n  this.$__.backup.validationError = this.$__.validationError;\n  this.$__.backup.errors = this.$errors;\n\n  // Clear 'dirty' cache\n  this.$__.activePaths.clear('modify');\n  this.$__.activePaths.clear('default');\n  this.$__.validationError = undefined;\n  this.$errors = undefined;\n  _this = this;\n  this.$__schema.requiredPaths().forEach(function(path) {\n    _this.$__.activePaths.require(path);\n  });\n\n  return this;\n};\n\n/*!\n * ignore\n */\n\nDocument.prototype.$__undoReset = function $__undoReset() {\n  if (this.$__.backup == null || this.$__.backup.activePaths == null) {\n    return;\n  }\n\n  this.$__.activePaths.states.modify = this.$__.backup.activePaths.modify;\n  this.$__.activePaths.states.default = this.$__.backup.activePaths.default;\n\n  this.$__.validationError = this.$__.backup.validationError;\n  this.$errors = this.$__.backup.errors;\n\n  for (const dirt of this.$__dirty()) {\n    const type = dirt.value;\n\n    if (type && type[arrayAtomicsSymbol] && type[arrayAtomicsBackupSymbol]) {\n      type[arrayAtomicsSymbol] = type[arrayAtomicsBackupSymbol];\n    }\n  }\n\n  for (const subdoc of this.$getAllSubdocs()) {\n    subdoc.$__undoReset();\n  }\n};\n\n/**\n * Returns this documents dirty paths / vals.\n *\n * @return {Array}\n * @api private\n * @method $__dirty\n * @memberOf Document\n * @instance\n */\n\nDocument.prototype.$__dirty = function() {\n  const _this = this;\n  let all = this.$__.activePaths.map('modify', function(path) {\n    return {\n      path: path,\n      value: _this.$__getValue(path),\n      schema: _this.$__path(path)\n    };\n  });\n\n  // gh-2558: if we had to set a default and the value is not undefined,\n  // we have to save as well\n  all = all.concat(this.$__.activePaths.map('default', function(path) {\n    if (path === '_id' || _this.$__getValue(path) == null) {\n      return;\n    }\n    return {\n      path: path,\n      value: _this.$__getValue(path),\n      schema: _this.$__path(path)\n    };\n  }));\n\n  const allPaths = new Map(all.filter((el) => el != null).map((el) => [el.path, el.value]));\n  // Ignore \"foo.a\" if \"foo\" is dirty already.\n  const minimal = [];\n\n  all.forEach(function(item) {\n    if (!item) {\n      return;\n    }\n\n    let top = null;\n\n    const array = parentPaths(item.path);\n    for (let i = 0; i < array.length - 1; i++) {\n      if (allPaths.has(array[i])) {\n        top = allPaths.get(array[i]);\n        break;\n      }\n    }\n    if (top == null) {\n      minimal.push(item);\n    } else if (top != null &&\n        top[arrayAtomicsSymbol] != null &&\n        top.hasAtomics()) {\n      // special case for top level MongooseArrays\n      // the `top` array itself and a sub path of `top` are being set.\n      // the only way to honor all of both modifications is through a $set\n      // of entire array.\n      top[arrayAtomicsSymbol] = {};\n      top[arrayAtomicsSymbol].$set = top;\n    }\n  });\n  return minimal;\n};\n\n/**\n * Assigns/compiles `schema` into this documents prototype.\n *\n * @param {Schema} schema\n * @api private\n * @method $__setSchema\n * @memberOf Document\n * @instance\n */\n\nDocument.prototype.$__setSchema = function(schema) {\n  compile(schema.tree, this, undefined, schema.options);\n\n  // Apply default getters if virtual doesn't have any (gh-6262)\n  for (const key of Object.keys(schema.virtuals)) {\n    schema.virtuals[key]._applyDefaultGetters();\n  }\n  if (schema.path('schema') == null) {\n    this.schema = schema;\n  }\n  this.$__schema = schema;\n  this[documentSchemaSymbol] = schema;\n};\n\n\n/**\n * Get active path that were changed and are arrays\n *\n * @return {Array}\n * @api private\n * @method $__getArrayPathsToValidate\n * @memberOf Document\n * @instance\n */\n\nDocument.prototype.$__getArrayPathsToValidate = function() {\n  DocumentArray || (DocumentArray = __webpack_require__(/*! ./types/documentArray */ \"(ssr)/./node_modules/mongoose/lib/types/documentArray/index.js\"));\n\n  // validate all document arrays.\n  return this.$__.activePaths\n    .map('init', 'modify', function(i) {\n      return this.$__getValue(i);\n    }.bind(this))\n    .filter(function(val) {\n      return val && Array.isArray(val) && utils.isMongooseDocumentArray(val) && val.length;\n    }).reduce(function(seed, array) {\n      return seed.concat(array);\n    }, [])\n    .filter(function(doc) {\n      return doc;\n    });\n};\n\n\n/**\n * Get all subdocs (by bfs)\n *\n * @return {Array}\n * @api public\n * @method $getAllSubdocs\n * @memberOf Document\n * @instance\n */\n\nDocument.prototype.$getAllSubdocs = function() {\n  DocumentArray || (DocumentArray = __webpack_require__(/*! ./types/documentArray */ \"(ssr)/./node_modules/mongoose/lib/types/documentArray/index.js\"));\n  Embedded = Embedded || __webpack_require__(/*! ./types/arraySubdocument */ \"(ssr)/./node_modules/mongoose/lib/types/arraySubdocument.js\");\n\n  function docReducer(doc, seed, path) {\n    let val = doc;\n    let isNested = false;\n    if (path) {\n      if (doc instanceof Document && doc[documentSchemaSymbol].paths[path]) {\n        val = doc._doc[path];\n      } else if (doc instanceof Document && doc[documentSchemaSymbol].nested[path]) {\n        val = doc._doc[path];\n        isNested = true;\n      } else {\n        val = doc[path];\n      }\n    }\n    if (val instanceof Embedded) {\n      seed.push(val);\n    } else if (val instanceof Map) {\n      seed = Array.from(val.keys()).reduce(function(seed, path) {\n        return docReducer(val.get(path), seed, null);\n      }, seed);\n    } else if (val && !Array.isArray(val) && val.$isSingleNested) {\n      seed = Object.keys(val._doc).reduce(function(seed, path) {\n        return docReducer(val, seed, path);\n      }, seed);\n      seed.push(val);\n    } else if (val && utils.isMongooseDocumentArray(val)) {\n      val.forEach(function _docReduce(doc) {\n        if (!doc || !doc._doc) {\n          return;\n        }\n        seed = Object.keys(doc._doc).reduce(function(seed, path) {\n          return docReducer(doc._doc, seed, path);\n        }, seed);\n        if (doc instanceof Embedded) {\n          seed.push(doc);\n        }\n      });\n    } else if (isNested && val != null) {\n      for (const path of Object.keys(val)) {\n        docReducer(val, seed, path);\n      }\n    }\n    return seed;\n  }\n\n  const subDocs = [];\n  for (const path of Object.keys(this._doc)) {\n    docReducer(this, subDocs, path);\n  }\n\n  return subDocs;\n};\n\n/*!\n * Runs queued functions\n */\n\nfunction applyQueue(doc) {\n  const q = doc.$__schema && doc.$__schema.callQueue;\n  if (!q.length) {\n    return;\n  }\n\n  for (const pair of q) {\n    if (pair[0] !== 'pre' && pair[0] !== 'post' && pair[0] !== 'on') {\n      doc[pair[0]].apply(doc, pair[1]);\n    }\n  }\n}\n\n/*!\n * ignore\n */\n\nDocument.prototype.$__handleReject = function handleReject(err) {\n  // emit on the Model if listening\n  if (this.$listeners('error').length) {\n    this.$emit('error', err);\n  } else if (this.constructor.listeners && this.constructor.listeners('error').length) {\n    this.constructor.emit('error', err);\n  }\n};\n\n/**\n * Internal helper for toObject() and toJSON() that doesn't manipulate options\n *\n * @return {Object}\n * @api private\n * @method $toObject\n * @memberOf Document\n * @instance\n */\n\nDocument.prototype.$toObject = function(options, json) {\n  let defaultOptions = {\n    transform: true,\n    flattenDecimals: true\n  };\n\n  const path = json ? 'toJSON' : 'toObject';\n  const baseOptions = this.constructor &&\n    this.constructor.base &&\n    this.constructor.base.options &&\n    get(this.constructor.base.options, path) || {};\n  const schemaOptions = this.$__schema && this.$__schema.options || {};\n  // merge base default options with Schema's set default options if available.\n  // `clone` is necessary here because `utils.options` directly modifies the second input.\n  defaultOptions = utils.options(defaultOptions, clone(baseOptions));\n  defaultOptions = utils.options(defaultOptions, clone(schemaOptions[path] || {}));\n\n  // If options do not exist or is not an object, set it to empty object\n  options = utils.isPOJO(options) ? { ...options } : {};\n  options._calledWithOptions = options._calledWithOptions || { ...options };\n\n  let _minimize;\n  if (options._calledWithOptions.minimize != null) {\n    _minimize = options.minimize;\n  } else if (defaultOptions.minimize != null) {\n    _minimize = defaultOptions.minimize;\n  } else {\n    _minimize = schemaOptions.minimize;\n  }\n\n  let flattenMaps;\n  if (options._calledWithOptions.flattenMaps != null) {\n    flattenMaps = options.flattenMaps;\n  } else if (defaultOptions.flattenMaps != null) {\n    flattenMaps = defaultOptions.flattenMaps;\n  } else {\n    flattenMaps = schemaOptions.flattenMaps;\n  }\n\n  let flattenObjectIds;\n  if (options._calledWithOptions.flattenObjectIds != null) {\n    flattenObjectIds = options.flattenObjectIds;\n  } else if (defaultOptions.flattenObjectIds != null) {\n    flattenObjectIds = defaultOptions.flattenObjectIds;\n  } else {\n    flattenObjectIds = schemaOptions.flattenObjectIds;\n  }\n\n  // The original options that will be passed to `clone()`. Important because\n  // `clone()` will recursively call `$toObject()` on embedded docs, so we\n  // need the original options the user passed in, plus `_isNested` and\n  // `_parentOptions` for checking whether we need to depopulate.\n  const cloneOptions = Object.assign({}, options, {\n    _isNested: true,\n    json: json,\n    minimize: _minimize,\n    flattenMaps: flattenMaps,\n    flattenObjectIds: flattenObjectIds,\n    _seen: (options && options._seen) || new Map()\n  });\n\n  if (utils.hasUserDefinedProperty(options, 'getters')) {\n    cloneOptions.getters = options.getters;\n  }\n  if (utils.hasUserDefinedProperty(options, 'virtuals')) {\n    cloneOptions.virtuals = options.virtuals;\n  }\n\n  const depopulate = options.depopulate ||\n    (options._parentOptions && options._parentOptions.depopulate || false);\n  // _isNested will only be true if this is not the top level document, we\n  // should never depopulate the top-level document\n  if (depopulate && options._isNested && this.$__.wasPopulated) {\n    return clone(this.$__.wasPopulated.value || this._id, cloneOptions);\n  }\n\n  // merge default options with input options.\n  options = utils.options(defaultOptions, options);\n  options._isNested = true;\n  options.json = json;\n  options.minimize = _minimize;\n\n  cloneOptions._parentOptions = options;\n  cloneOptions._skipSingleNestedGetters = false;\n\n  const gettersOptions = Object.assign({}, cloneOptions);\n  gettersOptions._skipSingleNestedGetters = true;\n\n  // remember the root transform function\n  // to save it from being overwritten by sub-transform functions\n  const originalTransform = options.transform;\n\n  let ret = clone(this._doc, cloneOptions) || {};\n\n  if (options.getters) {\n    applyGetters(this, ret, gettersOptions);\n\n    if (options.minimize) {\n      ret = minimize(ret) || {};\n    }\n  }\n\n  if (options.virtuals || (options.getters && options.virtuals !== false)) {\n    applyVirtuals(this, ret, gettersOptions, options);\n  }\n\n  if (options.versionKey === false && this.$__schema.options.versionKey) {\n    delete ret[this.$__schema.options.versionKey];\n  }\n\n  let transform = options.transform;\n\n  // In the case where a subdocument has its own transform function, we need to\n  // check and see if the parent has a transform (options.transform) and if the\n  // child schema has a transform (this.schema.options.toObject) In this case,\n  // we need to adjust options.transform to be the child schema's transform and\n  // not the parent schema's\n  if (transform) {\n    applySchemaTypeTransforms(this, ret);\n  }\n\n  if (options.useProjection) {\n    omitDeselectedFields(this, ret);\n  }\n\n  if (transform === true || (schemaOptions.toObject && transform)) {\n    const opts = options.json ? schemaOptions.toJSON : schemaOptions.toObject;\n\n    if (opts) {\n      transform = (typeof options.transform === 'function' ? options.transform : opts.transform);\n    }\n  } else {\n    options.transform = originalTransform;\n  }\n\n  if (typeof transform === 'function') {\n    const xformed = transform(this, ret, options);\n    if (typeof xformed !== 'undefined') {\n      ret = xformed;\n    }\n  }\n\n  return ret;\n};\n\n/**\n * Converts this document into a plain-old JavaScript object ([POJO](https://masteringjs.io/tutorials/fundamentals/pojo)).\n *\n * Buffers are converted to instances of [mongodb.Binary](https://mongodb.github.io/node-mongodb-native/4.9/classes/Binary.html) for proper storage.\n *\n * #### Getters/Virtuals\n *\n * Example of only applying path getters\n *\n *     doc.toObject({ getters: true, virtuals: false })\n *\n * Example of only applying virtual getters\n *\n *     doc.toObject({ virtuals: true })\n *\n * Example of applying both path and virtual getters\n *\n *     doc.toObject({ getters: true })\n *\n * To apply these options to every document of your schema by default, set your [schemas](https://mongoosejs.com/docs/api/schema.html#Schema()) `toObject` option to the same argument.\n *\n *     schema.set('toObject', { virtuals: true })\n *\n * #### Transform:\n *\n * We may need to perform a transformation of the resulting object based on some criteria, say to remove some sensitive information or return a custom object. In this case we set the optional `transform` function.\n *\n * Transform functions receive three arguments\n *\n *     function (doc, ret, options) {}\n *\n * - `doc` The mongoose document which is being converted\n * - `ret` The plain object representation which has been converted\n * - `options` The options in use (either schema options or the options passed inline)\n *\n * #### Example:\n *\n *     // specify the transform schema option\n *     if (!schema.options.toObject) schema.options.toObject = {};\n *     schema.options.toObject.transform = function (doc, ret, options) {\n *       // remove the _id of every document before returning the result\n *       delete ret._id;\n *       return ret;\n *     }\n *\n *     // without the transformation in the schema\n *     doc.toObject(); // { _id: 'anId', name: 'Wreck-it Ralph' }\n *\n *     // with the transformation\n *     doc.toObject(); // { name: 'Wreck-it Ralph' }\n *\n * With transformations we can do a lot more than remove properties. We can even return completely new customized objects:\n *\n *     if (!schema.options.toObject) schema.options.toObject = {};\n *     schema.options.toObject.transform = function (doc, ret, options) {\n *       return { movie: ret.name }\n *     }\n *\n *     // without the transformation in the schema\n *     doc.toObject(); // { _id: 'anId', name: 'Wreck-it Ralph' }\n *\n *     // with the transformation\n *     doc.toObject(); // { movie: 'Wreck-it Ralph' }\n *\n * _Note: if a transform function returns `undefined`, the return value will be ignored._\n *\n * Transformations may also be applied inline, overridding any transform set in the options:\n *\n *     function xform (doc, ret, options) {\n *       return { inline: ret.name, custom: true }\n *     }\n *\n *     // pass the transform as an inline option\n *     doc.toObject({ transform: xform }); // { inline: 'Wreck-it Ralph', custom: true }\n *\n * If you want to skip transformations, use `transform: false`:\n *\n *     schema.options.toObject.hide = '_id';\n *     schema.options.toObject.transform = function (doc, ret, options) {\n *       if (options.hide) {\n *         options.hide.split(' ').forEach(function (prop) {\n *           delete ret[prop];\n *         });\n *       }\n *       return ret;\n *     }\n *\n *     const doc = new Doc({ _id: 'anId', secret: 47, name: 'Wreck-it Ralph' });\n *     doc.toObject();                                        // { secret: 47, name: 'Wreck-it Ralph' }\n *     doc.toObject({ hide: 'secret _id', transform: false });// { _id: 'anId', secret: 47, name: 'Wreck-it Ralph' }\n *     doc.toObject({ hide: 'secret _id', transform: true }); // { name: 'Wreck-it Ralph' }\n *\n * If you pass a transform in `toObject()` options, Mongoose will apply the transform\n * to [subdocuments](https://mongoosejs.com/docs/subdocs.html) in addition to the top-level document.\n * Similarly, `transform: false` skips transforms for all subdocuments.\n * Note that this behavior is different for transforms defined in the schema:\n * if you define a transform in `schema.options.toObject.transform`, that transform\n * will **not** apply to subdocuments.\n *\n *     const memberSchema = new Schema({ name: String, email: String });\n *     const groupSchema = new Schema({ members: [memberSchema], name: String, email });\n *     const Group = mongoose.model('Group', groupSchema);\n *\n *     const doc = new Group({\n *       name: 'Engineering',\n *       email: 'dev@mongoosejs.io',\n *       members: [{ name: 'Val', email: 'val@mongoosejs.io' }]\n *     });\n *\n *     // Removes `email` from both top-level document **and** array elements\n *     // { name: 'Engineering', members: [{ name: 'Val' }] }\n *     doc.toObject({ transform: (doc, ret) => { delete ret.email; return ret; } });\n *\n * Transforms, like all of these options, are also available for `toJSON`. See [this guide to `JSON.stringify()`](https://thecodebarbarian.com/the-80-20-guide-to-json-stringify-in-javascript.html) to learn why `toJSON()` and `toObject()` are separate functions.\n *\n * See [schema options](https://mongoosejs.com/docs/guide.html#toObject) for some more details.\n *\n * _During save, no custom options are applied to the document before being sent to the database._\n *\n * @param {Object} [options]\n * @param {Boolean} [options.getters=false] if true, apply all getters, including virtuals\n * @param {Boolean|Object} [options.virtuals=false] if true, apply virtuals, including aliases. Use `{ getters: true, virtuals: false }` to just apply getters, not virtuals. An object of the form `{ pathsToSkip: ['someVirtual'] }` may also be used to omit specific virtuals.\n * @param {Boolean} [options.aliases=true] if `options.virtuals = true`, you can set `options.aliases = false` to skip applying aliases. This option is a no-op if `options.virtuals = false`.\n * @param {Boolean} [options.minimize=true] if true, omit any empty objects from the output\n * @param {Function|null} [options.transform=null] if set, mongoose will call this function to allow you to transform the returned object\n * @param {Boolean} [options.depopulate=false] if true, replace any conventionally populated paths with the original id in the output. Has no affect on virtual populated paths.\n * @param {Boolean} [options.versionKey=true] if false, exclude the version key (`__v` by default) from the output\n * @param {Boolean} [options.flattenMaps=false] if true, convert Maps to POJOs. Useful if you want to `JSON.stringify()` the result of `toObject()`.\n * @param {Boolean} [options.flattenObjectIds=false] if true, convert any ObjectIds in the result to 24 character hex strings.\n * @param {Boolean} [options.useProjection=false] - If true, omits fields that are excluded in this document's projection. Unless you specified a projection, this will omit any field that has `select: false` in the schema.\n * @return {Object} js object (not a POJO)\n * @see mongodb.Binary https://mongodb.github.io/node-mongodb-native/4.9/classes/Binary.html\n * @api public\n * @memberOf Document\n * @instance\n */\n\nDocument.prototype.toObject = function(options) {\n  return this.$toObject(options);\n};\n\n/*!\n * Applies virtuals properties to `json`.\n */\n\nfunction applyVirtuals(self, json, options, toObjectOptions) {\n  const schema = self.$__schema;\n  const paths = Object.keys(schema.virtuals);\n  let i = paths.length;\n  const numPaths = i;\n  let path;\n  let assignPath;\n  let cur = self._doc;\n  let v;\n  const aliases = typeof (toObjectOptions && toObjectOptions.aliases) === 'boolean'\n    ? toObjectOptions.aliases\n    : true;\n\n  let virtualsToApply = null;\n  if (Array.isArray(options.virtuals)) {\n    virtualsToApply = new Set(options.virtuals);\n  } else if (options.virtuals && options.virtuals.pathsToSkip) {\n    virtualsToApply = new Set(paths);\n    for (let i = 0; i < options.virtuals.pathsToSkip.length; i++) {\n      if (virtualsToApply.has(options.virtuals.pathsToSkip[i])) {\n        virtualsToApply.delete(options.virtuals.pathsToSkip[i]);\n      }\n    }\n  }\n\n  if (!cur) {\n    return json;\n  }\n\n  options = options || {};\n  for (i = 0; i < numPaths; ++i) {\n    path = paths[i];\n\n    if (virtualsToApply != null && !virtualsToApply.has(path)) {\n      continue;\n    }\n\n    // Allow skipping aliases with `toObject({ virtuals: true, aliases: false })`\n    if (!aliases && schema.aliases.hasOwnProperty(path)) {\n      continue;\n    }\n\n    // We may be applying virtuals to a nested object, for example if calling\n    // `doc.nestedProp.toJSON()`. If so, the path we assign to, `assignPath`,\n    // will be a trailing substring of the `path`.\n    assignPath = path;\n    if (options.path != null) {\n      if (!path.startsWith(options.path + '.')) {\n        continue;\n      }\n      assignPath = path.substring(options.path.length + 1);\n    }\n    const parts = assignPath.split('.');\n    v = clone(self.get(path), options);\n    if (v === void 0) {\n      continue;\n    }\n    const plen = parts.length;\n    cur = json;\n    for (let j = 0; j < plen - 1; ++j) {\n      cur[parts[j]] = cur[parts[j]] || {};\n      cur = cur[parts[j]];\n    }\n    cur[parts[plen - 1]] = v;\n  }\n\n  return json;\n}\n\n\n/**\n * Applies virtuals properties to `json`.\n *\n * @param {Document} self\n * @param {Object} json\n * @param {Object} [options]\n * @return {Object} `json`\n * @api private\n */\n\nfunction applyGetters(self, json, options) {\n  const schema = self.$__schema;\n  const paths = Object.keys(schema.paths);\n  let i = paths.length;\n  let path;\n  let cur = self._doc;\n  let v;\n\n  if (!cur) {\n    return json;\n  }\n\n  while (i--) {\n    path = paths[i];\n\n    const parts = path.split('.');\n\n    const plen = parts.length;\n    const last = plen - 1;\n    let branch = json;\n    let part;\n    cur = self._doc;\n\n    if (!self.$__isSelected(path)) {\n      continue;\n    }\n\n    for (let ii = 0; ii < plen; ++ii) {\n      part = parts[ii];\n      v = cur[part];\n      if (ii === last) {\n        const val = self.$get(path);\n        branch[part] = clone(val, options);\n        if (Array.isArray(branch[part]) && schema.paths[path].$embeddedSchemaType) {\n          for (let i = 0; i < branch[part].length; ++i) {\n            branch[part][i] = schema.paths[path].$embeddedSchemaType.applyGetters(\n              branch[part][i],\n              self\n            );\n          }\n        }\n      } else if (v == null) {\n        if (part in cur) {\n          branch[part] = v;\n        }\n        break;\n      } else {\n        branch = branch[part] || (branch[part] = {});\n      }\n      cur = v;\n    }\n  }\n\n  return json;\n}\n\n/**\n * Applies schema type transforms to `json`.\n *\n * @param {Document} self\n * @param {Object} json\n * @return {Object} `json`\n * @api private\n */\n\nfunction applySchemaTypeTransforms(self, json) {\n  const schema = self.$__schema;\n  const paths = Object.keys(schema.paths || {});\n  const cur = self._doc;\n\n  if (!cur) {\n    return json;\n  }\n\n  for (const path of paths) {\n    const schematype = schema.paths[path];\n    if (typeof schematype.options.transform === 'function') {\n      const val = self.$get(path);\n      if (val === undefined) {\n        continue;\n      }\n      const transformedValue = schematype.options.transform.call(self, val);\n      throwErrorIfPromise(path, transformedValue);\n      utils.setValue(path, transformedValue, json);\n    } else if (schematype.$embeddedSchemaType != null &&\n        typeof schematype.$embeddedSchemaType.options.transform === 'function') {\n      const val = self.$get(path);\n      if (val === undefined) {\n        continue;\n      }\n      const vals = [].concat(val);\n      const transform = schematype.$embeddedSchemaType.options.transform;\n      for (let i = 0; i < vals.length; ++i) {\n        const transformedValue = transform.call(self, vals[i]);\n        vals[i] = transformedValue;\n        throwErrorIfPromise(path, transformedValue);\n      }\n\n      json[path] = vals;\n    }\n  }\n\n  return json;\n}\n\nfunction throwErrorIfPromise(path, transformedValue) {\n  if (isPromise(transformedValue)) {\n    throw new Error('`transform` function must be synchronous, but the transform on path `' + path + '` returned a promise.');\n  }\n}\n\n/*!\n * ignore\n */\n\nfunction omitDeselectedFields(self, json) {\n  const schema = self.$__schema;\n  const paths = Object.keys(schema.paths || {});\n  const cur = self._doc;\n\n  if (!cur) {\n    return json;\n  }\n\n  let selected = self.$__.selected;\n  if (selected === void 0) {\n    selected = {};\n    queryhelpers.applyPaths(selected, schema);\n  }\n  if (selected == null || Object.keys(selected).length === 0) {\n    return json;\n  }\n\n  for (const path of paths) {\n    if (selected[path] != null && !selected[path]) {\n      delete json[path];\n    }\n  }\n\n  return json;\n}\n\n/**\n * The return value of this method is used in calls to [`JSON.stringify(doc)`](https://thecodebarbarian.com/the-80-20-guide-to-json-stringify-in-javascript#the-tojson-function).\n *\n * This method accepts the same options as [Document#toObject](https://mongoosejs.com/docs/api/document.html#Document.prototype.toObject()). To apply the options to every document of your schema by default, set your [schemas](https://mongoosejs.com/docs/api/schema.html#Schema()) `toJSON` option to the same argument.\n *\n *     schema.set('toJSON', { virtuals: true });\n *\n * There is one difference between `toJSON()` and `toObject()` options.\n * When you call `toJSON()`, the [`flattenMaps` option](https://mongoosejs.com/docs/api/document.html#Document.prototype.toObject()) defaults to `true`, because `JSON.stringify()` doesn't convert maps to objects by default.\n * When you call `toObject()`, the `flattenMaps` option is `false` by default.\n *\n * See [schema options](https://mongoosejs.com/docs/guide.html#toJSON) for more information on setting `toJSON` option defaults.\n *\n * @param {Object} options\n * @param {Boolean} [options.flattenMaps=true] if true, convert Maps to [POJOs](https://masteringjs.io/tutorials/fundamentals/pojo). Useful if you want to `JSON.stringify()` the result.\n * @param {Boolean} [options.flattenObjectIds=false] if true, convert any ObjectIds in the result to 24 character hex strings.\n * @return {Object}\n * @see Document#toObject https://mongoosejs.com/docs/api/document.html#Document.prototype.toObject()\n * @see JSON.stringify() in JavaScript https://thecodebarbarian.com/the-80-20-guide-to-json-stringify-in-javascript.html\n * @api public\n * @memberOf Document\n * @instance\n */\n\nDocument.prototype.toJSON = function(options) {\n  return this.$toObject(options, true);\n};\n\n/*!\n * ignore\n */\n\nDocument.prototype.ownerDocument = function() {\n  return this;\n};\n\n\n/**\n * If this document is a subdocument or populated document, returns the document's\n * parent. Returns the original document if there is no parent.\n *\n * @return {Document}\n * @api public\n * @method parent\n * @memberOf Document\n * @instance\n */\n\nDocument.prototype.parent = function() {\n  if (this.$isSubdocument || this.$__.wasPopulated) {\n    return this.$__.parent;\n  }\n  return this;\n};\n\n/**\n * Alias for [`parent()`](https://mongoosejs.com/docs/api/document.html#Document.prototype.parent()). If this document is a subdocument or populated\n * document, returns the document's parent. Returns `undefined` otherwise.\n *\n * @return {Document}\n * @api public\n * @method $parent\n * @memberOf Document\n * @instance\n */\n\nDocument.prototype.$parent = Document.prototype.parent;\n\n/**\n * Helper for console.log\n *\n * @return {String}\n * @api public\n * @method inspect\n * @memberOf Document\n * @instance\n */\n\nDocument.prototype.inspect = function(options) {\n  const isPOJO = utils.isPOJO(options);\n  let opts;\n  if (isPOJO) {\n    opts = options;\n    opts.minimize = false;\n  }\n  const ret = this.toObject(opts);\n\n  if (ret == null) {\n    // If `toObject()` returns null, `this` is still an object, so if `inspect()`\n    // prints out null this can cause some serious confusion. See gh-7942.\n    return 'MongooseDocument { ' + ret + ' }';\n  }\n\n  return ret;\n};\n\nif (inspect.custom) {\n  // Avoid Node deprecation warning DEP0079\n  Document.prototype[inspect.custom] = Document.prototype.inspect;\n}\n\n/**\n * Helper for console.log\n *\n * @return {String}\n * @api public\n * @method toString\n * @memberOf Document\n * @instance\n */\n\nDocument.prototype.toString = function() {\n  const ret = this.inspect();\n  if (typeof ret === 'string') {\n    return ret;\n  }\n  return inspect(ret);\n};\n\n/**\n * Returns true if this document is equal to another document.\n *\n * Documents are considered equal when they have matching `_id`s, unless neither\n * document has an `_id`, in which case this function falls back to using\n * `deepEqual()`.\n *\n * @param {Document} [doc] a document to compare. If falsy, will always return \"false\".\n * @return {Boolean}\n * @api public\n * @memberOf Document\n * @instance\n */\n\nDocument.prototype.equals = function(doc) {\n  if (!doc) {\n    return false;\n  }\n\n  const tid = this.$__getValue('_id');\n  const docid = doc.$__ != null ? doc.$__getValue('_id') : doc;\n  if (!tid && !docid) {\n    return deepEqual(this, doc);\n  }\n  return tid && tid.equals\n    ? tid.equals(docid)\n    : tid === docid;\n};\n\n/**\n * Populates paths on an existing document.\n *\n * #### Example:\n *\n *     // Given a document, `populate()` lets you pull in referenced docs\n *     await doc.populate([\n *       'stories',\n *       { path: 'fans', sort: { name: -1 } }\n *     ]);\n *     doc.populated('stories'); // Array of ObjectIds\n *     doc.stories[0].title; // 'Casino Royale'\n *     doc.populated('fans'); // Array of ObjectIds\n *\n *     // If the referenced doc has been deleted, `populate()` will\n *     // remove that entry from the array.\n *     await Story.delete({ title: 'Casino Royale' });\n *     await doc.populate('stories'); // Empty array\n *\n *     // You can also pass additional query options to `populate()`,\n *     // like projections:\n *     await doc.populate('fans', '-email');\n *     doc.fans[0].email // undefined because of 2nd param `select`\n *\n * @param {String|Object|Array} path either the path to populate or an object specifying all parameters, or either an array of those\n * @param {Object|String} [select] Field selection for the population query\n * @param {Model} [model] The model you wish to use for population. If not specified, populate will look up the model by the name in the Schema's `ref` field.\n * @param {Object} [match] Conditions for the population query\n * @param {Object} [options] Options for the population query (sort, etc)\n * @param {String} [options.path=null] The path to populate.\n * @param {string|PopulateOptions} [options.populate=null] Recursively populate paths in the populated documents. See [deep populate docs](https://mongoosejs.com/docs/populate.html#deep-populate).\n * @param {boolean} [options.retainNullValues=false] by default, Mongoose removes null and undefined values from populated arrays. Use this option to make `populate()` retain `null` and `undefined` array entries.\n * @param {boolean} [options.getters=false] if true, Mongoose will call any getters defined on the `localField`. By default, Mongoose gets the raw value of `localField`. For example, you would need to set this option to `true` if you wanted to [add a `lowercase` getter to your `localField`](https://mongoosejs.com/docs/schematypes.html#schematype-options).\n * @param {boolean} [options.clone=false] When you do `BlogPost.find().populate('author')`, blog posts with the same author will share 1 copy of an `author` doc. Enable this option to make Mongoose clone populated docs before assigning them.\n * @param {Object|Function} [options.match=null] Add an additional filter to the populate query. Can be a filter object containing [MongoDB query syntax](https://www.mongodb.com/docs/manual/tutorial/query-documents/), or a function that returns a filter object.\n * @param {Function} [options.transform=null] Function that Mongoose will call on every populated document that allows you to transform the populated document.\n * @param {Object} [options.options=null] Additional options like `limit` and `lean`.\n * @param {Function} [callback] Callback\n * @see population https://mongoosejs.com/docs/populate.html\n * @see Query#select https://mongoosejs.com/docs/api/query.html#Query.prototype.select()\n * @see Model.populate https://mongoosejs.com/docs/api/model.html#Model.populate()\n * @memberOf Document\n * @instance\n * @return {Promise|null} Returns a Promise if no `callback` is given.\n * @api public\n */\n\nDocument.prototype.populate = async function populate() {\n  const pop = {};\n  const args = [...arguments];\n  if (typeof args[args.length - 1] === 'function') {\n    throw new MongooseError('Document.prototype.populate() no longer accepts a callback');\n  }\n\n  if (args.length !== 0) {\n    // use hash to remove duplicate paths\n    const res = utils.populate.apply(null, args);\n    for (const populateOptions of res) {\n      pop[populateOptions.path] = populateOptions;\n    }\n  }\n\n  const paths = utils.object.vals(pop);\n  let topLevelModel = this.constructor;\n  if (this.$__isNested) {\n    topLevelModel = this.$__[scopeSymbol].constructor;\n    const nestedPath = this.$__.nestedPath;\n    paths.forEach(function(populateOptions) {\n      populateOptions.path = nestedPath + '.' + populateOptions.path;\n    });\n  }\n\n  // Use `$session()` by default if the document has an associated session\n  // See gh-6754\n  if (this.$session() != null) {\n    const session = this.$session();\n    paths.forEach(path => {\n      if (path.options == null) {\n        path.options = { session: session };\n        return;\n      }\n      if (!('session' in path.options)) {\n        path.options.session = session;\n      }\n    });\n  }\n\n  paths.forEach(p => {\n    p._localModel = topLevelModel;\n  });\n\n  return topLevelModel.populate(this, paths);\n};\n\n/**\n * Gets all populated documents associated with this document.\n *\n * @api public\n * @return {Document[]} array of populated documents. Empty array if there are no populated documents associated with this document.\n * @memberOf Document\n * @method $getPopulatedDocs\n * @instance\n */\n\nDocument.prototype.$getPopulatedDocs = function $getPopulatedDocs() {\n  let keys = [];\n  if (this.$__.populated != null) {\n    keys = keys.concat(Object.keys(this.$__.populated));\n  }\n  let result = [];\n  for (const key of keys) {\n    const value = this.$get(key);\n    if (Array.isArray(value)) {\n      result = result.concat(value);\n    } else if (value instanceof Document) {\n      result.push(value);\n    }\n  }\n  return result;\n};\n\n/**\n * Gets _id(s) used during population of the given `path`.\n *\n * #### Example:\n *\n *     const doc = await Model.findOne().populate('author');\n *\n *     console.log(doc.author.name); // Dr.Seuss\n *     console.log(doc.populated('author')); // '5144cf8050f071d979c118a7'\n *\n * If the path was not populated, returns `undefined`.\n *\n * @param {String} path\n * @param {Any} [val]\n * @param {Object} [options]\n * @return {Array|ObjectId|Number|Buffer|String|undefined}\n * @memberOf Document\n * @instance\n * @api public\n */\n\nDocument.prototype.populated = function(path, val, options) {\n  // val and options are internal\n  if (val == null || val === true) {\n    if (!this.$__.populated) {\n      return undefined;\n    }\n    if (typeof path !== 'string') {\n      return undefined;\n    }\n\n    // Map paths can be populated with either `path.$*` or just `path`\n    const _path = path.endsWith('.$*') ? path.replace(/\\.\\$\\*$/, '') : path;\n\n    const v = this.$__.populated[_path];\n    if (v) {\n      return val === true ? v : v.value;\n    }\n    return undefined;\n  }\n\n  this.$__.populated || (this.$__.populated = {});\n  this.$__.populated[path] = { value: val, options: options };\n\n  // If this was a nested populate, make sure each populated doc knows\n  // about its populated children (gh-7685)\n  const pieces = path.split('.');\n  for (let i = 0; i < pieces.length - 1; ++i) {\n    const subpath = pieces.slice(0, i + 1).join('.');\n    const subdoc = this.$get(subpath);\n    if (subdoc != null && subdoc.$__ != null && this.$populated(subpath)) {\n      const rest = pieces.slice(i + 1).join('.');\n      subdoc.$populated(rest, val, options);\n      // No need to continue because the above recursion should take care of\n      // marking the rest of the docs as populated\n      break;\n    }\n  }\n\n  return val;\n};\n\n/**\n * Alias of [`.populated`](https://mongoosejs.com/docs/api/document.html#Document.prototype.populated()).\n *\n * @method $populated\n * @memberOf Document\n * @api public\n */\n\nDocument.prototype.$populated = Document.prototype.populated;\n\n/**\n * Throws an error if a given path is not populated\n *\n * #### Example:\n *\n *     const doc = await Model.findOne().populate('author');\n *\n *     doc.$assertPopulated('author'); // does not throw\n *     doc.$assertPopulated('other path'); // throws an error\n *\n *     // Manually populate and assert in one call. The following does\n *     // `doc.$set({ likes })` before asserting.\n *     doc.$assertPopulated('likes', { likes });\n *\n *\n * @param {String|String[]} path path or array of paths to check. `$assertPopulated` throws if any of the given paths is not populated.\n * @param {Object} [values] optional values to `$set()`. Convenient if you want to manually populate a path and assert that the path was populated in 1 call.\n * @return {Document} this\n * @memberOf Document\n * @method $assertPopulated\n * @instance\n * @api public\n */\n\nDocument.prototype.$assertPopulated = function $assertPopulated(path, values) {\n  if (Array.isArray(path)) {\n    path.forEach(p => this.$assertPopulated(p, values));\n    return this;\n  }\n\n  if (arguments.length > 1) {\n    this.$set(values);\n  }\n\n  if (!this.$populated(path)) {\n    throw new MongooseError(`Expected path \"${path}\" to be populated`);\n  }\n\n  return this;\n};\n\n/**\n * Takes a populated field and returns it to its unpopulated state.\n *\n * #### Example:\n *\n *     Model.findOne().populate('author').exec(function (err, doc) {\n *       console.log(doc.author.name); // Dr.Seuss\n *       console.log(doc.depopulate('author'));\n *       console.log(doc.author); // '5144cf8050f071d979c118a7'\n *     })\n *\n * If the path was not provided, then all populated fields are returned to their unpopulated state.\n *\n * @param {String|String[]} [path] Specific Path to depopulate. If unset, will depopulate all paths on the Document. Or multiple space-delimited paths.\n * @return {Document} this\n * @see Document.populate https://mongoosejs.com/docs/api/document.html#Document.prototype.populate()\n * @api public\n * @memberOf Document\n * @instance\n */\n\nDocument.prototype.depopulate = function(path) {\n  if (typeof path === 'string') {\n    path = path.indexOf(' ') === -1 ? [path] : path.split(' ');\n  }\n\n  let populatedIds;\n  const virtualKeys = this.$$populatedVirtuals ? Object.keys(this.$$populatedVirtuals) : [];\n  const populated = this.$__ && this.$__.populated || {};\n\n  if (arguments.length === 0) {\n    // Depopulate all\n    for (const virtualKey of virtualKeys) {\n      delete this.$$populatedVirtuals[virtualKey];\n      delete this._doc[virtualKey];\n      delete populated[virtualKey];\n    }\n\n    const keys = Object.keys(populated);\n\n    for (const key of keys) {\n      populatedIds = this.$populated(key);\n      if (!populatedIds) {\n        continue;\n      }\n      delete populated[key];\n      utils.setValue(key, populatedIds, this._doc);\n    }\n    return this;\n  }\n\n  for (const singlePath of path) {\n    populatedIds = this.$populated(singlePath);\n    delete populated[singlePath];\n\n    if (virtualKeys.indexOf(singlePath) !== -1) {\n      delete this.$$populatedVirtuals[singlePath];\n      delete this._doc[singlePath];\n    } else if (populatedIds) {\n      utils.setValue(singlePath, populatedIds, this._doc);\n    }\n  }\n  return this;\n};\n\n\n/**\n * Returns the full path to this document.\n *\n * @param {String} [path]\n * @return {String}\n * @api private\n * @method $__fullPath\n * @memberOf Document\n * @instance\n */\n\nDocument.prototype.$__fullPath = function(path) {\n  // overridden in SubDocuments\n  return path || '';\n};\n\n/**\n * Returns the changes that happened to the document\n * in the format that will be sent to MongoDB.\n *\n * #### Example:\n *\n *     const userSchema = new Schema({\n *       name: String,\n *       age: Number,\n *       country: String\n *     });\n *     const User = mongoose.model('User', userSchema);\n *     const user = await User.create({\n *       name: 'Hafez',\n *       age: 25,\n *       country: 'Egypt'\n *     });\n *\n *     // returns an empty object, no changes happened yet\n *     user.getChanges(); // { }\n *\n *     user.country = undefined;\n *     user.age = 26;\n *\n *     user.getChanges(); // { $set: { age: 26 }, { $unset: { country: 1 } } }\n *\n *     await user.save();\n *\n *     user.getChanges(); // { }\n *\n * Modifying the object that `getChanges()` returns does not affect the document's\n * change tracking state. Even if you `delete user.getChanges().$set`, Mongoose\n * will still send a `$set` to the server.\n *\n * @return {Object}\n * @api public\n * @method getChanges\n * @memberOf Document\n * @instance\n */\n\nDocument.prototype.getChanges = function() {\n  const delta = this.$__delta();\n  const changes = delta ? delta[1] : {};\n  return changes;\n};\n\n/**\n * Returns a copy of this document with a deep clone of `_doc` and `$__`.\n *\n * @return {Document} a copy of this document\n * @api public\n * @method $clone\n * @memberOf Document\n * @instance\n */\n\nDocument.prototype.$clone = function() {\n  const Model = this.constructor;\n  const clonedDoc = new Model();\n  clonedDoc.$isNew = this.$isNew;\n  if (this._doc) {\n    clonedDoc._doc = clone(this._doc);\n  }\n  if (this.$__) {\n    const Cache = this.$__.constructor;\n    const clonedCache = new Cache();\n    for (const key of Object.getOwnPropertyNames(this.$__)) {\n      if (key === 'activePaths') {\n        continue;\n      }\n      clonedCache[key] = clone(this.$__[key]);\n    }\n    Object.assign(clonedCache.activePaths, clone({ ...this.$__.activePaths }));\n    clonedDoc.$__ = clonedCache;\n  }\n  return clonedDoc;\n};\n\n/*!\n * Module exports.\n */\n\nDocument.ValidationError = ValidationError;\nmodule.exports = exports = Document;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbW9uZ29vc2UvbGliL2RvY3VtZW50LmpzIiwibWFwcGluZ3MiOiJBQUFhOztBQUViO0FBQ0E7QUFDQTs7QUFFQSxxQkFBcUIsMERBQThCO0FBQ25ELHNCQUFzQixtQkFBTyxDQUFDLGlFQUFZO0FBQzFDLHNCQUFzQixtQkFBTyxDQUFDLHVFQUFlO0FBQzdDLG9CQUFvQixtQkFBTyxDQUFDLHlFQUFnQjtBQUM1Qyw0QkFBNEIsbUJBQU8sQ0FBQyx5RkFBd0I7QUFDNUQsNkJBQTZCLG1CQUFPLENBQUMsMkZBQXlCO0FBQzlELDhCQUE4QixtQkFBTyxDQUFDLDZGQUEwQjtBQUNoRSxlQUFlLG1CQUFPLENBQUMsNkRBQVU7QUFDakMsd0JBQXdCLG1CQUFPLENBQUMseUVBQWdCO0FBQ2hELHdCQUF3QixtQkFBTyxDQUFDLGlGQUFvQjtBQUNwRCx1QkFBdUIsbUJBQU8sQ0FBQywrRUFBbUI7QUFDbEQsK0JBQStCLG1CQUFPLENBQUMsNkhBQTBDO0FBQ2pGLHNCQUFzQixtQkFBTyxDQUFDLDZHQUFrQztBQUNoRSw4QkFBOEIsbUJBQU8sQ0FBQyw2SEFBMEM7QUFDaEYsY0FBYyxtQkFBTyxDQUFDLDJFQUFpQjtBQUN2QyxnQkFBZ0IsZ0lBQTZDO0FBQzdELGtCQUFrQixrSUFBK0M7QUFDakUsZ0JBQWdCLDRHQUFtQztBQUNuRCxZQUFZLG1CQUFPLENBQUMsdUVBQWU7QUFDbkMscUNBQXFDLG1CQUFPLENBQUMsMklBQWlEO0FBQzlGLDZCQUE2QixtQkFBTyxDQUFDLHVIQUF1QztBQUM1RSxrQ0FBa0MsbUJBQU8sQ0FBQyxpSUFBNEM7QUFDdEYsd0JBQXdCLG1CQUFPLENBQUMsaUhBQW9DO0FBQ3BFLGtCQUFrQixtQkFBTyxDQUFDLG1GQUFxQjtBQUMvQyw2QkFBNkIsbUJBQU8sQ0FBQywrSEFBMkM7QUFDaEYsb0JBQW9CLG1CQUFPLENBQUMsNkdBQWtDO0FBQzlELGdCQUFnQixpREFBdUI7QUFDdkMsZ0NBQWdDLDhHQUE0QztBQUM1RSxrQ0FBa0MsbUJBQU8sQ0FBQyxxSUFBOEM7QUFDeEYsaUJBQWlCLG1CQUFPLENBQUMsaUZBQW9CO0FBQzdDLGNBQWMsbUJBQU8sQ0FBQyxrREFBTztBQUM3QixxQkFBcUIsbUJBQU8sQ0FBQyx5RUFBZ0I7QUFDN0MsY0FBYyxtQkFBTyxDQUFDLDJEQUFTO0FBQy9CLGtCQUFrQixtQkFBTyxDQUFDLG1GQUFxQjs7QUFFL0M7QUFDQTs7QUFFQSxpQ0FBaUMsK0hBQXFEO0FBQ3RGLDJCQUEyQix5SEFBK0M7QUFDMUUsNEJBQTRCLDBIQUFnRDtBQUM1RSwyQkFBMkIseUhBQStDO0FBQzFFLDhCQUE4Qiw0SEFBa0Q7QUFDaEYsNkJBQTZCLDJIQUFpRDtBQUM5RSxrQkFBa0IsZ0hBQXNDO0FBQ3hELDRCQUE0QiwwSEFBZ0Q7QUFDNUUsb0JBQW9CLGtIQUF3QztBQUM1RCwwQkFBMEIsc0hBQTZDO0FBQ3ZFLG9CQUFvQixtQkFBTyxDQUFDLGlHQUE0QjtBQUN4RCxxQ0FBcUMsbUJBQU8sQ0FBQywySUFBaUQ7QUFDOUYsNEJBQTRCLDBIQUFnRDs7QUFFNUU7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsV0FBVyxTQUFTO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0Qjs7QUFFNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQiw2Q0FBNkM7QUFDakU7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCLG9CQUFvQjtBQUNuRCxvQkFBb0I7QUFDcEI7QUFDQSwwQkFBMEI7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5Q0FBeUMsb0JBQW9CO0FBQzdELG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCLFFBQVE7QUFDUiwyQkFBMkIsb0JBQW9CO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEI7QUFDOUI7QUFDQSwwQkFBMEIsb0JBQW9CO0FBQzlDLDhCQUE4QjtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQixVQUFVO0FBQ3JDLEdBQUc7O0FBRUg7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QixRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixjQUFjLElBQUksV0FBVztBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQixjQUFjO0FBQzdDLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBLGtCQUFrQixVQUFVO0FBQzVCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsb0JBQW9CLFNBQVM7QUFDN0I7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsU0FBUztBQUNwQixXQUFXLFNBQVM7QUFDcEIsV0FBVyxRQUFRO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsU0FBUyxXQUFXO0FBQ3BCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLG9CQUFvQixTQUFTO0FBQzdCOztBQUVBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBOztBQUVBO0FBQ0EsK0NBQStDO0FBQy9DO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixXQUFXLFVBQVU7QUFDckI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFVBQVU7QUFDckIsV0FBVyxRQUFRO0FBQ25CLGFBQWEsVUFBVTtBQUN2QjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixXQUFXLFNBQVM7QUFDcEIsV0FBVyxRQUFRO0FBQ25CO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLE9BQU8sVUFBVSxJQUFJLE1BQU07QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsV0FBVyxnQkFBZ0I7QUFDM0IsV0FBVyxTQUFTO0FBQ3BCLFdBQVcsVUFBVTtBQUNyQixZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSw2Q0FBNkMsZUFBZTtBQUM1RDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSx1RUFBdUU7QUFDdkUsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsVUFBVTtBQUNyQixZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGlCQUFpQixlQUFlO0FBQ2hDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DO0FBQ25DO0FBQ0EsZ0NBQWdDO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxlQUFlO0FBQzFCLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2REFBNkQsY0FBYyxJQUFJLGtCQUFrQjtBQUNqRyxtQ0FBbUMsb0JBQW9CO0FBQ3ZEO0FBQ0EsMEJBQTBCO0FBQzFCO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQSxXQUFXLFNBQVM7QUFDcEIsWUFBWSw0QkFBNEI7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLFVBQVU7QUFDdEI7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsZUFBZTtBQUMxQixXQUFXLEtBQUs7QUFDaEIsV0FBVywrQkFBK0I7QUFDMUMsV0FBVyxRQUFRO0FBQ25CLFdBQVcsU0FBUyw2TkFBNk4sWUFBWSxvQ0FBb0MsdUJBQXVCO0FBQ3hULFlBQVksVUFBVTtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsNkRBQTZEO0FBQzdEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLElBQUk7QUFDSixzQkFBc0IsVUFBVTtBQUNoQztBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTs7QUFFQSw4QkFBOEIsYUFBYSw4QkFBOEI7O0FBRXpFLG9CQUFvQixTQUFTO0FBQzdCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHFFQUFxRSxhQUFhLHlCQUF5QjtBQUMzRztBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxvRUFBb0UsZ0JBQWdCO0FBQ3BGOztBQUVBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQSxpQ0FBaUMsa0JBQWtCO0FBQ25ELFVBQVU7QUFDVjtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsOENBQThDLFNBQVM7QUFDdkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkRBQTJELGdCQUFnQjtBQUMzRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsNEJBQTRCLE9BQU87QUFDbkM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGlEQUFpRDtBQUNqRDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTs7QUFFQTs7QUFFQSwrQkFBK0I7QUFDL0I7QUFDQSw4REFBOEQscUNBQXFDO0FBQ25HO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLGdCQUFnQixrQkFBa0I7QUFDbEM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsc0JBQXNCO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQjtBQUMzQjtBQUNBO0FBQ0EsZ0NBQWdDLGFBQWE7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQSxnQkFBZ0IsU0FBUztBQUN6QjtBQUNBLHFDQUFxQyxnQkFBZ0I7QUFDckQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsMkJBQTJCLG1DQUFtQztBQUM5RDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBLGdEQUFnRCx3Q0FBd0M7QUFDeEYsK0JBQStCO0FBQy9CO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEIsa0RBQWtELGVBQWU7O0FBRWpFO0FBQ0EsaUNBQWlDO0FBQ2pDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlFQUF5RSwwQkFBMEI7QUFDbkcsUUFBUTtBQUNSO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsZ0JBQWdCO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCLGVBQWU7QUFDN0M7QUFDQSxXQUFXLGVBQWU7QUFDMUIsV0FBVyxLQUFLO0FBQ2hCLFdBQVcsK0JBQStCO0FBQzFDLFdBQVcsUUFBUTtBQUNuQixZQUFZLFVBQVU7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE9BQU87QUFDbEIsV0FBVyxlQUFlO0FBQzFCLFdBQVcsUUFBUTtBQUNuQixXQUFXLEtBQUs7QUFDaEIsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsUUFBUTtBQUNuQixXQUFXLEtBQUs7QUFDaEIsV0FBVyxLQUFLO0FBQ2hCLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsV0FBVyxlQUFlO0FBQzFCLFdBQVcsUUFBUTtBQUNuQixXQUFXLEtBQUs7QUFDaEIsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsUUFBUTtBQUNuQixXQUFXLEtBQUs7QUFDaEIsV0FBVyxLQUFLO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSx5QkFBeUIsbUJBQU8sQ0FBQyw2RkFBMEI7O0FBRTNEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHNDQUFzQyxtQkFBTyxDQUFDLDZFQUFlO0FBQzdEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLFNBQVMsT0FBTztBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQSxRQUFRO0FBQ1I7QUFDQSxRQUFRO0FBQ1I7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixZQUFZLEtBQUs7QUFDakI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQyxpQkFBaUI7QUFDcEQ7QUFDQTtBQUNBLHVDQUF1QyxZQUFZO0FBQ25EO0FBQ0EseUJBQXlCLGNBQWMsUUFBUSxjQUFjO0FBQzdELG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0EseUJBQXlCLGNBQWMsUUFBUSxjQUFjO0FBQzdEO0FBQ0EsV0FBVyxjQUFjO0FBQ3pCLFdBQVcsUUFBUTtBQUNuQixZQUFZLFVBQVU7QUFDdEI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQztBQUMxQyxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsWUFBWSxVQUFVO0FBQ3RCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLCtCQUErQjtBQUMxQyxXQUFXLFFBQVE7QUFDbkIsV0FBVyxTQUFTO0FBQ3BCLFdBQVcsU0FBUztBQUNwQixZQUFZO0FBQ1o7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHFDQUFxQyxPQUFPO0FBQzVDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsTUFBTTtBQUNOLGlDQUFpQyxnQkFBZ0I7QUFDakQsTUFBTTtBQUNOO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBLCtDQUErQyxJQUFJLFlBQVk7QUFDL0Q7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLFVBQVU7QUFDckI7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQjtBQUNuQjtBQUNBLFdBQVcsUUFBUTtBQUNuQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQjtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsWUFBWTtBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUMsdUJBQXVCLGVBQWU7QUFDekU7QUFDQSw0QkFBNEIsMkJBQTJCLG1CQUFtQjtBQUMxRTtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0M7QUFDbEMsNEJBQTRCO0FBQzVCO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DLFVBQVUsZUFBZTtBQUM1RDtBQUNBLCtCQUErQjtBQUMvQiwrQkFBK0I7QUFDL0IsOEJBQThCO0FBQzlCO0FBQ0E7QUFDQSwrQkFBK0I7QUFDL0IsOEJBQThCO0FBQzlCO0FBQ0EsV0FBVyxRQUFRO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFdBQVcsU0FBUywySkFBMkosa0JBQWtCO0FBQ2pNLFlBQVk7QUFDWjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsY0FBYyxTQUFTO0FBQ3ZCO0FBQ0E7QUFDQTs7QUFFQSxnQkFBZ0IsVUFBVTtBQUMxQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLFVBQVU7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsY0FBYztBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQixVQUFVO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixZQUFZO0FBQ1o7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0w7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMENBQTBDLFFBQVEsZ0NBQWdDO0FBQ2xGO0FBQ0EsNkJBQTZCO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFlBQVk7QUFDWjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QjtBQUM3Qix5QkFBeUI7QUFDekI7QUFDQTtBQUNBLDZCQUE2QjtBQUM3Qix5QkFBeUI7QUFDekI7QUFDQTtBQUNBLFdBQVcsU0FBUztBQUNwQixZQUFZLGtCQUFrQjtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLGlCQUFpQjtBQUM1QixZQUFZO0FBQ1o7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsWUFBWTtBQUNaO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxpQkFBaUI7QUFDNUIsWUFBWTtBQUNaO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFlBQVk7QUFDWjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLDREQUE0RDtBQUN4RjtBQUNBLFdBQVcsY0FBYztBQUN6QixXQUFXLFFBQVE7QUFDbkIsV0FBVyxTQUFTO0FBQ3BCLFdBQVcsY0FBYztBQUN6QixZQUFZLFNBQVM7QUFDckI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsSUFBSTtBQUNKLDREQUE0RCw2Q0FBNkM7QUFDekc7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsU0FBUztBQUN2Qjs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQSwyQkFBMkI7O0FBRTNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsZ0RBQWdEO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixpQkFBaUI7QUFDdkM7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLDJCQUEyQjtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQixrQkFBa0I7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFD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O0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLDBCQUEwQjtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQixLQUFLLFFBQVEsU0FBUyxJQUFJLFVBQVU7QUFDOUQ7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFlBQVksVUFBVTtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbURBQW1ELHlCQUF5QjtBQUM1RTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL2FwcDEvLi9ub2RlX21vZHVsZXMvbW9uZ29vc2UvbGliL2RvY3VtZW50LmpzPzc0NzAiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG4vKiFcbiAqIE1vZHVsZSBkZXBlbmRlbmNpZXMuXG4gKi9cblxuY29uc3QgRXZlbnRFbWl0dGVyID0gcmVxdWlyZSgnZXZlbnRzJykuRXZlbnRFbWl0dGVyO1xuY29uc3QgSW50ZXJuYWxDYWNoZSA9IHJlcXVpcmUoJy4vaW50ZXJuYWwnKTtcbmNvbnN0IE1vbmdvb3NlRXJyb3IgPSByZXF1aXJlKCcuL2Vycm9yL2luZGV4Jyk7XG5jb25zdCBNaXhlZFNjaGVtYSA9IHJlcXVpcmUoJy4vc2NoZW1hL21peGVkJyk7XG5jb25zdCBPYmplY3RFeHBlY3RlZEVycm9yID0gcmVxdWlyZSgnLi9lcnJvci9vYmplY3RFeHBlY3RlZCcpO1xuY29uc3QgT2JqZWN0UGFyYW1ldGVyRXJyb3IgPSByZXF1aXJlKCcuL2Vycm9yL29iamVjdFBhcmFtZXRlcicpO1xuY29uc3QgUGFyYWxsZWxWYWxpZGF0ZUVycm9yID0gcmVxdWlyZSgnLi9lcnJvci9wYXJhbGxlbFZhbGlkYXRlJyk7XG5jb25zdCBTY2hlbWEgPSByZXF1aXJlKCcuL3NjaGVtYScpO1xuY29uc3QgU3RyaWN0TW9kZUVycm9yID0gcmVxdWlyZSgnLi9lcnJvci9zdHJpY3QnKTtcbmNvbnN0IFZhbGlkYXRpb25FcnJvciA9IHJlcXVpcmUoJy4vZXJyb3IvdmFsaWRhdGlvbicpO1xuY29uc3QgVmFsaWRhdG9yRXJyb3IgPSByZXF1aXJlKCcuL2Vycm9yL3ZhbGlkYXRvcicpO1xuY29uc3QgJF9faGFzSW5jbHVkZWRDaGlsZHJlbiA9IHJlcXVpcmUoJy4vaGVscGVycy9wcm9qZWN0aW9uL2hhc0luY2x1ZGVkQ2hpbGRyZW4nKTtcbmNvbnN0IGFwcGx5RGVmYXVsdHMgPSByZXF1aXJlKCcuL2hlbHBlcnMvZG9jdW1lbnQvYXBwbHlEZWZhdWx0cycpO1xuY29uc3QgY2xlYW5Nb2RpZmllZFN1YnBhdGhzID0gcmVxdWlyZSgnLi9oZWxwZXJzL2RvY3VtZW50L2NsZWFuTW9kaWZpZWRTdWJwYXRocycpO1xuY29uc3QgY2xvbmUgPSByZXF1aXJlKCcuL2hlbHBlcnMvY2xvbmUnKTtcbmNvbnN0IGNvbXBpbGUgPSByZXF1aXJlKCcuL2hlbHBlcnMvZG9jdW1lbnQvY29tcGlsZScpLmNvbXBpbGU7XG5jb25zdCBkZWZpbmVLZXkgPSByZXF1aXJlKCcuL2hlbHBlcnMvZG9jdW1lbnQvY29tcGlsZScpLmRlZmluZUtleTtcbmNvbnN0IGZsYXR0ZW4gPSByZXF1aXJlKCcuL2hlbHBlcnMvY29tbW9uJykuZmxhdHRlbjtcbmNvbnN0IGdldCA9IHJlcXVpcmUoJy4vaGVscGVycy9nZXQnKTtcbmNvbnN0IGdldEVtYmVkZGVkRGlzY3JpbWluYXRvclBhdGggPSByZXF1aXJlKCcuL2hlbHBlcnMvZG9jdW1lbnQvZ2V0RW1iZWRkZWREaXNjcmltaW5hdG9yUGF0aCcpO1xuY29uc3QgZ2V0S2V5c0luU2NoZW1hT3JkZXIgPSByZXF1aXJlKCcuL2hlbHBlcnMvc2NoZW1hL2dldEtleXNJblNjaGVtYU9yZGVyJyk7XG5jb25zdCBnZXRTdWJkb2N1bWVudFN0cmljdFZhbHVlID0gcmVxdWlyZSgnLi9oZWxwZXJzL3NjaGVtYS9nZXRTdWJkb2N1bWVudFN0cmljdFZhbHVlJyk7XG5jb25zdCBoYW5kbGVTcHJlYWREb2MgPSByZXF1aXJlKCcuL2hlbHBlcnMvZG9jdW1lbnQvaGFuZGxlU3ByZWFkRG9jJyk7XG5jb25zdCBpbW1lZGlhdGUgPSByZXF1aXJlKCcuL2hlbHBlcnMvaW1tZWRpYXRlJyk7XG5jb25zdCBpc0RlZmluaW5nUHJvamVjdGlvbiA9IHJlcXVpcmUoJy4vaGVscGVycy9wcm9qZWN0aW9uL2lzRGVmaW5pbmdQcm9qZWN0aW9uJyk7XG5jb25zdCBpc0V4Y2x1c2l2ZSA9IHJlcXVpcmUoJy4vaGVscGVycy9wcm9qZWN0aW9uL2lzRXhjbHVzaXZlJyk7XG5jb25zdCBpbnNwZWN0ID0gcmVxdWlyZSgndXRpbCcpLmluc3BlY3Q7XG5jb25zdCBpbnRlcm5hbFRvT2JqZWN0T3B0aW9ucyA9IHJlcXVpcmUoJy4vb3B0aW9ucycpLmludGVybmFsVG9PYmplY3RPcHRpb25zO1xuY29uc3QgbWFya0FycmF5U3ViZG9jc1BvcHVsYXRlZCA9IHJlcXVpcmUoJy4vaGVscGVycy9wb3B1bGF0ZS9tYXJrQXJyYXlTdWJkb2NzUG9wdWxhdGVkJyk7XG5jb25zdCBtaW5pbWl6ZSA9IHJlcXVpcmUoJy4vaGVscGVycy9taW5pbWl6ZScpO1xuY29uc3QgbXBhdGggPSByZXF1aXJlKCdtcGF0aCcpO1xuY29uc3QgcXVlcnloZWxwZXJzID0gcmVxdWlyZSgnLi9xdWVyeUhlbHBlcnMnKTtcbmNvbnN0IHV0aWxzID0gcmVxdWlyZSgnLi91dGlscycpO1xuY29uc3QgaXNQcm9taXNlID0gcmVxdWlyZSgnLi9oZWxwZXJzL2lzUHJvbWlzZScpO1xuXG5jb25zdCBkZWVwRXF1YWwgPSB1dGlscy5kZWVwRXF1YWw7XG5jb25zdCBpc01vbmdvb3NlT2JqZWN0ID0gdXRpbHMuaXNNb25nb29zZU9iamVjdDtcblxuY29uc3QgYXJyYXlBdG9taWNzQmFja3VwU3ltYm9sID0gcmVxdWlyZSgnLi9oZWxwZXJzL3N5bWJvbHMnKS5hcnJheUF0b21pY3NCYWNrdXBTeW1ib2w7XG5jb25zdCBhcnJheUF0b21pY3NTeW1ib2wgPSByZXF1aXJlKCcuL2hlbHBlcnMvc3ltYm9scycpLmFycmF5QXRvbWljc1N5bWJvbDtcbmNvbnN0IGRvY3VtZW50QXJyYXlQYXJlbnQgPSByZXF1aXJlKCcuL2hlbHBlcnMvc3ltYm9scycpLmRvY3VtZW50QXJyYXlQYXJlbnQ7XG5jb25zdCBkb2N1bWVudElzTW9kaWZpZWQgPSByZXF1aXJlKCcuL2hlbHBlcnMvc3ltYm9scycpLmRvY3VtZW50SXNNb2RpZmllZDtcbmNvbnN0IGRvY3VtZW50TW9kaWZpZWRQYXRocyA9IHJlcXVpcmUoJy4vaGVscGVycy9zeW1ib2xzJykuZG9jdW1lbnRNb2RpZmllZFBhdGhzO1xuY29uc3QgZG9jdW1lbnRTY2hlbWFTeW1ib2wgPSByZXF1aXJlKCcuL2hlbHBlcnMvc3ltYm9scycpLmRvY3VtZW50U2NoZW1hU3ltYm9sO1xuY29uc3QgZ2V0U3ltYm9sID0gcmVxdWlyZSgnLi9oZWxwZXJzL3N5bWJvbHMnKS5nZXRTeW1ib2w7XG5jb25zdCBwb3B1bGF0ZU1vZGVsU3ltYm9sID0gcmVxdWlyZSgnLi9oZWxwZXJzL3N5bWJvbHMnKS5wb3B1bGF0ZU1vZGVsU3ltYm9sO1xuY29uc3Qgc2NvcGVTeW1ib2wgPSByZXF1aXJlKCcuL2hlbHBlcnMvc3ltYm9scycpLnNjb3BlU3ltYm9sO1xuY29uc3Qgc2NoZW1hTWl4ZWRTeW1ib2wgPSByZXF1aXJlKCcuL3NjaGVtYS9zeW1ib2xzJykuc2NoZW1hTWl4ZWRTeW1ib2w7XG5jb25zdCBwYXJlbnRQYXRocyA9IHJlcXVpcmUoJy4vaGVscGVycy9wYXRoL3BhcmVudFBhdGhzJyk7XG5jb25zdCBnZXREZWVwZXN0U3ViZG9jdW1lbnRGb3JQYXRoID0gcmVxdWlyZSgnLi9oZWxwZXJzL2RvY3VtZW50L2dldERlZXBlc3RTdWJkb2N1bWVudEZvclBhdGgnKTtcbmNvbnN0IHNlc3Npb25OZXdEb2N1bWVudHMgPSByZXF1aXJlKCcuL2hlbHBlcnMvc3ltYm9scycpLnNlc3Npb25OZXdEb2N1bWVudHM7XG5cbmxldCBEb2N1bWVudEFycmF5O1xubGV0IE1vbmdvb3NlQXJyYXk7XG5sZXQgRW1iZWRkZWQ7XG5cbmNvbnN0IHNwZWNpYWxQcm9wZXJ0aWVzID0gdXRpbHMuc3BlY2lhbFByb3BlcnRpZXM7XG5cbi8qKlxuICogVGhlIGNvcmUgTW9uZ29vc2UgZG9jdW1lbnQgY29uc3RydWN0b3IuIFlvdSBzaG91bGQgbm90IGNhbGwgdGhpcyBkaXJlY3RseSxcbiAqIHRoZSBNb25nb29zZSBbTW9kZWwgY29uc3RydWN0b3JdKC4vYXBpL21vZGVsLmh0bWwjTW9kZWwpIGNhbGxzIHRoaXMgZm9yIHlvdS5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqIHRoZSB2YWx1ZXMgdG8gc2V0XG4gKiBAcGFyYW0ge09iamVjdH0gW2ZpZWxkc10gb3B0aW9uYWwgb2JqZWN0IGNvbnRhaW5pbmcgdGhlIGZpZWxkcyB3aGljaCB3ZXJlIHNlbGVjdGVkIGluIHRoZSBxdWVyeSByZXR1cm5pbmcgdGhpcyBkb2N1bWVudCBhbmQgYW55IHBvcHVsYXRlZCBwYXRocyBkYXRhXG4gKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdIHZhcmlvdXMgY29uZmlndXJhdGlvbiBvcHRpb25zIGZvciB0aGUgZG9jdW1lbnRcbiAqIEBwYXJhbSB7Qm9vbGVhbn0gW29wdGlvbnMuZGVmYXVsdHM9dHJ1ZV0gaWYgYGZhbHNlYCwgc2tpcCBhcHBseWluZyBkZWZhdWx0IHZhbHVlcyB0byB0aGlzIGRvY3VtZW50LlxuICogQGluaGVyaXRzIE5vZGVKUyBFdmVudEVtaXR0ZXIgaHR0cHM6Ly9ub2RlanMub3JnL2FwaS9ldmVudHMuaHRtbCNjbGFzcy1ldmVudGVtaXR0ZXJcbiAqIEBldmVudCBgaW5pdGA6IEVtaXR0ZWQgb24gYSBkb2N1bWVudCBhZnRlciBpdCBoYXMgYmVlbiByZXRyaWV2ZWQgZnJvbSB0aGUgZGIgYW5kIGZ1bGx5IGh5ZHJhdGVkIGJ5IE1vbmdvb3NlLlxuICogQGV2ZW50IGBzYXZlYDogRW1pdHRlZCB3aGVuIHRoZSBkb2N1bWVudCBpcyBzdWNjZXNzZnVsbHkgc2F2ZWRcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmZ1bmN0aW9uIERvY3VtZW50KG9iaiwgZmllbGRzLCBza2lwSWQsIG9wdGlvbnMpIHtcbiAgaWYgKHR5cGVvZiBza2lwSWQgPT09ICdvYmplY3QnICYmIHNraXBJZCAhPSBudWxsKSB7XG4gICAgb3B0aW9ucyA9IHNraXBJZDtcbiAgICBza2lwSWQgPSBvcHRpb25zLnNraXBJZDtcbiAgfVxuICBvcHRpb25zID0gT2JqZWN0LmFzc2lnbih7fSwgb3B0aW9ucyk7XG5cbiAgLy8gU3VwcG9ydCBgYnJvd3NlckRvY3VtZW50LmpzYCBzeW50YXhcbiAgaWYgKHRoaXMuJF9fc2NoZW1hID09IG51bGwpIHtcbiAgICBjb25zdCBfc2NoZW1hID0gdXRpbHMuaXNPYmplY3QoZmllbGRzKSAmJiAhZmllbGRzLmluc3RhbmNlT2ZTY2hlbWEgP1xuICAgICAgbmV3IFNjaGVtYShmaWVsZHMpIDpcbiAgICAgIGZpZWxkcztcbiAgICB0aGlzLiRfX3NldFNjaGVtYShfc2NoZW1hKTtcbiAgICBmaWVsZHMgPSBza2lwSWQ7XG4gICAgc2tpcElkID0gb3B0aW9ucztcbiAgICBvcHRpb25zID0gYXJndW1lbnRzWzRdIHx8IHt9O1xuICB9XG5cbiAgdGhpcy4kX18gPSBuZXcgSW50ZXJuYWxDYWNoZSgpO1xuXG4gIC8vIEF2b2lkIHNldHRpbmcgYGlzTmV3YCB0byBgdHJ1ZWAsIGJlY2F1c2UgaXQgaXMgYHRydWVgIGJ5IGRlZmF1bHRcbiAgaWYgKG9wdGlvbnMuaXNOZXcgIT0gbnVsbCAmJiBvcHRpb25zLmlzTmV3ICE9PSB0cnVlKSB7XG4gICAgdGhpcy4kaXNOZXcgPSBvcHRpb25zLmlzTmV3O1xuICB9XG5cbiAgaWYgKG9wdGlvbnMucHJpb3JEb2MgIT0gbnVsbCkge1xuICAgIHRoaXMuJF9fLnByaW9yRG9jID0gb3B0aW9ucy5wcmlvckRvYztcbiAgfVxuXG4gIGlmIChza2lwSWQpIHtcbiAgICB0aGlzLiRfXy5za2lwSWQgPSBza2lwSWQ7XG4gIH1cblxuICBpZiAob2JqICE9IG51bGwgJiYgdHlwZW9mIG9iaiAhPT0gJ29iamVjdCcpIHtcbiAgICB0aHJvdyBuZXcgT2JqZWN0UGFyYW1ldGVyRXJyb3Iob2JqLCAnb2JqJywgJ0RvY3VtZW50Jyk7XG4gIH1cblxuICBsZXQgZGVmYXVsdHMgPSB0cnVlO1xuICBpZiAob3B0aW9ucy5kZWZhdWx0cyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgdGhpcy4kX18uZGVmYXVsdHMgPSBvcHRpb25zLmRlZmF1bHRzO1xuICAgIGRlZmF1bHRzID0gb3B0aW9ucy5kZWZhdWx0cztcbiAgfVxuXG4gIGNvbnN0IHNjaGVtYSA9IHRoaXMuJF9fc2NoZW1hO1xuXG4gIGlmICh0eXBlb2YgZmllbGRzID09PSAnYm9vbGVhbicgfHwgZmllbGRzID09PSAndGhyb3cnKSB7XG4gICAgaWYgKGZpZWxkcyAhPT0gdHJ1ZSkge1xuICAgICAgdGhpcy4kX18uc3RyaWN0TW9kZSA9IGZpZWxkcztcbiAgICB9XG4gICAgZmllbGRzID0gdW5kZWZpbmVkO1xuICB9IGVsc2UgaWYgKHNjaGVtYS5vcHRpb25zLnN0cmljdCAhPT0gdHJ1ZSkge1xuICAgIHRoaXMuJF9fLnN0cmljdE1vZGUgPSBzY2hlbWEub3B0aW9ucy5zdHJpY3Q7XG4gIH1cblxuICBjb25zdCByZXF1aXJlZFBhdGhzID0gc2NoZW1hLnJlcXVpcmVkUGF0aHModHJ1ZSk7XG4gIGZvciAoY29uc3QgcGF0aCBvZiByZXF1aXJlZFBhdGhzKSB7XG4gICAgdGhpcy4kX18uYWN0aXZlUGF0aHMucmVxdWlyZShwYXRoKTtcbiAgfVxuXG4gIGxldCBleGNsdWRlID0gbnVsbDtcblxuICAvLyBkZXRlcm1pbmUgaWYgdGhpcyBkb2MgaXMgYSByZXN1bHQgb2YgYSBxdWVyeSB3aXRoXG4gIC8vIGV4Y2x1ZGVkIGZpZWxkc1xuICBpZiAodXRpbHMuaXNQT0pPKGZpZWxkcykgJiYgT2JqZWN0LmtleXMoZmllbGRzKS5sZW5ndGggPiAwKSB7XG4gICAgZXhjbHVkZSA9IGlzRXhjbHVzaXZlKGZpZWxkcyk7XG4gICAgdGhpcy4kX18uc2VsZWN0ZWQgPSBmaWVsZHM7XG4gICAgdGhpcy4kX18uZXhjbHVkZSA9IGV4Y2x1ZGU7XG4gIH1cblxuICBjb25zdCBoYXNJbmNsdWRlZENoaWxkcmVuID0gZXhjbHVkZSA9PT0gZmFsc2UgJiYgZmllbGRzID9cbiAgICAkX19oYXNJbmNsdWRlZENoaWxkcmVuKGZpZWxkcykgOlxuICAgIG51bGw7XG5cbiAgaWYgKHRoaXMuX2RvYyA9PSBudWxsKSB7XG4gICAgdGhpcy4kX19idWlsZERvYyhvYmosIGZpZWxkcywgc2tpcElkLCBleGNsdWRlLCBoYXNJbmNsdWRlZENoaWxkcmVuLCBmYWxzZSk7XG5cbiAgICAvLyBCeSBkZWZhdWx0LCBkZWZhdWx0cyBnZXQgYXBwbGllZCAqKmJlZm9yZSoqIHNldHRpbmcgaW5pdGlhbCB2YWx1ZXNcbiAgICAvLyBSZTogZ2gtNjE1NVxuICAgIGlmIChkZWZhdWx0cykge1xuICAgICAgYXBwbHlEZWZhdWx0cyh0aGlzLCBmaWVsZHMsIGV4Y2x1ZGUsIGhhc0luY2x1ZGVkQ2hpbGRyZW4sIHRydWUsIG51bGwpO1xuICAgIH1cbiAgfVxuICBpZiAob2JqKSB7XG4gICAgLy8gU2tpcCBzZXQgaG9va3NcbiAgICBpZiAodGhpcy4kX19vcmlnaW5hbF9zZXQpIHtcbiAgICAgIHRoaXMuJF9fb3JpZ2luYWxfc2V0KG9iaiwgdW5kZWZpbmVkLCB0cnVlLCBvcHRpb25zKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy4kc2V0KG9iaiwgdW5kZWZpbmVkLCB0cnVlLCBvcHRpb25zKTtcbiAgICB9XG5cbiAgICBpZiAob2JqIGluc3RhbmNlb2YgRG9jdW1lbnQpIHtcbiAgICAgIHRoaXMuJGlzTmV3ID0gb2JqLiRpc05ldztcbiAgICB9XG4gIH1cblxuICAvLyBGdW5jdGlvbiBkZWZhdWx0cyBnZXQgYXBwbGllZCAqKmFmdGVyKiogc2V0dGluZyBpbml0aWFsIHZhbHVlcyBzbyB0aGV5XG4gIC8vIHNlZSB0aGUgZnVsbCBkb2MgcmF0aGVyIHRoYW4gYW4gZW1wdHkgb25lLCB1bmxlc3MgdGhleSBvcHQgb3V0LlxuICAvLyBSZTogZ2gtMzc4MSwgZ2gtNjE1NVxuICBpZiAob3B0aW9ucy53aWxsSW5pdCAmJiBkZWZhdWx0cykge1xuICAgIGlmIChvcHRpb25zLnNraXBEZWZhdWx0cykge1xuICAgICAgdGhpcy4kX18uc2tpcERlZmF1bHRzID0gb3B0aW9ucy5za2lwRGVmYXVsdHM7XG4gICAgfVxuICB9IGVsc2UgaWYgKGRlZmF1bHRzKSB7XG4gICAgYXBwbHlEZWZhdWx0cyh0aGlzLCBmaWVsZHMsIGV4Y2x1ZGUsIGhhc0luY2x1ZGVkQ2hpbGRyZW4sIGZhbHNlLCBvcHRpb25zLnNraXBEZWZhdWx0cyk7XG4gIH1cblxuICBpZiAoIXRoaXMuJF9fLnN0cmljdE1vZGUgJiYgb2JqKSB7XG4gICAgY29uc3QgX3RoaXMgPSB0aGlzO1xuICAgIGNvbnN0IGtleXMgPSBPYmplY3Qua2V5cyh0aGlzLl9kb2MpO1xuXG4gICAga2V5cy5mb3JFYWNoKGZ1bmN0aW9uKGtleSkge1xuICAgICAgLy8gQXZvaWQgbWV0aG9kcywgdmlydHVhbHMsIGV4aXN0aW5nIGZpZWxkcywgYW5kIGAkYCBrZXlzLiBUaGUgbGF0dGVyIGlzIHRvIGF2b2lkIG92ZXJ3cml0aW5nXG4gICAgICAvLyBNb25nb29zZSBpbnRlcm5hbHMuXG4gICAgICBpZiAoIShrZXkgaW4gc2NoZW1hLnRyZWUpICYmICEoa2V5IGluIHNjaGVtYS5tZXRob2RzKSAmJiAhKGtleSBpbiBzY2hlbWEudmlydHVhbHMpICYmICFrZXkuc3RhcnRzV2l0aCgnJCcpKSB7XG4gICAgICAgIGRlZmluZUtleSh7IHByb3A6IGtleSwgc3VicHJvcHM6IG51bGwsIHByb3RvdHlwZTogX3RoaXMgfSk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICBhcHBseVF1ZXVlKHRoaXMpO1xufVxuXG5Eb2N1bWVudC5wcm90b3R5cGUuJGlzTW9uZ29vc2VEb2N1bWVudFByb3RvdHlwZSA9IHRydWU7XG5cbi8qKlxuICogQm9vbGVhbiBmbGFnIHNwZWNpZnlpbmcgaWYgdGhlIGRvY3VtZW50IGlzIG5ldy4gSWYgeW91IGNyZWF0ZSBhIGRvY3VtZW50XG4gKiB1c2luZyBgbmV3YCwgdGhpcyBkb2N1bWVudCB3aWxsIGJlIGNvbnNpZGVyZWQgXCJuZXdcIi4gYCRpc05ld2AgaXMgaG93XG4gKiBNb25nb29zZSBkZXRlcm1pbmVzIHdoZXRoZXIgYHNhdmUoKWAgc2hvdWxkIHVzZSBgaW5zZXJ0T25lKClgIHRvIGNyZWF0ZVxuICogYSBuZXcgZG9jdW1lbnQgb3IgYHVwZGF0ZU9uZSgpYCB0byB1cGRhdGUgYW4gZXhpc3RpbmcgZG9jdW1lbnQuXG4gKlxuICogIyMjIyBFeGFtcGxlOlxuICpcbiAqICAgICBjb25zdCB1c2VyID0gbmV3IFVzZXIoeyBuYW1lOiAnSm9obiBTbWl0aCcgfSk7XG4gKiAgICAgdXNlci4kaXNOZXc7IC8vIHRydWVcbiAqXG4gKiAgICAgYXdhaXQgdXNlci5zYXZlKCk7IC8vIFNlbmRzIGFuIGBpbnNlcnRPbmVgIHRvIE1vbmdvREJcbiAqXG4gKiBPbiB0aGUgb3RoZXIgaGFuZCwgaWYgeW91IGxvYWQgYW4gZXhpc3RpbmcgZG9jdW1lbnQgZnJvbSB0aGUgZGF0YWJhc2VcbiAqIHVzaW5nIGBmaW5kT25lKClgIG9yIGFub3RoZXIgW3F1ZXJ5IG9wZXJhdGlvbl0oaHR0cHM6Ly9tb25nb29zZWpzLmNvbS9kb2NzL3F1ZXJpZXMuaHRtbCksXG4gKiBgJGlzTmV3YCB3aWxsIGJlIGZhbHNlLlxuICpcbiAqICMjIyMgRXhhbXBsZTpcbiAqXG4gKiAgICAgY29uc3QgdXNlciA9IGF3YWl0IFVzZXIuZmluZE9uZSh7IG5hbWU6ICdKb2huIFNtaXRoJyB9KTtcbiAqICAgICB1c2VyLiRpc05ldzsgLy8gZmFsc2VcbiAqXG4gKiBNb25nb29zZSBzZXRzIGAkaXNOZXdgIHRvIGBmYWxzZWAgaW1tZWRpYXRlbHkgYWZ0ZXIgYHNhdmUoKWAgc3VjY2VlZHMuXG4gKiBUaGF0IG1lYW5zIE1vbmdvb3NlIHNldHMgYCRpc05ld2AgdG8gZmFsc2UgKipiZWZvcmUqKiBgcG9zdCgnc2F2ZScpYCBob29rcyBydW4uXG4gKiBJbiBgcG9zdCgnc2F2ZScpYCBob29rcywgYCRpc05ld2Agd2lsbCBiZSBgZmFsc2VgIGlmIGBzYXZlKClgIHN1Y2NlZWRlZC5cbiAqXG4gKiAjIyMjIEV4YW1wbGU6XG4gKlxuICogICAgIHVzZXJTY2hlbWEucG9zdCgnc2F2ZScsIGZ1bmN0aW9uKCkge1xuICogICAgICAgdGhpcy4kaXNOZXc7IC8vIGZhbHNlXG4gKiAgICAgfSk7XG4gKiAgICAgYXdhaXQgVXNlci5jcmVhdGUoeyBuYW1lOiAnSm9obiBTbWl0aCcgfSk7XG4gKlxuICogRm9yIHN1YmRvY3VtZW50cywgYCRpc05ld2AgaXMgdHJ1ZSBpZiBlaXRoZXIgdGhlIHBhcmVudCBoYXMgYCRpc05ld2Agc2V0LFxuICogb3IgaWYgeW91IGNyZWF0ZSBhIG5ldyBzdWJkb2N1bWVudC5cbiAqXG4gKiAjIyMjIEV4YW1wbGU6XG4gKlxuICogICAgIC8vIEFzc3VtZSBgR3JvdXBgIGhhcyBhIGRvY3VtZW50IGFycmF5IGB1c2Vyc2BcbiAqICAgICBjb25zdCBncm91cCA9IGF3YWl0IEdyb3VwLmZpbmRPbmUoKTtcbiAqICAgICBncm91cC51c2Vyc1swXS4kaXNOZXc7IC8vIGZhbHNlXG4gKlxuICogICAgIGdyb3VwLnVzZXJzLnB1c2goeyBuYW1lOiAnSm9obiBTbWl0aCcgfSk7XG4gKiAgICAgZ3JvdXAudXNlcnNbMV0uJGlzTmV3OyAvLyB0cnVlXG4gKlxuICogQGFwaSBwdWJsaWNcbiAqIEBwcm9wZXJ0eSAkaXNOZXdcbiAqIEBtZW1iZXJPZiBEb2N1bWVudFxuICogQGluc3RhbmNlXG4gKi9cblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KERvY3VtZW50LnByb3RvdHlwZSwgJ2lzTmV3Jywge1xuICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLiRpc05ldztcbiAgfSxcbiAgc2V0OiBmdW5jdGlvbih2YWx1ZSkge1xuICAgIHRoaXMuJGlzTmV3ID0gdmFsdWU7XG4gIH1cbn0pO1xuXG4vKipcbiAqIEhhc2ggY29udGFpbmluZyBjdXJyZW50IHZhbGlkYXRpb24gZXJyb3JzLlxuICpcbiAqIEBhcGkgcHVibGljXG4gKiBAcHJvcGVydHkgZXJyb3JzXG4gKiBAbWVtYmVyT2YgRG9jdW1lbnRcbiAqIEBpbnN0YW5jZVxuICovXG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShEb2N1bWVudC5wcm90b3R5cGUsICdlcnJvcnMnLCB7XG4gIGdldDogZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMuJGVycm9ycztcbiAgfSxcbiAgc2V0OiBmdW5jdGlvbih2YWx1ZSkge1xuICAgIHRoaXMuJGVycm9ycyA9IHZhbHVlO1xuICB9XG59KTtcblxuLyohXG4gKiBpZ25vcmVcbiAqL1xuXG5Eb2N1bWVudC5wcm90b3R5cGUuJGlzTmV3ID0gdHJ1ZTtcblxuLyohXG4gKiBEb2N1bWVudCBleHBvc2VzIHRoZSBOb2RlSlMgZXZlbnQgZW1pdHRlciBBUEksIHNvIHlvdSBjYW4gdXNlXG4gKiBgb25gLCBgb25jZWAsIGV0Yy5cbiAqL1xudXRpbHMuZWFjaChcbiAgWydvbicsICdvbmNlJywgJ2VtaXQnLCAnbGlzdGVuZXJzJywgJ3JlbW92ZUxpc3RlbmVyJywgJ3NldE1heExpc3RlbmVycycsXG4gICAgJ3JlbW92ZUFsbExpc3RlbmVycycsICdhZGRMaXN0ZW5lciddLFxuICBmdW5jdGlvbihlbWl0dGVyRm4pIHtcbiAgICBEb2N1bWVudC5wcm90b3R5cGVbZW1pdHRlckZuXSA9IGZ1bmN0aW9uKCkge1xuICAgICAgLy8gRGVsYXkgY3JlYXRpbmcgZW1pdHRlciB1bnRpbCBuZWNlc3NhcnkgYmVjYXVzZSBlbWl0dGVycyB0YWtlIHVwIGEgbG90IG9mIG1lbW9yeSxcbiAgICAgIC8vIGVzcGVjaWFsbHkgZm9yIHN1YmRvY3VtZW50cy5cbiAgICAgIGlmICghdGhpcy4kX18uZW1pdHRlcikge1xuICAgICAgICBpZiAoZW1pdHRlckZuID09PSAnZW1pdCcpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy4kX18uZW1pdHRlciA9IG5ldyBFdmVudEVtaXR0ZXIoKTtcbiAgICAgICAgdGhpcy4kX18uZW1pdHRlci5zZXRNYXhMaXN0ZW5lcnMoMCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcy4kX18uZW1pdHRlcltlbWl0dGVyRm5dLmFwcGx5KHRoaXMuJF9fLmVtaXR0ZXIsIGFyZ3VtZW50cyk7XG4gICAgfTtcbiAgICBEb2N1bWVudC5wcm90b3R5cGVbYCQke2VtaXR0ZXJGbn1gXSA9IERvY3VtZW50LnByb3RvdHlwZVtlbWl0dGVyRm5dO1xuICB9KTtcblxuRG9jdW1lbnQucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gRG9jdW1lbnQ7XG5cbmZvciAoY29uc3QgaSBpbiBFdmVudEVtaXR0ZXIucHJvdG90eXBlKSB7XG4gIERvY3VtZW50W2ldID0gRXZlbnRFbWl0dGVyLnByb3RvdHlwZVtpXTtcbn1cblxuLyoqXG4gKiBUaGUgZG9jdW1lbnQncyBpbnRlcm5hbCBzY2hlbWEuXG4gKlxuICogQGFwaSBwcml2YXRlXG4gKiBAcHJvcGVydHkgc2NoZW1hXG4gKiBAbWVtYmVyT2YgRG9jdW1lbnRcbiAqIEBpbnN0YW5jZVxuICovXG5cbkRvY3VtZW50LnByb3RvdHlwZS4kX19zY2hlbWE7XG5cbi8qKlxuICogVGhlIGRvY3VtZW50J3Mgc2NoZW1hLlxuICpcbiAqIEBhcGkgcHVibGljXG4gKiBAcHJvcGVydHkgc2NoZW1hXG4gKiBAbWVtYmVyT2YgRG9jdW1lbnRcbiAqIEBpbnN0YW5jZVxuICovXG5cbkRvY3VtZW50LnByb3RvdHlwZS5zY2hlbWE7XG5cbi8qKlxuICogRW1wdHkgb2JqZWN0IHRoYXQgeW91IGNhbiB1c2UgZm9yIHN0b3JpbmcgcHJvcGVydGllcyBvbiB0aGUgZG9jdW1lbnQuIFRoaXNcbiAqIGlzIGhhbmR5IGZvciBwYXNzaW5nIGRhdGEgdG8gbWlkZGxld2FyZSB3aXRob3V0IGNvbmZsaWN0aW5nIHdpdGggTW9uZ29vc2VcbiAqIGludGVybmFscy5cbiAqXG4gKiAjIyMjIEV4YW1wbGU6XG4gKlxuICogICAgIHNjaGVtYS5wcmUoJ3NhdmUnLCBmdW5jdGlvbigpIHtcbiAqICAgICAgIC8vIE1vbmdvb3NlIHdpbGwgc2V0IGBpc05ld2AgdG8gYGZhbHNlYCBpZiBgc2F2ZSgpYCBzdWNjZWVkc1xuICogICAgICAgdGhpcy4kbG9jYWxzLndhc05ldyA9IHRoaXMuaXNOZXc7XG4gKiAgICAgfSk7XG4gKlxuICogICAgIHNjaGVtYS5wb3N0KCdzYXZlJywgZnVuY3Rpb24oKSB7XG4gKiAgICAgICAvLyBQcmludHMgdHJ1ZSBpZiBgaXNOZXdgIHdhcyBzZXQgYmVmb3JlIGBzYXZlKClgXG4gKiAgICAgICBjb25zb2xlLmxvZyh0aGlzLiRsb2NhbHMud2FzTmV3KTtcbiAqICAgICB9KTtcbiAqXG4gKiBAYXBpIHB1YmxpY1xuICogQHByb3BlcnR5ICRsb2NhbHNcbiAqIEBtZW1iZXJPZiBEb2N1bWVudFxuICogQGluc3RhbmNlXG4gKi9cblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KERvY3VtZW50LnByb3RvdHlwZSwgJyRsb2NhbHMnLCB7XG4gIGNvbmZpZ3VyYWJsZTogZmFsc2UsXG4gIGVudW1lcmFibGU6IGZhbHNlLFxuICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgIGlmICh0aGlzLiRfXy5sb2NhbHMgPT0gbnVsbCkge1xuICAgICAgdGhpcy4kX18ubG9jYWxzID0ge307XG4gICAgfVxuICAgIHJldHVybiB0aGlzLiRfXy5sb2NhbHM7XG4gIH0sXG4gIHNldDogZnVuY3Rpb24odikge1xuICAgIHRoaXMuJF9fLmxvY2FscyA9IHY7XG4gIH1cbn0pO1xuXG4vKipcbiAqIExlZ2FjeSBhbGlhcyBmb3IgYCRpc05ld2AuXG4gKlxuICogQGFwaSBwdWJsaWNcbiAqIEBwcm9wZXJ0eSBpc05ld1xuICogQG1lbWJlck9mIERvY3VtZW50XG4gKiBAc2VlICRpc05ldyBodHRwczovL21vbmdvb3NlanMuY29tL2RvY3MvYXBpL2RvY3VtZW50Lmh0bWwjRG9jdW1lbnQucHJvdG90eXBlLiRpc05ld1xuICogQGluc3RhbmNlXG4gKi9cblxuRG9jdW1lbnQucHJvdG90eXBlLmlzTmV3O1xuXG4vKipcbiAqIFNldCB0aGlzIHByb3BlcnR5IHRvIGFkZCBhZGRpdGlvbmFsIHF1ZXJ5IGZpbHRlcnMgd2hlbiBNb25nb29zZSBzYXZlcyB0aGlzIGRvY3VtZW50IGFuZCBgaXNOZXdgIGlzIGZhbHNlLlxuICpcbiAqICMjIyMgRXhhbXBsZTpcbiAqXG4gKiAgICAgLy8gTWFrZSBzdXJlIGBzYXZlKClgIG5ldmVyIHVwZGF0ZXMgYSBzb2Z0IGRlbGV0ZWQgZG9jdW1lbnQuXG4gKiAgICAgc2NoZW1hLnByZSgnc2F2ZScsIGZ1bmN0aW9uKCkge1xuICogICAgICAgdGhpcy4kd2hlcmUgPSB7IGlzRGVsZXRlZDogZmFsc2UgfTtcbiAqICAgICB9KTtcbiAqXG4gKiBAYXBpIHB1YmxpY1xuICogQHByb3BlcnR5ICR3aGVyZVxuICogQG1lbWJlck9mIERvY3VtZW50XG4gKiBAaW5zdGFuY2VcbiAqL1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoRG9jdW1lbnQucHJvdG90eXBlLCAnJHdoZXJlJywge1xuICBjb25maWd1cmFibGU6IGZhbHNlLFxuICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgd3JpdGFibGU6IHRydWVcbn0pO1xuXG4vKipcbiAqIFRoZSBzdHJpbmcgdmVyc2lvbiBvZiB0aGlzIGRvY3VtZW50cyBfaWQuXG4gKlxuICogIyMjIyBOb3RlOlxuICpcbiAqIFRoaXMgZ2V0dGVyIGV4aXN0cyBvbiBhbGwgZG9jdW1lbnRzIGJ5IGRlZmF1bHQuIFRoZSBnZXR0ZXIgY2FuIGJlIGRpc2FibGVkIGJ5IHNldHRpbmcgdGhlIGBpZGAgW29wdGlvbl0oaHR0cHM6Ly9tb25nb29zZWpzLmNvbS9kb2NzL2d1aWRlLmh0bWwjaWQpIG9mIGl0cyBgU2NoZW1hYCB0byBmYWxzZSBhdCBjb25zdHJ1Y3Rpb24gdGltZS5cbiAqXG4gKiAgICAgbmV3IFNjaGVtYSh7IG5hbWU6IFN0cmluZyB9LCB7IGlkOiBmYWxzZSB9KTtcbiAqXG4gKiBAYXBpIHB1YmxpY1xuICogQHNlZSBTY2hlbWEgb3B0aW9ucyBodHRwczovL21vbmdvb3NlanMuY29tL2RvY3MvZ3VpZGUuaHRtbCNvcHRpb25zXG4gKiBAcHJvcGVydHkgaWRcbiAqIEBtZW1iZXJPZiBEb2N1bWVudFxuICogQGluc3RhbmNlXG4gKi9cblxuRG9jdW1lbnQucHJvdG90eXBlLmlkO1xuXG4vKipcbiAqIEhhc2ggY29udGFpbmluZyBjdXJyZW50IHZhbGlkYXRpb24gJGVycm9ycy5cbiAqXG4gKiBAYXBpIHB1YmxpY1xuICogQHByb3BlcnR5ICRlcnJvcnNcbiAqIEBtZW1iZXJPZiBEb2N1bWVudFxuICogQGluc3RhbmNlXG4gKi9cblxuRG9jdW1lbnQucHJvdG90eXBlLiRlcnJvcnM7XG5cbi8qKlxuICogQSBzdHJpbmcgY29udGFpbmluZyB0aGUgY3VycmVudCBvcGVyYXRpb24gdGhhdCBNb25nb29zZSBpcyBleGVjdXRpbmdcbiAqIG9uIHRoaXMgZG9jdW1lbnQuIE1heSBiZSBgbnVsbGAsIGAnc2F2ZSdgLCBgJ3ZhbGlkYXRlJ2AsIG9yIGAncmVtb3ZlJ2AuXG4gKlxuICogIyMjIyBFeGFtcGxlOlxuICpcbiAqICAgICBjb25zdCBkb2MgPSBuZXcgTW9kZWwoeyBuYW1lOiAndGVzdCcgfSk7XG4gKiAgICAgZG9jLiRvcDsgLy8gbnVsbFxuICpcbiAqICAgICBjb25zdCBwcm9taXNlID0gZG9jLnNhdmUoKTtcbiAqICAgICBkb2MuJG9wOyAvLyAnc2F2ZSdcbiAqXG4gKiAgICAgYXdhaXQgcHJvbWlzZTtcbiAqICAgICBkb2MuJG9wOyAvLyBudWxsXG4gKlxuICogQGFwaSBwdWJsaWNcbiAqIEBwcm9wZXJ0eSAkb3BcbiAqIEBtZW1iZXJPZiBEb2N1bWVudFxuICogQGluc3RhbmNlXG4gKi9cblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KERvY3VtZW50LnByb3RvdHlwZSwgJyRvcCcsIHtcbiAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy4kX18ub3AgfHwgbnVsbDtcbiAgfSxcbiAgc2V0OiBmdW5jdGlvbih2YWx1ZSkge1xuICAgIHRoaXMuJF9fLm9wID0gdmFsdWU7XG4gIH1cbn0pO1xuXG4vKiFcbiAqIGlnbm9yZVxuICovXG5cbmZ1bmN0aW9uICRhcHBseURlZmF1bHRzVG9OZXN0ZWQodmFsLCBwYXRoLCBkb2MpIHtcbiAgaWYgKHZhbCA9PSBudWxsKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgY29uc3QgcGF0aHMgPSBPYmplY3Qua2V5cyhkb2MuJF9fc2NoZW1hLnBhdGhzKTtcbiAgY29uc3QgcGxlbiA9IHBhdGhzLmxlbmd0aDtcblxuICBjb25zdCBwYXRoUGllY2VzID0gcGF0aC5pbmRleE9mKCcuJykgPT09IC0xID8gW3BhdGhdIDogcGF0aC5zcGxpdCgnLicpO1xuXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgcGxlbjsgKytpKSB7XG4gICAgbGV0IGN1clBhdGggPSAnJztcbiAgICBjb25zdCBwID0gcGF0aHNbaV07XG5cbiAgICBpZiAoIXAuc3RhcnRzV2l0aChwYXRoICsgJy4nKSkge1xuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgY29uc3QgdHlwZSA9IGRvYy4kX19zY2hlbWEucGF0aHNbcF07XG4gICAgY29uc3QgcGllY2VzID0gdHlwZS5zcGxpdFBhdGgoKS5zbGljZShwYXRoUGllY2VzLmxlbmd0aCk7XG4gICAgY29uc3QgbGVuID0gcGllY2VzLmxlbmd0aDtcblxuICAgIGlmICh0eXBlLmRlZmF1bHRWYWx1ZSA9PT0gdm9pZCAwKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICBsZXQgY3VyID0gdmFsO1xuXG4gICAgZm9yIChsZXQgaiA9IDA7IGogPCBsZW47ICsraikge1xuICAgICAgaWYgKGN1ciA9PSBudWxsKSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuXG4gICAgICBjb25zdCBwaWVjZSA9IHBpZWNlc1tqXTtcblxuICAgICAgaWYgKGogPT09IGxlbiAtIDEpIHtcbiAgICAgICAgaWYgKGN1cltwaWVjZV0gIT09IHZvaWQgMCkge1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG5cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBjb25zdCBkZWYgPSB0eXBlLmdldERlZmF1bHQoZG9jLCBmYWxzZSk7XG4gICAgICAgICAgaWYgKGRlZiAhPT0gdm9pZCAwKSB7XG4gICAgICAgICAgICBjdXJbcGllY2VdID0gZGVmO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgZG9jLmludmFsaWRhdGUocGF0aCArICcuJyArIGN1clBhdGgsIGVycik7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cblxuICAgICAgICBicmVhaztcbiAgICAgIH1cblxuICAgICAgY3VyUGF0aCArPSAoIWN1clBhdGgubGVuZ3RoID8gJycgOiAnLicpICsgcGllY2U7XG5cbiAgICAgIGN1cltwaWVjZV0gPSBjdXJbcGllY2VdIHx8IHt9O1xuICAgICAgY3VyID0gY3VyW3BpZWNlXTtcbiAgICB9XG4gIH1cbn1cblxuLyoqXG4gKiBCdWlsZHMgdGhlIGRlZmF1bHQgZG9jIHN0cnVjdHVyZVxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmpcbiAqIEBwYXJhbSB7T2JqZWN0fSBbZmllbGRzXVxuICogQHBhcmFtIHtCb29sZWFufSBbc2tpcElkXVxuICogQHBhcmFtIHtCb29sZWFufSBbZXhjbHVkZV1cbiAqIEBwYXJhbSB7T2JqZWN0fSBbaGFzSW5jbHVkZWRDaGlsZHJlbl1cbiAqIEBhcGkgcHJpdmF0ZVxuICogQG1ldGhvZCAkX19idWlsZERvY1xuICogQG1lbWJlck9mIERvY3VtZW50XG4gKiBAaW5zdGFuY2VcbiAqL1xuXG5Eb2N1bWVudC5wcm90b3R5cGUuJF9fYnVpbGREb2MgPSBmdW5jdGlvbihvYmosIGZpZWxkcywgc2tpcElkLCBleGNsdWRlLCBoYXNJbmNsdWRlZENoaWxkcmVuKSB7XG4gIGNvbnN0IGRvYyA9IHt9O1xuXG4gIGNvbnN0IHBhdGhzID0gT2JqZWN0LmtleXModGhpcy4kX19zY2hlbWEucGF0aHMpLlxuICAgIC8vIERvbid0IGJ1aWxkIHVwIGFueSBwYXRocyB0aGF0IGFyZSB1bmRlcm5lYXRoIGEgbWFwLCB3ZSBkb24ndCBrbm93XG4gICAgLy8gd2hhdCB0aGUga2V5cyB3aWxsIGJlXG4gICAgZmlsdGVyKHAgPT4gIXAuaW5jbHVkZXMoJyQqJykpO1xuICBjb25zdCBwbGVuID0gcGF0aHMubGVuZ3RoO1xuICBsZXQgaWkgPSAwO1xuXG4gIGZvciAoOyBpaSA8IHBsZW47ICsraWkpIHtcbiAgICBjb25zdCBwID0gcGF0aHNbaWldO1xuXG4gICAgaWYgKHAgPT09ICdfaWQnKSB7XG4gICAgICBpZiAoc2tpcElkKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgaWYgKG9iaiAmJiAnX2lkJyBpbiBvYmopIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgfVxuXG4gICAgY29uc3QgcGF0aCA9IHRoaXMuJF9fc2NoZW1hLnBhdGhzW3BdLnNwbGl0UGF0aCgpO1xuICAgIGNvbnN0IGxlbiA9IHBhdGgubGVuZ3RoO1xuICAgIGNvbnN0IGxhc3QgPSBsZW4gLSAxO1xuICAgIGxldCBjdXJQYXRoID0gJyc7XG4gICAgbGV0IGRvY18gPSBkb2M7XG4gICAgbGV0IGluY2x1ZGVkID0gZmFsc2U7XG5cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbjsgKytpKSB7XG4gICAgICBjb25zdCBwaWVjZSA9IHBhdGhbaV07XG5cbiAgICAgIGlmICghY3VyUGF0aC5sZW5ndGgpIHtcbiAgICAgICAgY3VyUGF0aCA9IHBpZWNlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY3VyUGF0aCArPSAnLicgKyBwaWVjZTtcbiAgICAgIH1cblxuICAgICAgLy8gc3VwcG9ydCBleGNsdWRpbmcgaW50ZXJtZWRpYXJ5IGxldmVsc1xuICAgICAgaWYgKGV4Y2x1ZGUgPT09IHRydWUpIHtcbiAgICAgICAgaWYgKGN1clBhdGggaW4gZmllbGRzKSB7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoZXhjbHVkZSA9PT0gZmFsc2UgJiYgZmllbGRzICYmICFpbmNsdWRlZCkge1xuICAgICAgICBpZiAoY3VyUGF0aCBpbiBmaWVsZHMpIHtcbiAgICAgICAgICBpbmNsdWRlZCA9IHRydWU7XG4gICAgICAgIH0gZWxzZSBpZiAoIWhhc0luY2x1ZGVkQ2hpbGRyZW5bY3VyUGF0aF0pIHtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAoaSA8IGxhc3QpIHtcbiAgICAgICAgZG9jXyA9IGRvY19bcGllY2VdIHx8IChkb2NfW3BpZWNlXSA9IHt9KTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICB0aGlzLl9kb2MgPSBkb2M7XG59O1xuXG4vKiFcbiAqIENvbnZlcnRzIHRvIFBPSk8gd2hlbiB5b3UgdXNlIHRoZSBkb2N1bWVudCBmb3IgcXVlcnlpbmdcbiAqL1xuXG5Eb2N1bWVudC5wcm90b3R5cGUudG9CU09OID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiB0aGlzLnRvT2JqZWN0KGludGVybmFsVG9PYmplY3RPcHRpb25zKTtcbn07XG5cbi8qKlxuICogSW5pdGlhbGl6ZXMgdGhlIGRvY3VtZW50IHdpdGhvdXQgc2V0dGVycyBvciBtYXJraW5nIGFueXRoaW5nIG1vZGlmaWVkLlxuICpcbiAqIENhbGxlZCBpbnRlcm5hbGx5IGFmdGVyIGEgZG9jdW1lbnQgaXMgcmV0dXJuZWQgZnJvbSBtb25nb2RiLiBOb3JtYWxseSxcbiAqIHlvdSBkbyAqKm5vdCoqIG5lZWQgdG8gY2FsbCB0aGlzIGZ1bmN0aW9uIG9uIHlvdXIgb3duLlxuICpcbiAqIFRoaXMgZnVuY3Rpb24gdHJpZ2dlcnMgYGluaXRgIFttaWRkbGV3YXJlXShodHRwczovL21vbmdvb3NlanMuY29tL2RvY3MvbWlkZGxld2FyZS5odG1sKS5cbiAqIE5vdGUgdGhhdCBgaW5pdGAgaG9va3MgYXJlIFtzeW5jaHJvbm91c10oaHR0cHM6Ly9tb25nb29zZWpzLmNvbS9kb2NzL21pZGRsZXdhcmUuaHRtbCNzeW5jaHJvbm91cykuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IGRvYyBkb2N1bWVudCByZXR1cm5lZCBieSBtb25nb1xuICogQHBhcmFtIHtPYmplY3R9IFtvcHRzXVxuICogQHBhcmFtIHtGdW5jdGlvbn0gW2ZuXVxuICogQGFwaSBwdWJsaWNcbiAqIEBtZW1iZXJPZiBEb2N1bWVudFxuICogQGluc3RhbmNlXG4gKi9cblxuRG9jdW1lbnQucHJvdG90eXBlLmluaXQgPSBmdW5jdGlvbihkb2MsIG9wdHMsIGZuKSB7XG4gIGlmICh0eXBlb2Ygb3B0cyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIGZuID0gb3B0cztcbiAgICBvcHRzID0gbnVsbDtcbiAgfVxuXG4gIHRoaXMuJF9faW5pdChkb2MsIG9wdHMpO1xuXG4gIGlmIChmbikge1xuICAgIGZuKG51bGwsIHRoaXMpO1xuICB9XG5cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIEFsaWFzIGZvciBbYC5pbml0YF0oaHR0cHM6Ly9tb25nb29zZWpzLmNvbS9kb2NzL2FwaS9kb2N1bWVudC5odG1sI0RvY3VtZW50LnByb3RvdHlwZS5pbml0KCkpXG4gKlxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5Eb2N1bWVudC5wcm90b3R5cGUuJGluaXQgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHRoaXMuY29uc3RydWN0b3IucHJvdG90eXBlLmluaXQuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbn07XG5cbi8qKlxuICogSW50ZXJuYWwgXCJpbml0XCIgZnVuY3Rpb25cbiAqXG4gKiBAcGFyYW0ge0RvY3VtZW50fSBkb2NcbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0c11cbiAqIEByZXR1cm5zIHtEb2N1bWVudH0gdGhpc1xuICogQGFwaSBwcml2YXRlXG4gKi9cblxuRG9jdW1lbnQucHJvdG90eXBlLiRfX2luaXQgPSBmdW5jdGlvbihkb2MsIG9wdHMpIHtcbiAgdGhpcy4kaXNOZXcgPSBmYWxzZTtcbiAgb3B0cyA9IG9wdHMgfHwge307XG5cbiAgLy8gaGFuZGxlIGRvY3Mgd2l0aCBwb3B1bGF0ZWQgcGF0aHNcbiAgLy8gSWYgZG9jLl9pZCBpcyBub3QgbnVsbCBvciB1bmRlZmluZWRcbiAgaWYgKGRvYy5faWQgIT0gbnVsbCAmJiBvcHRzLnBvcHVsYXRlZCAmJiBvcHRzLnBvcHVsYXRlZC5sZW5ndGgpIHtcbiAgICBjb25zdCBpZCA9IFN0cmluZyhkb2MuX2lkKTtcbiAgICBmb3IgKGNvbnN0IGl0ZW0gb2Ygb3B0cy5wb3B1bGF0ZWQpIHtcbiAgICAgIGlmIChpdGVtLmlzVmlydHVhbCkge1xuICAgICAgICB0aGlzLiRwb3B1bGF0ZWQoaXRlbS5wYXRoLCB1dGlscy5nZXRWYWx1ZShpdGVtLnBhdGgsIGRvYyksIGl0ZW0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy4kcG9wdWxhdGVkKGl0ZW0ucGF0aCwgaXRlbS5fZG9jc1tpZF0sIGl0ZW0pO1xuICAgICAgfVxuXG4gICAgICBpZiAoaXRlbS5fY2hpbGREb2NzID09IG51bGwpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBmb3IgKGNvbnN0IGNoaWxkIG9mIGl0ZW0uX2NoaWxkRG9jcykge1xuICAgICAgICBpZiAoY2hpbGQgPT0gbnVsbCB8fCBjaGlsZC4kX18gPT0gbnVsbCkge1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIGNoaWxkLiRfXy5wYXJlbnQgPSB0aGlzO1xuICAgICAgfVxuICAgICAgaXRlbS5fY2hpbGREb2NzID0gW107XG4gICAgfVxuICB9XG5cbiAgaW5pdCh0aGlzLCBkb2MsIHRoaXMuX2RvYywgb3B0cyk7XG5cbiAgbWFya0FycmF5U3ViZG9jc1BvcHVsYXRlZCh0aGlzLCBvcHRzLnBvcHVsYXRlZCk7XG5cbiAgdGhpcy4kZW1pdCgnaW5pdCcsIHRoaXMpO1xuICB0aGlzLmNvbnN0cnVjdG9yLmVtaXQoJ2luaXQnLCB0aGlzKTtcblxuICBjb25zdCBoYXNJbmNsdWRlZENoaWxkcmVuID0gdGhpcy4kX18uZXhjbHVkZSA9PT0gZmFsc2UgJiYgdGhpcy4kX18uc2VsZWN0ZWQgP1xuICAgICRfX2hhc0luY2x1ZGVkQ2hpbGRyZW4odGhpcy4kX18uc2VsZWN0ZWQpIDpcbiAgICBudWxsO1xuXG4gIGFwcGx5RGVmYXVsdHModGhpcywgdGhpcy4kX18uc2VsZWN0ZWQsIHRoaXMuJF9fLmV4Y2x1ZGUsIGhhc0luY2x1ZGVkQ2hpbGRyZW4sIGZhbHNlLCB0aGlzLiRfXy5za2lwRGVmYXVsdHMpO1xuXG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBJbml0IGhlbHBlci5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gc2VsZiBkb2N1bWVudCBpbnN0YW5jZVxuICogQHBhcmFtIHtPYmplY3R9IG9iaiByYXcgbW9uZ29kYiBkb2NcbiAqIEBwYXJhbSB7T2JqZWN0fSBkb2Mgb2JqZWN0IHdlIGFyZSBpbml0aWFsaXppbmdcbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0c10gT3B0aW9uYWwgT3B0aW9uc1xuICogQHBhcmFtIHtCb29sZWFufSBbb3B0cy5zZXR0ZXJzXSBDYWxsIGBhcHBseVNldHRlcnNgIGluc3RlYWQgb2YgYGNhc3RgXG4gKiBAcGFyYW0ge1N0cmluZ30gW3ByZWZpeF0gUHJlZml4IHRvIGFkZCB0byBlYWNoIHBhdGhcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmZ1bmN0aW9uIGluaXQoc2VsZiwgb2JqLCBkb2MsIG9wdHMsIHByZWZpeCkge1xuICBwcmVmaXggPSBwcmVmaXggfHwgJyc7XG5cbiAgaWYgKG9iai4kX18gIT0gbnVsbCkge1xuICAgIG9iaiA9IG9iai5fZG9jO1xuICB9XG4gIGNvbnN0IGtleXMgPSBPYmplY3Qua2V5cyhvYmopO1xuICBjb25zdCBsZW4gPSBrZXlzLmxlbmd0aDtcbiAgbGV0IHNjaGVtYVR5cGU7XG4gIGxldCBwYXRoO1xuICBsZXQgaTtcbiAgbGV0IGluZGV4ID0gMDtcbiAgY29uc3Qgc3RyaWN0ID0gc2VsZi4kX18uc3RyaWN0TW9kZTtcbiAgY29uc3QgZG9jU2NoZW1hID0gc2VsZi4kX19zY2hlbWE7XG5cbiAgd2hpbGUgKGluZGV4IDwgbGVuKSB7XG4gICAgX2luaXQoaW5kZXgrKyk7XG4gIH1cblxuICBmdW5jdGlvbiBfaW5pdChpbmRleCkge1xuICAgIGkgPSBrZXlzW2luZGV4XTtcbiAgICAvLyBhdm9pZCBwcm90b3R5cGUgcG9sbHV0aW9uXG4gICAgaWYgKGkgPT09ICdfX3Byb3RvX18nIHx8IGkgPT09ICdjb25zdHJ1Y3RvcicpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgcGF0aCA9IHByZWZpeCArIGk7XG4gICAgc2NoZW1hVHlwZSA9IGRvY1NjaGVtYS5wYXRoKHBhdGgpO1xuXG4gICAgLy8gU2hvdWxkIHN0aWxsIHdvcmsgaWYgbm90IGEgbW9kZWwtbGV2ZWwgZGlzY3JpbWluYXRvciwgYnV0IHNob3VsZCBub3QgYmVcbiAgICAvLyBuZWNlc3NhcnkuIFRoaXMgaXMgKm9ubHkqIHRvIGNhdGNoIHRoZSBjYXNlIHdoZXJlIHdlIHF1ZXJpZWQgdXNpbmcgdGhlXG4gICAgLy8gYmFzZSBtb2RlbCBhbmQgdGhlIGRpc2NyaW1pbmF0ZWQgbW9kZWwgaGFzIGEgcHJvamVjdGlvblxuICAgIGlmIChkb2NTY2hlbWEuJGlzUm9vdERpc2NyaW1pbmF0b3IgJiYgIXNlbGYuJF9faXNTZWxlY3RlZChwYXRoKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmICghc2NoZW1hVHlwZSAmJiB1dGlscy5pc1BPSk8ob2JqW2ldKSkge1xuICAgICAgLy8gYXNzdW1lIG5lc3RlZCBvYmplY3RcbiAgICAgIGlmICghZG9jW2ldKSB7XG4gICAgICAgIGRvY1tpXSA9IHt9O1xuICAgICAgICBpZiAoIXN0cmljdCAmJiAhKGkgaW4gZG9jU2NoZW1hLnRyZWUpICYmICEoaSBpbiBkb2NTY2hlbWEubWV0aG9kcykgJiYgIShpIGluIGRvY1NjaGVtYS52aXJ0dWFscykpIHtcbiAgICAgICAgICBzZWxmW2ldID0gZG9jW2ldO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpbml0KHNlbGYsIG9ialtpXSwgZG9jW2ldLCBvcHRzLCBwYXRoICsgJy4nKTtcbiAgICB9IGVsc2UgaWYgKCFzY2hlbWFUeXBlKSB7XG4gICAgICBkb2NbaV0gPSBvYmpbaV07XG4gICAgICBpZiAoIXN0cmljdCAmJiAhcHJlZml4KSB7XG4gICAgICAgIHNlbGZbaV0gPSBvYmpbaV07XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIFJldGFpbiBvcmRlciB3aGVuIG92ZXJ3cml0aW5nIGRlZmF1bHRzXG4gICAgICBpZiAoZG9jLmhhc093blByb3BlcnR5KGkpICYmIG9ialtpXSAhPT0gdm9pZCAwKSB7XG4gICAgICAgIGRlbGV0ZSBkb2NbaV07XG4gICAgICB9XG4gICAgICBpZiAob2JqW2ldID09PSBudWxsKSB7XG4gICAgICAgIGRvY1tpXSA9IHNjaGVtYVR5cGUuX2Nhc3ROdWxsaXNoKG51bGwpO1xuICAgICAgfSBlbHNlIGlmIChvYmpbaV0gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBjb25zdCB3YXNQb3B1bGF0ZWQgPSBvYmpbaV0uJF9fID09IG51bGwgPyBudWxsIDogb2JqW2ldLiRfXy53YXNQb3B1bGF0ZWQ7XG5cbiAgICAgICAgaWYgKHNjaGVtYVR5cGUgJiYgIXdhc1BvcHVsYXRlZCkge1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICBpZiAob3B0cyAmJiBvcHRzLnNldHRlcnMpIHtcbiAgICAgICAgICAgICAgLy8gQ2FsbCBhcHBseVNldHRlcnMgd2l0aCBgaW5pdCA9IGZhbHNlYCBiZWNhdXNlIG90aGVyd2lzZSBzZXR0ZXJzIGFyZSBhIG5vb3BcbiAgICAgICAgICAgICAgY29uc3Qgb3ZlcnJpZGVJbml0ID0gZmFsc2U7XG4gICAgICAgICAgICAgIGRvY1tpXSA9IHNjaGVtYVR5cGUuYXBwbHlTZXR0ZXJzKG9ialtpXSwgc2VsZiwgb3ZlcnJpZGVJbml0KTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGRvY1tpXSA9IHNjaGVtYVR5cGUuY2FzdChvYmpbaV0sIHNlbGYsIHRydWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIHNlbGYuaW52YWxpZGF0ZShlLnBhdGgsIG5ldyBWYWxpZGF0b3JFcnJvcih7XG4gICAgICAgICAgICAgIHBhdGg6IGUucGF0aCxcbiAgICAgICAgICAgICAgbWVzc2FnZTogZS5tZXNzYWdlLFxuICAgICAgICAgICAgICB0eXBlOiAnY2FzdCcsXG4gICAgICAgICAgICAgIHZhbHVlOiBlLnZhbHVlLFxuICAgICAgICAgICAgICByZWFzb246IGVcbiAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZG9jW2ldID0gb2JqW2ldO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICAvLyBtYXJrIGFzIGh5ZHJhdGVkXG4gICAgICBpZiAoIXNlbGYuJGlzTW9kaWZpZWQocGF0aCkpIHtcbiAgICAgICAgc2VsZi4kX18uYWN0aXZlUGF0aHMuaW5pdChwYXRoKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuLyoqXG4gKiBTZW5kcyBhbiB1cGRhdGVPbmUgY29tbWFuZCB3aXRoIHRoaXMgZG9jdW1lbnQgYF9pZGAgYXMgdGhlIHF1ZXJ5IHNlbGVjdG9yLlxuICpcbiAqICMjIyMgRXhhbXBsZTpcbiAqXG4gKiAgICAgd2VpcmRDYXIudXBkYXRlT25lKHskaW5jOiB7d2hlZWxzOjF9fSwgeyB3OiAxIH0sIGNhbGxiYWNrKTtcbiAqXG4gKiAjIyMjIFZhbGlkIG9wdGlvbnM6XG4gKlxuICogIC0gc2FtZSBhcyBpbiBbTW9kZWwudXBkYXRlT25lXShodHRwczovL21vbmdvb3NlanMuY29tL2RvY3MvYXBpL21vZGVsLmh0bWwjTW9kZWwudXBkYXRlT25lKVxuICpcbiAqIEBzZWUgTW9kZWwudXBkYXRlT25lIGh0dHBzOi8vbW9uZ29vc2Vqcy5jb20vZG9jcy9hcGkvbW9kZWwuaHRtbCNNb2RlbC51cGRhdGVPbmVcbiAqIEBwYXJhbSB7T2JqZWN0fSBkb2NcbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gb3B0aW9uYWwgc2VlIFtgUXVlcnkucHJvdG90eXBlLnNldE9wdGlvbnMoKWBdKGh0dHBzOi8vbW9uZ29vc2Vqcy5jb20vZG9jcy9hcGkvcXVlcnkuaHRtbCNRdWVyeS5wcm90b3R5cGUuc2V0T3B0aW9ucygpKVxuICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zLmxlYW5dIGlmIHRydXRoeSwgbW9uZ29vc2Ugd2lsbCByZXR1cm4gdGhlIGRvY3VtZW50IGFzIGEgcGxhaW4gSmF2YVNjcmlwdCBvYmplY3QgcmF0aGVyIHRoYW4gYSBtb25nb29zZSBkb2N1bWVudC4gU2VlIFtgUXVlcnkubGVhbigpYF0oaHR0cHM6Ly9tb25nb29zZWpzLmNvbS9kb2NzL2FwaS9xdWVyeS5odG1sI1F1ZXJ5LnByb3RvdHlwZS5sZWFuKCkpIGFuZCB0aGUgW01vbmdvb3NlIGxlYW4gdHV0b3JpYWxdKGh0dHBzOi8vbW9uZ29vc2Vqcy5jb20vZG9jcy90dXRvcmlhbHMvbGVhbi5odG1sKS5cbiAqIEBwYXJhbSB7Qm9vbGVhbnxTdHJpbmd9IFtvcHRpb25zLnN0cmljdF0gb3ZlcndyaXRlcyB0aGUgc2NoZW1hJ3MgW3N0cmljdCBtb2RlIG9wdGlvbl0oaHR0cHM6Ly9tb25nb29zZWpzLmNvbS9kb2NzL2d1aWRlLmh0bWwjc3RyaWN0KVxuICogQHBhcmFtIHtCb29sZWFufSBbb3B0aW9ucy50aW1lc3RhbXBzPW51bGxdIElmIHNldCB0byBgZmFsc2VgIGFuZCBbc2NoZW1hLWxldmVsIHRpbWVzdGFtcHNdKGh0dHBzOi8vbW9uZ29vc2Vqcy5jb20vZG9jcy9ndWlkZS5odG1sI3RpbWVzdGFtcHMpIGFyZSBlbmFibGVkLCBza2lwIHRpbWVzdGFtcHMgZm9yIHRoaXMgdXBkYXRlLiBOb3RlIHRoYXQgdGhpcyBhbGxvd3MgeW91IHRvIG92ZXJ3cml0ZSB0aW1lc3RhbXBzLiBEb2VzIG5vdGhpbmcgaWYgc2NoZW1hLWxldmVsIHRpbWVzdGFtcHMgYXJlIG5vdCBzZXQuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY2FsbGJhY2tdXG4gKiBAcmV0dXJuIHtRdWVyeX1cbiAqIEBhcGkgcHVibGljXG4gKiBAbWVtYmVyT2YgRG9jdW1lbnRcbiAqIEBpbnN0YW5jZVxuICovXG5cbkRvY3VtZW50LnByb3RvdHlwZS51cGRhdGVPbmUgPSBmdW5jdGlvbiB1cGRhdGVPbmUoZG9jLCBvcHRpb25zLCBjYWxsYmFjaykge1xuICBjb25zdCBxdWVyeSA9IHRoaXMuY29uc3RydWN0b3IudXBkYXRlT25lKHsgX2lkOiB0aGlzLl9pZCB9LCBkb2MsIG9wdGlvbnMpO1xuICBjb25zdCBzZWxmID0gdGhpcztcbiAgcXVlcnkucHJlKGZ1bmN0aW9uIHF1ZXJ5UHJlVXBkYXRlT25lKGNiKSB7XG4gICAgc2VsZi5jb25zdHJ1Y3Rvci5fbWlkZGxld2FyZS5leGVjUHJlKCd1cGRhdGVPbmUnLCBzZWxmLCBbc2VsZl0sIGNiKTtcbiAgfSk7XG4gIHF1ZXJ5LnBvc3QoZnVuY3Rpb24gcXVlcnlQb3N0VXBkYXRlT25lKGNiKSB7XG4gICAgc2VsZi5jb25zdHJ1Y3Rvci5fbWlkZGxld2FyZS5leGVjUG9zdCgndXBkYXRlT25lJywgc2VsZiwgW3NlbGZdLCB7fSwgY2IpO1xuICB9KTtcblxuICBpZiAodGhpcy4kc2Vzc2lvbigpICE9IG51bGwpIHtcbiAgICBpZiAoISgnc2Vzc2lvbicgaW4gcXVlcnkub3B0aW9ucykpIHtcbiAgICAgIHF1ZXJ5Lm9wdGlvbnMuc2Vzc2lvbiA9IHRoaXMuJHNlc3Npb24oKTtcbiAgICB9XG4gIH1cblxuICBpZiAoY2FsbGJhY2sgIT0gbnVsbCkge1xuICAgIHJldHVybiBxdWVyeS5leGVjKGNhbGxiYWNrKTtcbiAgfVxuXG4gIHJldHVybiBxdWVyeTtcbn07XG5cbi8qKlxuICogU2VuZHMgYSByZXBsYWNlT25lIGNvbW1hbmQgd2l0aCB0aGlzIGRvY3VtZW50IGBfaWRgIGFzIHRoZSBxdWVyeSBzZWxlY3Rvci5cbiAqXG4gKiAjIyMjIFZhbGlkIG9wdGlvbnM6XG4gKlxuICogIC0gc2FtZSBhcyBpbiBbTW9kZWwucmVwbGFjZU9uZV0oaHR0cHM6Ly9tb25nb29zZWpzLmNvbS9kb2NzL2FwaS9tb2RlbC5odG1sI01vZGVsLnJlcGxhY2VPbmUoKSlcbiAqXG4gKiBAc2VlIE1vZGVsLnJlcGxhY2VPbmUgaHR0cHM6Ly9tb25nb29zZWpzLmNvbS9kb2NzL2FwaS9tb2RlbC5odG1sI01vZGVsLnJlcGxhY2VPbmUoKVxuICogQHBhcmFtIHtPYmplY3R9IGRvY1xuICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXVxuICogQHBhcmFtIHtGdW5jdGlvbn0gW2NhbGxiYWNrXVxuICogQHJldHVybiB7UXVlcnl9XG4gKiBAYXBpIHB1YmxpY1xuICogQG1lbWJlck9mIERvY3VtZW50XG4gKiBAaW5zdGFuY2VcbiAqL1xuXG5Eb2N1bWVudC5wcm90b3R5cGUucmVwbGFjZU9uZSA9IGZ1bmN0aW9uIHJlcGxhY2VPbmUoKSB7XG4gIGNvbnN0IGFyZ3MgPSBbLi4uYXJndW1lbnRzXTtcbiAgYXJncy51bnNoaWZ0KHsgX2lkOiB0aGlzLl9pZCB9KTtcbiAgcmV0dXJuIHRoaXMuY29uc3RydWN0b3IucmVwbGFjZU9uZS5hcHBseSh0aGlzLmNvbnN0cnVjdG9yLCBhcmdzKTtcbn07XG5cbi8qKlxuICogR2V0dGVyL3NldHRlciBhcm91bmQgdGhlIHNlc3Npb24gYXNzb2NpYXRlZCB3aXRoIHRoaXMgZG9jdW1lbnQuIFVzZWQgdG9cbiAqIGF1dG9tYXRpY2FsbHkgc2V0IGBzZXNzaW9uYCBpZiB5b3UgYHNhdmUoKWAgYSBkb2MgdGhhdCB5b3UgZ290IGZyb20gYVxuICogcXVlcnkgd2l0aCBhbiBhc3NvY2lhdGVkIHNlc3Npb24uXG4gKlxuICogIyMjIyBFeGFtcGxlOlxuICpcbiAqICAgICBjb25zdCBzZXNzaW9uID0gTXlNb2RlbC5zdGFydFNlc3Npb24oKTtcbiAqICAgICBjb25zdCBkb2MgPSBhd2FpdCBNeU1vZGVsLmZpbmRPbmUoKS5zZXNzaW9uKHNlc3Npb24pO1xuICogICAgIGRvYy4kc2Vzc2lvbigpID09PSBzZXNzaW9uOyAvLyB0cnVlXG4gKiAgICAgZG9jLiRzZXNzaW9uKG51bGwpO1xuICogICAgIGRvYy4kc2Vzc2lvbigpID09PSBudWxsOyAvLyB0cnVlXG4gKlxuICogSWYgdGhpcyBpcyBhIHRvcC1sZXZlbCBkb2N1bWVudCwgc2V0dGluZyB0aGUgc2Vzc2lvbiBwcm9wYWdhdGVzIHRvIGFsbCBjaGlsZFxuICogZG9jcy5cbiAqXG4gKiBAcGFyYW0ge0NsaWVudFNlc3Npb259IFtzZXNzaW9uXSBvdmVyd3JpdGUgdGhlIGN1cnJlbnQgc2Vzc2lvblxuICogQHJldHVybiB7Q2xpZW50U2Vzc2lvbn1cbiAqIEBtZXRob2QgJHNlc3Npb25cbiAqIEBhcGkgcHVibGljXG4gKiBAbWVtYmVyT2YgRG9jdW1lbnRcbiAqL1xuXG5Eb2N1bWVudC5wcm90b3R5cGUuJHNlc3Npb24gPSBmdW5jdGlvbiAkc2Vzc2lvbihzZXNzaW9uKSB7XG4gIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAwKSB7XG4gICAgaWYgKHRoaXMuJF9fLnNlc3Npb24gIT0gbnVsbCAmJiB0aGlzLiRfXy5zZXNzaW9uLmhhc0VuZGVkKSB7XG4gICAgICB0aGlzLiRfXy5zZXNzaW9uID0gbnVsbDtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy4kX18uc2Vzc2lvbjtcbiAgfVxuXG4gIGlmIChzZXNzaW9uICE9IG51bGwgJiYgc2Vzc2lvbi5oYXNFbmRlZCkge1xuICAgIHRocm93IG5ldyBNb25nb29zZUVycm9yKCdDYW5ub3Qgc2V0IGEgZG9jdW1lbnRcXCdzIHNlc3Npb24gdG8gYSBzZXNzaW9uIHRoYXQgaGFzIGVuZGVkLiBNYWtlIHN1cmUgeW91IGhhdmVuXFwndCAnICtcbiAgICAgICdjYWxsZWQgYGVuZFNlc3Npb24oKWAgb24gdGhlIHNlc3Npb24geW91IGFyZSBwYXNzaW5nIHRvIGAkc2Vzc2lvbigpYC4nKTtcbiAgfVxuXG4gIGlmIChzZXNzaW9uID09IG51bGwgJiYgdGhpcy4kX18uc2Vzc2lvbiA9PSBudWxsKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgdGhpcy4kX18uc2Vzc2lvbiA9IHNlc3Npb247XG5cbiAgaWYgKCF0aGlzLiRpc1N1YmRvY3VtZW50KSB7XG4gICAgY29uc3Qgc3ViZG9jcyA9IHRoaXMuJGdldEFsbFN1YmRvY3MoKTtcbiAgICBmb3IgKGNvbnN0IGNoaWxkIG9mIHN1YmRvY3MpIHtcbiAgICAgIGNoaWxkLiRzZXNzaW9uKHNlc3Npb24pO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBzZXNzaW9uO1xufTtcblxuLyoqXG4gKiBHZXR0ZXIvc2V0dGVyIGFyb3VuZCB3aGV0aGVyIHRoaXMgZG9jdW1lbnQgd2lsbCBhcHBseSB0aW1lc3RhbXBzIGJ5XG4gKiBkZWZhdWx0IHdoZW4gdXNpbmcgYHNhdmUoKWAgYW5kIGBidWxrU2F2ZSgpYC5cbiAqXG4gKiAjIyMjIEV4YW1wbGU6XG4gKlxuICogICAgIGNvbnN0IFRlc3RNb2RlbCA9IG1vbmdvb3NlLm1vZGVsKCdUZXN0JywgbmV3IFNjaGVtYSh7IG5hbWU6IFN0cmluZyB9LCB7IHRpbWVzdGFtcHM6IHRydWUgfSkpO1xuICogICAgIGNvbnN0IGRvYyA9IG5ldyBUZXN0TW9kZWwoeyBuYW1lOiAnSm9obiBTbWl0aCcgfSk7XG4gKlxuICogICAgIGRvYy4kdGltZXN0YW1wcygpOyAvLyB0cnVlXG4gKlxuICogICAgIGRvYy4kdGltZXN0YW1wcyhmYWxzZSk7XG4gKiAgICAgYXdhaXQgZG9jLnNhdmUoKTsgLy8gRG9lcyAqKm5vdCoqIGFwcGx5IHRpbWVzdGFtcHNcbiAqXG4gKiBAcGFyYW0ge0Jvb2xlYW59IFt2YWx1ZV0gb3ZlcndyaXRlIHRoZSBjdXJyZW50IHNlc3Npb25cbiAqIEByZXR1cm4ge0RvY3VtZW50fGJvb2xlYW58dW5kZWZpbmVkfSBXaGVuIHVzZWQgYXMgYSBnZXR0ZXIgKG5vIGFyZ3VtZW50KSwgYSBib29sZWFuIHdpbGwgYmUgcmV0dXJuZWQgaW5kaWNhdGluZyB0aGUgdGltZXN0YW1wcyBvcHRpb24gc3RhdGUgb3IgaWYgdW5zZXQgXCJ1bmRlZmluZWRcIiB3aWxsIGJlIHVzZWQsIG90aGVyd2lzZSB3aWxsIHJldHVybiBcInRoaXNcIlxuICogQG1ldGhvZCAkdGltZXN0YW1wc1xuICogQGFwaSBwdWJsaWNcbiAqIEBtZW1iZXJPZiBEb2N1bWVudFxuICovXG5cbkRvY3VtZW50LnByb3RvdHlwZS4kdGltZXN0YW1wcyA9IGZ1bmN0aW9uICR0aW1lc3RhbXBzKHZhbHVlKSB7XG4gIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAwKSB7XG4gICAgaWYgKHRoaXMuJF9fLnRpbWVzdGFtcHMgIT0gbnVsbCkge1xuICAgICAgcmV0dXJuIHRoaXMuJF9fLnRpbWVzdGFtcHM7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuJF9fc2NoZW1hKSB7XG4gICAgICByZXR1cm4gdGhpcy4kX19zY2hlbWEub3B0aW9ucy50aW1lc3RhbXBzO1xuICAgIH1cblxuICAgIHJldHVybiB1bmRlZmluZWQ7XG4gIH1cblxuICBjb25zdCBjdXJyZW50VmFsdWUgPSB0aGlzLiR0aW1lc3RhbXBzKCk7XG4gIGlmICh2YWx1ZSAhPT0gY3VycmVudFZhbHVlKSB7XG4gICAgdGhpcy4kX18udGltZXN0YW1wcyA9IHZhbHVlO1xuICB9XG5cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIE92ZXJ3cml0ZSBhbGwgdmFsdWVzIGluIHRoaXMgZG9jdW1lbnQgd2l0aCB0aGUgdmFsdWVzIG9mIGBvYmpgLCBleGNlcHRcbiAqIGZvciBpbW11dGFibGUgcHJvcGVydGllcy4gQmVoYXZlcyBzaW1pbGFybHkgdG8gYHNldCgpYCwgZXhjZXB0IGZvciBpdFxuICogdW5zZXRzIGFsbCBwcm9wZXJ0aWVzIHRoYXQgYXJlbid0IGluIGBvYmpgLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmogdGhlIG9iamVjdCB0byBvdmVyd3JpdGUgdGhpcyBkb2N1bWVudCB3aXRoXG4gKiBAbWV0aG9kIG92ZXJ3cml0ZVxuICogQG1lbWJlck9mIERvY3VtZW50XG4gKiBAaW5zdGFuY2VcbiAqIEBhcGkgcHVibGljXG4gKiBAcmV0dXJuIHtEb2N1bWVudH0gdGhpc1xuICovXG5cbkRvY3VtZW50LnByb3RvdHlwZS5vdmVyd3JpdGUgPSBmdW5jdGlvbiBvdmVyd3JpdGUob2JqKSB7XG4gIGNvbnN0IGtleXMgPSBBcnJheS5mcm9tKG5ldyBTZXQoT2JqZWN0LmtleXModGhpcy5fZG9jKS5jb25jYXQoT2JqZWN0LmtleXMob2JqKSkpKTtcblxuICBmb3IgKGNvbnN0IGtleSBvZiBrZXlzKSB7XG4gICAgaWYgKGtleSA9PT0gJ19pZCcpIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICAvLyBFeHBsaWNpdGx5IHNraXAgdmVyc2lvbiBrZXlcbiAgICBpZiAodGhpcy4kX19zY2hlbWEub3B0aW9ucy52ZXJzaW9uS2V5ICYmIGtleSA9PT0gdGhpcy4kX19zY2hlbWEub3B0aW9ucy52ZXJzaW9uS2V5KSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgaWYgKHRoaXMuJF9fc2NoZW1hLm9wdGlvbnMuZGlzY3JpbWluYXRvcktleSAmJiBrZXkgPT09IHRoaXMuJF9fc2NoZW1hLm9wdGlvbnMuZGlzY3JpbWluYXRvcktleSkge1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIHRoaXMuJHNldChrZXksIG9ialtrZXldKTtcbiAgfVxuXG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBBbGlhcyBmb3IgYHNldCgpYCwgdXNlZCBpbnRlcm5hbGx5IHRvIGF2b2lkIGNvbmZsaWN0c1xuICpcbiAqIEBwYXJhbSB7U3RyaW5nfE9iamVjdH0gcGF0aCBwYXRoIG9yIG9iamVjdCBvZiBrZXkvdmFscyB0byBzZXRcbiAqIEBwYXJhbSB7QW55fSB2YWwgdGhlIHZhbHVlIHRvIHNldFxuICogQHBhcmFtIHtTY2hlbWF8U3RyaW5nfE51bWJlcnxCdWZmZXJ8Kn0gW3R5cGVdIG9wdGlvbmFsbHkgc3BlY2lmeSBhIHR5cGUgZm9yIFwib24tdGhlLWZseVwiIGF0dHJpYnV0ZXNcbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gb3B0aW9uYWxseSBzcGVjaWZ5IG9wdGlvbnMgdGhhdCBtb2RpZnkgdGhlIGJlaGF2aW9yIG9mIHRoZSBzZXRcbiAqIEBwYXJhbSB7Qm9vbGVhbn0gW29wdGlvbnMubWVyZ2U9ZmFsc2VdIGlmIHRydWUsIHNldHRpbmcgYSBbbmVzdGVkIHBhdGhdKGh0dHBzOi8vbW9uZ29vc2Vqcy5jb20vZG9jcy9zdWJkb2NzLmh0bWwjc3ViZG9jdW1lbnRzLXZlcnN1cy1uZXN0ZWQtcGF0aHMpIHdpbGwgbWVyZ2UgZXhpc3RpbmcgdmFsdWVzIHJhdGhlciB0aGFuIG92ZXJ3cml0ZSB0aGUgd2hvbGUgb2JqZWN0LiBTbyBgZG9jLnNldCgnbmVzdGVkJywgeyBhOiAxLCBiOiAyIH0pYCBiZWNvbWVzIGBkb2Muc2V0KCduZXN0ZWQuYScsIDEpOyBkb2Muc2V0KCduZXN0ZWQuYicsIDIpO2BcbiAqIEByZXR1cm4ge0RvY3VtZW50fSB0aGlzXG4gKiBAbWV0aG9kICRzZXRcbiAqIEBtZW1iZXJPZiBEb2N1bWVudFxuICogQGluc3RhbmNlXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbkRvY3VtZW50LnByb3RvdHlwZS4kc2V0ID0gZnVuY3Rpb24gJHNldChwYXRoLCB2YWwsIHR5cGUsIG9wdGlvbnMpIHtcbiAgaWYgKHV0aWxzLmlzUE9KTyh0eXBlKSkge1xuICAgIG9wdGlvbnMgPSB0eXBlO1xuICAgIHR5cGUgPSB1bmRlZmluZWQ7XG4gIH1cblxuICBjb25zdCBtZXJnZSA9IG9wdGlvbnMgJiYgb3B0aW9ucy5tZXJnZTtcbiAgY29uc3QgYWRob2MgPSB0eXBlICYmIHR5cGUgIT09IHRydWU7XG4gIGNvbnN0IGNvbnN0cnVjdGluZyA9IHR5cGUgPT09IHRydWU7XG4gIGxldCBhZGhvY3M7XG4gIGxldCBrZXlzO1xuICBsZXQgaSA9IDA7XG4gIGxldCBwYXRodHlwZTtcbiAgbGV0IGtleTtcbiAgbGV0IHByZWZpeDtcblxuICBjb25zdCB1c2VyU3BlY2lmaWVkU3RyaWN0ID0gb3B0aW9ucyAmJiAnc3RyaWN0JyBpbiBvcHRpb25zO1xuICBsZXQgc3RyaWN0ID0gdXNlclNwZWNpZmllZFN0cmljdFxuICAgID8gb3B0aW9ucy5zdHJpY3RcbiAgICA6IHRoaXMuJF9fLnN0cmljdE1vZGU7XG5cbiAgaWYgKGFkaG9jKSB7XG4gICAgYWRob2NzID0gdGhpcy4kX18uYWRob2NQYXRocyB8fCAodGhpcy4kX18uYWRob2NQYXRocyA9IHt9KTtcbiAgICBhZGhvY3NbcGF0aF0gPSB0aGlzLiRfX3NjaGVtYS5pbnRlcnByZXRBc1R5cGUocGF0aCwgdHlwZSwgdGhpcy4kX19zY2hlbWEub3B0aW9ucyk7XG4gIH1cblxuICBpZiAocGF0aCA9PSBudWxsKSB7XG4gICAgW3BhdGgsIHZhbF0gPSBbdmFsLCBwYXRoXTtcbiAgfSBlbHNlIGlmICh0eXBlb2YgcGF0aCAhPT0gJ3N0cmluZycpIHtcbiAgICAvLyBuZXcgRG9jdW1lbnQoeyBrZXk6IHZhbCB9KVxuICAgIGlmIChwYXRoIGluc3RhbmNlb2YgRG9jdW1lbnQpIHtcbiAgICAgIGlmIChwYXRoLiRfX2lzTmVzdGVkKSB7XG4gICAgICAgIHBhdGggPSBwYXRoLnRvT2JqZWN0KCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBwYXRoID0gcGF0aC5fZG9jO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAocGF0aCA9PSBudWxsKSB7XG4gICAgICBbcGF0aCwgdmFsXSA9IFt2YWwsIHBhdGhdO1xuICAgIH1cblxuICAgIHByZWZpeCA9IHZhbCA/IHZhbCArICcuJyA6ICcnO1xuICAgIGtleXMgPSBnZXRLZXlzSW5TY2hlbWFPcmRlcih0aGlzLiRfX3NjaGVtYSwgcGF0aCk7XG5cbiAgICBjb25zdCBsZW4gPSBrZXlzLmxlbmd0aDtcblxuICAgIC8vIGBfc2tpcE1pbmltaXplVG9wTGV2ZWxgIGlzIGJlY2F1c2Ugd2UgbWF5IGhhdmUgZGVsZXRlZCB0aGUgdG9wLWxldmVsXG4gICAgLy8gbmVzdGVkIGtleSB0byBlbnN1cmUga2V5IG9yZGVyLlxuICAgIGNvbnN0IF9za2lwTWluaW1pemVUb3BMZXZlbCA9IG9wdGlvbnMgJiYgb3B0aW9ucy5fc2tpcE1pbmltaXplVG9wTGV2ZWwgfHwgZmFsc2U7XG4gICAgaWYgKGxlbiA9PT0gMCAmJiBfc2tpcE1pbmltaXplVG9wTGV2ZWwpIHtcbiAgICAgIGRlbGV0ZSBvcHRpb25zLl9za2lwTWluaW1pemVUb3BMZXZlbDtcbiAgICAgIGlmICh2YWwpIHtcbiAgICAgICAgdGhpcy4kc2V0KHZhbCwge30pO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgb3B0aW9ucyA9IE9iamVjdC5hc3NpZ24oe30sIG9wdGlvbnMsIHsgX3NraXBNaW5pbWl6ZVRvcExldmVsOiBmYWxzZSB9KTtcblxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGVuOyArK2kpIHtcbiAgICAgIGtleSA9IGtleXNbaV07XG4gICAgICBjb25zdCBwYXRoTmFtZSA9IHByZWZpeCA/IHByZWZpeCArIGtleSA6IGtleTtcbiAgICAgIHBhdGh0eXBlID0gdGhpcy4kX19zY2hlbWEucGF0aFR5cGUocGF0aE5hbWUpO1xuICAgICAgY29uc3QgdmFsRm9yS2V5ID0gcGF0aFtrZXldO1xuXG4gICAgICAvLyBPbiBpbml0aWFsIHNldCwgZGVsZXRlIGFueSBuZXN0ZWQga2V5cyBpZiB3ZSdyZSBnb2luZyB0byBvdmVyd3JpdGVcbiAgICAgIC8vIHRoZW0gdG8gZW5zdXJlIHdlIGtlZXAgdGhlIHVzZXIncyBrZXkgb3JkZXIuXG4gICAgICBpZiAodHlwZSA9PT0gdHJ1ZSAmJlxuICAgICAgICAgICFwcmVmaXggJiZcbiAgICAgICAgICB2YWxGb3JLZXkgIT0gbnVsbCAmJlxuICAgICAgICAgIHBhdGh0eXBlID09PSAnbmVzdGVkJyAmJlxuICAgICAgICAgIHRoaXMuX2RvY1trZXldICE9IG51bGwpIHtcbiAgICAgICAgZGVsZXRlIHRoaXMuX2RvY1trZXldO1xuICAgICAgfVxuXG4gICAgICBpZiAodXRpbHMuaXNOb25CdWlsdGluT2JqZWN0KHZhbEZvcktleSkgJiYgcGF0aHR5cGUgPT09ICduZXN0ZWQnKSB7XG4gICAgICAgIHRoaXMuJHNldChwYXRoTmFtZSwgdmFsRm9yS2V5LCBjb25zdHJ1Y3RpbmcsIE9iamVjdC5hc3NpZ24oe30sIG9wdGlvbnMsIHsgX3NraXBNYXJrTW9kaWZpZWQ6IHRydWUgfSkpO1xuICAgICAgICAkYXBwbHlEZWZhdWx0c1RvTmVzdGVkKHRoaXMuJGdldChwYXRoTmFtZSksIHBhdGhOYW1lLCB0aGlzKTtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9IGVsc2UgaWYgKHN0cmljdCkge1xuICAgICAgICAvLyBEb24ndCBvdmVyd3JpdGUgZGVmYXVsdHMgd2l0aCB1bmRlZmluZWQga2V5cyAoZ2gtMzk4MSkgKGdoLTkwMzkpXG4gICAgICAgIGlmIChjb25zdHJ1Y3RpbmcgJiYgdmFsRm9yS2V5ID09PSB2b2lkIDAgJiZcbiAgICAgICAgICAgIHRoaXMuJGdldChwYXRoTmFtZSkgIT09IHZvaWQgMCkge1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHBhdGh0eXBlID09PSAnYWRob2NPclVuZGVmaW5lZCcpIHtcbiAgICAgICAgICBwYXRodHlwZSA9IGdldEVtYmVkZGVkRGlzY3JpbWluYXRvclBhdGgodGhpcywgcGF0aE5hbWUsIHsgdHlwZU9ubHk6IHRydWUgfSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAocGF0aHR5cGUgPT09ICdyZWFsJyB8fCBwYXRodHlwZSA9PT0gJ3ZpcnR1YWwnKSB7XG4gICAgICAgICAgdGhpcy4kc2V0KHBhdGhOYW1lLCB2YWxGb3JLZXksIGNvbnN0cnVjdGluZywgb3B0aW9ucyk7XG4gICAgICAgIH0gZWxzZSBpZiAocGF0aHR5cGUgPT09ICduZXN0ZWQnICYmIHZhbEZvcktleSBpbnN0YW5jZW9mIERvY3VtZW50KSB7XG4gICAgICAgICAgdGhpcy4kc2V0KHBhdGhOYW1lLFxuICAgICAgICAgICAgdmFsRm9yS2V5LnRvT2JqZWN0KHsgdHJhbnNmb3JtOiBmYWxzZSB9KSwgY29uc3RydWN0aW5nLCBvcHRpb25zKTtcbiAgICAgICAgfSBlbHNlIGlmIChzdHJpY3QgPT09ICd0aHJvdycpIHtcbiAgICAgICAgICBpZiAocGF0aHR5cGUgPT09ICduZXN0ZWQnKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgT2JqZWN0RXhwZWN0ZWRFcnJvcihrZXksIHZhbEZvcktleSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBTdHJpY3RNb2RlRXJyb3Ioa2V5KTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAodmFsRm9yS2V5ICE9PSB2b2lkIDApIHtcbiAgICAgICAgdGhpcy4kc2V0KHBhdGhOYW1lLCB2YWxGb3JLZXksIGNvbnN0cnVjdGluZywgb3B0aW9ucyk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gRW5zdXJlIGFsbCBwcm9wZXJ0aWVzIGFyZSBpbiBjb3JyZWN0IG9yZGVyXG4gICAgY29uc3Qgb3JkZXJlZERvYyA9IHt9O1xuICAgIGNvbnN0IG9yZGVyZWRLZXlzID0gT2JqZWN0LmtleXModGhpcy4kX19zY2hlbWEudHJlZSk7XG4gICAgZm9yIChsZXQgaSA9IDAsIGxlbiA9IG9yZGVyZWRLZXlzLmxlbmd0aDsgaSA8IGxlbjsgKytpKSB7XG4gICAgICAoa2V5ID0gb3JkZXJlZEtleXNbaV0pICYmXG4gICAgICAodGhpcy5fZG9jLmhhc093blByb3BlcnR5KGtleSkpICYmXG4gICAgICAob3JkZXJlZERvY1trZXldID0gdW5kZWZpbmVkKTtcbiAgICB9XG4gICAgdGhpcy5fZG9jID0gT2JqZWN0LmFzc2lnbihvcmRlcmVkRG9jLCB0aGlzLl9kb2MpO1xuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICBsZXQgcGF0aFR5cGUgPSB0aGlzLiRfX3NjaGVtYS5wYXRoVHlwZShwYXRoKTtcbiAgbGV0IHBhcnRzID0gbnVsbDtcbiAgaWYgKHBhdGhUeXBlID09PSAnYWRob2NPclVuZGVmaW5lZCcpIHtcbiAgICBwYXJ0cyA9IHBhdGguaW5kZXhPZignLicpID09PSAtMSA/IFtwYXRoXSA6IHBhdGguc3BsaXQoJy4nKTtcbiAgICBwYXRoVHlwZSA9IGdldEVtYmVkZGVkRGlzY3JpbWluYXRvclBhdGgodGhpcywgcGFydHMsIHsgdHlwZU9ubHk6IHRydWUgfSk7XG4gIH1cbiAgaWYgKHBhdGhUeXBlID09PSAnYWRob2NPclVuZGVmaW5lZCcgJiYgIXVzZXJTcGVjaWZpZWRTdHJpY3QpIHtcbiAgICAvLyBNYXkgYmUgcGF0aCB1bmRlcm5lYXRoIG5vbi1zdHJpY3Qgc2NoZW1hXG4gICAgaWYgKHBhcnRzID09IG51bGwpIHtcbiAgICAgIHBhcnRzID0gcGF0aC5pbmRleE9mKCcuJykgPT09IC0xID8gW3BhdGhdIDogcGF0aC5zcGxpdCgnLicpO1xuICAgIH1cbiAgICBjb25zdCBzdWJkb2NTdHJpY3QgPSBnZXRTdWJkb2N1bWVudFN0cmljdFZhbHVlKHRoaXMuJF9fc2NoZW1hLCBwYXJ0cyk7XG4gICAgaWYgKHN1YmRvY1N0cmljdCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBzdHJpY3QgPSBzdWJkb2NTdHJpY3Q7XG4gICAgfVxuICB9XG5cbiAgLy8gQXNzdW1lIHRoaXMgaXMgYSBNb25nb29zZSBkb2N1bWVudCB0aGF0IHdhcyBjb3BpZWQgaW50byBhIFBPSk8gdXNpbmdcbiAgLy8gYE9iamVjdC5hc3NpZ24oKWAgb3IgYHsuLi5kb2N9YFxuICB2YWwgPSBoYW5kbGVTcHJlYWREb2ModmFsKTtcblxuICAvLyBpZiB0aGlzIGRvYyBpcyBiZWluZyBjb25zdHJ1Y3RlZCB3ZSBzaG91bGQgbm90IHRyaWdnZXIgZ2V0dGVyc1xuICBjb25zdCBwcmlvclZhbCA9ICgoKSA9PiB7XG4gICAgaWYgKHRoaXMuJF9fLnByaW9yRG9jICE9IG51bGwpIHtcbiAgICAgIHJldHVybiB0aGlzLiRfXy5wcmlvckRvYy4kX19nZXRWYWx1ZShwYXRoKTtcbiAgICB9XG4gICAgaWYgKGNvbnN0cnVjdGluZykge1xuICAgICAgcmV0dXJuIHZvaWQgMDtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuJF9fZ2V0VmFsdWUocGF0aCk7XG4gIH0pKCk7XG5cbiAgaWYgKHBhdGhUeXBlID09PSAnbmVzdGVkJyAmJiB2YWwpIHtcbiAgICBpZiAodHlwZW9mIHZhbCA9PT0gJ29iamVjdCcgJiYgdmFsICE9IG51bGwpIHtcbiAgICAgIGlmICh2YWwuJF9fICE9IG51bGwpIHtcbiAgICAgICAgdmFsID0gdmFsLnRvT2JqZWN0KGludGVybmFsVG9PYmplY3RPcHRpb25zKTtcbiAgICAgIH1cbiAgICAgIGlmICh2YWwgPT0gbnVsbCkge1xuICAgICAgICB0aGlzLmludmFsaWRhdGUocGF0aCwgbmV3IE1vbmdvb3NlRXJyb3IuQ2FzdEVycm9yKCdPYmplY3QnLCB2YWwsIHBhdGgpKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9XG4gICAgICBjb25zdCB3YXNNb2RpZmllZCA9IHRoaXMuJGlzTW9kaWZpZWQocGF0aCk7XG4gICAgICBjb25zdCBoYXNJbml0aWFsVmFsID0gdGhpcy4kX18uc2F2ZWRTdGF0ZSAhPSBudWxsICYmIHRoaXMuJF9fLnNhdmVkU3RhdGUuaGFzT3duUHJvcGVydHkocGF0aCk7XG4gICAgICBpZiAodGhpcy4kX18uc2F2ZWRTdGF0ZSAhPSBudWxsICYmICF0aGlzLiRpc05ldyAmJiAhdGhpcy4kX18uc2F2ZWRTdGF0ZS5oYXNPd25Qcm9wZXJ0eShwYXRoKSkge1xuICAgICAgICBjb25zdCBpbml0aWFsVmFsID0gdGhpcy4kX19nZXRWYWx1ZShwYXRoKTtcbiAgICAgICAgdGhpcy4kX18uc2F2ZWRTdGF0ZVtwYXRoXSA9IGluaXRpYWxWYWw7XG5cbiAgICAgICAgY29uc3Qga2V5cyA9IE9iamVjdC5rZXlzKGluaXRpYWxWYWwgfHwge30pO1xuICAgICAgICBmb3IgKGNvbnN0IGtleSBvZiBrZXlzKSB7XG4gICAgICAgICAgdGhpcy4kX18uc2F2ZWRTdGF0ZVtwYXRoICsgJy4nICsga2V5XSA9IGluaXRpYWxWYWxba2V5XTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAoIW1lcmdlKSB7XG4gICAgICAgIHRoaXMuJF9fc2V0VmFsdWUocGF0aCwgbnVsbCk7XG4gICAgICAgIGNsZWFuTW9kaWZpZWRTdWJwYXRocyh0aGlzLCBwYXRoKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiB0aGlzLiRzZXQodmFsLCBwYXRoLCBjb25zdHJ1Y3RpbmcpO1xuICAgICAgfVxuXG4gICAgICBjb25zdCBrZXlzID0gZ2V0S2V5c0luU2NoZW1hT3JkZXIodGhpcy4kX19zY2hlbWEsIHZhbCwgcGF0aCk7XG5cbiAgICAgIHRoaXMuJF9fc2V0VmFsdWUocGF0aCwge30pO1xuICAgICAgZm9yIChjb25zdCBrZXkgb2Yga2V5cykge1xuICAgICAgICB0aGlzLiRzZXQocGF0aCArICcuJyArIGtleSwgdmFsW2tleV0sIGNvbnN0cnVjdGluZywgeyAuLi5vcHRpb25zLCBfc2tpcE1hcmtNb2RpZmllZDogdHJ1ZSB9KTtcbiAgICAgIH1cbiAgICAgIGlmIChwcmlvclZhbCAhPSBudWxsICYmXG4gICAgICAgICAgKCF3YXNNb2RpZmllZCB8fCBoYXNJbml0aWFsVmFsKSAmJlxuICAgICAgICAgIHV0aWxzLmRlZXBFcXVhbChoYXNJbml0aWFsVmFsID8gdGhpcy4kX18uc2F2ZWRTdGF0ZVtwYXRoXSA6IHByaW9yVmFsLCB2YWwpKSB7XG4gICAgICAgIHRoaXMudW5tYXJrTW9kaWZpZWQocGF0aCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLm1hcmtNb2RpZmllZChwYXRoKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICB0aGlzLmludmFsaWRhdGUocGF0aCwgbmV3IE1vbmdvb3NlRXJyb3IuQ2FzdEVycm9yKCdPYmplY3QnLCB2YWwsIHBhdGgpKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIGxldCBzY2hlbWE7XG4gIGlmIChwYXJ0cyA9PSBudWxsKSB7XG4gICAgcGFydHMgPSBwYXRoLmluZGV4T2YoJy4nKSA9PT0gLTEgPyBbcGF0aF0gOiBwYXRoLnNwbGl0KCcuJyk7XG4gIH1cblxuICAvLyBNaWdodCBuZWVkIHRvIGNoYW5nZSBwYXRoIGZvciB0b3AtbGV2ZWwgYWxpYXNcbiAgaWYgKHR5cGVvZiB0aGlzLiRfX3NjaGVtYS5hbGlhc2VzW3BhcnRzWzBdXSA9PT0gJ3N0cmluZycpIHtcbiAgICBwYXJ0c1swXSA9IHRoaXMuJF9fc2NoZW1hLmFsaWFzZXNbcGFydHNbMF1dO1xuICB9XG5cbiAgaWYgKHBhdGhUeXBlID09PSAnYWRob2NPclVuZGVmaW5lZCcgJiYgc3RyaWN0KSB7XG4gICAgLy8gY2hlY2sgZm9yIHJvb3RzIHRoYXQgYXJlIE1peGVkIHR5cGVzXG4gICAgbGV0IG1peGVkO1xuXG4gICAgZm9yIChpID0gMDsgaSA8IHBhcnRzLmxlbmd0aDsgKytpKSB7XG4gICAgICBjb25zdCBzdWJwYXRoID0gcGFydHMuc2xpY2UoMCwgaSArIDEpLmpvaW4oJy4nKTtcblxuICAgICAgLy8gSWYgcGF0aCBpcyB1bmRlcm5lYXRoIGEgdmlydHVhbCwgYnlwYXNzIGV2ZXJ5dGhpbmcgYW5kIGp1c3Qgc2V0IGl0LlxuICAgICAgaWYgKGkgKyAxIDwgcGFydHMubGVuZ3RoICYmIHRoaXMuJF9fc2NoZW1hLnBhdGhUeXBlKHN1YnBhdGgpID09PSAndmlydHVhbCcpIHtcbiAgICAgICAgbXBhdGguc2V0KHBhdGgsIHZhbCwgdGhpcyk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfVxuXG4gICAgICBzY2hlbWEgPSB0aGlzLiRfX3NjaGVtYS5wYXRoKHN1YnBhdGgpO1xuICAgICAgaWYgKHNjaGVtYSA9PSBudWxsKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuXG4gICAgICBpZiAoc2NoZW1hIGluc3RhbmNlb2YgTWl4ZWRTY2hlbWEpIHtcbiAgICAgICAgLy8gYWxsb3cgY2hhbmdlcyB0byBzdWIgcGF0aHMgb2YgbWl4ZWQgdHlwZXNcbiAgICAgICAgbWl4ZWQgPSB0cnVlO1xuICAgICAgICBicmVhaztcbiAgICAgIH0gZWxzZSBpZiAoc2NoZW1hLiRpc1NjaGVtYU1hcCAmJiBzY2hlbWEuJF9fc2NoZW1hVHlwZSBpbnN0YW5jZW9mIE1peGVkU2NoZW1hICYmIGkgPCBwYXJ0cy5sZW5ndGggLSAxKSB7XG4gICAgICAgIC8vIE1hcCBvZiBtaXhlZCBhbmQgbm90IHRoZSBsYXN0IGVsZW1lbnQgaW4gdGhlIHBhdGggcmVzb2x2ZXMgdG8gbWl4ZWRcbiAgICAgICAgbWl4ZWQgPSB0cnVlO1xuICAgICAgICBzY2hlbWEgPSBzY2hlbWEuJF9fc2NoZW1hVHlwZTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHNjaGVtYSA9PSBudWxsKSB7XG4gICAgICAvLyBDaGVjayBmb3IgZW1iZWRkZWQgZGlzY3JpbWluYXRvcnNcbiAgICAgIHNjaGVtYSA9IGdldEVtYmVkZGVkRGlzY3JpbWluYXRvclBhdGgodGhpcywgcGF0aCk7XG4gICAgfVxuXG4gICAgaWYgKCFtaXhlZCAmJiAhc2NoZW1hKSB7XG4gICAgICBpZiAoc3RyaWN0ID09PSAndGhyb3cnKSB7XG4gICAgICAgIHRocm93IG5ldyBTdHJpY3RNb2RlRXJyb3IocGF0aCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gIH0gZWxzZSBpZiAocGF0aFR5cGUgPT09ICd2aXJ0dWFsJykge1xuICAgIHNjaGVtYSA9IHRoaXMuJF9fc2NoZW1hLnZpcnR1YWxwYXRoKHBhdGgpO1xuICAgIHNjaGVtYS5hcHBseVNldHRlcnModmFsLCB0aGlzKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfSBlbHNlIHtcbiAgICBzY2hlbWEgPSB0aGlzLiRfX3BhdGgocGF0aCk7XG4gIH1cblxuICAvLyBnaC00NTc4LCBpZiBzZXR0aW5nIGEgZGVlcGx5IG5lc3RlZCBwYXRoIHRoYXQgZG9lc24ndCBleGlzdCB5ZXQsIGNyZWF0ZSBpdFxuICBsZXQgY3VyID0gdGhpcy5fZG9jO1xuICBsZXQgY3VyUGF0aCA9ICcnO1xuICBmb3IgKGkgPSAwOyBpIDwgcGFydHMubGVuZ3RoIC0gMTsgKytpKSB7XG4gICAgY3VyID0gY3VyW3BhcnRzW2ldXTtcbiAgICBjdXJQYXRoICs9IChjdXJQYXRoLmxlbmd0aCAhPT0gMCA/ICcuJyA6ICcnKSArIHBhcnRzW2ldO1xuICAgIGlmICghY3VyKSB7XG4gICAgICB0aGlzLiRzZXQoY3VyUGF0aCwge30pO1xuICAgICAgLy8gSGFjayByZTogZ2gtNTgwMC4gSWYgbmVzdGVkIGZpZWxkIGlzIG5vdCBzZWxlY3RlZCwgaXQgcHJvYmFibHkgZXhpc3RzXG4gICAgICAvLyBzbyBgTW9uZ29TZXJ2ZXJFcnJvcjogY2Fubm90IHVzZSB0aGUgcGFydCAobmVzdGVkIG9mIG5lc3RlZC5udW0pIHRvXG4gICAgICAvLyB0cmF2ZXJzZSB0aGUgZWxlbWVudCAoe25lc3RlZDogbnVsbH0pYCBpcyBub3QgbGlrZWx5LiBJZiB1c2VyIGdldHNcbiAgICAgIC8vIHRoYXQgZXJyb3IsIGl0cyB0aGVpciBmYXVsdCBmb3Igbm93LiBXZSBzaG91bGQgcmVjb25zaWRlciBkaXNhbGxvd2luZ1xuICAgICAgLy8gbW9kaWZ5aW5nIG5vdCBzZWxlY3RlZCBwYXRocyBmb3IgNi54XG4gICAgICBpZiAoIXRoaXMuJF9faXNTZWxlY3RlZChjdXJQYXRoKSkge1xuICAgICAgICB0aGlzLnVubWFya01vZGlmaWVkKGN1clBhdGgpO1xuICAgICAgfVxuICAgICAgY3VyID0gdGhpcy4kX19nZXRWYWx1ZShjdXJQYXRoKTtcbiAgICB9XG4gIH1cblxuICBsZXQgcGF0aFRvTWFyaztcblxuICAvLyBXaGVuIHVzaW5nIHRoZSAkc2V0IG9wZXJhdG9yIHRoZSBwYXRoIHRvIHRoZSBmaWVsZCBtdXN0IGFscmVhZHkgZXhpc3QuXG4gIC8vIEVsc2UgbW9uZ29kYiB0aHJvd3M6IFwiTEVGVF9TVUJGSUVMRCBvbmx5IHN1cHBvcnRzIE9iamVjdFwiXG5cbiAgaWYgKHBhcnRzLmxlbmd0aCA8PSAxKSB7XG4gICAgcGF0aFRvTWFyayA9IHBhdGg7XG4gIH0gZWxzZSB7XG4gICAgY29uc3QgbGVuID0gcGFydHMubGVuZ3RoO1xuICAgIGZvciAoaSA9IDA7IGkgPCBsZW47ICsraSkge1xuICAgICAgY29uc3Qgc3VicGF0aCA9IHBhcnRzLnNsaWNlKDAsIGkgKyAxKS5qb2luKCcuJyk7XG4gICAgICBpZiAodGhpcy4kZ2V0KHN1YnBhdGgsIG51bGwsIHsgZ2V0dGVyczogZmFsc2UgfSkgPT09IG51bGwpIHtcbiAgICAgICAgcGF0aFRvTWFyayA9IHN1YnBhdGg7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmICghcGF0aFRvTWFyaykge1xuICAgICAgcGF0aFRvTWFyayA9IHBhdGg7XG4gICAgfVxuICB9XG5cbiAgaWYgKCFzY2hlbWEpIHtcbiAgICB0aGlzLiRfX3NldChwYXRoVG9NYXJrLCBwYXRoLCBvcHRpb25zLCBjb25zdHJ1Y3RpbmcsIHBhcnRzLCBzY2hlbWEsIHZhbCwgcHJpb3JWYWwpO1xuXG4gICAgaWYgKHBhdGhUeXBlID09PSAnbmVzdGVkJyAmJiB2YWwgPT0gbnVsbCkge1xuICAgICAgY2xlYW5Nb2RpZmllZFN1YnBhdGhzKHRoaXMsIHBhdGgpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIC8vIElmIG92ZXJ3cml0aW5nIGEgc3ViZG9jdW1lbnQgcGF0aCwgbWFrZSBzdXJlIHRvIGNsZWFyIG91dFxuICAvLyBhbnkgZXJyb3JzIF9iZWZvcmVfIHNldHRpbmcsIHNvIG5ldyBlcnJvcnMgdGhhdCBoYXBwZW5cbiAgLy8gZ2V0IHBlcnNpc3RlZC4gUmU6ICM5MDgwXG4gIGlmIChzY2hlbWEuJGlzU2luZ2xlTmVzdGVkIHx8IHNjaGVtYS4kaXNNb25nb29zZUFycmF5KSB7XG4gICAgX21hcmtWYWxpZFN1YnBhdGhzKHRoaXMsIHBhdGgpO1xuICB9XG5cbiAgaWYgKHZhbCAhPSBudWxsICYmIG1lcmdlICYmIHNjaGVtYS4kaXNTaW5nbGVOZXN0ZWQpIHtcbiAgICBpZiAodmFsIGluc3RhbmNlb2YgRG9jdW1lbnQpIHtcbiAgICAgIHZhbCA9IHZhbC50b09iamVjdCh7IHZpcnR1YWxzOiBmYWxzZSwgdHJhbnNmb3JtOiBmYWxzZSB9KTtcbiAgICB9XG4gICAgY29uc3Qga2V5cyA9IE9iamVjdC5rZXlzKHZhbCk7XG4gICAgZm9yIChjb25zdCBrZXkgb2Yga2V5cykge1xuICAgICAgdGhpcy4kc2V0KHBhdGggKyAnLicgKyBrZXksIHZhbFtrZXldLCBjb25zdHJ1Y3RpbmcsIG9wdGlvbnMpO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgbGV0IHNob3VsZFNldCA9IHRydWU7XG4gIHRyeSB7XG4gICAgLy8gSWYgdGhlIHVzZXIgaXMgdHJ5aW5nIHRvIHNldCBhIHJlZiBwYXRoIHRvIGEgZG9jdW1lbnQgd2l0aFxuICAgIC8vIHRoZSBjb3JyZWN0IG1vZGVsIG5hbWUsIHRyZWF0IGl0IGFzIHBvcHVsYXRlZFxuICAgIGNvbnN0IHJlZk1hdGNoZXMgPSAoKCkgPT4ge1xuICAgICAgaWYgKHNjaGVtYS5vcHRpb25zID09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgICAgaWYgKCEodmFsIGluc3RhbmNlb2YgRG9jdW1lbnQpKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IG1vZGVsID0gdmFsLmNvbnN0cnVjdG9yO1xuXG4gICAgICAvLyBDaGVjayByZWZcbiAgICAgIGNvbnN0IHJlZiA9IHNjaGVtYS5vcHRpb25zLnJlZjtcbiAgICAgIGlmIChyZWYgIT0gbnVsbCAmJiAocmVmID09PSBtb2RlbC5tb2RlbE5hbWUgfHwgcmVmID09PSBtb2RlbC5iYXNlTW9kZWxOYW1lKSkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cblxuICAgICAgLy8gQ2hlY2sgcmVmUGF0aFxuICAgICAgY29uc3QgcmVmUGF0aCA9IHNjaGVtYS5vcHRpb25zLnJlZlBhdGg7XG4gICAgICBpZiAocmVmUGF0aCA9PSBudWxsKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IG1vZGVsTmFtZSA9IHZhbC5nZXQocmVmUGF0aCk7XG4gICAgICByZXR1cm4gbW9kZWxOYW1lID09PSBtb2RlbC5tb2RlbE5hbWUgfHwgbW9kZWxOYW1lID09PSBtb2RlbC5iYXNlTW9kZWxOYW1lO1xuICAgIH0pKCk7XG5cbiAgICBsZXQgZGlkUG9wdWxhdGUgPSBmYWxzZTtcbiAgICBpZiAocmVmTWF0Y2hlcyAmJiB2YWwgaW5zdGFuY2VvZiBEb2N1bWVudCAmJiAoIXZhbC4kX18ud2FzUG9wdWxhdGVkIHx8IHV0aWxzLmRlZXBFcXVhbCh2YWwuJF9fLndhc1BvcHVsYXRlZC52YWx1ZSwgdmFsLl9pZCkpKSB7XG4gICAgICBjb25zdCB1bnBvcHVsYXRlZFZhbHVlID0gKHNjaGVtYSAmJiBzY2hlbWEuJGlzU2luZ2xlTmVzdGVkKSA/IHNjaGVtYS5jYXN0KHZhbCwgdGhpcykgOiB2YWwuX2lkO1xuICAgICAgdGhpcy4kcG9wdWxhdGVkKHBhdGgsIHVucG9wdWxhdGVkVmFsdWUsIHsgW3BvcHVsYXRlTW9kZWxTeW1ib2xdOiB2YWwuY29uc3RydWN0b3IgfSk7XG4gICAgICB2YWwuJF9fLndhc1BvcHVsYXRlZCA9IHsgdmFsdWU6IHVucG9wdWxhdGVkVmFsdWUgfTtcbiAgICAgIGRpZFBvcHVsYXRlID0gdHJ1ZTtcbiAgICB9XG5cbiAgICBsZXQgcG9wT3B0cztcbiAgICBjb25zdCB0eXBlS2V5ID0gdGhpcy4kX19zY2hlbWEub3B0aW9ucy50eXBlS2V5O1xuICAgIGlmIChzY2hlbWEub3B0aW9ucyAmJlxuICAgICAgICBBcnJheS5pc0FycmF5KHNjaGVtYS5vcHRpb25zW3R5cGVLZXldKSAmJlxuICAgICAgICBzY2hlbWEub3B0aW9uc1t0eXBlS2V5XS5sZW5ndGggJiZcbiAgICAgICAgc2NoZW1hLm9wdGlvbnNbdHlwZUtleV1bMF0ucmVmICYmXG4gICAgICAgIF9pc01hbnVhbGx5UG9wdWxhdGVkQXJyYXkodmFsLCBzY2hlbWEub3B0aW9uc1t0eXBlS2V5XVswXS5yZWYpKSB7XG4gICAgICBwb3BPcHRzID0geyBbcG9wdWxhdGVNb2RlbFN5bWJvbF06IHZhbFswXS5jb25zdHJ1Y3RvciB9O1xuICAgICAgdGhpcy4kcG9wdWxhdGVkKHBhdGgsIHZhbC5tYXAoZnVuY3Rpb24odikgeyByZXR1cm4gdi5faWQ7IH0pLCBwb3BPcHRzKTtcblxuICAgICAgZm9yIChjb25zdCBkb2Mgb2YgdmFsKSB7XG4gICAgICAgIGRvYy4kX18ud2FzUG9wdWxhdGVkID0geyB2YWx1ZTogZG9jLl9pZCB9O1xuICAgICAgfVxuICAgICAgZGlkUG9wdWxhdGUgPSB0cnVlO1xuICAgIH1cblxuICAgIGlmICghcmVmTWF0Y2hlcyB8fCAhc2NoZW1hLiRpc1NpbmdsZU5lc3RlZCB8fCAhdmFsLiRfXykge1xuICAgICAgLy8gSWYgdGhpcyBwYXRoIGlzIHVuZGVybmVhdGggYSBzaW5nbGUgbmVzdGVkIHNjaGVtYSwgd2UnbGwgY2FsbCB0aGUgc2V0dGVyXG4gICAgICAvLyBsYXRlciBpbiBgJF9fc2V0KClgIGJlY2F1c2Ugd2UgZG9uJ3QgdGFrZSBgX2RvY2Agd2hlbiB3ZSBpdGVyYXRlIHRocm91Z2hcbiAgICAgIC8vIGEgc2luZ2xlIG5lc3RlZCBkb2MuIFRoYXQncyB0byBtYWtlIHN1cmUgd2UgZ2V0IHRoZSBjb3JyZWN0IGNvbnRleHQuXG4gICAgICAvLyBPdGhlcndpc2Ugd2Ugd291bGQgZG91YmxlLWNhbGwgdGhlIHNldHRlciwgc2VlIGdoLTcxOTYuXG4gICAgICBsZXQgc2V0dGVyQ29udGV4dCA9IHRoaXM7XG4gICAgICBpZiAodGhpcy4kX19zY2hlbWEuc2luZ2xlTmVzdGVkUGF0aHNbcGF0aF0gIT0gbnVsbCAmJiBwYXJ0cy5sZW5ndGggPiAxKSB7XG4gICAgICAgIHNldHRlckNvbnRleHQgPSBnZXREZWVwZXN0U3ViZG9jdW1lbnRGb3JQYXRoKHRoaXMsIHBhcnRzLCB0aGlzLnNjaGVtYSk7XG4gICAgICB9XG4gICAgICBpZiAob3B0aW9ucyAhPSBudWxsICYmIG9wdGlvbnMub3ZlcndyaXRlSW1tdXRhYmxlKSB7XG4gICAgICAgIHZhbCA9IHNjaGVtYS5hcHBseVNldHRlcnModmFsLCBzZXR0ZXJDb250ZXh0LCBmYWxzZSwgcHJpb3JWYWwsIHsgb3ZlcndyaXRlSW1tdXRhYmxlOiB0cnVlIH0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFsID0gc2NoZW1hLmFwcGx5U2V0dGVycyh2YWwsIHNldHRlckNvbnRleHQsIGZhbHNlLCBwcmlvclZhbCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKEFycmF5LmlzQXJyYXkodmFsKSAmJlxuICAgICAgICAhQXJyYXkuaXNBcnJheShzY2hlbWEpICYmXG4gICAgICAgIHNjaGVtYS4kaXNNb25nb29zZURvY3VtZW50QXJyYXkgJiZcbiAgICAgICAgdmFsLmxlbmd0aCAhPT0gMCAmJlxuICAgICAgICB2YWxbMF0gIT0gbnVsbCAmJlxuICAgICAgICB2YWxbMF0uJF9fICE9IG51bGwgJiZcbiAgICAgICAgdmFsWzBdLiRfXy5wb3B1bGF0ZWQgIT0gbnVsbCkge1xuICAgICAgY29uc3QgcG9wdWxhdGVkUGF0aHMgPSBPYmplY3Qua2V5cyh2YWxbMF0uJF9fLnBvcHVsYXRlZCk7XG4gICAgICBmb3IgKGNvbnN0IHBvcHVsYXRlZFBhdGggb2YgcG9wdWxhdGVkUGF0aHMpIHtcbiAgICAgICAgdGhpcy4kcG9wdWxhdGVkKHBhdGggKyAnLicgKyBwb3B1bGF0ZWRQYXRoLFxuICAgICAgICAgIHZhbC5tYXAodiA9PiB2LiRwb3B1bGF0ZWQocG9wdWxhdGVkUGF0aCkpLFxuICAgICAgICAgIHZhbFswXS4kX18ucG9wdWxhdGVkW3BvcHVsYXRlZFBhdGhdLm9wdGlvbnMpO1xuICAgICAgfVxuICAgICAgZGlkUG9wdWxhdGUgPSB0cnVlO1xuICAgIH1cblxuICAgIGlmICghZGlkUG9wdWxhdGUgJiYgdGhpcy4kX18ucG9wdWxhdGVkKSB7XG4gICAgICAvLyBJZiB0aGlzIGFycmF5IHBhcnRpYWxseSBjb250YWlucyBwb3B1bGF0ZWQgZG9jdW1lbnRzLCBjb252ZXJ0IHRoZW1cbiAgICAgIC8vIGFsbCB0byBPYmplY3RJZHMgcmU6ICM4NDQzXG4gICAgICBpZiAoQXJyYXkuaXNBcnJheSh2YWwpICYmIHRoaXMuJF9fLnBvcHVsYXRlZFtwYXRoXSkge1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHZhbC5sZW5ndGg7ICsraSkge1xuICAgICAgICAgIGlmICh2YWxbaV0gaW5zdGFuY2VvZiBEb2N1bWVudCkge1xuICAgICAgICAgICAgdmFsLnNldChpLCB2YWxbaV0uX2lkLCB0cnVlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGRlbGV0ZSB0aGlzLiRfXy5wb3B1bGF0ZWRbcGF0aF07XG4gICAgfVxuXG4gICAgaWYgKHZhbCAhPSBudWxsICYmIHNjaGVtYS4kaXNTaW5nbGVOZXN0ZWQpIHtcbiAgICAgIF9jaGVja0ltbXV0YWJsZVN1YnBhdGhzKHZhbCwgc2NoZW1hLCBwcmlvclZhbCk7XG4gICAgfVxuXG4gICAgdGhpcy4kbWFya1ZhbGlkKHBhdGgpO1xuICB9IGNhdGNoIChlKSB7XG4gICAgaWYgKGUgaW5zdGFuY2VvZiBNb25nb29zZUVycm9yLlN0cmljdE1vZGVFcnJvciAmJiBlLmlzSW1tdXRhYmxlRXJyb3IpIHtcbiAgICAgIHRoaXMuaW52YWxpZGF0ZShwYXRoLCBlKTtcbiAgICB9IGVsc2UgaWYgKGUgaW5zdGFuY2VvZiBNb25nb29zZUVycm9yLkNhc3RFcnJvcikge1xuICAgICAgdGhpcy5pbnZhbGlkYXRlKGUucGF0aCwgZSk7XG4gICAgICBpZiAoZS4kb3JpZ2luYWxFcnJvclBhdGgpIHtcbiAgICAgICAgdGhpcy5pbnZhbGlkYXRlKHBhdGgsXG4gICAgICAgICAgbmV3IE1vbmdvb3NlRXJyb3IuQ2FzdEVycm9yKHNjaGVtYS5pbnN0YW5jZSwgdmFsLCBwYXRoLCBlLiRvcmlnaW5hbEVycm9yUGF0aCkpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmludmFsaWRhdGUocGF0aCxcbiAgICAgICAgbmV3IE1vbmdvb3NlRXJyb3IuQ2FzdEVycm9yKHNjaGVtYS5pbnN0YW5jZSwgdmFsLCBwYXRoLCBlKSk7XG4gICAgfVxuICAgIHNob3VsZFNldCA9IGZhbHNlO1xuICB9XG5cbiAgaWYgKHNob3VsZFNldCkge1xuICAgIGxldCBzYXZlZFN0YXRlID0gbnVsbDtcbiAgICBsZXQgc2F2ZWRTdGF0ZVBhdGggPSBudWxsO1xuICAgIGlmICghY29uc3RydWN0aW5nKSB7XG4gICAgICBjb25zdCBkb2MgPSB0aGlzLiRpc1N1YmRvY3VtZW50ID8gdGhpcy5vd25lckRvY3VtZW50KCkgOiB0aGlzO1xuICAgICAgc2F2ZWRTdGF0ZSA9IGRvYy4kX18uc2F2ZWRTdGF0ZTtcbiAgICAgIHNhdmVkU3RhdGVQYXRoID0gdGhpcy4kaXNTdWJkb2N1bWVudCA/IHRoaXMuJF9fLmZ1bGxQYXRoICsgJy4nICsgcGF0aCA6IHBhdGg7XG4gICAgICBkb2MuJF9fc2F2ZUluaXRpYWxTdGF0ZShzYXZlZFN0YXRlUGF0aCk7XG4gICAgfVxuXG4gICAgdGhpcy4kX19zZXQocGF0aFRvTWFyaywgcGF0aCwgb3B0aW9ucywgY29uc3RydWN0aW5nLCBwYXJ0cywgc2NoZW1hLCB2YWwsIHByaW9yVmFsKTtcblxuICAgIGNvbnN0IGlzSW5UcmFuc2FjdGlvbiA9ICEhdGhpcy4kX18uc2Vzc2lvbj8udHJhbnNhY3Rpb247XG4gICAgY29uc3QgaXNNb2RpZmllZFdpdGhpblRyYW5zYWN0aW9uID0gdGhpcy4kX18uc2Vzc2lvbiAmJlxuICAgICAgdGhpcy4kX18uc2Vzc2lvbltzZXNzaW9uTmV3RG9jdW1lbnRzXSAmJlxuICAgICAgdGhpcy4kX18uc2Vzc2lvbltzZXNzaW9uTmV3RG9jdW1lbnRzXS5oYXModGhpcykgJiZcbiAgICAgIHRoaXMuJF9fLnNlc3Npb25bc2Vzc2lvbk5ld0RvY3VtZW50c10uZ2V0KHRoaXMpLm1vZGlmaWVkUGF0aHMgJiZcbiAgICAgICF0aGlzLiRfXy5zZXNzaW9uW3Nlc3Npb25OZXdEb2N1bWVudHNdLmdldCh0aGlzKS5tb2RpZmllZFBhdGhzLmhhcyhzYXZlZFN0YXRlUGF0aCk7XG4gICAgaWYgKHNhdmVkU3RhdGUgIT0gbnVsbCAmJlxuICAgICAgICBzYXZlZFN0YXRlLmhhc093blByb3BlcnR5KHNhdmVkU3RhdGVQYXRoKSAmJlxuICAgICAgICAoIWlzSW5UcmFuc2FjdGlvbiB8fCBpc01vZGlmaWVkV2l0aGluVHJhbnNhY3Rpb24pICYmXG4gICAgICAgIHV0aWxzLmRlZXBFcXVhbCh2YWwsIHNhdmVkU3RhdGVbc2F2ZWRTdGF0ZVBhdGhdKSkge1xuICAgICAgdGhpcy51bm1hcmtNb2RpZmllZChwYXRoKTtcbiAgICB9XG4gIH1cblxuICBpZiAoc2NoZW1hLiRpc1NpbmdsZU5lc3RlZCAmJiAodGhpcy5pc0RpcmVjdE1vZGlmaWVkKHBhdGgpIHx8IHZhbCA9PSBudWxsKSkge1xuICAgIGNsZWFuTW9kaWZpZWRTdWJwYXRocyh0aGlzLCBwYXRoKTtcbiAgfVxuXG4gIHJldHVybiB0aGlzO1xufTtcblxuLyohXG4gKiBpZ25vcmVcbiAqL1xuXG5mdW5jdGlvbiBfaXNNYW51YWxseVBvcHVsYXRlZEFycmF5KHZhbCwgcmVmKSB7XG4gIGlmICghQXJyYXkuaXNBcnJheSh2YWwpKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGlmICh2YWwubGVuZ3RoID09PSAwKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgZm9yIChjb25zdCBlbCBvZiB2YWwpIHtcbiAgICBpZiAoIShlbCBpbnN0YW5jZW9mIERvY3VtZW50KSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBjb25zdCBtb2RlbE5hbWUgPSBlbC5jb25zdHJ1Y3Rvci5tb2RlbE5hbWU7XG4gICAgaWYgKG1vZGVsTmFtZSA9PSBudWxsKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGlmIChlbC5jb25zdHJ1Y3Rvci5tb2RlbE5hbWUgIT0gcmVmICYmIGVsLmNvbnN0cnVjdG9yLmJhc2VNb2RlbE5hbWUgIT0gcmVmKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHRydWU7XG59XG5cbi8qKlxuICogU2V0cyB0aGUgdmFsdWUgb2YgYSBwYXRoLCBvciBtYW55IHBhdGhzLlxuICogQWxpYXMgZm9yIFtgLiRzZXRgXShodHRwczovL21vbmdvb3NlanMuY29tL2RvY3MvYXBpL2RvY3VtZW50Lmh0bWwjRG9jdW1lbnQucHJvdG90eXBlLiRzZXQoKSkuXG4gKlxuICogIyMjIyBFeGFtcGxlOlxuICpcbiAqICAgICAvLyBwYXRoLCB2YWx1ZVxuICogICAgIGRvYy5zZXQocGF0aCwgdmFsdWUpXG4gKlxuICogICAgIC8vIG9iamVjdFxuICogICAgIGRvYy5zZXQoe1xuICogICAgICAgICBwYXRoICA6IHZhbHVlXG4gKiAgICAgICAsIHBhdGgyIDoge1xuICogICAgICAgICAgICBwYXRoICA6IHZhbHVlXG4gKiAgICAgICAgIH1cbiAqICAgICB9KVxuICpcbiAqICAgICAvLyBvbi10aGUtZmx5IGNhc3QgdG8gbnVtYmVyXG4gKiAgICAgZG9jLnNldChwYXRoLCB2YWx1ZSwgTnVtYmVyKVxuICpcbiAqICAgICAvLyBvbi10aGUtZmx5IGNhc3QgdG8gc3RyaW5nXG4gKiAgICAgZG9jLnNldChwYXRoLCB2YWx1ZSwgU3RyaW5nKVxuICpcbiAqICAgICAvLyBjaGFuZ2luZyBzdHJpY3QgbW9kZSBiZWhhdmlvclxuICogICAgIGRvYy5zZXQocGF0aCwgdmFsdWUsIHsgc3RyaWN0OiBmYWxzZSB9KTtcbiAqXG4gKiBAcGFyYW0ge1N0cmluZ3xPYmplY3R9IHBhdGggcGF0aCBvciBvYmplY3Qgb2Yga2V5L3ZhbHMgdG8gc2V0XG4gKiBAcGFyYW0ge0FueX0gdmFsIHRoZSB2YWx1ZSB0byBzZXRcbiAqIEBwYXJhbSB7U2NoZW1hfFN0cmluZ3xOdW1iZXJ8QnVmZmVyfCp9IFt0eXBlXSBvcHRpb25hbGx5IHNwZWNpZnkgYSB0eXBlIGZvciBcIm9uLXRoZS1mbHlcIiBhdHRyaWJ1dGVzXG4gKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdIG9wdGlvbmFsbHkgc3BlY2lmeSBvcHRpb25zIHRoYXQgbW9kaWZ5IHRoZSBiZWhhdmlvciBvZiB0aGUgc2V0XG4gKiBAcmV0dXJuIHtEb2N1bWVudH0gdGhpc1xuICogQGFwaSBwdWJsaWNcbiAqIEBtZXRob2Qgc2V0XG4gKiBAbWVtYmVyT2YgRG9jdW1lbnRcbiAqIEBpbnN0YW5jZVxuICovXG5cbkRvY3VtZW50LnByb3RvdHlwZS5zZXQgPSBEb2N1bWVudC5wcm90b3R5cGUuJHNldDtcblxuLyoqXG4gKiBEZXRlcm1pbmUgaWYgd2Ugc2hvdWxkIG1hcmsgdGhpcyBjaGFuZ2UgYXMgbW9kaWZpZWQuXG4gKlxuICogQHBhcmFtIHtuZXZlcn0gcGF0aFRvTWFyayBVTlVTRURcbiAqIEBwYXJhbSB7U3RyaW5nfFN5bWJvbH0gcGF0aFxuICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcbiAqIEBwYXJhbSB7QW55fSBjb25zdHJ1Y3RpbmdcbiAqIEBwYXJhbSB7bmV2ZXJ9IHBhcnRzIFVOVVNFRFxuICogQHBhcmFtIHtTY2hlbWF9IHNjaGVtYVxuICogQHBhcmFtIHtBbnl9IHZhbFxuICogQHBhcmFtIHtBbnl9IHByaW9yVmFsXG4gKiBAcmV0dXJuIHtCb29sZWFufVxuICogQGFwaSBwcml2YXRlXG4gKiBAbWV0aG9kICRfX3Nob3VsZE1vZGlmeVxuICogQG1lbWJlck9mIERvY3VtZW50XG4gKiBAaW5zdGFuY2VcbiAqL1xuXG5Eb2N1bWVudC5wcm90b3R5cGUuJF9fc2hvdWxkTW9kaWZ5ID0gZnVuY3Rpb24ocGF0aFRvTWFyaywgcGF0aCwgb3B0aW9ucywgY29uc3RydWN0aW5nLCBwYXJ0cywgc2NoZW1hLCB2YWwsIHByaW9yVmFsKSB7XG4gIGlmIChvcHRpb25zICYmIG9wdGlvbnMuX3NraXBNYXJrTW9kaWZpZWQpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgaWYgKHRoaXMuJGlzTmV3KSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgLy8gSXMgcGF0aCBhbHJlYWR5IG1vZGlmaWVkPyBJZiBzbywgYWx3YXlzIG1vZGlmeS4gV2UgbWF5IHVubWFyayBtb2RpZmllZCBsYXRlci5cbiAgaWYgKHBhdGggaW4gdGhpcy4kX18uYWN0aXZlUGF0aHMuZ2V0U3RhdGVQYXRocygnbW9kaWZ5JykpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIGlmICh2YWwgPT09IHZvaWQgMCAmJiAhdGhpcy4kX19pc1NlbGVjdGVkKHBhdGgpKSB7XG4gICAgLy8gd2hlbiBhIHBhdGggaXMgbm90IHNlbGVjdGVkIGluIGEgcXVlcnksIGl0cyBpbml0aWFsXG4gICAgLy8gdmFsdWUgd2lsbCBiZSB1bmRlZmluZWQuXG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICBpZiAodmFsID09PSB2b2lkIDAgJiYgcGF0aCBpbiB0aGlzLiRfXy5hY3RpdmVQYXRocy5nZXRTdGF0ZVBhdGhzKCdkZWZhdWx0JykpIHtcbiAgICAvLyB3ZSdyZSBqdXN0IHVuc2V0dGluZyB0aGUgZGVmYXVsdCB2YWx1ZSB3aGljaCB3YXMgbmV2ZXIgc2F2ZWRcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICAvLyBnaC0zOTkyOiBpZiBzZXR0aW5nIGEgcG9wdWxhdGVkIGZpZWxkIHRvIGEgZG9jLCBkb24ndCBtYXJrIG1vZGlmaWVkXG4gIC8vIGlmIHRoZXkgaGF2ZSB0aGUgc2FtZSBfaWRcbiAgaWYgKHRoaXMuJHBvcHVsYXRlZChwYXRoKSAmJlxuICAgICAgdmFsIGluc3RhbmNlb2YgRG9jdW1lbnQgJiZcbiAgICAgIGRlZXBFcXVhbCh2YWwuX2lkLCBwcmlvclZhbCkpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBpZiAoIWRlZXBFcXVhbCh2YWwsIHByaW9yVmFsICE9PSB1bmRlZmluZWQgPyBwcmlvclZhbCA6IHV0aWxzLmdldFZhbHVlKHBhdGgsIHRoaXMpKSkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgaWYgKCFjb25zdHJ1Y3RpbmcgJiZcbiAgICAgIHZhbCAhPT0gbnVsbCAmJlxuICAgICAgdmFsICE9PSB1bmRlZmluZWQgJiZcbiAgICAgIHBhdGggaW4gdGhpcy4kX18uYWN0aXZlUGF0aHMuZ2V0U3RhdGVQYXRocygnZGVmYXVsdCcpICYmXG4gICAgICBkZWVwRXF1YWwodmFsLCBzY2hlbWEuZ2V0RGVmYXVsdCh0aGlzLCBjb25zdHJ1Y3RpbmcpKSkge1xuICAgIC8vIGEgcGF0aCB3aXRoIGEgZGVmYXVsdCB3YXMgJHVuc2V0IG9uIHRoZSBzZXJ2ZXJcbiAgICAvLyBhbmQgdGhlIHVzZXIgaXMgc2V0dGluZyBpdCB0byB0aGUgc2FtZSB2YWx1ZSBhZ2FpblxuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIHJldHVybiBmYWxzZTtcbn07XG5cbi8qKlxuICogSGFuZGxlcyB0aGUgYWN0dWFsIHNldHRpbmcgb2YgdGhlIHZhbHVlIGFuZCBtYXJraW5nIHRoZSBwYXRoIG1vZGlmaWVkIGlmIGFwcHJvcHJpYXRlLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBwYXRoVG9NYXJrXG4gKiBAcGFyYW0ge1N0cmluZ3xTeW1ib2x9IHBhdGhcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zXG4gKiBAcGFyYW0ge0FueX0gY29uc3RydWN0aW5nXG4gKiBAcGFyYW0ge0FycmF5fSBwYXJ0c1xuICogQHBhcmFtIHtTY2hlbWF9IHNjaGVtYVxuICogQHBhcmFtIHtBbnl9IHZhbFxuICogQHBhcmFtIHtBbnl9IHByaW9yVmFsXG4gKiBAYXBpIHByaXZhdGVcbiAqIEBtZXRob2QgJF9fc2V0XG4gKiBAbWVtYmVyT2YgRG9jdW1lbnRcbiAqIEBpbnN0YW5jZVxuICovXG5cbkRvY3VtZW50LnByb3RvdHlwZS4kX19zZXQgPSBmdW5jdGlvbihwYXRoVG9NYXJrLCBwYXRoLCBvcHRpb25zLCBjb25zdHJ1Y3RpbmcsIHBhcnRzLCBzY2hlbWEsIHZhbCwgcHJpb3JWYWwpIHtcbiAgRW1iZWRkZWQgPSBFbWJlZGRlZCB8fCByZXF1aXJlKCcuL3R5cGVzL2FycmF5U3ViZG9jdW1lbnQnKTtcblxuICBjb25zdCBzaG91bGRNb2RpZnkgPSB0aGlzLiRfX3Nob3VsZE1vZGlmeShwYXRoVG9NYXJrLCBwYXRoLCBvcHRpb25zLCBjb25zdHJ1Y3RpbmcsIHBhcnRzLFxuICAgIHNjaGVtYSwgdmFsLCBwcmlvclZhbCk7XG5cbiAgaWYgKHNob3VsZE1vZGlmeSkge1xuICAgIGlmICh0aGlzLiRfXy5wcmltaXRpdmVBdG9taWNzICYmIHRoaXMuJF9fLnByaW1pdGl2ZUF0b21pY3NbcGF0aF0pIHtcbiAgICAgIGRlbGV0ZSB0aGlzLiRfXy5wcmltaXRpdmVBdG9taWNzW3BhdGhdO1xuICAgICAgaWYgKE9iamVjdC5rZXlzKHRoaXMuJF9fLnByaW1pdGl2ZUF0b21pY3MpLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICBkZWxldGUgdGhpcy4kX18ucHJpbWl0aXZlQXRvbWljcztcbiAgICAgIH1cbiAgICB9XG4gICAgdGhpcy5tYXJrTW9kaWZpZWQocGF0aFRvTWFyayk7XG5cbiAgICAvLyBoYW5kbGUgZGlyZWN0bHkgc2V0dGluZyBhcnJheXMgKGdoLTExMjYpXG4gICAgTW9uZ29vc2VBcnJheSB8fCAoTW9uZ29vc2VBcnJheSA9IHJlcXVpcmUoJy4vdHlwZXMvYXJyYXknKSk7XG4gICAgaWYgKHZhbCAmJiB1dGlscy5pc01vbmdvb3NlQXJyYXkodmFsKSkge1xuICAgICAgdmFsLl9yZWdpc3RlckF0b21pYygnJHNldCcsIHZhbCk7XG5cbiAgICAgIC8vIFVwZGF0ZSBlbWJlZGRlZCBkb2N1bWVudCBwYXJlbnQgcmVmZXJlbmNlcyAoZ2gtNTE4OSlcbiAgICAgIGlmICh1dGlscy5pc01vbmdvb3NlRG9jdW1lbnRBcnJheSh2YWwpKSB7XG4gICAgICAgIHZhbC5mb3JFYWNoKGZ1bmN0aW9uKGl0ZW0pIHtcbiAgICAgICAgICBpdGVtICYmIGl0ZW0uX19wYXJlbnRBcnJheSAmJiAoaXRlbS5fX3BhcmVudEFycmF5ID0gdmFsKTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuICB9IGVsc2UgaWYgKEFycmF5LmlzQXJyYXkodmFsKSAmJiBBcnJheS5pc0FycmF5KHByaW9yVmFsKSAmJiB1dGlscy5pc01vbmdvb3NlQXJyYXkodmFsKSAmJiB1dGlscy5pc01vbmdvb3NlQXJyYXkocHJpb3JWYWwpKSB7XG4gICAgdmFsW2FycmF5QXRvbWljc1N5bWJvbF0gPSBwcmlvclZhbFthcnJheUF0b21pY3NTeW1ib2xdO1xuICAgIHZhbFthcnJheUF0b21pY3NCYWNrdXBTeW1ib2xdID0gcHJpb3JWYWxbYXJyYXlBdG9taWNzQmFja3VwU3ltYm9sXTtcbiAgICBpZiAodXRpbHMuaXNNb25nb29zZURvY3VtZW50QXJyYXkodmFsKSkge1xuICAgICAgdmFsLmZvckVhY2goZG9jID0+IHtcbiAgICAgICAgaWYgKGRvYyAhPSBudWxsKSB7XG4gICAgICAgICAgZG9jLiRpc05ldyA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG4gIH1cblxuICBsZXQgb2JqID0gdGhpcy5fZG9jO1xuICBsZXQgaSA9IDA7XG4gIGNvbnN0IGwgPSBwYXJ0cy5sZW5ndGg7XG4gIGxldCBjdXIgPSAnJztcblxuICBmb3IgKDsgaSA8IGw7IGkrKykge1xuICAgIGNvbnN0IG5leHQgPSBpICsgMTtcbiAgICBjb25zdCBsYXN0ID0gbmV4dCA9PT0gbDtcbiAgICBjdXIgKz0gKGN1ciA/ICcuJyArIHBhcnRzW2ldIDogcGFydHNbaV0pO1xuICAgIGlmIChzcGVjaWFsUHJvcGVydGllcy5oYXMocGFydHNbaV0pKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKGxhc3QpIHtcbiAgICAgIGlmIChvYmogaW5zdGFuY2VvZiBNYXApIHtcbiAgICAgICAgb2JqLnNldChwYXJ0c1tpXSwgdmFsKTtcbiAgICAgIH0gZWxzZSBpZiAob2JqLiRpc1NpbmdsZU5lc3RlZCkge1xuICAgICAgICBpZiAoIShwYXJ0c1tpXSBpbiBvYmopKSB7XG4gICAgICAgICAgb2JqW3BhcnRzW2ldXSA9IHZhbDtcbiAgICAgICAgICBvYmouX2RvY1twYXJ0c1tpXV0gPSB2YWw7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgb2JqLl9kb2NbcGFydHNbaV1dID0gdmFsO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBvYmpbcGFydHNbaV1dID0gdmFsO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCBpc01hcCA9IG9iaiBpbnN0YW5jZW9mIE1hcDtcbiAgICAgIGxldCB2YWx1ZSA9IGlzTWFwID8gb2JqLmdldChwYXJ0c1tpXSkgOiBvYmpbcGFydHNbaV1dO1xuICAgICAgaWYgKHV0aWxzLmlzUE9KTyh2YWx1ZSkpIHtcbiAgICAgICAgb2JqID0gdmFsdWU7XG4gICAgICB9IGVsc2UgaWYgKHZhbHVlICYmIHZhbHVlIGluc3RhbmNlb2YgRW1iZWRkZWQpIHtcbiAgICAgICAgb2JqID0gdmFsdWU7XG4gICAgICB9IGVsc2UgaWYgKHZhbHVlICYmICFBcnJheS5pc0FycmF5KHZhbHVlKSAmJiB2YWx1ZS4kaXNTaW5nbGVOZXN0ZWQpIHtcbiAgICAgICAgb2JqID0gdmFsdWU7XG4gICAgICB9IGVsc2UgaWYgKHZhbHVlICYmIEFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgICAgIG9iaiA9IHZhbHVlO1xuICAgICAgfSBlbHNlIGlmICh2YWx1ZSA9PSBudWxsKSB7XG4gICAgICAgIHZhbHVlID0ge307XG4gICAgICAgIGlmIChpc01hcCkge1xuICAgICAgICAgIG9iai5zZXQocGFydHNbaV0sIHZhbHVlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBvYmpbcGFydHNbaV1dID0gdmFsdWU7XG4gICAgICAgIH1cbiAgICAgICAgb2JqID0gdmFsdWU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBvYmogPSB2YWx1ZTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn07XG5cbi8qKlxuICogR2V0cyBhIHJhdyB2YWx1ZSBmcm9tIGEgcGF0aCAobm8gZ2V0dGVycylcbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gcGF0aFxuICogQHJldHVybiB7QW55fSBSZXR1cm5zIHRoZSB2YWx1ZSBmcm9tIHRoZSBnaXZlbiBgcGF0aGAuXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5Eb2N1bWVudC5wcm90b3R5cGUuJF9fZ2V0VmFsdWUgPSBmdW5jdGlvbihwYXRoKSB7XG4gIHJldHVybiB1dGlscy5nZXRWYWx1ZShwYXRoLCB0aGlzLl9kb2MpO1xufTtcblxuLyoqXG4gKiBJbmNyZW1lbnRzIHRoZSBudW1lcmljIHZhbHVlIGF0IGBwYXRoYCBieSB0aGUgZ2l2ZW4gYHZhbGAuXG4gKiBXaGVuIHlvdSBjYWxsIGBzYXZlKClgIG9uIHRoaXMgZG9jdW1lbnQsIE1vbmdvb3NlIHdpbGwgc2VuZCBhXG4gKiBbYCRpbmNgXShodHRwczovL3d3dy5tb25nb2RiLmNvbS9kb2NzL21hbnVhbC9yZWZlcmVuY2Uvb3BlcmF0b3IvdXBkYXRlL2luYy8pXG4gKiBhcyBvcHBvc2VkIHRvIGEgYCRzZXRgLlxuICpcbiAqICMjIyMgRXhhbXBsZTpcbiAqXG4gKiAgICAgY29uc3Qgc2NoZW1hID0gbmV3IFNjaGVtYSh7IGNvdW50ZXI6IE51bWJlciB9KTtcbiAqICAgICBjb25zdCBUZXN0ID0gZGIubW9kZWwoJ1Rlc3QnLCBzY2hlbWEpO1xuICpcbiAqICAgICBjb25zdCBkb2MgPSBhd2FpdCBUZXN0LmNyZWF0ZSh7IGNvdW50ZXI6IDAgfSk7XG4gKiAgICAgZG9jLiRpbmMoJ2NvdW50ZXInLCAyKTtcbiAqICAgICBhd2FpdCBkb2Muc2F2ZSgpOyAvLyBTZW5kcyBhIGB7ICRpbmM6IHsgY291bnRlcjogMiB9IH1gIHRvIE1vbmdvREJcbiAqICAgICBkb2MuY291bnRlcjsgLy8gMlxuICpcbiAqICAgICBkb2MuY291bnRlciArPSAyO1xuICogICAgIGF3YWl0IGRvYy5zYXZlKCk7IC8vIFNlbmRzIGEgYHsgJHNldDogeyBjb3VudGVyOiAyIH0gfWAgdG8gTW9uZ29EQlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfEFycmF5fSBwYXRoIHBhdGggb3IgcGF0aHMgdG8gdXBkYXRlXG4gKiBAcGFyYW0ge051bWJlcn0gdmFsIGluY3JlbWVudCBgcGF0aGAgYnkgdGhpcyB2YWx1ZVxuICogQHJldHVybiB7RG9jdW1lbnR9IHRoaXNcbiAqL1xuXG5Eb2N1bWVudC5wcm90b3R5cGUuJGluYyA9IGZ1bmN0aW9uICRpbmMocGF0aCwgdmFsKSB7XG4gIGlmICh2YWwgPT0gbnVsbCkge1xuICAgIHZhbCA9IDE7XG4gIH1cblxuICBpZiAoQXJyYXkuaXNBcnJheShwYXRoKSkge1xuICAgIHBhdGguZm9yRWFjaCgocCkgPT4gdGhpcy4kaW5jKHAsIHZhbCkpO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgY29uc3Qgc2NoZW1hVHlwZSA9IHRoaXMuJF9fcGF0aChwYXRoKTtcbiAgaWYgKHNjaGVtYVR5cGUgPT0gbnVsbCkge1xuICAgIGlmICh0aGlzLiRfXy5zdHJpY3RNb2RlID09PSAndGhyb3cnKSB7XG4gICAgICB0aHJvdyBuZXcgU3RyaWN0TW9kZUVycm9yKHBhdGgpO1xuICAgIH0gZWxzZSBpZiAodGhpcy4kX18uc3RyaWN0TW9kZSA9PT0gdHJ1ZSkge1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICB9IGVsc2UgaWYgKHNjaGVtYVR5cGUuaW5zdGFuY2UgIT09ICdOdW1iZXInKSB7XG4gICAgdGhpcy5pbnZhbGlkYXRlKHBhdGgsIG5ldyBNb25nb29zZUVycm9yLkNhc3RFcnJvcihzY2hlbWFUeXBlLmluc3RhbmNlLCB2YWwsIHBhdGgpKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIGNvbnN0IGN1cnJlbnRWYWx1ZSA9IHRoaXMuJF9fZ2V0VmFsdWUocGF0aCkgfHwgMDtcbiAgbGV0IHNob3VsZFNldCA9IGZhbHNlO1xuICBsZXQgdmFsVG9TZXQgPSBudWxsO1xuICBsZXQgdmFsVG9JbmMgPSB2YWw7XG5cbiAgdHJ5IHtcbiAgICB2YWwgPSBzY2hlbWFUeXBlLmNhc3QodmFsKTtcbiAgICB2YWxUb1NldCA9IHNjaGVtYVR5cGUuYXBwbHlTZXR0ZXJzKGN1cnJlbnRWYWx1ZSArIHZhbCwgdGhpcyk7XG4gICAgdmFsVG9JbmMgPSB2YWxUb1NldCAtIGN1cnJlbnRWYWx1ZTtcbiAgICBzaG91bGRTZXQgPSB0cnVlO1xuICB9IGNhdGNoIChlcnIpIHtcbiAgICB0aGlzLmludmFsaWRhdGUocGF0aCwgbmV3IE1vbmdvb3NlRXJyb3IuQ2FzdEVycm9yKCdudW1iZXInLCB2YWwsIHBhdGgsIGVycikpO1xuICB9XG5cbiAgaWYgKHNob3VsZFNldCkge1xuICAgIHRoaXMuJF9fLnByaW1pdGl2ZUF0b21pY3MgPSB0aGlzLiRfXy5wcmltaXRpdmVBdG9taWNzIHx8IHt9O1xuICAgIGlmICh0aGlzLiRfXy5wcmltaXRpdmVBdG9taWNzW3BhdGhdID09IG51bGwpIHtcbiAgICAgIHRoaXMuJF9fLnByaW1pdGl2ZUF0b21pY3NbcGF0aF0gPSB7ICRpbmM6IHZhbFRvSW5jIH07XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuJF9fLnByaW1pdGl2ZUF0b21pY3NbcGF0aF0uJGluYyArPSB2YWxUb0luYztcbiAgICB9XG4gICAgdGhpcy5tYXJrTW9kaWZpZWQocGF0aCk7XG4gICAgdGhpcy4kX19zZXRWYWx1ZShwYXRoLCB2YWxUb1NldCk7XG4gIH1cblxuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogU2V0cyBhIHJhdyB2YWx1ZSBmb3IgYSBwYXRoIChubyBjYXN0aW5nLCBzZXR0ZXJzLCB0cmFuc2Zvcm1hdGlvbnMpXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IHBhdGhcbiAqIEBwYXJhbSB7T2JqZWN0fSB2YWx1ZVxuICogQHJldHVybiB7RG9jdW1lbnR9IHRoaXNcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbkRvY3VtZW50LnByb3RvdHlwZS4kX19zZXRWYWx1ZSA9IGZ1bmN0aW9uKHBhdGgsIHZhbCkge1xuICB1dGlscy5zZXRWYWx1ZShwYXRoLCB2YWwsIHRoaXMuX2RvYyk7XG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBSZXR1cm5zIHRoZSB2YWx1ZSBvZiBhIHBhdGguXG4gKlxuICogIyMjIyBFeGFtcGxlOlxuICpcbiAqICAgICAvLyBwYXRoXG4gKiAgICAgZG9jLmdldCgnYWdlJykgLy8gNDdcbiAqXG4gKiAgICAgLy8gZHluYW1pYyBjYXN0aW5nIHRvIGEgc3RyaW5nXG4gKiAgICAgZG9jLmdldCgnYWdlJywgU3RyaW5nKSAvLyBcIjQ3XCJcbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gcGF0aFxuICogQHBhcmFtIHtTY2hlbWF8U3RyaW5nfE51bWJlcnxCdWZmZXJ8Kn0gW3R5cGVdIG9wdGlvbmFsbHkgc3BlY2lmeSBhIHR5cGUgZm9yIG9uLXRoZS1mbHkgYXR0cmlidXRlc1xuICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXVxuICogQHBhcmFtIHtCb29sZWFufSBbb3B0aW9ucy52aXJ0dWFscz1mYWxzZV0gQXBwbHkgdmlydHVhbHMgYmVmb3JlIGdldHRpbmcgdGhpcyBwYXRoXG4gKiBAcGFyYW0ge0Jvb2xlYW59IFtvcHRpb25zLmdldHRlcnM9dHJ1ZV0gSWYgZmFsc2UsIHNraXAgYXBwbHlpbmcgZ2V0dGVycyBhbmQganVzdCBnZXQgdGhlIHJhdyB2YWx1ZVxuICogQHJldHVybiB7QW55fVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5Eb2N1bWVudC5wcm90b3R5cGUuZ2V0ID0gZnVuY3Rpb24ocGF0aCwgdHlwZSwgb3B0aW9ucykge1xuICBsZXQgYWRob2M7XG4gIGlmIChvcHRpb25zID09IG51bGwpIHtcbiAgICBvcHRpb25zID0ge307XG4gIH1cbiAgaWYgKHR5cGUpIHtcbiAgICBhZGhvYyA9IHRoaXMuJF9fc2NoZW1hLmludGVycHJldEFzVHlwZShwYXRoLCB0eXBlLCB0aGlzLiRfX3NjaGVtYS5vcHRpb25zKTtcbiAgfVxuICBjb25zdCBub0RvdHRlZFBhdGggPSBvcHRpb25zLm5vRG90dGVkUGF0aDtcblxuICAvLyBGYXN0IHBhdGggaWYgd2Uga25vdyB3ZSdyZSBqdXN0IGFjY2Vzc2luZyB0b3AtbGV2ZWwgcGF0aCBvbiB0aGUgZG9jdW1lbnQ6XG4gIC8vIGp1c3QgZ2V0IHRoZSBzY2hlbWEgcGF0aCwgYXZvaWQgYCRfX3BhdGgoKWAgYmVjYXVzZSB0aGF0IGRvZXMgc3RyaW5nIG1hbmlwdWxhdGlvblxuICBsZXQgc2NoZW1hID0gbm9Eb3R0ZWRQYXRoID8gdGhpcy4kX19zY2hlbWEucGF0aHNbcGF0aF0gOiB0aGlzLiRfX3BhdGgocGF0aCk7XG4gIGlmIChzY2hlbWEgPT0gbnVsbCkge1xuICAgIHNjaGVtYSA9IHRoaXMuJF9fc2NoZW1hLnZpcnR1YWxwYXRoKHBhdGgpO1xuXG4gICAgaWYgKHNjaGVtYSAhPSBudWxsKSB7XG4gICAgICByZXR1cm4gc2NoZW1hLmFwcGx5R2V0dGVycyh2b2lkIDAsIHRoaXMpO1xuICAgIH1cbiAgfVxuXG4gIGlmIChub0RvdHRlZFBhdGgpIHtcbiAgICBsZXQgb2JqID0gdGhpcy5fZG9jW3BhdGhdO1xuICAgIGlmIChhZGhvYykge1xuICAgICAgb2JqID0gYWRob2MuY2FzdChvYmopO1xuICAgIH1cbiAgICBpZiAoc2NoZW1hICE9IG51bGwgJiYgb3B0aW9ucy5nZXR0ZXJzICE9PSBmYWxzZSkge1xuICAgICAgcmV0dXJuIHNjaGVtYS5hcHBseUdldHRlcnMob2JqLCB0aGlzKTtcbiAgICB9XG4gICAgcmV0dXJuIG9iajtcbiAgfVxuXG4gIGlmIChzY2hlbWEgIT0gbnVsbCAmJiBzY2hlbWEuaW5zdGFuY2UgPT09ICdNaXhlZCcpIHtcbiAgICBjb25zdCB2aXJ0dWFsID0gdGhpcy4kX19zY2hlbWEudmlydHVhbHBhdGgocGF0aCk7XG4gICAgaWYgKHZpcnR1YWwgIT0gbnVsbCkge1xuICAgICAgc2NoZW1hID0gdmlydHVhbDtcbiAgICB9XG4gIH1cblxuICBjb25zdCBoYXNEb3QgPSBwYXRoLmluZGV4T2YoJy4nKSAhPT0gLTE7XG4gIGxldCBvYmogPSB0aGlzLl9kb2M7XG5cbiAgY29uc3QgcGllY2VzID0gaGFzRG90ID8gcGF0aC5zcGxpdCgnLicpIDogW3BhdGhdO1xuICAvLyBNaWdodCBuZWVkIHRvIGNoYW5nZSBwYXRoIGZvciB0b3AtbGV2ZWwgYWxpYXNcbiAgaWYgKHR5cGVvZiB0aGlzLiRfX3NjaGVtYS5hbGlhc2VzW3BpZWNlc1swXV0gPT09ICdzdHJpbmcnKSB7XG4gICAgcGllY2VzWzBdID0gdGhpcy4kX19zY2hlbWEuYWxpYXNlc1twaWVjZXNbMF1dO1xuICB9XG5cbiAgZm9yIChsZXQgaSA9IDAsIGwgPSBwaWVjZXMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgaWYgKG9iaiAmJiBvYmouX2RvYykge1xuICAgICAgb2JqID0gb2JqLl9kb2M7XG4gICAgfVxuXG4gICAgaWYgKG9iaiA9PSBudWxsKSB7XG4gICAgICBvYmogPSB2b2lkIDA7XG4gICAgfSBlbHNlIGlmIChvYmogaW5zdGFuY2VvZiBNYXApIHtcbiAgICAgIG9iaiA9IG9iai5nZXQocGllY2VzW2ldLCB7IGdldHRlcnM6IGZhbHNlIH0pO1xuICAgIH0gZWxzZSBpZiAoaSA9PT0gbCAtIDEpIHtcbiAgICAgIG9iaiA9IHV0aWxzLmdldFZhbHVlKHBpZWNlc1tpXSwgb2JqKTtcbiAgICB9IGVsc2Uge1xuICAgICAgb2JqID0gb2JqW3BpZWNlc1tpXV07XG4gICAgfVxuICB9XG5cbiAgaWYgKGFkaG9jKSB7XG4gICAgb2JqID0gYWRob2MuY2FzdChvYmopO1xuICB9XG5cbiAgaWYgKHNjaGVtYSAhPSBudWxsICYmIG9wdGlvbnMuZ2V0dGVycyAhPT0gZmFsc2UpIHtcbiAgICBvYmogPSBzY2hlbWEuYXBwbHlHZXR0ZXJzKG9iaiwgdGhpcyk7XG4gIH0gZWxzZSBpZiAodGhpcy4kX19zY2hlbWEubmVzdGVkW3BhdGhdICYmIG9wdGlvbnMudmlydHVhbHMpIHtcbiAgICAvLyBNaWdodCBuZWVkIHRvIGFwcGx5IHZpcnR1YWxzIGlmIHRoaXMgaXMgYSBuZXN0ZWQgcGF0aFxuICAgIHJldHVybiBhcHBseVZpcnR1YWxzKHRoaXMsIGNsb25lKG9iaikgfHwge30sIHsgcGF0aDogcGF0aCB9KTtcbiAgfVxuXG4gIHJldHVybiBvYmo7XG59O1xuXG4vKiFcbiAqIGlnbm9yZVxuICovXG5cbkRvY3VtZW50LnByb3RvdHlwZVtnZXRTeW1ib2xdID0gRG9jdW1lbnQucHJvdG90eXBlLmdldDtcbkRvY3VtZW50LnByb3RvdHlwZS4kZ2V0ID0gRG9jdW1lbnQucHJvdG90eXBlLmdldDtcblxuLyoqXG4gKiBSZXR1cm5zIHRoZSBzY2hlbWF0eXBlIGZvciB0aGUgZ2l2ZW4gYHBhdGhgLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBwYXRoXG4gKiBAcmV0dXJuIHtTY2hlbWFQYXRofVxuICogQGFwaSBwcml2YXRlXG4gKiBAbWV0aG9kICRfX3BhdGhcbiAqIEBtZW1iZXJPZiBEb2N1bWVudFxuICogQGluc3RhbmNlXG4gKi9cblxuRG9jdW1lbnQucHJvdG90eXBlLiRfX3BhdGggPSBmdW5jdGlvbihwYXRoKSB7XG4gIGNvbnN0IGFkaG9jcyA9IHRoaXMuJF9fLmFkaG9jUGF0aHM7XG4gIGNvbnN0IGFkaG9jVHlwZSA9IGFkaG9jcyAmJiBhZGhvY3MuaGFzT3duUHJvcGVydHkocGF0aCkgPyBhZGhvY3NbcGF0aF0gOiBudWxsO1xuXG4gIGlmIChhZGhvY1R5cGUpIHtcbiAgICByZXR1cm4gYWRob2NUeXBlO1xuICB9XG4gIHJldHVybiB0aGlzLiRfX3NjaGVtYS5wYXRoKHBhdGgpO1xufTtcblxuLyoqXG4gKiBNYXJrcyB0aGUgcGF0aCBhcyBoYXZpbmcgcGVuZGluZyBjaGFuZ2VzIHRvIHdyaXRlIHRvIHRoZSBkYi5cbiAqXG4gKiBfVmVyeSBoZWxwZnVsIHdoZW4gdXNpbmcgW01peGVkXShodHRwczovL21vbmdvb3NlanMuY29tL2RvY3Mvc2NoZW1hdHlwZXMuaHRtbCNtaXhlZCkgdHlwZXMuX1xuICpcbiAqICMjIyMgRXhhbXBsZTpcbiAqXG4gKiAgICAgZG9jLm1peGVkLnR5cGUgPSAnY2hhbmdlZCc7XG4gKiAgICAgZG9jLm1hcmtNb2RpZmllZCgnbWl4ZWQudHlwZScpO1xuICogICAgIGRvYy5zYXZlKCkgLy8gY2hhbmdlcyB0byBtaXhlZC50eXBlIGFyZSBub3cgcGVyc2lzdGVkXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IHBhdGggdGhlIHBhdGggdG8gbWFyayBtb2RpZmllZFxuICogQHBhcmFtIHtEb2N1bWVudH0gW3Njb3BlXSB0aGUgc2NvcGUgdG8gcnVuIHZhbGlkYXRvcnMgd2l0aFxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5Eb2N1bWVudC5wcm90b3R5cGUubWFya01vZGlmaWVkID0gZnVuY3Rpb24ocGF0aCwgc2NvcGUpIHtcbiAgdGhpcy4kX19zYXZlSW5pdGlhbFN0YXRlKHBhdGgpO1xuXG4gIHRoaXMuJF9fLmFjdGl2ZVBhdGhzLm1vZGlmeShwYXRoKTtcbiAgaWYgKHNjb3BlICE9IG51bGwgJiYgIXRoaXMuJGlzU3ViZG9jdW1lbnQpIHtcbiAgICB0aGlzLiRfXy5wYXRoc1RvU2NvcGVzID0gdGhpcy4kX19wYXRoc1RvU2NvcGVzIHx8IHt9O1xuICAgIHRoaXMuJF9fLnBhdGhzVG9TY29wZXNbcGF0aF0gPSBzY29wZTtcbiAgfVxufTtcblxuLyohXG4gKiBpZ25vcmVcbiAqL1xuXG5Eb2N1bWVudC5wcm90b3R5cGUuJF9fc2F2ZUluaXRpYWxTdGF0ZSA9IGZ1bmN0aW9uICRfX3NhdmVJbml0aWFsU3RhdGUocGF0aCkge1xuICBjb25zdCBzYXZlZFN0YXRlID0gdGhpcy4kX18uc2F2ZWRTdGF0ZTtcbiAgY29uc3Qgc2F2ZWRTdGF0ZVBhdGggPSBwYXRoO1xuICBpZiAoc2F2ZWRTdGF0ZSAhPSBudWxsKSB7XG4gICAgY29uc3QgZmlyc3REb3QgPSBzYXZlZFN0YXRlUGF0aC5pbmRleE9mKCcuJyk7XG4gICAgY29uc3QgdG9wTGV2ZWxQYXRoID0gZmlyc3REb3QgPT09IC0xID8gc2F2ZWRTdGF0ZVBhdGggOiBzYXZlZFN0YXRlUGF0aC5zbGljZSgwLCBmaXJzdERvdCk7XG4gICAgaWYgKCFzYXZlZFN0YXRlLmhhc093blByb3BlcnR5KHRvcExldmVsUGF0aCkpIHtcbiAgICAgIHNhdmVkU3RhdGVbdG9wTGV2ZWxQYXRoXSA9IGNsb25lKHRoaXMuJF9fZ2V0VmFsdWUodG9wTGV2ZWxQYXRoKSk7XG4gICAgfVxuICB9XG59O1xuXG4vKipcbiAqIENsZWFycyB0aGUgbW9kaWZpZWQgc3RhdGUgb24gdGhlIHNwZWNpZmllZCBwYXRoLlxuICpcbiAqICMjIyMgRXhhbXBsZTpcbiAqXG4gKiAgICAgZG9jLmZvbyA9ICdiYXInO1xuICogICAgIGRvYy51bm1hcmtNb2RpZmllZCgnZm9vJyk7XG4gKiAgICAgZG9jLnNhdmUoKTsgLy8gY2hhbmdlcyB0byBmb28gd2lsbCBub3QgYmUgcGVyc2lzdGVkXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IHBhdGggdGhlIHBhdGggdG8gdW5tYXJrIG1vZGlmaWVkXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbkRvY3VtZW50LnByb3RvdHlwZS51bm1hcmtNb2RpZmllZCA9IGZ1bmN0aW9uKHBhdGgpIHtcbiAgdGhpcy4kX18uYWN0aXZlUGF0aHMuaW5pdChwYXRoKTtcbiAgaWYgKHRoaXMuJF9fLnBhdGhzVG9TY29wZXMgIT0gbnVsbCkge1xuICAgIGRlbGV0ZSB0aGlzLiRfXy5wYXRoc1RvU2NvcGVzW3BhdGhdO1xuICB9XG59O1xuXG4vKipcbiAqIERvbid0IHJ1biB2YWxpZGF0aW9uIG9uIHRoaXMgcGF0aCBvciBwZXJzaXN0IGNoYW5nZXMgdG8gdGhpcyBwYXRoLlxuICpcbiAqICMjIyMgRXhhbXBsZTpcbiAqXG4gKiAgICAgZG9jLmZvbyA9IG51bGw7XG4gKiAgICAgZG9jLiRpZ25vcmUoJ2ZvbycpO1xuICogICAgIGRvYy5zYXZlKCk7IC8vIGNoYW5nZXMgdG8gZm9vIHdpbGwgbm90IGJlIHBlcnNpc3RlZCBhbmQgdmFsaWRhdG9ycyB3b24ndCBiZSBydW5cbiAqXG4gKiBAbWVtYmVyT2YgRG9jdW1lbnRcbiAqIEBpbnN0YW5jZVxuICogQG1ldGhvZCAkaWdub3JlXG4gKiBAcGFyYW0ge1N0cmluZ30gcGF0aCB0aGUgcGF0aCB0byBpZ25vcmVcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuRG9jdW1lbnQucHJvdG90eXBlLiRpZ25vcmUgPSBmdW5jdGlvbihwYXRoKSB7XG4gIHRoaXMuJF9fLmFjdGl2ZVBhdGhzLmlnbm9yZShwYXRoKTtcbn07XG5cbi8qKlxuICogUmV0dXJucyB0aGUgbGlzdCBvZiBwYXRocyB0aGF0IGhhdmUgYmVlbiBkaXJlY3RseSBtb2RpZmllZC4gQSBkaXJlY3RcbiAqIG1vZGlmaWVkIHBhdGggaXMgYSBwYXRoIHRoYXQgeW91IGV4cGxpY2l0bHkgc2V0LCB3aGV0aGVyIHZpYSBgZG9jLmZvbyA9ICdiYXInYCxcbiAqIGBPYmplY3QuYXNzaWduKGRvYywgeyBmb286ICdiYXInIH0pYCwgb3IgYGRvYy5zZXQoJ2ZvbycsICdiYXInKWAuXG4gKlxuICogQSBwYXRoIGBhYCBtYXkgYmUgaW4gYG1vZGlmaWVkUGF0aHMoKWAgYnV0IG5vdCBpbiBgZGlyZWN0TW9kaWZpZWRQYXRocygpYFxuICogYmVjYXVzZSBhIGNoaWxkIG9mIGBhYCB3YXMgZGlyZWN0bHkgbW9kaWZpZWQuXG4gKlxuICogIyMjIyBFeGFtcGxlOlxuICpcbiAqICAgICBjb25zdCBzY2hlbWEgPSBuZXcgU2NoZW1hKHsgZm9vOiBTdHJpbmcsIG5lc3RlZDogeyBiYXI6IFN0cmluZyB9IH0pO1xuICogICAgIGNvbnN0IE1vZGVsID0gbW9uZ29vc2UubW9kZWwoJ1Rlc3QnLCBzY2hlbWEpO1xuICogICAgIGF3YWl0IE1vZGVsLmNyZWF0ZSh7IGZvbzogJ29yaWdpbmFsJywgbmVzdGVkOiB7IGJhcjogJ29yaWdpbmFsJyB9IH0pO1xuICpcbiAqICAgICBjb25zdCBkb2MgPSBhd2FpdCBNb2RlbC5maW5kT25lKCk7XG4gKiAgICAgZG9jLm5lc3RlZC5iYXIgPSAnbW9kaWZpZWQnO1xuICogICAgIGRvYy5kaXJlY3RNb2RpZmllZFBhdGhzKCk7IC8vIFsnbmVzdGVkLmJhciddXG4gKiAgICAgZG9jLm1vZGlmaWVkUGF0aHMoKTsgLy8gWyduZXN0ZWQnLCAnbmVzdGVkLmJhciddXG4gKlxuICogQHJldHVybiB7U3RyaW5nW119XG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbkRvY3VtZW50LnByb3RvdHlwZS5kaXJlY3RNb2RpZmllZFBhdGhzID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiBPYmplY3Qua2V5cyh0aGlzLiRfXy5hY3RpdmVQYXRocy5nZXRTdGF0ZVBhdGhzKCdtb2RpZnknKSk7XG59O1xuXG4vKipcbiAqIFJldHVybnMgdHJ1ZSBpZiB0aGUgZ2l2ZW4gcGF0aCBpcyBudWxsaXNoIG9yIG9ubHkgY29udGFpbnMgZW1wdHkgb2JqZWN0cy5cbiAqIFVzZWZ1bCBmb3IgZGV0ZXJtaW5pbmcgd2hldGhlciB0aGlzIHN1YmRvYyB3aWxsIGdldCBzdHJpcHBlZCBvdXQgYnkgdGhlXG4gKiBbbWluaW1pemUgb3B0aW9uXShodHRwczovL21vbmdvb3NlanMuY29tL2RvY3MvZ3VpZGUuaHRtbCNtaW5pbWl6ZSkuXG4gKlxuICogIyMjIyBFeGFtcGxlOlxuICpcbiAqICAgICBjb25zdCBzY2hlbWEgPSBuZXcgU2NoZW1hKHsgbmVzdGVkOiB7IGZvbzogU3RyaW5nIH0gfSk7XG4gKiAgICAgY29uc3QgTW9kZWwgPSBtb25nb29zZS5tb2RlbCgnVGVzdCcsIHNjaGVtYSk7XG4gKiAgICAgY29uc3QgZG9jID0gbmV3IE1vZGVsKHt9KTtcbiAqICAgICBkb2MuJGlzRW1wdHkoJ25lc3RlZCcpOyAvLyB0cnVlXG4gKiAgICAgZG9jLm5lc3RlZC4kaXNFbXB0eSgpOyAvLyB0cnVlXG4gKlxuICogICAgIGRvYy5uZXN0ZWQuZm9vID0gJ2Jhcic7XG4gKiAgICAgZG9jLiRpc0VtcHR5KCduZXN0ZWQnKTsgLy8gZmFsc2VcbiAqICAgICBkb2MubmVzdGVkLiRpc0VtcHR5KCk7IC8vIGZhbHNlXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IFtwYXRoXVxuICogQG1lbWJlck9mIERvY3VtZW50XG4gKiBAaW5zdGFuY2VcbiAqIEBhcGkgcHVibGljXG4gKiBAbWV0aG9kICRpc0VtcHR5XG4gKiBAcmV0dXJuIHtCb29sZWFufVxuICovXG5cbkRvY3VtZW50LnByb3RvdHlwZS4kaXNFbXB0eSA9IGZ1bmN0aW9uKHBhdGgpIHtcbiAgY29uc3QgaXNFbXB0eU9wdGlvbnMgPSB7XG4gICAgbWluaW1pemU6IHRydWUsXG4gICAgdmlydHVhbHM6IGZhbHNlLFxuICAgIGdldHRlcnM6IGZhbHNlLFxuICAgIHRyYW5zZm9ybTogZmFsc2VcbiAgfTtcblxuICBpZiAoYXJndW1lbnRzLmxlbmd0aCAhPT0gMCkge1xuICAgIGNvbnN0IHYgPSB0aGlzLiRnZXQocGF0aCk7XG4gICAgaWYgKHYgPT0gbnVsbCkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGlmICh0eXBlb2YgdiAhPT0gJ29iamVjdCcpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgaWYgKHV0aWxzLmlzUE9KTyh2KSkge1xuICAgICAgcmV0dXJuIF9pc0VtcHR5KHYpO1xuICAgIH1cbiAgICByZXR1cm4gT2JqZWN0LmtleXModi50b09iamVjdChpc0VtcHR5T3B0aW9ucykpLmxlbmd0aCA9PT0gMDtcbiAgfVxuXG4gIHJldHVybiBPYmplY3Qua2V5cyh0aGlzLnRvT2JqZWN0KGlzRW1wdHlPcHRpb25zKSkubGVuZ3RoID09PSAwO1xufTtcblxuLyohXG4gKiBpZ25vcmVcbiAqL1xuXG5mdW5jdGlvbiBfaXNFbXB0eSh2KSB7XG4gIGlmICh2ID09IG51bGwpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICBpZiAodHlwZW9mIHYgIT09ICdvYmplY3QnIHx8IEFycmF5LmlzQXJyYXkodikpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgZm9yIChjb25zdCBrZXkgb2YgT2JqZWN0LmtleXModikpIHtcbiAgICBpZiAoIV9pc0VtcHR5KHZba2V5XSkpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHRydWU7XG59XG5cbi8qKlxuICogUmV0dXJucyB0aGUgbGlzdCBvZiBwYXRocyB0aGF0IGhhdmUgYmVlbiBtb2RpZmllZC5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdXG4gKiBAcGFyYW0ge0Jvb2xlYW59IFtvcHRpb25zLmluY2x1ZGVDaGlsZHJlbj1mYWxzZV0gaWYgdHJ1ZSwgcmV0dXJucyBjaGlsZHJlbiBvZiBtb2RpZmllZCBwYXRocyBhcyB3ZWxsLiBGb3IgZXhhbXBsZSwgaWYgZmFsc2UsIHRoZSBsaXN0IG9mIG1vZGlmaWVkIHBhdGhzIGZvciBgZG9jLmNvbG9ycyA9IHsgcHJpbWFyeTogJ2JsdWUnIH07YCB3aWxsICoqbm90KiogY29udGFpbiBgY29sb3JzLnByaW1hcnlgLiBJZiB0cnVlLCBgbW9kaWZpZWRQYXRocygpYCB3aWxsIHJldHVybiBhbiBhcnJheSB0aGF0IGNvbnRhaW5zIGBjb2xvcnMucHJpbWFyeWAuXG4gKiBAcmV0dXJuIHtTdHJpbmdbXX1cbiAqIEBhcGkgcHVibGljXG4gKi9cblxuRG9jdW1lbnQucHJvdG90eXBlLm1vZGlmaWVkUGF0aHMgPSBmdW5jdGlvbihvcHRpb25zKSB7XG4gIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuXG4gIGNvbnN0IGRpcmVjdE1vZGlmaWVkUGF0aHMgPSBPYmplY3Qua2V5cyh0aGlzLiRfXy5hY3RpdmVQYXRocy5nZXRTdGF0ZVBhdGhzKCdtb2RpZnknKSk7XG4gIGNvbnN0IHJlc3VsdCA9IG5ldyBTZXQoKTtcblxuICBsZXQgaSA9IDA7XG4gIGxldCBqID0gMDtcbiAgY29uc3QgbGVuID0gZGlyZWN0TW9kaWZpZWRQYXRocy5sZW5ndGg7XG5cbiAgZm9yIChpID0gMDsgaSA8IGxlbjsgKytpKSB7XG4gICAgY29uc3QgcGF0aCA9IGRpcmVjdE1vZGlmaWVkUGF0aHNbaV07XG4gICAgY29uc3QgcGFydHMgPSBwYXJlbnRQYXRocyhwYXRoKTtcbiAgICBjb25zdCBwTGVuID0gcGFydHMubGVuZ3RoO1xuXG4gICAgZm9yIChqID0gMDsgaiA8IHBMZW47ICsraikge1xuICAgICAgcmVzdWx0LmFkZChwYXJ0c1tqXSk7XG4gICAgfVxuXG4gICAgaWYgKCFvcHRpb25zLmluY2x1ZGVDaGlsZHJlbikge1xuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgbGV0IGlpID0gMDtcbiAgICBsZXQgY3VyID0gdGhpcy4kZ2V0KHBhdGgpO1xuICAgIGlmICh0eXBlb2YgY3VyID09PSAnb2JqZWN0JyAmJiBjdXIgIT09IG51bGwpIHtcbiAgICAgIGlmIChjdXIuX2RvYykge1xuICAgICAgICBjdXIgPSBjdXIuX2RvYztcbiAgICAgIH1cbiAgICAgIGNvbnN0IGxlbiA9IGN1ci5sZW5ndGg7XG4gICAgICBpZiAoQXJyYXkuaXNBcnJheShjdXIpKSB7XG4gICAgICAgIGZvciAoaWkgPSAwOyBpaSA8IGxlbjsgKytpaSkge1xuICAgICAgICAgIGNvbnN0IHN1YlBhdGggPSBwYXRoICsgJy4nICsgaWk7XG4gICAgICAgICAgaWYgKCFyZXN1bHQuaGFzKHN1YlBhdGgpKSB7XG4gICAgICAgICAgICByZXN1bHQuYWRkKHN1YlBhdGgpO1xuICAgICAgICAgICAgaWYgKGN1cltpaV0gIT0gbnVsbCAmJiBjdXJbaWldLiRfXykge1xuICAgICAgICAgICAgICBjb25zdCBtb2RpZmllZCA9IGN1cltpaV0ubW9kaWZpZWRQYXRocygpO1xuICAgICAgICAgICAgICBsZXQgaWlpID0gMDtcbiAgICAgICAgICAgICAgY29uc3QgaWlpTGVuID0gbW9kaWZpZWQubGVuZ3RoO1xuICAgICAgICAgICAgICBmb3IgKGlpaSA9IDA7IGlpaSA8IGlpaUxlbjsgKytpaWkpIHtcbiAgICAgICAgICAgICAgICByZXN1bHQuYWRkKHN1YlBhdGggKyAnLicgKyBtb2RpZmllZFtpaWldKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc3Qga2V5cyA9IE9iamVjdC5rZXlzKGN1cik7XG4gICAgICAgIGxldCBpaSA9IDA7XG4gICAgICAgIGNvbnN0IGxlbiA9IGtleXMubGVuZ3RoO1xuICAgICAgICBmb3IgKGlpID0gMDsgaWkgPCBsZW47ICsraWkpIHtcbiAgICAgICAgICByZXN1bHQuYWRkKHBhdGggKyAnLicgKyBrZXlzW2lpXSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIEFycmF5LmZyb20ocmVzdWx0KTtcbn07XG5cbkRvY3VtZW50LnByb3RvdHlwZVtkb2N1bWVudE1vZGlmaWVkUGF0aHNdID0gRG9jdW1lbnQucHJvdG90eXBlLm1vZGlmaWVkUGF0aHM7XG5cbi8qKlxuICogUmV0dXJucyB0cnVlIGlmIGFueSBvZiB0aGUgZ2l2ZW4gcGF0aHMgaXMgbW9kaWZpZWQsIGVsc2UgZmFsc2UuIElmIG5vIGFyZ3VtZW50cywgcmV0dXJucyBgdHJ1ZWAgaWYgYW55IHBhdGhcbiAqIGluIHRoaXMgZG9jdW1lbnQgaXMgbW9kaWZpZWQuXG4gKlxuICogSWYgYHBhdGhgIGlzIGdpdmVuLCBjaGVja3MgaWYgYSBwYXRoIG9yIGFueSBmdWxsIHBhdGggY29udGFpbmluZyBgcGF0aGAgYXMgcGFydCBvZiBpdHMgcGF0aCBjaGFpbiBoYXMgYmVlbiBtb2RpZmllZC5cbiAqXG4gKiAjIyMjIEV4YW1wbGU6XG4gKlxuICogICAgIGRvYy5zZXQoJ2RvY3VtZW50cy4wLnRpdGxlJywgJ2NoYW5nZWQnKTtcbiAqICAgICBkb2MuaXNNb2RpZmllZCgpICAgICAgICAgICAgICAgICAgICAgIC8vIHRydWVcbiAqICAgICBkb2MuaXNNb2RpZmllZCgnZG9jdW1lbnRzJykgICAgICAgICAgIC8vIHRydWVcbiAqICAgICBkb2MuaXNNb2RpZmllZCgnZG9jdW1lbnRzLjAudGl0bGUnKSAgIC8vIHRydWVcbiAqICAgICBkb2MuaXNNb2RpZmllZCgnZG9jdW1lbnRzIG90aGVyUHJvcCcpIC8vIHRydWVcbiAqICAgICBkb2MuaXNEaXJlY3RNb2RpZmllZCgnZG9jdW1lbnRzJykgICAgIC8vIGZhbHNlXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IFtwYXRoXSBvcHRpb25hbFxuICogQHJldHVybiB7Qm9vbGVhbn1cbiAqIEBhcGkgcHVibGljXG4gKi9cblxuRG9jdW1lbnQucHJvdG90eXBlLmlzTW9kaWZpZWQgPSBmdW5jdGlvbihwYXRocywgbW9kaWZpZWRQYXRocykge1xuICBpZiAocGF0aHMpIHtcbiAgICBjb25zdCBkaXJlY3RNb2RpZmllZFBhdGhzT2JqID0gdGhpcy4kX18uYWN0aXZlUGF0aHMuc3RhdGVzLm1vZGlmeTtcbiAgICBpZiAoZGlyZWN0TW9kaWZpZWRQYXRoc09iaiA9PSBudWxsKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiBwYXRocyA9PT0gJ3N0cmluZycpIHtcbiAgICAgIHBhdGhzID0gcGF0aHMuaW5kZXhPZignICcpID09PSAtMSA/IFtwYXRoc10gOiBwYXRocy5zcGxpdCgnICcpO1xuICAgIH1cblxuICAgIGZvciAoY29uc3QgcGF0aCBvZiBwYXRocykge1xuICAgICAgaWYgKGRpcmVjdE1vZGlmaWVkUGF0aHNPYmpbcGF0aF0gIT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBjb25zdCBtb2RpZmllZCA9IG1vZGlmaWVkUGF0aHMgfHwgdGhpc1tkb2N1bWVudE1vZGlmaWVkUGF0aHNdKCk7XG4gICAgY29uc3QgaXNNb2RpZmllZENoaWxkID0gcGF0aHMuc29tZShmdW5jdGlvbihwYXRoKSB7XG4gICAgICByZXR1cm4gISF+bW9kaWZpZWQuaW5kZXhPZihwYXRoKTtcbiAgICB9KTtcblxuICAgIGNvbnN0IGRpcmVjdE1vZGlmaWVkUGF0aHMgPSBPYmplY3Qua2V5cyhkaXJlY3RNb2RpZmllZFBhdGhzT2JqKTtcbiAgICByZXR1cm4gaXNNb2RpZmllZENoaWxkIHx8IHBhdGhzLnNvbWUoZnVuY3Rpb24ocGF0aCkge1xuICAgICAgcmV0dXJuIGRpcmVjdE1vZGlmaWVkUGF0aHMuc29tZShmdW5jdGlvbihtb2QpIHtcbiAgICAgICAgcmV0dXJuIG1vZCA9PT0gcGF0aCB8fCBwYXRoLnN0YXJ0c1dpdGgobW9kICsgJy4nKTtcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9XG5cbiAgcmV0dXJuIHRoaXMuJF9fLmFjdGl2ZVBhdGhzLnNvbWUoJ21vZGlmeScpO1xufTtcblxuLyoqXG4gKiBBbGlhcyBvZiBbYC5pc01vZGlmaWVkYF0oaHR0cHM6Ly9tb25nb29zZWpzLmNvbS9kb2NzL2FwaS9kb2N1bWVudC5odG1sI0RvY3VtZW50LnByb3RvdHlwZS5pc01vZGlmaWVkKCkpXG4gKlxuICogQG1ldGhvZCAkaXNNb2RpZmllZFxuICogQG1lbWJlck9mIERvY3VtZW50XG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbkRvY3VtZW50LnByb3RvdHlwZS4kaXNNb2RpZmllZCA9IERvY3VtZW50LnByb3RvdHlwZS5pc01vZGlmaWVkO1xuXG5Eb2N1bWVudC5wcm90b3R5cGVbZG9jdW1lbnRJc01vZGlmaWVkXSA9IERvY3VtZW50LnByb3RvdHlwZS5pc01vZGlmaWVkO1xuXG4vKipcbiAqIENoZWNrcyBpZiBhIHBhdGggaXMgc2V0IHRvIGl0cyBkZWZhdWx0LlxuICpcbiAqICMjIyMgRXhhbXBsZTpcbiAqXG4gKiAgICAgTXlNb2RlbCA9IG1vbmdvb3NlLm1vZGVsKCd0ZXN0JywgeyBuYW1lOiB7IHR5cGU6IFN0cmluZywgZGVmYXVsdDogJ1ZhbCAnfSB9KTtcbiAqICAgICBjb25zdCBtID0gbmV3IE15TW9kZWwoKTtcbiAqICAgICBtLiRpc0RlZmF1bHQoJ25hbWUnKTsgLy8gdHJ1ZVxuICpcbiAqIEBtZW1iZXJPZiBEb2N1bWVudFxuICogQGluc3RhbmNlXG4gKiBAbWV0aG9kICRpc0RlZmF1bHRcbiAqIEBwYXJhbSB7U3RyaW5nfSBbcGF0aF1cbiAqIEByZXR1cm4ge0Jvb2xlYW59XG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbkRvY3VtZW50LnByb3RvdHlwZS4kaXNEZWZhdWx0ID0gZnVuY3Rpb24ocGF0aCkge1xuICBpZiAocGF0aCA9PSBudWxsKSB7XG4gICAgcmV0dXJuIHRoaXMuJF9fLmFjdGl2ZVBhdGhzLnNvbWUoJ2RlZmF1bHQnKTtcbiAgfVxuXG4gIGlmICh0eXBlb2YgcGF0aCA9PT0gJ3N0cmluZycgJiYgcGF0aC5pbmRleE9mKCcgJykgPT09IC0xKSB7XG4gICAgcmV0dXJuIHRoaXMuJF9fLmFjdGl2ZVBhdGhzLmdldFN0YXRlUGF0aHMoJ2RlZmF1bHQnKS5oYXNPd25Qcm9wZXJ0eShwYXRoKTtcbiAgfVxuXG4gIGxldCBwYXRocyA9IHBhdGg7XG4gIGlmICghQXJyYXkuaXNBcnJheShwYXRocykpIHtcbiAgICBwYXRocyA9IHBhdGhzLnNwbGl0KCcgJyk7XG4gIH1cblxuICByZXR1cm4gcGF0aHMuc29tZShwYXRoID0+IHRoaXMuJF9fLmFjdGl2ZVBhdGhzLmdldFN0YXRlUGF0aHMoJ2RlZmF1bHQnKS5oYXNPd25Qcm9wZXJ0eShwYXRoKSk7XG59O1xuXG4vKipcbiAqIEdldHRlci9zZXR0ZXIsIGRldGVybWluZXMgd2hldGhlciB0aGUgZG9jdW1lbnQgd2FzIHJlbW92ZWQgb3Igbm90LlxuICpcbiAqICMjIyMgRXhhbXBsZTpcbiAqXG4gKiAgICAgY29uc3QgcHJvZHVjdCA9IGF3YWl0IHByb2R1Y3QucmVtb3ZlKCk7XG4gKiAgICAgcHJvZHVjdC4kaXNEZWxldGVkKCk7IC8vIHRydWVcbiAqICAgICBwcm9kdWN0LnJlbW92ZSgpOyAvLyBuby1vcCwgZG9lc24ndCBzZW5kIGFueXRoaW5nIHRvIHRoZSBkYlxuICpcbiAqICAgICBwcm9kdWN0LiRpc0RlbGV0ZWQoZmFsc2UpO1xuICogICAgIHByb2R1Y3QuJGlzRGVsZXRlZCgpOyAvLyBmYWxzZVxuICogICAgIHByb2R1Y3QucmVtb3ZlKCk7IC8vIHdpbGwgZXhlY3V0ZSBhIHJlbW92ZSBhZ2FpbnN0IHRoZSBkYlxuICpcbiAqXG4gKiBAcGFyYW0ge0Jvb2xlYW59IFt2YWxdIG9wdGlvbmFsLCBvdmVycmlkZXMgd2hldGhlciBtb25nb29zZSB0aGlua3MgdGhlIGRvYyBpcyBkZWxldGVkXG4gKiBAcmV0dXJuIHtCb29sZWFufERvY3VtZW50fSB3aGV0aGVyIG1vbmdvb3NlIHRoaW5rcyB0aGlzIGRvYyBpcyBkZWxldGVkLlxuICogQG1ldGhvZCAkaXNEZWxldGVkXG4gKiBAbWVtYmVyT2YgRG9jdW1lbnRcbiAqIEBpbnN0YW5jZVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5Eb2N1bWVudC5wcm90b3R5cGUuJGlzRGVsZXRlZCA9IGZ1bmN0aW9uKHZhbCkge1xuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMCkge1xuICAgIHJldHVybiAhIXRoaXMuJF9fLmlzRGVsZXRlZDtcbiAgfVxuXG4gIHRoaXMuJF9fLmlzRGVsZXRlZCA9ICEhdmFsO1xuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogUmV0dXJucyB0cnVlIGlmIGBwYXRoYCB3YXMgZGlyZWN0bHkgc2V0IGFuZCBtb2RpZmllZCwgZWxzZSBmYWxzZS5cbiAqXG4gKiAjIyMjIEV4YW1wbGU6XG4gKlxuICogICAgIGRvYy5zZXQoJ2RvY3VtZW50cy4wLnRpdGxlJywgJ2NoYW5nZWQnKTtcbiAqICAgICBkb2MuaXNEaXJlY3RNb2RpZmllZCgnZG9jdW1lbnRzLjAudGl0bGUnKSAvLyB0cnVlXG4gKiAgICAgZG9jLmlzRGlyZWN0TW9kaWZpZWQoJ2RvY3VtZW50cycpIC8vIGZhbHNlXG4gKlxuICogQHBhcmFtIHtTdHJpbmd8U3RyaW5nW119IFtwYXRoXVxuICogQHJldHVybiB7Qm9vbGVhbn1cbiAqIEBhcGkgcHVibGljXG4gKi9cblxuRG9jdW1lbnQucHJvdG90eXBlLmlzRGlyZWN0TW9kaWZpZWQgPSBmdW5jdGlvbihwYXRoKSB7XG4gIGlmIChwYXRoID09IG51bGwpIHtcbiAgICByZXR1cm4gdGhpcy4kX18uYWN0aXZlUGF0aHMuc29tZSgnbW9kaWZ5Jyk7XG4gIH1cblxuICBpZiAodHlwZW9mIHBhdGggPT09ICdzdHJpbmcnICYmIHBhdGguaW5kZXhPZignICcpID09PSAtMSkge1xuICAgIHJldHVybiB0aGlzLiRfXy5hY3RpdmVQYXRocy5nZXRTdGF0ZVBhdGhzKCdtb2RpZnknKS5oYXNPd25Qcm9wZXJ0eShwYXRoKTtcbiAgfVxuXG4gIGxldCBwYXRocyA9IHBhdGg7XG4gIGlmICghQXJyYXkuaXNBcnJheShwYXRocykpIHtcbiAgICBwYXRocyA9IHBhdGhzLnNwbGl0KCcgJyk7XG4gIH1cblxuICByZXR1cm4gcGF0aHMuc29tZShwYXRoID0+IHRoaXMuJF9fLmFjdGl2ZVBhdGhzLmdldFN0YXRlUGF0aHMoJ21vZGlmeScpLmhhc093blByb3BlcnR5KHBhdGgpKTtcbn07XG5cbi8qKlxuICogQ2hlY2tzIGlmIGBwYXRoYCBpcyBpbiB0aGUgYGluaXRgIHN0YXRlLCB0aGF0IGlzLCBpdCB3YXMgc2V0IGJ5IGBEb2N1bWVudCNpbml0KClgIGFuZCBub3QgbW9kaWZpZWQgc2luY2UuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IFtwYXRoXVxuICogQHJldHVybiB7Qm9vbGVhbn1cbiAqIEBhcGkgcHVibGljXG4gKi9cblxuRG9jdW1lbnQucHJvdG90eXBlLmlzSW5pdCA9IGZ1bmN0aW9uKHBhdGgpIHtcbiAgaWYgKHBhdGggPT0gbnVsbCkge1xuICAgIHJldHVybiB0aGlzLiRfXy5hY3RpdmVQYXRocy5zb21lKCdpbml0Jyk7XG4gIH1cblxuICBpZiAodHlwZW9mIHBhdGggPT09ICdzdHJpbmcnICYmIHBhdGguaW5kZXhPZignICcpID09PSAtMSkge1xuICAgIHJldHVybiB0aGlzLiRfXy5hY3RpdmVQYXRocy5nZXRTdGF0ZVBhdGhzKCdpbml0JykuaGFzT3duUHJvcGVydHkocGF0aCk7XG4gIH1cblxuICBsZXQgcGF0aHMgPSBwYXRoO1xuICBpZiAoIUFycmF5LmlzQXJyYXkocGF0aHMpKSB7XG4gICAgcGF0aHMgPSBwYXRocy5zcGxpdCgnICcpO1xuICB9XG5cbiAgcmV0dXJuIHBhdGhzLnNvbWUocGF0aCA9PiB0aGlzLiRfXy5hY3RpdmVQYXRocy5nZXRTdGF0ZVBhdGhzKCdpbml0JykuaGFzT3duUHJvcGVydHkocGF0aCkpO1xufTtcblxuLyoqXG4gKiBDaGVja3MgaWYgYHBhdGhgIHdhcyBzZWxlY3RlZCBpbiB0aGUgc291cmNlIHF1ZXJ5IHdoaWNoIGluaXRpYWxpemVkIHRoaXMgZG9jdW1lbnQuXG4gKlxuICogIyMjIyBFeGFtcGxlOlxuICpcbiAqICAgICBjb25zdCBkb2MgPSBhd2FpdCBUaGluZy5maW5kT25lKCkuc2VsZWN0KCduYW1lJyk7XG4gKiAgICAgZG9jLmlzU2VsZWN0ZWQoJ25hbWUnKSAvLyB0cnVlXG4gKiAgICAgZG9jLmlzU2VsZWN0ZWQoJ2FnZScpICAvLyBmYWxzZVxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfFN0cmluZ1tdfSBwYXRoXG4gKiBAcmV0dXJuIHtCb29sZWFufVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5Eb2N1bWVudC5wcm90b3R5cGUuaXNTZWxlY3RlZCA9IGZ1bmN0aW9uIGlzU2VsZWN0ZWQocGF0aCkge1xuICBpZiAodGhpcy4kX18uc2VsZWN0ZWQgPT0gbnVsbCkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIGlmICghcGF0aCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBpZiAocGF0aCA9PT0gJ19pZCcpIHtcbiAgICByZXR1cm4gdGhpcy4kX18uc2VsZWN0ZWQuX2lkICE9PSAwO1xuICB9XG5cbiAgaWYgKHBhdGguaW5kZXhPZignICcpICE9PSAtMSkge1xuICAgIHBhdGggPSBwYXRoLnNwbGl0KCcgJyk7XG4gIH1cbiAgaWYgKEFycmF5LmlzQXJyYXkocGF0aCkpIHtcbiAgICByZXR1cm4gcGF0aC5zb21lKHAgPT4gdGhpcy4kX19pc1NlbGVjdGVkKHApKTtcbiAgfVxuXG4gIGNvbnN0IHBhdGhzID0gT2JqZWN0LmtleXModGhpcy4kX18uc2VsZWN0ZWQpO1xuICBsZXQgaW5jbHVzaXZlID0gbnVsbDtcblxuICBpZiAocGF0aHMubGVuZ3RoID09PSAxICYmIHBhdGhzWzBdID09PSAnX2lkJykge1xuICAgIC8vIG9ubHkgX2lkIHdhcyBzZWxlY3RlZC5cbiAgICByZXR1cm4gdGhpcy4kX18uc2VsZWN0ZWQuX2lkID09PSAwO1xuICB9XG5cbiAgZm9yIChjb25zdCBjdXIgb2YgcGF0aHMpIHtcbiAgICBpZiAoY3VyID09PSAnX2lkJykge1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIGlmICghaXNEZWZpbmluZ1Byb2plY3Rpb24odGhpcy4kX18uc2VsZWN0ZWRbY3VyXSkpIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICBpbmNsdXNpdmUgPSAhIXRoaXMuJF9fLnNlbGVjdGVkW2N1cl07XG4gICAgYnJlYWs7XG4gIH1cblxuICBpZiAoaW5jbHVzaXZlID09PSBudWxsKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICBpZiAocGF0aCBpbiB0aGlzLiRfXy5zZWxlY3RlZCkge1xuICAgIHJldHVybiBpbmNsdXNpdmU7XG4gIH1cblxuICBjb25zdCBwYXRoRG90ID0gcGF0aCArICcuJztcblxuICBmb3IgKGNvbnN0IGN1ciBvZiBwYXRocykge1xuICAgIGlmIChjdXIgPT09ICdfaWQnKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICBpZiAoY3VyLnN0YXJ0c1dpdGgocGF0aERvdCkpIHtcbiAgICAgIHJldHVybiBpbmNsdXNpdmUgfHwgY3VyICE9PSBwYXRoRG90O1xuICAgIH1cblxuICAgIGlmIChwYXRoRG90LnN0YXJ0c1dpdGgoY3VyICsgJy4nKSkge1xuICAgICAgcmV0dXJuIGluY2x1c2l2ZTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuICFpbmNsdXNpdmU7XG59O1xuXG5Eb2N1bWVudC5wcm90b3R5cGUuJF9faXNTZWxlY3RlZCA9IERvY3VtZW50LnByb3RvdHlwZS5pc1NlbGVjdGVkO1xuXG4vKipcbiAqIENoZWNrcyBpZiBgcGF0aGAgd2FzIGV4cGxpY2l0bHkgc2VsZWN0ZWQuIElmIG5vIHByb2plY3Rpb24sIGFsd2F5cyByZXR1cm5zXG4gKiB0cnVlLlxuICpcbiAqICMjIyMgRXhhbXBsZTpcbiAqXG4gKiAgICAgVGhpbmcuZmluZE9uZSgpLnNlbGVjdCgnbmVzdGVkLm5hbWUnKS5leGVjKGZ1bmN0aW9uIChlcnIsIGRvYykge1xuICogICAgICAgIGRvYy5pc0RpcmVjdFNlbGVjdGVkKCduZXN0ZWQubmFtZScpIC8vIHRydWVcbiAqICAgICAgICBkb2MuaXNEaXJlY3RTZWxlY3RlZCgnbmVzdGVkLm90aGVyTmFtZScpIC8vIGZhbHNlXG4gKiAgICAgICAgZG9jLmlzRGlyZWN0U2VsZWN0ZWQoJ25lc3RlZCcpICAvLyBmYWxzZVxuICogICAgIH0pXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IHBhdGhcbiAqIEByZXR1cm4ge0Jvb2xlYW59XG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbkRvY3VtZW50LnByb3RvdHlwZS5pc0RpcmVjdFNlbGVjdGVkID0gZnVuY3Rpb24gaXNEaXJlY3RTZWxlY3RlZChwYXRoKSB7XG4gIGlmICh0aGlzLiRfXy5zZWxlY3RlZCA9PSBudWxsKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICBpZiAocGF0aCA9PT0gJ19pZCcpIHtcbiAgICByZXR1cm4gdGhpcy4kX18uc2VsZWN0ZWQuX2lkICE9PSAwO1xuICB9XG5cbiAgaWYgKHBhdGguaW5kZXhPZignICcpICE9PSAtMSkge1xuICAgIHBhdGggPSBwYXRoLnNwbGl0KCcgJyk7XG4gIH1cbiAgaWYgKEFycmF5LmlzQXJyYXkocGF0aCkpIHtcbiAgICByZXR1cm4gcGF0aC5zb21lKHAgPT4gdGhpcy5pc0RpcmVjdFNlbGVjdGVkKHApKTtcbiAgfVxuXG4gIGNvbnN0IHBhdGhzID0gT2JqZWN0LmtleXModGhpcy4kX18uc2VsZWN0ZWQpO1xuICBsZXQgaW5jbHVzaXZlID0gbnVsbDtcblxuICBpZiAocGF0aHMubGVuZ3RoID09PSAxICYmIHBhdGhzWzBdID09PSAnX2lkJykge1xuICAgIC8vIG9ubHkgX2lkIHdhcyBzZWxlY3RlZC5cbiAgICByZXR1cm4gdGhpcy4kX18uc2VsZWN0ZWQuX2lkID09PSAwO1xuICB9XG5cbiAgZm9yIChjb25zdCBjdXIgb2YgcGF0aHMpIHtcbiAgICBpZiAoY3VyID09PSAnX2lkJykge1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIGlmICghaXNEZWZpbmluZ1Byb2plY3Rpb24odGhpcy4kX18uc2VsZWN0ZWRbY3VyXSkpIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICBpbmNsdXNpdmUgPSAhIXRoaXMuJF9fLnNlbGVjdGVkW2N1cl07XG4gICAgYnJlYWs7XG4gIH1cblxuICBpZiAoaW5jbHVzaXZlID09PSBudWxsKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICBpZiAodGhpcy4kX18uc2VsZWN0ZWQuaGFzT3duUHJvcGVydHkocGF0aCkpIHtcbiAgICByZXR1cm4gaW5jbHVzaXZlO1xuICB9XG5cbiAgcmV0dXJuICFpbmNsdXNpdmU7XG59O1xuXG4vKipcbiAqIEV4ZWN1dGVzIHJlZ2lzdGVyZWQgdmFsaWRhdGlvbiBydWxlcyBmb3IgdGhpcyBkb2N1bWVudC5cbiAqXG4gKiAjIyMjIE5vdGU6XG4gKlxuICogVGhpcyBtZXRob2QgaXMgY2FsbGVkIGBwcmVgIHNhdmUgYW5kIGlmIGEgdmFsaWRhdGlvbiBydWxlIGlzIHZpb2xhdGVkLCBbc2F2ZV0oaHR0cHM6Ly9tb25nb29zZWpzLmNvbS9kb2NzL2FwaS9tb2RlbC5odG1sI01vZGVsLnByb3RvdHlwZS5zYXZlKCkpIGlzIGFib3J0ZWQgYW5kIHRoZSBlcnJvciBpcyB0aHJvd24uXG4gKlxuICogIyMjIyBFeGFtcGxlOlxuICpcbiAqICAgICBhd2FpdCBkb2MudmFsaWRhdGUoeyB2YWxpZGF0ZU1vZGlmaWVkT25seTogZmFsc2UsIHBhdGhzVG9Ta2lwOiBbJ25hbWUnLCAnZW1haWwnXX0pO1xuICpcbiAqIEBwYXJhbSB7QXJyYXl8U3RyaW5nfSBbcGF0aHNUb1ZhbGlkYXRlXSBsaXN0IG9mIHBhdGhzIHRvIHZhbGlkYXRlLiBJZiBzZXQsIE1vbmdvb3NlIHdpbGwgdmFsaWRhdGUgb25seSB0aGUgbW9kaWZpZWQgcGF0aHMgdGhhdCBhcmUgaW4gdGhlIGdpdmVuIGxpc3QuXG4gKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdIGludGVybmFsIG9wdGlvbnNcbiAqIEBwYXJhbSB7Qm9vbGVhbn0gW29wdGlvbnMudmFsaWRhdGVNb2RpZmllZE9ubHk9ZmFsc2VdIGlmIGB0cnVlYCBtb25nb29zZSB2YWxpZGF0ZXMgb25seSBtb2RpZmllZCBwYXRocy5cbiAqIEBwYXJhbSB7QXJyYXl8c3RyaW5nfSBbb3B0aW9ucy5wYXRoc1RvU2tpcF0gbGlzdCBvZiBwYXRocyB0byBza2lwLiBJZiBzZXQsIE1vbmdvb3NlIHdpbGwgdmFsaWRhdGUgZXZlcnkgbW9kaWZpZWQgcGF0aCB0aGF0IGlzIG5vdCBpbiB0aGlzIGxpc3QuXG4gKiBAcmV0dXJuIHtQcm9taXNlfSBSZXR1cm5zIGEgUHJvbWlzZS5cbiAqIEBhcGkgcHVibGljXG4gKi9cblxuRG9jdW1lbnQucHJvdG90eXBlLnZhbGlkYXRlID0gYXN5bmMgZnVuY3Rpb24gdmFsaWRhdGUocGF0aHNUb1ZhbGlkYXRlLCBvcHRpb25zKSB7XG4gIGlmICh0eXBlb2YgcGF0aHNUb1ZhbGlkYXRlID09PSAnZnVuY3Rpb24nIHx8IHR5cGVvZiBvcHRpb25zID09PSAnZnVuY3Rpb24nIHx8IHR5cGVvZiBhcmd1bWVudHNbMl0gPT09ICdmdW5jdGlvbicpIHtcbiAgICB0aHJvdyBuZXcgTW9uZ29vc2VFcnJvcignRG9jdW1lbnQucHJvdG90eXBlLnZhbGlkYXRlKCkgbm8gbG9uZ2VyIGFjY2VwdHMgYSBjYWxsYmFjaycpO1xuICB9XG4gIGxldCBwYXJhbGxlbFZhbGlkYXRlO1xuICB0aGlzLiRvcCA9ICd2YWxpZGF0ZSc7XG5cbiAgaWYgKHRoaXMuJGlzU3ViZG9jdW1lbnQgIT0gbnVsbCkge1xuICAgIC8vIFNraXAgcGFyYWxsZWwgdmFsaWRhdGUgY2hlY2sgZm9yIHN1YmRvY3VtZW50c1xuICB9IGVsc2UgaWYgKHRoaXMuJF9fLnZhbGlkYXRpbmcpIHtcbiAgICBwYXJhbGxlbFZhbGlkYXRlID0gbmV3IFBhcmFsbGVsVmFsaWRhdGVFcnJvcih0aGlzLCB7XG4gICAgICBwYXJlbnRTdGFjazogb3B0aW9ucyAmJiBvcHRpb25zLnBhcmVudFN0YWNrLFxuICAgICAgY29uZmxpY3RTdGFjazogdGhpcy4kX18udmFsaWRhdGluZy5zdGFja1xuICAgIH0pO1xuICB9IGVsc2Uge1xuICAgIHRoaXMuJF9fLnZhbGlkYXRpbmcgPSBuZXcgUGFyYWxsZWxWYWxpZGF0ZUVycm9yKHRoaXMsIHsgcGFyZW50U3RhY2s6IG9wdGlvbnMgJiYgb3B0aW9ucy5wYXJlbnRTdGFjayB9KTtcbiAgfVxuXG4gIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAxKSB7XG4gICAgaWYgKHR5cGVvZiBhcmd1bWVudHNbMF0gPT09ICdvYmplY3QnICYmICFBcnJheS5pc0FycmF5KGFyZ3VtZW50c1swXSkpIHtcbiAgICAgIG9wdGlvbnMgPSBhcmd1bWVudHNbMF07XG4gICAgICBwYXRoc1RvVmFsaWRhdGUgPSBudWxsO1xuICAgIH1cbiAgfVxuICBpZiAob3B0aW9ucyAmJiB0eXBlb2Ygb3B0aW9ucy5wYXRoc1RvU2tpcCA9PT0gJ3N0cmluZycpIHtcbiAgICBjb25zdCBpc09uZVBhdGhPbmx5ID0gb3B0aW9ucy5wYXRoc1RvU2tpcC5pbmRleE9mKCcgJykgPT09IC0xO1xuICAgIG9wdGlvbnMucGF0aHNUb1NraXAgPSBpc09uZVBhdGhPbmx5ID8gW29wdGlvbnMucGF0aHNUb1NraXBdIDogb3B0aW9ucy5wYXRoc1RvU2tpcC5zcGxpdCgnICcpO1xuICB9XG5cbiAgaWYgKHBhcmFsbGVsVmFsaWRhdGUgIT0gbnVsbCkge1xuICAgIHRocm93IHBhcmFsbGVsVmFsaWRhdGU7XG4gIH1cblxuICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgIHRoaXMuJF9fdmFsaWRhdGUocGF0aHNUb1ZhbGlkYXRlLCBvcHRpb25zLCAoZXJyb3IpID0+IHtcbiAgICAgIHRoaXMuJG9wID0gbnVsbDtcbiAgICAgIHRoaXMuJF9fLnZhbGlkYXRpbmcgPSBudWxsO1xuICAgICAgaWYgKGVycm9yICE9IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIHJlamVjdChlcnJvcik7XG4gICAgICB9XG4gICAgICByZXNvbHZlKCk7XG4gICAgfSk7XG4gIH0pO1xufTtcblxuLyoqXG4gKiBBbGlhcyBvZiBbYC52YWxpZGF0ZWBdKGh0dHBzOi8vbW9uZ29vc2Vqcy5jb20vZG9jcy9hcGkvZG9jdW1lbnQuaHRtbCNEb2N1bWVudC5wcm90b3R5cGUudmFsaWRhdGUoKSlcbiAqXG4gKiBAbWV0aG9kICR2YWxpZGF0ZVxuICogQG1lbWJlck9mIERvY3VtZW50XG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbkRvY3VtZW50LnByb3RvdHlwZS4kdmFsaWRhdGUgPSBEb2N1bWVudC5wcm90b3R5cGUudmFsaWRhdGU7XG5cbi8qIVxuICogaWdub3JlXG4gKi9cblxuZnVuY3Rpb24gX2V2YWx1YXRlUmVxdWlyZWRGdW5jdGlvbnMoZG9jKSB7XG4gIGNvbnN0IHJlcXVpcmVkRmllbGRzID0gT2JqZWN0LmtleXMoZG9jLiRfXy5hY3RpdmVQYXRocy5nZXRTdGF0ZVBhdGhzKCdyZXF1aXJlJykpO1xuICBsZXQgaSA9IDA7XG4gIGNvbnN0IGxlbiA9IHJlcXVpcmVkRmllbGRzLmxlbmd0aDtcbiAgZm9yIChpID0gMDsgaSA8IGxlbjsgKytpKSB7XG4gICAgY29uc3QgcGF0aCA9IHJlcXVpcmVkRmllbGRzW2ldO1xuXG4gICAgY29uc3QgcCA9IGRvYy4kX19zY2hlbWEucGF0aChwYXRoKTtcblxuICAgIGlmIChwICE9IG51bGwgJiYgdHlwZW9mIHAub3JpZ2luYWxSZXF1aXJlZFZhbHVlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBkb2MuJF9fLmNhY2hlZFJlcXVpcmVkID0gZG9jLiRfXy5jYWNoZWRSZXF1aXJlZCB8fCB7fTtcbiAgICAgIHRyeSB7XG4gICAgICAgIGRvYy4kX18uY2FjaGVkUmVxdWlyZWRbcGF0aF0gPSBwLm9yaWdpbmFsUmVxdWlyZWRWYWx1ZS5jYWxsKGRvYywgZG9jKTtcbiAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICBkb2MuaW52YWxpZGF0ZShwYXRoLCBlcnIpO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG4vKiFcbiAqIGlnbm9yZVxuICovXG5cbmZ1bmN0aW9uIF9nZXRQYXRoc1RvVmFsaWRhdGUoZG9jLCBwYXRoc1RvVmFsaWRhdGUsIHBhdGhzVG9Ta2lwKSB7XG4gIGNvbnN0IGRvVmFsaWRhdGVPcHRpb25zID0ge307XG5cbiAgX2V2YWx1YXRlUmVxdWlyZWRGdW5jdGlvbnMoZG9jKTtcbiAgLy8gb25seSB2YWxpZGF0ZSByZXF1aXJlZCBmaWVsZHMgd2hlbiBuZWNlc3NhcnlcbiAgbGV0IHBhdGhzID0gbmV3IFNldChPYmplY3Qua2V5cyhkb2MuJF9fLmFjdGl2ZVBhdGhzLmdldFN0YXRlUGF0aHMoJ3JlcXVpcmUnKSkuZmlsdGVyKGZ1bmN0aW9uKHBhdGgpIHtcbiAgICBpZiAoIWRvYy4kX19pc1NlbGVjdGVkKHBhdGgpICYmICFkb2MuJGlzTW9kaWZpZWQocGF0aCkpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgaWYgKGRvYy4kX18uY2FjaGVkUmVxdWlyZWQgIT0gbnVsbCAmJiBwYXRoIGluIGRvYy4kX18uY2FjaGVkUmVxdWlyZWQpIHtcbiAgICAgIHJldHVybiBkb2MuJF9fLmNhY2hlZFJlcXVpcmVkW3BhdGhdO1xuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfSkpO1xuXG4gIE9iamVjdC5rZXlzKGRvYy4kX18uYWN0aXZlUGF0aHMuZ2V0U3RhdGVQYXRocygnaW5pdCcpKS5mb3JFYWNoKGFkZFRvUGF0aHMpO1xuICBPYmplY3Qua2V5cyhkb2MuJF9fLmFjdGl2ZVBhdGhzLmdldFN0YXRlUGF0aHMoJ21vZGlmeScpKS5mb3JFYWNoKGFkZFRvUGF0aHMpO1xuICBPYmplY3Qua2V5cyhkb2MuJF9fLmFjdGl2ZVBhdGhzLmdldFN0YXRlUGF0aHMoJ2RlZmF1bHQnKSkuZm9yRWFjaChhZGRUb1BhdGhzKTtcbiAgZnVuY3Rpb24gYWRkVG9QYXRocyhwKSB7IHBhdGhzLmFkZChwKTsgfVxuXG4gIGNvbnN0IHN1YmRvY3MgPSBkb2MuJGdldEFsbFN1YmRvY3MoKTtcbiAgY29uc3QgbW9kaWZpZWRQYXRocyA9IGRvYy5tb2RpZmllZFBhdGhzKCk7XG4gIGZvciAoY29uc3Qgc3ViZG9jIG9mIHN1YmRvY3MpIHtcbiAgICBpZiAoc3ViZG9jLiRiYXNlUGF0aCkge1xuICAgICAgY29uc3QgZnVsbFBhdGhUb1N1YmRvYyA9IHN1YmRvYy4kaXNTaW5nbGVOZXN0ZWQgPyBzdWJkb2MuJF9fcGF0aFJlbGF0aXZlVG9QYXJlbnQoKSA6IHN1YmRvYy4kX19mdWxsUGF0aFdpdGhJbmRleGVzKCk7XG5cbiAgICAgIC8vIFJlbW92ZSBjaGlsZCBwYXRocyBmb3Igbm93LCBiZWNhdXNlIHdlJ2xsIGJlIHZhbGlkYXRpbmcgdGhlIHdob2xlXG4gICAgICAvLyBzdWJkb2MuXG4gICAgICAvLyBUaGUgZm9sbG93aW5nIGlzIGEgZmFzdGVyIHRha2Ugb24gbG9vcGluZyB0aHJvdWdoIGV2ZXJ5IHBhdGggaW4gYHBhdGhzYFxuICAgICAgLy8gYW5kIGNoZWNraW5nIGlmIHRoZSBwYXRoIHN0YXJ0cyB3aXRoIGBmdWxsUGF0aFRvU3ViZG9jYCByZTogZ2gtMTMxOTFcbiAgICAgIGZvciAoY29uc3QgbW9kaWZpZWRQYXRoIG9mIHN1YmRvYy5tb2RpZmllZFBhdGhzKCkpIHtcbiAgICAgICAgcGF0aHMuZGVsZXRlKGZ1bGxQYXRoVG9TdWJkb2MgKyAnLicgKyBtb2RpZmllZFBhdGgpO1xuICAgICAgfVxuXG4gICAgICBpZiAoZG9jLiRpc01vZGlmaWVkKGZ1bGxQYXRoVG9TdWJkb2MsIG1vZGlmaWVkUGF0aHMpICYmXG4gICAgICAgICAgICAhZG9jLmlzRGlyZWN0TW9kaWZpZWQoZnVsbFBhdGhUb1N1YmRvYykgJiZcbiAgICAgICAgICAgICFkb2MuJGlzRGVmYXVsdChmdWxsUGF0aFRvU3ViZG9jKSkge1xuICAgICAgICBwYXRocy5hZGQoZnVsbFBhdGhUb1N1YmRvYyk7XG4gICAgICAgIGlmIChkb2MuJF9fLnBhdGhzVG9TY29wZXMgPT0gbnVsbCkge1xuICAgICAgICAgIGRvYy4kX18ucGF0aHNUb1Njb3BlcyA9IHt9O1xuICAgICAgICB9XG4gICAgICAgIGRvYy4kX18ucGF0aHNUb1Njb3Blc1tmdWxsUGF0aFRvU3ViZG9jXSA9IHN1YmRvYy4kaXNEb2N1bWVudEFycmF5RWxlbWVudCA/XG4gICAgICAgICAgc3ViZG9jLl9fcGFyZW50QXJyYXkgOlxuICAgICAgICAgIHN1YmRvYy4kcGFyZW50KCk7XG5cbiAgICAgICAgZG9WYWxpZGF0ZU9wdGlvbnNbZnVsbFBhdGhUb1N1YmRvY10gPSB7IHNraXBTY2hlbWFWYWxpZGF0b3JzOiB0cnVlIH07XG4gICAgICAgIGlmIChzdWJkb2MuJGlzRG9jdW1lbnRBcnJheUVsZW1lbnQgJiYgc3ViZG9jLl9faW5kZXggIT0gbnVsbCkge1xuICAgICAgICAgIGRvVmFsaWRhdGVPcHRpb25zW2Z1bGxQYXRoVG9TdWJkb2NdLmluZGV4ID0gc3ViZG9jLl9faW5kZXg7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBmb3IgKGNvbnN0IHBhdGggb2YgcGF0aHMpIHtcbiAgICBjb25zdCBfcGF0aFR5cGUgPSBkb2MuJF9fc2NoZW1hLnBhdGgocGF0aCk7XG4gICAgaWYgKCFfcGF0aFR5cGUpIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIGlmIChfcGF0aFR5cGUuJGlzTW9uZ29vc2VEb2N1bWVudEFycmF5KSB7XG4gICAgICBmb3IgKGNvbnN0IHAgb2YgcGF0aHMpIHtcbiAgICAgICAgaWYgKHAgPT0gbnVsbCB8fCBwLnN0YXJ0c1dpdGgoX3BhdGhUeXBlLnBhdGggKyAnLicpKSB7XG4gICAgICAgICAgcGF0aHMuZGVsZXRlKHApO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gT3B0aW1pemF0aW9uOiBpZiBwcmltaXRpdmUgcGF0aCB3aXRoIG5vIHZhbGlkYXRvcnMsIG9yIGFycmF5IG9mIHByaW1pdGl2ZXNcbiAgICAvLyB3aXRoIG5vIHZhbGlkYXRvcnMsIHNraXAgdmFsaWRhdGluZyB0aGlzIHBhdGggZW50aXJlbHkuXG4gICAgaWYgKCFfcGF0aFR5cGUuY2FzdGVyICYmIF9wYXRoVHlwZS52YWxpZGF0b3JzLmxlbmd0aCA9PT0gMCAmJiAhX3BhdGhUeXBlLiRwYXJlbnRTY2hlbWFEb2NBcnJheSkge1xuICAgICAgcGF0aHMuZGVsZXRlKHBhdGgpO1xuICAgIH0gZWxzZSBpZiAoX3BhdGhUeXBlLiRpc01vbmdvb3NlQXJyYXkgJiZcbiAgICAgICFfcGF0aFR5cGUuJGlzTW9uZ29vc2VEb2N1bWVudEFycmF5ICYmIC8vIFNraXAgZG9jdW1lbnQgYXJyYXlzLi4uXG4gICAgICAhX3BhdGhUeXBlLiRlbWJlZGRlZFNjaGVtYVR5cGUuJGlzTW9uZ29vc2VBcnJheSAmJiAvLyBhbmQgYXJyYXlzIG9mIGFycmF5c1xuICAgICAgX3BhdGhUeXBlLnZhbGlkYXRvcnMubGVuZ3RoID09PSAwICYmIC8vIGFuZCBhcnJheXMgd2l0aCB0b3AtbGV2ZWwgdmFsaWRhdG9yc1xuICAgICAgX3BhdGhUeXBlLiRlbWJlZGRlZFNjaGVtYVR5cGUudmFsaWRhdG9ycy5sZW5ndGggPT09IDApIHtcbiAgICAgIHBhdGhzLmRlbGV0ZShwYXRoKTtcbiAgICB9XG4gIH1cblxuICBmb3IgKGNvbnN0IHBhdGggb2YgcGF0aHMpIHtcbiAgICAvLyBTaW5nbGUgbmVzdGVkIHBhdGhzIChwYXRocyBlbWJlZGRlZCB1bmRlciBzaW5nbGUgbmVzdGVkIHN1YmRvY3MpIHdpbGxcbiAgICAvLyBiZSB2YWxpZGF0ZWQgb24gdGhlaXIgb3duIHdoZW4gd2UgY2FsbCBgdmFsaWRhdGUoKWAgb24gdGhlIHN1YmRvYyBpdHNlbGYuXG4gICAgLy8gUmU6IGdoLTg0NjhcbiAgICBpZiAoZG9jLiRfX3NjaGVtYS5zaW5nbGVOZXN0ZWRQYXRocy5oYXNPd25Qcm9wZXJ0eShwYXRoKSkge1xuICAgICAgcGF0aHMuZGVsZXRlKHBhdGgpO1xuICAgICAgY29udGludWU7XG4gICAgfVxuICB9XG5cbiAgaWYgKEFycmF5LmlzQXJyYXkocGF0aHNUb1ZhbGlkYXRlKSkge1xuICAgIHBhdGhzID0gX2hhbmRsZVBhdGhzVG9WYWxpZGF0ZShwYXRocywgcGF0aHNUb1ZhbGlkYXRlKTtcbiAgfSBlbHNlIGlmIChBcnJheS5pc0FycmF5KHBhdGhzVG9Ta2lwKSkge1xuICAgIHBhdGhzID0gX2hhbmRsZVBhdGhzVG9Ta2lwKHBhdGhzLCBwYXRoc1RvU2tpcCk7XG4gIH1cblxuICAvLyBmcm9tIGhlcmUgb24gd2UncmUgbm90IHJlbW92aW5nIGl0ZW1zIGZyb20gcGF0aHNcblxuICAvLyBnaC02NjE6IGlmIGEgd2hvbGUgYXJyYXkgaXMgbW9kaWZpZWQsIG1ha2Ugc3VyZSB0byBydW4gdmFsaWRhdGlvbiBvbiBhbGxcbiAgLy8gdGhlIGNoaWxkcmVuIGFzIHdlbGxcbiAgZm9yIChjb25zdCBwYXRoIG9mIHBhdGhzKSB7XG4gICAgY29uc3QgX3BhdGhUeXBlID0gZG9jLiRfX3NjaGVtYS5wYXRoKHBhdGgpO1xuICAgIGlmICghX3BhdGhUeXBlKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICBpZiAoIV9wYXRoVHlwZS4kaXNNb25nb29zZUFycmF5IHx8XG4gICAgICAgIC8vIFRvIGF2b2lkIHBvdGVudGlhbCBwZXJmb3JtYW5jZSBpc3N1ZXMsIHNraXAgZG9jIGFycmF5cyB3aG9zZSBjaGlsZHJlblxuICAgICAgICAvLyBhcmUgbm90IHJlcXVpcmVkLiBgZ2V0UG9zaXRpb25hbFBhdGhUeXBlKClgIG1heSBiZSBzbG93LCBzbyBhdm9pZFxuICAgICAgICAvLyBpdCB1bmxlc3Mgd2UgaGF2ZSBhIGNhc2Ugb2YgIzYzNjRcbiAgICAgICAgKCFBcnJheS5pc0FycmF5KF9wYXRoVHlwZSkgJiZcbiAgICAgICAgICBfcGF0aFR5cGUuJGlzTW9uZ29vc2VEb2N1bWVudEFycmF5ICYmXG4gICAgICAgICAgIShfcGF0aFR5cGUgJiYgX3BhdGhUeXBlLnNjaGVtYU9wdGlvbnMgJiYgX3BhdGhUeXBlLnNjaGVtYU9wdGlvbnMucmVxdWlyZWQpKSkge1xuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgLy8gZ2gtMTEzODA6IG9wdGltaXphdGlvbi4gSWYgdGhlIGFycmF5IGlzbid0IGEgZG9jdW1lbnQgYXJyYXkgYW5kIHRoZXJlJ3Mgbm8gdmFsaWRhdG9yc1xuICAgIC8vIG9uIHRoZSBhcnJheSB0eXBlLCB0aGVyZSdzIG5vIG5lZWQgdG8gcnVuIHZhbGlkYXRpb24gb24gdGhlIGluZGl2aWR1YWwgYXJyYXkgZWxlbWVudHMuXG4gICAgaWYgKF9wYXRoVHlwZS4kaXNNb25nb29zZUFycmF5ICYmXG4gICAgICAgICFfcGF0aFR5cGUuJGlzTW9uZ29vc2VEb2N1bWVudEFycmF5ICYmIC8vIFNraXAgZG9jdW1lbnQgYXJyYXlzLi4uXG4gICAgICAgICFfcGF0aFR5cGUuJGVtYmVkZGVkU2NoZW1hVHlwZS4kaXNNb25nb29zZUFycmF5ICYmIC8vIGFuZCBhcnJheXMgb2YgYXJyYXlzXG4gICAgICAgIF9wYXRoVHlwZS4kZW1iZWRkZWRTY2hlbWFUeXBlLnZhbGlkYXRvcnMubGVuZ3RoID09PSAwKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICBjb25zdCB2YWwgPSBkb2MuJF9fZ2V0VmFsdWUocGF0aCk7XG4gICAgX3B1c2hOZXN0ZWRBcnJheVBhdGhzKHZhbCwgcGF0aHMsIHBhdGgpO1xuICB9XG5cbiAgZnVuY3Rpb24gX3B1c2hOZXN0ZWRBcnJheVBhdGhzKHZhbCwgcGF0aHMsIHBhdGgpIHtcbiAgICBpZiAodmFsICE9IG51bGwpIHtcbiAgICAgIGNvbnN0IG51bUVsZW1lbnRzID0gdmFsLmxlbmd0aDtcbiAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgbnVtRWxlbWVudHM7ICsraikge1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheSh2YWxbal0pKSB7XG4gICAgICAgICAgX3B1c2hOZXN0ZWRBcnJheVBhdGhzKHZhbFtqXSwgcGF0aHMsIHBhdGggKyAnLicgKyBqKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBwYXRocy5hZGQocGF0aCArICcuJyArIGopO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgY29uc3QgZmxhdHRlbk9wdGlvbnMgPSB7IHNraXBBcnJheXM6IHRydWUgfTtcbiAgZm9yIChjb25zdCBwYXRoVG9DaGVjayBvZiBwYXRocykge1xuICAgIGlmIChkb2MuJF9fc2NoZW1hLm5lc3RlZFtwYXRoVG9DaGVja10pIHtcbiAgICAgIGxldCBfdiA9IGRvYy4kX19nZXRWYWx1ZShwYXRoVG9DaGVjayk7XG4gICAgICBpZiAoaXNNb25nb29zZU9iamVjdChfdikpIHtcbiAgICAgICAgX3YgPSBfdi50b09iamVjdCh7IHRyYW5zZm9ybTogZmFsc2UgfSk7XG4gICAgICB9XG4gICAgICBjb25zdCBmbGF0ID0gZmxhdHRlbihfdiwgcGF0aFRvQ2hlY2ssIGZsYXR0ZW5PcHRpb25zLCBkb2MuJF9fc2NoZW1hKTtcbiAgICAgIE9iamVjdC5rZXlzKGZsYXQpLmZvckVhY2goYWRkVG9QYXRocyk7XG4gICAgfVxuICB9XG5cbiAgZm9yIChjb25zdCBwYXRoIG9mIHBhdGhzKSB7XG4gICAgY29uc3QgX3BhdGhUeXBlID0gZG9jLiRfX3NjaGVtYS5wYXRoKHBhdGgpO1xuXG4gICAgaWYgKCFfcGF0aFR5cGUpIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIC8vIElmIHVuZGVybmVhdGggYSBkb2N1bWVudCBhcnJheSwgbWF5IG5lZWQgdG8gcmUtdmFsaWRhdGUgdGhlIHBhcmVudFxuICAgIC8vIGFycmF5IHJlOiBnaC02ODE4LiBEbyB0aGlzIF9hZnRlcl8gYWRkaW5nIHN1YnBhdGhzLCBiZWNhdXNlXG4gICAgLy8gd2UgZG9uJ3Qgd2FudCB0byBhZGQgZXZlcnkgYXJyYXkgc3VicGF0aC5cbiAgICBpZiAoX3BhdGhUeXBlLiRwYXJlbnRTY2hlbWFEb2NBcnJheSAmJiB0eXBlb2YgX3BhdGhUeXBlLiRwYXJlbnRTY2hlbWFEb2NBcnJheS5wYXRoID09PSAnc3RyaW5nJykge1xuICAgICAgcGF0aHMuYWRkKF9wYXRoVHlwZS4kcGFyZW50U2NoZW1hRG9jQXJyYXkucGF0aCk7XG4gICAgfVxuXG4gICAgaWYgKCFfcGF0aFR5cGUuJGlzU2NoZW1hTWFwKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICBjb25zdCB2YWwgPSBkb2MuJF9fZ2V0VmFsdWUocGF0aCk7XG4gICAgaWYgKHZhbCA9PSBudWxsKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgZm9yIChjb25zdCBrZXkgb2YgdmFsLmtleXMoKSkge1xuICAgICAgcGF0aHMuYWRkKHBhdGggKyAnLicgKyBrZXkpO1xuICAgIH1cbiAgfVxuXG4gIHBhdGhzID0gQXJyYXkuZnJvbShwYXRocyk7XG4gIHJldHVybiBbcGF0aHMsIGRvVmFsaWRhdGVPcHRpb25zXTtcbn1cblxuLyohXG4gKiBpZ25vcmVcbiAqL1xuXG5Eb2N1bWVudC5wcm90b3R5cGUuJF9fdmFsaWRhdGUgPSBmdW5jdGlvbihwYXRoc1RvVmFsaWRhdGUsIG9wdGlvbnMsIGNhbGxiYWNrKSB7XG4gIGlmICh0eXBlb2YgcGF0aHNUb1ZhbGlkYXRlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgY2FsbGJhY2sgPSBwYXRoc1RvVmFsaWRhdGU7XG4gICAgb3B0aW9ucyA9IG51bGw7XG4gICAgcGF0aHNUb1ZhbGlkYXRlID0gbnVsbDtcbiAgfSBlbHNlIGlmICh0eXBlb2Ygb3B0aW9ucyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIGNhbGxiYWNrID0gb3B0aW9ucztcbiAgICBvcHRpb25zID0gbnVsbDtcbiAgfVxuXG4gIGNvbnN0IGhhc1ZhbGlkYXRlTW9kaWZpZWRPbmx5T3B0aW9uID0gb3B0aW9ucyAmJlxuICAgICAgKHR5cGVvZiBvcHRpb25zID09PSAnb2JqZWN0JykgJiZcbiAgICAgICgndmFsaWRhdGVNb2RpZmllZE9ubHknIGluIG9wdGlvbnMpO1xuXG4gIGNvbnN0IHBhdGhzVG9Ta2lwID0gKG9wdGlvbnMgJiYgb3B0aW9ucy5wYXRoc1RvU2tpcCkgfHwgbnVsbDtcblxuICBsZXQgc2hvdWxkVmFsaWRhdGVNb2RpZmllZE9ubHk7XG4gIGlmIChoYXNWYWxpZGF0ZU1vZGlmaWVkT25seU9wdGlvbikge1xuICAgIHNob3VsZFZhbGlkYXRlTW9kaWZpZWRPbmx5ID0gISFvcHRpb25zLnZhbGlkYXRlTW9kaWZpZWRPbmx5O1xuICB9IGVsc2Uge1xuICAgIHNob3VsZFZhbGlkYXRlTW9kaWZpZWRPbmx5ID0gdGhpcy4kX19zY2hlbWEub3B0aW9ucy52YWxpZGF0ZU1vZGlmaWVkT25seTtcbiAgfVxuXG4gIGNvbnN0IF90aGlzID0gdGhpcztcbiAgY29uc3QgX2NvbXBsZXRlID0gKCkgPT4ge1xuICAgIGxldCB2YWxpZGF0aW9uRXJyb3IgPSB0aGlzLiRfXy52YWxpZGF0aW9uRXJyb3I7XG4gICAgdGhpcy4kX18udmFsaWRhdGlvbkVycm9yID0gbnVsbDtcbiAgICB0aGlzLiRfXy52YWxpZGF0aW5nID0gbnVsbDtcblxuICAgIGlmIChzaG91bGRWYWxpZGF0ZU1vZGlmaWVkT25seSAmJiB2YWxpZGF0aW9uRXJyb3IgIT0gbnVsbCkge1xuICAgICAgLy8gUmVtb3ZlIGFueSB2YWxpZGF0aW9uIGVycm9ycyB0aGF0IGFyZW4ndCBmcm9tIG1vZGlmaWVkIHBhdGhzXG4gICAgICBjb25zdCBlcnJvcnMgPSBPYmplY3Qua2V5cyh2YWxpZGF0aW9uRXJyb3IuZXJyb3JzKTtcbiAgICAgIGZvciAoY29uc3QgZXJyUGF0aCBvZiBlcnJvcnMpIHtcbiAgICAgICAgaWYgKCF0aGlzLiRpc01vZGlmaWVkKGVyclBhdGgpKSB7XG4gICAgICAgICAgZGVsZXRlIHZhbGlkYXRpb25FcnJvci5lcnJvcnNbZXJyUGF0aF07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChPYmplY3Qua2V5cyh2YWxpZGF0aW9uRXJyb3IuZXJyb3JzKS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgdmFsaWRhdGlvbkVycm9yID0gdm9pZCAwO1xuICAgICAgfVxuICAgIH1cblxuICAgIHRoaXMuJF9fLmNhY2hlZFJlcXVpcmVkID0ge307XG4gICAgdGhpcy4kZW1pdCgndmFsaWRhdGUnLCBfdGhpcyk7XG4gICAgdGhpcy5jb25zdHJ1Y3Rvci5lbWl0KCd2YWxpZGF0ZScsIF90aGlzKTtcblxuICAgIGlmICh2YWxpZGF0aW9uRXJyb3IpIHtcbiAgICAgIGZvciAoY29uc3Qga2V5IGluIHZhbGlkYXRpb25FcnJvci5lcnJvcnMpIHtcbiAgICAgICAgLy8gTWFrZSBzdXJlIGNhc3QgZXJyb3JzIHBlcnNpc3RcbiAgICAgICAgaWYgKCF0aGlzW2RvY3VtZW50QXJyYXlQYXJlbnRdICYmXG4gICAgICAgICAgICB2YWxpZGF0aW9uRXJyb3IuZXJyb3JzW2tleV0gaW5zdGFuY2VvZiBNb25nb29zZUVycm9yLkNhc3RFcnJvcikge1xuICAgICAgICAgIHRoaXMuaW52YWxpZGF0ZShrZXksIHZhbGlkYXRpb25FcnJvci5lcnJvcnNba2V5XSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHZhbGlkYXRpb25FcnJvcjtcbiAgICB9XG4gIH07XG5cbiAgLy8gb25seSB2YWxpZGF0ZSByZXF1aXJlZCBmaWVsZHMgd2hlbiBuZWNlc3NhcnlcbiAgY29uc3QgcGF0aERldGFpbHMgPSBfZ2V0UGF0aHNUb1ZhbGlkYXRlKHRoaXMsIHBhdGhzVG9WYWxpZGF0ZSwgcGF0aHNUb1NraXApO1xuICBjb25zdCBwYXRocyA9IHNob3VsZFZhbGlkYXRlTW9kaWZpZWRPbmx5ID9cbiAgICBwYXRoRGV0YWlsc1swXS5maWx0ZXIoKHBhdGgpID0+IHRoaXMuJGlzTW9kaWZpZWQocGF0aCkpIDpcbiAgICBwYXRoRGV0YWlsc1swXTtcbiAgY29uc3QgZG9WYWxpZGF0ZU9wdGlvbnNCeVBhdGggPSBwYXRoRGV0YWlsc1sxXTtcbiAgaWYgKHR5cGVvZiBwYXRoc1RvVmFsaWRhdGUgPT09ICdzdHJpbmcnKSB7XG4gICAgcGF0aHNUb1ZhbGlkYXRlID0gcGF0aHNUb1ZhbGlkYXRlLnNwbGl0KCcgJyk7XG4gIH1cblxuICBpZiAocGF0aHMubGVuZ3RoID09PSAwKSB7XG4gICAgcmV0dXJuIGltbWVkaWF0ZShmdW5jdGlvbigpIHtcbiAgICAgIGNvbnN0IGVycm9yID0gX2NvbXBsZXRlKCk7XG4gICAgICBpZiAoZXJyb3IpIHtcbiAgICAgICAgcmV0dXJuIF90aGlzLiRfX3NjaGVtYS5zLmhvb2tzLmV4ZWNQb3N0KCd2YWxpZGF0ZTplcnJvcicsIF90aGlzLCBbX3RoaXNdLCB7IGVycm9yOiBlcnJvciB9LCBmdW5jdGlvbihlcnJvcikge1xuICAgICAgICAgIGNhbGxiYWNrKGVycm9yKTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICBjYWxsYmFjayhudWxsLCBfdGhpcyk7XG4gICAgfSk7XG4gIH1cblxuICBjb25zdCB2YWxpZGF0ZWQgPSB7fTtcbiAgbGV0IHRvdGFsID0gMDtcblxuICBmb3IgKGNvbnN0IHBhdGggb2YgcGF0aHMpIHtcbiAgICB2YWxpZGF0ZVBhdGgocGF0aCk7XG4gIH1cblxuICBmdW5jdGlvbiB2YWxpZGF0ZVBhdGgocGF0aCkge1xuICAgIGlmIChwYXRoID09IG51bGwgfHwgdmFsaWRhdGVkW3BhdGhdKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFsaWRhdGVkW3BhdGhdID0gdHJ1ZTtcbiAgICB0b3RhbCsrO1xuXG4gICAgaW1tZWRpYXRlKGZ1bmN0aW9uKCkge1xuICAgICAgY29uc3Qgc2NoZW1hVHlwZSA9IF90aGlzLiRfX3NjaGVtYS5wYXRoKHBhdGgpO1xuXG4gICAgICBpZiAoIXNjaGVtYVR5cGUpIHtcbiAgICAgICAgcmV0dXJuIC0tdG90YWwgfHwgY29tcGxldGUoKTtcbiAgICAgIH1cblxuICAgICAgLy8gSWYgdXNlciBtYXJrZWQgYXMgaW52YWxpZCBvciB0aGVyZSB3YXMgYSBjYXN0IGVycm9yLCBkb24ndCB2YWxpZGF0ZVxuICAgICAgaWYgKCFfdGhpcy4kaXNWYWxpZChwYXRoKSkge1xuICAgICAgICAtLXRvdGFsIHx8IGNvbXBsZXRlKCk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgLy8gSWYgc2V0dGluZyBhIHBhdGggdW5kZXIgYSBtaXhlZCBwYXRoLCBhdm9pZCB1c2luZyB0aGUgbWl4ZWQgcGF0aCB2YWxpZGF0b3IgKGdoLTEwMTQxKVxuICAgICAgaWYgKHNjaGVtYVR5cGVbc2NoZW1hTWl4ZWRTeW1ib2xdICE9IG51bGwgJiYgcGF0aCAhPT0gc2NoZW1hVHlwZS5wYXRoKSB7XG4gICAgICAgIHJldHVybiAtLXRvdGFsIHx8IGNvbXBsZXRlKCk7XG4gICAgICB9XG5cbiAgICAgIGxldCB2YWwgPSBfdGhpcy4kX19nZXRWYWx1ZShwYXRoKTtcblxuICAgICAgLy8gSWYgeW91IGBwb3B1bGF0ZSgpYCBhbmQgZ2V0IGJhY2sgYSBudWxsIHZhbHVlLCByZXF1aXJlZCB2YWxpZGF0b3JzXG4gICAgICAvLyBzaG91bGRuJ3QgZmFpbCAoZ2gtODAxOCkuIFdlIHNob3VsZCBhbHdheXMgZmFsbCBiYWNrIHRvIHRoZSBwb3B1bGF0ZWRcbiAgICAgIC8vIHZhbHVlLlxuICAgICAgbGV0IHBvcDtcbiAgICAgIGlmICgocG9wID0gX3RoaXMuJHBvcHVsYXRlZChwYXRoKSkpIHtcbiAgICAgICAgdmFsID0gcG9wO1xuICAgICAgfSBlbHNlIGlmICh2YWwgIT0gbnVsbCAmJiB2YWwuJF9fICE9IG51bGwgJiYgdmFsLiRfXy53YXNQb3B1bGF0ZWQpIHtcbiAgICAgICAgLy8gQXJyYXkgcGF0aHMsIGxpa2UgYHNvbWVhcnJheS4xYCwgZG8gbm90IHNob3cgdXAgYXMgcG9wdWxhdGVkIHdpdGggYCRwb3B1bGF0ZWQoKWAsXG4gICAgICAgIC8vIHNvIGluIHRoYXQgY2FzZSBwdWxsIG91dCB0aGUgZG9jdW1lbnQncyBpZFxuICAgICAgICB2YWwgPSB2YWwuX2lkO1xuICAgICAgfVxuICAgICAgY29uc3Qgc2NvcGUgPSBfdGhpcy4kX18ucGF0aHNUb1Njb3BlcyAhPSBudWxsICYmIHBhdGggaW4gX3RoaXMuJF9fLnBhdGhzVG9TY29wZXMgP1xuICAgICAgICBfdGhpcy4kX18ucGF0aHNUb1Njb3Blc1twYXRoXSA6XG4gICAgICAgIF90aGlzO1xuXG4gICAgICBjb25zdCBkb1ZhbGlkYXRlT3B0aW9ucyA9IHtcbiAgICAgICAgLi4uZG9WYWxpZGF0ZU9wdGlvbnNCeVBhdGhbcGF0aF0sXG4gICAgICAgIHBhdGg6IHBhdGgsXG4gICAgICAgIHZhbGlkYXRlTW9kaWZpZWRPbmx5OiBzaG91bGRWYWxpZGF0ZU1vZGlmaWVkT25seVxuICAgICAgfTtcblxuICAgICAgc2NoZW1hVHlwZS5kb1ZhbGlkYXRlKHZhbCwgZnVuY3Rpb24oZXJyKSB7XG4gICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICBjb25zdCBpc1N1YmRvYyA9IHNjaGVtYVR5cGUuJGlzU2luZ2xlTmVzdGVkIHx8XG4gICAgICAgICAgICAgIHNjaGVtYVR5cGUuJGlzQXJyYXlTdWJkb2N1bWVudCB8fFxuICAgICAgICAgICAgICBzY2hlbWFUeXBlLiRpc01vbmdvb3NlRG9jdW1lbnRBcnJheTtcbiAgICAgICAgICBpZiAoaXNTdWJkb2MgJiYgZXJyIGluc3RhbmNlb2YgVmFsaWRhdGlvbkVycm9yKSB7XG4gICAgICAgICAgICByZXR1cm4gLS10b3RhbCB8fCBjb21wbGV0ZSgpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBfdGhpcy5pbnZhbGlkYXRlKHBhdGgsIGVyciwgdW5kZWZpbmVkLCB0cnVlKTtcbiAgICAgICAgfVxuICAgICAgICAtLXRvdGFsIHx8IGNvbXBsZXRlKCk7XG4gICAgICB9LCBzY29wZSwgZG9WYWxpZGF0ZU9wdGlvbnMpO1xuICAgIH0pO1xuICB9XG5cbiAgZnVuY3Rpb24gY29tcGxldGUoKSB7XG4gICAgY29uc3QgZXJyb3IgPSBfY29tcGxldGUoKTtcbiAgICBpZiAoZXJyb3IpIHtcbiAgICAgIHJldHVybiBfdGhpcy4kX19zY2hlbWEucy5ob29rcy5leGVjUG9zdCgndmFsaWRhdGU6ZXJyb3InLCBfdGhpcywgW190aGlzXSwgeyBlcnJvcjogZXJyb3IgfSwgZnVuY3Rpb24oZXJyb3IpIHtcbiAgICAgICAgY2FsbGJhY2soZXJyb3IpO1xuICAgICAgfSk7XG4gICAgfVxuICAgIGNhbGxiYWNrKG51bGwsIF90aGlzKTtcbiAgfVxuXG59O1xuXG4vKiFcbiAqIGlnbm9yZVxuICovXG5cbmZ1bmN0aW9uIF9oYW5kbGVQYXRoc1RvVmFsaWRhdGUocGF0aHMsIHBhdGhzVG9WYWxpZGF0ZSkge1xuICBjb25zdCBfcGF0aHNUb1ZhbGlkYXRlID0gbmV3IFNldChwYXRoc1RvVmFsaWRhdGUpO1xuICBjb25zdCBwYXJlbnRQYXRocyA9IG5ldyBNYXAoW10pO1xuICBmb3IgKGNvbnN0IHBhdGggb2YgcGF0aHNUb1ZhbGlkYXRlKSB7XG4gICAgaWYgKHBhdGguaW5kZXhPZignLicpID09PSAtMSkge1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIGNvbnN0IHBpZWNlcyA9IHBhdGguc3BsaXQoJy4nKTtcbiAgICBsZXQgY3VyID0gcGllY2VzWzBdO1xuICAgIGZvciAobGV0IGkgPSAxOyBpIDwgcGllY2VzLmxlbmd0aDsgKytpKSB7XG4gICAgICAvLyBTaW5jZSB3ZSBza2lwIHN1YnBhdGhzIHVuZGVyIHNpbmdsZSBuZXN0ZWQgc3ViZG9jcyB0b1xuICAgICAgLy8gYXZvaWQgZG91YmxlIHZhbGlkYXRpb24sIHdlIG5lZWQgdG8gYWRkIGJhY2sgdGhlXG4gICAgICAvLyBzaW5nbGUgbmVzdGVkIHN1YnBhdGggaWYgdGhlIHVzZXIgYXNrZWQgZm9yIGl0IChnaC04NjI2KVxuICAgICAgcGFyZW50UGF0aHMuc2V0KGN1ciwgcGF0aCk7XG4gICAgICBjdXIgPSBjdXIgKyAnLicgKyBwaWVjZXNbaV07XG4gICAgfVxuICB9XG5cbiAgY29uc3QgcmV0ID0gbmV3IFNldCgpO1xuICBmb3IgKGNvbnN0IHBhdGggb2YgcGF0aHMpIHtcbiAgICBpZiAoX3BhdGhzVG9WYWxpZGF0ZS5oYXMocGF0aCkpIHtcbiAgICAgIHJldC5hZGQocGF0aCk7XG4gICAgfSBlbHNlIGlmIChwYXJlbnRQYXRocy5oYXMocGF0aCkpIHtcbiAgICAgIHJldC5hZGQocGFyZW50UGF0aHMuZ2V0KHBhdGgpKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJldDtcbn1cblxuLyohXG4gKiBpZ25vcmVcbiAqL1xuXG5mdW5jdGlvbiBfaGFuZGxlUGF0aHNUb1NraXAocGF0aHMsIHBhdGhzVG9Ta2lwKSB7XG4gIHBhdGhzVG9Ta2lwID0gbmV3IFNldChwYXRoc1RvU2tpcCk7XG4gIHBhdGhzID0gQXJyYXkuZnJvbShwYXRocykuZmlsdGVyKHAgPT4gIXBhdGhzVG9Ta2lwLmhhcyhwKSk7XG4gIHJldHVybiBuZXcgU2V0KHBhdGhzKTtcbn1cblxuLyoqXG4gKiBFeGVjdXRlcyByZWdpc3RlcmVkIHZhbGlkYXRpb24gcnVsZXMgKHNraXBwaW5nIGFzeW5jaHJvbm91cyB2YWxpZGF0b3JzKSBmb3IgdGhpcyBkb2N1bWVudC5cbiAqXG4gKiAjIyMjIE5vdGU6XG4gKlxuICogVGhpcyBtZXRob2QgaXMgdXNlZnVsIGlmIHlvdSBuZWVkIHN5bmNocm9ub3VzIHZhbGlkYXRpb24uXG4gKlxuICogIyMjIyBFeGFtcGxlOlxuICpcbiAqICAgICBjb25zdCBlcnIgPSBkb2MudmFsaWRhdGVTeW5jKCk7XG4gKiAgICAgaWYgKGVycikge1xuICogICAgICAgaGFuZGxlRXJyb3IoZXJyKTtcbiAqICAgICB9IGVsc2Uge1xuICogICAgICAgLy8gdmFsaWRhdGlvbiBwYXNzZWRcbiAqICAgICB9XG4gKlxuICogQHBhcmFtIHtBcnJheXxzdHJpbmd9IFtwYXRoc1RvVmFsaWRhdGVdIG9ubHkgdmFsaWRhdGUgdGhlIGdpdmVuIHBhdGhzXG4gKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdIG9wdGlvbnMgZm9yIHZhbGlkYXRpb25cbiAqIEBwYXJhbSB7Qm9vbGVhbn0gW29wdGlvbnMudmFsaWRhdGVNb2RpZmllZE9ubHk9ZmFsc2VdIElmIGB0cnVlYCwgTW9uZ29vc2Ugd2lsbCBvbmx5IHZhbGlkYXRlIG1vZGlmaWVkIHBhdGhzLCBhcyBvcHBvc2VkIHRvIG1vZGlmaWVkIHBhdGhzIGFuZCBgcmVxdWlyZWRgIHBhdGhzLlxuICogQHBhcmFtIHtBcnJheXxzdHJpbmd9IFtvcHRpb25zLnBhdGhzVG9Ta2lwXSBsaXN0IG9mIHBhdGhzIHRvIHNraXAuIElmIHNldCwgTW9uZ29vc2Ugd2lsbCB2YWxpZGF0ZSBldmVyeSBtb2RpZmllZCBwYXRoIHRoYXQgaXMgbm90IGluIHRoaXMgbGlzdC5cbiAqIEByZXR1cm4ge1ZhbGlkYXRpb25FcnJvcnx1bmRlZmluZWR9IFZhbGlkYXRpb25FcnJvciBpZiB0aGVyZSBhcmUgZXJyb3JzIGR1cmluZyB2YWxpZGF0aW9uLCBvciB1bmRlZmluZWQgaWYgdGhlcmUgaXMgbm8gZXJyb3IuXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbkRvY3VtZW50LnByb3RvdHlwZS52YWxpZGF0ZVN5bmMgPSBmdW5jdGlvbihwYXRoc1RvVmFsaWRhdGUsIG9wdGlvbnMpIHtcbiAgY29uc3QgX3RoaXMgPSB0aGlzO1xuXG4gIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAxICYmIHR5cGVvZiBhcmd1bWVudHNbMF0gPT09ICdvYmplY3QnICYmICFBcnJheS5pc0FycmF5KGFyZ3VtZW50c1swXSkpIHtcbiAgICBvcHRpb25zID0gYXJndW1lbnRzWzBdO1xuICAgIHBhdGhzVG9WYWxpZGF0ZSA9IG51bGw7XG4gIH1cblxuICBjb25zdCBoYXNWYWxpZGF0ZU1vZGlmaWVkT25seU9wdGlvbiA9IG9wdGlvbnMgJiZcbiAgICAgICh0eXBlb2Ygb3B0aW9ucyA9PT0gJ29iamVjdCcpICYmXG4gICAgICAoJ3ZhbGlkYXRlTW9kaWZpZWRPbmx5JyBpbiBvcHRpb25zKTtcblxuICBsZXQgc2hvdWxkVmFsaWRhdGVNb2RpZmllZE9ubHk7XG4gIGlmIChoYXNWYWxpZGF0ZU1vZGlmaWVkT25seU9wdGlvbikge1xuICAgIHNob3VsZFZhbGlkYXRlTW9kaWZpZWRPbmx5ID0gISFvcHRpb25zLnZhbGlkYXRlTW9kaWZpZWRPbmx5O1xuICB9IGVsc2Uge1xuICAgIHNob3VsZFZhbGlkYXRlTW9kaWZpZWRPbmx5ID0gdGhpcy4kX19zY2hlbWEub3B0aW9ucy52YWxpZGF0ZU1vZGlmaWVkT25seTtcbiAgfVxuXG4gIGxldCBwYXRoc1RvU2tpcCA9IG9wdGlvbnMgJiYgb3B0aW9ucy5wYXRoc1RvU2tpcDtcblxuICBpZiAodHlwZW9mIHBhdGhzVG9WYWxpZGF0ZSA9PT0gJ3N0cmluZycpIHtcbiAgICBjb25zdCBpc09uZVBhdGhPbmx5ID0gcGF0aHNUb1ZhbGlkYXRlLmluZGV4T2YoJyAnKSA9PT0gLTE7XG4gICAgcGF0aHNUb1ZhbGlkYXRlID0gaXNPbmVQYXRoT25seSA/IFtwYXRoc1RvVmFsaWRhdGVdIDogcGF0aHNUb1ZhbGlkYXRlLnNwbGl0KCcgJyk7XG4gIH0gZWxzZSBpZiAodHlwZW9mIHBhdGhzVG9Ta2lwID09PSAnc3RyaW5nJyAmJiBwYXRoc1RvU2tpcC5pbmRleE9mKCcgJykgIT09IC0xKSB7XG4gICAgcGF0aHNUb1NraXAgPSBwYXRoc1RvU2tpcC5zcGxpdCgnICcpO1xuICB9XG5cbiAgLy8gb25seSB2YWxpZGF0ZSByZXF1aXJlZCBmaWVsZHMgd2hlbiBuZWNlc3NhcnlcbiAgY29uc3QgcGF0aERldGFpbHMgPSBfZ2V0UGF0aHNUb1ZhbGlkYXRlKHRoaXMsIHBhdGhzVG9WYWxpZGF0ZSwgcGF0aHNUb1NraXApO1xuICBjb25zdCBwYXRocyA9IHNob3VsZFZhbGlkYXRlTW9kaWZpZWRPbmx5ID9cbiAgICBwYXRoRGV0YWlsc1swXS5maWx0ZXIoKHBhdGgpID0+IHRoaXMuJGlzTW9kaWZpZWQocGF0aCkpIDpcbiAgICBwYXRoRGV0YWlsc1swXTtcbiAgY29uc3Qgc2tpcFNjaGVtYVZhbGlkYXRvcnMgPSBwYXRoRGV0YWlsc1sxXTtcblxuICBjb25zdCB2YWxpZGF0aW5nID0ge307XG5cbiAgZm9yIChsZXQgaSA9IDAsIGxlbiA9IHBhdGhzLmxlbmd0aDsgaSA8IGxlbjsgKytpKSB7XG4gICAgY29uc3QgcGF0aCA9IHBhdGhzW2ldO1xuXG4gICAgaWYgKHZhbGlkYXRpbmdbcGF0aF0pIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIHZhbGlkYXRpbmdbcGF0aF0gPSB0cnVlO1xuXG4gICAgY29uc3QgcCA9IF90aGlzLiRfX3NjaGVtYS5wYXRoKHBhdGgpO1xuICAgIGlmICghcCkge1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIGlmICghX3RoaXMuJGlzVmFsaWQocGF0aCkpIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIGNvbnN0IHZhbCA9IF90aGlzLiRfX2dldFZhbHVlKHBhdGgpO1xuICAgIGNvbnN0IGVyciA9IHAuZG9WYWxpZGF0ZVN5bmModmFsLCBfdGhpcywge1xuICAgICAgc2tpcFNjaGVtYVZhbGlkYXRvcnM6IHNraXBTY2hlbWFWYWxpZGF0b3JzW3BhdGhdLFxuICAgICAgcGF0aDogcGF0aCxcbiAgICAgIHZhbGlkYXRlTW9kaWZpZWRPbmx5OiBzaG91bGRWYWxpZGF0ZU1vZGlmaWVkT25seVxuICAgIH0pO1xuICAgIGlmIChlcnIpIHtcbiAgICAgIGNvbnN0IGlzU3ViZG9jID0gcC4kaXNTaW5nbGVOZXN0ZWQgfHxcbiAgICAgICAgcC4kaXNBcnJheVN1YmRvY3VtZW50IHx8XG4gICAgICAgIHAuJGlzTW9uZ29vc2VEb2N1bWVudEFycmF5O1xuICAgICAgaWYgKGlzU3ViZG9jICYmIGVyciBpbnN0YW5jZW9mIFZhbGlkYXRpb25FcnJvcikge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIF90aGlzLmludmFsaWRhdGUocGF0aCwgZXJyLCB1bmRlZmluZWQsIHRydWUpO1xuICAgIH1cbiAgfVxuXG4gIGNvbnN0IGVyciA9IF90aGlzLiRfXy52YWxpZGF0aW9uRXJyb3I7XG4gIF90aGlzLiRfXy52YWxpZGF0aW9uRXJyb3IgPSB1bmRlZmluZWQ7XG4gIF90aGlzLiRlbWl0KCd2YWxpZGF0ZScsIF90aGlzKTtcbiAgX3RoaXMuY29uc3RydWN0b3IuZW1pdCgndmFsaWRhdGUnLCBfdGhpcyk7XG5cbiAgaWYgKGVycikge1xuICAgIGZvciAoY29uc3Qga2V5IGluIGVyci5lcnJvcnMpIHtcbiAgICAgIC8vIE1ha2Ugc3VyZSBjYXN0IGVycm9ycyBwZXJzaXN0XG4gICAgICBpZiAoZXJyLmVycm9yc1trZXldIGluc3RhbmNlb2YgTW9uZ29vc2VFcnJvci5DYXN0RXJyb3IpIHtcbiAgICAgICAgX3RoaXMuaW52YWxpZGF0ZShrZXksIGVyci5lcnJvcnNba2V5XSk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGVycjtcbn07XG5cbi8qKlxuICogTWFya3MgYSBwYXRoIGFzIGludmFsaWQsIGNhdXNpbmcgdmFsaWRhdGlvbiB0byBmYWlsLlxuICpcbiAqIFRoZSBgZXJyb3JNc2dgIGFyZ3VtZW50IHdpbGwgYmVjb21lIHRoZSBtZXNzYWdlIG9mIHRoZSBgVmFsaWRhdGlvbkVycm9yYC5cbiAqXG4gKiBUaGUgYHZhbHVlYCBhcmd1bWVudCAoaWYgcGFzc2VkKSB3aWxsIGJlIGF2YWlsYWJsZSB0aHJvdWdoIHRoZSBgVmFsaWRhdGlvbkVycm9yLnZhbHVlYCBwcm9wZXJ0eS5cbiAqXG4gKiAgICAgZG9jLmludmFsaWRhdGUoJ3NpemUnLCAnbXVzdCBiZSBsZXNzIHRoYW4gMjAnLCAxNCk7XG4gKlxuICogICAgIGRvYy52YWxpZGF0ZShmdW5jdGlvbiAoZXJyKSB7XG4gKiAgICAgICBjb25zb2xlLmxvZyhlcnIpXG4gKiAgICAgICAvLyBwcmludHNcbiAqICAgICAgIHsgbWVzc2FnZTogJ1ZhbGlkYXRpb24gZmFpbGVkJyxcbiAqICAgICAgICAgbmFtZTogJ1ZhbGlkYXRpb25FcnJvcicsXG4gKiAgICAgICAgIGVycm9yczpcbiAqICAgICAgICAgIHsgc2l6ZTpcbiAqICAgICAgICAgICAgIHsgbWVzc2FnZTogJ211c3QgYmUgbGVzcyB0aGFuIDIwJyxcbiAqICAgICAgICAgICAgICAgbmFtZTogJ1ZhbGlkYXRvckVycm9yJyxcbiAqICAgICAgICAgICAgICAgcGF0aDogJ3NpemUnLFxuICogICAgICAgICAgICAgICB0eXBlOiAndXNlciBkZWZpbmVkJyxcbiAqICAgICAgICAgICAgICAgdmFsdWU6IDE0IH0gfSB9XG4gKiAgICAgfSlcbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gcGF0aCB0aGUgZmllbGQgdG8gaW52YWxpZGF0ZS4gRm9yIGFycmF5IGVsZW1lbnRzLCB1c2UgdGhlIGBhcnJheS5pLmZpZWxkYCBzeW50YXgsIHdoZXJlIGBpYCBpcyB0aGUgMC1iYXNlZCBpbmRleCBpbiB0aGUgYXJyYXkuXG4gKiBAcGFyYW0ge1N0cmluZ3xFcnJvcn0gZXJyIHRoZSBlcnJvciB3aGljaCBzdGF0ZXMgdGhlIHJlYXNvbiBgcGF0aGAgd2FzIGludmFsaWRcbiAqIEBwYXJhbSB7T2JqZWN0fFN0cmluZ3xOdW1iZXJ8YW55fSB2YWwgb3B0aW9uYWwgaW52YWxpZCB2YWx1ZVxuICogQHBhcmFtIHtTdHJpbmd9IFtraW5kXSBvcHRpb25hbCBga2luZGAgcHJvcGVydHkgZm9yIHRoZSBlcnJvclxuICogQHJldHVybiB7VmFsaWRhdGlvbkVycm9yfSB0aGUgY3VycmVudCBWYWxpZGF0aW9uRXJyb3IsIHdpdGggYWxsIGN1cnJlbnRseSBpbnZhbGlkYXRlZCBwYXRoc1xuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5Eb2N1bWVudC5wcm90b3R5cGUuaW52YWxpZGF0ZSA9IGZ1bmN0aW9uKHBhdGgsIGVyciwgdmFsLCBraW5kKSB7XG4gIGlmICghdGhpcy4kX18udmFsaWRhdGlvbkVycm9yKSB7XG4gICAgdGhpcy4kX18udmFsaWRhdGlvbkVycm9yID0gbmV3IFZhbGlkYXRpb25FcnJvcih0aGlzKTtcbiAgfVxuXG4gIGlmICh0aGlzLiRfXy52YWxpZGF0aW9uRXJyb3IuZXJyb3JzW3BhdGhdKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgaWYgKCFlcnIgfHwgdHlwZW9mIGVyciA9PT0gJ3N0cmluZycpIHtcbiAgICBlcnIgPSBuZXcgVmFsaWRhdG9yRXJyb3Ioe1xuICAgICAgcGF0aDogcGF0aCxcbiAgICAgIG1lc3NhZ2U6IGVycixcbiAgICAgIHR5cGU6IGtpbmQgfHwgJ3VzZXIgZGVmaW5lZCcsXG4gICAgICB2YWx1ZTogdmFsXG4gICAgfSk7XG4gIH1cblxuICBpZiAodGhpcy4kX18udmFsaWRhdGlvbkVycm9yID09PSBlcnIpIHtcbiAgICByZXR1cm4gdGhpcy4kX18udmFsaWRhdGlvbkVycm9yO1xuICB9XG5cbiAgdGhpcy4kX18udmFsaWRhdGlvbkVycm9yLmFkZEVycm9yKHBhdGgsIGVycik7XG4gIHJldHVybiB0aGlzLiRfXy52YWxpZGF0aW9uRXJyb3I7XG59O1xuXG4vKipcbiAqIE1hcmtzIGEgcGF0aCBhcyB2YWxpZCwgcmVtb3ZpbmcgZXhpc3RpbmcgdmFsaWRhdGlvbiBlcnJvcnMuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IHBhdGggdGhlIGZpZWxkIHRvIG1hcmsgYXMgdmFsaWRcbiAqIEBhcGkgcHVibGljXG4gKiBAbWVtYmVyT2YgRG9jdW1lbnRcbiAqIEBpbnN0YW5jZVxuICogQG1ldGhvZCAkbWFya1ZhbGlkXG4gKi9cblxuRG9jdW1lbnQucHJvdG90eXBlLiRtYXJrVmFsaWQgPSBmdW5jdGlvbihwYXRoKSB7XG4gIGlmICghdGhpcy4kX18udmFsaWRhdGlvbkVycm9yIHx8ICF0aGlzLiRfXy52YWxpZGF0aW9uRXJyb3IuZXJyb3JzW3BhdGhdKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgZGVsZXRlIHRoaXMuJF9fLnZhbGlkYXRpb25FcnJvci5lcnJvcnNbcGF0aF07XG4gIGlmIChPYmplY3Qua2V5cyh0aGlzLiRfXy52YWxpZGF0aW9uRXJyb3IuZXJyb3JzKS5sZW5ndGggPT09IDApIHtcbiAgICB0aGlzLiRfXy52YWxpZGF0aW9uRXJyb3IgPSBudWxsO1xuICB9XG59O1xuXG4vKiFcbiAqIGlnbm9yZVxuICovXG5cbmZ1bmN0aW9uIF9tYXJrVmFsaWRTdWJwYXRocyhkb2MsIHBhdGgpIHtcbiAgaWYgKCFkb2MuJF9fLnZhbGlkYXRpb25FcnJvcikge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIGNvbnN0IGtleXMgPSBPYmplY3Qua2V5cyhkb2MuJF9fLnZhbGlkYXRpb25FcnJvci5lcnJvcnMpO1xuICBmb3IgKGNvbnN0IGtleSBvZiBrZXlzKSB7XG4gICAgaWYgKGtleS5zdGFydHNXaXRoKHBhdGggKyAnLicpKSB7XG4gICAgICBkZWxldGUgZG9jLiRfXy52YWxpZGF0aW9uRXJyb3IuZXJyb3JzW2tleV07XG4gICAgfVxuICB9XG4gIGlmIChPYmplY3Qua2V5cyhkb2MuJF9fLnZhbGlkYXRpb25FcnJvci5lcnJvcnMpLmxlbmd0aCA9PT0gMCkge1xuICAgIGRvYy4kX18udmFsaWRhdGlvbkVycm9yID0gbnVsbDtcbiAgfVxufVxuXG4vKiFcbiAqIGlnbm9yZVxuICovXG5cbmZ1bmN0aW9uIF9jaGVja0ltbXV0YWJsZVN1YnBhdGhzKHN1YmRvYywgc2NoZW1hdHlwZSwgcHJpb3JWYWwpIHtcbiAgY29uc3Qgc2NoZW1hID0gc2NoZW1hdHlwZS5zY2hlbWE7XG4gIGlmIChzY2hlbWEgPT0gbnVsbCkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIGZvciAoY29uc3Qga2V5IG9mIE9iamVjdC5rZXlzKHNjaGVtYS5wYXRocykpIHtcbiAgICBjb25zdCBwYXRoID0gc2NoZW1hLnBhdGhzW2tleV07XG4gICAgaWYgKHBhdGguJGltbXV0YWJsZVNldHRlciA9PSBudWxsKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgY29uc3Qgb2xkVmFsID0gcHJpb3JWYWwgPT0gbnVsbCA/IHZvaWQgMCA6IHByaW9yVmFsLiRfX2dldFZhbHVlKGtleSk7XG4gICAgLy8gQ2FsbGluZyBpbW11dGFibGVTZXR0ZXIgd2l0aCBgb2xkVmFsYCBldmVuIHRob3VnaCBpdCBleHBlY3RzIGBuZXdWYWxgXG4gICAgLy8gaXMgaW50ZW50aW9uYWwuIFRoYXQncyBiZWNhdXNlIGAkaW1tdXRhYmxlU2V0dGVyYCBjb21wYXJlcyBpdHMgcGFyYW1cbiAgICAvLyB0byB0aGUgY3VycmVudCB2YWx1ZS5cbiAgICBwYXRoLiRpbW11dGFibGVTZXR0ZXIuY2FsbChzdWJkb2MsIG9sZFZhbCk7XG4gIH1cbn1cblxuLyoqXG4gKiBTYXZlcyB0aGlzIGRvY3VtZW50IGJ5IGluc2VydGluZyBhIG5ldyBkb2N1bWVudCBpbnRvIHRoZSBkYXRhYmFzZSBpZiBbZG9jdW1lbnQuaXNOZXddKGh0dHBzOi8vbW9uZ29vc2Vqcy5jb20vZG9jcy9hcGkvZG9jdW1lbnQuaHRtbCNEb2N1bWVudC5wcm90b3R5cGUuaXNOZXcoKSkgaXMgYHRydWVgLFxuICogb3Igc2VuZHMgYW4gW3VwZGF0ZU9uZV0oaHR0cHM6Ly9tb25nb29zZWpzLmNvbS9kb2NzL2FwaS9kb2N1bWVudC5odG1sI0RvY3VtZW50LnByb3RvdHlwZS51cGRhdGVPbmUoKSkgb3BlcmF0aW9uICoqb25seSoqIHdpdGggdGhlIG1vZGlmaWNhdGlvbnMgdG8gdGhlIGRhdGFiYXNlLCBpdCBkb2VzIG5vdCByZXBsYWNlIHRoZSB3aG9sZSBkb2N1bWVudCBpbiB0aGUgbGF0dGVyIGNhc2UuXG4gKlxuICogIyMjIyBFeGFtcGxlOlxuICpcbiAqICAgICBwcm9kdWN0LnNvbGQgPSBEYXRlLm5vdygpO1xuICogICAgIHByb2R1Y3QgPSBhd2FpdCBwcm9kdWN0LnNhdmUoKTtcbiAqXG4gKiBJZiBzYXZlIGlzIHN1Y2Nlc3NmdWwsIHRoZSByZXR1cm5lZCBwcm9taXNlIHdpbGwgZnVsZmlsbCB3aXRoIHRoZSBkb2N1bWVudFxuICogc2F2ZWQuXG4gKlxuICogIyMjIyBFeGFtcGxlOlxuICpcbiAqICAgICBjb25zdCBuZXdQcm9kdWN0ID0gYXdhaXQgcHJvZHVjdC5zYXZlKCk7XG4gKiAgICAgbmV3UHJvZHVjdCA9PT0gcHJvZHVjdDsgLy8gdHJ1ZVxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gb3B0aW9ucyBvcHRpb25hbCBvcHRpb25zXG4gKiBAcGFyYW0ge1Nlc3Npb259IFtvcHRpb25zLnNlc3Npb249bnVsbF0gdGhlIFtzZXNzaW9uXShodHRwczovL3d3dy5tb25nb2RiLmNvbS9kb2NzL21hbnVhbC9yZWZlcmVuY2Uvc2VydmVyLXNlc3Npb25zLykgYXNzb2NpYXRlZCB3aXRoIHRoaXMgc2F2ZSBvcGVyYXRpb24uIElmIG5vdCBzcGVjaWZpZWQsIGRlZmF1bHRzIHRvIHRoZSBbZG9jdW1lbnQncyBhc3NvY2lhdGVkIHNlc3Npb25dKGh0dHBzOi8vbW9uZ29vc2Vqcy5jb20vZG9jcy9hcGkvZG9jdW1lbnQuaHRtbCNEb2N1bWVudC5wcm90b3R5cGUuJHNlc3Npb24oKSkuXG4gKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnMuc2FmZV0gKERFUFJFQ0FURUQpIG92ZXJyaWRlcyBbc2NoZW1hJ3Mgc2FmZSBvcHRpb25dKGh0dHBzOi8vbW9uZ29vc2Vqcy5jb20vZG9jcy9ndWlkZS5odG1sI3NhZmUpLiBVc2UgdGhlIGB3YCBvcHRpb24gaW5zdGVhZC5cbiAqIEBwYXJhbSB7Qm9vbGVhbn0gW29wdGlvbnMudmFsaWRhdGVCZWZvcmVTYXZlXSBzZXQgdG8gZmFsc2UgdG8gc2F2ZSB3aXRob3V0IHZhbGlkYXRpbmcuXG4gKiBAcGFyYW0ge0Jvb2xlYW59IFtvcHRpb25zLnZhbGlkYXRlTW9kaWZpZWRPbmx5PWZhbHNlXSBJZiBgdHJ1ZWAsIE1vbmdvb3NlIHdpbGwgb25seSB2YWxpZGF0ZSBtb2RpZmllZCBwYXRocywgYXMgb3Bwb3NlZCB0byBtb2RpZmllZCBwYXRocyBhbmQgYHJlcXVpcmVkYCBwYXRocy5cbiAqIEBwYXJhbSB7TnVtYmVyfFN0cmluZ30gW29wdGlvbnMud10gc2V0IHRoZSBbd3JpdGUgY29uY2Vybl0oaHR0cHM6Ly93d3cubW9uZ29kYi5jb20vZG9jcy9tYW51YWwvcmVmZXJlbmNlL3dyaXRlLWNvbmNlcm4vI3ctb3B0aW9uKS4gT3ZlcnJpZGVzIHRoZSBbc2NoZW1hLWxldmVsIGB3cml0ZUNvbmNlcm5gIG9wdGlvbl0oaHR0cHM6Ly9tb25nb29zZWpzLmNvbS9kb2NzL2d1aWRlLmh0bWwjd3JpdGVDb25jZXJuKVxuICogQHBhcmFtIHtCb29sZWFufSBbb3B0aW9ucy5qXSBzZXQgdG8gdHJ1ZSBmb3IgTW9uZ29EQiB0byB3YWl0IHVudGlsIHRoaXMgYHNhdmUoKWAgaGFzIGJlZW4gW2pvdXJuYWxlZCBiZWZvcmUgcmVzb2x2aW5nIHRoZSByZXR1cm5lZCBwcm9taXNlXShodHRwczovL3d3dy5tb25nb2RiLmNvbS9kb2NzL21hbnVhbC9yZWZlcmVuY2Uvd3JpdGUtY29uY2Vybi8jai1vcHRpb24pLiBPdmVycmlkZXMgdGhlIFtzY2hlbWEtbGV2ZWwgYHdyaXRlQ29uY2VybmAgb3B0aW9uXShodHRwczovL21vbmdvb3NlanMuY29tL2RvY3MvZ3VpZGUuaHRtbCN3cml0ZUNvbmNlcm4pXG4gKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMud3RpbWVvdXRdIHNldHMgYSBbdGltZW91dCBmb3IgdGhlIHdyaXRlIGNvbmNlcm5dKGh0dHBzOi8vd3d3Lm1vbmdvZGIuY29tL2RvY3MvbWFudWFsL3JlZmVyZW5jZS93cml0ZS1jb25jZXJuLyN3dGltZW91dCkuIE92ZXJyaWRlcyB0aGUgW3NjaGVtYS1sZXZlbCBgd3JpdGVDb25jZXJuYCBvcHRpb25dKGh0dHBzOi8vbW9uZ29vc2Vqcy5jb20vZG9jcy9ndWlkZS5odG1sI3dyaXRlQ29uY2VybikuXG4gKiBAcGFyYW0ge0Jvb2xlYW59IFtvcHRpb25zLmNoZWNrS2V5cz10cnVlXSB0aGUgTW9uZ29EQiBkcml2ZXIgcHJldmVudHMgeW91IGZyb20gc2F2aW5nIGtleXMgdGhhdCBzdGFydCB3aXRoICckJyBvciBjb250YWluICcuJyBieSBkZWZhdWx0LiBTZXQgdGhpcyBvcHRpb24gdG8gYGZhbHNlYCB0byBza2lwIHRoYXQgY2hlY2suIFNlZSBbcmVzdHJpY3Rpb25zIG9uIGZpZWxkIG5hbWVzXShodHRwczovL3d3dy5tb25nb2RiLmNvbS9kb2NzL21hbnVhbC9yZWZlcmVuY2UvbGltaXRzLyNSZXN0cmljdGlvbnMtb24tRmllbGQtTmFtZXMpXG4gKiBAcGFyYW0ge0Jvb2xlYW59IFtvcHRpb25zLnRpbWVzdGFtcHM9dHJ1ZV0gaWYgYGZhbHNlYCBhbmQgW3RpbWVzdGFtcHNdKGh0dHBzOi8vbW9uZ29vc2Vqcy5jb20vZG9jcy9ndWlkZS5odG1sI3RpbWVzdGFtcHMpIGFyZSBlbmFibGVkLCBza2lwIHRpbWVzdGFtcHMgZm9yIHRoaXMgYHNhdmUoKWAuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbZm5dIG9wdGlvbmFsIGNhbGxiYWNrXG4gKiBAbWV0aG9kIHNhdmVcbiAqIEBtZW1iZXJPZiBEb2N1bWVudFxuICogQGluc3RhbmNlXG4gKiBAdGhyb3dzIHtEb2N1bWVudE5vdEZvdW5kRXJyb3J9IGlmIHRoaXMgW3NhdmUgdXBkYXRlcyBhbiBleGlzdGluZyBkb2N1bWVudF0oaHR0cHM6Ly9tb25nb29zZWpzLmNvbS9kb2NzL2FwaS9kb2N1bWVudC5odG1sI0RvY3VtZW50LnByb3RvdHlwZS5pc05ldygpKSBidXQgdGhlIGRvY3VtZW50IGRvZXNuJ3QgZXhpc3QgaW4gdGhlIGRhdGFiYXNlLiBGb3IgZXhhbXBsZSwgeW91IHdpbGwgZ2V0IHRoaXMgZXJyb3IgaWYgdGhlIGRvY3VtZW50IGlzIFtkZWxldGVkIGJldHdlZW4gd2hlbiB5b3UgcmV0cmlldmVkIHRoZSBkb2N1bWVudCBhbmQgd2hlbiB5b3Ugc2F2ZWQgaXRdKGRvY3VtZW50cy5odG1sI3VwZGF0aW5nKS5cbiAqIEByZXR1cm4ge1Byb21pc2V8dW5kZWZpbmVkfSBSZXR1cm5zIHVuZGVmaW5lZCBpZiB1c2VkIHdpdGggY2FsbGJhY2sgb3IgYSBQcm9taXNlIG90aGVyd2lzZS5cbiAqIEBhcGkgcHVibGljXG4gKiBAc2VlIG1pZGRsZXdhcmUgaHR0cHM6Ly9tb25nb29zZWpzLmNvbS9kb2NzL21pZGRsZXdhcmUuaHRtbFxuICovXG5cbi8qKlxuICogQ2hlY2tzIGlmIGEgcGF0aCBpcyBpbnZhbGlkXG4gKlxuICogQHBhcmFtIHtTdHJpbmd8U3RyaW5nW119IFtwYXRoXSB0aGUgZmllbGQgdG8gY2hlY2suIElmIHVuc2V0IHdpbGwgYWx3YXlzIHJldHVybiBcImZhbHNlXCJcbiAqIEBtZXRob2QgJGlzVmFsaWRcbiAqIEBtZW1iZXJPZiBEb2N1bWVudFxuICogQGluc3RhbmNlXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5Eb2N1bWVudC5wcm90b3R5cGUuJGlzVmFsaWQgPSBmdW5jdGlvbihwYXRoKSB7XG4gIGlmICh0aGlzLiRfXy52YWxpZGF0aW9uRXJyb3IgPT0gbnVsbCB8fCBPYmplY3Qua2V5cyh0aGlzLiRfXy52YWxpZGF0aW9uRXJyb3IuZXJyb3JzKS5sZW5ndGggPT09IDApIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICBpZiAocGF0aCA9PSBudWxsKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgaWYgKHBhdGguaW5kZXhPZignICcpICE9PSAtMSkge1xuICAgIHBhdGggPSBwYXRoLnNwbGl0KCcgJyk7XG4gIH1cbiAgaWYgKEFycmF5LmlzQXJyYXkocGF0aCkpIHtcbiAgICByZXR1cm4gcGF0aC5zb21lKHAgPT4gdGhpcy4kX18udmFsaWRhdGlvbkVycm9yLmVycm9yc1twXSA9PSBudWxsKTtcbiAgfVxuXG4gIHJldHVybiB0aGlzLiRfXy52YWxpZGF0aW9uRXJyb3IuZXJyb3JzW3BhdGhdID09IG51bGw7XG59O1xuXG4vKipcbiAqIFJlc2V0cyB0aGUgaW50ZXJuYWwgbW9kaWZpZWQgc3RhdGUgb2YgdGhpcyBkb2N1bWVudC5cbiAqXG4gKiBAYXBpIHByaXZhdGVcbiAqIEByZXR1cm4ge0RvY3VtZW50fSB0aGlzXG4gKiBAbWV0aG9kICRfX3Jlc2V0XG4gKiBAbWVtYmVyT2YgRG9jdW1lbnRcbiAqIEBpbnN0YW5jZVxuICovXG5cbkRvY3VtZW50LnByb3RvdHlwZS4kX19yZXNldCA9IGZ1bmN0aW9uIHJlc2V0KCkge1xuICBsZXQgX3RoaXMgPSB0aGlzO1xuXG4gIC8vIFNraXAgZm9yIHN1YmRvY3VtZW50c1xuICBjb25zdCBzdWJkb2NzID0gdGhpcy4kcGFyZW50KCkgPT09IHRoaXMgPyB0aGlzLiRnZXRBbGxTdWJkb2NzKCkgOiBbXTtcbiAgY29uc3QgcmVzZXRBcnJheXMgPSBuZXcgU2V0KCk7XG4gIGZvciAoY29uc3Qgc3ViZG9jIG9mIHN1YmRvY3MpIHtcbiAgICBjb25zdCBmdWxsUGF0aFdpdGhJbmRleGVzID0gc3ViZG9jLiRfX2Z1bGxQYXRoV2l0aEluZGV4ZXMoKTtcbiAgICBzdWJkb2MuJF9fcmVzZXQoKTtcbiAgICBpZiAodGhpcy5pc01vZGlmaWVkKGZ1bGxQYXRoV2l0aEluZGV4ZXMpIHx8IGlzUGFyZW50SW5pdChmdWxsUGF0aFdpdGhJbmRleGVzKSkge1xuICAgICAgaWYgKHN1YmRvYy4kaXNEb2N1bWVudEFycmF5RWxlbWVudCkge1xuICAgICAgICByZXNldEFycmF5cy5hZGQoc3ViZG9jLnBhcmVudEFycmF5KCkpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc3QgcGFyZW50ID0gc3ViZG9jLiRwYXJlbnQoKTtcbiAgICAgICAgaWYgKHBhcmVudCA9PT0gdGhpcykge1xuICAgICAgICAgIHRoaXMuJF9fLmFjdGl2ZVBhdGhzLmNsZWFyUGF0aChzdWJkb2MuJGJhc2VQYXRoKTtcbiAgICAgICAgfSBlbHNlIGlmIChwYXJlbnQgIT0gbnVsbCAmJiBwYXJlbnQuJGlzU3ViZG9jdW1lbnQpIHtcbiAgICAgICAgICAvLyBJZiBtYXAgcGF0aCB1bmRlcm5lYXRoIHN1YmRvY3VtZW50LCBtYXkgZW5kIHVwIHdpdGggYSBjYXNlIHdoZXJlXG4gICAgICAgICAgLy8gbWFwIHBhdGggaXMgbW9kaWZpZWQgYnV0IHBhcmVudCBzdGlsbCBuZWVkcyB0byBiZSByZXNldC4gU2VlIGdoLTEwMjk1XG4gICAgICAgICAgcGFyZW50LiRfX3Jlc2V0KCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBmb3IgKGNvbnN0IGFycmF5IG9mIHJlc2V0QXJyYXlzKSB7XG4gICAgdGhpcy4kX18uYWN0aXZlUGF0aHMuY2xlYXJQYXRoKGFycmF5LiRwYXRoKCkpO1xuICAgIGFycmF5W2FycmF5QXRvbWljc0JhY2t1cFN5bWJvbF0gPSBhcnJheVthcnJheUF0b21pY3NTeW1ib2xdO1xuICAgIGFycmF5W2FycmF5QXRvbWljc1N5bWJvbF0gPSB7fTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGlzUGFyZW50SW5pdChwYXRoKSB7XG4gICAgcGF0aCA9IHBhdGguaW5kZXhPZignLicpID09PSAtMSA/IFtwYXRoXSA6IHBhdGguc3BsaXQoJy4nKTtcbiAgICBsZXQgY3VyID0gJyc7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBwYXRoLmxlbmd0aDsgKytpKSB7XG4gICAgICBjdXIgKz0gKGN1ci5sZW5ndGggPyAnLicgOiAnJykgKyBwYXRoW2ldO1xuICAgICAgaWYgKF90aGlzLiRfXy5hY3RpdmVQYXRoc1tjdXJdID09PSAnaW5pdCcpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgLy8gY2xlYXIgYXRvbWljc1xuICB0aGlzLiRfX2RpcnR5KCkuZm9yRWFjaChmdW5jdGlvbihkaXJ0KSB7XG4gICAgY29uc3QgdHlwZSA9IGRpcnQudmFsdWU7XG5cbiAgICBpZiAodHlwZSAmJiB0eXBlW2FycmF5QXRvbWljc1N5bWJvbF0pIHtcbiAgICAgIHR5cGVbYXJyYXlBdG9taWNzQmFja3VwU3ltYm9sXSA9IHR5cGVbYXJyYXlBdG9taWNzU3ltYm9sXTtcbiAgICAgIHR5cGVbYXJyYXlBdG9taWNzU3ltYm9sXSA9IHt9O1xuICAgIH1cbiAgfSk7XG5cbiAgdGhpcy4kX18uYmFja3VwID0ge307XG4gIHRoaXMuJF9fLmJhY2t1cC5hY3RpdmVQYXRocyA9IHtcbiAgICBtb2RpZnk6IE9iamVjdC5hc3NpZ24oe30sIHRoaXMuJF9fLmFjdGl2ZVBhdGhzLmdldFN0YXRlUGF0aHMoJ21vZGlmeScpKSxcbiAgICBkZWZhdWx0OiBPYmplY3QuYXNzaWduKHt9LCB0aGlzLiRfXy5hY3RpdmVQYXRocy5nZXRTdGF0ZVBhdGhzKCdkZWZhdWx0JykpXG4gIH07XG4gIHRoaXMuJF9fLmJhY2t1cC52YWxpZGF0aW9uRXJyb3IgPSB0aGlzLiRfXy52YWxpZGF0aW9uRXJyb3I7XG4gIHRoaXMuJF9fLmJhY2t1cC5lcnJvcnMgPSB0aGlzLiRlcnJvcnM7XG5cbiAgLy8gQ2xlYXIgJ2RpcnR5JyBjYWNoZVxuICB0aGlzLiRfXy5hY3RpdmVQYXRocy5jbGVhcignbW9kaWZ5Jyk7XG4gIHRoaXMuJF9fLmFjdGl2ZVBhdGhzLmNsZWFyKCdkZWZhdWx0Jyk7XG4gIHRoaXMuJF9fLnZhbGlkYXRpb25FcnJvciA9IHVuZGVmaW5lZDtcbiAgdGhpcy4kZXJyb3JzID0gdW5kZWZpbmVkO1xuICBfdGhpcyA9IHRoaXM7XG4gIHRoaXMuJF9fc2NoZW1hLnJlcXVpcmVkUGF0aHMoKS5mb3JFYWNoKGZ1bmN0aW9uKHBhdGgpIHtcbiAgICBfdGhpcy4kX18uYWN0aXZlUGF0aHMucmVxdWlyZShwYXRoKTtcbiAgfSk7XG5cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKiFcbiAqIGlnbm9yZVxuICovXG5cbkRvY3VtZW50LnByb3RvdHlwZS4kX191bmRvUmVzZXQgPSBmdW5jdGlvbiAkX191bmRvUmVzZXQoKSB7XG4gIGlmICh0aGlzLiRfXy5iYWNrdXAgPT0gbnVsbCB8fCB0aGlzLiRfXy5iYWNrdXAuYWN0aXZlUGF0aHMgPT0gbnVsbCkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIHRoaXMuJF9fLmFjdGl2ZVBhdGhzLnN0YXRlcy5tb2RpZnkgPSB0aGlzLiRfXy5iYWNrdXAuYWN0aXZlUGF0aHMubW9kaWZ5O1xuICB0aGlzLiRfXy5hY3RpdmVQYXRocy5zdGF0ZXMuZGVmYXVsdCA9IHRoaXMuJF9fLmJhY2t1cC5hY3RpdmVQYXRocy5kZWZhdWx0O1xuXG4gIHRoaXMuJF9fLnZhbGlkYXRpb25FcnJvciA9IHRoaXMuJF9fLmJhY2t1cC52YWxpZGF0aW9uRXJyb3I7XG4gIHRoaXMuJGVycm9ycyA9IHRoaXMuJF9fLmJhY2t1cC5lcnJvcnM7XG5cbiAgZm9yIChjb25zdCBkaXJ0IG9mIHRoaXMuJF9fZGlydHkoKSkge1xuICAgIGNvbnN0IHR5cGUgPSBkaXJ0LnZhbHVlO1xuXG4gICAgaWYgKHR5cGUgJiYgdHlwZVthcnJheUF0b21pY3NTeW1ib2xdICYmIHR5cGVbYXJyYXlBdG9taWNzQmFja3VwU3ltYm9sXSkge1xuICAgICAgdHlwZVthcnJheUF0b21pY3NTeW1ib2xdID0gdHlwZVthcnJheUF0b21pY3NCYWNrdXBTeW1ib2xdO1xuICAgIH1cbiAgfVxuXG4gIGZvciAoY29uc3Qgc3ViZG9jIG9mIHRoaXMuJGdldEFsbFN1YmRvY3MoKSkge1xuICAgIHN1YmRvYy4kX191bmRvUmVzZXQoKTtcbiAgfVxufTtcblxuLyoqXG4gKiBSZXR1cm5zIHRoaXMgZG9jdW1lbnRzIGRpcnR5IHBhdGhzIC8gdmFscy5cbiAqXG4gKiBAcmV0dXJuIHtBcnJheX1cbiAqIEBhcGkgcHJpdmF0ZVxuICogQG1ldGhvZCAkX19kaXJ0eVxuICogQG1lbWJlck9mIERvY3VtZW50XG4gKiBAaW5zdGFuY2VcbiAqL1xuXG5Eb2N1bWVudC5wcm90b3R5cGUuJF9fZGlydHkgPSBmdW5jdGlvbigpIHtcbiAgY29uc3QgX3RoaXMgPSB0aGlzO1xuICBsZXQgYWxsID0gdGhpcy4kX18uYWN0aXZlUGF0aHMubWFwKCdtb2RpZnknLCBmdW5jdGlvbihwYXRoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHBhdGg6IHBhdGgsXG4gICAgICB2YWx1ZTogX3RoaXMuJF9fZ2V0VmFsdWUocGF0aCksXG4gICAgICBzY2hlbWE6IF90aGlzLiRfX3BhdGgocGF0aClcbiAgICB9O1xuICB9KTtcblxuICAvLyBnaC0yNTU4OiBpZiB3ZSBoYWQgdG8gc2V0IGEgZGVmYXVsdCBhbmQgdGhlIHZhbHVlIGlzIG5vdCB1bmRlZmluZWQsXG4gIC8vIHdlIGhhdmUgdG8gc2F2ZSBhcyB3ZWxsXG4gIGFsbCA9IGFsbC5jb25jYXQodGhpcy4kX18uYWN0aXZlUGF0aHMubWFwKCdkZWZhdWx0JywgZnVuY3Rpb24ocGF0aCkge1xuICAgIGlmIChwYXRoID09PSAnX2lkJyB8fCBfdGhpcy4kX19nZXRWYWx1ZShwYXRoKSA9PSBudWxsKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICBwYXRoOiBwYXRoLFxuICAgICAgdmFsdWU6IF90aGlzLiRfX2dldFZhbHVlKHBhdGgpLFxuICAgICAgc2NoZW1hOiBfdGhpcy4kX19wYXRoKHBhdGgpXG4gICAgfTtcbiAgfSkpO1xuXG4gIGNvbnN0IGFsbFBhdGhzID0gbmV3IE1hcChhbGwuZmlsdGVyKChlbCkgPT4gZWwgIT0gbnVsbCkubWFwKChlbCkgPT4gW2VsLnBhdGgsIGVsLnZhbHVlXSkpO1xuICAvLyBJZ25vcmUgXCJmb28uYVwiIGlmIFwiZm9vXCIgaXMgZGlydHkgYWxyZWFkeS5cbiAgY29uc3QgbWluaW1hbCA9IFtdO1xuXG4gIGFsbC5mb3JFYWNoKGZ1bmN0aW9uKGl0ZW0pIHtcbiAgICBpZiAoIWl0ZW0pIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBsZXQgdG9wID0gbnVsbDtcblxuICAgIGNvbnN0IGFycmF5ID0gcGFyZW50UGF0aHMoaXRlbS5wYXRoKTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGFycmF5Lmxlbmd0aCAtIDE7IGkrKykge1xuICAgICAgaWYgKGFsbFBhdGhzLmhhcyhhcnJheVtpXSkpIHtcbiAgICAgICAgdG9wID0gYWxsUGF0aHMuZ2V0KGFycmF5W2ldKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICAgIGlmICh0b3AgPT0gbnVsbCkge1xuICAgICAgbWluaW1hbC5wdXNoKGl0ZW0pO1xuICAgIH0gZWxzZSBpZiAodG9wICE9IG51bGwgJiZcbiAgICAgICAgdG9wW2FycmF5QXRvbWljc1N5bWJvbF0gIT0gbnVsbCAmJlxuICAgICAgICB0b3AuaGFzQXRvbWljcygpKSB7XG4gICAgICAvLyBzcGVjaWFsIGNhc2UgZm9yIHRvcCBsZXZlbCBNb25nb29zZUFycmF5c1xuICAgICAgLy8gdGhlIGB0b3BgIGFycmF5IGl0c2VsZiBhbmQgYSBzdWIgcGF0aCBvZiBgdG9wYCBhcmUgYmVpbmcgc2V0LlxuICAgICAgLy8gdGhlIG9ubHkgd2F5IHRvIGhvbm9yIGFsbCBvZiBib3RoIG1vZGlmaWNhdGlvbnMgaXMgdGhyb3VnaCBhICRzZXRcbiAgICAgIC8vIG9mIGVudGlyZSBhcnJheS5cbiAgICAgIHRvcFthcnJheUF0b21pY3NTeW1ib2xdID0ge307XG4gICAgICB0b3BbYXJyYXlBdG9taWNzU3ltYm9sXS4kc2V0ID0gdG9wO1xuICAgIH1cbiAgfSk7XG4gIHJldHVybiBtaW5pbWFsO1xufTtcblxuLyoqXG4gKiBBc3NpZ25zL2NvbXBpbGVzIGBzY2hlbWFgIGludG8gdGhpcyBkb2N1bWVudHMgcHJvdG90eXBlLlxuICpcbiAqIEBwYXJhbSB7U2NoZW1hfSBzY2hlbWFcbiAqIEBhcGkgcHJpdmF0ZVxuICogQG1ldGhvZCAkX19zZXRTY2hlbWFcbiAqIEBtZW1iZXJPZiBEb2N1bWVudFxuICogQGluc3RhbmNlXG4gKi9cblxuRG9jdW1lbnQucHJvdG90eXBlLiRfX3NldFNjaGVtYSA9IGZ1bmN0aW9uKHNjaGVtYSkge1xuICBjb21waWxlKHNjaGVtYS50cmVlLCB0aGlzLCB1bmRlZmluZWQsIHNjaGVtYS5vcHRpb25zKTtcblxuICAvLyBBcHBseSBkZWZhdWx0IGdldHRlcnMgaWYgdmlydHVhbCBkb2Vzbid0IGhhdmUgYW55IChnaC02MjYyKVxuICBmb3IgKGNvbnN0IGtleSBvZiBPYmplY3Qua2V5cyhzY2hlbWEudmlydHVhbHMpKSB7XG4gICAgc2NoZW1hLnZpcnR1YWxzW2tleV0uX2FwcGx5RGVmYXVsdEdldHRlcnMoKTtcbiAgfVxuICBpZiAoc2NoZW1hLnBhdGgoJ3NjaGVtYScpID09IG51bGwpIHtcbiAgICB0aGlzLnNjaGVtYSA9IHNjaGVtYTtcbiAgfVxuICB0aGlzLiRfX3NjaGVtYSA9IHNjaGVtYTtcbiAgdGhpc1tkb2N1bWVudFNjaGVtYVN5bWJvbF0gPSBzY2hlbWE7XG59O1xuXG5cbi8qKlxuICogR2V0IGFjdGl2ZSBwYXRoIHRoYXQgd2VyZSBjaGFuZ2VkIGFuZCBhcmUgYXJyYXlzXG4gKlxuICogQHJldHVybiB7QXJyYXl9XG4gKiBAYXBpIHByaXZhdGVcbiAqIEBtZXRob2QgJF9fZ2V0QXJyYXlQYXRoc1RvVmFsaWRhdGVcbiAqIEBtZW1iZXJPZiBEb2N1bWVudFxuICogQGluc3RhbmNlXG4gKi9cblxuRG9jdW1lbnQucHJvdG90eXBlLiRfX2dldEFycmF5UGF0aHNUb1ZhbGlkYXRlID0gZnVuY3Rpb24oKSB7XG4gIERvY3VtZW50QXJyYXkgfHwgKERvY3VtZW50QXJyYXkgPSByZXF1aXJlKCcuL3R5cGVzL2RvY3VtZW50QXJyYXknKSk7XG5cbiAgLy8gdmFsaWRhdGUgYWxsIGRvY3VtZW50IGFycmF5cy5cbiAgcmV0dXJuIHRoaXMuJF9fLmFjdGl2ZVBhdGhzXG4gICAgLm1hcCgnaW5pdCcsICdtb2RpZnknLCBmdW5jdGlvbihpKSB7XG4gICAgICByZXR1cm4gdGhpcy4kX19nZXRWYWx1ZShpKTtcbiAgICB9LmJpbmQodGhpcykpXG4gICAgLmZpbHRlcihmdW5jdGlvbih2YWwpIHtcbiAgICAgIHJldHVybiB2YWwgJiYgQXJyYXkuaXNBcnJheSh2YWwpICYmIHV0aWxzLmlzTW9uZ29vc2VEb2N1bWVudEFycmF5KHZhbCkgJiYgdmFsLmxlbmd0aDtcbiAgICB9KS5yZWR1Y2UoZnVuY3Rpb24oc2VlZCwgYXJyYXkpIHtcbiAgICAgIHJldHVybiBzZWVkLmNvbmNhdChhcnJheSk7XG4gICAgfSwgW10pXG4gICAgLmZpbHRlcihmdW5jdGlvbihkb2MpIHtcbiAgICAgIHJldHVybiBkb2M7XG4gICAgfSk7XG59O1xuXG5cbi8qKlxuICogR2V0IGFsbCBzdWJkb2NzIChieSBiZnMpXG4gKlxuICogQHJldHVybiB7QXJyYXl9XG4gKiBAYXBpIHB1YmxpY1xuICogQG1ldGhvZCAkZ2V0QWxsU3ViZG9jc1xuICogQG1lbWJlck9mIERvY3VtZW50XG4gKiBAaW5zdGFuY2VcbiAqL1xuXG5Eb2N1bWVudC5wcm90b3R5cGUuJGdldEFsbFN1YmRvY3MgPSBmdW5jdGlvbigpIHtcbiAgRG9jdW1lbnRBcnJheSB8fCAoRG9jdW1lbnRBcnJheSA9IHJlcXVpcmUoJy4vdHlwZXMvZG9jdW1lbnRBcnJheScpKTtcbiAgRW1iZWRkZWQgPSBFbWJlZGRlZCB8fCByZXF1aXJlKCcuL3R5cGVzL2FycmF5U3ViZG9jdW1lbnQnKTtcblxuICBmdW5jdGlvbiBkb2NSZWR1Y2VyKGRvYywgc2VlZCwgcGF0aCkge1xuICAgIGxldCB2YWwgPSBkb2M7XG4gICAgbGV0IGlzTmVzdGVkID0gZmFsc2U7XG4gICAgaWYgKHBhdGgpIHtcbiAgICAgIGlmIChkb2MgaW5zdGFuY2VvZiBEb2N1bWVudCAmJiBkb2NbZG9jdW1lbnRTY2hlbWFTeW1ib2xdLnBhdGhzW3BhdGhdKSB7XG4gICAgICAgIHZhbCA9IGRvYy5fZG9jW3BhdGhdO1xuICAgICAgfSBlbHNlIGlmIChkb2MgaW5zdGFuY2VvZiBEb2N1bWVudCAmJiBkb2NbZG9jdW1lbnRTY2hlbWFTeW1ib2xdLm5lc3RlZFtwYXRoXSkge1xuICAgICAgICB2YWwgPSBkb2MuX2RvY1twYXRoXTtcbiAgICAgICAgaXNOZXN0ZWQgPSB0cnVlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFsID0gZG9jW3BhdGhdO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAodmFsIGluc3RhbmNlb2YgRW1iZWRkZWQpIHtcbiAgICAgIHNlZWQucHVzaCh2YWwpO1xuICAgIH0gZWxzZSBpZiAodmFsIGluc3RhbmNlb2YgTWFwKSB7XG4gICAgICBzZWVkID0gQXJyYXkuZnJvbSh2YWwua2V5cygpKS5yZWR1Y2UoZnVuY3Rpb24oc2VlZCwgcGF0aCkge1xuICAgICAgICByZXR1cm4gZG9jUmVkdWNlcih2YWwuZ2V0KHBhdGgpLCBzZWVkLCBudWxsKTtcbiAgICAgIH0sIHNlZWQpO1xuICAgIH0gZWxzZSBpZiAodmFsICYmICFBcnJheS5pc0FycmF5KHZhbCkgJiYgdmFsLiRpc1NpbmdsZU5lc3RlZCkge1xuICAgICAgc2VlZCA9IE9iamVjdC5rZXlzKHZhbC5fZG9jKS5yZWR1Y2UoZnVuY3Rpb24oc2VlZCwgcGF0aCkge1xuICAgICAgICByZXR1cm4gZG9jUmVkdWNlcih2YWwsIHNlZWQsIHBhdGgpO1xuICAgICAgfSwgc2VlZCk7XG4gICAgICBzZWVkLnB1c2godmFsKTtcbiAgICB9IGVsc2UgaWYgKHZhbCAmJiB1dGlscy5pc01vbmdvb3NlRG9jdW1lbnRBcnJheSh2YWwpKSB7XG4gICAgICB2YWwuZm9yRWFjaChmdW5jdGlvbiBfZG9jUmVkdWNlKGRvYykge1xuICAgICAgICBpZiAoIWRvYyB8fCAhZG9jLl9kb2MpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgc2VlZCA9IE9iamVjdC5rZXlzKGRvYy5fZG9jKS5yZWR1Y2UoZnVuY3Rpb24oc2VlZCwgcGF0aCkge1xuICAgICAgICAgIHJldHVybiBkb2NSZWR1Y2VyKGRvYy5fZG9jLCBzZWVkLCBwYXRoKTtcbiAgICAgICAgfSwgc2VlZCk7XG4gICAgICAgIGlmIChkb2MgaW5zdGFuY2VvZiBFbWJlZGRlZCkge1xuICAgICAgICAgIHNlZWQucHVzaChkb2MpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9IGVsc2UgaWYgKGlzTmVzdGVkICYmIHZhbCAhPSBudWxsKSB7XG4gICAgICBmb3IgKGNvbnN0IHBhdGggb2YgT2JqZWN0LmtleXModmFsKSkge1xuICAgICAgICBkb2NSZWR1Y2VyKHZhbCwgc2VlZCwgcGF0aCk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBzZWVkO1xuICB9XG5cbiAgY29uc3Qgc3ViRG9jcyA9IFtdO1xuICBmb3IgKGNvbnN0IHBhdGggb2YgT2JqZWN0LmtleXModGhpcy5fZG9jKSkge1xuICAgIGRvY1JlZHVjZXIodGhpcywgc3ViRG9jcywgcGF0aCk7XG4gIH1cblxuICByZXR1cm4gc3ViRG9jcztcbn07XG5cbi8qIVxuICogUnVucyBxdWV1ZWQgZnVuY3Rpb25zXG4gKi9cblxuZnVuY3Rpb24gYXBwbHlRdWV1ZShkb2MpIHtcbiAgY29uc3QgcSA9IGRvYy4kX19zY2hlbWEgJiYgZG9jLiRfX3NjaGVtYS5jYWxsUXVldWU7XG4gIGlmICghcS5sZW5ndGgpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICBmb3IgKGNvbnN0IHBhaXIgb2YgcSkge1xuICAgIGlmIChwYWlyWzBdICE9PSAncHJlJyAmJiBwYWlyWzBdICE9PSAncG9zdCcgJiYgcGFpclswXSAhPT0gJ29uJykge1xuICAgICAgZG9jW3BhaXJbMF1dLmFwcGx5KGRvYywgcGFpclsxXSk7XG4gICAgfVxuICB9XG59XG5cbi8qIVxuICogaWdub3JlXG4gKi9cblxuRG9jdW1lbnQucHJvdG90eXBlLiRfX2hhbmRsZVJlamVjdCA9IGZ1bmN0aW9uIGhhbmRsZVJlamVjdChlcnIpIHtcbiAgLy8gZW1pdCBvbiB0aGUgTW9kZWwgaWYgbGlzdGVuaW5nXG4gIGlmICh0aGlzLiRsaXN0ZW5lcnMoJ2Vycm9yJykubGVuZ3RoKSB7XG4gICAgdGhpcy4kZW1pdCgnZXJyb3InLCBlcnIpO1xuICB9IGVsc2UgaWYgKHRoaXMuY29uc3RydWN0b3IubGlzdGVuZXJzICYmIHRoaXMuY29uc3RydWN0b3IubGlzdGVuZXJzKCdlcnJvcicpLmxlbmd0aCkge1xuICAgIHRoaXMuY29uc3RydWN0b3IuZW1pdCgnZXJyb3InLCBlcnIpO1xuICB9XG59O1xuXG4vKipcbiAqIEludGVybmFsIGhlbHBlciBmb3IgdG9PYmplY3QoKSBhbmQgdG9KU09OKCkgdGhhdCBkb2Vzbid0IG1hbmlwdWxhdGUgb3B0aW9uc1xuICpcbiAqIEByZXR1cm4ge09iamVjdH1cbiAqIEBhcGkgcHJpdmF0ZVxuICogQG1ldGhvZCAkdG9PYmplY3RcbiAqIEBtZW1iZXJPZiBEb2N1bWVudFxuICogQGluc3RhbmNlXG4gKi9cblxuRG9jdW1lbnQucHJvdG90eXBlLiR0b09iamVjdCA9IGZ1bmN0aW9uKG9wdGlvbnMsIGpzb24pIHtcbiAgbGV0IGRlZmF1bHRPcHRpb25zID0ge1xuICAgIHRyYW5zZm9ybTogdHJ1ZSxcbiAgICBmbGF0dGVuRGVjaW1hbHM6IHRydWVcbiAgfTtcblxuICBjb25zdCBwYXRoID0ganNvbiA/ICd0b0pTT04nIDogJ3RvT2JqZWN0JztcbiAgY29uc3QgYmFzZU9wdGlvbnMgPSB0aGlzLmNvbnN0cnVjdG9yICYmXG4gICAgdGhpcy5jb25zdHJ1Y3Rvci5iYXNlICYmXG4gICAgdGhpcy5jb25zdHJ1Y3Rvci5iYXNlLm9wdGlvbnMgJiZcbiAgICBnZXQodGhpcy5jb25zdHJ1Y3Rvci5iYXNlLm9wdGlvbnMsIHBhdGgpIHx8IHt9O1xuICBjb25zdCBzY2hlbWFPcHRpb25zID0gdGhpcy4kX19zY2hlbWEgJiYgdGhpcy4kX19zY2hlbWEub3B0aW9ucyB8fCB7fTtcbiAgLy8gbWVyZ2UgYmFzZSBkZWZhdWx0IG9wdGlvbnMgd2l0aCBTY2hlbWEncyBzZXQgZGVmYXVsdCBvcHRpb25zIGlmIGF2YWlsYWJsZS5cbiAgLy8gYGNsb25lYCBpcyBuZWNlc3NhcnkgaGVyZSBiZWNhdXNlIGB1dGlscy5vcHRpb25zYCBkaXJlY3RseSBtb2RpZmllcyB0aGUgc2Vjb25kIGlucHV0LlxuICBkZWZhdWx0T3B0aW9ucyA9IHV0aWxzLm9wdGlvbnMoZGVmYXVsdE9wdGlvbnMsIGNsb25lKGJhc2VPcHRpb25zKSk7XG4gIGRlZmF1bHRPcHRpb25zID0gdXRpbHMub3B0aW9ucyhkZWZhdWx0T3B0aW9ucywgY2xvbmUoc2NoZW1hT3B0aW9uc1twYXRoXSB8fCB7fSkpO1xuXG4gIC8vIElmIG9wdGlvbnMgZG8gbm90IGV4aXN0IG9yIGlzIG5vdCBhbiBvYmplY3QsIHNldCBpdCB0byBlbXB0eSBvYmplY3RcbiAgb3B0aW9ucyA9IHV0aWxzLmlzUE9KTyhvcHRpb25zKSA/IHsgLi4ub3B0aW9ucyB9IDoge307XG4gIG9wdGlvbnMuX2NhbGxlZFdpdGhPcHRpb25zID0gb3B0aW9ucy5fY2FsbGVkV2l0aE9wdGlvbnMgfHwgeyAuLi5vcHRpb25zIH07XG5cbiAgbGV0IF9taW5pbWl6ZTtcbiAgaWYgKG9wdGlvbnMuX2NhbGxlZFdpdGhPcHRpb25zLm1pbmltaXplICE9IG51bGwpIHtcbiAgICBfbWluaW1pemUgPSBvcHRpb25zLm1pbmltaXplO1xuICB9IGVsc2UgaWYgKGRlZmF1bHRPcHRpb25zLm1pbmltaXplICE9IG51bGwpIHtcbiAgICBfbWluaW1pemUgPSBkZWZhdWx0T3B0aW9ucy5taW5pbWl6ZTtcbiAgfSBlbHNlIHtcbiAgICBfbWluaW1pemUgPSBzY2hlbWFPcHRpb25zLm1pbmltaXplO1xuICB9XG5cbiAgbGV0IGZsYXR0ZW5NYXBzO1xuICBpZiAob3B0aW9ucy5fY2FsbGVkV2l0aE9wdGlvbnMuZmxhdHRlbk1hcHMgIT0gbnVsbCkge1xuICAgIGZsYXR0ZW5NYXBzID0gb3B0aW9ucy5mbGF0dGVuTWFwcztcbiAgfSBlbHNlIGlmIChkZWZhdWx0T3B0aW9ucy5mbGF0dGVuTWFwcyAhPSBudWxsKSB7XG4gICAgZmxhdHRlbk1hcHMgPSBkZWZhdWx0T3B0aW9ucy5mbGF0dGVuTWFwcztcbiAgfSBlbHNlIHtcbiAgICBmbGF0dGVuTWFwcyA9IHNjaGVtYU9wdGlvbnMuZmxhdHRlbk1hcHM7XG4gIH1cblxuICBsZXQgZmxhdHRlbk9iamVjdElkcztcbiAgaWYgKG9wdGlvbnMuX2NhbGxlZFdpdGhPcHRpb25zLmZsYXR0ZW5PYmplY3RJZHMgIT0gbnVsbCkge1xuICAgIGZsYXR0ZW5PYmplY3RJZHMgPSBvcHRpb25zLmZsYXR0ZW5PYmplY3RJZHM7XG4gIH0gZWxzZSBpZiAoZGVmYXVsdE9wdGlvbnMuZmxhdHRlbk9iamVjdElkcyAhPSBudWxsKSB7XG4gICAgZmxhdHRlbk9iamVjdElkcyA9IGRlZmF1bHRPcHRpb25zLmZsYXR0ZW5PYmplY3RJZHM7XG4gIH0gZWxzZSB7XG4gICAgZmxhdHRlbk9iamVjdElkcyA9IHNjaGVtYU9wdGlvbnMuZmxhdHRlbk9iamVjdElkcztcbiAgfVxuXG4gIC8vIFRoZSBvcmlnaW5hbCBvcHRpb25zIHRoYXQgd2lsbCBiZSBwYXNzZWQgdG8gYGNsb25lKClgLiBJbXBvcnRhbnQgYmVjYXVzZVxuICAvLyBgY2xvbmUoKWAgd2lsbCByZWN1cnNpdmVseSBjYWxsIGAkdG9PYmplY3QoKWAgb24gZW1iZWRkZWQgZG9jcywgc28gd2VcbiAgLy8gbmVlZCB0aGUgb3JpZ2luYWwgb3B0aW9ucyB0aGUgdXNlciBwYXNzZWQgaW4sIHBsdXMgYF9pc05lc3RlZGAgYW5kXG4gIC8vIGBfcGFyZW50T3B0aW9uc2AgZm9yIGNoZWNraW5nIHdoZXRoZXIgd2UgbmVlZCB0byBkZXBvcHVsYXRlLlxuICBjb25zdCBjbG9uZU9wdGlvbnMgPSBPYmplY3QuYXNzaWduKHt9LCBvcHRpb25zLCB7XG4gICAgX2lzTmVzdGVkOiB0cnVlLFxuICAgIGpzb246IGpzb24sXG4gICAgbWluaW1pemU6IF9taW5pbWl6ZSxcbiAgICBmbGF0dGVuTWFwczogZmxhdHRlbk1hcHMsXG4gICAgZmxhdHRlbk9iamVjdElkczogZmxhdHRlbk9iamVjdElkcyxcbiAgICBfc2VlbjogKG9wdGlvbnMgJiYgb3B0aW9ucy5fc2VlbikgfHwgbmV3IE1hcCgpXG4gIH0pO1xuXG4gIGlmICh1dGlscy5oYXNVc2VyRGVmaW5lZFByb3BlcnR5KG9wdGlvbnMsICdnZXR0ZXJzJykpIHtcbiAgICBjbG9uZU9wdGlvbnMuZ2V0dGVycyA9IG9wdGlvbnMuZ2V0dGVycztcbiAgfVxuICBpZiAodXRpbHMuaGFzVXNlckRlZmluZWRQcm9wZXJ0eShvcHRpb25zLCAndmlydHVhbHMnKSkge1xuICAgIGNsb25lT3B0aW9ucy52aXJ0dWFscyA9IG9wdGlvbnMudmlydHVhbHM7XG4gIH1cblxuICBjb25zdCBkZXBvcHVsYXRlID0gb3B0aW9ucy5kZXBvcHVsYXRlIHx8XG4gICAgKG9wdGlvbnMuX3BhcmVudE9wdGlvbnMgJiYgb3B0aW9ucy5fcGFyZW50T3B0aW9ucy5kZXBvcHVsYXRlIHx8IGZhbHNlKTtcbiAgLy8gX2lzTmVzdGVkIHdpbGwgb25seSBiZSB0cnVlIGlmIHRoaXMgaXMgbm90IHRoZSB0b3AgbGV2ZWwgZG9jdW1lbnQsIHdlXG4gIC8vIHNob3VsZCBuZXZlciBkZXBvcHVsYXRlIHRoZSB0b3AtbGV2ZWwgZG9jdW1lbnRcbiAgaWYgKGRlcG9wdWxhdGUgJiYgb3B0aW9ucy5faXNOZXN0ZWQgJiYgdGhpcy4kX18ud2FzUG9wdWxhdGVkKSB7XG4gICAgcmV0dXJuIGNsb25lKHRoaXMuJF9fLndhc1BvcHVsYXRlZC52YWx1ZSB8fCB0aGlzLl9pZCwgY2xvbmVPcHRpb25zKTtcbiAgfVxuXG4gIC8vIG1lcmdlIGRlZmF1bHQgb3B0aW9ucyB3aXRoIGlucHV0IG9wdGlvbnMuXG4gIG9wdGlvbnMgPSB1dGlscy5vcHRpb25zKGRlZmF1bHRPcHRpb25zLCBvcHRpb25zKTtcbiAgb3B0aW9ucy5faXNOZXN0ZWQgPSB0cnVlO1xuICBvcHRpb25zLmpzb24gPSBqc29uO1xuICBvcHRpb25zLm1pbmltaXplID0gX21pbmltaXplO1xuXG4gIGNsb25lT3B0aW9ucy5fcGFyZW50T3B0aW9ucyA9IG9wdGlvbnM7XG4gIGNsb25lT3B0aW9ucy5fc2tpcFNpbmdsZU5lc3RlZEdldHRlcnMgPSBmYWxzZTtcblxuICBjb25zdCBnZXR0ZXJzT3B0aW9ucyA9IE9iamVjdC5hc3NpZ24oe30sIGNsb25lT3B0aW9ucyk7XG4gIGdldHRlcnNPcHRpb25zLl9za2lwU2luZ2xlTmVzdGVkR2V0dGVycyA9IHRydWU7XG5cbiAgLy8gcmVtZW1iZXIgdGhlIHJvb3QgdHJhbnNmb3JtIGZ1bmN0aW9uXG4gIC8vIHRvIHNhdmUgaXQgZnJvbSBiZWluZyBvdmVyd3JpdHRlbiBieSBzdWItdHJhbnNmb3JtIGZ1bmN0aW9uc1xuICBjb25zdCBvcmlnaW5hbFRyYW5zZm9ybSA9IG9wdGlvbnMudHJhbnNmb3JtO1xuXG4gIGxldCByZXQgPSBjbG9uZSh0aGlzLl9kb2MsIGNsb25lT3B0aW9ucykgfHwge307XG5cbiAgaWYgKG9wdGlvbnMuZ2V0dGVycykge1xuICAgIGFwcGx5R2V0dGVycyh0aGlzLCByZXQsIGdldHRlcnNPcHRpb25zKTtcblxuICAgIGlmIChvcHRpb25zLm1pbmltaXplKSB7XG4gICAgICByZXQgPSBtaW5pbWl6ZShyZXQpIHx8IHt9O1xuICAgIH1cbiAgfVxuXG4gIGlmIChvcHRpb25zLnZpcnR1YWxzIHx8IChvcHRpb25zLmdldHRlcnMgJiYgb3B0aW9ucy52aXJ0dWFscyAhPT0gZmFsc2UpKSB7XG4gICAgYXBwbHlWaXJ0dWFscyh0aGlzLCByZXQsIGdldHRlcnNPcHRpb25zLCBvcHRpb25zKTtcbiAgfVxuXG4gIGlmIChvcHRpb25zLnZlcnNpb25LZXkgPT09IGZhbHNlICYmIHRoaXMuJF9fc2NoZW1hLm9wdGlvbnMudmVyc2lvbktleSkge1xuICAgIGRlbGV0ZSByZXRbdGhpcy4kX19zY2hlbWEub3B0aW9ucy52ZXJzaW9uS2V5XTtcbiAgfVxuXG4gIGxldCB0cmFuc2Zvcm0gPSBvcHRpb25zLnRyYW5zZm9ybTtcblxuICAvLyBJbiB0aGUgY2FzZSB3aGVyZSBhIHN1YmRvY3VtZW50IGhhcyBpdHMgb3duIHRyYW5zZm9ybSBmdW5jdGlvbiwgd2UgbmVlZCB0b1xuICAvLyBjaGVjayBhbmQgc2VlIGlmIHRoZSBwYXJlbnQgaGFzIGEgdHJhbnNmb3JtIChvcHRpb25zLnRyYW5zZm9ybSkgYW5kIGlmIHRoZVxuICAvLyBjaGlsZCBzY2hlbWEgaGFzIGEgdHJhbnNmb3JtICh0aGlzLnNjaGVtYS5vcHRpb25zLnRvT2JqZWN0KSBJbiB0aGlzIGNhc2UsXG4gIC8vIHdlIG5lZWQgdG8gYWRqdXN0IG9wdGlvbnMudHJhbnNmb3JtIHRvIGJlIHRoZSBjaGlsZCBzY2hlbWEncyB0cmFuc2Zvcm0gYW5kXG4gIC8vIG5vdCB0aGUgcGFyZW50IHNjaGVtYSdzXG4gIGlmICh0cmFuc2Zvcm0pIHtcbiAgICBhcHBseVNjaGVtYVR5cGVUcmFuc2Zvcm1zKHRoaXMsIHJldCk7XG4gIH1cblxuICBpZiAob3B0aW9ucy51c2VQcm9qZWN0aW9uKSB7XG4gICAgb21pdERlc2VsZWN0ZWRGaWVsZHModGhpcywgcmV0KTtcbiAgfVxuXG4gIGlmICh0cmFuc2Zvcm0gPT09IHRydWUgfHwgKHNjaGVtYU9wdGlvbnMudG9PYmplY3QgJiYgdHJhbnNmb3JtKSkge1xuICAgIGNvbnN0IG9wdHMgPSBvcHRpb25zLmpzb24gPyBzY2hlbWFPcHRpb25zLnRvSlNPTiA6IHNjaGVtYU9wdGlvbnMudG9PYmplY3Q7XG5cbiAgICBpZiAob3B0cykge1xuICAgICAgdHJhbnNmb3JtID0gKHR5cGVvZiBvcHRpb25zLnRyYW5zZm9ybSA9PT0gJ2Z1bmN0aW9uJyA/IG9wdGlvbnMudHJhbnNmb3JtIDogb3B0cy50cmFuc2Zvcm0pO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBvcHRpb25zLnRyYW5zZm9ybSA9IG9yaWdpbmFsVHJhbnNmb3JtO1xuICB9XG5cbiAgaWYgKHR5cGVvZiB0cmFuc2Zvcm0gPT09ICdmdW5jdGlvbicpIHtcbiAgICBjb25zdCB4Zm9ybWVkID0gdHJhbnNmb3JtKHRoaXMsIHJldCwgb3B0aW9ucyk7XG4gICAgaWYgKHR5cGVvZiB4Zm9ybWVkICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgcmV0ID0geGZvcm1lZDtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gcmV0O1xufTtcblxuLyoqXG4gKiBDb252ZXJ0cyB0aGlzIGRvY3VtZW50IGludG8gYSBwbGFpbi1vbGQgSmF2YVNjcmlwdCBvYmplY3QgKFtQT0pPXShodHRwczovL21hc3RlcmluZ2pzLmlvL3R1dG9yaWFscy9mdW5kYW1lbnRhbHMvcG9qbykpLlxuICpcbiAqIEJ1ZmZlcnMgYXJlIGNvbnZlcnRlZCB0byBpbnN0YW5jZXMgb2YgW21vbmdvZGIuQmluYXJ5XShodHRwczovL21vbmdvZGIuZ2l0aHViLmlvL25vZGUtbW9uZ29kYi1uYXRpdmUvNC45L2NsYXNzZXMvQmluYXJ5Lmh0bWwpIGZvciBwcm9wZXIgc3RvcmFnZS5cbiAqXG4gKiAjIyMjIEdldHRlcnMvVmlydHVhbHNcbiAqXG4gKiBFeGFtcGxlIG9mIG9ubHkgYXBwbHlpbmcgcGF0aCBnZXR0ZXJzXG4gKlxuICogICAgIGRvYy50b09iamVjdCh7IGdldHRlcnM6IHRydWUsIHZpcnR1YWxzOiBmYWxzZSB9KVxuICpcbiAqIEV4YW1wbGUgb2Ygb25seSBhcHBseWluZyB2aXJ0dWFsIGdldHRlcnNcbiAqXG4gKiAgICAgZG9jLnRvT2JqZWN0KHsgdmlydHVhbHM6IHRydWUgfSlcbiAqXG4gKiBFeGFtcGxlIG9mIGFwcGx5aW5nIGJvdGggcGF0aCBhbmQgdmlydHVhbCBnZXR0ZXJzXG4gKlxuICogICAgIGRvYy50b09iamVjdCh7IGdldHRlcnM6IHRydWUgfSlcbiAqXG4gKiBUbyBhcHBseSB0aGVzZSBvcHRpb25zIHRvIGV2ZXJ5IGRvY3VtZW50IG9mIHlvdXIgc2NoZW1hIGJ5IGRlZmF1bHQsIHNldCB5b3VyIFtzY2hlbWFzXShodHRwczovL21vbmdvb3NlanMuY29tL2RvY3MvYXBpL3NjaGVtYS5odG1sI1NjaGVtYSgpKSBgdG9PYmplY3RgIG9wdGlvbiB0byB0aGUgc2FtZSBhcmd1bWVudC5cbiAqXG4gKiAgICAgc2NoZW1hLnNldCgndG9PYmplY3QnLCB7IHZpcnR1YWxzOiB0cnVlIH0pXG4gKlxuICogIyMjIyBUcmFuc2Zvcm06XG4gKlxuICogV2UgbWF5IG5lZWQgdG8gcGVyZm9ybSBhIHRyYW5zZm9ybWF0aW9uIG9mIHRoZSByZXN1bHRpbmcgb2JqZWN0IGJhc2VkIG9uIHNvbWUgY3JpdGVyaWEsIHNheSB0byByZW1vdmUgc29tZSBzZW5zaXRpdmUgaW5mb3JtYXRpb24gb3IgcmV0dXJuIGEgY3VzdG9tIG9iamVjdC4gSW4gdGhpcyBjYXNlIHdlIHNldCB0aGUgb3B0aW9uYWwgYHRyYW5zZm9ybWAgZnVuY3Rpb24uXG4gKlxuICogVHJhbnNmb3JtIGZ1bmN0aW9ucyByZWNlaXZlIHRocmVlIGFyZ3VtZW50c1xuICpcbiAqICAgICBmdW5jdGlvbiAoZG9jLCByZXQsIG9wdGlvbnMpIHt9XG4gKlxuICogLSBgZG9jYCBUaGUgbW9uZ29vc2UgZG9jdW1lbnQgd2hpY2ggaXMgYmVpbmcgY29udmVydGVkXG4gKiAtIGByZXRgIFRoZSBwbGFpbiBvYmplY3QgcmVwcmVzZW50YXRpb24gd2hpY2ggaGFzIGJlZW4gY29udmVydGVkXG4gKiAtIGBvcHRpb25zYCBUaGUgb3B0aW9ucyBpbiB1c2UgKGVpdGhlciBzY2hlbWEgb3B0aW9ucyBvciB0aGUgb3B0aW9ucyBwYXNzZWQgaW5saW5lKVxuICpcbiAqICMjIyMgRXhhbXBsZTpcbiAqXG4gKiAgICAgLy8gc3BlY2lmeSB0aGUgdHJhbnNmb3JtIHNjaGVtYSBvcHRpb25cbiAqICAgICBpZiAoIXNjaGVtYS5vcHRpb25zLnRvT2JqZWN0KSBzY2hlbWEub3B0aW9ucy50b09iamVjdCA9IHt9O1xuICogICAgIHNjaGVtYS5vcHRpb25zLnRvT2JqZWN0LnRyYW5zZm9ybSA9IGZ1bmN0aW9uIChkb2MsIHJldCwgb3B0aW9ucykge1xuICogICAgICAgLy8gcmVtb3ZlIHRoZSBfaWQgb2YgZXZlcnkgZG9jdW1lbnQgYmVmb3JlIHJldHVybmluZyB0aGUgcmVzdWx0XG4gKiAgICAgICBkZWxldGUgcmV0Ll9pZDtcbiAqICAgICAgIHJldHVybiByZXQ7XG4gKiAgICAgfVxuICpcbiAqICAgICAvLyB3aXRob3V0IHRoZSB0cmFuc2Zvcm1hdGlvbiBpbiB0aGUgc2NoZW1hXG4gKiAgICAgZG9jLnRvT2JqZWN0KCk7IC8vIHsgX2lkOiAnYW5JZCcsIG5hbWU6ICdXcmVjay1pdCBSYWxwaCcgfVxuICpcbiAqICAgICAvLyB3aXRoIHRoZSB0cmFuc2Zvcm1hdGlvblxuICogICAgIGRvYy50b09iamVjdCgpOyAvLyB7IG5hbWU6ICdXcmVjay1pdCBSYWxwaCcgfVxuICpcbiAqIFdpdGggdHJhbnNmb3JtYXRpb25zIHdlIGNhbiBkbyBhIGxvdCBtb3JlIHRoYW4gcmVtb3ZlIHByb3BlcnRpZXMuIFdlIGNhbiBldmVuIHJldHVybiBjb21wbGV0ZWx5IG5ldyBjdXN0b21pemVkIG9iamVjdHM6XG4gKlxuICogICAgIGlmICghc2NoZW1hLm9wdGlvbnMudG9PYmplY3QpIHNjaGVtYS5vcHRpb25zLnRvT2JqZWN0ID0ge307XG4gKiAgICAgc2NoZW1hLm9wdGlvbnMudG9PYmplY3QudHJhbnNmb3JtID0gZnVuY3Rpb24gKGRvYywgcmV0LCBvcHRpb25zKSB7XG4gKiAgICAgICByZXR1cm4geyBtb3ZpZTogcmV0Lm5hbWUgfVxuICogICAgIH1cbiAqXG4gKiAgICAgLy8gd2l0aG91dCB0aGUgdHJhbnNmb3JtYXRpb24gaW4gdGhlIHNjaGVtYVxuICogICAgIGRvYy50b09iamVjdCgpOyAvLyB7IF9pZDogJ2FuSWQnLCBuYW1lOiAnV3JlY2staXQgUmFscGgnIH1cbiAqXG4gKiAgICAgLy8gd2l0aCB0aGUgdHJhbnNmb3JtYXRpb25cbiAqICAgICBkb2MudG9PYmplY3QoKTsgLy8geyBtb3ZpZTogJ1dyZWNrLWl0IFJhbHBoJyB9XG4gKlxuICogX05vdGU6IGlmIGEgdHJhbnNmb3JtIGZ1bmN0aW9uIHJldHVybnMgYHVuZGVmaW5lZGAsIHRoZSByZXR1cm4gdmFsdWUgd2lsbCBiZSBpZ25vcmVkLl9cbiAqXG4gKiBUcmFuc2Zvcm1hdGlvbnMgbWF5IGFsc28gYmUgYXBwbGllZCBpbmxpbmUsIG92ZXJyaWRkaW5nIGFueSB0cmFuc2Zvcm0gc2V0IGluIHRoZSBvcHRpb25zOlxuICpcbiAqICAgICBmdW5jdGlvbiB4Zm9ybSAoZG9jLCByZXQsIG9wdGlvbnMpIHtcbiAqICAgICAgIHJldHVybiB7IGlubGluZTogcmV0Lm5hbWUsIGN1c3RvbTogdHJ1ZSB9XG4gKiAgICAgfVxuICpcbiAqICAgICAvLyBwYXNzIHRoZSB0cmFuc2Zvcm0gYXMgYW4gaW5saW5lIG9wdGlvblxuICogICAgIGRvYy50b09iamVjdCh7IHRyYW5zZm9ybTogeGZvcm0gfSk7IC8vIHsgaW5saW5lOiAnV3JlY2staXQgUmFscGgnLCBjdXN0b206IHRydWUgfVxuICpcbiAqIElmIHlvdSB3YW50IHRvIHNraXAgdHJhbnNmb3JtYXRpb25zLCB1c2UgYHRyYW5zZm9ybTogZmFsc2VgOlxuICpcbiAqICAgICBzY2hlbWEub3B0aW9ucy50b09iamVjdC5oaWRlID0gJ19pZCc7XG4gKiAgICAgc2NoZW1hLm9wdGlvbnMudG9PYmplY3QudHJhbnNmb3JtID0gZnVuY3Rpb24gKGRvYywgcmV0LCBvcHRpb25zKSB7XG4gKiAgICAgICBpZiAob3B0aW9ucy5oaWRlKSB7XG4gKiAgICAgICAgIG9wdGlvbnMuaGlkZS5zcGxpdCgnICcpLmZvckVhY2goZnVuY3Rpb24gKHByb3ApIHtcbiAqICAgICAgICAgICBkZWxldGUgcmV0W3Byb3BdO1xuICogICAgICAgICB9KTtcbiAqICAgICAgIH1cbiAqICAgICAgIHJldHVybiByZXQ7XG4gKiAgICAgfVxuICpcbiAqICAgICBjb25zdCBkb2MgPSBuZXcgRG9jKHsgX2lkOiAnYW5JZCcsIHNlY3JldDogNDcsIG5hbWU6ICdXcmVjay1pdCBSYWxwaCcgfSk7XG4gKiAgICAgZG9jLnRvT2JqZWN0KCk7ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHsgc2VjcmV0OiA0NywgbmFtZTogJ1dyZWNrLWl0IFJhbHBoJyB9XG4gKiAgICAgZG9jLnRvT2JqZWN0KHsgaGlkZTogJ3NlY3JldCBfaWQnLCB0cmFuc2Zvcm06IGZhbHNlIH0pOy8vIHsgX2lkOiAnYW5JZCcsIHNlY3JldDogNDcsIG5hbWU6ICdXcmVjay1pdCBSYWxwaCcgfVxuICogICAgIGRvYy50b09iamVjdCh7IGhpZGU6ICdzZWNyZXQgX2lkJywgdHJhbnNmb3JtOiB0cnVlIH0pOyAvLyB7IG5hbWU6ICdXcmVjay1pdCBSYWxwaCcgfVxuICpcbiAqIElmIHlvdSBwYXNzIGEgdHJhbnNmb3JtIGluIGB0b09iamVjdCgpYCBvcHRpb25zLCBNb25nb29zZSB3aWxsIGFwcGx5IHRoZSB0cmFuc2Zvcm1cbiAqIHRvIFtzdWJkb2N1bWVudHNdKGh0dHBzOi8vbW9uZ29vc2Vqcy5jb20vZG9jcy9zdWJkb2NzLmh0bWwpIGluIGFkZGl0aW9uIHRvIHRoZSB0b3AtbGV2ZWwgZG9jdW1lbnQuXG4gKiBTaW1pbGFybHksIGB0cmFuc2Zvcm06IGZhbHNlYCBza2lwcyB0cmFuc2Zvcm1zIGZvciBhbGwgc3ViZG9jdW1lbnRzLlxuICogTm90ZSB0aGF0IHRoaXMgYmVoYXZpb3IgaXMgZGlmZmVyZW50IGZvciB0cmFuc2Zvcm1zIGRlZmluZWQgaW4gdGhlIHNjaGVtYTpcbiAqIGlmIHlvdSBkZWZpbmUgYSB0cmFuc2Zvcm0gaW4gYHNjaGVtYS5vcHRpb25zLnRvT2JqZWN0LnRyYW5zZm9ybWAsIHRoYXQgdHJhbnNmb3JtXG4gKiB3aWxsICoqbm90KiogYXBwbHkgdG8gc3ViZG9jdW1lbnRzLlxuICpcbiAqICAgICBjb25zdCBtZW1iZXJTY2hlbWEgPSBuZXcgU2NoZW1hKHsgbmFtZTogU3RyaW5nLCBlbWFpbDogU3RyaW5nIH0pO1xuICogICAgIGNvbnN0IGdyb3VwU2NoZW1hID0gbmV3IFNjaGVtYSh7IG1lbWJlcnM6IFttZW1iZXJTY2hlbWFdLCBuYW1lOiBTdHJpbmcsIGVtYWlsIH0pO1xuICogICAgIGNvbnN0IEdyb3VwID0gbW9uZ29vc2UubW9kZWwoJ0dyb3VwJywgZ3JvdXBTY2hlbWEpO1xuICpcbiAqICAgICBjb25zdCBkb2MgPSBuZXcgR3JvdXAoe1xuICogICAgICAgbmFtZTogJ0VuZ2luZWVyaW5nJyxcbiAqICAgICAgIGVtYWlsOiAnZGV2QG1vbmdvb3NlanMuaW8nLFxuICogICAgICAgbWVtYmVyczogW3sgbmFtZTogJ1ZhbCcsIGVtYWlsOiAndmFsQG1vbmdvb3NlanMuaW8nIH1dXG4gKiAgICAgfSk7XG4gKlxuICogICAgIC8vIFJlbW92ZXMgYGVtYWlsYCBmcm9tIGJvdGggdG9wLWxldmVsIGRvY3VtZW50ICoqYW5kKiogYXJyYXkgZWxlbWVudHNcbiAqICAgICAvLyB7IG5hbWU6ICdFbmdpbmVlcmluZycsIG1lbWJlcnM6IFt7IG5hbWU6ICdWYWwnIH1dIH1cbiAqICAgICBkb2MudG9PYmplY3QoeyB0cmFuc2Zvcm06IChkb2MsIHJldCkgPT4geyBkZWxldGUgcmV0LmVtYWlsOyByZXR1cm4gcmV0OyB9IH0pO1xuICpcbiAqIFRyYW5zZm9ybXMsIGxpa2UgYWxsIG9mIHRoZXNlIG9wdGlvbnMsIGFyZSBhbHNvIGF2YWlsYWJsZSBmb3IgYHRvSlNPTmAuIFNlZSBbdGhpcyBndWlkZSB0byBgSlNPTi5zdHJpbmdpZnkoKWBdKGh0dHBzOi8vdGhlY29kZWJhcmJhcmlhbi5jb20vdGhlLTgwLTIwLWd1aWRlLXRvLWpzb24tc3RyaW5naWZ5LWluLWphdmFzY3JpcHQuaHRtbCkgdG8gbGVhcm4gd2h5IGB0b0pTT04oKWAgYW5kIGB0b09iamVjdCgpYCBhcmUgc2VwYXJhdGUgZnVuY3Rpb25zLlxuICpcbiAqIFNlZSBbc2NoZW1hIG9wdGlvbnNdKGh0dHBzOi8vbW9uZ29vc2Vqcy5jb20vZG9jcy9ndWlkZS5odG1sI3RvT2JqZWN0KSBmb3Igc29tZSBtb3JlIGRldGFpbHMuXG4gKlxuICogX0R1cmluZyBzYXZlLCBubyBjdXN0b20gb3B0aW9ucyBhcmUgYXBwbGllZCB0byB0aGUgZG9jdW1lbnQgYmVmb3JlIGJlaW5nIHNlbnQgdG8gdGhlIGRhdGFiYXNlLl9cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdXG4gKiBAcGFyYW0ge0Jvb2xlYW59IFtvcHRpb25zLmdldHRlcnM9ZmFsc2VdIGlmIHRydWUsIGFwcGx5IGFsbCBnZXR0ZXJzLCBpbmNsdWRpbmcgdmlydHVhbHNcbiAqIEBwYXJhbSB7Qm9vbGVhbnxPYmplY3R9IFtvcHRpb25zLnZpcnR1YWxzPWZhbHNlXSBpZiB0cnVlLCBhcHBseSB2aXJ0dWFscywgaW5jbHVkaW5nIGFsaWFzZXMuIFVzZSBgeyBnZXR0ZXJzOiB0cnVlLCB2aXJ0dWFsczogZmFsc2UgfWAgdG8ganVzdCBhcHBseSBnZXR0ZXJzLCBub3QgdmlydHVhbHMuIEFuIG9iamVjdCBvZiB0aGUgZm9ybSBgeyBwYXRoc1RvU2tpcDogWydzb21lVmlydHVhbCddIH1gIG1heSBhbHNvIGJlIHVzZWQgdG8gb21pdCBzcGVjaWZpYyB2aXJ0dWFscy5cbiAqIEBwYXJhbSB7Qm9vbGVhbn0gW29wdGlvbnMuYWxpYXNlcz10cnVlXSBpZiBgb3B0aW9ucy52aXJ0dWFscyA9IHRydWVgLCB5b3UgY2FuIHNldCBgb3B0aW9ucy5hbGlhc2VzID0gZmFsc2VgIHRvIHNraXAgYXBwbHlpbmcgYWxpYXNlcy4gVGhpcyBvcHRpb24gaXMgYSBuby1vcCBpZiBgb3B0aW9ucy52aXJ0dWFscyA9IGZhbHNlYC5cbiAqIEBwYXJhbSB7Qm9vbGVhbn0gW29wdGlvbnMubWluaW1pemU9dHJ1ZV0gaWYgdHJ1ZSwgb21pdCBhbnkgZW1wdHkgb2JqZWN0cyBmcm9tIHRoZSBvdXRwdXRcbiAqIEBwYXJhbSB7RnVuY3Rpb258bnVsbH0gW29wdGlvbnMudHJhbnNmb3JtPW51bGxdIGlmIHNldCwgbW9uZ29vc2Ugd2lsbCBjYWxsIHRoaXMgZnVuY3Rpb24gdG8gYWxsb3cgeW91IHRvIHRyYW5zZm9ybSB0aGUgcmV0dXJuZWQgb2JqZWN0XG4gKiBAcGFyYW0ge0Jvb2xlYW59IFtvcHRpb25zLmRlcG9wdWxhdGU9ZmFsc2VdIGlmIHRydWUsIHJlcGxhY2UgYW55IGNvbnZlbnRpb25hbGx5IHBvcHVsYXRlZCBwYXRocyB3aXRoIHRoZSBvcmlnaW5hbCBpZCBpbiB0aGUgb3V0cHV0LiBIYXMgbm8gYWZmZWN0IG9uIHZpcnR1YWwgcG9wdWxhdGVkIHBhdGhzLlxuICogQHBhcmFtIHtCb29sZWFufSBbb3B0aW9ucy52ZXJzaW9uS2V5PXRydWVdIGlmIGZhbHNlLCBleGNsdWRlIHRoZSB2ZXJzaW9uIGtleSAoYF9fdmAgYnkgZGVmYXVsdCkgZnJvbSB0aGUgb3V0cHV0XG4gKiBAcGFyYW0ge0Jvb2xlYW59IFtvcHRpb25zLmZsYXR0ZW5NYXBzPWZhbHNlXSBpZiB0cnVlLCBjb252ZXJ0IE1hcHMgdG8gUE9KT3MuIFVzZWZ1bCBpZiB5b3Ugd2FudCB0byBgSlNPTi5zdHJpbmdpZnkoKWAgdGhlIHJlc3VsdCBvZiBgdG9PYmplY3QoKWAuXG4gKiBAcGFyYW0ge0Jvb2xlYW59IFtvcHRpb25zLmZsYXR0ZW5PYmplY3RJZHM9ZmFsc2VdIGlmIHRydWUsIGNvbnZlcnQgYW55IE9iamVjdElkcyBpbiB0aGUgcmVzdWx0IHRvIDI0IGNoYXJhY3RlciBoZXggc3RyaW5ncy5cbiAqIEBwYXJhbSB7Qm9vbGVhbn0gW29wdGlvbnMudXNlUHJvamVjdGlvbj1mYWxzZV0gLSBJZiB0cnVlLCBvbWl0cyBmaWVsZHMgdGhhdCBhcmUgZXhjbHVkZWQgaW4gdGhpcyBkb2N1bWVudCdzIHByb2plY3Rpb24uIFVubGVzcyB5b3Ugc3BlY2lmaWVkIGEgcHJvamVjdGlvbiwgdGhpcyB3aWxsIG9taXQgYW55IGZpZWxkIHRoYXQgaGFzIGBzZWxlY3Q6IGZhbHNlYCBpbiB0aGUgc2NoZW1hLlxuICogQHJldHVybiB7T2JqZWN0fSBqcyBvYmplY3QgKG5vdCBhIFBPSk8pXG4gKiBAc2VlIG1vbmdvZGIuQmluYXJ5IGh0dHBzOi8vbW9uZ29kYi5naXRodWIuaW8vbm9kZS1tb25nb2RiLW5hdGl2ZS80LjkvY2xhc3Nlcy9CaW5hcnkuaHRtbFxuICogQGFwaSBwdWJsaWNcbiAqIEBtZW1iZXJPZiBEb2N1bWVudFxuICogQGluc3RhbmNlXG4gKi9cblxuRG9jdW1lbnQucHJvdG90eXBlLnRvT2JqZWN0ID0gZnVuY3Rpb24ob3B0aW9ucykge1xuICByZXR1cm4gdGhpcy4kdG9PYmplY3Qob3B0aW9ucyk7XG59O1xuXG4vKiFcbiAqIEFwcGxpZXMgdmlydHVhbHMgcHJvcGVydGllcyB0byBganNvbmAuXG4gKi9cblxuZnVuY3Rpb24gYXBwbHlWaXJ0dWFscyhzZWxmLCBqc29uLCBvcHRpb25zLCB0b09iamVjdE9wdGlvbnMpIHtcbiAgY29uc3Qgc2NoZW1hID0gc2VsZi4kX19zY2hlbWE7XG4gIGNvbnN0IHBhdGhzID0gT2JqZWN0LmtleXMoc2NoZW1hLnZpcnR1YWxzKTtcbiAgbGV0IGkgPSBwYXRocy5sZW5ndGg7XG4gIGNvbnN0IG51bVBhdGhzID0gaTtcbiAgbGV0IHBhdGg7XG4gIGxldCBhc3NpZ25QYXRoO1xuICBsZXQgY3VyID0gc2VsZi5fZG9jO1xuICBsZXQgdjtcbiAgY29uc3QgYWxpYXNlcyA9IHR5cGVvZiAodG9PYmplY3RPcHRpb25zICYmIHRvT2JqZWN0T3B0aW9ucy5hbGlhc2VzKSA9PT0gJ2Jvb2xlYW4nXG4gICAgPyB0b09iamVjdE9wdGlvbnMuYWxpYXNlc1xuICAgIDogdHJ1ZTtcblxuICBsZXQgdmlydHVhbHNUb0FwcGx5ID0gbnVsbDtcbiAgaWYgKEFycmF5LmlzQXJyYXkob3B0aW9ucy52aXJ0dWFscykpIHtcbiAgICB2aXJ0dWFsc1RvQXBwbHkgPSBuZXcgU2V0KG9wdGlvbnMudmlydHVhbHMpO1xuICB9IGVsc2UgaWYgKG9wdGlvbnMudmlydHVhbHMgJiYgb3B0aW9ucy52aXJ0dWFscy5wYXRoc1RvU2tpcCkge1xuICAgIHZpcnR1YWxzVG9BcHBseSA9IG5ldyBTZXQocGF0aHMpO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgb3B0aW9ucy52aXJ0dWFscy5wYXRoc1RvU2tpcC5sZW5ndGg7IGkrKykge1xuICAgICAgaWYgKHZpcnR1YWxzVG9BcHBseS5oYXMob3B0aW9ucy52aXJ0dWFscy5wYXRoc1RvU2tpcFtpXSkpIHtcbiAgICAgICAgdmlydHVhbHNUb0FwcGx5LmRlbGV0ZShvcHRpb25zLnZpcnR1YWxzLnBhdGhzVG9Ta2lwW2ldKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBpZiAoIWN1cikge1xuICAgIHJldHVybiBqc29uO1xuICB9XG5cbiAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gIGZvciAoaSA9IDA7IGkgPCBudW1QYXRoczsgKytpKSB7XG4gICAgcGF0aCA9IHBhdGhzW2ldO1xuXG4gICAgaWYgKHZpcnR1YWxzVG9BcHBseSAhPSBudWxsICYmICF2aXJ0dWFsc1RvQXBwbHkuaGFzKHBhdGgpKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICAvLyBBbGxvdyBza2lwcGluZyBhbGlhc2VzIHdpdGggYHRvT2JqZWN0KHsgdmlydHVhbHM6IHRydWUsIGFsaWFzZXM6IGZhbHNlIH0pYFxuICAgIGlmICghYWxpYXNlcyAmJiBzY2hlbWEuYWxpYXNlcy5oYXNPd25Qcm9wZXJ0eShwYXRoKSkge1xuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgLy8gV2UgbWF5IGJlIGFwcGx5aW5nIHZpcnR1YWxzIHRvIGEgbmVzdGVkIG9iamVjdCwgZm9yIGV4YW1wbGUgaWYgY2FsbGluZ1xuICAgIC8vIGBkb2MubmVzdGVkUHJvcC50b0pTT04oKWAuIElmIHNvLCB0aGUgcGF0aCB3ZSBhc3NpZ24gdG8sIGBhc3NpZ25QYXRoYCxcbiAgICAvLyB3aWxsIGJlIGEgdHJhaWxpbmcgc3Vic3RyaW5nIG9mIHRoZSBgcGF0aGAuXG4gICAgYXNzaWduUGF0aCA9IHBhdGg7XG4gICAgaWYgKG9wdGlvbnMucGF0aCAhPSBudWxsKSB7XG4gICAgICBpZiAoIXBhdGguc3RhcnRzV2l0aChvcHRpb25zLnBhdGggKyAnLicpKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgYXNzaWduUGF0aCA9IHBhdGguc3Vic3RyaW5nKG9wdGlvbnMucGF0aC5sZW5ndGggKyAxKTtcbiAgICB9XG4gICAgY29uc3QgcGFydHMgPSBhc3NpZ25QYXRoLnNwbGl0KCcuJyk7XG4gICAgdiA9IGNsb25lKHNlbGYuZ2V0KHBhdGgpLCBvcHRpb25zKTtcbiAgICBpZiAodiA9PT0gdm9pZCAwKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgY29uc3QgcGxlbiA9IHBhcnRzLmxlbmd0aDtcbiAgICBjdXIgPSBqc29uO1xuICAgIGZvciAobGV0IGogPSAwOyBqIDwgcGxlbiAtIDE7ICsraikge1xuICAgICAgY3VyW3BhcnRzW2pdXSA9IGN1cltwYXJ0c1tqXV0gfHwge307XG4gICAgICBjdXIgPSBjdXJbcGFydHNbal1dO1xuICAgIH1cbiAgICBjdXJbcGFydHNbcGxlbiAtIDFdXSA9IHY7XG4gIH1cblxuICByZXR1cm4ganNvbjtcbn1cblxuXG4vKipcbiAqIEFwcGxpZXMgdmlydHVhbHMgcHJvcGVydGllcyB0byBganNvbmAuXG4gKlxuICogQHBhcmFtIHtEb2N1bWVudH0gc2VsZlxuICogQHBhcmFtIHtPYmplY3R9IGpzb25cbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc11cbiAqIEByZXR1cm4ge09iamVjdH0gYGpzb25gXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5mdW5jdGlvbiBhcHBseUdldHRlcnMoc2VsZiwganNvbiwgb3B0aW9ucykge1xuICBjb25zdCBzY2hlbWEgPSBzZWxmLiRfX3NjaGVtYTtcbiAgY29uc3QgcGF0aHMgPSBPYmplY3Qua2V5cyhzY2hlbWEucGF0aHMpO1xuICBsZXQgaSA9IHBhdGhzLmxlbmd0aDtcbiAgbGV0IHBhdGg7XG4gIGxldCBjdXIgPSBzZWxmLl9kb2M7XG4gIGxldCB2O1xuXG4gIGlmICghY3VyKSB7XG4gICAgcmV0dXJuIGpzb247XG4gIH1cblxuICB3aGlsZSAoaS0tKSB7XG4gICAgcGF0aCA9IHBhdGhzW2ldO1xuXG4gICAgY29uc3QgcGFydHMgPSBwYXRoLnNwbGl0KCcuJyk7XG5cbiAgICBjb25zdCBwbGVuID0gcGFydHMubGVuZ3RoO1xuICAgIGNvbnN0IGxhc3QgPSBwbGVuIC0gMTtcbiAgICBsZXQgYnJhbmNoID0ganNvbjtcbiAgICBsZXQgcGFydDtcbiAgICBjdXIgPSBzZWxmLl9kb2M7XG5cbiAgICBpZiAoIXNlbGYuJF9faXNTZWxlY3RlZChwYXRoKSkge1xuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgZm9yIChsZXQgaWkgPSAwOyBpaSA8IHBsZW47ICsraWkpIHtcbiAgICAgIHBhcnQgPSBwYXJ0c1tpaV07XG4gICAgICB2ID0gY3VyW3BhcnRdO1xuICAgICAgaWYgKGlpID09PSBsYXN0KSB7XG4gICAgICAgIGNvbnN0IHZhbCA9IHNlbGYuJGdldChwYXRoKTtcbiAgICAgICAgYnJhbmNoW3BhcnRdID0gY2xvbmUodmFsLCBvcHRpb25zKTtcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoYnJhbmNoW3BhcnRdKSAmJiBzY2hlbWEucGF0aHNbcGF0aF0uJGVtYmVkZGVkU2NoZW1hVHlwZSkge1xuICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYnJhbmNoW3BhcnRdLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICBicmFuY2hbcGFydF1baV0gPSBzY2hlbWEucGF0aHNbcGF0aF0uJGVtYmVkZGVkU2NoZW1hVHlwZS5hcHBseUdldHRlcnMoXG4gICAgICAgICAgICAgIGJyYW5jaFtwYXJ0XVtpXSxcbiAgICAgICAgICAgICAgc2VsZlxuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAodiA9PSBudWxsKSB7XG4gICAgICAgIGlmIChwYXJ0IGluIGN1cikge1xuICAgICAgICAgIGJyYW5jaFtwYXJ0XSA9IHY7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBicmFuY2ggPSBicmFuY2hbcGFydF0gfHwgKGJyYW5jaFtwYXJ0XSA9IHt9KTtcbiAgICAgIH1cbiAgICAgIGN1ciA9IHY7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGpzb247XG59XG5cbi8qKlxuICogQXBwbGllcyBzY2hlbWEgdHlwZSB0cmFuc2Zvcm1zIHRvIGBqc29uYC5cbiAqXG4gKiBAcGFyYW0ge0RvY3VtZW50fSBzZWxmXG4gKiBAcGFyYW0ge09iamVjdH0ganNvblxuICogQHJldHVybiB7T2JqZWN0fSBganNvbmBcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmZ1bmN0aW9uIGFwcGx5U2NoZW1hVHlwZVRyYW5zZm9ybXMoc2VsZiwganNvbikge1xuICBjb25zdCBzY2hlbWEgPSBzZWxmLiRfX3NjaGVtYTtcbiAgY29uc3QgcGF0aHMgPSBPYmplY3Qua2V5cyhzY2hlbWEucGF0aHMgfHwge30pO1xuICBjb25zdCBjdXIgPSBzZWxmLl9kb2M7XG5cbiAgaWYgKCFjdXIpIHtcbiAgICByZXR1cm4ganNvbjtcbiAgfVxuXG4gIGZvciAoY29uc3QgcGF0aCBvZiBwYXRocykge1xuICAgIGNvbnN0IHNjaGVtYXR5cGUgPSBzY2hlbWEucGF0aHNbcGF0aF07XG4gICAgaWYgKHR5cGVvZiBzY2hlbWF0eXBlLm9wdGlvbnMudHJhbnNmb3JtID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBjb25zdCB2YWwgPSBzZWxmLiRnZXQocGF0aCk7XG4gICAgICBpZiAodmFsID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBjb25zdCB0cmFuc2Zvcm1lZFZhbHVlID0gc2NoZW1hdHlwZS5vcHRpb25zLnRyYW5zZm9ybS5jYWxsKHNlbGYsIHZhbCk7XG4gICAgICB0aHJvd0Vycm9ySWZQcm9taXNlKHBhdGgsIHRyYW5zZm9ybWVkVmFsdWUpO1xuICAgICAgdXRpbHMuc2V0VmFsdWUocGF0aCwgdHJhbnNmb3JtZWRWYWx1ZSwganNvbik7XG4gICAgfSBlbHNlIGlmIChzY2hlbWF0eXBlLiRlbWJlZGRlZFNjaGVtYVR5cGUgIT0gbnVsbCAmJlxuICAgICAgICB0eXBlb2Ygc2NoZW1hdHlwZS4kZW1iZWRkZWRTY2hlbWFUeXBlLm9wdGlvbnMudHJhbnNmb3JtID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBjb25zdCB2YWwgPSBzZWxmLiRnZXQocGF0aCk7XG4gICAgICBpZiAodmFsID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBjb25zdCB2YWxzID0gW10uY29uY2F0KHZhbCk7XG4gICAgICBjb25zdCB0cmFuc2Zvcm0gPSBzY2hlbWF0eXBlLiRlbWJlZGRlZFNjaGVtYVR5cGUub3B0aW9ucy50cmFuc2Zvcm07XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHZhbHMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgY29uc3QgdHJhbnNmb3JtZWRWYWx1ZSA9IHRyYW5zZm9ybS5jYWxsKHNlbGYsIHZhbHNbaV0pO1xuICAgICAgICB2YWxzW2ldID0gdHJhbnNmb3JtZWRWYWx1ZTtcbiAgICAgICAgdGhyb3dFcnJvcklmUHJvbWlzZShwYXRoLCB0cmFuc2Zvcm1lZFZhbHVlKTtcbiAgICAgIH1cblxuICAgICAganNvbltwYXRoXSA9IHZhbHM7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGpzb247XG59XG5cbmZ1bmN0aW9uIHRocm93RXJyb3JJZlByb21pc2UocGF0aCwgdHJhbnNmb3JtZWRWYWx1ZSkge1xuICBpZiAoaXNQcm9taXNlKHRyYW5zZm9ybWVkVmFsdWUpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdgdHJhbnNmb3JtYCBmdW5jdGlvbiBtdXN0IGJlIHN5bmNocm9ub3VzLCBidXQgdGhlIHRyYW5zZm9ybSBvbiBwYXRoIGAnICsgcGF0aCArICdgIHJldHVybmVkIGEgcHJvbWlzZS4nKTtcbiAgfVxufVxuXG4vKiFcbiAqIGlnbm9yZVxuICovXG5cbmZ1bmN0aW9uIG9taXREZXNlbGVjdGVkRmllbGRzKHNlbGYsIGpzb24pIHtcbiAgY29uc3Qgc2NoZW1hID0gc2VsZi4kX19zY2hlbWE7XG4gIGNvbnN0IHBhdGhzID0gT2JqZWN0LmtleXMoc2NoZW1hLnBhdGhzIHx8IHt9KTtcbiAgY29uc3QgY3VyID0gc2VsZi5fZG9jO1xuXG4gIGlmICghY3VyKSB7XG4gICAgcmV0dXJuIGpzb247XG4gIH1cblxuICBsZXQgc2VsZWN0ZWQgPSBzZWxmLiRfXy5zZWxlY3RlZDtcbiAgaWYgKHNlbGVjdGVkID09PSB2b2lkIDApIHtcbiAgICBzZWxlY3RlZCA9IHt9O1xuICAgIHF1ZXJ5aGVscGVycy5hcHBseVBhdGhzKHNlbGVjdGVkLCBzY2hlbWEpO1xuICB9XG4gIGlmIChzZWxlY3RlZCA9PSBudWxsIHx8IE9iamVjdC5rZXlzKHNlbGVjdGVkKS5sZW5ndGggPT09IDApIHtcbiAgICByZXR1cm4ganNvbjtcbiAgfVxuXG4gIGZvciAoY29uc3QgcGF0aCBvZiBwYXRocykge1xuICAgIGlmIChzZWxlY3RlZFtwYXRoXSAhPSBudWxsICYmICFzZWxlY3RlZFtwYXRoXSkge1xuICAgICAgZGVsZXRlIGpzb25bcGF0aF07XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGpzb247XG59XG5cbi8qKlxuICogVGhlIHJldHVybiB2YWx1ZSBvZiB0aGlzIG1ldGhvZCBpcyB1c2VkIGluIGNhbGxzIHRvIFtgSlNPTi5zdHJpbmdpZnkoZG9jKWBdKGh0dHBzOi8vdGhlY29kZWJhcmJhcmlhbi5jb20vdGhlLTgwLTIwLWd1aWRlLXRvLWpzb24tc3RyaW5naWZ5LWluLWphdmFzY3JpcHQjdGhlLXRvanNvbi1mdW5jdGlvbikuXG4gKlxuICogVGhpcyBtZXRob2QgYWNjZXB0cyB0aGUgc2FtZSBvcHRpb25zIGFzIFtEb2N1bWVudCN0b09iamVjdF0oaHR0cHM6Ly9tb25nb29zZWpzLmNvbS9kb2NzL2FwaS9kb2N1bWVudC5odG1sI0RvY3VtZW50LnByb3RvdHlwZS50b09iamVjdCgpKS4gVG8gYXBwbHkgdGhlIG9wdGlvbnMgdG8gZXZlcnkgZG9jdW1lbnQgb2YgeW91ciBzY2hlbWEgYnkgZGVmYXVsdCwgc2V0IHlvdXIgW3NjaGVtYXNdKGh0dHBzOi8vbW9uZ29vc2Vqcy5jb20vZG9jcy9hcGkvc2NoZW1hLmh0bWwjU2NoZW1hKCkpIGB0b0pTT05gIG9wdGlvbiB0byB0aGUgc2FtZSBhcmd1bWVudC5cbiAqXG4gKiAgICAgc2NoZW1hLnNldCgndG9KU09OJywgeyB2aXJ0dWFsczogdHJ1ZSB9KTtcbiAqXG4gKiBUaGVyZSBpcyBvbmUgZGlmZmVyZW5jZSBiZXR3ZWVuIGB0b0pTT04oKWAgYW5kIGB0b09iamVjdCgpYCBvcHRpb25zLlxuICogV2hlbiB5b3UgY2FsbCBgdG9KU09OKClgLCB0aGUgW2BmbGF0dGVuTWFwc2Agb3B0aW9uXShodHRwczovL21vbmdvb3NlanMuY29tL2RvY3MvYXBpL2RvY3VtZW50Lmh0bWwjRG9jdW1lbnQucHJvdG90eXBlLnRvT2JqZWN0KCkpIGRlZmF1bHRzIHRvIGB0cnVlYCwgYmVjYXVzZSBgSlNPTi5zdHJpbmdpZnkoKWAgZG9lc24ndCBjb252ZXJ0IG1hcHMgdG8gb2JqZWN0cyBieSBkZWZhdWx0LlxuICogV2hlbiB5b3UgY2FsbCBgdG9PYmplY3QoKWAsIHRoZSBgZmxhdHRlbk1hcHNgIG9wdGlvbiBpcyBgZmFsc2VgIGJ5IGRlZmF1bHQuXG4gKlxuICogU2VlIFtzY2hlbWEgb3B0aW9uc10oaHR0cHM6Ly9tb25nb29zZWpzLmNvbS9kb2NzL2d1aWRlLmh0bWwjdG9KU09OKSBmb3IgbW9yZSBpbmZvcm1hdGlvbiBvbiBzZXR0aW5nIGB0b0pTT05gIG9wdGlvbiBkZWZhdWx0cy5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xuICogQHBhcmFtIHtCb29sZWFufSBbb3B0aW9ucy5mbGF0dGVuTWFwcz10cnVlXSBpZiB0cnVlLCBjb252ZXJ0IE1hcHMgdG8gW1BPSk9zXShodHRwczovL21hc3RlcmluZ2pzLmlvL3R1dG9yaWFscy9mdW5kYW1lbnRhbHMvcG9qbykuIFVzZWZ1bCBpZiB5b3Ugd2FudCB0byBgSlNPTi5zdHJpbmdpZnkoKWAgdGhlIHJlc3VsdC5cbiAqIEBwYXJhbSB7Qm9vbGVhbn0gW29wdGlvbnMuZmxhdHRlbk9iamVjdElkcz1mYWxzZV0gaWYgdHJ1ZSwgY29udmVydCBhbnkgT2JqZWN0SWRzIGluIHRoZSByZXN1bHQgdG8gMjQgY2hhcmFjdGVyIGhleCBzdHJpbmdzLlxuICogQHJldHVybiB7T2JqZWN0fVxuICogQHNlZSBEb2N1bWVudCN0b09iamVjdCBodHRwczovL21vbmdvb3NlanMuY29tL2RvY3MvYXBpL2RvY3VtZW50Lmh0bWwjRG9jdW1lbnQucHJvdG90eXBlLnRvT2JqZWN0KClcbiAqIEBzZWUgSlNPTi5zdHJpbmdpZnkoKSBpbiBKYXZhU2NyaXB0IGh0dHBzOi8vdGhlY29kZWJhcmJhcmlhbi5jb20vdGhlLTgwLTIwLWd1aWRlLXRvLWpzb24tc3RyaW5naWZ5LWluLWphdmFzY3JpcHQuaHRtbFxuICogQGFwaSBwdWJsaWNcbiAqIEBtZW1iZXJPZiBEb2N1bWVudFxuICogQGluc3RhbmNlXG4gKi9cblxuRG9jdW1lbnQucHJvdG90eXBlLnRvSlNPTiA9IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgcmV0dXJuIHRoaXMuJHRvT2JqZWN0KG9wdGlvbnMsIHRydWUpO1xufTtcblxuLyohXG4gKiBpZ25vcmVcbiAqL1xuXG5Eb2N1bWVudC5wcm90b3R5cGUub3duZXJEb2N1bWVudCA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gdGhpcztcbn07XG5cblxuLyoqXG4gKiBJZiB0aGlzIGRvY3VtZW50IGlzIGEgc3ViZG9jdW1lbnQgb3IgcG9wdWxhdGVkIGRvY3VtZW50LCByZXR1cm5zIHRoZSBkb2N1bWVudCdzXG4gKiBwYXJlbnQuIFJldHVybnMgdGhlIG9yaWdpbmFsIGRvY3VtZW50IGlmIHRoZXJlIGlzIG5vIHBhcmVudC5cbiAqXG4gKiBAcmV0dXJuIHtEb2N1bWVudH1cbiAqIEBhcGkgcHVibGljXG4gKiBAbWV0aG9kIHBhcmVudFxuICogQG1lbWJlck9mIERvY3VtZW50XG4gKiBAaW5zdGFuY2VcbiAqL1xuXG5Eb2N1bWVudC5wcm90b3R5cGUucGFyZW50ID0gZnVuY3Rpb24oKSB7XG4gIGlmICh0aGlzLiRpc1N1YmRvY3VtZW50IHx8IHRoaXMuJF9fLndhc1BvcHVsYXRlZCkge1xuICAgIHJldHVybiB0aGlzLiRfXy5wYXJlbnQ7XG4gIH1cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIEFsaWFzIGZvciBbYHBhcmVudCgpYF0oaHR0cHM6Ly9tb25nb29zZWpzLmNvbS9kb2NzL2FwaS9kb2N1bWVudC5odG1sI0RvY3VtZW50LnByb3RvdHlwZS5wYXJlbnQoKSkuIElmIHRoaXMgZG9jdW1lbnQgaXMgYSBzdWJkb2N1bWVudCBvciBwb3B1bGF0ZWRcbiAqIGRvY3VtZW50LCByZXR1cm5zIHRoZSBkb2N1bWVudCdzIHBhcmVudC4gUmV0dXJucyBgdW5kZWZpbmVkYCBvdGhlcndpc2UuXG4gKlxuICogQHJldHVybiB7RG9jdW1lbnR9XG4gKiBAYXBpIHB1YmxpY1xuICogQG1ldGhvZCAkcGFyZW50XG4gKiBAbWVtYmVyT2YgRG9jdW1lbnRcbiAqIEBpbnN0YW5jZVxuICovXG5cbkRvY3VtZW50LnByb3RvdHlwZS4kcGFyZW50ID0gRG9jdW1lbnQucHJvdG90eXBlLnBhcmVudDtcblxuLyoqXG4gKiBIZWxwZXIgZm9yIGNvbnNvbGUubG9nXG4gKlxuICogQHJldHVybiB7U3RyaW5nfVxuICogQGFwaSBwdWJsaWNcbiAqIEBtZXRob2QgaW5zcGVjdFxuICogQG1lbWJlck9mIERvY3VtZW50XG4gKiBAaW5zdGFuY2VcbiAqL1xuXG5Eb2N1bWVudC5wcm90b3R5cGUuaW5zcGVjdCA9IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgY29uc3QgaXNQT0pPID0gdXRpbHMuaXNQT0pPKG9wdGlvbnMpO1xuICBsZXQgb3B0cztcbiAgaWYgKGlzUE9KTykge1xuICAgIG9wdHMgPSBvcHRpb25zO1xuICAgIG9wdHMubWluaW1pemUgPSBmYWxzZTtcbiAgfVxuICBjb25zdCByZXQgPSB0aGlzLnRvT2JqZWN0KG9wdHMpO1xuXG4gIGlmIChyZXQgPT0gbnVsbCkge1xuICAgIC8vIElmIGB0b09iamVjdCgpYCByZXR1cm5zIG51bGwsIGB0aGlzYCBpcyBzdGlsbCBhbiBvYmplY3QsIHNvIGlmIGBpbnNwZWN0KClgXG4gICAgLy8gcHJpbnRzIG91dCBudWxsIHRoaXMgY2FuIGNhdXNlIHNvbWUgc2VyaW91cyBjb25mdXNpb24uIFNlZSBnaC03OTQyLlxuICAgIHJldHVybiAnTW9uZ29vc2VEb2N1bWVudCB7ICcgKyByZXQgKyAnIH0nO1xuICB9XG5cbiAgcmV0dXJuIHJldDtcbn07XG5cbmlmIChpbnNwZWN0LmN1c3RvbSkge1xuICAvLyBBdm9pZCBOb2RlIGRlcHJlY2F0aW9uIHdhcm5pbmcgREVQMDA3OVxuICBEb2N1bWVudC5wcm90b3R5cGVbaW5zcGVjdC5jdXN0b21dID0gRG9jdW1lbnQucHJvdG90eXBlLmluc3BlY3Q7XG59XG5cbi8qKlxuICogSGVscGVyIGZvciBjb25zb2xlLmxvZ1xuICpcbiAqIEByZXR1cm4ge1N0cmluZ31cbiAqIEBhcGkgcHVibGljXG4gKiBAbWV0aG9kIHRvU3RyaW5nXG4gKiBAbWVtYmVyT2YgRG9jdW1lbnRcbiAqIEBpbnN0YW5jZVxuICovXG5cbkRvY3VtZW50LnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uKCkge1xuICBjb25zdCByZXQgPSB0aGlzLmluc3BlY3QoKTtcbiAgaWYgKHR5cGVvZiByZXQgPT09ICdzdHJpbmcnKSB7XG4gICAgcmV0dXJuIHJldDtcbiAgfVxuICByZXR1cm4gaW5zcGVjdChyZXQpO1xufTtcblxuLyoqXG4gKiBSZXR1cm5zIHRydWUgaWYgdGhpcyBkb2N1bWVudCBpcyBlcXVhbCB0byBhbm90aGVyIGRvY3VtZW50LlxuICpcbiAqIERvY3VtZW50cyBhcmUgY29uc2lkZXJlZCBlcXVhbCB3aGVuIHRoZXkgaGF2ZSBtYXRjaGluZyBgX2lkYHMsIHVubGVzcyBuZWl0aGVyXG4gKiBkb2N1bWVudCBoYXMgYW4gYF9pZGAsIGluIHdoaWNoIGNhc2UgdGhpcyBmdW5jdGlvbiBmYWxscyBiYWNrIHRvIHVzaW5nXG4gKiBgZGVlcEVxdWFsKClgLlxuICpcbiAqIEBwYXJhbSB7RG9jdW1lbnR9IFtkb2NdIGEgZG9jdW1lbnQgdG8gY29tcGFyZS4gSWYgZmFsc3ksIHdpbGwgYWx3YXlzIHJldHVybiBcImZhbHNlXCIuXG4gKiBAcmV0dXJuIHtCb29sZWFufVxuICogQGFwaSBwdWJsaWNcbiAqIEBtZW1iZXJPZiBEb2N1bWVudFxuICogQGluc3RhbmNlXG4gKi9cblxuRG9jdW1lbnQucHJvdG90eXBlLmVxdWFscyA9IGZ1bmN0aW9uKGRvYykge1xuICBpZiAoIWRvYykge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIGNvbnN0IHRpZCA9IHRoaXMuJF9fZ2V0VmFsdWUoJ19pZCcpO1xuICBjb25zdCBkb2NpZCA9IGRvYy4kX18gIT0gbnVsbCA/IGRvYy4kX19nZXRWYWx1ZSgnX2lkJykgOiBkb2M7XG4gIGlmICghdGlkICYmICFkb2NpZCkge1xuICAgIHJldHVybiBkZWVwRXF1YWwodGhpcywgZG9jKTtcbiAgfVxuICByZXR1cm4gdGlkICYmIHRpZC5lcXVhbHNcbiAgICA/IHRpZC5lcXVhbHMoZG9jaWQpXG4gICAgOiB0aWQgPT09IGRvY2lkO1xufTtcblxuLyoqXG4gKiBQb3B1bGF0ZXMgcGF0aHMgb24gYW4gZXhpc3RpbmcgZG9jdW1lbnQuXG4gKlxuICogIyMjIyBFeGFtcGxlOlxuICpcbiAqICAgICAvLyBHaXZlbiBhIGRvY3VtZW50LCBgcG9wdWxhdGUoKWAgbGV0cyB5b3UgcHVsbCBpbiByZWZlcmVuY2VkIGRvY3NcbiAqICAgICBhd2FpdCBkb2MucG9wdWxhdGUoW1xuICogICAgICAgJ3N0b3JpZXMnLFxuICogICAgICAgeyBwYXRoOiAnZmFucycsIHNvcnQ6IHsgbmFtZTogLTEgfSB9XG4gKiAgICAgXSk7XG4gKiAgICAgZG9jLnBvcHVsYXRlZCgnc3RvcmllcycpOyAvLyBBcnJheSBvZiBPYmplY3RJZHNcbiAqICAgICBkb2Muc3Rvcmllc1swXS50aXRsZTsgLy8gJ0Nhc2lubyBSb3lhbGUnXG4gKiAgICAgZG9jLnBvcHVsYXRlZCgnZmFucycpOyAvLyBBcnJheSBvZiBPYmplY3RJZHNcbiAqXG4gKiAgICAgLy8gSWYgdGhlIHJlZmVyZW5jZWQgZG9jIGhhcyBiZWVuIGRlbGV0ZWQsIGBwb3B1bGF0ZSgpYCB3aWxsXG4gKiAgICAgLy8gcmVtb3ZlIHRoYXQgZW50cnkgZnJvbSB0aGUgYXJyYXkuXG4gKiAgICAgYXdhaXQgU3RvcnkuZGVsZXRlKHsgdGl0bGU6ICdDYXNpbm8gUm95YWxlJyB9KTtcbiAqICAgICBhd2FpdCBkb2MucG9wdWxhdGUoJ3N0b3JpZXMnKTsgLy8gRW1wdHkgYXJyYXlcbiAqXG4gKiAgICAgLy8gWW91IGNhbiBhbHNvIHBhc3MgYWRkaXRpb25hbCBxdWVyeSBvcHRpb25zIHRvIGBwb3B1bGF0ZSgpYCxcbiAqICAgICAvLyBsaWtlIHByb2plY3Rpb25zOlxuICogICAgIGF3YWl0IGRvYy5wb3B1bGF0ZSgnZmFucycsICctZW1haWwnKTtcbiAqICAgICBkb2MuZmFuc1swXS5lbWFpbCAvLyB1bmRlZmluZWQgYmVjYXVzZSBvZiAybmQgcGFyYW0gYHNlbGVjdGBcbiAqXG4gKiBAcGFyYW0ge1N0cmluZ3xPYmplY3R8QXJyYXl9IHBhdGggZWl0aGVyIHRoZSBwYXRoIHRvIHBvcHVsYXRlIG9yIGFuIG9iamVjdCBzcGVjaWZ5aW5nIGFsbCBwYXJhbWV0ZXJzLCBvciBlaXRoZXIgYW4gYXJyYXkgb2YgdGhvc2VcbiAqIEBwYXJhbSB7T2JqZWN0fFN0cmluZ30gW3NlbGVjdF0gRmllbGQgc2VsZWN0aW9uIGZvciB0aGUgcG9wdWxhdGlvbiBxdWVyeVxuICogQHBhcmFtIHtNb2RlbH0gW21vZGVsXSBUaGUgbW9kZWwgeW91IHdpc2ggdG8gdXNlIGZvciBwb3B1bGF0aW9uLiBJZiBub3Qgc3BlY2lmaWVkLCBwb3B1bGF0ZSB3aWxsIGxvb2sgdXAgdGhlIG1vZGVsIGJ5IHRoZSBuYW1lIGluIHRoZSBTY2hlbWEncyBgcmVmYCBmaWVsZC5cbiAqIEBwYXJhbSB7T2JqZWN0fSBbbWF0Y2hdIENvbmRpdGlvbnMgZm9yIHRoZSBwb3B1bGF0aW9uIHF1ZXJ5XG4gKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdIE9wdGlvbnMgZm9yIHRoZSBwb3B1bGF0aW9uIHF1ZXJ5IChzb3J0LCBldGMpXG4gKiBAcGFyYW0ge1N0cmluZ30gW29wdGlvbnMucGF0aD1udWxsXSBUaGUgcGF0aCB0byBwb3B1bGF0ZS5cbiAqIEBwYXJhbSB7c3RyaW5nfFBvcHVsYXRlT3B0aW9uc30gW29wdGlvbnMucG9wdWxhdGU9bnVsbF0gUmVjdXJzaXZlbHkgcG9wdWxhdGUgcGF0aHMgaW4gdGhlIHBvcHVsYXRlZCBkb2N1bWVudHMuIFNlZSBbZGVlcCBwb3B1bGF0ZSBkb2NzXShodHRwczovL21vbmdvb3NlanMuY29tL2RvY3MvcG9wdWxhdGUuaHRtbCNkZWVwLXBvcHVsYXRlKS5cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdGlvbnMucmV0YWluTnVsbFZhbHVlcz1mYWxzZV0gYnkgZGVmYXVsdCwgTW9uZ29vc2UgcmVtb3ZlcyBudWxsIGFuZCB1bmRlZmluZWQgdmFsdWVzIGZyb20gcG9wdWxhdGVkIGFycmF5cy4gVXNlIHRoaXMgb3B0aW9uIHRvIG1ha2UgYHBvcHVsYXRlKClgIHJldGFpbiBgbnVsbGAgYW5kIGB1bmRlZmluZWRgIGFycmF5IGVudHJpZXMuXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRpb25zLmdldHRlcnM9ZmFsc2VdIGlmIHRydWUsIE1vbmdvb3NlIHdpbGwgY2FsbCBhbnkgZ2V0dGVycyBkZWZpbmVkIG9uIHRoZSBgbG9jYWxGaWVsZGAuIEJ5IGRlZmF1bHQsIE1vbmdvb3NlIGdldHMgdGhlIHJhdyB2YWx1ZSBvZiBgbG9jYWxGaWVsZGAuIEZvciBleGFtcGxlLCB5b3Ugd291bGQgbmVlZCB0byBzZXQgdGhpcyBvcHRpb24gdG8gYHRydWVgIGlmIHlvdSB3YW50ZWQgdG8gW2FkZCBhIGBsb3dlcmNhc2VgIGdldHRlciB0byB5b3VyIGBsb2NhbEZpZWxkYF0oaHR0cHM6Ly9tb25nb29zZWpzLmNvbS9kb2NzL3NjaGVtYXR5cGVzLmh0bWwjc2NoZW1hdHlwZS1vcHRpb25zKS5cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdGlvbnMuY2xvbmU9ZmFsc2VdIFdoZW4geW91IGRvIGBCbG9nUG9zdC5maW5kKCkucG9wdWxhdGUoJ2F1dGhvcicpYCwgYmxvZyBwb3N0cyB3aXRoIHRoZSBzYW1lIGF1dGhvciB3aWxsIHNoYXJlIDEgY29weSBvZiBhbiBgYXV0aG9yYCBkb2MuIEVuYWJsZSB0aGlzIG9wdGlvbiB0byBtYWtlIE1vbmdvb3NlIGNsb25lIHBvcHVsYXRlZCBkb2NzIGJlZm9yZSBhc3NpZ25pbmcgdGhlbS5cbiAqIEBwYXJhbSB7T2JqZWN0fEZ1bmN0aW9ufSBbb3B0aW9ucy5tYXRjaD1udWxsXSBBZGQgYW4gYWRkaXRpb25hbCBmaWx0ZXIgdG8gdGhlIHBvcHVsYXRlIHF1ZXJ5LiBDYW4gYmUgYSBmaWx0ZXIgb2JqZWN0IGNvbnRhaW5pbmcgW01vbmdvREIgcXVlcnkgc3ludGF4XShodHRwczovL3d3dy5tb25nb2RiLmNvbS9kb2NzL21hbnVhbC90dXRvcmlhbC9xdWVyeS1kb2N1bWVudHMvKSwgb3IgYSBmdW5jdGlvbiB0aGF0IHJldHVybnMgYSBmaWx0ZXIgb2JqZWN0LlxuICogQHBhcmFtIHtGdW5jdGlvbn0gW29wdGlvbnMudHJhbnNmb3JtPW51bGxdIEZ1bmN0aW9uIHRoYXQgTW9uZ29vc2Ugd2lsbCBjYWxsIG9uIGV2ZXJ5IHBvcHVsYXRlZCBkb2N1bWVudCB0aGF0IGFsbG93cyB5b3UgdG8gdHJhbnNmb3JtIHRoZSBwb3B1bGF0ZWQgZG9jdW1lbnQuXG4gKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnMub3B0aW9ucz1udWxsXSBBZGRpdGlvbmFsIG9wdGlvbnMgbGlrZSBgbGltaXRgIGFuZCBgbGVhbmAuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY2FsbGJhY2tdIENhbGxiYWNrXG4gKiBAc2VlIHBvcHVsYXRpb24gaHR0cHM6Ly9tb25nb29zZWpzLmNvbS9kb2NzL3BvcHVsYXRlLmh0bWxcbiAqIEBzZWUgUXVlcnkjc2VsZWN0IGh0dHBzOi8vbW9uZ29vc2Vqcy5jb20vZG9jcy9hcGkvcXVlcnkuaHRtbCNRdWVyeS5wcm90b3R5cGUuc2VsZWN0KClcbiAqIEBzZWUgTW9kZWwucG9wdWxhdGUgaHR0cHM6Ly9tb25nb29zZWpzLmNvbS9kb2NzL2FwaS9tb2RlbC5odG1sI01vZGVsLnBvcHVsYXRlKClcbiAqIEBtZW1iZXJPZiBEb2N1bWVudFxuICogQGluc3RhbmNlXG4gKiBAcmV0dXJuIHtQcm9taXNlfG51bGx9IFJldHVybnMgYSBQcm9taXNlIGlmIG5vIGBjYWxsYmFja2AgaXMgZ2l2ZW4uXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbkRvY3VtZW50LnByb3RvdHlwZS5wb3B1bGF0ZSA9IGFzeW5jIGZ1bmN0aW9uIHBvcHVsYXRlKCkge1xuICBjb25zdCBwb3AgPSB7fTtcbiAgY29uc3QgYXJncyA9IFsuLi5hcmd1bWVudHNdO1xuICBpZiAodHlwZW9mIGFyZ3NbYXJncy5sZW5ndGggLSAxXSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHRocm93IG5ldyBNb25nb29zZUVycm9yKCdEb2N1bWVudC5wcm90b3R5cGUucG9wdWxhdGUoKSBubyBsb25nZXIgYWNjZXB0cyBhIGNhbGxiYWNrJyk7XG4gIH1cblxuICBpZiAoYXJncy5sZW5ndGggIT09IDApIHtcbiAgICAvLyB1c2UgaGFzaCB0byByZW1vdmUgZHVwbGljYXRlIHBhdGhzXG4gICAgY29uc3QgcmVzID0gdXRpbHMucG9wdWxhdGUuYXBwbHkobnVsbCwgYXJncyk7XG4gICAgZm9yIChjb25zdCBwb3B1bGF0ZU9wdGlvbnMgb2YgcmVzKSB7XG4gICAgICBwb3BbcG9wdWxhdGVPcHRpb25zLnBhdGhdID0gcG9wdWxhdGVPcHRpb25zO1xuICAgIH1cbiAgfVxuXG4gIGNvbnN0IHBhdGhzID0gdXRpbHMub2JqZWN0LnZhbHMocG9wKTtcbiAgbGV0IHRvcExldmVsTW9kZWwgPSB0aGlzLmNvbnN0cnVjdG9yO1xuICBpZiAodGhpcy4kX19pc05lc3RlZCkge1xuICAgIHRvcExldmVsTW9kZWwgPSB0aGlzLiRfX1tzY29wZVN5bWJvbF0uY29uc3RydWN0b3I7XG4gICAgY29uc3QgbmVzdGVkUGF0aCA9IHRoaXMuJF9fLm5lc3RlZFBhdGg7XG4gICAgcGF0aHMuZm9yRWFjaChmdW5jdGlvbihwb3B1bGF0ZU9wdGlvbnMpIHtcbiAgICAgIHBvcHVsYXRlT3B0aW9ucy5wYXRoID0gbmVzdGVkUGF0aCArICcuJyArIHBvcHVsYXRlT3B0aW9ucy5wYXRoO1xuICAgIH0pO1xuICB9XG5cbiAgLy8gVXNlIGAkc2Vzc2lvbigpYCBieSBkZWZhdWx0IGlmIHRoZSBkb2N1bWVudCBoYXMgYW4gYXNzb2NpYXRlZCBzZXNzaW9uXG4gIC8vIFNlZSBnaC02NzU0XG4gIGlmICh0aGlzLiRzZXNzaW9uKCkgIT0gbnVsbCkge1xuICAgIGNvbnN0IHNlc3Npb24gPSB0aGlzLiRzZXNzaW9uKCk7XG4gICAgcGF0aHMuZm9yRWFjaChwYXRoID0+IHtcbiAgICAgIGlmIChwYXRoLm9wdGlvbnMgPT0gbnVsbCkge1xuICAgICAgICBwYXRoLm9wdGlvbnMgPSB7IHNlc3Npb246IHNlc3Npb24gfTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgaWYgKCEoJ3Nlc3Npb24nIGluIHBhdGgub3B0aW9ucykpIHtcbiAgICAgICAgcGF0aC5vcHRpb25zLnNlc3Npb24gPSBzZXNzaW9uO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbiAgcGF0aHMuZm9yRWFjaChwID0+IHtcbiAgICBwLl9sb2NhbE1vZGVsID0gdG9wTGV2ZWxNb2RlbDtcbiAgfSk7XG5cbiAgcmV0dXJuIHRvcExldmVsTW9kZWwucG9wdWxhdGUodGhpcywgcGF0aHMpO1xufTtcblxuLyoqXG4gKiBHZXRzIGFsbCBwb3B1bGF0ZWQgZG9jdW1lbnRzIGFzc29jaWF0ZWQgd2l0aCB0aGlzIGRvY3VtZW50LlxuICpcbiAqIEBhcGkgcHVibGljXG4gKiBAcmV0dXJuIHtEb2N1bWVudFtdfSBhcnJheSBvZiBwb3B1bGF0ZWQgZG9jdW1lbnRzLiBFbXB0eSBhcnJheSBpZiB0aGVyZSBhcmUgbm8gcG9wdWxhdGVkIGRvY3VtZW50cyBhc3NvY2lhdGVkIHdpdGggdGhpcyBkb2N1bWVudC5cbiAqIEBtZW1iZXJPZiBEb2N1bWVudFxuICogQG1ldGhvZCAkZ2V0UG9wdWxhdGVkRG9jc1xuICogQGluc3RhbmNlXG4gKi9cblxuRG9jdW1lbnQucHJvdG90eXBlLiRnZXRQb3B1bGF0ZWREb2NzID0gZnVuY3Rpb24gJGdldFBvcHVsYXRlZERvY3MoKSB7XG4gIGxldCBrZXlzID0gW107XG4gIGlmICh0aGlzLiRfXy5wb3B1bGF0ZWQgIT0gbnVsbCkge1xuICAgIGtleXMgPSBrZXlzLmNvbmNhdChPYmplY3Qua2V5cyh0aGlzLiRfXy5wb3B1bGF0ZWQpKTtcbiAgfVxuICBsZXQgcmVzdWx0ID0gW107XG4gIGZvciAoY29uc3Qga2V5IG9mIGtleXMpIHtcbiAgICBjb25zdCB2YWx1ZSA9IHRoaXMuJGdldChrZXkpO1xuICAgIGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgICAgcmVzdWx0ID0gcmVzdWx0LmNvbmNhdCh2YWx1ZSk7XG4gICAgfSBlbHNlIGlmICh2YWx1ZSBpbnN0YW5jZW9mIERvY3VtZW50KSB7XG4gICAgICByZXN1bHQucHVzaCh2YWx1ZSk7XG4gICAgfVxuICB9XG4gIHJldHVybiByZXN1bHQ7XG59O1xuXG4vKipcbiAqIEdldHMgX2lkKHMpIHVzZWQgZHVyaW5nIHBvcHVsYXRpb24gb2YgdGhlIGdpdmVuIGBwYXRoYC5cbiAqXG4gKiAjIyMjIEV4YW1wbGU6XG4gKlxuICogICAgIGNvbnN0IGRvYyA9IGF3YWl0IE1vZGVsLmZpbmRPbmUoKS5wb3B1bGF0ZSgnYXV0aG9yJyk7XG4gKlxuICogICAgIGNvbnNvbGUubG9nKGRvYy5hdXRob3IubmFtZSk7IC8vIERyLlNldXNzXG4gKiAgICAgY29uc29sZS5sb2coZG9jLnBvcHVsYXRlZCgnYXV0aG9yJykpOyAvLyAnNTE0NGNmODA1MGYwNzFkOTc5YzExOGE3J1xuICpcbiAqIElmIHRoZSBwYXRoIHdhcyBub3QgcG9wdWxhdGVkLCByZXR1cm5zIGB1bmRlZmluZWRgLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBwYXRoXG4gKiBAcGFyYW0ge0FueX0gW3ZhbF1cbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc11cbiAqIEByZXR1cm4ge0FycmF5fE9iamVjdElkfE51bWJlcnxCdWZmZXJ8U3RyaW5nfHVuZGVmaW5lZH1cbiAqIEBtZW1iZXJPZiBEb2N1bWVudFxuICogQGluc3RhbmNlXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbkRvY3VtZW50LnByb3RvdHlwZS5wb3B1bGF0ZWQgPSBmdW5jdGlvbihwYXRoLCB2YWwsIG9wdGlvbnMpIHtcbiAgLy8gdmFsIGFuZCBvcHRpb25zIGFyZSBpbnRlcm5hbFxuICBpZiAodmFsID09IG51bGwgfHwgdmFsID09PSB0cnVlKSB7XG4gICAgaWYgKCF0aGlzLiRfXy5wb3B1bGF0ZWQpIHtcbiAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfVxuICAgIGlmICh0eXBlb2YgcGF0aCAhPT0gJ3N0cmluZycpIHtcbiAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfVxuXG4gICAgLy8gTWFwIHBhdGhzIGNhbiBiZSBwb3B1bGF0ZWQgd2l0aCBlaXRoZXIgYHBhdGguJCpgIG9yIGp1c3QgYHBhdGhgXG4gICAgY29uc3QgX3BhdGggPSBwYXRoLmVuZHNXaXRoKCcuJConKSA/IHBhdGgucmVwbGFjZSgvXFwuXFwkXFwqJC8sICcnKSA6IHBhdGg7XG5cbiAgICBjb25zdCB2ID0gdGhpcy4kX18ucG9wdWxhdGVkW19wYXRoXTtcbiAgICBpZiAodikge1xuICAgICAgcmV0dXJuIHZhbCA9PT0gdHJ1ZSA/IHYgOiB2LnZhbHVlO1xuICAgIH1cbiAgICByZXR1cm4gdW5kZWZpbmVkO1xuICB9XG5cbiAgdGhpcy4kX18ucG9wdWxhdGVkIHx8ICh0aGlzLiRfXy5wb3B1bGF0ZWQgPSB7fSk7XG4gIHRoaXMuJF9fLnBvcHVsYXRlZFtwYXRoXSA9IHsgdmFsdWU6IHZhbCwgb3B0aW9uczogb3B0aW9ucyB9O1xuXG4gIC8vIElmIHRoaXMgd2FzIGEgbmVzdGVkIHBvcHVsYXRlLCBtYWtlIHN1cmUgZWFjaCBwb3B1bGF0ZWQgZG9jIGtub3dzXG4gIC8vIGFib3V0IGl0cyBwb3B1bGF0ZWQgY2hpbGRyZW4gKGdoLTc2ODUpXG4gIGNvbnN0IHBpZWNlcyA9IHBhdGguc3BsaXQoJy4nKTtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBwaWVjZXMubGVuZ3RoIC0gMTsgKytpKSB7XG4gICAgY29uc3Qgc3VicGF0aCA9IHBpZWNlcy5zbGljZSgwLCBpICsgMSkuam9pbignLicpO1xuICAgIGNvbnN0IHN1YmRvYyA9IHRoaXMuJGdldChzdWJwYXRoKTtcbiAgICBpZiAoc3ViZG9jICE9IG51bGwgJiYgc3ViZG9jLiRfXyAhPSBudWxsICYmIHRoaXMuJHBvcHVsYXRlZChzdWJwYXRoKSkge1xuICAgICAgY29uc3QgcmVzdCA9IHBpZWNlcy5zbGljZShpICsgMSkuam9pbignLicpO1xuICAgICAgc3ViZG9jLiRwb3B1bGF0ZWQocmVzdCwgdmFsLCBvcHRpb25zKTtcbiAgICAgIC8vIE5vIG5lZWQgdG8gY29udGludWUgYmVjYXVzZSB0aGUgYWJvdmUgcmVjdXJzaW9uIHNob3VsZCB0YWtlIGNhcmUgb2ZcbiAgICAgIC8vIG1hcmtpbmcgdGhlIHJlc3Qgb2YgdGhlIGRvY3MgYXMgcG9wdWxhdGVkXG4gICAgICBicmVhaztcbiAgICB9XG4gIH1cblxuICByZXR1cm4gdmFsO1xufTtcblxuLyoqXG4gKiBBbGlhcyBvZiBbYC5wb3B1bGF0ZWRgXShodHRwczovL21vbmdvb3NlanMuY29tL2RvY3MvYXBpL2RvY3VtZW50Lmh0bWwjRG9jdW1lbnQucHJvdG90eXBlLnBvcHVsYXRlZCgpKS5cbiAqXG4gKiBAbWV0aG9kICRwb3B1bGF0ZWRcbiAqIEBtZW1iZXJPZiBEb2N1bWVudFxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5Eb2N1bWVudC5wcm90b3R5cGUuJHBvcHVsYXRlZCA9IERvY3VtZW50LnByb3RvdHlwZS5wb3B1bGF0ZWQ7XG5cbi8qKlxuICogVGhyb3dzIGFuIGVycm9yIGlmIGEgZ2l2ZW4gcGF0aCBpcyBub3QgcG9wdWxhdGVkXG4gKlxuICogIyMjIyBFeGFtcGxlOlxuICpcbiAqICAgICBjb25zdCBkb2MgPSBhd2FpdCBNb2RlbC5maW5kT25lKCkucG9wdWxhdGUoJ2F1dGhvcicpO1xuICpcbiAqICAgICBkb2MuJGFzc2VydFBvcHVsYXRlZCgnYXV0aG9yJyk7IC8vIGRvZXMgbm90IHRocm93XG4gKiAgICAgZG9jLiRhc3NlcnRQb3B1bGF0ZWQoJ290aGVyIHBhdGgnKTsgLy8gdGhyb3dzIGFuIGVycm9yXG4gKlxuICogICAgIC8vIE1hbnVhbGx5IHBvcHVsYXRlIGFuZCBhc3NlcnQgaW4gb25lIGNhbGwuIFRoZSBmb2xsb3dpbmcgZG9lc1xuICogICAgIC8vIGBkb2MuJHNldCh7IGxpa2VzIH0pYCBiZWZvcmUgYXNzZXJ0aW5nLlxuICogICAgIGRvYy4kYXNzZXJ0UG9wdWxhdGVkKCdsaWtlcycsIHsgbGlrZXMgfSk7XG4gKlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfFN0cmluZ1tdfSBwYXRoIHBhdGggb3IgYXJyYXkgb2YgcGF0aHMgdG8gY2hlY2suIGAkYXNzZXJ0UG9wdWxhdGVkYCB0aHJvd3MgaWYgYW55IG9mIHRoZSBnaXZlbiBwYXRocyBpcyBub3QgcG9wdWxhdGVkLlxuICogQHBhcmFtIHtPYmplY3R9IFt2YWx1ZXNdIG9wdGlvbmFsIHZhbHVlcyB0byBgJHNldCgpYC4gQ29udmVuaWVudCBpZiB5b3Ugd2FudCB0byBtYW51YWxseSBwb3B1bGF0ZSBhIHBhdGggYW5kIGFzc2VydCB0aGF0IHRoZSBwYXRoIHdhcyBwb3B1bGF0ZWQgaW4gMSBjYWxsLlxuICogQHJldHVybiB7RG9jdW1lbnR9IHRoaXNcbiAqIEBtZW1iZXJPZiBEb2N1bWVudFxuICogQG1ldGhvZCAkYXNzZXJ0UG9wdWxhdGVkXG4gKiBAaW5zdGFuY2VcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuRG9jdW1lbnQucHJvdG90eXBlLiRhc3NlcnRQb3B1bGF0ZWQgPSBmdW5jdGlvbiAkYXNzZXJ0UG9wdWxhdGVkKHBhdGgsIHZhbHVlcykge1xuICBpZiAoQXJyYXkuaXNBcnJheShwYXRoKSkge1xuICAgIHBhdGguZm9yRWFjaChwID0+IHRoaXMuJGFzc2VydFBvcHVsYXRlZChwLCB2YWx1ZXMpKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIGlmIChhcmd1bWVudHMubGVuZ3RoID4gMSkge1xuICAgIHRoaXMuJHNldCh2YWx1ZXMpO1xuICB9XG5cbiAgaWYgKCF0aGlzLiRwb3B1bGF0ZWQocGF0aCkpIHtcbiAgICB0aHJvdyBuZXcgTW9uZ29vc2VFcnJvcihgRXhwZWN0ZWQgcGF0aCBcIiR7cGF0aH1cIiB0byBiZSBwb3B1bGF0ZWRgKTtcbiAgfVxuXG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBUYWtlcyBhIHBvcHVsYXRlZCBmaWVsZCBhbmQgcmV0dXJucyBpdCB0byBpdHMgdW5wb3B1bGF0ZWQgc3RhdGUuXG4gKlxuICogIyMjIyBFeGFtcGxlOlxuICpcbiAqICAgICBNb2RlbC5maW5kT25lKCkucG9wdWxhdGUoJ2F1dGhvcicpLmV4ZWMoZnVuY3Rpb24gKGVyciwgZG9jKSB7XG4gKiAgICAgICBjb25zb2xlLmxvZyhkb2MuYXV0aG9yLm5hbWUpOyAvLyBEci5TZXVzc1xuICogICAgICAgY29uc29sZS5sb2coZG9jLmRlcG9wdWxhdGUoJ2F1dGhvcicpKTtcbiAqICAgICAgIGNvbnNvbGUubG9nKGRvYy5hdXRob3IpOyAvLyAnNTE0NGNmODA1MGYwNzFkOTc5YzExOGE3J1xuICogICAgIH0pXG4gKlxuICogSWYgdGhlIHBhdGggd2FzIG5vdCBwcm92aWRlZCwgdGhlbiBhbGwgcG9wdWxhdGVkIGZpZWxkcyBhcmUgcmV0dXJuZWQgdG8gdGhlaXIgdW5wb3B1bGF0ZWQgc3RhdGUuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd8U3RyaW5nW119IFtwYXRoXSBTcGVjaWZpYyBQYXRoIHRvIGRlcG9wdWxhdGUuIElmIHVuc2V0LCB3aWxsIGRlcG9wdWxhdGUgYWxsIHBhdGhzIG9uIHRoZSBEb2N1bWVudC4gT3IgbXVsdGlwbGUgc3BhY2UtZGVsaW1pdGVkIHBhdGhzLlxuICogQHJldHVybiB7RG9jdW1lbnR9IHRoaXNcbiAqIEBzZWUgRG9jdW1lbnQucG9wdWxhdGUgaHR0cHM6Ly9tb25nb29zZWpzLmNvbS9kb2NzL2FwaS9kb2N1bWVudC5odG1sI0RvY3VtZW50LnByb3RvdHlwZS5wb3B1bGF0ZSgpXG4gKiBAYXBpIHB1YmxpY1xuICogQG1lbWJlck9mIERvY3VtZW50XG4gKiBAaW5zdGFuY2VcbiAqL1xuXG5Eb2N1bWVudC5wcm90b3R5cGUuZGVwb3B1bGF0ZSA9IGZ1bmN0aW9uKHBhdGgpIHtcbiAgaWYgKHR5cGVvZiBwYXRoID09PSAnc3RyaW5nJykge1xuICAgIHBhdGggPSBwYXRoLmluZGV4T2YoJyAnKSA9PT0gLTEgPyBbcGF0aF0gOiBwYXRoLnNwbGl0KCcgJyk7XG4gIH1cblxuICBsZXQgcG9wdWxhdGVkSWRzO1xuICBjb25zdCB2aXJ0dWFsS2V5cyA9IHRoaXMuJCRwb3B1bGF0ZWRWaXJ0dWFscyA/IE9iamVjdC5rZXlzKHRoaXMuJCRwb3B1bGF0ZWRWaXJ0dWFscykgOiBbXTtcbiAgY29uc3QgcG9wdWxhdGVkID0gdGhpcy4kX18gJiYgdGhpcy4kX18ucG9wdWxhdGVkIHx8IHt9O1xuXG4gIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAwKSB7XG4gICAgLy8gRGVwb3B1bGF0ZSBhbGxcbiAgICBmb3IgKGNvbnN0IHZpcnR1YWxLZXkgb2YgdmlydHVhbEtleXMpIHtcbiAgICAgIGRlbGV0ZSB0aGlzLiQkcG9wdWxhdGVkVmlydHVhbHNbdmlydHVhbEtleV07XG4gICAgICBkZWxldGUgdGhpcy5fZG9jW3ZpcnR1YWxLZXldO1xuICAgICAgZGVsZXRlIHBvcHVsYXRlZFt2aXJ0dWFsS2V5XTtcbiAgICB9XG5cbiAgICBjb25zdCBrZXlzID0gT2JqZWN0LmtleXMocG9wdWxhdGVkKTtcblxuICAgIGZvciAoY29uc3Qga2V5IG9mIGtleXMpIHtcbiAgICAgIHBvcHVsYXRlZElkcyA9IHRoaXMuJHBvcHVsYXRlZChrZXkpO1xuICAgICAgaWYgKCFwb3B1bGF0ZWRJZHMpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBkZWxldGUgcG9wdWxhdGVkW2tleV07XG4gICAgICB1dGlscy5zZXRWYWx1ZShrZXksIHBvcHVsYXRlZElkcywgdGhpcy5fZG9jKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICBmb3IgKGNvbnN0IHNpbmdsZVBhdGggb2YgcGF0aCkge1xuICAgIHBvcHVsYXRlZElkcyA9IHRoaXMuJHBvcHVsYXRlZChzaW5nbGVQYXRoKTtcbiAgICBkZWxldGUgcG9wdWxhdGVkW3NpbmdsZVBhdGhdO1xuXG4gICAgaWYgKHZpcnR1YWxLZXlzLmluZGV4T2Yoc2luZ2xlUGF0aCkgIT09IC0xKSB7XG4gICAgICBkZWxldGUgdGhpcy4kJHBvcHVsYXRlZFZpcnR1YWxzW3NpbmdsZVBhdGhdO1xuICAgICAgZGVsZXRlIHRoaXMuX2RvY1tzaW5nbGVQYXRoXTtcbiAgICB9IGVsc2UgaWYgKHBvcHVsYXRlZElkcykge1xuICAgICAgdXRpbHMuc2V0VmFsdWUoc2luZ2xlUGF0aCwgcG9wdWxhdGVkSWRzLCB0aGlzLl9kb2MpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gdGhpcztcbn07XG5cblxuLyoqXG4gKiBSZXR1cm5zIHRoZSBmdWxsIHBhdGggdG8gdGhpcyBkb2N1bWVudC5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gW3BhdGhdXG4gKiBAcmV0dXJuIHtTdHJpbmd9XG4gKiBAYXBpIHByaXZhdGVcbiAqIEBtZXRob2QgJF9fZnVsbFBhdGhcbiAqIEBtZW1iZXJPZiBEb2N1bWVudFxuICogQGluc3RhbmNlXG4gKi9cblxuRG9jdW1lbnQucHJvdG90eXBlLiRfX2Z1bGxQYXRoID0gZnVuY3Rpb24ocGF0aCkge1xuICAvLyBvdmVycmlkZGVuIGluIFN1YkRvY3VtZW50c1xuICByZXR1cm4gcGF0aCB8fCAnJztcbn07XG5cbi8qKlxuICogUmV0dXJucyB0aGUgY2hhbmdlcyB0aGF0IGhhcHBlbmVkIHRvIHRoZSBkb2N1bWVudFxuICogaW4gdGhlIGZvcm1hdCB0aGF0IHdpbGwgYmUgc2VudCB0byBNb25nb0RCLlxuICpcbiAqICMjIyMgRXhhbXBsZTpcbiAqXG4gKiAgICAgY29uc3QgdXNlclNjaGVtYSA9IG5ldyBTY2hlbWEoe1xuICogICAgICAgbmFtZTogU3RyaW5nLFxuICogICAgICAgYWdlOiBOdW1iZXIsXG4gKiAgICAgICBjb3VudHJ5OiBTdHJpbmdcbiAqICAgICB9KTtcbiAqICAgICBjb25zdCBVc2VyID0gbW9uZ29vc2UubW9kZWwoJ1VzZXInLCB1c2VyU2NoZW1hKTtcbiAqICAgICBjb25zdCB1c2VyID0gYXdhaXQgVXNlci5jcmVhdGUoe1xuICogICAgICAgbmFtZTogJ0hhZmV6JyxcbiAqICAgICAgIGFnZTogMjUsXG4gKiAgICAgICBjb3VudHJ5OiAnRWd5cHQnXG4gKiAgICAgfSk7XG4gKlxuICogICAgIC8vIHJldHVybnMgYW4gZW1wdHkgb2JqZWN0LCBubyBjaGFuZ2VzIGhhcHBlbmVkIHlldFxuICogICAgIHVzZXIuZ2V0Q2hhbmdlcygpOyAvLyB7IH1cbiAqXG4gKiAgICAgdXNlci5jb3VudHJ5ID0gdW5kZWZpbmVkO1xuICogICAgIHVzZXIuYWdlID0gMjY7XG4gKlxuICogICAgIHVzZXIuZ2V0Q2hhbmdlcygpOyAvLyB7ICRzZXQ6IHsgYWdlOiAyNiB9LCB7ICR1bnNldDogeyBjb3VudHJ5OiAxIH0gfSB9XG4gKlxuICogICAgIGF3YWl0IHVzZXIuc2F2ZSgpO1xuICpcbiAqICAgICB1c2VyLmdldENoYW5nZXMoKTsgLy8geyB9XG4gKlxuICogTW9kaWZ5aW5nIHRoZSBvYmplY3QgdGhhdCBgZ2V0Q2hhbmdlcygpYCByZXR1cm5zIGRvZXMgbm90IGFmZmVjdCB0aGUgZG9jdW1lbnQnc1xuICogY2hhbmdlIHRyYWNraW5nIHN0YXRlLiBFdmVuIGlmIHlvdSBgZGVsZXRlIHVzZXIuZ2V0Q2hhbmdlcygpLiRzZXRgLCBNb25nb29zZVxuICogd2lsbCBzdGlsbCBzZW5kIGEgYCRzZXRgIHRvIHRoZSBzZXJ2ZXIuXG4gKlxuICogQHJldHVybiB7T2JqZWN0fVxuICogQGFwaSBwdWJsaWNcbiAqIEBtZXRob2QgZ2V0Q2hhbmdlc1xuICogQG1lbWJlck9mIERvY3VtZW50XG4gKiBAaW5zdGFuY2VcbiAqL1xuXG5Eb2N1bWVudC5wcm90b3R5cGUuZ2V0Q2hhbmdlcyA9IGZ1bmN0aW9uKCkge1xuICBjb25zdCBkZWx0YSA9IHRoaXMuJF9fZGVsdGEoKTtcbiAgY29uc3QgY2hhbmdlcyA9IGRlbHRhID8gZGVsdGFbMV0gOiB7fTtcbiAgcmV0dXJuIGNoYW5nZXM7XG59O1xuXG4vKipcbiAqIFJldHVybnMgYSBjb3B5IG9mIHRoaXMgZG9jdW1lbnQgd2l0aCBhIGRlZXAgY2xvbmUgb2YgYF9kb2NgIGFuZCBgJF9fYC5cbiAqXG4gKiBAcmV0dXJuIHtEb2N1bWVudH0gYSBjb3B5IG9mIHRoaXMgZG9jdW1lbnRcbiAqIEBhcGkgcHVibGljXG4gKiBAbWV0aG9kICRjbG9uZVxuICogQG1lbWJlck9mIERvY3VtZW50XG4gKiBAaW5zdGFuY2VcbiAqL1xuXG5Eb2N1bWVudC5wcm90b3R5cGUuJGNsb25lID0gZnVuY3Rpb24oKSB7XG4gIGNvbnN0IE1vZGVsID0gdGhpcy5jb25zdHJ1Y3RvcjtcbiAgY29uc3QgY2xvbmVkRG9jID0gbmV3IE1vZGVsKCk7XG4gIGNsb25lZERvYy4kaXNOZXcgPSB0aGlzLiRpc05ldztcbiAgaWYgKHRoaXMuX2RvYykge1xuICAgIGNsb25lZERvYy5fZG9jID0gY2xvbmUodGhpcy5fZG9jKTtcbiAgfVxuICBpZiAodGhpcy4kX18pIHtcbiAgICBjb25zdCBDYWNoZSA9IHRoaXMuJF9fLmNvbnN0cnVjdG9yO1xuICAgIGNvbnN0IGNsb25lZENhY2hlID0gbmV3IENhY2hlKCk7XG4gICAgZm9yIChjb25zdCBrZXkgb2YgT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXModGhpcy4kX18pKSB7XG4gICAgICBpZiAoa2V5ID09PSAnYWN0aXZlUGF0aHMnKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgY2xvbmVkQ2FjaGVba2V5XSA9IGNsb25lKHRoaXMuJF9fW2tleV0pO1xuICAgIH1cbiAgICBPYmplY3QuYXNzaWduKGNsb25lZENhY2hlLmFjdGl2ZVBhdGhzLCBjbG9uZSh7IC4uLnRoaXMuJF9fLmFjdGl2ZVBhdGhzIH0pKTtcbiAgICBjbG9uZWREb2MuJF9fID0gY2xvbmVkQ2FjaGU7XG4gIH1cbiAgcmV0dXJuIGNsb25lZERvYztcbn07XG5cbi8qIVxuICogTW9kdWxlIGV4cG9ydHMuXG4gKi9cblxuRG9jdW1lbnQuVmFsaWRhdGlvbkVycm9yID0gVmFsaWRhdGlvbkVycm9yO1xubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzID0gRG9jdW1lbnQ7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/mongoose/lib/document.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/mongoose/lib/documentProvider.js":
/*!*******************************************************!*\
  !*** ./node_modules/mongoose/lib/documentProvider.js ***!
  \*******************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\n\n/* eslint-env browser */\n\n/*!\n * Module dependencies.\n */\nconst Document = __webpack_require__(/*! ./document.js */ \"(ssr)/./node_modules/mongoose/lib/document.js\");\nconst BrowserDocument = __webpack_require__(/*! ./browserDocument.js */ \"(ssr)/./node_modules/mongoose/lib/browserDocument.js\");\n\nlet isBrowser = false;\n\n/**\n * Returns the Document constructor for the current context\n *\n * @api private\n */\nmodule.exports = function documentProvider() {\n  if (isBrowser) {\n    return BrowserDocument;\n  }\n  return Document;\n};\n\n/*!\n * ignore\n */\nmodule.exports.setBrowser = function(flag) {\n  isBrowser = flag;\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbW9uZ29vc2UvbGliL2RvY3VtZW50UHJvdmlkZXIuanMiLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWI7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLG1CQUFPLENBQUMsb0VBQWU7QUFDeEMsd0JBQXdCLG1CQUFPLENBQUMsa0ZBQXNCOztBQUV0RDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vYXBwMS8uL25vZGVfbW9kdWxlcy9tb25nb29zZS9saWIvZG9jdW1lbnRQcm92aWRlci5qcz80NjUzIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxuLyogZXNsaW50LWVudiBicm93c2VyICovXG5cbi8qIVxuICogTW9kdWxlIGRlcGVuZGVuY2llcy5cbiAqL1xuY29uc3QgRG9jdW1lbnQgPSByZXF1aXJlKCcuL2RvY3VtZW50LmpzJyk7XG5jb25zdCBCcm93c2VyRG9jdW1lbnQgPSByZXF1aXJlKCcuL2Jyb3dzZXJEb2N1bWVudC5qcycpO1xuXG5sZXQgaXNCcm93c2VyID0gZmFsc2U7XG5cbi8qKlxuICogUmV0dXJucyB0aGUgRG9jdW1lbnQgY29uc3RydWN0b3IgZm9yIHRoZSBjdXJyZW50IGNvbnRleHRcbiAqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBkb2N1bWVudFByb3ZpZGVyKCkge1xuICBpZiAoaXNCcm93c2VyKSB7XG4gICAgcmV0dXJuIEJyb3dzZXJEb2N1bWVudDtcbiAgfVxuICByZXR1cm4gRG9jdW1lbnQ7XG59O1xuXG4vKiFcbiAqIGlnbm9yZVxuICovXG5tb2R1bGUuZXhwb3J0cy5zZXRCcm93c2VyID0gZnVuY3Rpb24oZmxhZykge1xuICBpc0Jyb3dzZXIgPSBmbGFnO1xufTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/mongoose/lib/documentProvider.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/mongoose/lib/driver.js":
/*!*********************************************!*\
  !*** ./node_modules/mongoose/lib/driver.js ***!
  \*********************************************/
/***/ ((module) => {

eval("\n\n/*!\n * ignore\n */\n\nlet driver = null;\n\nmodule.exports.get = function() {\n  return driver;\n};\n\nmodule.exports.set = function(v) {\n  driver = v;\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbW9uZ29vc2UvbGliL2RyaXZlci5qcyIsIm1hcHBpbmdzIjoiQUFBYTs7QUFFYjtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsa0JBQWtCO0FBQ2xCO0FBQ0E7O0FBRUEsa0JBQWtCO0FBQ2xCO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9hcHAxLy4vbm9kZV9tb2R1bGVzL21vbmdvb3NlL2xpYi9kcml2ZXIuanM/ZDg1YSJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbi8qIVxuICogaWdub3JlXG4gKi9cblxubGV0IGRyaXZlciA9IG51bGw7XG5cbm1vZHVsZS5leHBvcnRzLmdldCA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gZHJpdmVyO1xufTtcblxubW9kdWxlLmV4cG9ydHMuc2V0ID0gZnVuY3Rpb24odikge1xuICBkcml2ZXIgPSB2O1xufTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/mongoose/lib/driver.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/mongoose/lib/drivers/node-mongodb-native/collection.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/mongoose/lib/drivers/node-mongodb-native/collection.js ***!
  \*****************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\n\n/*!\n * Module dependencies.\n */\n\nconst MongooseCollection = __webpack_require__(/*! ../../collection */ \"(ssr)/./node_modules/mongoose/lib/collection.js\");\nconst MongooseError = __webpack_require__(/*! ../../error/mongooseError */ \"(ssr)/./node_modules/mongoose/lib/error/mongooseError.js\");\nconst Collection = (__webpack_require__(/*! mongodb */ \"(ssr)/./node_modules/mongodb/lib/index.js\").Collection);\nconst ObjectId = __webpack_require__(/*! ../../types/objectid */ \"(ssr)/./node_modules/mongoose/lib/types/objectid.js\");\nconst getConstructorName = __webpack_require__(/*! ../../helpers/getConstructorName */ \"(ssr)/./node_modules/mongoose/lib/helpers/getConstructorName.js\");\nconst internalToObjectOptions = (__webpack_require__(/*! ../../options */ \"(ssr)/./node_modules/mongoose/lib/options.js\").internalToObjectOptions);\nconst stream = __webpack_require__(/*! stream */ \"stream\");\nconst util = __webpack_require__(/*! util */ \"util\");\n\n/**\n * A [node-mongodb-native](https://github.com/mongodb/node-mongodb-native) collection implementation.\n *\n * All methods methods from the [node-mongodb-native](https://github.com/mongodb/node-mongodb-native) driver are copied and wrapped in queue management.\n *\n * @inherits Collection https://mongodb.github.io/node-mongodb-native/4.9/classes/Collection.html\n * @api private\n */\n\nfunction NativeCollection(name, conn, options) {\n  this.collection = null;\n  this.Promise = options.Promise || Promise;\n  this.modelName = options.modelName;\n  delete options.modelName;\n  this._closed = false;\n  MongooseCollection.apply(this, arguments);\n}\n\n/*!\n * Inherit from abstract Collection.\n */\n\nObject.setPrototypeOf(NativeCollection.prototype, MongooseCollection.prototype);\n\n/**\n * Called when the connection opens.\n *\n * @api private\n */\n\nNativeCollection.prototype.onOpen = function() {\n  this.collection = this.conn.db.collection(this.name);\n  MongooseCollection.prototype.onOpen.call(this);\n  return this.collection;\n};\n\n/**\n * Called when the connection closes\n *\n * @api private\n */\n\nNativeCollection.prototype.onClose = function(force) {\n  MongooseCollection.prototype.onClose.call(this, force);\n};\n\n/**\n * Helper to get the collection, in case `this.collection` isn't set yet.\n * May happen if `bufferCommands` is false and created the model when\n * Mongoose was disconnected.\n *\n * @api private\n */\n\nNativeCollection.prototype._getCollection = function _getCollection() {\n  if (this.collection) {\n    return this.collection;\n  }\n  if (this.conn.db != null) {\n    this.collection = this.conn.db.collection(this.name);\n    return this.collection;\n  }\n  return null;\n};\n\n/*!\n * ignore\n */\n\nconst syncCollectionMethods = { watch: true, find: true, aggregate: true };\n\n/**\n * Copy the collection methods and make them subject to queues\n * @param {Number|String} I\n * @api private\n */\n\nfunction iter(i) {\n  NativeCollection.prototype[i] = function() {\n    const collection = this._getCollection();\n    const args = Array.from(arguments);\n    const _this = this;\n    const globalDebug = _this &&\n      _this.conn &&\n      _this.conn.base &&\n      _this.conn.base.options &&\n      _this.conn.base.options.debug;\n    const connectionDebug = _this &&\n      _this.conn &&\n      _this.conn.options &&\n      _this.conn.options.debug;\n    const debug = connectionDebug == null ? globalDebug : connectionDebug;\n    const lastArg = arguments[arguments.length - 1];\n    const opId = new ObjectId();\n\n    // If user force closed, queueing will hang forever. See #5664\n    if (this.conn.$wasForceClosed) {\n      const error = new MongooseError('Connection was force closed');\n      if (args.length > 0 &&\n        typeof args[args.length - 1] === 'function') {\n        args[args.length - 1](error);\n        return;\n      } else {\n        throw error;\n      }\n    }\n\n    let _args = args;\n    let callback = null;\n    if (this._shouldBufferCommands() && this.buffer) {\n      this.conn.emit('buffer', {\n        _id: opId,\n        modelName: _this.modelName,\n        collectionName: _this.name,\n        method: i,\n        args: args\n      });\n\n      let callback;\n      let _args = args;\n      let promise = null;\n      let timeout = null;\n      if (syncCollectionMethods[i] && typeof lastArg === 'function') {\n        this.addQueue(() => {\n          lastArg.call(this, null, this[i].apply(this, _args.slice(0, _args.length - 1)));\n        }, []);\n      } else if (syncCollectionMethods[i]) {\n        promise = new Promise((resolve, reject) => {\n          callback = function collectionOperationCallback(err, res) {\n            if (timeout != null) {\n              clearTimeout(timeout);\n            }\n            if (err != null) {\n              return reject(err);\n            }\n            resolve(res);\n          };\n          _args = args.concat([callback]);\n          this.addQueue(i, _args);\n        });\n      } else if (typeof lastArg === 'function') {\n        callback = function collectionOperationCallback() {\n          if (timeout != null) {\n            clearTimeout(timeout);\n          }\n          return lastArg.apply(this, arguments);\n        };\n        _args = args.slice(0, args.length - 1).concat([callback]);\n      } else {\n        promise = new Promise((resolve, reject) => {\n          callback = function collectionOperationCallback(err, res) {\n            if (timeout != null) {\n              clearTimeout(timeout);\n            }\n            if (err != null) {\n              return reject(err);\n            }\n            resolve(res);\n          };\n          _args = args.concat([callback]);\n          this.addQueue(i, _args);\n        });\n      }\n\n      const bufferTimeoutMS = this._getBufferTimeoutMS();\n      timeout = setTimeout(() => {\n        const removed = this.removeQueue(i, _args);\n        if (removed) {\n          const message = 'Operation `' + this.name + '.' + i + '()` buffering timed out after ' +\n            bufferTimeoutMS + 'ms';\n          const err = new MongooseError(message);\n          this.conn.emit('buffer-end', { _id: opId, modelName: _this.modelName, collectionName: _this.name, method: i, error: err });\n          callback(err);\n        }\n      }, bufferTimeoutMS);\n\n      if (!syncCollectionMethods[i] && typeof lastArg === 'function') {\n        this.addQueue(i, _args);\n        return;\n      }\n\n      return promise;\n    } else if (!syncCollectionMethods[i] && typeof lastArg === 'function') {\n      callback = function collectionOperationCallback(err, res) {\n        if (err != null) {\n          _this.conn.emit('operation-end', { _id: opId, modelName: _this.modelName, collectionName: _this.name, method: i, error: err });\n        } else {\n          _this.conn.emit('operation-end', { _id: opId, modelName: _this.modelName, collectionName: _this.name, method: i, result: res });\n        }\n        return lastArg.apply(this, arguments);\n      };\n      _args = args.slice(0, args.length - 1).concat([callback]);\n    }\n\n    if (debug) {\n      if (typeof debug === 'function') {\n        let argsToAdd = null;\n        if (typeof args[args.length - 1] == 'function') {\n          argsToAdd = args.slice(0, args.length - 1);\n        } else {\n          argsToAdd = args;\n        }\n        debug.apply(_this,\n          [_this.name, i].concat(argsToAdd));\n      } else if (debug instanceof stream.Writable) {\n        this.$printToStream(_this.name, i, args, debug);\n      } else {\n        const color = debug.color == null ? true : debug.color;\n        const shell = debug.shell == null ? false : debug.shell;\n        this.$print(_this.name, i, args, color, shell);\n      }\n    }\n\n    this.conn.emit('operation-start', { _id: opId, modelName: _this.modelName, collectionName: this.name, method: i, params: _args });\n\n    try {\n      if (collection == null) {\n        const message = 'Cannot call `' + this.name + '.' + i + '()` before initial connection ' +\n          'is complete if `bufferCommands = false`. Make sure you `await mongoose.connect()` if ' +\n          'you have `bufferCommands = false`.';\n        throw new MongooseError(message);\n      }\n\n      if (syncCollectionMethods[i] && typeof lastArg === 'function') {\n        const ret = collection[i].apply(collection, _args.slice(0, _args.length - 1));\n        return lastArg.call(this, null, ret);\n      }\n\n      const ret = collection[i].apply(collection, _args);\n      if (ret != null && typeof ret.then === 'function') {\n        return ret.then(\n          res => {\n            typeof lastArg === 'function' && lastArg(null, res);\n            return res;\n          },\n          err => {\n            if (typeof lastArg === 'function') {\n              lastArg(err);\n              return;\n            }\n            throw err;\n          }\n        );\n      }\n      return ret;\n    } catch (error) {\n      // Collection operation may throw because of max bson size, catch it here\n      // See gh-3906\n      if (typeof lastArg === 'function') {\n        return lastArg(error);\n      } else {\n        this.conn.emit('operation-end', { _id: opId, modelName: _this.modelName, collectionName: this.name, method: i, error: error });\n\n        throw error;\n      }\n    }\n  };\n}\n\nfor (const key of Object.getOwnPropertyNames(Collection.prototype)) {\n  // Janky hack to work around gh-3005 until we can get rid of the mongoose\n  // collection abstraction\n  const descriptor = Object.getOwnPropertyDescriptor(Collection.prototype, key);\n  // Skip properties with getters because they may throw errors (gh-8528)\n  if (descriptor.get !== undefined) {\n    continue;\n  }\n  if (typeof Collection.prototype[key] !== 'function') {\n    continue;\n  }\n\n  iter(key);\n}\n\n/**\n * Debug print helper\n *\n * @api public\n * @method $print\n */\n\nNativeCollection.prototype.$print = function(name, i, args, color, shell) {\n  const moduleName = color ? '\\x1B[0;36mMongoose:\\x1B[0m ' : 'Mongoose: ';\n  const functionCall = [name, i].join('.');\n  const _args = [];\n  for (let j = args.length - 1; j >= 0; --j) {\n    if (this.$format(args[j]) || _args.length) {\n      _args.unshift(this.$format(args[j], color, shell));\n    }\n  }\n  const params = '(' + _args.join(', ') + ')';\n\n  console.info(moduleName + functionCall + params);\n};\n\n/**\n * Debug print helper\n *\n * @api public\n * @method $print\n */\n\nNativeCollection.prototype.$printToStream = function(name, i, args, stream) {\n  const functionCall = [name, i].join('.');\n  const _args = [];\n  for (let j = args.length - 1; j >= 0; --j) {\n    if (this.$format(args[j]) || _args.length) {\n      _args.unshift(this.$format(args[j]));\n    }\n  }\n  const params = '(' + _args.join(', ') + ')';\n\n  stream.write(functionCall + params, 'utf8');\n};\n\n/**\n * Formatter for debug print args\n *\n * @api public\n * @method $format\n */\n\nNativeCollection.prototype.$format = function(arg, color, shell) {\n  const type = typeof arg;\n  if (type === 'function' || type === 'undefined') return '';\n  return format(arg, false, color, shell);\n};\n\n/**\n * Debug print helper\n * @param {Any} representation\n * @api private\n */\n\nfunction inspectable(representation) {\n  const ret = {\n    inspect: function() { return representation; }\n  };\n  if (util.inspect.custom) {\n    ret[util.inspect.custom] = ret.inspect;\n  }\n  return ret;\n}\nfunction map(o) {\n  return format(o, true);\n}\nfunction formatObjectId(x, key) {\n  x[key] = inspectable('ObjectId(\"' + x[key].toHexString() + '\")');\n}\nfunction formatDate(x, key, shell) {\n  if (shell) {\n    x[key] = inspectable('ISODate(\"' + x[key].toUTCString() + '\")');\n  } else {\n    x[key] = inspectable('new Date(\"' + x[key].toUTCString() + '\")');\n  }\n}\nfunction format(obj, sub, color, shell) {\n  if (obj && typeof obj.toBSON === 'function') {\n    obj = obj.toBSON();\n  }\n  if (obj == null) {\n    return obj;\n  }\n\n  const clone = __webpack_require__(/*! ../../helpers/clone */ \"(ssr)/./node_modules/mongoose/lib/helpers/clone.js\");\n  let x = clone(obj, internalToObjectOptions);\n  const constructorName = getConstructorName(x);\n\n  if (constructorName === 'Binary') {\n    x = 'BinData(' + x.sub_type + ', \"' + x.toString('base64') + '\")';\n  } else if (constructorName === 'ObjectId') {\n    x = inspectable('ObjectId(\"' + x.toHexString() + '\")');\n  } else if (constructorName === 'Date') {\n    x = inspectable('new Date(\"' + x.toUTCString() + '\")');\n  } else if (constructorName === 'Object') {\n    const keys = Object.keys(x);\n    const numKeys = keys.length;\n    let key;\n    for (let i = 0; i < numKeys; ++i) {\n      key = keys[i];\n      if (x[key]) {\n        let error;\n        if (typeof x[key].toBSON === 'function') {\n          try {\n            // `session.toBSON()` throws an error. This means we throw errors\n            // in debug mode when using transactions, see gh-6712. As a\n            // workaround, catch `toBSON()` errors, try to serialize without\n            // `toBSON()`, and rethrow if serialization still fails.\n            x[key] = x[key].toBSON();\n          } catch (_error) {\n            error = _error;\n          }\n        }\n        const _constructorName = getConstructorName(x[key]);\n        if (_constructorName === 'Binary') {\n          x[key] = 'BinData(' + x[key].sub_type + ', \"' +\n            x[key].buffer.toString('base64') + '\")';\n        } else if (_constructorName === 'Object') {\n          x[key] = format(x[key], true);\n        } else if (_constructorName === 'ObjectId') {\n          formatObjectId(x, key);\n        } else if (_constructorName === 'Date') {\n          formatDate(x, key, shell);\n        } else if (_constructorName === 'ClientSession') {\n          x[key] = inspectable('ClientSession(\"' +\n            (\n              x[key] &&\n              x[key].id &&\n              x[key].id.id &&\n              x[key].id.id.buffer || ''\n            ).toString('hex') + '\")');\n        } else if (Array.isArray(x[key])) {\n          x[key] = x[key].map(map);\n        } else if (error != null) {\n          // If there was an error with `toBSON()` and the object wasn't\n          // already converted to a string representation, rethrow it.\n          // Open to better ideas on how to handle this.\n          throw error;\n        }\n      }\n    }\n  }\n  if (sub) {\n    return x;\n  }\n\n  return util.\n    inspect(x, false, 10, color).\n    replace(/\\n/g, '').\n    replace(/\\s{2,}/g, ' ');\n}\n\n/**\n * Retrieves information about this collections indexes.\n *\n * @param {Function} callback\n * @method getIndexes\n * @api public\n */\n\nNativeCollection.prototype.getIndexes = NativeCollection.prototype.indexInformation;\n\n/*!\n * Module exports.\n */\n\nmodule.exports = NativeCollection;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbW9uZ29vc2UvbGliL2RyaXZlcnMvbm9kZS1tb25nb2RiLW5hdGl2ZS9jb2xsZWN0aW9uLmpzIiwibWFwcGluZ3MiOiJBQUFhOztBQUViO0FBQ0E7QUFDQTs7QUFFQSwyQkFBMkIsbUJBQU8sQ0FBQyx5RUFBa0I7QUFDckQsc0JBQXNCLG1CQUFPLENBQUMsMkZBQTJCO0FBQ3pELG1CQUFtQiw0RkFBNkI7QUFDaEQsaUJBQWlCLG1CQUFPLENBQUMsaUZBQXNCO0FBQy9DLDJCQUEyQixtQkFBTyxDQUFDLHlHQUFrQztBQUNyRSxnQ0FBZ0Msa0hBQWdEO0FBQ2hGLGVBQWUsbUJBQU8sQ0FBQyxzQkFBUTtBQUMvQixhQUFhLG1CQUFPLENBQUMsa0JBQU07O0FBRTNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxnQ0FBZ0M7O0FBRWhDO0FBQ0E7QUFDQSxXQUFXLGVBQWU7QUFDMUI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFD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Q0E7QUFDQSxXQUFXLFVBQVU7QUFDckI7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSIsInNvdXJjZXMiOlsid2VicGFjazovL2FwcDEvLi9ub2RlX21vZHVsZXMvbW9uZ29vc2UvbGliL2RyaXZlcnMvbm9kZS1tb25nb2RiLW5hdGl2ZS9jb2xsZWN0aW9uLmpzPzYyYWQiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG4vKiFcbiAqIE1vZHVsZSBkZXBlbmRlbmNpZXMuXG4gKi9cblxuY29uc3QgTW9uZ29vc2VDb2xsZWN0aW9uID0gcmVxdWlyZSgnLi4vLi4vY29sbGVjdGlvbicpO1xuY29uc3QgTW9uZ29vc2VFcnJvciA9IHJlcXVpcmUoJy4uLy4uL2Vycm9yL21vbmdvb3NlRXJyb3InKTtcbmNvbnN0IENvbGxlY3Rpb24gPSByZXF1aXJlKCdtb25nb2RiJykuQ29sbGVjdGlvbjtcbmNvbnN0IE9iamVjdElkID0gcmVxdWlyZSgnLi4vLi4vdHlwZXMvb2JqZWN0aWQnKTtcbmNvbnN0IGdldENvbnN0cnVjdG9yTmFtZSA9IHJlcXVpcmUoJy4uLy4uL2hlbHBlcnMvZ2V0Q29uc3RydWN0b3JOYW1lJyk7XG5jb25zdCBpbnRlcm5hbFRvT2JqZWN0T3B0aW9ucyA9IHJlcXVpcmUoJy4uLy4uL29wdGlvbnMnKS5pbnRlcm5hbFRvT2JqZWN0T3B0aW9ucztcbmNvbnN0IHN0cmVhbSA9IHJlcXVpcmUoJ3N0cmVhbScpO1xuY29uc3QgdXRpbCA9IHJlcXVpcmUoJ3V0aWwnKTtcblxuLyoqXG4gKiBBIFtub2RlLW1vbmdvZGItbmF0aXZlXShodHRwczovL2dpdGh1Yi5jb20vbW9uZ29kYi9ub2RlLW1vbmdvZGItbmF0aXZlKSBjb2xsZWN0aW9uIGltcGxlbWVudGF0aW9uLlxuICpcbiAqIEFsbCBtZXRob2RzIG1ldGhvZHMgZnJvbSB0aGUgW25vZGUtbW9uZ29kYi1uYXRpdmVdKGh0dHBzOi8vZ2l0aHViLmNvbS9tb25nb2RiL25vZGUtbW9uZ29kYi1uYXRpdmUpIGRyaXZlciBhcmUgY29waWVkIGFuZCB3cmFwcGVkIGluIHF1ZXVlIG1hbmFnZW1lbnQuXG4gKlxuICogQGluaGVyaXRzIENvbGxlY3Rpb24gaHR0cHM6Ly9tb25nb2RiLmdpdGh1Yi5pby9ub2RlLW1vbmdvZGItbmF0aXZlLzQuOS9jbGFzc2VzL0NvbGxlY3Rpb24uaHRtbFxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZnVuY3Rpb24gTmF0aXZlQ29sbGVjdGlvbihuYW1lLCBjb25uLCBvcHRpb25zKSB7XG4gIHRoaXMuY29sbGVjdGlvbiA9IG51bGw7XG4gIHRoaXMuUHJvbWlzZSA9IG9wdGlvbnMuUHJvbWlzZSB8fCBQcm9taXNlO1xuICB0aGlzLm1vZGVsTmFtZSA9IG9wdGlvbnMubW9kZWxOYW1lO1xuICBkZWxldGUgb3B0aW9ucy5tb2RlbE5hbWU7XG4gIHRoaXMuX2Nsb3NlZCA9IGZhbHNlO1xuICBNb25nb29zZUNvbGxlY3Rpb24uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbn1cblxuLyohXG4gKiBJbmhlcml0IGZyb20gYWJzdHJhY3QgQ29sbGVjdGlvbi5cbiAqL1xuXG5PYmplY3Quc2V0UHJvdG90eXBlT2YoTmF0aXZlQ29sbGVjdGlvbi5wcm90b3R5cGUsIE1vbmdvb3NlQ29sbGVjdGlvbi5wcm90b3R5cGUpO1xuXG4vKipcbiAqIENhbGxlZCB3aGVuIHRoZSBjb25uZWN0aW9uIG9wZW5zLlxuICpcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbk5hdGl2ZUNvbGxlY3Rpb24ucHJvdG90eXBlLm9uT3BlbiA9IGZ1bmN0aW9uKCkge1xuICB0aGlzLmNvbGxlY3Rpb24gPSB0aGlzLmNvbm4uZGIuY29sbGVjdGlvbih0aGlzLm5hbWUpO1xuICBNb25nb29zZUNvbGxlY3Rpb24ucHJvdG90eXBlLm9uT3Blbi5jYWxsKHRoaXMpO1xuICByZXR1cm4gdGhpcy5jb2xsZWN0aW9uO1xufTtcblxuLyoqXG4gKiBDYWxsZWQgd2hlbiB0aGUgY29ubmVjdGlvbiBjbG9zZXNcbiAqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5OYXRpdmVDb2xsZWN0aW9uLnByb3RvdHlwZS5vbkNsb3NlID0gZnVuY3Rpb24oZm9yY2UpIHtcbiAgTW9uZ29vc2VDb2xsZWN0aW9uLnByb3RvdHlwZS5vbkNsb3NlLmNhbGwodGhpcywgZm9yY2UpO1xufTtcblxuLyoqXG4gKiBIZWxwZXIgdG8gZ2V0IHRoZSBjb2xsZWN0aW9uLCBpbiBjYXNlIGB0aGlzLmNvbGxlY3Rpb25gIGlzbid0IHNldCB5ZXQuXG4gKiBNYXkgaGFwcGVuIGlmIGBidWZmZXJDb21tYW5kc2AgaXMgZmFsc2UgYW5kIGNyZWF0ZWQgdGhlIG1vZGVsIHdoZW5cbiAqIE1vbmdvb3NlIHdhcyBkaXNjb25uZWN0ZWQuXG4gKlxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuTmF0aXZlQ29sbGVjdGlvbi5wcm90b3R5cGUuX2dldENvbGxlY3Rpb24gPSBmdW5jdGlvbiBfZ2V0Q29sbGVjdGlvbigpIHtcbiAgaWYgKHRoaXMuY29sbGVjdGlvbikge1xuICAgIHJldHVybiB0aGlzLmNvbGxlY3Rpb247XG4gIH1cbiAgaWYgKHRoaXMuY29ubi5kYiAhPSBudWxsKSB7XG4gICAgdGhpcy5jb2xsZWN0aW9uID0gdGhpcy5jb25uLmRiLmNvbGxlY3Rpb24odGhpcy5uYW1lKTtcbiAgICByZXR1cm4gdGhpcy5jb2xsZWN0aW9uO1xuICB9XG4gIHJldHVybiBudWxsO1xufTtcblxuLyohXG4gKiBpZ25vcmVcbiAqL1xuXG5jb25zdCBzeW5jQ29sbGVjdGlvbk1ldGhvZHMgPSB7IHdhdGNoOiB0cnVlLCBmaW5kOiB0cnVlLCBhZ2dyZWdhdGU6IHRydWUgfTtcblxuLyoqXG4gKiBDb3B5IHRoZSBjb2xsZWN0aW9uIG1ldGhvZHMgYW5kIG1ha2UgdGhlbSBzdWJqZWN0IHRvIHF1ZXVlc1xuICogQHBhcmFtIHtOdW1iZXJ8U3RyaW5nfSBJXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5mdW5jdGlvbiBpdGVyKGkpIHtcbiAgTmF0aXZlQ29sbGVjdGlvbi5wcm90b3R5cGVbaV0gPSBmdW5jdGlvbigpIHtcbiAgICBjb25zdCBjb2xsZWN0aW9uID0gdGhpcy5fZ2V0Q29sbGVjdGlvbigpO1xuICAgIGNvbnN0IGFyZ3MgPSBBcnJheS5mcm9tKGFyZ3VtZW50cyk7XG4gICAgY29uc3QgX3RoaXMgPSB0aGlzO1xuICAgIGNvbnN0IGdsb2JhbERlYnVnID0gX3RoaXMgJiZcbiAgICAgIF90aGlzLmNvbm4gJiZcbiAgICAgIF90aGlzLmNvbm4uYmFzZSAmJlxuICAgICAgX3RoaXMuY29ubi5iYXNlLm9wdGlvbnMgJiZcbiAgICAgIF90aGlzLmNvbm4uYmFzZS5vcHRpb25zLmRlYnVnO1xuICAgIGNvbnN0IGNvbm5lY3Rpb25EZWJ1ZyA9IF90aGlzICYmXG4gICAgICBfdGhpcy5jb25uICYmXG4gICAgICBfdGhpcy5jb25uLm9wdGlvbnMgJiZcbiAgICAgIF90aGlzLmNvbm4ub3B0aW9ucy5kZWJ1ZztcbiAgICBjb25zdCBkZWJ1ZyA9IGNvbm5lY3Rpb25EZWJ1ZyA9PSBudWxsID8gZ2xvYmFsRGVidWcgOiBjb25uZWN0aW9uRGVidWc7XG4gICAgY29uc3QgbGFzdEFyZyA9IGFyZ3VtZW50c1thcmd1bWVudHMubGVuZ3RoIC0gMV07XG4gICAgY29uc3Qgb3BJZCA9IG5ldyBPYmplY3RJZCgpO1xuXG4gICAgLy8gSWYgdXNlciBmb3JjZSBjbG9zZWQsIHF1ZXVlaW5nIHdpbGwgaGFuZyBmb3JldmVyLiBTZWUgIzU2NjRcbiAgICBpZiAodGhpcy5jb25uLiR3YXNGb3JjZUNsb3NlZCkge1xuICAgICAgY29uc3QgZXJyb3IgPSBuZXcgTW9uZ29vc2VFcnJvcignQ29ubmVjdGlvbiB3YXMgZm9yY2UgY2xvc2VkJyk7XG4gICAgICBpZiAoYXJncy5sZW5ndGggPiAwICYmXG4gICAgICAgIHR5cGVvZiBhcmdzW2FyZ3MubGVuZ3RoIC0gMV0gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgYXJnc1thcmdzLmxlbmd0aCAtIDFdKGVycm9yKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICB9XG4gICAgfVxuXG4gICAgbGV0IF9hcmdzID0gYXJncztcbiAgICBsZXQgY2FsbGJhY2sgPSBudWxsO1xuICAgIGlmICh0aGlzLl9zaG91bGRCdWZmZXJDb21tYW5kcygpICYmIHRoaXMuYnVmZmVyKSB7XG4gICAgICB0aGlzLmNvbm4uZW1pdCgnYnVmZmVyJywge1xuICAgICAgICBfaWQ6IG9wSWQsXG4gICAgICAgIG1vZGVsTmFtZTogX3RoaXMubW9kZWxOYW1lLFxuICAgICAgICBjb2xsZWN0aW9uTmFtZTogX3RoaXMubmFtZSxcbiAgICAgICAgbWV0aG9kOiBpLFxuICAgICAgICBhcmdzOiBhcmdzXG4gICAgICB9KTtcblxuICAgICAgbGV0IGNhbGxiYWNrO1xuICAgICAgbGV0IF9hcmdzID0gYXJncztcbiAgICAgIGxldCBwcm9taXNlID0gbnVsbDtcbiAgICAgIGxldCB0aW1lb3V0ID0gbnVsbDtcbiAgICAgIGlmIChzeW5jQ29sbGVjdGlvbk1ldGhvZHNbaV0gJiYgdHlwZW9mIGxhc3RBcmcgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgdGhpcy5hZGRRdWV1ZSgoKSA9PiB7XG4gICAgICAgICAgbGFzdEFyZy5jYWxsKHRoaXMsIG51bGwsIHRoaXNbaV0uYXBwbHkodGhpcywgX2FyZ3Muc2xpY2UoMCwgX2FyZ3MubGVuZ3RoIC0gMSkpKTtcbiAgICAgICAgfSwgW10pO1xuICAgICAgfSBlbHNlIGlmIChzeW5jQ29sbGVjdGlvbk1ldGhvZHNbaV0pIHtcbiAgICAgICAgcHJvbWlzZSA9IG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgICBjYWxsYmFjayA9IGZ1bmN0aW9uIGNvbGxlY3Rpb25PcGVyYXRpb25DYWxsYmFjayhlcnIsIHJlcykge1xuICAgICAgICAgICAgaWYgKHRpbWVvdXQgIT0gbnVsbCkge1xuICAgICAgICAgICAgICBjbGVhclRpbWVvdXQodGltZW91dCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZXJyICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIHJlamVjdChlcnIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmVzb2x2ZShyZXMpO1xuICAgICAgICAgIH07XG4gICAgICAgICAgX2FyZ3MgPSBhcmdzLmNvbmNhdChbY2FsbGJhY2tdKTtcbiAgICAgICAgICB0aGlzLmFkZFF1ZXVlKGksIF9hcmdzKTtcbiAgICAgICAgfSk7XG4gICAgICB9IGVsc2UgaWYgKHR5cGVvZiBsYXN0QXJnID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIGNhbGxiYWNrID0gZnVuY3Rpb24gY29sbGVjdGlvbk9wZXJhdGlvbkNhbGxiYWNrKCkge1xuICAgICAgICAgIGlmICh0aW1lb3V0ICE9IG51bGwpIHtcbiAgICAgICAgICAgIGNsZWFyVGltZW91dCh0aW1lb3V0KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIGxhc3RBcmcuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgfTtcbiAgICAgICAgX2FyZ3MgPSBhcmdzLnNsaWNlKDAsIGFyZ3MubGVuZ3RoIC0gMSkuY29uY2F0KFtjYWxsYmFja10pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcHJvbWlzZSA9IG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgICBjYWxsYmFjayA9IGZ1bmN0aW9uIGNvbGxlY3Rpb25PcGVyYXRpb25DYWxsYmFjayhlcnIsIHJlcykge1xuICAgICAgICAgICAgaWYgKHRpbWVvdXQgIT0gbnVsbCkge1xuICAgICAgICAgICAgICBjbGVhclRpbWVvdXQodGltZW91dCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZXJyICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIHJlamVjdChlcnIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmVzb2x2ZShyZXMpO1xuICAgICAgICAgIH07XG4gICAgICAgICAgX2FyZ3MgPSBhcmdzLmNvbmNhdChbY2FsbGJhY2tdKTtcbiAgICAgICAgICB0aGlzLmFkZFF1ZXVlKGksIF9hcmdzKTtcbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IGJ1ZmZlclRpbWVvdXRNUyA9IHRoaXMuX2dldEJ1ZmZlclRpbWVvdXRNUygpO1xuICAgICAgdGltZW91dCA9IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICBjb25zdCByZW1vdmVkID0gdGhpcy5yZW1vdmVRdWV1ZShpLCBfYXJncyk7XG4gICAgICAgIGlmIChyZW1vdmVkKSB7XG4gICAgICAgICAgY29uc3QgbWVzc2FnZSA9ICdPcGVyYXRpb24gYCcgKyB0aGlzLm5hbWUgKyAnLicgKyBpICsgJygpYCBidWZmZXJpbmcgdGltZWQgb3V0IGFmdGVyICcgK1xuICAgICAgICAgICAgYnVmZmVyVGltZW91dE1TICsgJ21zJztcbiAgICAgICAgICBjb25zdCBlcnIgPSBuZXcgTW9uZ29vc2VFcnJvcihtZXNzYWdlKTtcbiAgICAgICAgICB0aGlzLmNvbm4uZW1pdCgnYnVmZmVyLWVuZCcsIHsgX2lkOiBvcElkLCBtb2RlbE5hbWU6IF90aGlzLm1vZGVsTmFtZSwgY29sbGVjdGlvbk5hbWU6IF90aGlzLm5hbWUsIG1ldGhvZDogaSwgZXJyb3I6IGVyciB9KTtcbiAgICAgICAgICBjYWxsYmFjayhlcnIpO1xuICAgICAgICB9XG4gICAgICB9LCBidWZmZXJUaW1lb3V0TVMpO1xuXG4gICAgICBpZiAoIXN5bmNDb2xsZWN0aW9uTWV0aG9kc1tpXSAmJiB0eXBlb2YgbGFzdEFyZyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICB0aGlzLmFkZFF1ZXVlKGksIF9hcmdzKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gcHJvbWlzZTtcbiAgICB9IGVsc2UgaWYgKCFzeW5jQ29sbGVjdGlvbk1ldGhvZHNbaV0gJiYgdHlwZW9mIGxhc3RBcmcgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIGNhbGxiYWNrID0gZnVuY3Rpb24gY29sbGVjdGlvbk9wZXJhdGlvbkNhbGxiYWNrKGVyciwgcmVzKSB7XG4gICAgICAgIGlmIChlcnIgIT0gbnVsbCkge1xuICAgICAgICAgIF90aGlzLmNvbm4uZW1pdCgnb3BlcmF0aW9uLWVuZCcsIHsgX2lkOiBvcElkLCBtb2RlbE5hbWU6IF90aGlzLm1vZGVsTmFtZSwgY29sbGVjdGlvbk5hbWU6IF90aGlzLm5hbWUsIG1ldGhvZDogaSwgZXJyb3I6IGVyciB9KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBfdGhpcy5jb25uLmVtaXQoJ29wZXJhdGlvbi1lbmQnLCB7IF9pZDogb3BJZCwgbW9kZWxOYW1lOiBfdGhpcy5tb2RlbE5hbWUsIGNvbGxlY3Rpb25OYW1lOiBfdGhpcy5uYW1lLCBtZXRob2Q6IGksIHJlc3VsdDogcmVzIH0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBsYXN0QXJnLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICB9O1xuICAgICAgX2FyZ3MgPSBhcmdzLnNsaWNlKDAsIGFyZ3MubGVuZ3RoIC0gMSkuY29uY2F0KFtjYWxsYmFja10pO1xuICAgIH1cblxuICAgIGlmIChkZWJ1Zykge1xuICAgICAgaWYgKHR5cGVvZiBkZWJ1ZyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICBsZXQgYXJnc1RvQWRkID0gbnVsbDtcbiAgICAgICAgaWYgKHR5cGVvZiBhcmdzW2FyZ3MubGVuZ3RoIC0gMV0gPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgIGFyZ3NUb0FkZCA9IGFyZ3Muc2xpY2UoMCwgYXJncy5sZW5ndGggLSAxKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBhcmdzVG9BZGQgPSBhcmdzO1xuICAgICAgICB9XG4gICAgICAgIGRlYnVnLmFwcGx5KF90aGlzLFxuICAgICAgICAgIFtfdGhpcy5uYW1lLCBpXS5jb25jYXQoYXJnc1RvQWRkKSk7XG4gICAgICB9IGVsc2UgaWYgKGRlYnVnIGluc3RhbmNlb2Ygc3RyZWFtLldyaXRhYmxlKSB7XG4gICAgICAgIHRoaXMuJHByaW50VG9TdHJlYW0oX3RoaXMubmFtZSwgaSwgYXJncywgZGVidWcpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc3QgY29sb3IgPSBkZWJ1Zy5jb2xvciA9PSBudWxsID8gdHJ1ZSA6IGRlYnVnLmNvbG9yO1xuICAgICAgICBjb25zdCBzaGVsbCA9IGRlYnVnLnNoZWxsID09IG51bGwgPyBmYWxzZSA6IGRlYnVnLnNoZWxsO1xuICAgICAgICB0aGlzLiRwcmludChfdGhpcy5uYW1lLCBpLCBhcmdzLCBjb2xvciwgc2hlbGwpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHRoaXMuY29ubi5lbWl0KCdvcGVyYXRpb24tc3RhcnQnLCB7IF9pZDogb3BJZCwgbW9kZWxOYW1lOiBfdGhpcy5tb2RlbE5hbWUsIGNvbGxlY3Rpb25OYW1lOiB0aGlzLm5hbWUsIG1ldGhvZDogaSwgcGFyYW1zOiBfYXJncyB9KTtcblxuICAgIHRyeSB7XG4gICAgICBpZiAoY29sbGVjdGlvbiA9PSBudWxsKSB7XG4gICAgICAgIGNvbnN0IG1lc3NhZ2UgPSAnQ2Fubm90IGNhbGwgYCcgKyB0aGlzLm5hbWUgKyAnLicgKyBpICsgJygpYCBiZWZvcmUgaW5pdGlhbCBjb25uZWN0aW9uICcgK1xuICAgICAgICAgICdpcyBjb21wbGV0ZSBpZiBgYnVmZmVyQ29tbWFuZHMgPSBmYWxzZWAuIE1ha2Ugc3VyZSB5b3UgYGF3YWl0IG1vbmdvb3NlLmNvbm5lY3QoKWAgaWYgJyArXG4gICAgICAgICAgJ3lvdSBoYXZlIGBidWZmZXJDb21tYW5kcyA9IGZhbHNlYC4nO1xuICAgICAgICB0aHJvdyBuZXcgTW9uZ29vc2VFcnJvcihtZXNzYWdlKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHN5bmNDb2xsZWN0aW9uTWV0aG9kc1tpXSAmJiB0eXBlb2YgbGFzdEFyZyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICBjb25zdCByZXQgPSBjb2xsZWN0aW9uW2ldLmFwcGx5KGNvbGxlY3Rpb24sIF9hcmdzLnNsaWNlKDAsIF9hcmdzLmxlbmd0aCAtIDEpKTtcbiAgICAgICAgcmV0dXJuIGxhc3RBcmcuY2FsbCh0aGlzLCBudWxsLCByZXQpO1xuICAgICAgfVxuXG4gICAgICBjb25zdCByZXQgPSBjb2xsZWN0aW9uW2ldLmFwcGx5KGNvbGxlY3Rpb24sIF9hcmdzKTtcbiAgICAgIGlmIChyZXQgIT0gbnVsbCAmJiB0eXBlb2YgcmV0LnRoZW4gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgcmV0dXJuIHJldC50aGVuKFxuICAgICAgICAgIHJlcyA9PiB7XG4gICAgICAgICAgICB0eXBlb2YgbGFzdEFyZyA9PT0gJ2Z1bmN0aW9uJyAmJiBsYXN0QXJnKG51bGwsIHJlcyk7XG4gICAgICAgICAgICByZXR1cm4gcmVzO1xuICAgICAgICAgIH0sXG4gICAgICAgICAgZXJyID0+IHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgbGFzdEFyZyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICBsYXN0QXJnKGVycik7XG4gICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRocm93IGVycjtcbiAgICAgICAgICB9XG4gICAgICAgICk7XG4gICAgICB9XG4gICAgICByZXR1cm4gcmV0O1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAvLyBDb2xsZWN0aW9uIG9wZXJhdGlvbiBtYXkgdGhyb3cgYmVjYXVzZSBvZiBtYXggYnNvbiBzaXplLCBjYXRjaCBpdCBoZXJlXG4gICAgICAvLyBTZWUgZ2gtMzkwNlxuICAgICAgaWYgKHR5cGVvZiBsYXN0QXJnID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHJldHVybiBsYXN0QXJnKGVycm9yKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuY29ubi5lbWl0KCdvcGVyYXRpb24tZW5kJywgeyBfaWQ6IG9wSWQsIG1vZGVsTmFtZTogX3RoaXMubW9kZWxOYW1lLCBjb2xsZWN0aW9uTmFtZTogdGhpcy5uYW1lLCBtZXRob2Q6IGksIGVycm9yOiBlcnJvciB9KTtcblxuICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgIH1cbiAgICB9XG4gIH07XG59XG5cbmZvciAoY29uc3Qga2V5IG9mIE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKENvbGxlY3Rpb24ucHJvdG90eXBlKSkge1xuICAvLyBKYW5reSBoYWNrIHRvIHdvcmsgYXJvdW5kIGdoLTMwMDUgdW50aWwgd2UgY2FuIGdldCByaWQgb2YgdGhlIG1vbmdvb3NlXG4gIC8vIGNvbGxlY3Rpb24gYWJzdHJhY3Rpb25cbiAgY29uc3QgZGVzY3JpcHRvciA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoQ29sbGVjdGlvbi5wcm90b3R5cGUsIGtleSk7XG4gIC8vIFNraXAgcHJvcGVydGllcyB3aXRoIGdldHRlcnMgYmVjYXVzZSB0aGV5IG1heSB0aHJvdyBlcnJvcnMgKGdoLTg1MjgpXG4gIGlmIChkZXNjcmlwdG9yLmdldCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgY29udGludWU7XG4gIH1cbiAgaWYgKHR5cGVvZiBDb2xsZWN0aW9uLnByb3RvdHlwZVtrZXldICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgY29udGludWU7XG4gIH1cblxuICBpdGVyKGtleSk7XG59XG5cbi8qKlxuICogRGVidWcgcHJpbnQgaGVscGVyXG4gKlxuICogQGFwaSBwdWJsaWNcbiAqIEBtZXRob2QgJHByaW50XG4gKi9cblxuTmF0aXZlQ29sbGVjdGlvbi5wcm90b3R5cGUuJHByaW50ID0gZnVuY3Rpb24obmFtZSwgaSwgYXJncywgY29sb3IsIHNoZWxsKSB7XG4gIGNvbnN0IG1vZHVsZU5hbWUgPSBjb2xvciA/ICdcXHgxQlswOzM2bU1vbmdvb3NlOlxceDFCWzBtICcgOiAnTW9uZ29vc2U6ICc7XG4gIGNvbnN0IGZ1bmN0aW9uQ2FsbCA9IFtuYW1lLCBpXS5qb2luKCcuJyk7XG4gIGNvbnN0IF9hcmdzID0gW107XG4gIGZvciAobGV0IGogPSBhcmdzLmxlbmd0aCAtIDE7IGogPj0gMDsgLS1qKSB7XG4gICAgaWYgKHRoaXMuJGZvcm1hdChhcmdzW2pdKSB8fCBfYXJncy5sZW5ndGgpIHtcbiAgICAgIF9hcmdzLnVuc2hpZnQodGhpcy4kZm9ybWF0KGFyZ3Nbal0sIGNvbG9yLCBzaGVsbCkpO1xuICAgIH1cbiAgfVxuICBjb25zdCBwYXJhbXMgPSAnKCcgKyBfYXJncy5qb2luKCcsICcpICsgJyknO1xuXG4gIGNvbnNvbGUuaW5mbyhtb2R1bGVOYW1lICsgZnVuY3Rpb25DYWxsICsgcGFyYW1zKTtcbn07XG5cbi8qKlxuICogRGVidWcgcHJpbnQgaGVscGVyXG4gKlxuICogQGFwaSBwdWJsaWNcbiAqIEBtZXRob2QgJHByaW50XG4gKi9cblxuTmF0aXZlQ29sbGVjdGlvbi5wcm90b3R5cGUuJHByaW50VG9TdHJlYW0gPSBmdW5jdGlvbihuYW1lLCBpLCBhcmdzLCBzdHJlYW0pIHtcbiAgY29uc3QgZnVuY3Rpb25DYWxsID0gW25hbWUsIGldLmpvaW4oJy4nKTtcbiAgY29uc3QgX2FyZ3MgPSBbXTtcbiAgZm9yIChsZXQgaiA9IGFyZ3MubGVuZ3RoIC0gMTsgaiA+PSAwOyAtLWopIHtcbiAgICBpZiAodGhpcy4kZm9ybWF0KGFyZ3Nbal0pIHx8IF9hcmdzLmxlbmd0aCkge1xuICAgICAgX2FyZ3MudW5zaGlmdCh0aGlzLiRmb3JtYXQoYXJnc1tqXSkpO1xuICAgIH1cbiAgfVxuICBjb25zdCBwYXJhbXMgPSAnKCcgKyBfYXJncy5qb2luKCcsICcpICsgJyknO1xuXG4gIHN0cmVhbS53cml0ZShmdW5jdGlvbkNhbGwgKyBwYXJhbXMsICd1dGY4Jyk7XG59O1xuXG4vKipcbiAqIEZvcm1hdHRlciBmb3IgZGVidWcgcHJpbnQgYXJnc1xuICpcbiAqIEBhcGkgcHVibGljXG4gKiBAbWV0aG9kICRmb3JtYXRcbiAqL1xuXG5OYXRpdmVDb2xsZWN0aW9uLnByb3RvdHlwZS4kZm9ybWF0ID0gZnVuY3Rpb24oYXJnLCBjb2xvciwgc2hlbGwpIHtcbiAgY29uc3QgdHlwZSA9IHR5cGVvZiBhcmc7XG4gIGlmICh0eXBlID09PSAnZnVuY3Rpb24nIHx8IHR5cGUgPT09ICd1bmRlZmluZWQnKSByZXR1cm4gJyc7XG4gIHJldHVybiBmb3JtYXQoYXJnLCBmYWxzZSwgY29sb3IsIHNoZWxsKTtcbn07XG5cbi8qKlxuICogRGVidWcgcHJpbnQgaGVscGVyXG4gKiBAcGFyYW0ge0FueX0gcmVwcmVzZW50YXRpb25cbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmZ1bmN0aW9uIGluc3BlY3RhYmxlKHJlcHJlc2VudGF0aW9uKSB7XG4gIGNvbnN0IHJldCA9IHtcbiAgICBpbnNwZWN0OiBmdW5jdGlvbigpIHsgcmV0dXJuIHJlcHJlc2VudGF0aW9uOyB9XG4gIH07XG4gIGlmICh1dGlsLmluc3BlY3QuY3VzdG9tKSB7XG4gICAgcmV0W3V0aWwuaW5zcGVjdC5jdXN0b21dID0gcmV0Lmluc3BlY3Q7XG4gIH1cbiAgcmV0dXJuIHJldDtcbn1cbmZ1bmN0aW9uIG1hcChvKSB7XG4gIHJldHVybiBmb3JtYXQobywgdHJ1ZSk7XG59XG5mdW5jdGlvbiBmb3JtYXRPYmplY3RJZCh4LCBrZXkpIHtcbiAgeFtrZXldID0gaW5zcGVjdGFibGUoJ09iamVjdElkKFwiJyArIHhba2V5XS50b0hleFN0cmluZygpICsgJ1wiKScpO1xufVxuZnVuY3Rpb24gZm9ybWF0RGF0ZSh4LCBrZXksIHNoZWxsKSB7XG4gIGlmIChzaGVsbCkge1xuICAgIHhba2V5XSA9IGluc3BlY3RhYmxlKCdJU09EYXRlKFwiJyArIHhba2V5XS50b1VUQ1N0cmluZygpICsgJ1wiKScpO1xuICB9IGVsc2Uge1xuICAgIHhba2V5XSA9IGluc3BlY3RhYmxlKCduZXcgRGF0ZShcIicgKyB4W2tleV0udG9VVENTdHJpbmcoKSArICdcIiknKTtcbiAgfVxufVxuZnVuY3Rpb24gZm9ybWF0KG9iaiwgc3ViLCBjb2xvciwgc2hlbGwpIHtcbiAgaWYgKG9iaiAmJiB0eXBlb2Ygb2JqLnRvQlNPTiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIG9iaiA9IG9iai50b0JTT04oKTtcbiAgfVxuICBpZiAob2JqID09IG51bGwpIHtcbiAgICByZXR1cm4gb2JqO1xuICB9XG5cbiAgY29uc3QgY2xvbmUgPSByZXF1aXJlKCcuLi8uLi9oZWxwZXJzL2Nsb25lJyk7XG4gIGxldCB4ID0gY2xvbmUob2JqLCBpbnRlcm5hbFRvT2JqZWN0T3B0aW9ucyk7XG4gIGNvbnN0IGNvbnN0cnVjdG9yTmFtZSA9IGdldENvbnN0cnVjdG9yTmFtZSh4KTtcblxuICBpZiAoY29uc3RydWN0b3JOYW1lID09PSAnQmluYXJ5Jykge1xuICAgIHggPSAnQmluRGF0YSgnICsgeC5zdWJfdHlwZSArICcsIFwiJyArIHgudG9TdHJpbmcoJ2Jhc2U2NCcpICsgJ1wiKSc7XG4gIH0gZWxzZSBpZiAoY29uc3RydWN0b3JOYW1lID09PSAnT2JqZWN0SWQnKSB7XG4gICAgeCA9IGluc3BlY3RhYmxlKCdPYmplY3RJZChcIicgKyB4LnRvSGV4U3RyaW5nKCkgKyAnXCIpJyk7XG4gIH0gZWxzZSBpZiAoY29uc3RydWN0b3JOYW1lID09PSAnRGF0ZScpIHtcbiAgICB4ID0gaW5zcGVjdGFibGUoJ25ldyBEYXRlKFwiJyArIHgudG9VVENTdHJpbmcoKSArICdcIiknKTtcbiAgfSBlbHNlIGlmIChjb25zdHJ1Y3Rvck5hbWUgPT09ICdPYmplY3QnKSB7XG4gICAgY29uc3Qga2V5cyA9IE9iamVjdC5rZXlzKHgpO1xuICAgIGNvbnN0IG51bUtleXMgPSBrZXlzLmxlbmd0aDtcbiAgICBsZXQga2V5O1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbnVtS2V5czsgKytpKSB7XG4gICAgICBrZXkgPSBrZXlzW2ldO1xuICAgICAgaWYgKHhba2V5XSkge1xuICAgICAgICBsZXQgZXJyb3I7XG4gICAgICAgIGlmICh0eXBlb2YgeFtrZXldLnRvQlNPTiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAvLyBgc2Vzc2lvbi50b0JTT04oKWAgdGhyb3dzIGFuIGVycm9yLiBUaGlzIG1lYW5zIHdlIHRocm93IGVycm9yc1xuICAgICAgICAgICAgLy8gaW4gZGVidWcgbW9kZSB3aGVuIHVzaW5nIHRyYW5zYWN0aW9ucywgc2VlIGdoLTY3MTIuIEFzIGFcbiAgICAgICAgICAgIC8vIHdvcmthcm91bmQsIGNhdGNoIGB0b0JTT04oKWAgZXJyb3JzLCB0cnkgdG8gc2VyaWFsaXplIHdpdGhvdXRcbiAgICAgICAgICAgIC8vIGB0b0JTT04oKWAsIGFuZCByZXRocm93IGlmIHNlcmlhbGl6YXRpb24gc3RpbGwgZmFpbHMuXG4gICAgICAgICAgICB4W2tleV0gPSB4W2tleV0udG9CU09OKCk7XG4gICAgICAgICAgfSBjYXRjaCAoX2Vycm9yKSB7XG4gICAgICAgICAgICBlcnJvciA9IF9lcnJvcjtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgX2NvbnN0cnVjdG9yTmFtZSA9IGdldENvbnN0cnVjdG9yTmFtZSh4W2tleV0pO1xuICAgICAgICBpZiAoX2NvbnN0cnVjdG9yTmFtZSA9PT0gJ0JpbmFyeScpIHtcbiAgICAgICAgICB4W2tleV0gPSAnQmluRGF0YSgnICsgeFtrZXldLnN1Yl90eXBlICsgJywgXCInICtcbiAgICAgICAgICAgIHhba2V5XS5idWZmZXIudG9TdHJpbmcoJ2Jhc2U2NCcpICsgJ1wiKSc7XG4gICAgICAgIH0gZWxzZSBpZiAoX2NvbnN0cnVjdG9yTmFtZSA9PT0gJ09iamVjdCcpIHtcbiAgICAgICAgICB4W2tleV0gPSBmb3JtYXQoeFtrZXldLCB0cnVlKTtcbiAgICAgICAgfSBlbHNlIGlmIChfY29uc3RydWN0b3JOYW1lID09PSAnT2JqZWN0SWQnKSB7XG4gICAgICAgICAgZm9ybWF0T2JqZWN0SWQoeCwga2V5KTtcbiAgICAgICAgfSBlbHNlIGlmIChfY29uc3RydWN0b3JOYW1lID09PSAnRGF0ZScpIHtcbiAgICAgICAgICBmb3JtYXREYXRlKHgsIGtleSwgc2hlbGwpO1xuICAgICAgICB9IGVsc2UgaWYgKF9jb25zdHJ1Y3Rvck5hbWUgPT09ICdDbGllbnRTZXNzaW9uJykge1xuICAgICAgICAgIHhba2V5XSA9IGluc3BlY3RhYmxlKCdDbGllbnRTZXNzaW9uKFwiJyArXG4gICAgICAgICAgICAoXG4gICAgICAgICAgICAgIHhba2V5XSAmJlxuICAgICAgICAgICAgICB4W2tleV0uaWQgJiZcbiAgICAgICAgICAgICAgeFtrZXldLmlkLmlkICYmXG4gICAgICAgICAgICAgIHhba2V5XS5pZC5pZC5idWZmZXIgfHwgJydcbiAgICAgICAgICAgICkudG9TdHJpbmcoJ2hleCcpICsgJ1wiKScpO1xuICAgICAgICB9IGVsc2UgaWYgKEFycmF5LmlzQXJyYXkoeFtrZXldKSkge1xuICAgICAgICAgIHhba2V5XSA9IHhba2V5XS5tYXAobWFwKTtcbiAgICAgICAgfSBlbHNlIGlmIChlcnJvciAhPSBudWxsKSB7XG4gICAgICAgICAgLy8gSWYgdGhlcmUgd2FzIGFuIGVycm9yIHdpdGggYHRvQlNPTigpYCBhbmQgdGhlIG9iamVjdCB3YXNuJ3RcbiAgICAgICAgICAvLyBhbHJlYWR5IGNvbnZlcnRlZCB0byBhIHN0cmluZyByZXByZXNlbnRhdGlvbiwgcmV0aHJvdyBpdC5cbiAgICAgICAgICAvLyBPcGVuIHRvIGJldHRlciBpZGVhcyBvbiBob3cgdG8gaGFuZGxlIHRoaXMuXG4gICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgaWYgKHN1Yikge1xuICAgIHJldHVybiB4O1xuICB9XG5cbiAgcmV0dXJuIHV0aWwuXG4gICAgaW5zcGVjdCh4LCBmYWxzZSwgMTAsIGNvbG9yKS5cbiAgICByZXBsYWNlKC9cXG4vZywgJycpLlxuICAgIHJlcGxhY2UoL1xcc3syLH0vZywgJyAnKTtcbn1cblxuLyoqXG4gKiBSZXRyaWV2ZXMgaW5mb3JtYXRpb24gYWJvdXQgdGhpcyBjb2xsZWN0aW9ucyBpbmRleGVzLlxuICpcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrXG4gKiBAbWV0aG9kIGdldEluZGV4ZXNcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuTmF0aXZlQ29sbGVjdGlvbi5wcm90b3R5cGUuZ2V0SW5kZXhlcyA9IE5hdGl2ZUNvbGxlY3Rpb24ucHJvdG90eXBlLmluZGV4SW5mb3JtYXRpb247XG5cbi8qIVxuICogTW9kdWxlIGV4cG9ydHMuXG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSBOYXRpdmVDb2xsZWN0aW9uO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/mongoose/lib/drivers/node-mongodb-native/collection.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/mongoose/lib/drivers/node-mongodb-native/connection.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/mongoose/lib/drivers/node-mongodb-native/connection.js ***!
  \*****************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("/*!\n * Module dependencies.\n */\n\n\n\nconst MongooseConnection = __webpack_require__(/*! ../../connection */ \"(ssr)/./node_modules/mongoose/lib/connection.js\");\nconst MongooseError = __webpack_require__(/*! ../../error/index */ \"(ssr)/./node_modules/mongoose/lib/error/index.js\");\nconst STATES = __webpack_require__(/*! ../../connectionState */ \"(ssr)/./node_modules/mongoose/lib/connectionState.js\");\nconst mongodb = __webpack_require__(/*! mongodb */ \"(ssr)/./node_modules/mongodb/lib/index.js\");\nconst pkg = __webpack_require__(/*! ../../../package.json */ \"(ssr)/./node_modules/mongoose/package.json\");\nconst processConnectionOptions = __webpack_require__(/*! ../../helpers/processConnectionOptions */ \"(ssr)/./node_modules/mongoose/lib/helpers/processConnectionOptions.js\");\nconst setTimeout = (__webpack_require__(/*! ../../helpers/timers */ \"(ssr)/./node_modules/mongoose/lib/helpers/timers.js\").setTimeout);\nconst utils = __webpack_require__(/*! ../../utils */ \"(ssr)/./node_modules/mongoose/lib/utils.js\");\n\n/**\n * A [node-mongodb-native](https://github.com/mongodb/node-mongodb-native) connection implementation.\n *\n * @inherits Connection\n * @api private\n */\n\nfunction NativeConnection() {\n  MongooseConnection.apply(this, arguments);\n  this._listening = false;\n}\n\n/**\n * Expose the possible connection states.\n * @api public\n */\n\nNativeConnection.STATES = STATES;\n\n/*!\n * Inherits from Connection.\n */\n\nObject.setPrototypeOf(NativeConnection.prototype, MongooseConnection.prototype);\n\n/**\n * Switches to a different database using the same connection pool.\n *\n * Returns a new connection object, with the new db. If you set the `useCache`\n * option, `useDb()` will cache connections by `name`.\n *\n * **Note:** Calling `close()` on a `useDb()` connection will close the base connection as well.\n *\n * @param {String} name The database name\n * @param {Object} [options]\n * @param {Boolean} [options.useCache=false] If true, cache results so calling `useDb()` multiple times with the same name only creates 1 connection object.\n * @param {Boolean} [options.noListener=false] If true, the new connection object won't listen to any events on the base connection. This is better for memory usage in cases where you're calling `useDb()` for every request.\n * @return {Connection} New Connection Object\n * @api public\n */\n\nNativeConnection.prototype.useDb = function(name, options) {\n  // Return immediately if cached\n  options = options || {};\n  if (options.useCache && this.relatedDbs[name]) {\n    return this.relatedDbs[name];\n  }\n\n  // we have to manually copy all of the attributes...\n  const newConn = new this.constructor();\n  newConn.name = name;\n  newConn.base = this.base;\n  newConn.collections = {};\n  newConn.models = {};\n  newConn.replica = this.replica;\n  newConn.config = Object.assign({}, this.config, newConn.config);\n  newConn.name = this.name;\n  newConn.options = this.options;\n  newConn._readyState = this._readyState;\n  newConn._closeCalled = this._closeCalled;\n  newConn._hasOpened = this._hasOpened;\n  newConn._listening = false;\n  newConn._parent = this;\n\n  newConn.host = this.host;\n  newConn.port = this.port;\n  newConn.user = this.user;\n  newConn.pass = this.pass;\n\n  // First, when we create another db object, we are not guaranteed to have a\n  // db object to work with. So, in the case where we have a db object and it\n  // is connected, we can just proceed with setting everything up. However, if\n  // we do not have a db or the state is not connected, then we need to wait on\n  // the 'open' event of the connection before doing the rest of the setup\n  // the 'connected' event is the first time we'll have access to the db object\n\n  const _this = this;\n\n  newConn.client = _this.client;\n\n  if (this.db && this._readyState === STATES.connected) {\n    wireup();\n  } else {\n    this.once('connected', wireup);\n  }\n\n  function wireup() {\n    newConn.client = _this.client;\n    const _opts = {};\n    if (options.hasOwnProperty('noListener')) {\n      _opts.noListener = options.noListener;\n    }\n    newConn.db = _this.client.db(name, _opts);\n    newConn.onOpen();\n  }\n\n  newConn.name = name;\n\n  // push onto the otherDbs stack, this is used when state changes\n  if (options.noListener !== true) {\n    this.otherDbs.push(newConn);\n  }\n  newConn.otherDbs.push(this);\n\n  // push onto the relatedDbs cache, this is used when state changes\n  if (options && options.useCache) {\n    this.relatedDbs[newConn.name] = newConn;\n    newConn.relatedDbs = this.relatedDbs;\n  }\n\n  return newConn;\n};\n\n/**\n * Removes the database connection with the given name created with `useDb()`.\n *\n * Throws an error if the database connection was not found.\n *\n * #### Example:\n *\n *     // Connect to `initialdb` first\n *     const conn = await mongoose.createConnection('mongodb://127.0.0.1:27017/initialdb').asPromise();\n *\n *     // Creates an un-cached connection to `mydb`\n *     const db = conn.useDb('mydb');\n *\n *     // Closes `db`, and removes `db` from `conn.relatedDbs` and `conn.otherDbs`\n *     await conn.removeDb('mydb');\n *\n * @method removeDb\n * @memberOf Connection\n * @param {String} name The database name\n * @return {Connection} this\n */\n\nNativeConnection.prototype.removeDb = function removeDb(name) {\n  const dbs = this.otherDbs.filter(db => db.name === name);\n  if (!dbs.length) {\n    throw new MongooseError(`No connections to database \"${name}\" found`);\n  }\n\n  for (const db of dbs) {\n    db._closeCalled = true;\n    db._destroyCalled = true;\n    db._readyState = STATES.disconnected;\n    db.$wasForceClosed = true;\n  }\n  delete this.relatedDbs[name];\n  this.otherDbs = this.otherDbs.filter(db => db.name !== name);\n};\n\n/**\n * Closes the connection\n *\n * @param {Boolean} [force]\n * @return {Connection} this\n * @api private\n */\n\nNativeConnection.prototype.doClose = async function doClose(force) {\n  if (this.client == null) {\n    return this;\n  }\n\n  let skipCloseClient = false;\n  if (force != null && typeof force === 'object') {\n    skipCloseClient = force.skipCloseClient;\n    force = force.force;\n  }\n\n  if (skipCloseClient) {\n    return this;\n  }\n\n  await this.client.close(force);\n  // Defer because the driver will wait at least 1ms before finishing closing\n  // the pool, see https://github.com/mongodb-js/mongodb-core/blob/a8f8e4ce41936babc3b9112bf42d609779f03b39/lib/connection/pool.js#L1026-L1030.\n  // If there's queued operations, you may still get some background work\n  // after the callback is called.\n  await new Promise(resolve => setTimeout(resolve, 1));\n\n  return this;\n};\n\n/*!\n * ignore\n */\n\nNativeConnection.prototype.createClient = async function createClient(uri, options) {\n  if (typeof uri !== 'string') {\n    throw new MongooseError('The `uri` parameter to `openUri()` must be a ' +\n      `string, got \"${typeof uri}\". Make sure the first parameter to ` +\n      '`mongoose.connect()` or `mongoose.createConnection()` is a string.');\n  }\n\n  if (this._destroyCalled) {\n    throw new MongooseError(\n      'Connection has been closed and destroyed, and cannot be used for re-opening the connection. ' +\n      'Please create a new connection with `mongoose.createConnection()` or `mongoose.connect()`.'\n    );\n  }\n\n  if (this.readyState === STATES.connecting || this.readyState === STATES.connected) {\n    if (this._connectionString !== uri) {\n      throw new MongooseError('Can\\'t call `openUri()` on an active connection with ' +\n        'different connection strings. Make sure you aren\\'t calling `mongoose.connect()` ' +\n        'multiple times. See: https://mongoosejs.com/docs/connections.html#multiple_connections');\n    }\n  }\n\n  options = processConnectionOptions(uri, options);\n\n  if (options) {\n\n    const autoIndex = options.config && options.config.autoIndex != null ?\n      options.config.autoIndex :\n      options.autoIndex;\n    if (autoIndex != null) {\n      this.config.autoIndex = autoIndex !== false;\n      delete options.config;\n      delete options.autoIndex;\n    }\n\n    if ('autoCreate' in options) {\n      this.config.autoCreate = !!options.autoCreate;\n      delete options.autoCreate;\n    }\n\n    if ('sanitizeFilter' in options) {\n      this.config.sanitizeFilter = options.sanitizeFilter;\n      delete options.sanitizeFilter;\n    }\n\n    // Backwards compat\n    if (options.user || options.pass) {\n      options.auth = options.auth || {};\n      options.auth.username = options.user;\n      options.auth.password = options.pass;\n\n      this.user = options.user;\n      this.pass = options.pass;\n    }\n    delete options.user;\n    delete options.pass;\n\n    if (options.bufferCommands != null) {\n      this.config.bufferCommands = options.bufferCommands;\n      delete options.bufferCommands;\n    }\n  } else {\n    options = {};\n  }\n\n  this._connectionOptions = options;\n  const dbName = options.dbName;\n  if (dbName != null) {\n    this.$dbName = dbName;\n  }\n  delete options.dbName;\n\n  if (!utils.hasUserDefinedProperty(options, 'driverInfo')) {\n    options.driverInfo = {\n      name: 'Mongoose',\n      version: pkg.version\n    };\n  }\n\n  this.readyState = STATES.connecting;\n  this._connectionString = uri;\n\n  let client;\n  try {\n    client = new mongodb.MongoClient(uri, options);\n  } catch (error) {\n    this.readyState = STATES.disconnected;\n    throw error;\n  }\n  this.client = client;\n\n  client.setMaxListeners(0);\n  await client.connect();\n\n  _setClient(this, client, options, dbName);\n\n  for (const db of this.otherDbs) {\n    _setClient(db, client, {}, db.name);\n  }\n  return this;\n};\n\n/*!\n * ignore\n */\n\nNativeConnection.prototype.setClient = function setClient(client) {\n  if (!(client instanceof mongodb.MongoClient)) {\n    throw new MongooseError('Must call `setClient()` with an instance of MongoClient');\n  }\n  if (this.readyState !== STATES.disconnected) {\n    throw new MongooseError('Cannot call `setClient()` on a connection that is already connected.');\n  }\n  if (client.topology == null) {\n    throw new MongooseError('Cannot call `setClient()` with a MongoClient that you have not called `connect()` on yet.');\n  }\n\n  this._connectionString = client.s.url;\n  _setClient(this, client, {}, client.s.options.dbName);\n\n  for (const model of Object.values(this.models)) {\n    // Errors handled internally, so safe to ignore error\n    model.init().catch(function $modelInitNoop() {});\n  }\n\n  return this;\n};\n\n/*!\n * ignore\n */\n\nfunction _setClient(conn, client, options, dbName) {\n  const db = dbName != null ? client.db(dbName) : client.db();\n  conn.db = db;\n  conn.client = client;\n  conn.host = client &&\n    client.s &&\n    client.s.options &&\n    client.s.options.hosts &&\n    client.s.options.hosts[0] &&\n    client.s.options.hosts[0].host || void 0;\n  conn.port = client &&\n    client.s &&\n    client.s.options &&\n    client.s.options.hosts &&\n    client.s.options.hosts[0] &&\n    client.s.options.hosts[0].port || void 0;\n  conn.name = dbName != null ? dbName : db.databaseName;\n  conn._closeCalled = client._closeCalled;\n\n  const _handleReconnect = () => {\n    // If we aren't disconnected, we assume this reconnect is due to a\n    // socket timeout. If there's no activity on a socket for\n    // `socketTimeoutMS`, the driver will attempt to reconnect and emit\n    // this event.\n    if (conn.readyState !== STATES.connected) {\n      conn.readyState = STATES.connected;\n      conn.emit('reconnect');\n      conn.emit('reconnected');\n      conn.onOpen();\n    }\n  };\n\n  const type = client &&\n  client.topology &&\n  client.topology.description &&\n  client.topology.description.type || '';\n\n  if (type === 'Single') {\n    client.on('serverDescriptionChanged', ev => {\n      const newDescription = ev.newDescription;\n      if (newDescription.type === 'Unknown') {\n        conn.readyState = STATES.disconnected;\n      } else {\n        _handleReconnect();\n      }\n    });\n  } else if (type.startsWith('ReplicaSet')) {\n    client.on('topologyDescriptionChanged', ev => {\n      // Emit disconnected if we've lost connectivity to the primary\n      const description = ev.newDescription;\n      if (conn.readyState === STATES.connected && description.type !== 'ReplicaSetWithPrimary') {\n        // Implicitly emits 'disconnected'\n        conn.readyState = STATES.disconnected;\n      } else if (conn.readyState === STATES.disconnected && description.type === 'ReplicaSetWithPrimary') {\n        _handleReconnect();\n      }\n    });\n  }\n\n  conn.onOpen();\n\n  for (const i in conn.collections) {\n    if (utils.object.hasOwnProperty(conn.collections, i)) {\n      conn.collections[i].onOpen();\n    }\n  }\n}\n\n\n/*!\n * Module exports.\n */\n\nmodule.exports = NativeConnection;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbW9uZ29vc2UvbGliL2RyaXZlcnMvbm9kZS1tb25nb2RiLW5hdGl2ZS9jb25uZWN0aW9uLmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTs7QUFFYTs7QUFFYiwyQkFBMkIsbUJBQU8sQ0FBQyx5RUFBa0I7QUFDckQsc0JBQXNCLG1CQUFPLENBQUMsMkVBQW1CO0FBQ2pELGVBQWUsbUJBQU8sQ0FBQyxtRkFBdUI7QUFDOUMsZ0JBQWdCLG1CQUFPLENBQUMsMERBQVM7QUFDakMsWUFBWSxtQkFBTyxDQUFDLHlFQUF1QjtBQUMzQyxpQ0FBaUMsbUJBQU8sQ0FBQyxxSEFBd0M7QUFDakYsbUJBQW1CLG1IQUEwQztBQUM3RCxjQUFjLG1CQUFPLENBQUMsK0RBQWE7O0FBRW5DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsV0FBVyxTQUFTO0FBQ3BCLFdBQVcsU0FBUztBQUNwQixZQUFZLFlBQVk7QUFDeEI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUM7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFlBQVksWUFBWTtBQUN4Qjs7QUFFQTtBQUNBO0FBQ0E7QUFDQSwyREFBMkQsS0FBSztBQUNoRTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxTQUFTO0FBQ3BCLFlBQVksWUFBWTtBQUN4QjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsV0FBVztBQUNqQztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLDZCQUE2QjtBQUM3QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsNkJBQTZCOztBQUU3QjtBQUNBO0FBQ0EsbURBQW1EO0FBQ25EOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsS0FBSztBQUNMLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTs7QUFFQSIsInNvdXJjZXMiOlsid2VicGFjazovL2FwcDEvLi9ub2RlX21vZHVsZXMvbW9uZ29vc2UvbGliL2RyaXZlcnMvbm9kZS1tb25nb2RiLW5hdGl2ZS9jb25uZWN0aW9uLmpzPzk4M2EiXSwic291cmNlc0NvbnRlbnQiOlsiLyohXG4gKiBNb2R1bGUgZGVwZW5kZW5jaWVzLlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxuY29uc3QgTW9uZ29vc2VDb25uZWN0aW9uID0gcmVxdWlyZSgnLi4vLi4vY29ubmVjdGlvbicpO1xuY29uc3QgTW9uZ29vc2VFcnJvciA9IHJlcXVpcmUoJy4uLy4uL2Vycm9yL2luZGV4Jyk7XG5jb25zdCBTVEFURVMgPSByZXF1aXJlKCcuLi8uLi9jb25uZWN0aW9uU3RhdGUnKTtcbmNvbnN0IG1vbmdvZGIgPSByZXF1aXJlKCdtb25nb2RiJyk7XG5jb25zdCBwa2cgPSByZXF1aXJlKCcuLi8uLi8uLi9wYWNrYWdlLmpzb24nKTtcbmNvbnN0IHByb2Nlc3NDb25uZWN0aW9uT3B0aW9ucyA9IHJlcXVpcmUoJy4uLy4uL2hlbHBlcnMvcHJvY2Vzc0Nvbm5lY3Rpb25PcHRpb25zJyk7XG5jb25zdCBzZXRUaW1lb3V0ID0gcmVxdWlyZSgnLi4vLi4vaGVscGVycy90aW1lcnMnKS5zZXRUaW1lb3V0O1xuY29uc3QgdXRpbHMgPSByZXF1aXJlKCcuLi8uLi91dGlscycpO1xuXG4vKipcbiAqIEEgW25vZGUtbW9uZ29kYi1uYXRpdmVdKGh0dHBzOi8vZ2l0aHViLmNvbS9tb25nb2RiL25vZGUtbW9uZ29kYi1uYXRpdmUpIGNvbm5lY3Rpb24gaW1wbGVtZW50YXRpb24uXG4gKlxuICogQGluaGVyaXRzIENvbm5lY3Rpb25cbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmZ1bmN0aW9uIE5hdGl2ZUNvbm5lY3Rpb24oKSB7XG4gIE1vbmdvb3NlQ29ubmVjdGlvbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICB0aGlzLl9saXN0ZW5pbmcgPSBmYWxzZTtcbn1cblxuLyoqXG4gKiBFeHBvc2UgdGhlIHBvc3NpYmxlIGNvbm5lY3Rpb24gc3RhdGVzLlxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5OYXRpdmVDb25uZWN0aW9uLlNUQVRFUyA9IFNUQVRFUztcblxuLyohXG4gKiBJbmhlcml0cyBmcm9tIENvbm5lY3Rpb24uXG4gKi9cblxuT2JqZWN0LnNldFByb3RvdHlwZU9mKE5hdGl2ZUNvbm5lY3Rpb24ucHJvdG90eXBlLCBNb25nb29zZUNvbm5lY3Rpb24ucHJvdG90eXBlKTtcblxuLyoqXG4gKiBTd2l0Y2hlcyB0byBhIGRpZmZlcmVudCBkYXRhYmFzZSB1c2luZyB0aGUgc2FtZSBjb25uZWN0aW9uIHBvb2wuXG4gKlxuICogUmV0dXJucyBhIG5ldyBjb25uZWN0aW9uIG9iamVjdCwgd2l0aCB0aGUgbmV3IGRiLiBJZiB5b3Ugc2V0IHRoZSBgdXNlQ2FjaGVgXG4gKiBvcHRpb24sIGB1c2VEYigpYCB3aWxsIGNhY2hlIGNvbm5lY3Rpb25zIGJ5IGBuYW1lYC5cbiAqXG4gKiAqKk5vdGU6KiogQ2FsbGluZyBgY2xvc2UoKWAgb24gYSBgdXNlRGIoKWAgY29ubmVjdGlvbiB3aWxsIGNsb3NlIHRoZSBiYXNlIGNvbm5lY3Rpb24gYXMgd2VsbC5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gbmFtZSBUaGUgZGF0YWJhc2UgbmFtZVxuICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXVxuICogQHBhcmFtIHtCb29sZWFufSBbb3B0aW9ucy51c2VDYWNoZT1mYWxzZV0gSWYgdHJ1ZSwgY2FjaGUgcmVzdWx0cyBzbyBjYWxsaW5nIGB1c2VEYigpYCBtdWx0aXBsZSB0aW1lcyB3aXRoIHRoZSBzYW1lIG5hbWUgb25seSBjcmVhdGVzIDEgY29ubmVjdGlvbiBvYmplY3QuXG4gKiBAcGFyYW0ge0Jvb2xlYW59IFtvcHRpb25zLm5vTGlzdGVuZXI9ZmFsc2VdIElmIHRydWUsIHRoZSBuZXcgY29ubmVjdGlvbiBvYmplY3Qgd29uJ3QgbGlzdGVuIHRvIGFueSBldmVudHMgb24gdGhlIGJhc2UgY29ubmVjdGlvbi4gVGhpcyBpcyBiZXR0ZXIgZm9yIG1lbW9yeSB1c2FnZSBpbiBjYXNlcyB3aGVyZSB5b3UncmUgY2FsbGluZyBgdXNlRGIoKWAgZm9yIGV2ZXJ5IHJlcXVlc3QuXG4gKiBAcmV0dXJuIHtDb25uZWN0aW9ufSBOZXcgQ29ubmVjdGlvbiBPYmplY3RcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuTmF0aXZlQ29ubmVjdGlvbi5wcm90b3R5cGUudXNlRGIgPSBmdW5jdGlvbihuYW1lLCBvcHRpb25zKSB7XG4gIC8vIFJldHVybiBpbW1lZGlhdGVseSBpZiBjYWNoZWRcbiAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gIGlmIChvcHRpb25zLnVzZUNhY2hlICYmIHRoaXMucmVsYXRlZERic1tuYW1lXSkge1xuICAgIHJldHVybiB0aGlzLnJlbGF0ZWREYnNbbmFtZV07XG4gIH1cblxuICAvLyB3ZSBoYXZlIHRvIG1hbnVhbGx5IGNvcHkgYWxsIG9mIHRoZSBhdHRyaWJ1dGVzLi4uXG4gIGNvbnN0IG5ld0Nvbm4gPSBuZXcgdGhpcy5jb25zdHJ1Y3RvcigpO1xuICBuZXdDb25uLm5hbWUgPSBuYW1lO1xuICBuZXdDb25uLmJhc2UgPSB0aGlzLmJhc2U7XG4gIG5ld0Nvbm4uY29sbGVjdGlvbnMgPSB7fTtcbiAgbmV3Q29ubi5tb2RlbHMgPSB7fTtcbiAgbmV3Q29ubi5yZXBsaWNhID0gdGhpcy5yZXBsaWNhO1xuICBuZXdDb25uLmNvbmZpZyA9IE9iamVjdC5hc3NpZ24oe30sIHRoaXMuY29uZmlnLCBuZXdDb25uLmNvbmZpZyk7XG4gIG5ld0Nvbm4ubmFtZSA9IHRoaXMubmFtZTtcbiAgbmV3Q29ubi5vcHRpb25zID0gdGhpcy5vcHRpb25zO1xuICBuZXdDb25uLl9yZWFkeVN0YXRlID0gdGhpcy5fcmVhZHlTdGF0ZTtcbiAgbmV3Q29ubi5fY2xvc2VDYWxsZWQgPSB0aGlzLl9jbG9zZUNhbGxlZDtcbiAgbmV3Q29ubi5faGFzT3BlbmVkID0gdGhpcy5faGFzT3BlbmVkO1xuICBuZXdDb25uLl9saXN0ZW5pbmcgPSBmYWxzZTtcbiAgbmV3Q29ubi5fcGFyZW50ID0gdGhpcztcblxuICBuZXdDb25uLmhvc3QgPSB0aGlzLmhvc3Q7XG4gIG5ld0Nvbm4ucG9ydCA9IHRoaXMucG9ydDtcbiAgbmV3Q29ubi51c2VyID0gdGhpcy51c2VyO1xuICBuZXdDb25uLnBhc3MgPSB0aGlzLnBhc3M7XG5cbiAgLy8gRmlyc3QsIHdoZW4gd2UgY3JlYXRlIGFub3RoZXIgZGIgb2JqZWN0LCB3ZSBhcmUgbm90IGd1YXJhbnRlZWQgdG8gaGF2ZSBhXG4gIC8vIGRiIG9iamVjdCB0byB3b3JrIHdpdGguIFNvLCBpbiB0aGUgY2FzZSB3aGVyZSB3ZSBoYXZlIGEgZGIgb2JqZWN0IGFuZCBpdFxuICAvLyBpcyBjb25uZWN0ZWQsIHdlIGNhbiBqdXN0IHByb2NlZWQgd2l0aCBzZXR0aW5nIGV2ZXJ5dGhpbmcgdXAuIEhvd2V2ZXIsIGlmXG4gIC8vIHdlIGRvIG5vdCBoYXZlIGEgZGIgb3IgdGhlIHN0YXRlIGlzIG5vdCBjb25uZWN0ZWQsIHRoZW4gd2UgbmVlZCB0byB3YWl0IG9uXG4gIC8vIHRoZSAnb3BlbicgZXZlbnQgb2YgdGhlIGNvbm5lY3Rpb24gYmVmb3JlIGRvaW5nIHRoZSByZXN0IG9mIHRoZSBzZXR1cFxuICAvLyB0aGUgJ2Nvbm5lY3RlZCcgZXZlbnQgaXMgdGhlIGZpcnN0IHRpbWUgd2UnbGwgaGF2ZSBhY2Nlc3MgdG8gdGhlIGRiIG9iamVjdFxuXG4gIGNvbnN0IF90aGlzID0gdGhpcztcblxuICBuZXdDb25uLmNsaWVudCA9IF90aGlzLmNsaWVudDtcblxuICBpZiAodGhpcy5kYiAmJiB0aGlzLl9yZWFkeVN0YXRlID09PSBTVEFURVMuY29ubmVjdGVkKSB7XG4gICAgd2lyZXVwKCk7XG4gIH0gZWxzZSB7XG4gICAgdGhpcy5vbmNlKCdjb25uZWN0ZWQnLCB3aXJldXApO1xuICB9XG5cbiAgZnVuY3Rpb24gd2lyZXVwKCkge1xuICAgIG5ld0Nvbm4uY2xpZW50ID0gX3RoaXMuY2xpZW50O1xuICAgIGNvbnN0IF9vcHRzID0ge307XG4gICAgaWYgKG9wdGlvbnMuaGFzT3duUHJvcGVydHkoJ25vTGlzdGVuZXInKSkge1xuICAgICAgX29wdHMubm9MaXN0ZW5lciA9IG9wdGlvbnMubm9MaXN0ZW5lcjtcbiAgICB9XG4gICAgbmV3Q29ubi5kYiA9IF90aGlzLmNsaWVudC5kYihuYW1lLCBfb3B0cyk7XG4gICAgbmV3Q29ubi5vbk9wZW4oKTtcbiAgfVxuXG4gIG5ld0Nvbm4ubmFtZSA9IG5hbWU7XG5cbiAgLy8gcHVzaCBvbnRvIHRoZSBvdGhlckRicyBzdGFjaywgdGhpcyBpcyB1c2VkIHdoZW4gc3RhdGUgY2hhbmdlc1xuICBpZiAob3B0aW9ucy5ub0xpc3RlbmVyICE9PSB0cnVlKSB7XG4gICAgdGhpcy5vdGhlckRicy5wdXNoKG5ld0Nvbm4pO1xuICB9XG4gIG5ld0Nvbm4ub3RoZXJEYnMucHVzaCh0aGlzKTtcblxuICAvLyBwdXNoIG9udG8gdGhlIHJlbGF0ZWREYnMgY2FjaGUsIHRoaXMgaXMgdXNlZCB3aGVuIHN0YXRlIGNoYW5nZXNcbiAgaWYgKG9wdGlvbnMgJiYgb3B0aW9ucy51c2VDYWNoZSkge1xuICAgIHRoaXMucmVsYXRlZERic1tuZXdDb25uLm5hbWVdID0gbmV3Q29ubjtcbiAgICBuZXdDb25uLnJlbGF0ZWREYnMgPSB0aGlzLnJlbGF0ZWREYnM7XG4gIH1cblxuICByZXR1cm4gbmV3Q29ubjtcbn07XG5cbi8qKlxuICogUmVtb3ZlcyB0aGUgZGF0YWJhc2UgY29ubmVjdGlvbiB3aXRoIHRoZSBnaXZlbiBuYW1lIGNyZWF0ZWQgd2l0aCBgdXNlRGIoKWAuXG4gKlxuICogVGhyb3dzIGFuIGVycm9yIGlmIHRoZSBkYXRhYmFzZSBjb25uZWN0aW9uIHdhcyBub3QgZm91bmQuXG4gKlxuICogIyMjIyBFeGFtcGxlOlxuICpcbiAqICAgICAvLyBDb25uZWN0IHRvIGBpbml0aWFsZGJgIGZpcnN0XG4gKiAgICAgY29uc3QgY29ubiA9IGF3YWl0IG1vbmdvb3NlLmNyZWF0ZUNvbm5lY3Rpb24oJ21vbmdvZGI6Ly8xMjcuMC4wLjE6MjcwMTcvaW5pdGlhbGRiJykuYXNQcm9taXNlKCk7XG4gKlxuICogICAgIC8vIENyZWF0ZXMgYW4gdW4tY2FjaGVkIGNvbm5lY3Rpb24gdG8gYG15ZGJgXG4gKiAgICAgY29uc3QgZGIgPSBjb25uLnVzZURiKCdteWRiJyk7XG4gKlxuICogICAgIC8vIENsb3NlcyBgZGJgLCBhbmQgcmVtb3ZlcyBgZGJgIGZyb20gYGNvbm4ucmVsYXRlZERic2AgYW5kIGBjb25uLm90aGVyRGJzYFxuICogICAgIGF3YWl0IGNvbm4ucmVtb3ZlRGIoJ215ZGInKTtcbiAqXG4gKiBAbWV0aG9kIHJlbW92ZURiXG4gKiBAbWVtYmVyT2YgQ29ubmVjdGlvblxuICogQHBhcmFtIHtTdHJpbmd9IG5hbWUgVGhlIGRhdGFiYXNlIG5hbWVcbiAqIEByZXR1cm4ge0Nvbm5lY3Rpb259IHRoaXNcbiAqL1xuXG5OYXRpdmVDb25uZWN0aW9uLnByb3RvdHlwZS5yZW1vdmVEYiA9IGZ1bmN0aW9uIHJlbW92ZURiKG5hbWUpIHtcbiAgY29uc3QgZGJzID0gdGhpcy5vdGhlckRicy5maWx0ZXIoZGIgPT4gZGIubmFtZSA9PT0gbmFtZSk7XG4gIGlmICghZGJzLmxlbmd0aCkge1xuICAgIHRocm93IG5ldyBNb25nb29zZUVycm9yKGBObyBjb25uZWN0aW9ucyB0byBkYXRhYmFzZSBcIiR7bmFtZX1cIiBmb3VuZGApO1xuICB9XG5cbiAgZm9yIChjb25zdCBkYiBvZiBkYnMpIHtcbiAgICBkYi5fY2xvc2VDYWxsZWQgPSB0cnVlO1xuICAgIGRiLl9kZXN0cm95Q2FsbGVkID0gdHJ1ZTtcbiAgICBkYi5fcmVhZHlTdGF0ZSA9IFNUQVRFUy5kaXNjb25uZWN0ZWQ7XG4gICAgZGIuJHdhc0ZvcmNlQ2xvc2VkID0gdHJ1ZTtcbiAgfVxuICBkZWxldGUgdGhpcy5yZWxhdGVkRGJzW25hbWVdO1xuICB0aGlzLm90aGVyRGJzID0gdGhpcy5vdGhlckRicy5maWx0ZXIoZGIgPT4gZGIubmFtZSAhPT0gbmFtZSk7XG59O1xuXG4vKipcbiAqIENsb3NlcyB0aGUgY29ubmVjdGlvblxuICpcbiAqIEBwYXJhbSB7Qm9vbGVhbn0gW2ZvcmNlXVxuICogQHJldHVybiB7Q29ubmVjdGlvbn0gdGhpc1xuICogQGFwaSBwcml2YXRlXG4gKi9cblxuTmF0aXZlQ29ubmVjdGlvbi5wcm90b3R5cGUuZG9DbG9zZSA9IGFzeW5jIGZ1bmN0aW9uIGRvQ2xvc2UoZm9yY2UpIHtcbiAgaWYgKHRoaXMuY2xpZW50ID09IG51bGwpIHtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIGxldCBza2lwQ2xvc2VDbGllbnQgPSBmYWxzZTtcbiAgaWYgKGZvcmNlICE9IG51bGwgJiYgdHlwZW9mIGZvcmNlID09PSAnb2JqZWN0Jykge1xuICAgIHNraXBDbG9zZUNsaWVudCA9IGZvcmNlLnNraXBDbG9zZUNsaWVudDtcbiAgICBmb3JjZSA9IGZvcmNlLmZvcmNlO1xuICB9XG5cbiAgaWYgKHNraXBDbG9zZUNsaWVudCkge1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgYXdhaXQgdGhpcy5jbGllbnQuY2xvc2UoZm9yY2UpO1xuICAvLyBEZWZlciBiZWNhdXNlIHRoZSBkcml2ZXIgd2lsbCB3YWl0IGF0IGxlYXN0IDFtcyBiZWZvcmUgZmluaXNoaW5nIGNsb3NpbmdcbiAgLy8gdGhlIHBvb2wsIHNlZSBodHRwczovL2dpdGh1Yi5jb20vbW9uZ29kYi1qcy9tb25nb2RiLWNvcmUvYmxvYi9hOGY4ZTRjZTQxOTM2YmFiYzNiOTExMmJmNDJkNjA5Nzc5ZjAzYjM5L2xpYi9jb25uZWN0aW9uL3Bvb2wuanMjTDEwMjYtTDEwMzAuXG4gIC8vIElmIHRoZXJlJ3MgcXVldWVkIG9wZXJhdGlvbnMsIHlvdSBtYXkgc3RpbGwgZ2V0IHNvbWUgYmFja2dyb3VuZCB3b3JrXG4gIC8vIGFmdGVyIHRoZSBjYWxsYmFjayBpcyBjYWxsZWQuXG4gIGF3YWl0IG5ldyBQcm9taXNlKHJlc29sdmUgPT4gc2V0VGltZW91dChyZXNvbHZlLCAxKSk7XG5cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKiFcbiAqIGlnbm9yZVxuICovXG5cbk5hdGl2ZUNvbm5lY3Rpb24ucHJvdG90eXBlLmNyZWF0ZUNsaWVudCA9IGFzeW5jIGZ1bmN0aW9uIGNyZWF0ZUNsaWVudCh1cmksIG9wdGlvbnMpIHtcbiAgaWYgKHR5cGVvZiB1cmkgIT09ICdzdHJpbmcnKSB7XG4gICAgdGhyb3cgbmV3IE1vbmdvb3NlRXJyb3IoJ1RoZSBgdXJpYCBwYXJhbWV0ZXIgdG8gYG9wZW5VcmkoKWAgbXVzdCBiZSBhICcgK1xuICAgICAgYHN0cmluZywgZ290IFwiJHt0eXBlb2YgdXJpfVwiLiBNYWtlIHN1cmUgdGhlIGZpcnN0IHBhcmFtZXRlciB0byBgICtcbiAgICAgICdgbW9uZ29vc2UuY29ubmVjdCgpYCBvciBgbW9uZ29vc2UuY3JlYXRlQ29ubmVjdGlvbigpYCBpcyBhIHN0cmluZy4nKTtcbiAgfVxuXG4gIGlmICh0aGlzLl9kZXN0cm95Q2FsbGVkKSB7XG4gICAgdGhyb3cgbmV3IE1vbmdvb3NlRXJyb3IoXG4gICAgICAnQ29ubmVjdGlvbiBoYXMgYmVlbiBjbG9zZWQgYW5kIGRlc3Ryb3llZCwgYW5kIGNhbm5vdCBiZSB1c2VkIGZvciByZS1vcGVuaW5nIHRoZSBjb25uZWN0aW9uLiAnICtcbiAgICAgICdQbGVhc2UgY3JlYXRlIGEgbmV3IGNvbm5lY3Rpb24gd2l0aCBgbW9uZ29vc2UuY3JlYXRlQ29ubmVjdGlvbigpYCBvciBgbW9uZ29vc2UuY29ubmVjdCgpYC4nXG4gICAgKTtcbiAgfVxuXG4gIGlmICh0aGlzLnJlYWR5U3RhdGUgPT09IFNUQVRFUy5jb25uZWN0aW5nIHx8IHRoaXMucmVhZHlTdGF0ZSA9PT0gU1RBVEVTLmNvbm5lY3RlZCkge1xuICAgIGlmICh0aGlzLl9jb25uZWN0aW9uU3RyaW5nICE9PSB1cmkpIHtcbiAgICAgIHRocm93IG5ldyBNb25nb29zZUVycm9yKCdDYW5cXCd0IGNhbGwgYG9wZW5VcmkoKWAgb24gYW4gYWN0aXZlIGNvbm5lY3Rpb24gd2l0aCAnICtcbiAgICAgICAgJ2RpZmZlcmVudCBjb25uZWN0aW9uIHN0cmluZ3MuIE1ha2Ugc3VyZSB5b3UgYXJlblxcJ3QgY2FsbGluZyBgbW9uZ29vc2UuY29ubmVjdCgpYCAnICtcbiAgICAgICAgJ211bHRpcGxlIHRpbWVzLiBTZWU6IGh0dHBzOi8vbW9uZ29vc2Vqcy5jb20vZG9jcy9jb25uZWN0aW9ucy5odG1sI211bHRpcGxlX2Nvbm5lY3Rpb25zJyk7XG4gICAgfVxuICB9XG5cbiAgb3B0aW9ucyA9IHByb2Nlc3NDb25uZWN0aW9uT3B0aW9ucyh1cmksIG9wdGlvbnMpO1xuXG4gIGlmIChvcHRpb25zKSB7XG5cbiAgICBjb25zdCBhdXRvSW5kZXggPSBvcHRpb25zLmNvbmZpZyAmJiBvcHRpb25zLmNvbmZpZy5hdXRvSW5kZXggIT0gbnVsbCA/XG4gICAgICBvcHRpb25zLmNvbmZpZy5hdXRvSW5kZXggOlxuICAgICAgb3B0aW9ucy5hdXRvSW5kZXg7XG4gICAgaWYgKGF1dG9JbmRleCAhPSBudWxsKSB7XG4gICAgICB0aGlzLmNvbmZpZy5hdXRvSW5kZXggPSBhdXRvSW5kZXggIT09IGZhbHNlO1xuICAgICAgZGVsZXRlIG9wdGlvbnMuY29uZmlnO1xuICAgICAgZGVsZXRlIG9wdGlvbnMuYXV0b0luZGV4O1xuICAgIH1cblxuICAgIGlmICgnYXV0b0NyZWF0ZScgaW4gb3B0aW9ucykge1xuICAgICAgdGhpcy5jb25maWcuYXV0b0NyZWF0ZSA9ICEhb3B0aW9ucy5hdXRvQ3JlYXRlO1xuICAgICAgZGVsZXRlIG9wdGlvbnMuYXV0b0NyZWF0ZTtcbiAgICB9XG5cbiAgICBpZiAoJ3Nhbml0aXplRmlsdGVyJyBpbiBvcHRpb25zKSB7XG4gICAgICB0aGlzLmNvbmZpZy5zYW5pdGl6ZUZpbHRlciA9IG9wdGlvbnMuc2FuaXRpemVGaWx0ZXI7XG4gICAgICBkZWxldGUgb3B0aW9ucy5zYW5pdGl6ZUZpbHRlcjtcbiAgICB9XG5cbiAgICAvLyBCYWNrd2FyZHMgY29tcGF0XG4gICAgaWYgKG9wdGlvbnMudXNlciB8fCBvcHRpb25zLnBhc3MpIHtcbiAgICAgIG9wdGlvbnMuYXV0aCA9IG9wdGlvbnMuYXV0aCB8fCB7fTtcbiAgICAgIG9wdGlvbnMuYXV0aC51c2VybmFtZSA9IG9wdGlvbnMudXNlcjtcbiAgICAgIG9wdGlvbnMuYXV0aC5wYXNzd29yZCA9IG9wdGlvbnMucGFzcztcblxuICAgICAgdGhpcy51c2VyID0gb3B0aW9ucy51c2VyO1xuICAgICAgdGhpcy5wYXNzID0gb3B0aW9ucy5wYXNzO1xuICAgIH1cbiAgICBkZWxldGUgb3B0aW9ucy51c2VyO1xuICAgIGRlbGV0ZSBvcHRpb25zLnBhc3M7XG5cbiAgICBpZiAob3B0aW9ucy5idWZmZXJDb21tYW5kcyAhPSBudWxsKSB7XG4gICAgICB0aGlzLmNvbmZpZy5idWZmZXJDb21tYW5kcyA9IG9wdGlvbnMuYnVmZmVyQ29tbWFuZHM7XG4gICAgICBkZWxldGUgb3B0aW9ucy5idWZmZXJDb21tYW5kcztcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgb3B0aW9ucyA9IHt9O1xuICB9XG5cbiAgdGhpcy5fY29ubmVjdGlvbk9wdGlvbnMgPSBvcHRpb25zO1xuICBjb25zdCBkYk5hbWUgPSBvcHRpb25zLmRiTmFtZTtcbiAgaWYgKGRiTmFtZSAhPSBudWxsKSB7XG4gICAgdGhpcy4kZGJOYW1lID0gZGJOYW1lO1xuICB9XG4gIGRlbGV0ZSBvcHRpb25zLmRiTmFtZTtcblxuICBpZiAoIXV0aWxzLmhhc1VzZXJEZWZpbmVkUHJvcGVydHkob3B0aW9ucywgJ2RyaXZlckluZm8nKSkge1xuICAgIG9wdGlvbnMuZHJpdmVySW5mbyA9IHtcbiAgICAgIG5hbWU6ICdNb25nb29zZScsXG4gICAgICB2ZXJzaW9uOiBwa2cudmVyc2lvblxuICAgIH07XG4gIH1cblxuICB0aGlzLnJlYWR5U3RhdGUgPSBTVEFURVMuY29ubmVjdGluZztcbiAgdGhpcy5fY29ubmVjdGlvblN0cmluZyA9IHVyaTtcblxuICBsZXQgY2xpZW50O1xuICB0cnkge1xuICAgIGNsaWVudCA9IG5ldyBtb25nb2RiLk1vbmdvQ2xpZW50KHVyaSwgb3B0aW9ucyk7XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgdGhpcy5yZWFkeVN0YXRlID0gU1RBVEVTLmRpc2Nvbm5lY3RlZDtcbiAgICB0aHJvdyBlcnJvcjtcbiAgfVxuICB0aGlzLmNsaWVudCA9IGNsaWVudDtcblxuICBjbGllbnQuc2V0TWF4TGlzdGVuZXJzKDApO1xuICBhd2FpdCBjbGllbnQuY29ubmVjdCgpO1xuXG4gIF9zZXRDbGllbnQodGhpcywgY2xpZW50LCBvcHRpb25zLCBkYk5hbWUpO1xuXG4gIGZvciAoY29uc3QgZGIgb2YgdGhpcy5vdGhlckRicykge1xuICAgIF9zZXRDbGllbnQoZGIsIGNsaWVudCwge30sIGRiLm5hbWUpO1xuICB9XG4gIHJldHVybiB0aGlzO1xufTtcblxuLyohXG4gKiBpZ25vcmVcbiAqL1xuXG5OYXRpdmVDb25uZWN0aW9uLnByb3RvdHlwZS5zZXRDbGllbnQgPSBmdW5jdGlvbiBzZXRDbGllbnQoY2xpZW50KSB7XG4gIGlmICghKGNsaWVudCBpbnN0YW5jZW9mIG1vbmdvZGIuTW9uZ29DbGllbnQpKSB7XG4gICAgdGhyb3cgbmV3IE1vbmdvb3NlRXJyb3IoJ011c3QgY2FsbCBgc2V0Q2xpZW50KClgIHdpdGggYW4gaW5zdGFuY2Ugb2YgTW9uZ29DbGllbnQnKTtcbiAgfVxuICBpZiAodGhpcy5yZWFkeVN0YXRlICE9PSBTVEFURVMuZGlzY29ubmVjdGVkKSB7XG4gICAgdGhyb3cgbmV3IE1vbmdvb3NlRXJyb3IoJ0Nhbm5vdCBjYWxsIGBzZXRDbGllbnQoKWAgb24gYSBjb25uZWN0aW9uIHRoYXQgaXMgYWxyZWFkeSBjb25uZWN0ZWQuJyk7XG4gIH1cbiAgaWYgKGNsaWVudC50b3BvbG9neSA9PSBudWxsKSB7XG4gICAgdGhyb3cgbmV3IE1vbmdvb3NlRXJyb3IoJ0Nhbm5vdCBjYWxsIGBzZXRDbGllbnQoKWAgd2l0aCBhIE1vbmdvQ2xpZW50IHRoYXQgeW91IGhhdmUgbm90IGNhbGxlZCBgY29ubmVjdCgpYCBvbiB5ZXQuJyk7XG4gIH1cblxuICB0aGlzLl9jb25uZWN0aW9uU3RyaW5nID0gY2xpZW50LnMudXJsO1xuICBfc2V0Q2xpZW50KHRoaXMsIGNsaWVudCwge30sIGNsaWVudC5zLm9wdGlvbnMuZGJOYW1lKTtcblxuICBmb3IgKGNvbnN0IG1vZGVsIG9mIE9iamVjdC52YWx1ZXModGhpcy5tb2RlbHMpKSB7XG4gICAgLy8gRXJyb3JzIGhhbmRsZWQgaW50ZXJuYWxseSwgc28gc2FmZSB0byBpZ25vcmUgZXJyb3JcbiAgICBtb2RlbC5pbml0KCkuY2F0Y2goZnVuY3Rpb24gJG1vZGVsSW5pdE5vb3AoKSB7fSk7XG4gIH1cblxuICByZXR1cm4gdGhpcztcbn07XG5cbi8qIVxuICogaWdub3JlXG4gKi9cblxuZnVuY3Rpb24gX3NldENsaWVudChjb25uLCBjbGllbnQsIG9wdGlvbnMsIGRiTmFtZSkge1xuICBjb25zdCBkYiA9IGRiTmFtZSAhPSBudWxsID8gY2xpZW50LmRiKGRiTmFtZSkgOiBjbGllbnQuZGIoKTtcbiAgY29ubi5kYiA9IGRiO1xuICBjb25uLmNsaWVudCA9IGNsaWVudDtcbiAgY29ubi5ob3N0ID0gY2xpZW50ICYmXG4gICAgY2xpZW50LnMgJiZcbiAgICBjbGllbnQucy5vcHRpb25zICYmXG4gICAgY2xpZW50LnMub3B0aW9ucy5ob3N0cyAmJlxuICAgIGNsaWVudC5zLm9wdGlvbnMuaG9zdHNbMF0gJiZcbiAgICBjbGllbnQucy5vcHRpb25zLmhvc3RzWzBdLmhvc3QgfHwgdm9pZCAwO1xuICBjb25uLnBvcnQgPSBjbGllbnQgJiZcbiAgICBjbGllbnQucyAmJlxuICAgIGNsaWVudC5zLm9wdGlvbnMgJiZcbiAgICBjbGllbnQucy5vcHRpb25zLmhvc3RzICYmXG4gICAgY2xpZW50LnMub3B0aW9ucy5ob3N0c1swXSAmJlxuICAgIGNsaWVudC5zLm9wdGlvbnMuaG9zdHNbMF0ucG9ydCB8fCB2b2lkIDA7XG4gIGNvbm4ubmFtZSA9IGRiTmFtZSAhPSBudWxsID8gZGJOYW1lIDogZGIuZGF0YWJhc2VOYW1lO1xuICBjb25uLl9jbG9zZUNhbGxlZCA9IGNsaWVudC5fY2xvc2VDYWxsZWQ7XG5cbiAgY29uc3QgX2hhbmRsZVJlY29ubmVjdCA9ICgpID0+IHtcbiAgICAvLyBJZiB3ZSBhcmVuJ3QgZGlzY29ubmVjdGVkLCB3ZSBhc3N1bWUgdGhpcyByZWNvbm5lY3QgaXMgZHVlIHRvIGFcbiAgICAvLyBzb2NrZXQgdGltZW91dC4gSWYgdGhlcmUncyBubyBhY3Rpdml0eSBvbiBhIHNvY2tldCBmb3JcbiAgICAvLyBgc29ja2V0VGltZW91dE1TYCwgdGhlIGRyaXZlciB3aWxsIGF0dGVtcHQgdG8gcmVjb25uZWN0IGFuZCBlbWl0XG4gICAgLy8gdGhpcyBldmVudC5cbiAgICBpZiAoY29ubi5yZWFkeVN0YXRlICE9PSBTVEFURVMuY29ubmVjdGVkKSB7XG4gICAgICBjb25uLnJlYWR5U3RhdGUgPSBTVEFURVMuY29ubmVjdGVkO1xuICAgICAgY29ubi5lbWl0KCdyZWNvbm5lY3QnKTtcbiAgICAgIGNvbm4uZW1pdCgncmVjb25uZWN0ZWQnKTtcbiAgICAgIGNvbm4ub25PcGVuKCk7XG4gICAgfVxuICB9O1xuXG4gIGNvbnN0IHR5cGUgPSBjbGllbnQgJiZcbiAgY2xpZW50LnRvcG9sb2d5ICYmXG4gIGNsaWVudC50b3BvbG9neS5kZXNjcmlwdGlvbiAmJlxuICBjbGllbnQudG9wb2xvZ3kuZGVzY3JpcHRpb24udHlwZSB8fCAnJztcblxuICBpZiAodHlwZSA9PT0gJ1NpbmdsZScpIHtcbiAgICBjbGllbnQub24oJ3NlcnZlckRlc2NyaXB0aW9uQ2hhbmdlZCcsIGV2ID0+IHtcbiAgICAgIGNvbnN0IG5ld0Rlc2NyaXB0aW9uID0gZXYubmV3RGVzY3JpcHRpb247XG4gICAgICBpZiAobmV3RGVzY3JpcHRpb24udHlwZSA9PT0gJ1Vua25vd24nKSB7XG4gICAgICAgIGNvbm4ucmVhZHlTdGF0ZSA9IFNUQVRFUy5kaXNjb25uZWN0ZWQ7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBfaGFuZGxlUmVjb25uZWN0KCk7XG4gICAgICB9XG4gICAgfSk7XG4gIH0gZWxzZSBpZiAodHlwZS5zdGFydHNXaXRoKCdSZXBsaWNhU2V0JykpIHtcbiAgICBjbGllbnQub24oJ3RvcG9sb2d5RGVzY3JpcHRpb25DaGFuZ2VkJywgZXYgPT4ge1xuICAgICAgLy8gRW1pdCBkaXNjb25uZWN0ZWQgaWYgd2UndmUgbG9zdCBjb25uZWN0aXZpdHkgdG8gdGhlIHByaW1hcnlcbiAgICAgIGNvbnN0IGRlc2NyaXB0aW9uID0gZXYubmV3RGVzY3JpcHRpb247XG4gICAgICBpZiAoY29ubi5yZWFkeVN0YXRlID09PSBTVEFURVMuY29ubmVjdGVkICYmIGRlc2NyaXB0aW9uLnR5cGUgIT09ICdSZXBsaWNhU2V0V2l0aFByaW1hcnknKSB7XG4gICAgICAgIC8vIEltcGxpY2l0bHkgZW1pdHMgJ2Rpc2Nvbm5lY3RlZCdcbiAgICAgICAgY29ubi5yZWFkeVN0YXRlID0gU1RBVEVTLmRpc2Nvbm5lY3RlZDtcbiAgICAgIH0gZWxzZSBpZiAoY29ubi5yZWFkeVN0YXRlID09PSBTVEFURVMuZGlzY29ubmVjdGVkICYmIGRlc2NyaXB0aW9uLnR5cGUgPT09ICdSZXBsaWNhU2V0V2l0aFByaW1hcnknKSB7XG4gICAgICAgIF9oYW5kbGVSZWNvbm5lY3QoKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuXG4gIGNvbm4ub25PcGVuKCk7XG5cbiAgZm9yIChjb25zdCBpIGluIGNvbm4uY29sbGVjdGlvbnMpIHtcbiAgICBpZiAodXRpbHMub2JqZWN0Lmhhc093blByb3BlcnR5KGNvbm4uY29sbGVjdGlvbnMsIGkpKSB7XG4gICAgICBjb25uLmNvbGxlY3Rpb25zW2ldLm9uT3BlbigpO1xuICAgIH1cbiAgfVxufVxuXG5cbi8qIVxuICogTW9kdWxlIGV4cG9ydHMuXG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSBOYXRpdmVDb25uZWN0aW9uO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/mongoose/lib/drivers/node-mongodb-native/connection.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/mongoose/lib/drivers/node-mongodb-native/index.js":
/*!************************************************************************!*\
  !*** ./node_modules/mongoose/lib/drivers/node-mongodb-native/index.js ***!
  \************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("/*!\n * Module exports.\n */\n\n\n\nexports.Collection = __webpack_require__(/*! ./collection */ \"(ssr)/./node_modules/mongoose/lib/drivers/node-mongodb-native/collection.js\");\nexports.Connection = __webpack_require__(/*! ./connection */ \"(ssr)/./node_modules/mongoose/lib/drivers/node-mongodb-native/connection.js\");\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbW9uZ29vc2UvbGliL2RyaXZlcnMvbm9kZS1tb25nb2RiLW5hdGl2ZS9pbmRleC5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7O0FBRWE7O0FBRWIsMklBQTRDO0FBQzVDLDJJQUE0QyIsInNvdXJjZXMiOlsid2VicGFjazovL2FwcDEvLi9ub2RlX21vZHVsZXMvbW9uZ29vc2UvbGliL2RyaXZlcnMvbm9kZS1tb25nb2RiLW5hdGl2ZS9pbmRleC5qcz9mOTAxIl0sInNvdXJjZXNDb250ZW50IjpbIi8qIVxuICogTW9kdWxlIGV4cG9ydHMuXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG5leHBvcnRzLkNvbGxlY3Rpb24gPSByZXF1aXJlKCcuL2NvbGxlY3Rpb24nKTtcbmV4cG9ydHMuQ29ubmVjdGlvbiA9IHJlcXVpcmUoJy4vY29ubmVjdGlvbicpO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/mongoose/lib/drivers/node-mongodb-native/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/mongoose/lib/error/bulkWriteError.js":
/*!***********************************************************!*\
  !*** ./node_modules/mongoose/lib/error/bulkWriteError.js ***!
  \***********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("/*!\n * Module dependencies.\n */\n\n\n\nconst MongooseError = __webpack_require__(/*! ./ */ \"(ssr)/./node_modules/mongoose/lib/error/index.js\");\n\n\n/**\n * If `bulkWrite()` or `insertMany()` has validation errors, but\n * all valid operations succeed, and 'throwOnValidationError' is true,\n * Mongoose will throw this error.\n *\n * @api private\n */\n\nclass MongooseBulkWriteError extends MongooseError {\n  constructor(validationErrors, results, rawResult, operation) {\n    let preview = validationErrors.map(e => e.message).join(', ');\n    if (preview.length > 200) {\n      preview = preview.slice(0, 200) + '...';\n    }\n    super(`${operation} failed with ${validationErrors.length} Mongoose validation errors: ${preview}`);\n\n    this.validationErrors = validationErrors;\n    this.results = results;\n    this.rawResult = rawResult;\n    this.operation = operation;\n  }\n}\n\nObject.defineProperty(MongooseBulkWriteError.prototype, 'name', {\n  value: 'MongooseBulkWriteError'\n});\n\n/*!\n * exports\n */\n\nmodule.exports = MongooseBulkWriteError;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbW9uZ29vc2UvbGliL2Vycm9yL2J1bGtXcml0ZUVycm9yLmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTs7QUFFYTs7QUFFYixzQkFBc0IsbUJBQU8sQ0FBQyw0REFBSTs7O0FBR2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsV0FBVyxjQUFjLHlCQUF5Qiw4QkFBOEIsUUFBUTs7QUFFckc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTs7QUFFQSIsInNvdXJjZXMiOlsid2VicGFjazovL2FwcDEvLi9ub2RlX21vZHVsZXMvbW9uZ29vc2UvbGliL2Vycm9yL2J1bGtXcml0ZUVycm9yLmpzP2MzYTYiXSwic291cmNlc0NvbnRlbnQiOlsiLyohXG4gKiBNb2R1bGUgZGVwZW5kZW5jaWVzLlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxuY29uc3QgTW9uZ29vc2VFcnJvciA9IHJlcXVpcmUoJy4vJyk7XG5cblxuLyoqXG4gKiBJZiBgYnVsa1dyaXRlKClgIG9yIGBpbnNlcnRNYW55KClgIGhhcyB2YWxpZGF0aW9uIGVycm9ycywgYnV0XG4gKiBhbGwgdmFsaWQgb3BlcmF0aW9ucyBzdWNjZWVkLCBhbmQgJ3Rocm93T25WYWxpZGF0aW9uRXJyb3InIGlzIHRydWUsXG4gKiBNb25nb29zZSB3aWxsIHRocm93IHRoaXMgZXJyb3IuXG4gKlxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuY2xhc3MgTW9uZ29vc2VCdWxrV3JpdGVFcnJvciBleHRlbmRzIE1vbmdvb3NlRXJyb3Ige1xuICBjb25zdHJ1Y3Rvcih2YWxpZGF0aW9uRXJyb3JzLCByZXN1bHRzLCByYXdSZXN1bHQsIG9wZXJhdGlvbikge1xuICAgIGxldCBwcmV2aWV3ID0gdmFsaWRhdGlvbkVycm9ycy5tYXAoZSA9PiBlLm1lc3NhZ2UpLmpvaW4oJywgJyk7XG4gICAgaWYgKHByZXZpZXcubGVuZ3RoID4gMjAwKSB7XG4gICAgICBwcmV2aWV3ID0gcHJldmlldy5zbGljZSgwLCAyMDApICsgJy4uLic7XG4gICAgfVxuICAgIHN1cGVyKGAke29wZXJhdGlvbn0gZmFpbGVkIHdpdGggJHt2YWxpZGF0aW9uRXJyb3JzLmxlbmd0aH0gTW9uZ29vc2UgdmFsaWRhdGlvbiBlcnJvcnM6ICR7cHJldmlld31gKTtcblxuICAgIHRoaXMudmFsaWRhdGlvbkVycm9ycyA9IHZhbGlkYXRpb25FcnJvcnM7XG4gICAgdGhpcy5yZXN1bHRzID0gcmVzdWx0cztcbiAgICB0aGlzLnJhd1Jlc3VsdCA9IHJhd1Jlc3VsdDtcbiAgICB0aGlzLm9wZXJhdGlvbiA9IG9wZXJhdGlvbjtcbiAgfVxufVxuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoTW9uZ29vc2VCdWxrV3JpdGVFcnJvci5wcm90b3R5cGUsICduYW1lJywge1xuICB2YWx1ZTogJ01vbmdvb3NlQnVsa1dyaXRlRXJyb3InXG59KTtcblxuLyohXG4gKiBleHBvcnRzXG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSBNb25nb29zZUJ1bGtXcml0ZUVycm9yO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/mongoose/lib/error/bulkWriteError.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/mongoose/lib/error/cast.js":
/*!*************************************************!*\
  !*** ./node_modules/mongoose/lib/error/cast.js ***!
  \*************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\n\n/*!\n * Module dependencies.\n */\n\nconst MongooseError = __webpack_require__(/*! ./mongooseError */ \"(ssr)/./node_modules/mongoose/lib/error/mongooseError.js\");\nconst util = __webpack_require__(/*! util */ \"util\");\n\n/**\n * Casting Error constructor.\n *\n * @param {String} type\n * @param {String} value\n * @inherits MongooseError\n * @api private\n */\n\nclass CastError extends MongooseError {\n  constructor(type, value, path, reason, schemaType) {\n    // If no args, assume we'll `init()` later.\n    if (arguments.length > 0) {\n      const valueType = getValueType(value);\n      const messageFormat = getMessageFormat(schemaType);\n      const msg = formatMessage(null, type, value, path, messageFormat, valueType, reason);\n      super(msg);\n      this.init(type, value, path, reason, schemaType);\n    } else {\n      super(formatMessage());\n    }\n  }\n\n  toJSON() {\n    return {\n      stringValue: this.stringValue,\n      valueType: this.valueType,\n      kind: this.kind,\n      value: this.value,\n      path: this.path,\n      reason: this.reason,\n      name: this.name,\n      message: this.message\n    };\n  }\n  /*!\n   * ignore\n   */\n  init(type, value, path, reason, schemaType) {\n    this.stringValue = getStringValue(value);\n    this.messageFormat = getMessageFormat(schemaType);\n    this.kind = type;\n    this.value = value;\n    this.path = path;\n    this.reason = reason;\n    this.valueType = getValueType(value);\n  }\n\n  /**\n   * ignore\n   * @param {Readonly<CastError>} other\n   * @api private\n   */\n  copy(other) {\n    this.messageFormat = other.messageFormat;\n    this.stringValue = other.stringValue;\n    this.kind = other.kind;\n    this.value = other.value;\n    this.path = other.path;\n    this.reason = other.reason;\n    this.message = other.message;\n    this.valueType = other.valueType;\n  }\n\n  /*!\n   * ignore\n   */\n  setModel(model) {\n    this.model = model;\n    this.message = formatMessage(model, this.kind, this.value, this.path,\n      this.messageFormat, this.valueType);\n  }\n}\n\nObject.defineProperty(CastError.prototype, 'name', {\n  value: 'CastError'\n});\n\nfunction getStringValue(value) {\n  let stringValue = util.inspect(value);\n  stringValue = stringValue.replace(/^'|'$/g, '\"');\n  if (!stringValue.startsWith('\"')) {\n    stringValue = '\"' + stringValue + '\"';\n  }\n  return stringValue;\n}\n\nfunction getValueType(value) {\n  if (value == null) {\n    return '' + value;\n  }\n\n  const t = typeof value;\n  if (t !== 'object') {\n    return t;\n  }\n  if (typeof value.constructor !== 'function') {\n    return t;\n  }\n  return value.constructor.name;\n}\n\nfunction getMessageFormat(schemaType) {\n  const messageFormat = schemaType && schemaType._castErrorMessage || null;\n  if (typeof messageFormat === 'string' || typeof messageFormat === 'function') {\n    return messageFormat;\n  }\n}\n\n/*!\n * ignore\n */\n\nfunction formatMessage(model, kind, value, path, messageFormat, valueType, reason) {\n  if (typeof messageFormat === 'string') {\n    const stringValue = getStringValue(value);\n    let ret = messageFormat.\n      replace('{KIND}', kind).\n      replace('{VALUE}', stringValue).\n      replace('{PATH}', path);\n    if (model != null) {\n      ret = ret.replace('{MODEL}', model.modelName);\n    }\n\n    return ret;\n  } else if (typeof messageFormat === 'function') {\n    return messageFormat(value, path, model, kind);\n  } else {\n    const stringValue = getStringValue(value);\n    const valueTypeMsg = valueType ? ' (type ' + valueType + ')' : '';\n    let ret = 'Cast to ' + kind + ' failed for value ' +\n      stringValue + valueTypeMsg + ' at path \"' + path + '\"';\n    if (model != null) {\n      ret += ' for model \"' + model.modelName + '\"';\n    }\n    if (reason != null &&\n        typeof reason.constructor === 'function' &&\n        reason.constructor.name !== 'AssertionError' &&\n        reason.constructor.name !== 'Error') {\n      ret += ' because of \"' + reason.constructor.name + '\"';\n    }\n    return ret;\n  }\n}\n\n/*!\n * exports\n */\n\nmodule.exports = CastError;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbW9uZ29vc2UvbGliL2Vycm9yL2Nhc3QuanMiLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWI7QUFDQTtBQUNBOztBQUVBLHNCQUFzQixtQkFBTyxDQUFDLGlGQUFpQjtBQUMvQyxhQUFhLG1CQUFPLENBQUMsa0JBQU07O0FBRTNCO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxhQUFhLHFCQUFxQjtBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsS0FBSztBQUNyQixnQkFBZ0IsTUFBTTtBQUN0QixnQkFBZ0IsS0FBSztBQUNyQjtBQUNBLDBCQUEwQixNQUFNO0FBQ2hDOztBQUVBO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSIsInNvdXJjZXMiOlsid2VicGFjazovL2FwcDEvLi9ub2RlX21vZHVsZXMvbW9uZ29vc2UvbGliL2Vycm9yL2Nhc3QuanM/NzY2NSJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbi8qIVxuICogTW9kdWxlIGRlcGVuZGVuY2llcy5cbiAqL1xuXG5jb25zdCBNb25nb29zZUVycm9yID0gcmVxdWlyZSgnLi9tb25nb29zZUVycm9yJyk7XG5jb25zdCB1dGlsID0gcmVxdWlyZSgndXRpbCcpO1xuXG4vKipcbiAqIENhc3RpbmcgRXJyb3IgY29uc3RydWN0b3IuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IHR5cGVcbiAqIEBwYXJhbSB7U3RyaW5nfSB2YWx1ZVxuICogQGluaGVyaXRzIE1vbmdvb3NlRXJyb3JcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmNsYXNzIENhc3RFcnJvciBleHRlbmRzIE1vbmdvb3NlRXJyb3Ige1xuICBjb25zdHJ1Y3Rvcih0eXBlLCB2YWx1ZSwgcGF0aCwgcmVhc29uLCBzY2hlbWFUeXBlKSB7XG4gICAgLy8gSWYgbm8gYXJncywgYXNzdW1lIHdlJ2xsIGBpbml0KClgIGxhdGVyLlxuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID4gMCkge1xuICAgICAgY29uc3QgdmFsdWVUeXBlID0gZ2V0VmFsdWVUeXBlKHZhbHVlKTtcbiAgICAgIGNvbnN0IG1lc3NhZ2VGb3JtYXQgPSBnZXRNZXNzYWdlRm9ybWF0KHNjaGVtYVR5cGUpO1xuICAgICAgY29uc3QgbXNnID0gZm9ybWF0TWVzc2FnZShudWxsLCB0eXBlLCB2YWx1ZSwgcGF0aCwgbWVzc2FnZUZvcm1hdCwgdmFsdWVUeXBlLCByZWFzb24pO1xuICAgICAgc3VwZXIobXNnKTtcbiAgICAgIHRoaXMuaW5pdCh0eXBlLCB2YWx1ZSwgcGF0aCwgcmVhc29uLCBzY2hlbWFUeXBlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgc3VwZXIoZm9ybWF0TWVzc2FnZSgpKTtcbiAgICB9XG4gIH1cblxuICB0b0pTT04oKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHN0cmluZ1ZhbHVlOiB0aGlzLnN0cmluZ1ZhbHVlLFxuICAgICAgdmFsdWVUeXBlOiB0aGlzLnZhbHVlVHlwZSxcbiAgICAgIGtpbmQ6IHRoaXMua2luZCxcbiAgICAgIHZhbHVlOiB0aGlzLnZhbHVlLFxuICAgICAgcGF0aDogdGhpcy5wYXRoLFxuICAgICAgcmVhc29uOiB0aGlzLnJlYXNvbixcbiAgICAgIG5hbWU6IHRoaXMubmFtZSxcbiAgICAgIG1lc3NhZ2U6IHRoaXMubWVzc2FnZVxuICAgIH07XG4gIH1cbiAgLyohXG4gICAqIGlnbm9yZVxuICAgKi9cbiAgaW5pdCh0eXBlLCB2YWx1ZSwgcGF0aCwgcmVhc29uLCBzY2hlbWFUeXBlKSB7XG4gICAgdGhpcy5zdHJpbmdWYWx1ZSA9IGdldFN0cmluZ1ZhbHVlKHZhbHVlKTtcbiAgICB0aGlzLm1lc3NhZ2VGb3JtYXQgPSBnZXRNZXNzYWdlRm9ybWF0KHNjaGVtYVR5cGUpO1xuICAgIHRoaXMua2luZCA9IHR5cGU7XG4gICAgdGhpcy52YWx1ZSA9IHZhbHVlO1xuICAgIHRoaXMucGF0aCA9IHBhdGg7XG4gICAgdGhpcy5yZWFzb24gPSByZWFzb247XG4gICAgdGhpcy52YWx1ZVR5cGUgPSBnZXRWYWx1ZVR5cGUodmFsdWUpO1xuICB9XG5cbiAgLyoqXG4gICAqIGlnbm9yZVxuICAgKiBAcGFyYW0ge1JlYWRvbmx5PENhc3RFcnJvcj59IG90aGVyXG4gICAqIEBhcGkgcHJpdmF0ZVxuICAgKi9cbiAgY29weShvdGhlcikge1xuICAgIHRoaXMubWVzc2FnZUZvcm1hdCA9IG90aGVyLm1lc3NhZ2VGb3JtYXQ7XG4gICAgdGhpcy5zdHJpbmdWYWx1ZSA9IG90aGVyLnN0cmluZ1ZhbHVlO1xuICAgIHRoaXMua2luZCA9IG90aGVyLmtpbmQ7XG4gICAgdGhpcy52YWx1ZSA9IG90aGVyLnZhbHVlO1xuICAgIHRoaXMucGF0aCA9IG90aGVyLnBhdGg7XG4gICAgdGhpcy5yZWFzb24gPSBvdGhlci5yZWFzb247XG4gICAgdGhpcy5tZXNzYWdlID0gb3RoZXIubWVzc2FnZTtcbiAgICB0aGlzLnZhbHVlVHlwZSA9IG90aGVyLnZhbHVlVHlwZTtcbiAgfVxuXG4gIC8qIVxuICAgKiBpZ25vcmVcbiAgICovXG4gIHNldE1vZGVsKG1vZGVsKSB7XG4gICAgdGhpcy5tb2RlbCA9IG1vZGVsO1xuICAgIHRoaXMubWVzc2FnZSA9IGZvcm1hdE1lc3NhZ2UobW9kZWwsIHRoaXMua2luZCwgdGhpcy52YWx1ZSwgdGhpcy5wYXRoLFxuICAgICAgdGhpcy5tZXNzYWdlRm9ybWF0LCB0aGlzLnZhbHVlVHlwZSk7XG4gIH1cbn1cblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KENhc3RFcnJvci5wcm90b3R5cGUsICduYW1lJywge1xuICB2YWx1ZTogJ0Nhc3RFcnJvcidcbn0pO1xuXG5mdW5jdGlvbiBnZXRTdHJpbmdWYWx1ZSh2YWx1ZSkge1xuICBsZXQgc3RyaW5nVmFsdWUgPSB1dGlsLmluc3BlY3QodmFsdWUpO1xuICBzdHJpbmdWYWx1ZSA9IHN0cmluZ1ZhbHVlLnJlcGxhY2UoL14nfCckL2csICdcIicpO1xuICBpZiAoIXN0cmluZ1ZhbHVlLnN0YXJ0c1dpdGgoJ1wiJykpIHtcbiAgICBzdHJpbmdWYWx1ZSA9ICdcIicgKyBzdHJpbmdWYWx1ZSArICdcIic7XG4gIH1cbiAgcmV0dXJuIHN0cmluZ1ZhbHVlO1xufVxuXG5mdW5jdGlvbiBnZXRWYWx1ZVR5cGUodmFsdWUpIHtcbiAgaWYgKHZhbHVlID09IG51bGwpIHtcbiAgICByZXR1cm4gJycgKyB2YWx1ZTtcbiAgfVxuXG4gIGNvbnN0IHQgPSB0eXBlb2YgdmFsdWU7XG4gIGlmICh0ICE9PSAnb2JqZWN0Jykge1xuICAgIHJldHVybiB0O1xuICB9XG4gIGlmICh0eXBlb2YgdmFsdWUuY29uc3RydWN0b3IgIT09ICdmdW5jdGlvbicpIHtcbiAgICByZXR1cm4gdDtcbiAgfVxuICByZXR1cm4gdmFsdWUuY29uc3RydWN0b3IubmFtZTtcbn1cblxuZnVuY3Rpb24gZ2V0TWVzc2FnZUZvcm1hdChzY2hlbWFUeXBlKSB7XG4gIGNvbnN0IG1lc3NhZ2VGb3JtYXQgPSBzY2hlbWFUeXBlICYmIHNjaGVtYVR5cGUuX2Nhc3RFcnJvck1lc3NhZ2UgfHwgbnVsbDtcbiAgaWYgKHR5cGVvZiBtZXNzYWdlRm9ybWF0ID09PSAnc3RyaW5nJyB8fCB0eXBlb2YgbWVzc2FnZUZvcm1hdCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHJldHVybiBtZXNzYWdlRm9ybWF0O1xuICB9XG59XG5cbi8qIVxuICogaWdub3JlXG4gKi9cblxuZnVuY3Rpb24gZm9ybWF0TWVzc2FnZShtb2RlbCwga2luZCwgdmFsdWUsIHBhdGgsIG1lc3NhZ2VGb3JtYXQsIHZhbHVlVHlwZSwgcmVhc29uKSB7XG4gIGlmICh0eXBlb2YgbWVzc2FnZUZvcm1hdCA9PT0gJ3N0cmluZycpIHtcbiAgICBjb25zdCBzdHJpbmdWYWx1ZSA9IGdldFN0cmluZ1ZhbHVlKHZhbHVlKTtcbiAgICBsZXQgcmV0ID0gbWVzc2FnZUZvcm1hdC5cbiAgICAgIHJlcGxhY2UoJ3tLSU5EfScsIGtpbmQpLlxuICAgICAgcmVwbGFjZSgne1ZBTFVFfScsIHN0cmluZ1ZhbHVlKS5cbiAgICAgIHJlcGxhY2UoJ3tQQVRIfScsIHBhdGgpO1xuICAgIGlmIChtb2RlbCAhPSBudWxsKSB7XG4gICAgICByZXQgPSByZXQucmVwbGFjZSgne01PREVMfScsIG1vZGVsLm1vZGVsTmFtZSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHJldDtcbiAgfSBlbHNlIGlmICh0eXBlb2YgbWVzc2FnZUZvcm1hdCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHJldHVybiBtZXNzYWdlRm9ybWF0KHZhbHVlLCBwYXRoLCBtb2RlbCwga2luZCk7XG4gIH0gZWxzZSB7XG4gICAgY29uc3Qgc3RyaW5nVmFsdWUgPSBnZXRTdHJpbmdWYWx1ZSh2YWx1ZSk7XG4gICAgY29uc3QgdmFsdWVUeXBlTXNnID0gdmFsdWVUeXBlID8gJyAodHlwZSAnICsgdmFsdWVUeXBlICsgJyknIDogJyc7XG4gICAgbGV0IHJldCA9ICdDYXN0IHRvICcgKyBraW5kICsgJyBmYWlsZWQgZm9yIHZhbHVlICcgK1xuICAgICAgc3RyaW5nVmFsdWUgKyB2YWx1ZVR5cGVNc2cgKyAnIGF0IHBhdGggXCInICsgcGF0aCArICdcIic7XG4gICAgaWYgKG1vZGVsICE9IG51bGwpIHtcbiAgICAgIHJldCArPSAnIGZvciBtb2RlbCBcIicgKyBtb2RlbC5tb2RlbE5hbWUgKyAnXCInO1xuICAgIH1cbiAgICBpZiAocmVhc29uICE9IG51bGwgJiZcbiAgICAgICAgdHlwZW9mIHJlYXNvbi5jb25zdHJ1Y3RvciA9PT0gJ2Z1bmN0aW9uJyAmJlxuICAgICAgICByZWFzb24uY29uc3RydWN0b3IubmFtZSAhPT0gJ0Fzc2VydGlvbkVycm9yJyAmJlxuICAgICAgICByZWFzb24uY29uc3RydWN0b3IubmFtZSAhPT0gJ0Vycm9yJykge1xuICAgICAgcmV0ICs9ICcgYmVjYXVzZSBvZiBcIicgKyByZWFzb24uY29uc3RydWN0b3IubmFtZSArICdcIic7XG4gICAgfVxuICAgIHJldHVybiByZXQ7XG4gIH1cbn1cblxuLyohXG4gKiBleHBvcnRzXG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSBDYXN0RXJyb3I7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/mongoose/lib/error/cast.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/mongoose/lib/error/createCollectionsError.js":
/*!*******************************************************************!*\
  !*** ./node_modules/mongoose/lib/error/createCollectionsError.js ***!
  \*******************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\n\nconst MongooseError = __webpack_require__(/*! ./mongooseError */ \"(ssr)/./node_modules/mongoose/lib/error/mongooseError.js\");\n\n/**\n * createCollections Error constructor\n *\n * @param {String} message\n * @param {String} errorsMap\n * @inherits MongooseError\n * @api private\n */\n\nclass CreateCollectionsError extends MongooseError {\n  constructor(message, errorsMap) {\n    super(message);\n    this.errors = errorsMap;\n  }\n}\n\nObject.defineProperty(CreateCollectionsError.prototype, 'name', {\n  value: 'CreateCollectionsError'\n});\n\nmodule.exports = CreateCollectionsError;\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbW9uZ29vc2UvbGliL2Vycm9yL2NyZWF0ZUNvbGxlY3Rpb25zRXJyb3IuanMiLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWIsc0JBQXNCLG1CQUFPLENBQUMsaUZBQWlCOztBQUUvQztBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLENBQUM7O0FBRUQiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9hcHAxLy4vbm9kZV9tb2R1bGVzL21vbmdvb3NlL2xpYi9lcnJvci9jcmVhdGVDb2xsZWN0aW9uc0Vycm9yLmpzPzM3MjUiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG5jb25zdCBNb25nb29zZUVycm9yID0gcmVxdWlyZSgnLi9tb25nb29zZUVycm9yJyk7XG5cbi8qKlxuICogY3JlYXRlQ29sbGVjdGlvbnMgRXJyb3IgY29uc3RydWN0b3JcbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gbWVzc2FnZVxuICogQHBhcmFtIHtTdHJpbmd9IGVycm9yc01hcFxuICogQGluaGVyaXRzIE1vbmdvb3NlRXJyb3JcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmNsYXNzIENyZWF0ZUNvbGxlY3Rpb25zRXJyb3IgZXh0ZW5kcyBNb25nb29zZUVycm9yIHtcbiAgY29uc3RydWN0b3IobWVzc2FnZSwgZXJyb3JzTWFwKSB7XG4gICAgc3VwZXIobWVzc2FnZSk7XG4gICAgdGhpcy5lcnJvcnMgPSBlcnJvcnNNYXA7XG4gIH1cbn1cblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KENyZWF0ZUNvbGxlY3Rpb25zRXJyb3IucHJvdG90eXBlLCAnbmFtZScsIHtcbiAgdmFsdWU6ICdDcmVhdGVDb2xsZWN0aW9uc0Vycm9yJ1xufSk7XG5cbm1vZHVsZS5leHBvcnRzID0gQ3JlYXRlQ29sbGVjdGlvbnNFcnJvcjtcblxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/mongoose/lib/error/createCollectionsError.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/mongoose/lib/error/divergentArray.js":
/*!***********************************************************!*\
  !*** ./node_modules/mongoose/lib/error/divergentArray.js ***!
  \***********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\n/*!\n * Module dependencies.\n */\n\n\n\nconst MongooseError = __webpack_require__(/*! ./ */ \"(ssr)/./node_modules/mongoose/lib/error/index.js\");\n\nclass DivergentArrayError extends MongooseError {\n  /**\n   * DivergentArrayError constructor.\n   * @param {Array<String>} paths\n   * @api private\n   */\n  constructor(paths) {\n    const msg = 'For your own good, using `document.save()` to update an array '\n            + 'which was selected using an $elemMatch projection OR '\n            + 'populated using skip, limit, query conditions, or exclusion of '\n            + 'the _id field when the operation results in a $pop or $set of '\n            + 'the entire array is not supported. The following '\n            + 'path(s) would have been modified unsafely:\\n'\n            + '  ' + paths.join('\\n  ') + '\\n'\n            + 'Use Model.updateOne() to update these arrays instead.';\n    // TODO write up a docs page (FAQ) and link to it\n    super(msg);\n  }\n}\n\nObject.defineProperty(DivergentArrayError.prototype, 'name', {\n  value: 'DivergentArrayError'\n});\n\n/*!\n * exports\n */\n\nmodule.exports = DivergentArrayError;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbW9uZ29vc2UvbGliL2Vycm9yL2RpdmVyZ2VudEFycmF5LmpzIiwibWFwcGluZ3MiOiI7QUFDQTtBQUNBO0FBQ0E7O0FBRWE7O0FBRWIsc0JBQXNCLG1CQUFPLENBQUMsNERBQUk7O0FBRWxDO0FBQ0E7QUFDQTtBQUNBLGFBQWEsZUFBZTtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBOztBQUVBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vYXBwMS8uL25vZGVfbW9kdWxlcy9tb25nb29zZS9saWIvZXJyb3IvZGl2ZXJnZW50QXJyYXkuanM/ZTAyZSJdLCJzb3VyY2VzQ29udGVudCI6WyJcbi8qIVxuICogTW9kdWxlIGRlcGVuZGVuY2llcy5cbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbmNvbnN0IE1vbmdvb3NlRXJyb3IgPSByZXF1aXJlKCcuLycpO1xuXG5jbGFzcyBEaXZlcmdlbnRBcnJheUVycm9yIGV4dGVuZHMgTW9uZ29vc2VFcnJvciB7XG4gIC8qKlxuICAgKiBEaXZlcmdlbnRBcnJheUVycm9yIGNvbnN0cnVjdG9yLlxuICAgKiBAcGFyYW0ge0FycmF5PFN0cmluZz59IHBhdGhzXG4gICAqIEBhcGkgcHJpdmF0ZVxuICAgKi9cbiAgY29uc3RydWN0b3IocGF0aHMpIHtcbiAgICBjb25zdCBtc2cgPSAnRm9yIHlvdXIgb3duIGdvb2QsIHVzaW5nIGBkb2N1bWVudC5zYXZlKClgIHRvIHVwZGF0ZSBhbiBhcnJheSAnXG4gICAgICAgICAgICArICd3aGljaCB3YXMgc2VsZWN0ZWQgdXNpbmcgYW4gJGVsZW1NYXRjaCBwcm9qZWN0aW9uIE9SICdcbiAgICAgICAgICAgICsgJ3BvcHVsYXRlZCB1c2luZyBza2lwLCBsaW1pdCwgcXVlcnkgY29uZGl0aW9ucywgb3IgZXhjbHVzaW9uIG9mICdcbiAgICAgICAgICAgICsgJ3RoZSBfaWQgZmllbGQgd2hlbiB0aGUgb3BlcmF0aW9uIHJlc3VsdHMgaW4gYSAkcG9wIG9yICRzZXQgb2YgJ1xuICAgICAgICAgICAgKyAndGhlIGVudGlyZSBhcnJheSBpcyBub3Qgc3VwcG9ydGVkLiBUaGUgZm9sbG93aW5nICdcbiAgICAgICAgICAgICsgJ3BhdGgocykgd291bGQgaGF2ZSBiZWVuIG1vZGlmaWVkIHVuc2FmZWx5OlxcbidcbiAgICAgICAgICAgICsgJyAgJyArIHBhdGhzLmpvaW4oJ1xcbiAgJykgKyAnXFxuJ1xuICAgICAgICAgICAgKyAnVXNlIE1vZGVsLnVwZGF0ZU9uZSgpIHRvIHVwZGF0ZSB0aGVzZSBhcnJheXMgaW5zdGVhZC4nO1xuICAgIC8vIFRPRE8gd3JpdGUgdXAgYSBkb2NzIHBhZ2UgKEZBUSkgYW5kIGxpbmsgdG8gaXRcbiAgICBzdXBlcihtc2cpO1xuICB9XG59XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShEaXZlcmdlbnRBcnJheUVycm9yLnByb3RvdHlwZSwgJ25hbWUnLCB7XG4gIHZhbHVlOiAnRGl2ZXJnZW50QXJyYXlFcnJvcidcbn0pO1xuXG4vKiFcbiAqIGV4cG9ydHNcbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IERpdmVyZ2VudEFycmF5RXJyb3I7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/mongoose/lib/error/divergentArray.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/mongoose/lib/error/eachAsyncMultiError.js":
/*!****************************************************************!*\
  !*** ./node_modules/mongoose/lib/error/eachAsyncMultiError.js ***!
  \****************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("/*!\n * Module dependencies.\n */\n\n\n\nconst MongooseError = __webpack_require__(/*! ./ */ \"(ssr)/./node_modules/mongoose/lib/error/index.js\");\n\n\n/**\n * If `eachAsync()` is called with `continueOnError: true`, there can be\n * multiple errors. This error class contains an `errors` property, which\n * contains an array of all errors that occurred in `eachAsync()`.\n *\n * @api private\n */\n\nclass EachAsyncMultiError extends MongooseError {\n  /**\n   * @param {String} connectionString\n   */\n  constructor(errors) {\n    let preview = errors.map(e => e.message).join(', ');\n    if (preview.length > 50) {\n      preview = preview.slice(0, 50) + '...';\n    }\n    super(`eachAsync() finished with ${errors.length} errors: ${preview}`);\n\n    this.errors = errors;\n  }\n}\n\nObject.defineProperty(EachAsyncMultiError.prototype, 'name', {\n  value: 'EachAsyncMultiError'\n});\n\n/*!\n * exports\n */\n\nmodule.exports = EachAsyncMultiError;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbW9uZ29vc2UvbGliL2Vycm9yL2VhY2hBc3luY011bHRpRXJyb3IuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBOztBQUVhOztBQUViLHNCQUFzQixtQkFBTyxDQUFDLDREQUFJOzs7QUFHbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGFBQWEsUUFBUTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUMsZUFBZSxVQUFVLFFBQVE7O0FBRXhFO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7O0FBRUEiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9hcHAxLy4vbm9kZV9tb2R1bGVzL21vbmdvb3NlL2xpYi9lcnJvci9lYWNoQXN5bmNNdWx0aUVycm9yLmpzP2NlYzAiXSwic291cmNlc0NvbnRlbnQiOlsiLyohXG4gKiBNb2R1bGUgZGVwZW5kZW5jaWVzLlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxuY29uc3QgTW9uZ29vc2VFcnJvciA9IHJlcXVpcmUoJy4vJyk7XG5cblxuLyoqXG4gKiBJZiBgZWFjaEFzeW5jKClgIGlzIGNhbGxlZCB3aXRoIGBjb250aW51ZU9uRXJyb3I6IHRydWVgLCB0aGVyZSBjYW4gYmVcbiAqIG11bHRpcGxlIGVycm9ycy4gVGhpcyBlcnJvciBjbGFzcyBjb250YWlucyBhbiBgZXJyb3JzYCBwcm9wZXJ0eSwgd2hpY2hcbiAqIGNvbnRhaW5zIGFuIGFycmF5IG9mIGFsbCBlcnJvcnMgdGhhdCBvY2N1cnJlZCBpbiBgZWFjaEFzeW5jKClgLlxuICpcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmNsYXNzIEVhY2hBc3luY011bHRpRXJyb3IgZXh0ZW5kcyBNb25nb29zZUVycm9yIHtcbiAgLyoqXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBjb25uZWN0aW9uU3RyaW5nXG4gICAqL1xuICBjb25zdHJ1Y3RvcihlcnJvcnMpIHtcbiAgICBsZXQgcHJldmlldyA9IGVycm9ycy5tYXAoZSA9PiBlLm1lc3NhZ2UpLmpvaW4oJywgJyk7XG4gICAgaWYgKHByZXZpZXcubGVuZ3RoID4gNTApIHtcbiAgICAgIHByZXZpZXcgPSBwcmV2aWV3LnNsaWNlKDAsIDUwKSArICcuLi4nO1xuICAgIH1cbiAgICBzdXBlcihgZWFjaEFzeW5jKCkgZmluaXNoZWQgd2l0aCAke2Vycm9ycy5sZW5ndGh9IGVycm9yczogJHtwcmV2aWV3fWApO1xuXG4gICAgdGhpcy5lcnJvcnMgPSBlcnJvcnM7XG4gIH1cbn1cblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KEVhY2hBc3luY011bHRpRXJyb3IucHJvdG90eXBlLCAnbmFtZScsIHtcbiAgdmFsdWU6ICdFYWNoQXN5bmNNdWx0aUVycm9yJ1xufSk7XG5cbi8qIVxuICogZXhwb3J0c1xuICovXG5cbm1vZHVsZS5leHBvcnRzID0gRWFjaEFzeW5jTXVsdGlFcnJvcjtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/mongoose/lib/error/eachAsyncMultiError.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/mongoose/lib/error/index.js":
/*!**************************************************!*\
  !*** ./node_modules/mongoose/lib/error/index.js ***!
  \**************************************************/
/***/ ((module, exports, __webpack_require__) => {

eval("\n\n/**\n * MongooseError constructor. MongooseError is the base class for all\n * Mongoose-specific errors.\n *\n * #### Example:\n *\n *     const Model = mongoose.model('Test', new mongoose.Schema({ answer: Number }));\n *     const doc = new Model({ answer: 'not a number' });\n *     const err = doc.validateSync();\n *\n *     err instanceof mongoose.Error.ValidationError; // true\n *\n * @constructor Error\n * @param {String} msg Error message\n * @inherits Error https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Error\n */\n\nconst MongooseError = __webpack_require__(/*! ./mongooseError */ \"(ssr)/./node_modules/mongoose/lib/error/mongooseError.js\");\n\n/**\n * The name of the error. The name uniquely identifies this Mongoose error. The\n * possible values are:\n *\n * - `MongooseError`: general Mongoose error\n * - `CastError`: Mongoose could not convert a value to the type defined in the schema path. May be in a `ValidationError` class' `errors` property.\n * - `DivergentArrayError`: You attempted to `save()` an array that was modified after you loaded it with a `$elemMatch` or similar projection\n * - `MissingSchemaError`: You tried to access a model with [`mongoose.model()`](https://mongoosejs.com/docs/api/mongoose.html#Mongoose.model()) that was not defined\n * - `DocumentNotFoundError`: The document you tried to [`save()`](https://mongoosejs.com/docs/api/document.html#Document.prototype.save()) was not found\n * - `ValidatorError`: error from an individual schema path's validator\n * - `ValidationError`: error returned from [`validate()`](https://mongoosejs.com/docs/api/document.html#Document.prototype.validate()) or [`validateSync()`](https://mongoosejs.com/docs/api/document.html#Document.prototype.validateSync()). Contains zero or more `ValidatorError` instances in `.errors` property.\n * - `MissingSchemaError`: You called `mongoose.Document()` without a schema\n * - `ObjectExpectedError`: Thrown when you set a nested path to a non-object value with [strict mode set](https://mongoosejs.com/docs/guide.html#strict).\n * - `ObjectParameterError`: Thrown when you pass a non-object value to a function which expects an object as a paramter\n * - `OverwriteModelError`: Thrown when you call [`mongoose.model()`](https://mongoosejs.com/docs/api/mongoose.html#Mongoose.model()) to re-define a model that was already defined.\n * - `ParallelSaveError`: Thrown when you call [`save()`](https://mongoosejs.com/docs/api/model.html#Model.prototype.save()) on a document when the same document instance is already saving.\n * - `StrictModeError`: Thrown when you set a path that isn't the schema and [strict mode](https://mongoosejs.com/docs/guide.html#strict) is set to `throw`.\n * - `VersionError`: Thrown when the [document is out of sync](https://mongoosejs.com/docs/guide.html#versionKey)\n *\n * @api public\n * @property {String} name\n * @memberOf Error\n * @instance\n */\n\n/*!\n * Module exports.\n */\n\nmodule.exports = exports = MongooseError;\n\n/**\n * The default built-in validator error messages.\n *\n * @see Error.messages https://mongoosejs.com/docs/api/error.html#Error.messages\n * @api public\n * @memberOf Error\n * @static\n */\n\nMongooseError.messages = __webpack_require__(/*! ./messages */ \"(ssr)/./node_modules/mongoose/lib/error/messages.js\");\n\n// backward compat\nMongooseError.Messages = MongooseError.messages;\n\n/**\n * An instance of this error class will be returned when `save()` fails\n * because the underlying\n * document was not found. The constructor takes one parameter, the\n * conditions that mongoose passed to `updateOne()` when trying to update\n * the document.\n *\n * @api public\n * @memberOf Error\n * @static\n */\n\nMongooseError.DocumentNotFoundError = __webpack_require__(/*! ./notFound */ \"(ssr)/./node_modules/mongoose/lib/error/notFound.js\");\n\n/**\n * An instance of this error class will be returned when mongoose failed to\n * cast a value.\n *\n * @api public\n * @memberOf Error\n * @static\n */\n\nMongooseError.CastError = __webpack_require__(/*! ./cast */ \"(ssr)/./node_modules/mongoose/lib/error/cast.js\");\n\n/**\n * An instance of this error class will be returned when [validation](https://mongoosejs.com/docs/validation.html) failed.\n * The `errors` property contains an object whose keys are the paths that failed and whose values are\n * instances of CastError or ValidationError.\n *\n * @api public\n * @memberOf Error\n * @static\n */\n\nMongooseError.ValidationError = __webpack_require__(/*! ./validation */ \"(ssr)/./node_modules/mongoose/lib/error/validation.js\");\n\n/**\n * A `ValidationError` has a hash of `errors` that contain individual\n * `ValidatorError` instances.\n *\n * #### Example:\n *\n *     const schema = Schema({ name: { type: String, required: true } });\n *     const Model = mongoose.model('Test', schema);\n *     const doc = new Model({});\n *\n *     // Top-level error is a ValidationError, **not** a ValidatorError\n *     const err = doc.validateSync();\n *     err instanceof mongoose.Error.ValidationError; // true\n *\n *     // A ValidationError `err` has 0 or more ValidatorErrors keyed by the\n *     // path in the `err.errors` property.\n *     err.errors['name'] instanceof mongoose.Error.ValidatorError;\n *\n *     err.errors['name'].kind; // 'required'\n *     err.errors['name'].path; // 'name'\n *     err.errors['name'].value; // undefined\n *\n * Instances of `ValidatorError` have the following properties:\n *\n * - `kind`: The validator's `type`, like `'required'` or `'regexp'`\n * - `path`: The path that failed validation\n * - `value`: The value that failed validation\n *\n * @api public\n * @memberOf Error\n * @static\n */\n\nMongooseError.ValidatorError = __webpack_require__(/*! ./validator */ \"(ssr)/./node_modules/mongoose/lib/error/validator.js\");\n\n/**\n * An instance of this error class will be returned when you call `save()` after\n * the document in the database was changed in a potentially unsafe way. See\n * the [`versionKey` option](https://mongoosejs.com/docs/guide.html#versionKey) for more information.\n *\n * @api public\n * @memberOf Error\n * @static\n */\n\nMongooseError.VersionError = __webpack_require__(/*! ./version */ \"(ssr)/./node_modules/mongoose/lib/error/version.js\");\n\n/**\n * An instance of this error class will be returned when you call `save()` multiple\n * times on the same document in parallel. See the [FAQ](https://mongoosejs.com/docs/faq.html) for more\n * information.\n *\n * @api public\n * @memberOf Error\n * @static\n */\n\nMongooseError.ParallelSaveError = __webpack_require__(/*! ./parallelSave */ \"(ssr)/./node_modules/mongoose/lib/error/parallelSave.js\");\n\n/**\n * Thrown when a model with the given name was already registered on the connection.\n * See [the FAQ about `OverwriteModelError`](https://mongoosejs.com/docs/faq.html#overwrite-model-error).\n *\n * @api public\n * @memberOf Error\n * @static\n */\n\nMongooseError.OverwriteModelError = __webpack_require__(/*! ./overwriteModel */ \"(ssr)/./node_modules/mongoose/lib/error/overwriteModel.js\");\n\n/**\n * Thrown when you try to access a model that has not been registered yet\n *\n * @api public\n * @memberOf Error\n * @static\n */\n\nMongooseError.MissingSchemaError = __webpack_require__(/*! ./missingSchema */ \"(ssr)/./node_modules/mongoose/lib/error/missingSchema.js\");\n\n/**\n * Thrown when the MongoDB Node driver can't connect to a valid server\n * to send an operation to.\n *\n * @api public\n * @memberOf Error\n * @static\n */\n\nMongooseError.MongooseServerSelectionError = __webpack_require__(/*! ./serverSelection */ \"(ssr)/./node_modules/mongoose/lib/error/serverSelection.js\");\n\n/**\n * An instance of this error will be returned if you used an array projection\n * and then modified the array in an unsafe way.\n *\n * @api public\n * @memberOf Error\n * @static\n */\n\nMongooseError.DivergentArrayError = __webpack_require__(/*! ./divergentArray */ \"(ssr)/./node_modules/mongoose/lib/error/divergentArray.js\");\n\n/**\n * Thrown when your try to pass values to model constructor that\n * were not specified in schema or change immutable properties when\n * `strict` mode is `\"throw\"`\n *\n * @api public\n * @memberOf Error\n * @static\n */\n\nMongooseError.StrictModeError = __webpack_require__(/*! ./strict */ \"(ssr)/./node_modules/mongoose/lib/error/strict.js\");\n\n/**\n * An instance of this error class will be returned when mongoose failed to\n * populate with a path that is not existing.\n *\n * @api public\n * @memberOf Error\n * @static\n */\n\nMongooseError.StrictPopulateError = __webpack_require__(/*! ./strictPopulate */ \"(ssr)/./node_modules/mongoose/lib/error/strictPopulate.js\");\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbW9uZ29vc2UvbGliL2Vycm9yL2luZGV4LmpzIiwibWFwcGluZ3MiOiJBQUFhOztBQUViO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtFQUFrRSxnQkFBZ0I7QUFDbEYsK0JBQStCLHdCQUF3QjtBQUN2RDtBQUNBO0FBQ0Esc0RBQXNEO0FBQ3REO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkI7QUFDQTs7QUFFQSxzQkFBc0IsbUJBQU8sQ0FBQyxpRkFBaUI7O0FBRS9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLFFBQVE7QUFDdEI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHlCQUF5QixtQkFBTyxDQUFDLHVFQUFZOztBQUU3QztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsc0NBQXNDLG1CQUFPLENBQUMsdUVBQVk7O0FBRTFEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsMEJBQTBCLG1CQUFPLENBQUMsK0RBQVE7O0FBRTFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxnQ0FBZ0MsbUJBQU8sQ0FBQywyRUFBYzs7QUFFdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCLFFBQVEsZ0NBQWdDO0FBQ3ZFO0FBQ0EsK0JBQStCO0FBQy9CO0FBQ0E7QUFDQTtBQUNBLHNEQUFzRDtBQUN0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDO0FBQ2hDLGdDQUFnQztBQUNoQyxpQ0FBaUM7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSwrQkFBK0IsbUJBQU8sQ0FBQyx5RUFBYTs7QUFFcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLDZCQUE2QixtQkFBTyxDQUFDLHFFQUFXOztBQUVoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsa0NBQWtDLG1CQUFPLENBQUMsK0VBQWdCOztBQUUxRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLG9DQUFvQyxtQkFBTyxDQUFDLG1GQUFrQjs7QUFFOUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsbUNBQW1DLG1CQUFPLENBQUMsaUZBQWlCOztBQUU1RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLDZDQUE2QyxtQkFBTyxDQUFDLHFGQUFtQjs7QUFFeEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxvQ0FBb0MsbUJBQU8sQ0FBQyxtRkFBa0I7O0FBRTlEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxnQ0FBZ0MsbUJBQU8sQ0FBQyxtRUFBVTs7QUFFbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxvQ0FBb0MsbUJBQU8sQ0FBQyxtRkFBa0IiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9hcHAxLy4vbm9kZV9tb2R1bGVzL21vbmdvb3NlL2xpYi9lcnJvci9pbmRleC5qcz8wMmE3Il0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxuLyoqXG4gKiBNb25nb29zZUVycm9yIGNvbnN0cnVjdG9yLiBNb25nb29zZUVycm9yIGlzIHRoZSBiYXNlIGNsYXNzIGZvciBhbGxcbiAqIE1vbmdvb3NlLXNwZWNpZmljIGVycm9ycy5cbiAqXG4gKiAjIyMjIEV4YW1wbGU6XG4gKlxuICogICAgIGNvbnN0IE1vZGVsID0gbW9uZ29vc2UubW9kZWwoJ1Rlc3QnLCBuZXcgbW9uZ29vc2UuU2NoZW1hKHsgYW5zd2VyOiBOdW1iZXIgfSkpO1xuICogICAgIGNvbnN0IGRvYyA9IG5ldyBNb2RlbCh7IGFuc3dlcjogJ25vdCBhIG51bWJlcicgfSk7XG4gKiAgICAgY29uc3QgZXJyID0gZG9jLnZhbGlkYXRlU3luYygpO1xuICpcbiAqICAgICBlcnIgaW5zdGFuY2VvZiBtb25nb29zZS5FcnJvci5WYWxpZGF0aW9uRXJyb3I7IC8vIHRydWVcbiAqXG4gKiBAY29uc3RydWN0b3IgRXJyb3JcbiAqIEBwYXJhbSB7U3RyaW5nfSBtc2cgRXJyb3IgbWVzc2FnZVxuICogQGluaGVyaXRzIEVycm9yIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL0Vycm9yXG4gKi9cblxuY29uc3QgTW9uZ29vc2VFcnJvciA9IHJlcXVpcmUoJy4vbW9uZ29vc2VFcnJvcicpO1xuXG4vKipcbiAqIFRoZSBuYW1lIG9mIHRoZSBlcnJvci4gVGhlIG5hbWUgdW5pcXVlbHkgaWRlbnRpZmllcyB0aGlzIE1vbmdvb3NlIGVycm9yLiBUaGVcbiAqIHBvc3NpYmxlIHZhbHVlcyBhcmU6XG4gKlxuICogLSBgTW9uZ29vc2VFcnJvcmA6IGdlbmVyYWwgTW9uZ29vc2UgZXJyb3JcbiAqIC0gYENhc3RFcnJvcmA6IE1vbmdvb3NlIGNvdWxkIG5vdCBjb252ZXJ0IGEgdmFsdWUgdG8gdGhlIHR5cGUgZGVmaW5lZCBpbiB0aGUgc2NoZW1hIHBhdGguIE1heSBiZSBpbiBhIGBWYWxpZGF0aW9uRXJyb3JgIGNsYXNzJyBgZXJyb3JzYCBwcm9wZXJ0eS5cbiAqIC0gYERpdmVyZ2VudEFycmF5RXJyb3JgOiBZb3UgYXR0ZW1wdGVkIHRvIGBzYXZlKClgIGFuIGFycmF5IHRoYXQgd2FzIG1vZGlmaWVkIGFmdGVyIHlvdSBsb2FkZWQgaXQgd2l0aCBhIGAkZWxlbU1hdGNoYCBvciBzaW1pbGFyIHByb2plY3Rpb25cbiAqIC0gYE1pc3NpbmdTY2hlbWFFcnJvcmA6IFlvdSB0cmllZCB0byBhY2Nlc3MgYSBtb2RlbCB3aXRoIFtgbW9uZ29vc2UubW9kZWwoKWBdKGh0dHBzOi8vbW9uZ29vc2Vqcy5jb20vZG9jcy9hcGkvbW9uZ29vc2UuaHRtbCNNb25nb29zZS5tb2RlbCgpKSB0aGF0IHdhcyBub3QgZGVmaW5lZFxuICogLSBgRG9jdW1lbnROb3RGb3VuZEVycm9yYDogVGhlIGRvY3VtZW50IHlvdSB0cmllZCB0byBbYHNhdmUoKWBdKGh0dHBzOi8vbW9uZ29vc2Vqcy5jb20vZG9jcy9hcGkvZG9jdW1lbnQuaHRtbCNEb2N1bWVudC5wcm90b3R5cGUuc2F2ZSgpKSB3YXMgbm90IGZvdW5kXG4gKiAtIGBWYWxpZGF0b3JFcnJvcmA6IGVycm9yIGZyb20gYW4gaW5kaXZpZHVhbCBzY2hlbWEgcGF0aCdzIHZhbGlkYXRvclxuICogLSBgVmFsaWRhdGlvbkVycm9yYDogZXJyb3IgcmV0dXJuZWQgZnJvbSBbYHZhbGlkYXRlKClgXShodHRwczovL21vbmdvb3NlanMuY29tL2RvY3MvYXBpL2RvY3VtZW50Lmh0bWwjRG9jdW1lbnQucHJvdG90eXBlLnZhbGlkYXRlKCkpIG9yIFtgdmFsaWRhdGVTeW5jKClgXShodHRwczovL21vbmdvb3NlanMuY29tL2RvY3MvYXBpL2RvY3VtZW50Lmh0bWwjRG9jdW1lbnQucHJvdG90eXBlLnZhbGlkYXRlU3luYygpKS4gQ29udGFpbnMgemVybyBvciBtb3JlIGBWYWxpZGF0b3JFcnJvcmAgaW5zdGFuY2VzIGluIGAuZXJyb3JzYCBwcm9wZXJ0eS5cbiAqIC0gYE1pc3NpbmdTY2hlbWFFcnJvcmA6IFlvdSBjYWxsZWQgYG1vbmdvb3NlLkRvY3VtZW50KClgIHdpdGhvdXQgYSBzY2hlbWFcbiAqIC0gYE9iamVjdEV4cGVjdGVkRXJyb3JgOiBUaHJvd24gd2hlbiB5b3Ugc2V0IGEgbmVzdGVkIHBhdGggdG8gYSBub24tb2JqZWN0IHZhbHVlIHdpdGggW3N0cmljdCBtb2RlIHNldF0oaHR0cHM6Ly9tb25nb29zZWpzLmNvbS9kb2NzL2d1aWRlLmh0bWwjc3RyaWN0KS5cbiAqIC0gYE9iamVjdFBhcmFtZXRlckVycm9yYDogVGhyb3duIHdoZW4geW91IHBhc3MgYSBub24tb2JqZWN0IHZhbHVlIHRvIGEgZnVuY3Rpb24gd2hpY2ggZXhwZWN0cyBhbiBvYmplY3QgYXMgYSBwYXJhbXRlclxuICogLSBgT3ZlcndyaXRlTW9kZWxFcnJvcmA6IFRocm93biB3aGVuIHlvdSBjYWxsIFtgbW9uZ29vc2UubW9kZWwoKWBdKGh0dHBzOi8vbW9uZ29vc2Vqcy5jb20vZG9jcy9hcGkvbW9uZ29vc2UuaHRtbCNNb25nb29zZS5tb2RlbCgpKSB0byByZS1kZWZpbmUgYSBtb2RlbCB0aGF0IHdhcyBhbHJlYWR5IGRlZmluZWQuXG4gKiAtIGBQYXJhbGxlbFNhdmVFcnJvcmA6IFRocm93biB3aGVuIHlvdSBjYWxsIFtgc2F2ZSgpYF0oaHR0cHM6Ly9tb25nb29zZWpzLmNvbS9kb2NzL2FwaS9tb2RlbC5odG1sI01vZGVsLnByb3RvdHlwZS5zYXZlKCkpIG9uIGEgZG9jdW1lbnQgd2hlbiB0aGUgc2FtZSBkb2N1bWVudCBpbnN0YW5jZSBpcyBhbHJlYWR5IHNhdmluZy5cbiAqIC0gYFN0cmljdE1vZGVFcnJvcmA6IFRocm93biB3aGVuIHlvdSBzZXQgYSBwYXRoIHRoYXQgaXNuJ3QgdGhlIHNjaGVtYSBhbmQgW3N0cmljdCBtb2RlXShodHRwczovL21vbmdvb3NlanMuY29tL2RvY3MvZ3VpZGUuaHRtbCNzdHJpY3QpIGlzIHNldCB0byBgdGhyb3dgLlxuICogLSBgVmVyc2lvbkVycm9yYDogVGhyb3duIHdoZW4gdGhlIFtkb2N1bWVudCBpcyBvdXQgb2Ygc3luY10oaHR0cHM6Ly9tb25nb29zZWpzLmNvbS9kb2NzL2d1aWRlLmh0bWwjdmVyc2lvbktleSlcbiAqXG4gKiBAYXBpIHB1YmxpY1xuICogQHByb3BlcnR5IHtTdHJpbmd9IG5hbWVcbiAqIEBtZW1iZXJPZiBFcnJvclxuICogQGluc3RhbmNlXG4gKi9cblxuLyohXG4gKiBNb2R1bGUgZXhwb3J0cy5cbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHMgPSBNb25nb29zZUVycm9yO1xuXG4vKipcbiAqIFRoZSBkZWZhdWx0IGJ1aWx0LWluIHZhbGlkYXRvciBlcnJvciBtZXNzYWdlcy5cbiAqXG4gKiBAc2VlIEVycm9yLm1lc3NhZ2VzIGh0dHBzOi8vbW9uZ29vc2Vqcy5jb20vZG9jcy9hcGkvZXJyb3IuaHRtbCNFcnJvci5tZXNzYWdlc1xuICogQGFwaSBwdWJsaWNcbiAqIEBtZW1iZXJPZiBFcnJvclxuICogQHN0YXRpY1xuICovXG5cbk1vbmdvb3NlRXJyb3IubWVzc2FnZXMgPSByZXF1aXJlKCcuL21lc3NhZ2VzJyk7XG5cbi8vIGJhY2t3YXJkIGNvbXBhdFxuTW9uZ29vc2VFcnJvci5NZXNzYWdlcyA9IE1vbmdvb3NlRXJyb3IubWVzc2FnZXM7XG5cbi8qKlxuICogQW4gaW5zdGFuY2Ugb2YgdGhpcyBlcnJvciBjbGFzcyB3aWxsIGJlIHJldHVybmVkIHdoZW4gYHNhdmUoKWAgZmFpbHNcbiAqIGJlY2F1c2UgdGhlIHVuZGVybHlpbmdcbiAqIGRvY3VtZW50IHdhcyBub3QgZm91bmQuIFRoZSBjb25zdHJ1Y3RvciB0YWtlcyBvbmUgcGFyYW1ldGVyLCB0aGVcbiAqIGNvbmRpdGlvbnMgdGhhdCBtb25nb29zZSBwYXNzZWQgdG8gYHVwZGF0ZU9uZSgpYCB3aGVuIHRyeWluZyB0byB1cGRhdGVcbiAqIHRoZSBkb2N1bWVudC5cbiAqXG4gKiBAYXBpIHB1YmxpY1xuICogQG1lbWJlck9mIEVycm9yXG4gKiBAc3RhdGljXG4gKi9cblxuTW9uZ29vc2VFcnJvci5Eb2N1bWVudE5vdEZvdW5kRXJyb3IgPSByZXF1aXJlKCcuL25vdEZvdW5kJyk7XG5cbi8qKlxuICogQW4gaW5zdGFuY2Ugb2YgdGhpcyBlcnJvciBjbGFzcyB3aWxsIGJlIHJldHVybmVkIHdoZW4gbW9uZ29vc2UgZmFpbGVkIHRvXG4gKiBjYXN0IGEgdmFsdWUuXG4gKlxuICogQGFwaSBwdWJsaWNcbiAqIEBtZW1iZXJPZiBFcnJvclxuICogQHN0YXRpY1xuICovXG5cbk1vbmdvb3NlRXJyb3IuQ2FzdEVycm9yID0gcmVxdWlyZSgnLi9jYXN0Jyk7XG5cbi8qKlxuICogQW4gaW5zdGFuY2Ugb2YgdGhpcyBlcnJvciBjbGFzcyB3aWxsIGJlIHJldHVybmVkIHdoZW4gW3ZhbGlkYXRpb25dKGh0dHBzOi8vbW9uZ29vc2Vqcy5jb20vZG9jcy92YWxpZGF0aW9uLmh0bWwpIGZhaWxlZC5cbiAqIFRoZSBgZXJyb3JzYCBwcm9wZXJ0eSBjb250YWlucyBhbiBvYmplY3Qgd2hvc2Uga2V5cyBhcmUgdGhlIHBhdGhzIHRoYXQgZmFpbGVkIGFuZCB3aG9zZSB2YWx1ZXMgYXJlXG4gKiBpbnN0YW5jZXMgb2YgQ2FzdEVycm9yIG9yIFZhbGlkYXRpb25FcnJvci5cbiAqXG4gKiBAYXBpIHB1YmxpY1xuICogQG1lbWJlck9mIEVycm9yXG4gKiBAc3RhdGljXG4gKi9cblxuTW9uZ29vc2VFcnJvci5WYWxpZGF0aW9uRXJyb3IgPSByZXF1aXJlKCcuL3ZhbGlkYXRpb24nKTtcblxuLyoqXG4gKiBBIGBWYWxpZGF0aW9uRXJyb3JgIGhhcyBhIGhhc2ggb2YgYGVycm9yc2AgdGhhdCBjb250YWluIGluZGl2aWR1YWxcbiAqIGBWYWxpZGF0b3JFcnJvcmAgaW5zdGFuY2VzLlxuICpcbiAqICMjIyMgRXhhbXBsZTpcbiAqXG4gKiAgICAgY29uc3Qgc2NoZW1hID0gU2NoZW1hKHsgbmFtZTogeyB0eXBlOiBTdHJpbmcsIHJlcXVpcmVkOiB0cnVlIH0gfSk7XG4gKiAgICAgY29uc3QgTW9kZWwgPSBtb25nb29zZS5tb2RlbCgnVGVzdCcsIHNjaGVtYSk7XG4gKiAgICAgY29uc3QgZG9jID0gbmV3IE1vZGVsKHt9KTtcbiAqXG4gKiAgICAgLy8gVG9wLWxldmVsIGVycm9yIGlzIGEgVmFsaWRhdGlvbkVycm9yLCAqKm5vdCoqIGEgVmFsaWRhdG9yRXJyb3JcbiAqICAgICBjb25zdCBlcnIgPSBkb2MudmFsaWRhdGVTeW5jKCk7XG4gKiAgICAgZXJyIGluc3RhbmNlb2YgbW9uZ29vc2UuRXJyb3IuVmFsaWRhdGlvbkVycm9yOyAvLyB0cnVlXG4gKlxuICogICAgIC8vIEEgVmFsaWRhdGlvbkVycm9yIGBlcnJgIGhhcyAwIG9yIG1vcmUgVmFsaWRhdG9yRXJyb3JzIGtleWVkIGJ5IHRoZVxuICogICAgIC8vIHBhdGggaW4gdGhlIGBlcnIuZXJyb3JzYCBwcm9wZXJ0eS5cbiAqICAgICBlcnIuZXJyb3JzWyduYW1lJ10gaW5zdGFuY2VvZiBtb25nb29zZS5FcnJvci5WYWxpZGF0b3JFcnJvcjtcbiAqXG4gKiAgICAgZXJyLmVycm9yc1snbmFtZSddLmtpbmQ7IC8vICdyZXF1aXJlZCdcbiAqICAgICBlcnIuZXJyb3JzWyduYW1lJ10ucGF0aDsgLy8gJ25hbWUnXG4gKiAgICAgZXJyLmVycm9yc1snbmFtZSddLnZhbHVlOyAvLyB1bmRlZmluZWRcbiAqXG4gKiBJbnN0YW5jZXMgb2YgYFZhbGlkYXRvckVycm9yYCBoYXZlIHRoZSBmb2xsb3dpbmcgcHJvcGVydGllczpcbiAqXG4gKiAtIGBraW5kYDogVGhlIHZhbGlkYXRvcidzIGB0eXBlYCwgbGlrZSBgJ3JlcXVpcmVkJ2Agb3IgYCdyZWdleHAnYFxuICogLSBgcGF0aGA6IFRoZSBwYXRoIHRoYXQgZmFpbGVkIHZhbGlkYXRpb25cbiAqIC0gYHZhbHVlYDogVGhlIHZhbHVlIHRoYXQgZmFpbGVkIHZhbGlkYXRpb25cbiAqXG4gKiBAYXBpIHB1YmxpY1xuICogQG1lbWJlck9mIEVycm9yXG4gKiBAc3RhdGljXG4gKi9cblxuTW9uZ29vc2VFcnJvci5WYWxpZGF0b3JFcnJvciA9IHJlcXVpcmUoJy4vdmFsaWRhdG9yJyk7XG5cbi8qKlxuICogQW4gaW5zdGFuY2Ugb2YgdGhpcyBlcnJvciBjbGFzcyB3aWxsIGJlIHJldHVybmVkIHdoZW4geW91IGNhbGwgYHNhdmUoKWAgYWZ0ZXJcbiAqIHRoZSBkb2N1bWVudCBpbiB0aGUgZGF0YWJhc2Ugd2FzIGNoYW5nZWQgaW4gYSBwb3RlbnRpYWxseSB1bnNhZmUgd2F5LiBTZWVcbiAqIHRoZSBbYHZlcnNpb25LZXlgIG9wdGlvbl0oaHR0cHM6Ly9tb25nb29zZWpzLmNvbS9kb2NzL2d1aWRlLmh0bWwjdmVyc2lvbktleSkgZm9yIG1vcmUgaW5mb3JtYXRpb24uXG4gKlxuICogQGFwaSBwdWJsaWNcbiAqIEBtZW1iZXJPZiBFcnJvclxuICogQHN0YXRpY1xuICovXG5cbk1vbmdvb3NlRXJyb3IuVmVyc2lvbkVycm9yID0gcmVxdWlyZSgnLi92ZXJzaW9uJyk7XG5cbi8qKlxuICogQW4gaW5zdGFuY2Ugb2YgdGhpcyBlcnJvciBjbGFzcyB3aWxsIGJlIHJldHVybmVkIHdoZW4geW91IGNhbGwgYHNhdmUoKWAgbXVsdGlwbGVcbiAqIHRpbWVzIG9uIHRoZSBzYW1lIGRvY3VtZW50IGluIHBhcmFsbGVsLiBTZWUgdGhlIFtGQVFdKGh0dHBzOi8vbW9uZ29vc2Vqcy5jb20vZG9jcy9mYXEuaHRtbCkgZm9yIG1vcmVcbiAqIGluZm9ybWF0aW9uLlxuICpcbiAqIEBhcGkgcHVibGljXG4gKiBAbWVtYmVyT2YgRXJyb3JcbiAqIEBzdGF0aWNcbiAqL1xuXG5Nb25nb29zZUVycm9yLlBhcmFsbGVsU2F2ZUVycm9yID0gcmVxdWlyZSgnLi9wYXJhbGxlbFNhdmUnKTtcblxuLyoqXG4gKiBUaHJvd24gd2hlbiBhIG1vZGVsIHdpdGggdGhlIGdpdmVuIG5hbWUgd2FzIGFscmVhZHkgcmVnaXN0ZXJlZCBvbiB0aGUgY29ubmVjdGlvbi5cbiAqIFNlZSBbdGhlIEZBUSBhYm91dCBgT3ZlcndyaXRlTW9kZWxFcnJvcmBdKGh0dHBzOi8vbW9uZ29vc2Vqcy5jb20vZG9jcy9mYXEuaHRtbCNvdmVyd3JpdGUtbW9kZWwtZXJyb3IpLlxuICpcbiAqIEBhcGkgcHVibGljXG4gKiBAbWVtYmVyT2YgRXJyb3JcbiAqIEBzdGF0aWNcbiAqL1xuXG5Nb25nb29zZUVycm9yLk92ZXJ3cml0ZU1vZGVsRXJyb3IgPSByZXF1aXJlKCcuL292ZXJ3cml0ZU1vZGVsJyk7XG5cbi8qKlxuICogVGhyb3duIHdoZW4geW91IHRyeSB0byBhY2Nlc3MgYSBtb2RlbCB0aGF0IGhhcyBub3QgYmVlbiByZWdpc3RlcmVkIHlldFxuICpcbiAqIEBhcGkgcHVibGljXG4gKiBAbWVtYmVyT2YgRXJyb3JcbiAqIEBzdGF0aWNcbiAqL1xuXG5Nb25nb29zZUVycm9yLk1pc3NpbmdTY2hlbWFFcnJvciA9IHJlcXVpcmUoJy4vbWlzc2luZ1NjaGVtYScpO1xuXG4vKipcbiAqIFRocm93biB3aGVuIHRoZSBNb25nb0RCIE5vZGUgZHJpdmVyIGNhbid0IGNvbm5lY3QgdG8gYSB2YWxpZCBzZXJ2ZXJcbiAqIHRvIHNlbmQgYW4gb3BlcmF0aW9uIHRvLlxuICpcbiAqIEBhcGkgcHVibGljXG4gKiBAbWVtYmVyT2YgRXJyb3JcbiAqIEBzdGF0aWNcbiAqL1xuXG5Nb25nb29zZUVycm9yLk1vbmdvb3NlU2VydmVyU2VsZWN0aW9uRXJyb3IgPSByZXF1aXJlKCcuL3NlcnZlclNlbGVjdGlvbicpO1xuXG4vKipcbiAqIEFuIGluc3RhbmNlIG9mIHRoaXMgZXJyb3Igd2lsbCBiZSByZXR1cm5lZCBpZiB5b3UgdXNlZCBhbiBhcnJheSBwcm9qZWN0aW9uXG4gKiBhbmQgdGhlbiBtb2RpZmllZCB0aGUgYXJyYXkgaW4gYW4gdW5zYWZlIHdheS5cbiAqXG4gKiBAYXBpIHB1YmxpY1xuICogQG1lbWJlck9mIEVycm9yXG4gKiBAc3RhdGljXG4gKi9cblxuTW9uZ29vc2VFcnJvci5EaXZlcmdlbnRBcnJheUVycm9yID0gcmVxdWlyZSgnLi9kaXZlcmdlbnRBcnJheScpO1xuXG4vKipcbiAqIFRocm93biB3aGVuIHlvdXIgdHJ5IHRvIHBhc3MgdmFsdWVzIHRvIG1vZGVsIGNvbnN0cnVjdG9yIHRoYXRcbiAqIHdlcmUgbm90IHNwZWNpZmllZCBpbiBzY2hlbWEgb3IgY2hhbmdlIGltbXV0YWJsZSBwcm9wZXJ0aWVzIHdoZW5cbiAqIGBzdHJpY3RgIG1vZGUgaXMgYFwidGhyb3dcImBcbiAqXG4gKiBAYXBpIHB1YmxpY1xuICogQG1lbWJlck9mIEVycm9yXG4gKiBAc3RhdGljXG4gKi9cblxuTW9uZ29vc2VFcnJvci5TdHJpY3RNb2RlRXJyb3IgPSByZXF1aXJlKCcuL3N0cmljdCcpO1xuXG4vKipcbiAqIEFuIGluc3RhbmNlIG9mIHRoaXMgZXJyb3IgY2xhc3Mgd2lsbCBiZSByZXR1cm5lZCB3aGVuIG1vbmdvb3NlIGZhaWxlZCB0b1xuICogcG9wdWxhdGUgd2l0aCBhIHBhdGggdGhhdCBpcyBub3QgZXhpc3RpbmcuXG4gKlxuICogQGFwaSBwdWJsaWNcbiAqIEBtZW1iZXJPZiBFcnJvclxuICogQHN0YXRpY1xuICovXG5cbk1vbmdvb3NlRXJyb3IuU3RyaWN0UG9wdWxhdGVFcnJvciA9IHJlcXVpcmUoJy4vc3RyaWN0UG9wdWxhdGUnKTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/mongoose/lib/error/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/mongoose/lib/error/invalidSchemaOption.js":
/*!****************************************************************!*\
  !*** ./node_modules/mongoose/lib/error/invalidSchemaOption.js ***!
  \****************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\n/*!\n * Module dependencies.\n */\n\n\n\nconst MongooseError = __webpack_require__(/*! ./ */ \"(ssr)/./node_modules/mongoose/lib/error/index.js\");\n\nclass InvalidSchemaOptionError extends MongooseError {\n  /**\n   * InvalidSchemaOption Error constructor.\n   * @param {String} name\n   * @api private\n   */\n  constructor(name, option) {\n    const msg = `Cannot create use schema for property \"${name}\" because the schema has the ${option} option enabled.`;\n    super(msg);\n  }\n}\n\nObject.defineProperty(InvalidSchemaOptionError.prototype, 'name', {\n  value: 'InvalidSchemaOptionError'\n});\n\n/*!\n * exports\n */\n\nmodule.exports = InvalidSchemaOptionError;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbW9uZ29vc2UvbGliL2Vycm9yL2ludmFsaWRTY2hlbWFPcHRpb24uanMiLCJtYXBwaW5ncyI6IjtBQUNBO0FBQ0E7QUFDQTs7QUFFYTs7QUFFYixzQkFBc0IsbUJBQU8sQ0FBQyw0REFBSTs7QUFFbEM7QUFDQTtBQUNBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBLDBEQUEwRCxLQUFLLCtCQUErQixRQUFRO0FBQ3RHO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7O0FBRUEiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9hcHAxLy4vbm9kZV9tb2R1bGVzL21vbmdvb3NlL2xpYi9lcnJvci9pbnZhbGlkU2NoZW1hT3B0aW9uLmpzPzA2MDQiXSwic291cmNlc0NvbnRlbnQiOlsiXG4vKiFcbiAqIE1vZHVsZSBkZXBlbmRlbmNpZXMuXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG5jb25zdCBNb25nb29zZUVycm9yID0gcmVxdWlyZSgnLi8nKTtcblxuY2xhc3MgSW52YWxpZFNjaGVtYU9wdGlvbkVycm9yIGV4dGVuZHMgTW9uZ29vc2VFcnJvciB7XG4gIC8qKlxuICAgKiBJbnZhbGlkU2NoZW1hT3B0aW9uIEVycm9yIGNvbnN0cnVjdG9yLlxuICAgKiBAcGFyYW0ge1N0cmluZ30gbmFtZVxuICAgKiBAYXBpIHByaXZhdGVcbiAgICovXG4gIGNvbnN0cnVjdG9yKG5hbWUsIG9wdGlvbikge1xuICAgIGNvbnN0IG1zZyA9IGBDYW5ub3QgY3JlYXRlIHVzZSBzY2hlbWEgZm9yIHByb3BlcnR5IFwiJHtuYW1lfVwiIGJlY2F1c2UgdGhlIHNjaGVtYSBoYXMgdGhlICR7b3B0aW9ufSBvcHRpb24gZW5hYmxlZC5gO1xuICAgIHN1cGVyKG1zZyk7XG4gIH1cbn1cblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KEludmFsaWRTY2hlbWFPcHRpb25FcnJvci5wcm90b3R5cGUsICduYW1lJywge1xuICB2YWx1ZTogJ0ludmFsaWRTY2hlbWFPcHRpb25FcnJvcidcbn0pO1xuXG4vKiFcbiAqIGV4cG9ydHNcbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IEludmFsaWRTY2hlbWFPcHRpb25FcnJvcjtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/mongoose/lib/error/invalidSchemaOption.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/mongoose/lib/error/messages.js":
/*!*****************************************************!*\
  !*** ./node_modules/mongoose/lib/error/messages.js ***!
  \*****************************************************/
/***/ ((module, exports) => {

eval("\n/**\n * The default built-in validator error messages. These may be customized.\n *\n *     // customize within each schema or globally like so\n *     const mongoose = require('mongoose');\n *     mongoose.Error.messages.String.enum  = \"Your custom message for {PATH}.\";\n *\n * Error messages support basic templating. Mongoose will replace the following strings with the corresponding value.\n *\n * - `{PATH}` is replaced with the invalid document path\n * - `{VALUE}` is replaced with the invalid value\n * - `{TYPE}` is replaced with the validator type such as \"regexp\", \"min\", or \"user defined\"\n * - `{MIN}` is replaced with the declared min value for the Number.min validator\n * - `{MAX}` is replaced with the declared max value for the Number.max validator\n *\n * Click the \"show code\" link below to see all defaults.\n *\n * @static\n * @memberOf MongooseError\n * @api public\n */\n\n\n\nconst msg = module.exports = exports = {};\n\nmsg.DocumentNotFoundError = null;\n\nmsg.general = {};\nmsg.general.default = 'Validator failed for path `{PATH}` with value `{VALUE}`';\nmsg.general.required = 'Path `{PATH}` is required.';\n\nmsg.Number = {};\nmsg.Number.min = 'Path `{PATH}` ({VALUE}) is less than minimum allowed value ({MIN}).';\nmsg.Number.max = 'Path `{PATH}` ({VALUE}) is more than maximum allowed value ({MAX}).';\nmsg.Number.enum = '`{VALUE}` is not a valid enum value for path `{PATH}`.';\n\nmsg.Date = {};\nmsg.Date.min = 'Path `{PATH}` ({VALUE}) is before minimum allowed value ({MIN}).';\nmsg.Date.max = 'Path `{PATH}` ({VALUE}) is after maximum allowed value ({MAX}).';\n\nmsg.String = {};\nmsg.String.enum = '`{VALUE}` is not a valid enum value for path `{PATH}`.';\nmsg.String.match = 'Path `{PATH}` is invalid ({VALUE}).';\nmsg.String.minlength = 'Path `{PATH}` (`{VALUE}`) is shorter than the minimum allowed length ({MINLENGTH}).';\nmsg.String.maxlength = 'Path `{PATH}` (`{VALUE}`) is longer than the maximum allowed length ({MAXLENGTH}).';\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbW9uZ29vc2UvbGliL2Vycm9yL21lc3NhZ2VzLmpzIiwibWFwcGluZ3MiOiI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0VBQXdFLEtBQUs7QUFDN0U7QUFDQTtBQUNBO0FBQ0EsT0FBTyxLQUFLO0FBQ1osT0FBTyxNQUFNO0FBQ2IsT0FBTyxLQUFLO0FBQ1osT0FBTyxJQUFJO0FBQ1gsT0FBTyxJQUFJO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRWE7O0FBRWI7O0FBRUE7O0FBRUE7QUFDQSxtREFBbUQsS0FBSyxlQUFlLE1BQU07QUFDN0UsK0JBQStCLEtBQUs7O0FBRXBDO0FBQ0EseUJBQXlCLEtBQUssSUFBSSxNQUFNLHVDQUF1QyxJQUFJO0FBQ25GLHlCQUF5QixLQUFLLElBQUksTUFBTSx1Q0FBdUMsSUFBSTtBQUNuRixxQkFBcUIsTUFBTSx1Q0FBdUMsS0FBSzs7QUFFdkU7QUFDQSx1QkFBdUIsS0FBSyxJQUFJLE1BQU0sb0NBQW9DLElBQUk7QUFDOUUsdUJBQXVCLEtBQUssSUFBSSxNQUFNLG1DQUFtQyxJQUFJOztBQUU3RTtBQUNBLHFCQUFxQixNQUFNLHVDQUF1QyxLQUFLO0FBQ3ZFLDJCQUEyQixLQUFLLGVBQWUsTUFBTTtBQUNyRCwrQkFBK0IsS0FBSyxLQUFLLE1BQU0sZ0RBQWdELFVBQVU7QUFDekcsK0JBQStCLEtBQUssS0FBSyxNQUFNLCtDQUErQyxVQUFVIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vYXBwMS8uL25vZGVfbW9kdWxlcy9tb25nb29zZS9saWIvZXJyb3IvbWVzc2FnZXMuanM/NjMzOCJdLCJzb3VyY2VzQ29udGVudCI6WyJcbi8qKlxuICogVGhlIGRlZmF1bHQgYnVpbHQtaW4gdmFsaWRhdG9yIGVycm9yIG1lc3NhZ2VzLiBUaGVzZSBtYXkgYmUgY3VzdG9taXplZC5cbiAqXG4gKiAgICAgLy8gY3VzdG9taXplIHdpdGhpbiBlYWNoIHNjaGVtYSBvciBnbG9iYWxseSBsaWtlIHNvXG4gKiAgICAgY29uc3QgbW9uZ29vc2UgPSByZXF1aXJlKCdtb25nb29zZScpO1xuICogICAgIG1vbmdvb3NlLkVycm9yLm1lc3NhZ2VzLlN0cmluZy5lbnVtICA9IFwiWW91ciBjdXN0b20gbWVzc2FnZSBmb3Ige1BBVEh9LlwiO1xuICpcbiAqIEVycm9yIG1lc3NhZ2VzIHN1cHBvcnQgYmFzaWMgdGVtcGxhdGluZy4gTW9uZ29vc2Ugd2lsbCByZXBsYWNlIHRoZSBmb2xsb3dpbmcgc3RyaW5ncyB3aXRoIHRoZSBjb3JyZXNwb25kaW5nIHZhbHVlLlxuICpcbiAqIC0gYHtQQVRIfWAgaXMgcmVwbGFjZWQgd2l0aCB0aGUgaW52YWxpZCBkb2N1bWVudCBwYXRoXG4gKiAtIGB7VkFMVUV9YCBpcyByZXBsYWNlZCB3aXRoIHRoZSBpbnZhbGlkIHZhbHVlXG4gKiAtIGB7VFlQRX1gIGlzIHJlcGxhY2VkIHdpdGggdGhlIHZhbGlkYXRvciB0eXBlIHN1Y2ggYXMgXCJyZWdleHBcIiwgXCJtaW5cIiwgb3IgXCJ1c2VyIGRlZmluZWRcIlxuICogLSBge01JTn1gIGlzIHJlcGxhY2VkIHdpdGggdGhlIGRlY2xhcmVkIG1pbiB2YWx1ZSBmb3IgdGhlIE51bWJlci5taW4gdmFsaWRhdG9yXG4gKiAtIGB7TUFYfWAgaXMgcmVwbGFjZWQgd2l0aCB0aGUgZGVjbGFyZWQgbWF4IHZhbHVlIGZvciB0aGUgTnVtYmVyLm1heCB2YWxpZGF0b3JcbiAqXG4gKiBDbGljayB0aGUgXCJzaG93IGNvZGVcIiBsaW5rIGJlbG93IHRvIHNlZSBhbGwgZGVmYXVsdHMuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIE1vbmdvb3NlRXJyb3JcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG5jb25zdCBtc2cgPSBtb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHMgPSB7fTtcblxubXNnLkRvY3VtZW50Tm90Rm91bmRFcnJvciA9IG51bGw7XG5cbm1zZy5nZW5lcmFsID0ge307XG5tc2cuZ2VuZXJhbC5kZWZhdWx0ID0gJ1ZhbGlkYXRvciBmYWlsZWQgZm9yIHBhdGggYHtQQVRIfWAgd2l0aCB2YWx1ZSBge1ZBTFVFfWAnO1xubXNnLmdlbmVyYWwucmVxdWlyZWQgPSAnUGF0aCBge1BBVEh9YCBpcyByZXF1aXJlZC4nO1xuXG5tc2cuTnVtYmVyID0ge307XG5tc2cuTnVtYmVyLm1pbiA9ICdQYXRoIGB7UEFUSH1gICh7VkFMVUV9KSBpcyBsZXNzIHRoYW4gbWluaW11bSBhbGxvd2VkIHZhbHVlICh7TUlOfSkuJztcbm1zZy5OdW1iZXIubWF4ID0gJ1BhdGggYHtQQVRIfWAgKHtWQUxVRX0pIGlzIG1vcmUgdGhhbiBtYXhpbXVtIGFsbG93ZWQgdmFsdWUgKHtNQVh9KS4nO1xubXNnLk51bWJlci5lbnVtID0gJ2B7VkFMVUV9YCBpcyBub3QgYSB2YWxpZCBlbnVtIHZhbHVlIGZvciBwYXRoIGB7UEFUSH1gLic7XG5cbm1zZy5EYXRlID0ge307XG5tc2cuRGF0ZS5taW4gPSAnUGF0aCBge1BBVEh9YCAoe1ZBTFVFfSkgaXMgYmVmb3JlIG1pbmltdW0gYWxsb3dlZCB2YWx1ZSAoe01JTn0pLic7XG5tc2cuRGF0ZS5tYXggPSAnUGF0aCBge1BBVEh9YCAoe1ZBTFVFfSkgaXMgYWZ0ZXIgbWF4aW11bSBhbGxvd2VkIHZhbHVlICh7TUFYfSkuJztcblxubXNnLlN0cmluZyA9IHt9O1xubXNnLlN0cmluZy5lbnVtID0gJ2B7VkFMVUV9YCBpcyBub3QgYSB2YWxpZCBlbnVtIHZhbHVlIGZvciBwYXRoIGB7UEFUSH1gLic7XG5tc2cuU3RyaW5nLm1hdGNoID0gJ1BhdGggYHtQQVRIfWAgaXMgaW52YWxpZCAoe1ZBTFVFfSkuJztcbm1zZy5TdHJpbmcubWlubGVuZ3RoID0gJ1BhdGggYHtQQVRIfWAgKGB7VkFMVUV9YCkgaXMgc2hvcnRlciB0aGFuIHRoZSBtaW5pbXVtIGFsbG93ZWQgbGVuZ3RoICh7TUlOTEVOR1RIfSkuJztcbm1zZy5TdHJpbmcubWF4bGVuZ3RoID0gJ1BhdGggYHtQQVRIfWAgKGB7VkFMVUV9YCkgaXMgbG9uZ2VyIHRoYW4gdGhlIG1heGltdW0gYWxsb3dlZCBsZW5ndGggKHtNQVhMRU5HVEh9KS4nO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/mongoose/lib/error/messages.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/mongoose/lib/error/missingSchema.js":
/*!**********************************************************!*\
  !*** ./node_modules/mongoose/lib/error/missingSchema.js ***!
  \**********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\n/*!\n * Module dependencies.\n */\n\n\n\nconst MongooseError = __webpack_require__(/*! ./ */ \"(ssr)/./node_modules/mongoose/lib/error/index.js\");\n\nclass MissingSchemaError extends MongooseError {\n  /**\n   * MissingSchema Error constructor.\n   * @param {String} name\n   * @api private\n   */\n  constructor(name) {\n    const msg = 'Schema hasn\\'t been registered for model \"' + name + '\".\\n'\n            + 'Use mongoose.model(name, schema)';\n    super(msg);\n  }\n}\n\nObject.defineProperty(MissingSchemaError.prototype, 'name', {\n  value: 'MissingSchemaError'\n});\n\n/*!\n * exports\n */\n\nmodule.exports = MissingSchemaError;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbW9uZ29vc2UvbGliL2Vycm9yL21pc3NpbmdTY2hlbWEuanMiLCJtYXBwaW5ncyI6IjtBQUNBO0FBQ0E7QUFDQTs7QUFFYTs7QUFFYixzQkFBc0IsbUJBQU8sQ0FBQyw0REFBSTs7QUFFbEM7QUFDQTtBQUNBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBOztBQUVBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vYXBwMS8uL25vZGVfbW9kdWxlcy9tb25nb29zZS9saWIvZXJyb3IvbWlzc2luZ1NjaGVtYS5qcz82ZDAwIl0sInNvdXJjZXNDb250ZW50IjpbIlxuLyohXG4gKiBNb2R1bGUgZGVwZW5kZW5jaWVzLlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxuY29uc3QgTW9uZ29vc2VFcnJvciA9IHJlcXVpcmUoJy4vJyk7XG5cbmNsYXNzIE1pc3NpbmdTY2hlbWFFcnJvciBleHRlbmRzIE1vbmdvb3NlRXJyb3Ige1xuICAvKipcbiAgICogTWlzc2luZ1NjaGVtYSBFcnJvciBjb25zdHJ1Y3Rvci5cbiAgICogQHBhcmFtIHtTdHJpbmd9IG5hbWVcbiAgICogQGFwaSBwcml2YXRlXG4gICAqL1xuICBjb25zdHJ1Y3RvcihuYW1lKSB7XG4gICAgY29uc3QgbXNnID0gJ1NjaGVtYSBoYXNuXFwndCBiZWVuIHJlZ2lzdGVyZWQgZm9yIG1vZGVsIFwiJyArIG5hbWUgKyAnXCIuXFxuJ1xuICAgICAgICAgICAgKyAnVXNlIG1vbmdvb3NlLm1vZGVsKG5hbWUsIHNjaGVtYSknO1xuICAgIHN1cGVyKG1zZyk7XG4gIH1cbn1cblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KE1pc3NpbmdTY2hlbWFFcnJvci5wcm90b3R5cGUsICduYW1lJywge1xuICB2YWx1ZTogJ01pc3NpbmdTY2hlbWFFcnJvcidcbn0pO1xuXG4vKiFcbiAqIGV4cG9ydHNcbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IE1pc3NpbmdTY2hlbWFFcnJvcjtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/mongoose/lib/error/missingSchema.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/mongoose/lib/error/mongooseError.js":
/*!**********************************************************!*\
  !*** ./node_modules/mongoose/lib/error/mongooseError.js ***!
  \**********************************************************/
/***/ ((module) => {

eval("\n\n/*!\n * ignore\n */\n\nclass MongooseError extends Error { }\n\nObject.defineProperty(MongooseError.prototype, 'name', {\n  value: 'MongooseError'\n});\n\nmodule.exports = MongooseError;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbW9uZ29vc2UvbGliL2Vycm9yL21vbmdvb3NlRXJyb3IuanMiLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWI7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxDQUFDOztBQUVEIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vYXBwMS8uL25vZGVfbW9kdWxlcy9tb25nb29zZS9saWIvZXJyb3IvbW9uZ29vc2VFcnJvci5qcz83MzcxIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxuLyohXG4gKiBpZ25vcmVcbiAqL1xuXG5jbGFzcyBNb25nb29zZUVycm9yIGV4dGVuZHMgRXJyb3IgeyB9XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShNb25nb29zZUVycm9yLnByb3RvdHlwZSwgJ25hbWUnLCB7XG4gIHZhbHVlOiAnTW9uZ29vc2VFcnJvcidcbn0pO1xuXG5tb2R1bGUuZXhwb3J0cyA9IE1vbmdvb3NlRXJyb3I7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/mongoose/lib/error/mongooseError.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/mongoose/lib/error/notFound.js":
/*!*****************************************************!*\
  !*** ./node_modules/mongoose/lib/error/notFound.js ***!
  \*****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\n\n/*!\n * Module dependencies.\n */\n\nconst MongooseError = __webpack_require__(/*! ./ */ \"(ssr)/./node_modules/mongoose/lib/error/index.js\");\nconst util = __webpack_require__(/*! util */ \"util\");\n\nclass DocumentNotFoundError extends MongooseError {\n  /**\n   * OverwriteModel Error constructor.\n   * @api private\n   */\n  constructor(filter, model, numAffected, result) {\n    let msg;\n    const messages = MongooseError.messages;\n    if (messages.DocumentNotFoundError != null) {\n      msg = typeof messages.DocumentNotFoundError === 'function' ?\n        messages.DocumentNotFoundError(filter, model) :\n        messages.DocumentNotFoundError;\n    } else {\n      msg = 'No document found for query \"' + util.inspect(filter) +\n        '\" on model \"' + model + '\"';\n    }\n\n    super(msg);\n\n    this.result = result;\n    this.numAffected = numAffected;\n    this.filter = filter;\n    // Backwards compat\n    this.query = filter;\n  }\n}\n\nObject.defineProperty(DocumentNotFoundError.prototype, 'name', {\n  value: 'DocumentNotFoundError'\n});\n\n/*!\n * exports\n */\n\nmodule.exports = DocumentNotFoundError;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbW9uZ29vc2UvbGliL2Vycm9yL25vdEZvdW5kLmpzIiwibWFwcGluZ3MiOiJBQUFhOztBQUViO0FBQ0E7QUFDQTs7QUFFQSxzQkFBc0IsbUJBQU8sQ0FBQyw0REFBSTtBQUNsQyxhQUFhLG1CQUFPLENBQUMsa0JBQU07O0FBRTNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBOztBQUVBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vYXBwMS8uL25vZGVfbW9kdWxlcy9tb25nb29zZS9saWIvZXJyb3Ivbm90Rm91bmQuanM/YmE2YyJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbi8qIVxuICogTW9kdWxlIGRlcGVuZGVuY2llcy5cbiAqL1xuXG5jb25zdCBNb25nb29zZUVycm9yID0gcmVxdWlyZSgnLi8nKTtcbmNvbnN0IHV0aWwgPSByZXF1aXJlKCd1dGlsJyk7XG5cbmNsYXNzIERvY3VtZW50Tm90Rm91bmRFcnJvciBleHRlbmRzIE1vbmdvb3NlRXJyb3Ige1xuICAvKipcbiAgICogT3ZlcndyaXRlTW9kZWwgRXJyb3IgY29uc3RydWN0b3IuXG4gICAqIEBhcGkgcHJpdmF0ZVxuICAgKi9cbiAgY29uc3RydWN0b3IoZmlsdGVyLCBtb2RlbCwgbnVtQWZmZWN0ZWQsIHJlc3VsdCkge1xuICAgIGxldCBtc2c7XG4gICAgY29uc3QgbWVzc2FnZXMgPSBNb25nb29zZUVycm9yLm1lc3NhZ2VzO1xuICAgIGlmIChtZXNzYWdlcy5Eb2N1bWVudE5vdEZvdW5kRXJyb3IgIT0gbnVsbCkge1xuICAgICAgbXNnID0gdHlwZW9mIG1lc3NhZ2VzLkRvY3VtZW50Tm90Rm91bmRFcnJvciA9PT0gJ2Z1bmN0aW9uJyA/XG4gICAgICAgIG1lc3NhZ2VzLkRvY3VtZW50Tm90Rm91bmRFcnJvcihmaWx0ZXIsIG1vZGVsKSA6XG4gICAgICAgIG1lc3NhZ2VzLkRvY3VtZW50Tm90Rm91bmRFcnJvcjtcbiAgICB9IGVsc2Uge1xuICAgICAgbXNnID0gJ05vIGRvY3VtZW50IGZvdW5kIGZvciBxdWVyeSBcIicgKyB1dGlsLmluc3BlY3QoZmlsdGVyKSArXG4gICAgICAgICdcIiBvbiBtb2RlbCBcIicgKyBtb2RlbCArICdcIic7XG4gICAgfVxuXG4gICAgc3VwZXIobXNnKTtcblxuICAgIHRoaXMucmVzdWx0ID0gcmVzdWx0O1xuICAgIHRoaXMubnVtQWZmZWN0ZWQgPSBudW1BZmZlY3RlZDtcbiAgICB0aGlzLmZpbHRlciA9IGZpbHRlcjtcbiAgICAvLyBCYWNrd2FyZHMgY29tcGF0XG4gICAgdGhpcy5xdWVyeSA9IGZpbHRlcjtcbiAgfVxufVxuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoRG9jdW1lbnROb3RGb3VuZEVycm9yLnByb3RvdHlwZSwgJ25hbWUnLCB7XG4gIHZhbHVlOiAnRG9jdW1lbnROb3RGb3VuZEVycm9yJ1xufSk7XG5cbi8qIVxuICogZXhwb3J0c1xuICovXG5cbm1vZHVsZS5leHBvcnRzID0gRG9jdW1lbnROb3RGb3VuZEVycm9yO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/mongoose/lib/error/notFound.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/mongoose/lib/error/objectExpected.js":
/*!***********************************************************!*\
  !*** ./node_modules/mongoose/lib/error/objectExpected.js ***!
  \***********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("/*!\n * Module dependencies.\n */\n\n\n\nconst MongooseError = __webpack_require__(/*! ./ */ \"(ssr)/./node_modules/mongoose/lib/error/index.js\");\n\n\nclass ObjectExpectedError extends MongooseError {\n  /**\n   * Strict mode error constructor\n   *\n   * @param {string} type\n   * @param {string} value\n   * @api private\n   */\n  constructor(path, val) {\n    const typeDescription = Array.isArray(val) ? 'array' : 'primitive value';\n    super('Tried to set nested object field `' + path +\n      `\\` to ${typeDescription} \\`` + val + '`');\n    this.path = path;\n  }\n}\n\nObject.defineProperty(ObjectExpectedError.prototype, 'name', {\n  value: 'ObjectExpectedError'\n});\n\nmodule.exports = ObjectExpectedError;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbW9uZ29vc2UvbGliL2Vycm9yL29iamVjdEV4cGVjdGVkLmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTs7QUFFYTs7QUFFYixzQkFBc0IsbUJBQU8sQ0FBQyw0REFBSTs7O0FBR2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCLGFBQWEsUUFBUTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxpQkFBaUI7QUFDaEM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxDQUFDOztBQUVEIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vYXBwMS8uL25vZGVfbW9kdWxlcy9tb25nb29zZS9saWIvZXJyb3Ivb2JqZWN0RXhwZWN0ZWQuanM/ZWZkMiJdLCJzb3VyY2VzQ29udGVudCI6WyIvKiFcbiAqIE1vZHVsZSBkZXBlbmRlbmNpZXMuXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG5jb25zdCBNb25nb29zZUVycm9yID0gcmVxdWlyZSgnLi8nKTtcblxuXG5jbGFzcyBPYmplY3RFeHBlY3RlZEVycm9yIGV4dGVuZHMgTW9uZ29vc2VFcnJvciB7XG4gIC8qKlxuICAgKiBTdHJpY3QgbW9kZSBlcnJvciBjb25zdHJ1Y3RvclxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gdHlwZVxuICAgKiBAcGFyYW0ge3N0cmluZ30gdmFsdWVcbiAgICogQGFwaSBwcml2YXRlXG4gICAqL1xuICBjb25zdHJ1Y3RvcihwYXRoLCB2YWwpIHtcbiAgICBjb25zdCB0eXBlRGVzY3JpcHRpb24gPSBBcnJheS5pc0FycmF5KHZhbCkgPyAnYXJyYXknIDogJ3ByaW1pdGl2ZSB2YWx1ZSc7XG4gICAgc3VwZXIoJ1RyaWVkIHRvIHNldCBuZXN0ZWQgb2JqZWN0IGZpZWxkIGAnICsgcGF0aCArXG4gICAgICBgXFxgIHRvICR7dHlwZURlc2NyaXB0aW9ufSBcXGBgICsgdmFsICsgJ2AnKTtcbiAgICB0aGlzLnBhdGggPSBwYXRoO1xuICB9XG59XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShPYmplY3RFeHBlY3RlZEVycm9yLnByb3RvdHlwZSwgJ25hbWUnLCB7XG4gIHZhbHVlOiAnT2JqZWN0RXhwZWN0ZWRFcnJvcidcbn0pO1xuXG5tb2R1bGUuZXhwb3J0cyA9IE9iamVjdEV4cGVjdGVkRXJyb3I7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/mongoose/lib/error/objectExpected.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/mongoose/lib/error/objectParameter.js":
/*!************************************************************!*\
  !*** ./node_modules/mongoose/lib/error/objectParameter.js ***!
  \************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("/*!\n * Module dependencies.\n */\n\n\n\nconst MongooseError = __webpack_require__(/*! ./ */ \"(ssr)/./node_modules/mongoose/lib/error/index.js\");\n\nclass ObjectParameterError extends MongooseError {\n  /**\n   * Constructor for errors that happen when a parameter that's expected to be\n   * an object isn't an object\n   *\n   * @param {Any} value\n   * @param {String} paramName\n   * @param {String} fnName\n   * @api private\n   */\n  constructor(value, paramName, fnName) {\n    super('Parameter \"' + paramName + '\" to ' + fnName +\n      '() must be an object, got \"' + value.toString() + '\" (type ' + typeof value + ')');\n  }\n}\n\n\nObject.defineProperty(ObjectParameterError.prototype, 'name', {\n  value: 'ObjectParameterError'\n});\n\nmodule.exports = ObjectParameterError;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbW9uZ29vc2UvbGliL2Vycm9yL29iamVjdFBhcmFtZXRlci5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7O0FBRWE7O0FBRWIsc0JBQXNCLG1CQUFPLENBQUMsNERBQUk7O0FBRWxDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLEtBQUs7QUFDbEIsYUFBYSxRQUFRO0FBQ3JCLGFBQWEsUUFBUTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBLENBQUM7O0FBRUQiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9hcHAxLy4vbm9kZV9tb2R1bGVzL21vbmdvb3NlL2xpYi9lcnJvci9vYmplY3RQYXJhbWV0ZXIuanM/YTUzOCJdLCJzb3VyY2VzQ29udGVudCI6WyIvKiFcbiAqIE1vZHVsZSBkZXBlbmRlbmNpZXMuXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG5jb25zdCBNb25nb29zZUVycm9yID0gcmVxdWlyZSgnLi8nKTtcblxuY2xhc3MgT2JqZWN0UGFyYW1ldGVyRXJyb3IgZXh0ZW5kcyBNb25nb29zZUVycm9yIHtcbiAgLyoqXG4gICAqIENvbnN0cnVjdG9yIGZvciBlcnJvcnMgdGhhdCBoYXBwZW4gd2hlbiBhIHBhcmFtZXRlciB0aGF0J3MgZXhwZWN0ZWQgdG8gYmVcbiAgICogYW4gb2JqZWN0IGlzbid0IGFuIG9iamVjdFxuICAgKlxuICAgKiBAcGFyYW0ge0FueX0gdmFsdWVcbiAgICogQHBhcmFtIHtTdHJpbmd9IHBhcmFtTmFtZVxuICAgKiBAcGFyYW0ge1N0cmluZ30gZm5OYW1lXG4gICAqIEBhcGkgcHJpdmF0ZVxuICAgKi9cbiAgY29uc3RydWN0b3IodmFsdWUsIHBhcmFtTmFtZSwgZm5OYW1lKSB7XG4gICAgc3VwZXIoJ1BhcmFtZXRlciBcIicgKyBwYXJhbU5hbWUgKyAnXCIgdG8gJyArIGZuTmFtZSArXG4gICAgICAnKCkgbXVzdCBiZSBhbiBvYmplY3QsIGdvdCBcIicgKyB2YWx1ZS50b1N0cmluZygpICsgJ1wiICh0eXBlICcgKyB0eXBlb2YgdmFsdWUgKyAnKScpO1xuICB9XG59XG5cblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KE9iamVjdFBhcmFtZXRlckVycm9yLnByb3RvdHlwZSwgJ25hbWUnLCB7XG4gIHZhbHVlOiAnT2JqZWN0UGFyYW1ldGVyRXJyb3InXG59KTtcblxubW9kdWxlLmV4cG9ydHMgPSBPYmplY3RQYXJhbWV0ZXJFcnJvcjtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/mongoose/lib/error/objectParameter.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/mongoose/lib/error/overwriteModel.js":
/*!***********************************************************!*\
  !*** ./node_modules/mongoose/lib/error/overwriteModel.js ***!
  \***********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\n/*!\n * Module dependencies.\n */\n\n\n\nconst MongooseError = __webpack_require__(/*! ./ */ \"(ssr)/./node_modules/mongoose/lib/error/index.js\");\n\n\nclass OverwriteModelError extends MongooseError {\n  /**\n   * OverwriteModel Error constructor.\n   * @param {String} name\n   * @api private\n   */\n  constructor(name) {\n    super('Cannot overwrite `' + name + '` model once compiled.');\n  }\n}\n\nObject.defineProperty(OverwriteModelError.prototype, 'name', {\n  value: 'OverwriteModelError'\n});\n\n/*!\n * exports\n */\n\nmodule.exports = OverwriteModelError;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbW9uZ29vc2UvbGliL2Vycm9yL292ZXJ3cml0ZU1vZGVsLmpzIiwibWFwcGluZ3MiOiI7QUFDQTtBQUNBO0FBQ0E7O0FBRWE7O0FBRWIsc0JBQXNCLG1CQUFPLENBQUMsNERBQUk7OztBQUdsQztBQUNBO0FBQ0E7QUFDQSxhQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTs7QUFFQSIsInNvdXJjZXMiOlsid2VicGFjazovL2FwcDEvLi9ub2RlX21vZHVsZXMvbW9uZ29vc2UvbGliL2Vycm9yL292ZXJ3cml0ZU1vZGVsLmpzP2U5MWQiXSwic291cmNlc0NvbnRlbnQiOlsiXG4vKiFcbiAqIE1vZHVsZSBkZXBlbmRlbmNpZXMuXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG5jb25zdCBNb25nb29zZUVycm9yID0gcmVxdWlyZSgnLi8nKTtcblxuXG5jbGFzcyBPdmVyd3JpdGVNb2RlbEVycm9yIGV4dGVuZHMgTW9uZ29vc2VFcnJvciB7XG4gIC8qKlxuICAgKiBPdmVyd3JpdGVNb2RlbCBFcnJvciBjb25zdHJ1Y3Rvci5cbiAgICogQHBhcmFtIHtTdHJpbmd9IG5hbWVcbiAgICogQGFwaSBwcml2YXRlXG4gICAqL1xuICBjb25zdHJ1Y3RvcihuYW1lKSB7XG4gICAgc3VwZXIoJ0Nhbm5vdCBvdmVyd3JpdGUgYCcgKyBuYW1lICsgJ2AgbW9kZWwgb25jZSBjb21waWxlZC4nKTtcbiAgfVxufVxuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoT3ZlcndyaXRlTW9kZWxFcnJvci5wcm90b3R5cGUsICduYW1lJywge1xuICB2YWx1ZTogJ092ZXJ3cml0ZU1vZGVsRXJyb3InXG59KTtcblxuLyohXG4gKiBleHBvcnRzXG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSBPdmVyd3JpdGVNb2RlbEVycm9yO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/mongoose/lib/error/overwriteModel.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/mongoose/lib/error/parallelSave.js":
/*!*********************************************************!*\
  !*** ./node_modules/mongoose/lib/error/parallelSave.js ***!
  \*********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\n\n/*!\n * Module dependencies.\n */\n\nconst MongooseError = __webpack_require__(/*! ./ */ \"(ssr)/./node_modules/mongoose/lib/error/index.js\");\n\nclass ParallelSaveError extends MongooseError {\n  /**\n   * ParallelSave Error constructor.\n   *\n   * @param {Document} doc\n   * @api private\n   */\n  constructor(doc) {\n    const msg = 'Can\\'t save() the same doc multiple times in parallel. Document: ';\n    super(msg + doc._id);\n  }\n}\n\nObject.defineProperty(ParallelSaveError.prototype, 'name', {\n  value: 'ParallelSaveError'\n});\n\n/*!\n * exports\n */\n\nmodule.exports = ParallelSaveError;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbW9uZ29vc2UvbGliL2Vycm9yL3BhcmFsbGVsU2F2ZS5qcyIsIm1hcHBpbmdzIjoiQUFBYTs7QUFFYjtBQUNBO0FBQ0E7O0FBRUEsc0JBQXNCLG1CQUFPLENBQUMsNERBQUk7O0FBRWxDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxVQUFVO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTs7QUFFQSIsInNvdXJjZXMiOlsid2VicGFjazovL2FwcDEvLi9ub2RlX21vZHVsZXMvbW9uZ29vc2UvbGliL2Vycm9yL3BhcmFsbGVsU2F2ZS5qcz8zZWNiIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxuLyohXG4gKiBNb2R1bGUgZGVwZW5kZW5jaWVzLlxuICovXG5cbmNvbnN0IE1vbmdvb3NlRXJyb3IgPSByZXF1aXJlKCcuLycpO1xuXG5jbGFzcyBQYXJhbGxlbFNhdmVFcnJvciBleHRlbmRzIE1vbmdvb3NlRXJyb3Ige1xuICAvKipcbiAgICogUGFyYWxsZWxTYXZlIEVycm9yIGNvbnN0cnVjdG9yLlxuICAgKlxuICAgKiBAcGFyYW0ge0RvY3VtZW50fSBkb2NcbiAgICogQGFwaSBwcml2YXRlXG4gICAqL1xuICBjb25zdHJ1Y3Rvcihkb2MpIHtcbiAgICBjb25zdCBtc2cgPSAnQ2FuXFwndCBzYXZlKCkgdGhlIHNhbWUgZG9jIG11bHRpcGxlIHRpbWVzIGluIHBhcmFsbGVsLiBEb2N1bWVudDogJztcbiAgICBzdXBlcihtc2cgKyBkb2MuX2lkKTtcbiAgfVxufVxuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoUGFyYWxsZWxTYXZlRXJyb3IucHJvdG90eXBlLCAnbmFtZScsIHtcbiAgdmFsdWU6ICdQYXJhbGxlbFNhdmVFcnJvcidcbn0pO1xuXG4vKiFcbiAqIGV4cG9ydHNcbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IFBhcmFsbGVsU2F2ZUVycm9yO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/mongoose/lib/error/parallelSave.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/mongoose/lib/error/parallelValidate.js":
/*!*************************************************************!*\
  !*** ./node_modules/mongoose/lib/error/parallelValidate.js ***!
  \*************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\n\n/*!\n * Module dependencies.\n */\n\nconst MongooseError = __webpack_require__(/*! ./mongooseError */ \"(ssr)/./node_modules/mongoose/lib/error/mongooseError.js\");\n\n\nclass ParallelValidateError extends MongooseError {\n  /**\n   * ParallelValidate Error constructor.\n   *\n   * @param {Document} doc\n   * @api private\n   */\n  constructor(doc) {\n    const msg = 'Can\\'t validate() the same doc multiple times in parallel. Document: ';\n    super(msg + doc._id);\n  }\n}\n\nObject.defineProperty(ParallelValidateError.prototype, 'name', {\n  value: 'ParallelValidateError'\n});\n\n/*!\n * exports\n */\n\nmodule.exports = ParallelValidateError;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbW9uZ29vc2UvbGliL2Vycm9yL3BhcmFsbGVsVmFsaWRhdGUuanMiLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWI7QUFDQTtBQUNBOztBQUVBLHNCQUFzQixtQkFBTyxDQUFDLGlGQUFpQjs7O0FBRy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxVQUFVO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTs7QUFFQSIsInNvdXJjZXMiOlsid2VicGFjazovL2FwcDEvLi9ub2RlX21vZHVsZXMvbW9uZ29vc2UvbGliL2Vycm9yL3BhcmFsbGVsVmFsaWRhdGUuanM/NjMyYSJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbi8qIVxuICogTW9kdWxlIGRlcGVuZGVuY2llcy5cbiAqL1xuXG5jb25zdCBNb25nb29zZUVycm9yID0gcmVxdWlyZSgnLi9tb25nb29zZUVycm9yJyk7XG5cblxuY2xhc3MgUGFyYWxsZWxWYWxpZGF0ZUVycm9yIGV4dGVuZHMgTW9uZ29vc2VFcnJvciB7XG4gIC8qKlxuICAgKiBQYXJhbGxlbFZhbGlkYXRlIEVycm9yIGNvbnN0cnVjdG9yLlxuICAgKlxuICAgKiBAcGFyYW0ge0RvY3VtZW50fSBkb2NcbiAgICogQGFwaSBwcml2YXRlXG4gICAqL1xuICBjb25zdHJ1Y3Rvcihkb2MpIHtcbiAgICBjb25zdCBtc2cgPSAnQ2FuXFwndCB2YWxpZGF0ZSgpIHRoZSBzYW1lIGRvYyBtdWx0aXBsZSB0aW1lcyBpbiBwYXJhbGxlbC4gRG9jdW1lbnQ6ICc7XG4gICAgc3VwZXIobXNnICsgZG9jLl9pZCk7XG4gIH1cbn1cblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KFBhcmFsbGVsVmFsaWRhdGVFcnJvci5wcm90b3R5cGUsICduYW1lJywge1xuICB2YWx1ZTogJ1BhcmFsbGVsVmFsaWRhdGVFcnJvcidcbn0pO1xuXG4vKiFcbiAqIGV4cG9ydHNcbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IFBhcmFsbGVsVmFsaWRhdGVFcnJvcjtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/mongoose/lib/error/parallelValidate.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/mongoose/lib/error/serverSelection.js":
/*!************************************************************!*\
  !*** ./node_modules/mongoose/lib/error/serverSelection.js ***!
  \************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("/*!\n * Module dependencies.\n */\n\n\n\nconst MongooseError = __webpack_require__(/*! ./mongooseError */ \"(ssr)/./node_modules/mongoose/lib/error/mongooseError.js\");\nconst allServersUnknown = __webpack_require__(/*! ../helpers/topology/allServersUnknown */ \"(ssr)/./node_modules/mongoose/lib/helpers/topology/allServersUnknown.js\");\nconst isAtlas = __webpack_require__(/*! ../helpers/topology/isAtlas */ \"(ssr)/./node_modules/mongoose/lib/helpers/topology/isAtlas.js\");\nconst isSSLError = __webpack_require__(/*! ../helpers/topology/isSSLError */ \"(ssr)/./node_modules/mongoose/lib/helpers/topology/isSSLError.js\");\n\n/*!\n * ignore\n */\n\nconst atlasMessage = 'Could not connect to any servers in your MongoDB Atlas cluster. ' +\n  'One common reason is that you\\'re trying to access the database from ' +\n  'an IP that isn\\'t whitelisted. Make sure your current IP address is on your Atlas ' +\n  'cluster\\'s IP whitelist: https://www.mongodb.com/docs/atlas/security-whitelist/';\n\nconst sslMessage = 'Mongoose is connecting with SSL enabled, but the server is ' +\n  'not accepting SSL connections. Please ensure that the MongoDB server you are ' +\n  'connecting to is configured to accept SSL connections. Learn more: ' +\n  'https://mongoosejs.com/docs/tutorials/ssl.html';\n\nclass MongooseServerSelectionError extends MongooseError {\n  /**\n   * MongooseServerSelectionError constructor\n   *\n   * @api private\n   */\n  assimilateError(err) {\n    const reason = err.reason;\n    // Special message for a case that is likely due to IP whitelisting issues.\n    const isAtlasWhitelistError = isAtlas(reason) &&\n      allServersUnknown(reason) &&\n      err.message.indexOf('bad auth') === -1 &&\n      err.message.indexOf('Authentication failed') === -1;\n\n    if (isAtlasWhitelistError) {\n      this.message = atlasMessage;\n    } else if (isSSLError(reason)) {\n      this.message = sslMessage;\n    } else {\n      this.message = err.message;\n    }\n    for (const key in err) {\n      if (key !== 'name') {\n        this[key] = err[key];\n      }\n    }\n\n    return this;\n  }\n}\n\nObject.defineProperty(MongooseServerSelectionError.prototype, 'name', {\n  value: 'MongooseServerSelectionError'\n});\n\nmodule.exports = MongooseServerSelectionError;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbW9uZ29vc2UvbGliL2Vycm9yL3NlcnZlclNlbGVjdGlvbi5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7O0FBRWE7O0FBRWIsc0JBQXNCLG1CQUFPLENBQUMsaUZBQWlCO0FBQy9DLDBCQUEwQixtQkFBTyxDQUFDLHNIQUF1QztBQUN6RSxnQkFBZ0IsbUJBQU8sQ0FBQyxrR0FBNkI7QUFDckQsbUJBQW1CLG1CQUFPLENBQUMsd0dBQWdDOztBQUUzRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLENBQUM7O0FBRUQiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9hcHAxLy4vbm9kZV9tb2R1bGVzL21vbmdvb3NlL2xpYi9lcnJvci9zZXJ2ZXJTZWxlY3Rpb24uanM/YThmNiJdLCJzb3VyY2VzQ29udGVudCI6WyIvKiFcbiAqIE1vZHVsZSBkZXBlbmRlbmNpZXMuXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG5jb25zdCBNb25nb29zZUVycm9yID0gcmVxdWlyZSgnLi9tb25nb29zZUVycm9yJyk7XG5jb25zdCBhbGxTZXJ2ZXJzVW5rbm93biA9IHJlcXVpcmUoJy4uL2hlbHBlcnMvdG9wb2xvZ3kvYWxsU2VydmVyc1Vua25vd24nKTtcbmNvbnN0IGlzQXRsYXMgPSByZXF1aXJlKCcuLi9oZWxwZXJzL3RvcG9sb2d5L2lzQXRsYXMnKTtcbmNvbnN0IGlzU1NMRXJyb3IgPSByZXF1aXJlKCcuLi9oZWxwZXJzL3RvcG9sb2d5L2lzU1NMRXJyb3InKTtcblxuLyohXG4gKiBpZ25vcmVcbiAqL1xuXG5jb25zdCBhdGxhc01lc3NhZ2UgPSAnQ291bGQgbm90IGNvbm5lY3QgdG8gYW55IHNlcnZlcnMgaW4geW91ciBNb25nb0RCIEF0bGFzIGNsdXN0ZXIuICcgK1xuICAnT25lIGNvbW1vbiByZWFzb24gaXMgdGhhdCB5b3VcXCdyZSB0cnlpbmcgdG8gYWNjZXNzIHRoZSBkYXRhYmFzZSBmcm9tICcgK1xuICAnYW4gSVAgdGhhdCBpc25cXCd0IHdoaXRlbGlzdGVkLiBNYWtlIHN1cmUgeW91ciBjdXJyZW50IElQIGFkZHJlc3MgaXMgb24geW91ciBBdGxhcyAnICtcbiAgJ2NsdXN0ZXJcXCdzIElQIHdoaXRlbGlzdDogaHR0cHM6Ly93d3cubW9uZ29kYi5jb20vZG9jcy9hdGxhcy9zZWN1cml0eS13aGl0ZWxpc3QvJztcblxuY29uc3Qgc3NsTWVzc2FnZSA9ICdNb25nb29zZSBpcyBjb25uZWN0aW5nIHdpdGggU1NMIGVuYWJsZWQsIGJ1dCB0aGUgc2VydmVyIGlzICcgK1xuICAnbm90IGFjY2VwdGluZyBTU0wgY29ubmVjdGlvbnMuIFBsZWFzZSBlbnN1cmUgdGhhdCB0aGUgTW9uZ29EQiBzZXJ2ZXIgeW91IGFyZSAnICtcbiAgJ2Nvbm5lY3RpbmcgdG8gaXMgY29uZmlndXJlZCB0byBhY2NlcHQgU1NMIGNvbm5lY3Rpb25zLiBMZWFybiBtb3JlOiAnICtcbiAgJ2h0dHBzOi8vbW9uZ29vc2Vqcy5jb20vZG9jcy90dXRvcmlhbHMvc3NsLmh0bWwnO1xuXG5jbGFzcyBNb25nb29zZVNlcnZlclNlbGVjdGlvbkVycm9yIGV4dGVuZHMgTW9uZ29vc2VFcnJvciB7XG4gIC8qKlxuICAgKiBNb25nb29zZVNlcnZlclNlbGVjdGlvbkVycm9yIGNvbnN0cnVjdG9yXG4gICAqXG4gICAqIEBhcGkgcHJpdmF0ZVxuICAgKi9cbiAgYXNzaW1pbGF0ZUVycm9yKGVycikge1xuICAgIGNvbnN0IHJlYXNvbiA9IGVyci5yZWFzb247XG4gICAgLy8gU3BlY2lhbCBtZXNzYWdlIGZvciBhIGNhc2UgdGhhdCBpcyBsaWtlbHkgZHVlIHRvIElQIHdoaXRlbGlzdGluZyBpc3N1ZXMuXG4gICAgY29uc3QgaXNBdGxhc1doaXRlbGlzdEVycm9yID0gaXNBdGxhcyhyZWFzb24pICYmXG4gICAgICBhbGxTZXJ2ZXJzVW5rbm93bihyZWFzb24pICYmXG4gICAgICBlcnIubWVzc2FnZS5pbmRleE9mKCdiYWQgYXV0aCcpID09PSAtMSAmJlxuICAgICAgZXJyLm1lc3NhZ2UuaW5kZXhPZignQXV0aGVudGljYXRpb24gZmFpbGVkJykgPT09IC0xO1xuXG4gICAgaWYgKGlzQXRsYXNXaGl0ZWxpc3RFcnJvcikge1xuICAgICAgdGhpcy5tZXNzYWdlID0gYXRsYXNNZXNzYWdlO1xuICAgIH0gZWxzZSBpZiAoaXNTU0xFcnJvcihyZWFzb24pKSB7XG4gICAgICB0aGlzLm1lc3NhZ2UgPSBzc2xNZXNzYWdlO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLm1lc3NhZ2UgPSBlcnIubWVzc2FnZTtcbiAgICB9XG4gICAgZm9yIChjb25zdCBrZXkgaW4gZXJyKSB7XG4gICAgICBpZiAoa2V5ICE9PSAnbmFtZScpIHtcbiAgICAgICAgdGhpc1trZXldID0gZXJyW2tleV07XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbn1cblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KE1vbmdvb3NlU2VydmVyU2VsZWN0aW9uRXJyb3IucHJvdG90eXBlLCAnbmFtZScsIHtcbiAgdmFsdWU6ICdNb25nb29zZVNlcnZlclNlbGVjdGlvbkVycm9yJ1xufSk7XG5cbm1vZHVsZS5leHBvcnRzID0gTW9uZ29vc2VTZXJ2ZXJTZWxlY3Rpb25FcnJvcjtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/mongoose/lib/error/serverSelection.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/mongoose/lib/error/setOptionError.js":
/*!***********************************************************!*\
  !*** ./node_modules/mongoose/lib/error/setOptionError.js ***!
  \***********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("/*!\n * Module requirements\n */\n\n\n\nconst MongooseError = __webpack_require__(/*! ./mongooseError */ \"(ssr)/./node_modules/mongoose/lib/error/mongooseError.js\");\nconst util = __webpack_require__(/*! util */ \"util\");\nconst combinePathErrors = __webpack_require__(/*! ../helpers/error/combinePathErrors */ \"(ssr)/./node_modules/mongoose/lib/helpers/error/combinePathErrors.js\");\n\nclass SetOptionError extends MongooseError {\n  /**\n   * Mongoose.set Error\n   *\n   * @api private\n   * @inherits MongooseError\n   */\n  constructor() {\n    super('');\n\n    this.errors = {};\n  }\n\n  /**\n   * Console.log helper\n   */\n  toString() {\n    return combinePathErrors(this);\n  }\n\n  /**\n   * inspect helper\n   * @api private\n   */\n  inspect() {\n    return Object.assign(new Error(this.message), this);\n  }\n\n  /**\n  * add message\n  * @param {String} key\n  * @param {String|Error} error\n  * @api private\n  */\n  addError(key, error) {\n    if (error instanceof SetOptionError) {\n      const { errors } = error;\n      for (const optionKey of Object.keys(errors)) {\n        this.addError(optionKey, errors[optionKey]);\n      }\n\n      return;\n    }\n\n    this.errors[key] = error;\n    this.message = combinePathErrors(this);\n  }\n}\n\n\nif (util.inspect.custom) {\n  // Avoid Node deprecation warning DEP0079\n  SetOptionError.prototype[util.inspect.custom] = SetOptionError.prototype.inspect;\n}\n\n/**\n * Helper for JSON.stringify\n * Ensure `name` and `message` show up in toJSON output re: gh-9847\n * @api private\n */\nObject.defineProperty(SetOptionError.prototype, 'toJSON', {\n  enumerable: false,\n  writable: false,\n  configurable: true,\n  value: function() {\n    return Object.assign({}, this, { name: this.name, message: this.message });\n  }\n});\n\n\nObject.defineProperty(SetOptionError.prototype, 'name', {\n  value: 'SetOptionError'\n});\n\nclass SetOptionInnerError extends MongooseError {\n  /**\n   * Error for the \"errors\" array in \"SetOptionError\" with consistent message\n   * @param {String} key\n   */\n  constructor(key) {\n    super(`\"${key}\" is not a valid option to set`);\n  }\n}\n\nSetOptionError.SetOptionInnerError = SetOptionInnerError;\n\n/*!\n * Module exports\n */\n\nmodule.exports = SetOptionError;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbW9uZ29vc2UvbGliL2Vycm9yL3NldE9wdGlvbkVycm9yLmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTs7QUFFYTs7QUFFYixzQkFBc0IsbUJBQU8sQ0FBQyxpRkFBaUI7QUFDL0MsYUFBYSxtQkFBTyxDQUFDLGtCQUFNO0FBQzNCLDBCQUEwQixtQkFBTyxDQUFDLGdIQUFvQzs7QUFFdEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxZQUFZLFFBQVE7QUFDcEIsWUFBWSxjQUFjO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxTQUFTO0FBQ3ZCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQixVQUFVLHdDQUF3QztBQUM3RTtBQUNBLENBQUM7OztBQUdEO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBLGFBQWEsUUFBUTtBQUNyQjtBQUNBO0FBQ0EsY0FBYyxJQUFJO0FBQ2xCO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vYXBwMS8uL25vZGVfbW9kdWxlcy9tb25nb29zZS9saWIvZXJyb3Ivc2V0T3B0aW9uRXJyb3IuanM/YTU5YyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKiFcbiAqIE1vZHVsZSByZXF1aXJlbWVudHNcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbmNvbnN0IE1vbmdvb3NlRXJyb3IgPSByZXF1aXJlKCcuL21vbmdvb3NlRXJyb3InKTtcbmNvbnN0IHV0aWwgPSByZXF1aXJlKCd1dGlsJyk7XG5jb25zdCBjb21iaW5lUGF0aEVycm9ycyA9IHJlcXVpcmUoJy4uL2hlbHBlcnMvZXJyb3IvY29tYmluZVBhdGhFcnJvcnMnKTtcblxuY2xhc3MgU2V0T3B0aW9uRXJyb3IgZXh0ZW5kcyBNb25nb29zZUVycm9yIHtcbiAgLyoqXG4gICAqIE1vbmdvb3NlLnNldCBFcnJvclxuICAgKlxuICAgKiBAYXBpIHByaXZhdGVcbiAgICogQGluaGVyaXRzIE1vbmdvb3NlRXJyb3JcbiAgICovXG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKCcnKTtcblxuICAgIHRoaXMuZXJyb3JzID0ge307XG4gIH1cblxuICAvKipcbiAgICogQ29uc29sZS5sb2cgaGVscGVyXG4gICAqL1xuICB0b1N0cmluZygpIHtcbiAgICByZXR1cm4gY29tYmluZVBhdGhFcnJvcnModGhpcyk7XG4gIH1cblxuICAvKipcbiAgICogaW5zcGVjdCBoZWxwZXJcbiAgICogQGFwaSBwcml2YXRlXG4gICAqL1xuICBpbnNwZWN0KCkge1xuICAgIHJldHVybiBPYmplY3QuYXNzaWduKG5ldyBFcnJvcih0aGlzLm1lc3NhZ2UpLCB0aGlzKTtcbiAgfVxuXG4gIC8qKlxuICAqIGFkZCBtZXNzYWdlXG4gICogQHBhcmFtIHtTdHJpbmd9IGtleVxuICAqIEBwYXJhbSB7U3RyaW5nfEVycm9yfSBlcnJvclxuICAqIEBhcGkgcHJpdmF0ZVxuICAqL1xuICBhZGRFcnJvcihrZXksIGVycm9yKSB7XG4gICAgaWYgKGVycm9yIGluc3RhbmNlb2YgU2V0T3B0aW9uRXJyb3IpIHtcbiAgICAgIGNvbnN0IHsgZXJyb3JzIH0gPSBlcnJvcjtcbiAgICAgIGZvciAoY29uc3Qgb3B0aW9uS2V5IG9mIE9iamVjdC5rZXlzKGVycm9ycykpIHtcbiAgICAgICAgdGhpcy5hZGRFcnJvcihvcHRpb25LZXksIGVycm9yc1tvcHRpb25LZXldKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHRoaXMuZXJyb3JzW2tleV0gPSBlcnJvcjtcbiAgICB0aGlzLm1lc3NhZ2UgPSBjb21iaW5lUGF0aEVycm9ycyh0aGlzKTtcbiAgfVxufVxuXG5cbmlmICh1dGlsLmluc3BlY3QuY3VzdG9tKSB7XG4gIC8vIEF2b2lkIE5vZGUgZGVwcmVjYXRpb24gd2FybmluZyBERVAwMDc5XG4gIFNldE9wdGlvbkVycm9yLnByb3RvdHlwZVt1dGlsLmluc3BlY3QuY3VzdG9tXSA9IFNldE9wdGlvbkVycm9yLnByb3RvdHlwZS5pbnNwZWN0O1xufVxuXG4vKipcbiAqIEhlbHBlciBmb3IgSlNPTi5zdHJpbmdpZnlcbiAqIEVuc3VyZSBgbmFtZWAgYW5kIGBtZXNzYWdlYCBzaG93IHVwIGluIHRvSlNPTiBvdXRwdXQgcmU6IGdoLTk4NDdcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoU2V0T3B0aW9uRXJyb3IucHJvdG90eXBlLCAndG9KU09OJywge1xuICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgd3JpdGFibGU6IGZhbHNlLFxuICBjb25maWd1cmFibGU6IHRydWUsXG4gIHZhbHVlOiBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gT2JqZWN0LmFzc2lnbih7fSwgdGhpcywgeyBuYW1lOiB0aGlzLm5hbWUsIG1lc3NhZ2U6IHRoaXMubWVzc2FnZSB9KTtcbiAgfVxufSk7XG5cblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KFNldE9wdGlvbkVycm9yLnByb3RvdHlwZSwgJ25hbWUnLCB7XG4gIHZhbHVlOiAnU2V0T3B0aW9uRXJyb3InXG59KTtcblxuY2xhc3MgU2V0T3B0aW9uSW5uZXJFcnJvciBleHRlbmRzIE1vbmdvb3NlRXJyb3Ige1xuICAvKipcbiAgICogRXJyb3IgZm9yIHRoZSBcImVycm9yc1wiIGFycmF5IGluIFwiU2V0T3B0aW9uRXJyb3JcIiB3aXRoIGNvbnNpc3RlbnQgbWVzc2FnZVxuICAgKiBAcGFyYW0ge1N0cmluZ30ga2V5XG4gICAqL1xuICBjb25zdHJ1Y3RvcihrZXkpIHtcbiAgICBzdXBlcihgXCIke2tleX1cIiBpcyBub3QgYSB2YWxpZCBvcHRpb24gdG8gc2V0YCk7XG4gIH1cbn1cblxuU2V0T3B0aW9uRXJyb3IuU2V0T3B0aW9uSW5uZXJFcnJvciA9IFNldE9wdGlvbklubmVyRXJyb3I7XG5cbi8qIVxuICogTW9kdWxlIGV4cG9ydHNcbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IFNldE9wdGlvbkVycm9yO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/mongoose/lib/error/setOptionError.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/mongoose/lib/error/strict.js":
/*!***************************************************!*\
  !*** ./node_modules/mongoose/lib/error/strict.js ***!
  \***************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("/*!\n * Module dependencies.\n */\n\n\n\nconst MongooseError = __webpack_require__(/*! ./ */ \"(ssr)/./node_modules/mongoose/lib/error/index.js\");\n\n\nclass StrictModeError extends MongooseError {\n  /**\n   * Strict mode error constructor\n   *\n   * @param {String} path\n   * @param {String} [msg]\n   * @param {Boolean} [immutable]\n   * @inherits MongooseError\n   * @api private\n   */\n  constructor(path, msg, immutable) {\n    msg = msg || 'Field `' + path + '` is not in schema and strict ' +\n      'mode is set to throw.';\n    super(msg);\n    this.isImmutableError = !!immutable;\n    this.path = path;\n  }\n}\n\nObject.defineProperty(StrictModeError.prototype, 'name', {\n  value: 'StrictModeError'\n});\n\nmodule.exports = StrictModeError;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbW9uZ29vc2UvbGliL2Vycm9yL3N0cmljdC5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7O0FBRWE7O0FBRWIsc0JBQXNCLG1CQUFPLENBQUMsNERBQUk7OztBQUdsQztBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsUUFBUTtBQUNyQixhQUFhLFFBQVE7QUFDckIsYUFBYSxTQUFTO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLENBQUM7O0FBRUQiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9hcHAxLy4vbm9kZV9tb2R1bGVzL21vbmdvb3NlL2xpYi9lcnJvci9zdHJpY3QuanM/ZjRlYSJdLCJzb3VyY2VzQ29udGVudCI6WyIvKiFcbiAqIE1vZHVsZSBkZXBlbmRlbmNpZXMuXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG5jb25zdCBNb25nb29zZUVycm9yID0gcmVxdWlyZSgnLi8nKTtcblxuXG5jbGFzcyBTdHJpY3RNb2RlRXJyb3IgZXh0ZW5kcyBNb25nb29zZUVycm9yIHtcbiAgLyoqXG4gICAqIFN0cmljdCBtb2RlIGVycm9yIGNvbnN0cnVjdG9yXG4gICAqXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBwYXRoXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBbbXNnXVxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtpbW11dGFibGVdXG4gICAqIEBpbmhlcml0cyBNb25nb29zZUVycm9yXG4gICAqIEBhcGkgcHJpdmF0ZVxuICAgKi9cbiAgY29uc3RydWN0b3IocGF0aCwgbXNnLCBpbW11dGFibGUpIHtcbiAgICBtc2cgPSBtc2cgfHwgJ0ZpZWxkIGAnICsgcGF0aCArICdgIGlzIG5vdCBpbiBzY2hlbWEgYW5kIHN0cmljdCAnICtcbiAgICAgICdtb2RlIGlzIHNldCB0byB0aHJvdy4nO1xuICAgIHN1cGVyKG1zZyk7XG4gICAgdGhpcy5pc0ltbXV0YWJsZUVycm9yID0gISFpbW11dGFibGU7XG4gICAgdGhpcy5wYXRoID0gcGF0aDtcbiAgfVxufVxuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoU3RyaWN0TW9kZUVycm9yLnByb3RvdHlwZSwgJ25hbWUnLCB7XG4gIHZhbHVlOiAnU3RyaWN0TW9kZUVycm9yJ1xufSk7XG5cbm1vZHVsZS5leHBvcnRzID0gU3RyaWN0TW9kZUVycm9yO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/mongoose/lib/error/strict.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/mongoose/lib/error/strictPopulate.js":
/*!***********************************************************!*\
  !*** ./node_modules/mongoose/lib/error/strictPopulate.js ***!
  \***********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("/*!\n * Module dependencies.\n */\n\n\n\nconst MongooseError = __webpack_require__(/*! ./ */ \"(ssr)/./node_modules/mongoose/lib/error/index.js\");\n\nclass StrictPopulateError extends MongooseError {\n  /**\n   * Strict mode error constructor\n   *\n   * @param {String} path\n   * @param {String} [msg]\n   * @inherits MongooseError\n   * @api private\n   */\n  constructor(path, msg) {\n    msg = msg || 'Cannot populate path `' + path + '` because it is not in your schema. ' + 'Set the `strictPopulate` option to false to override.';\n    super(msg);\n    this.path = path;\n  }\n}\n\nObject.defineProperty(StrictPopulateError.prototype, 'name', {\n  value: 'StrictPopulateError'\n});\n\nmodule.exports = StrictPopulateError;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbW9uZ29vc2UvbGliL2Vycm9yL3N0cmljdFBvcHVsYXRlLmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTs7QUFFYTs7QUFFYixzQkFBc0IsbUJBQU8sQ0FBQyw0REFBSTs7QUFFbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFFBQVE7QUFDckIsYUFBYSxRQUFRO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRCIsInNvdXJjZXMiOlsid2VicGFjazovL2FwcDEvLi9ub2RlX21vZHVsZXMvbW9uZ29vc2UvbGliL2Vycm9yL3N0cmljdFBvcHVsYXRlLmpzP2VjOTciXSwic291cmNlc0NvbnRlbnQiOlsiLyohXG4gKiBNb2R1bGUgZGVwZW5kZW5jaWVzLlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxuY29uc3QgTW9uZ29vc2VFcnJvciA9IHJlcXVpcmUoJy4vJyk7XG5cbmNsYXNzIFN0cmljdFBvcHVsYXRlRXJyb3IgZXh0ZW5kcyBNb25nb29zZUVycm9yIHtcbiAgLyoqXG4gICAqIFN0cmljdCBtb2RlIGVycm9yIGNvbnN0cnVjdG9yXG4gICAqXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBwYXRoXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBbbXNnXVxuICAgKiBAaW5oZXJpdHMgTW9uZ29vc2VFcnJvclxuICAgKiBAYXBpIHByaXZhdGVcbiAgICovXG4gIGNvbnN0cnVjdG9yKHBhdGgsIG1zZykge1xuICAgIG1zZyA9IG1zZyB8fCAnQ2Fubm90IHBvcHVsYXRlIHBhdGggYCcgKyBwYXRoICsgJ2AgYmVjYXVzZSBpdCBpcyBub3QgaW4geW91ciBzY2hlbWEuICcgKyAnU2V0IHRoZSBgc3RyaWN0UG9wdWxhdGVgIG9wdGlvbiB0byBmYWxzZSB0byBvdmVycmlkZS4nO1xuICAgIHN1cGVyKG1zZyk7XG4gICAgdGhpcy5wYXRoID0gcGF0aDtcbiAgfVxufVxuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoU3RyaWN0UG9wdWxhdGVFcnJvci5wcm90b3R5cGUsICduYW1lJywge1xuICB2YWx1ZTogJ1N0cmljdFBvcHVsYXRlRXJyb3InXG59KTtcblxubW9kdWxlLmV4cG9ydHMgPSBTdHJpY3RQb3B1bGF0ZUVycm9yO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/mongoose/lib/error/strictPopulate.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/mongoose/lib/error/syncIndexes.js":
/*!********************************************************!*\
  !*** ./node_modules/mongoose/lib/error/syncIndexes.js ***!
  \********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\n\n/*!\n * Module dependencies.\n */\n\nconst MongooseError = __webpack_require__(/*! ./mongooseError */ \"(ssr)/./node_modules/mongoose/lib/error/mongooseError.js\");\n\n/**\n * SyncIndexes Error constructor.\n *\n * @param {String} message\n * @param {String} errorsMap\n * @inherits MongooseError\n * @api private\n */\n\nclass SyncIndexesError extends MongooseError {\n  constructor(message, errorsMap) {\n    super(message);\n    this.errors = errorsMap;\n  }\n}\n\nObject.defineProperty(SyncIndexesError.prototype, 'name', {\n  value: 'SyncIndexesError'\n});\n\n\nmodule.exports = SyncIndexesError;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbW9uZ29vc2UvbGliL2Vycm9yL3N5bmNJbmRleGVzLmpzIiwibWFwcGluZ3MiOiJBQUFhOztBQUViO0FBQ0E7QUFDQTs7QUFFQSxzQkFBc0IsbUJBQU8sQ0FBQyxpRkFBaUI7O0FBRS9DO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsQ0FBQzs7O0FBR0QiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9hcHAxLy4vbm9kZV9tb2R1bGVzL21vbmdvb3NlL2xpYi9lcnJvci9zeW5jSW5kZXhlcy5qcz8xMGY0Il0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxuLyohXG4gKiBNb2R1bGUgZGVwZW5kZW5jaWVzLlxuICovXG5cbmNvbnN0IE1vbmdvb3NlRXJyb3IgPSByZXF1aXJlKCcuL21vbmdvb3NlRXJyb3InKTtcblxuLyoqXG4gKiBTeW5jSW5kZXhlcyBFcnJvciBjb25zdHJ1Y3Rvci5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gbWVzc2FnZVxuICogQHBhcmFtIHtTdHJpbmd9IGVycm9yc01hcFxuICogQGluaGVyaXRzIE1vbmdvb3NlRXJyb3JcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmNsYXNzIFN5bmNJbmRleGVzRXJyb3IgZXh0ZW5kcyBNb25nb29zZUVycm9yIHtcbiAgY29uc3RydWN0b3IobWVzc2FnZSwgZXJyb3JzTWFwKSB7XG4gICAgc3VwZXIobWVzc2FnZSk7XG4gICAgdGhpcy5lcnJvcnMgPSBlcnJvcnNNYXA7XG4gIH1cbn1cblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KFN5bmNJbmRleGVzRXJyb3IucHJvdG90eXBlLCAnbmFtZScsIHtcbiAgdmFsdWU6ICdTeW5jSW5kZXhlc0Vycm9yJ1xufSk7XG5cblxubW9kdWxlLmV4cG9ydHMgPSBTeW5jSW5kZXhlc0Vycm9yO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/mongoose/lib/error/syncIndexes.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/mongoose/lib/error/validation.js":
/*!*******************************************************!*\
  !*** ./node_modules/mongoose/lib/error/validation.js ***!
  \*******************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("/*!\n * Module requirements\n */\n\n\n\nconst MongooseError = __webpack_require__(/*! ./mongooseError */ \"(ssr)/./node_modules/mongoose/lib/error/mongooseError.js\");\nconst getConstructorName = __webpack_require__(/*! ../helpers/getConstructorName */ \"(ssr)/./node_modules/mongoose/lib/helpers/getConstructorName.js\");\nconst util = __webpack_require__(/*! util */ \"util\");\nconst combinePathErrors = __webpack_require__(/*! ../helpers/error/combinePathErrors */ \"(ssr)/./node_modules/mongoose/lib/helpers/error/combinePathErrors.js\");\n\nclass ValidationError extends MongooseError {\n  /**\n   * Document Validation Error\n   *\n   * @api private\n   * @param {Document} [instance]\n   * @inherits MongooseError\n   */\n  constructor(instance) {\n    let _message;\n    if (getConstructorName(instance) === 'model') {\n      _message = instance.constructor.modelName + ' validation failed';\n    } else {\n      _message = 'Validation failed';\n    }\n\n    super(_message);\n\n    this.errors = {};\n    this._message = _message;\n\n    if (instance) {\n      instance.$errors = this.errors;\n    }\n  }\n\n  /**\n   * Console.log helper\n   */\n  toString() {\n    return this.name + ': ' + combinePathErrors(this);\n  }\n\n  /**\n   * inspect helper\n   * @api private\n   */\n  inspect() {\n    return Object.assign(new Error(this.message), this);\n  }\n\n  /**\n  * add message\n  * @param {String} path\n  * @param {String|Error} error\n  * @api private\n  */\n  addError(path, error) {\n    if (error instanceof ValidationError) {\n      const { errors } = error;\n      for (const errorPath of Object.keys(errors)) {\n        this.addError(`${path}.${errorPath}`, errors[errorPath]);\n      }\n\n      return;\n    }\n\n    this.errors[path] = error;\n    this.message = this._message + ': ' + combinePathErrors(this);\n  }\n}\n\n\nif (util.inspect.custom) {\n  // Avoid Node deprecation warning DEP0079\n  ValidationError.prototype[util.inspect.custom] = ValidationError.prototype.inspect;\n}\n\n/**\n * Helper for JSON.stringify\n * Ensure `name` and `message` show up in toJSON output re: gh-9847\n * @api private\n */\nObject.defineProperty(ValidationError.prototype, 'toJSON', {\n  enumerable: false,\n  writable: false,\n  configurable: true,\n  value: function() {\n    return Object.assign({}, this, { name: this.name, message: this.message });\n  }\n});\n\n\nObject.defineProperty(ValidationError.prototype, 'name', {\n  value: 'ValidationError'\n});\n\n/*!\n * Module exports\n */\n\nmodule.exports = ValidationError;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbW9uZ29vc2UvbGliL2Vycm9yL3ZhbGlkYXRpb24uanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBOztBQUVhOztBQUViLHNCQUFzQixtQkFBTyxDQUFDLGlGQUFpQjtBQUMvQywyQkFBMkIsbUJBQU8sQ0FBQyxzR0FBK0I7QUFDbEUsYUFBYSxtQkFBTyxDQUFDLGtCQUFNO0FBQzNCLDBCQUEwQixtQkFBTyxDQUFDLGdIQUFvQzs7QUFFdEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsVUFBVTtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsWUFBWSxRQUFRO0FBQ3BCLFlBQVksY0FBYztBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsU0FBUztBQUN2QjtBQUNBLHlCQUF5QixLQUFLLEdBQUcsVUFBVTtBQUMzQzs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQixVQUFVLHdDQUF3QztBQUM3RTtBQUNBLENBQUM7OztBQUdEO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTs7QUFFQSIsInNvdXJjZXMiOlsid2VicGFjazovL2FwcDEvLi9ub2RlX21vZHVsZXMvbW9uZ29vc2UvbGliL2Vycm9yL3ZhbGlkYXRpb24uanM/MDM2YiJdLCJzb3VyY2VzQ29udGVudCI6WyIvKiFcbiAqIE1vZHVsZSByZXF1aXJlbWVudHNcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbmNvbnN0IE1vbmdvb3NlRXJyb3IgPSByZXF1aXJlKCcuL21vbmdvb3NlRXJyb3InKTtcbmNvbnN0IGdldENvbnN0cnVjdG9yTmFtZSA9IHJlcXVpcmUoJy4uL2hlbHBlcnMvZ2V0Q29uc3RydWN0b3JOYW1lJyk7XG5jb25zdCB1dGlsID0gcmVxdWlyZSgndXRpbCcpO1xuY29uc3QgY29tYmluZVBhdGhFcnJvcnMgPSByZXF1aXJlKCcuLi9oZWxwZXJzL2Vycm9yL2NvbWJpbmVQYXRoRXJyb3JzJyk7XG5cbmNsYXNzIFZhbGlkYXRpb25FcnJvciBleHRlbmRzIE1vbmdvb3NlRXJyb3Ige1xuICAvKipcbiAgICogRG9jdW1lbnQgVmFsaWRhdGlvbiBFcnJvclxuICAgKlxuICAgKiBAYXBpIHByaXZhdGVcbiAgICogQHBhcmFtIHtEb2N1bWVudH0gW2luc3RhbmNlXVxuICAgKiBAaW5oZXJpdHMgTW9uZ29vc2VFcnJvclxuICAgKi9cbiAgY29uc3RydWN0b3IoaW5zdGFuY2UpIHtcbiAgICBsZXQgX21lc3NhZ2U7XG4gICAgaWYgKGdldENvbnN0cnVjdG9yTmFtZShpbnN0YW5jZSkgPT09ICdtb2RlbCcpIHtcbiAgICAgIF9tZXNzYWdlID0gaW5zdGFuY2UuY29uc3RydWN0b3IubW9kZWxOYW1lICsgJyB2YWxpZGF0aW9uIGZhaWxlZCc7XG4gICAgfSBlbHNlIHtcbiAgICAgIF9tZXNzYWdlID0gJ1ZhbGlkYXRpb24gZmFpbGVkJztcbiAgICB9XG5cbiAgICBzdXBlcihfbWVzc2FnZSk7XG5cbiAgICB0aGlzLmVycm9ycyA9IHt9O1xuICAgIHRoaXMuX21lc3NhZ2UgPSBfbWVzc2FnZTtcblxuICAgIGlmIChpbnN0YW5jZSkge1xuICAgICAgaW5zdGFuY2UuJGVycm9ycyA9IHRoaXMuZXJyb3JzO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBDb25zb2xlLmxvZyBoZWxwZXJcbiAgICovXG4gIHRvU3RyaW5nKCkge1xuICAgIHJldHVybiB0aGlzLm5hbWUgKyAnOiAnICsgY29tYmluZVBhdGhFcnJvcnModGhpcyk7XG4gIH1cblxuICAvKipcbiAgICogaW5zcGVjdCBoZWxwZXJcbiAgICogQGFwaSBwcml2YXRlXG4gICAqL1xuICBpbnNwZWN0KCkge1xuICAgIHJldHVybiBPYmplY3QuYXNzaWduKG5ldyBFcnJvcih0aGlzLm1lc3NhZ2UpLCB0aGlzKTtcbiAgfVxuXG4gIC8qKlxuICAqIGFkZCBtZXNzYWdlXG4gICogQHBhcmFtIHtTdHJpbmd9IHBhdGhcbiAgKiBAcGFyYW0ge1N0cmluZ3xFcnJvcn0gZXJyb3JcbiAgKiBAYXBpIHByaXZhdGVcbiAgKi9cbiAgYWRkRXJyb3IocGF0aCwgZXJyb3IpIHtcbiAgICBpZiAoZXJyb3IgaW5zdGFuY2VvZiBWYWxpZGF0aW9uRXJyb3IpIHtcbiAgICAgIGNvbnN0IHsgZXJyb3JzIH0gPSBlcnJvcjtcbiAgICAgIGZvciAoY29uc3QgZXJyb3JQYXRoIG9mIE9iamVjdC5rZXlzKGVycm9ycykpIHtcbiAgICAgICAgdGhpcy5hZGRFcnJvcihgJHtwYXRofS4ke2Vycm9yUGF0aH1gLCBlcnJvcnNbZXJyb3JQYXRoXSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB0aGlzLmVycm9yc1twYXRoXSA9IGVycm9yO1xuICAgIHRoaXMubWVzc2FnZSA9IHRoaXMuX21lc3NhZ2UgKyAnOiAnICsgY29tYmluZVBhdGhFcnJvcnModGhpcyk7XG4gIH1cbn1cblxuXG5pZiAodXRpbC5pbnNwZWN0LmN1c3RvbSkge1xuICAvLyBBdm9pZCBOb2RlIGRlcHJlY2F0aW9uIHdhcm5pbmcgREVQMDA3OVxuICBWYWxpZGF0aW9uRXJyb3IucHJvdG90eXBlW3V0aWwuaW5zcGVjdC5jdXN0b21dID0gVmFsaWRhdGlvbkVycm9yLnByb3RvdHlwZS5pbnNwZWN0O1xufVxuXG4vKipcbiAqIEhlbHBlciBmb3IgSlNPTi5zdHJpbmdpZnlcbiAqIEVuc3VyZSBgbmFtZWAgYW5kIGBtZXNzYWdlYCBzaG93IHVwIGluIHRvSlNPTiBvdXRwdXQgcmU6IGdoLTk4NDdcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoVmFsaWRhdGlvbkVycm9yLnByb3RvdHlwZSwgJ3RvSlNPTicsIHtcbiAgZW51bWVyYWJsZTogZmFsc2UsXG4gIHdyaXRhYmxlOiBmYWxzZSxcbiAgY29uZmlndXJhYmxlOiB0cnVlLFxuICB2YWx1ZTogZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIE9iamVjdC5hc3NpZ24oe30sIHRoaXMsIHsgbmFtZTogdGhpcy5uYW1lLCBtZXNzYWdlOiB0aGlzLm1lc3NhZ2UgfSk7XG4gIH1cbn0pO1xuXG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShWYWxpZGF0aW9uRXJyb3IucHJvdG90eXBlLCAnbmFtZScsIHtcbiAgdmFsdWU6ICdWYWxpZGF0aW9uRXJyb3InXG59KTtcblxuLyohXG4gKiBNb2R1bGUgZXhwb3J0c1xuICovXG5cbm1vZHVsZS5leHBvcnRzID0gVmFsaWRhdGlvbkVycm9yO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/mongoose/lib/error/validation.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/mongoose/lib/error/validator.js":
/*!******************************************************!*\
  !*** ./node_modules/mongoose/lib/error/validator.js ***!
  \******************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("/*!\n * Module dependencies.\n */\n\n\n\nconst MongooseError = __webpack_require__(/*! ./ */ \"(ssr)/./node_modules/mongoose/lib/error/index.js\");\n\n\nclass ValidatorError extends MongooseError {\n  /**\n   * Schema validator error\n   *\n   * @param {Object} properties\n   * @param {Document} doc\n   * @api private\n   */\n  constructor(properties, doc) {\n    let msg = properties.message;\n    if (!msg) {\n      msg = MongooseError.messages.general.default;\n    }\n\n    const message = formatMessage(msg, properties, doc);\n    super(message);\n\n    properties = Object.assign({}, properties, { message: message });\n    this.properties = properties;\n    this.kind = properties.type;\n    this.path = properties.path;\n    this.value = properties.value;\n    this.reason = properties.reason;\n  }\n\n  /**\n   * toString helper\n   * TODO remove? This defaults to `${this.name}: ${this.message}`\n   * @api private\n   */\n  toString() {\n    return this.message;\n  }\n\n  /**\n   * Ensure `name` and `message` show up in toJSON output re: gh-9296\n   * @api private\n   */\n\n  toJSON() {\n    return Object.assign({ name: this.name, message: this.message }, this);\n  }\n}\n\n\nObject.defineProperty(ValidatorError.prototype, 'name', {\n  value: 'ValidatorError'\n});\n\n/**\n * The object used to define this validator. Not enumerable to hide\n * it from `require('util').inspect()` output re: gh-3925\n * @api private\n */\n\nObject.defineProperty(ValidatorError.prototype, 'properties', {\n  enumerable: false,\n  writable: true,\n  value: null\n});\n\n// Exposed for testing\nValidatorError.prototype.formatMessage = formatMessage;\n\n/**\n * Formats error messages\n * @api private\n */\n\nfunction formatMessage(msg, properties, doc) {\n  if (typeof msg === 'function') {\n    return msg(properties, doc);\n  }\n\n  const propertyNames = Object.keys(properties);\n  for (const propertyName of propertyNames) {\n    if (propertyName === 'message') {\n      continue;\n    }\n    msg = msg.replace('{' + propertyName.toUpperCase() + '}', properties[propertyName]);\n  }\n\n  return msg;\n}\n\n/*!\n * exports\n */\n\nmodule.exports = ValidatorError;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbW9uZ29vc2UvbGliL2Vycm9yL3ZhbGlkYXRvci5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7O0FBRWE7O0FBRWIsc0JBQXNCLG1CQUFPLENBQUMsNERBQUk7OztBQUdsQztBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsUUFBUTtBQUNyQixhQUFhLFVBQVU7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxpQ0FBaUMsZ0JBQWdCLGtCQUFrQjtBQUNuRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHNDQUFzQyxVQUFVLElBQUksYUFBYTtBQUNqRTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsMkJBQTJCLHdDQUF3QztBQUNuRTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsbUNBQW1DO0FBQzNEOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vYXBwMS8uL25vZGVfbW9kdWxlcy9tb25nb29zZS9saWIvZXJyb3IvdmFsaWRhdG9yLmpzP2EzOTIiXSwic291cmNlc0NvbnRlbnQiOlsiLyohXG4gKiBNb2R1bGUgZGVwZW5kZW5jaWVzLlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxuY29uc3QgTW9uZ29vc2VFcnJvciA9IHJlcXVpcmUoJy4vJyk7XG5cblxuY2xhc3MgVmFsaWRhdG9yRXJyb3IgZXh0ZW5kcyBNb25nb29zZUVycm9yIHtcbiAgLyoqXG4gICAqIFNjaGVtYSB2YWxpZGF0b3IgZXJyb3JcbiAgICpcbiAgICogQHBhcmFtIHtPYmplY3R9IHByb3BlcnRpZXNcbiAgICogQHBhcmFtIHtEb2N1bWVudH0gZG9jXG4gICAqIEBhcGkgcHJpdmF0ZVxuICAgKi9cbiAgY29uc3RydWN0b3IocHJvcGVydGllcywgZG9jKSB7XG4gICAgbGV0IG1zZyA9IHByb3BlcnRpZXMubWVzc2FnZTtcbiAgICBpZiAoIW1zZykge1xuICAgICAgbXNnID0gTW9uZ29vc2VFcnJvci5tZXNzYWdlcy5nZW5lcmFsLmRlZmF1bHQ7XG4gICAgfVxuXG4gICAgY29uc3QgbWVzc2FnZSA9IGZvcm1hdE1lc3NhZ2UobXNnLCBwcm9wZXJ0aWVzLCBkb2MpO1xuICAgIHN1cGVyKG1lc3NhZ2UpO1xuXG4gICAgcHJvcGVydGllcyA9IE9iamVjdC5hc3NpZ24oe30sIHByb3BlcnRpZXMsIHsgbWVzc2FnZTogbWVzc2FnZSB9KTtcbiAgICB0aGlzLnByb3BlcnRpZXMgPSBwcm9wZXJ0aWVzO1xuICAgIHRoaXMua2luZCA9IHByb3BlcnRpZXMudHlwZTtcbiAgICB0aGlzLnBhdGggPSBwcm9wZXJ0aWVzLnBhdGg7XG4gICAgdGhpcy52YWx1ZSA9IHByb3BlcnRpZXMudmFsdWU7XG4gICAgdGhpcy5yZWFzb24gPSBwcm9wZXJ0aWVzLnJlYXNvbjtcbiAgfVxuXG4gIC8qKlxuICAgKiB0b1N0cmluZyBoZWxwZXJcbiAgICogVE9ETyByZW1vdmU/IFRoaXMgZGVmYXVsdHMgdG8gYCR7dGhpcy5uYW1lfTogJHt0aGlzLm1lc3NhZ2V9YFxuICAgKiBAYXBpIHByaXZhdGVcbiAgICovXG4gIHRvU3RyaW5nKCkge1xuICAgIHJldHVybiB0aGlzLm1lc3NhZ2U7XG4gIH1cblxuICAvKipcbiAgICogRW5zdXJlIGBuYW1lYCBhbmQgYG1lc3NhZ2VgIHNob3cgdXAgaW4gdG9KU09OIG91dHB1dCByZTogZ2gtOTI5NlxuICAgKiBAYXBpIHByaXZhdGVcbiAgICovXG5cbiAgdG9KU09OKCkge1xuICAgIHJldHVybiBPYmplY3QuYXNzaWduKHsgbmFtZTogdGhpcy5uYW1lLCBtZXNzYWdlOiB0aGlzLm1lc3NhZ2UgfSwgdGhpcyk7XG4gIH1cbn1cblxuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoVmFsaWRhdG9yRXJyb3IucHJvdG90eXBlLCAnbmFtZScsIHtcbiAgdmFsdWU6ICdWYWxpZGF0b3JFcnJvcidcbn0pO1xuXG4vKipcbiAqIFRoZSBvYmplY3QgdXNlZCB0byBkZWZpbmUgdGhpcyB2YWxpZGF0b3IuIE5vdCBlbnVtZXJhYmxlIHRvIGhpZGVcbiAqIGl0IGZyb20gYHJlcXVpcmUoJ3V0aWwnKS5pbnNwZWN0KClgIG91dHB1dCByZTogZ2gtMzkyNVxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KFZhbGlkYXRvckVycm9yLnByb3RvdHlwZSwgJ3Byb3BlcnRpZXMnLCB7XG4gIGVudW1lcmFibGU6IGZhbHNlLFxuICB3cml0YWJsZTogdHJ1ZSxcbiAgdmFsdWU6IG51bGxcbn0pO1xuXG4vLyBFeHBvc2VkIGZvciB0ZXN0aW5nXG5WYWxpZGF0b3JFcnJvci5wcm90b3R5cGUuZm9ybWF0TWVzc2FnZSA9IGZvcm1hdE1lc3NhZ2U7XG5cbi8qKlxuICogRm9ybWF0cyBlcnJvciBtZXNzYWdlc1xuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZnVuY3Rpb24gZm9ybWF0TWVzc2FnZShtc2csIHByb3BlcnRpZXMsIGRvYykge1xuICBpZiAodHlwZW9mIG1zZyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHJldHVybiBtc2cocHJvcGVydGllcywgZG9jKTtcbiAgfVxuXG4gIGNvbnN0IHByb3BlcnR5TmFtZXMgPSBPYmplY3Qua2V5cyhwcm9wZXJ0aWVzKTtcbiAgZm9yIChjb25zdCBwcm9wZXJ0eU5hbWUgb2YgcHJvcGVydHlOYW1lcykge1xuICAgIGlmIChwcm9wZXJ0eU5hbWUgPT09ICdtZXNzYWdlJykge1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIG1zZyA9IG1zZy5yZXBsYWNlKCd7JyArIHByb3BlcnR5TmFtZS50b1VwcGVyQ2FzZSgpICsgJ30nLCBwcm9wZXJ0aWVzW3Byb3BlcnR5TmFtZV0pO1xuICB9XG5cbiAgcmV0dXJuIG1zZztcbn1cblxuLyohXG4gKiBleHBvcnRzXG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSBWYWxpZGF0b3JFcnJvcjtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/mongoose/lib/error/validator.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/mongoose/lib/error/version.js":
/*!****************************************************!*\
  !*** ./node_modules/mongoose/lib/error/version.js ***!
  \****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\n\n/*!\n * Module dependencies.\n */\n\nconst MongooseError = __webpack_require__(/*! ./ */ \"(ssr)/./node_modules/mongoose/lib/error/index.js\");\n\nclass VersionError extends MongooseError {\n  /**\n   * Version Error constructor.\n   *\n   * @param {Document} doc\n   * @param {Number} currentVersion\n   * @param {Array<String>} modifiedPaths\n   * @api private\n   */\n  constructor(doc, currentVersion, modifiedPaths) {\n    const modifiedPathsStr = modifiedPaths.join(', ');\n    super('No matching document found for id \"' + doc._id +\n      '\" version ' + currentVersion + ' modifiedPaths \"' + modifiedPathsStr + '\"');\n    this.version = currentVersion;\n    this.modifiedPaths = modifiedPaths;\n  }\n}\n\n\nObject.defineProperty(VersionError.prototype, 'name', {\n  value: 'VersionError'\n});\n\n/*!\n * exports\n */\n\nmodule.exports = VersionError;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbW9uZ29vc2UvbGliL2Vycm9yL3ZlcnNpb24uanMiLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWI7QUFDQTtBQUNBOztBQUVBLHNCQUFzQixtQkFBTyxDQUFDLDREQUFJOztBQUVsQztBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsVUFBVTtBQUN2QixhQUFhLFFBQVE7QUFDckIsYUFBYSxlQUFlO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7O0FBRUEiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9hcHAxLy4vbm9kZV9tb2R1bGVzL21vbmdvb3NlL2xpYi9lcnJvci92ZXJzaW9uLmpzPzMwZWMiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG4vKiFcbiAqIE1vZHVsZSBkZXBlbmRlbmNpZXMuXG4gKi9cblxuY29uc3QgTW9uZ29vc2VFcnJvciA9IHJlcXVpcmUoJy4vJyk7XG5cbmNsYXNzIFZlcnNpb25FcnJvciBleHRlbmRzIE1vbmdvb3NlRXJyb3Ige1xuICAvKipcbiAgICogVmVyc2lvbiBFcnJvciBjb25zdHJ1Y3Rvci5cbiAgICpcbiAgICogQHBhcmFtIHtEb2N1bWVudH0gZG9jXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBjdXJyZW50VmVyc2lvblxuICAgKiBAcGFyYW0ge0FycmF5PFN0cmluZz59IG1vZGlmaWVkUGF0aHNcbiAgICogQGFwaSBwcml2YXRlXG4gICAqL1xuICBjb25zdHJ1Y3Rvcihkb2MsIGN1cnJlbnRWZXJzaW9uLCBtb2RpZmllZFBhdGhzKSB7XG4gICAgY29uc3QgbW9kaWZpZWRQYXRoc1N0ciA9IG1vZGlmaWVkUGF0aHMuam9pbignLCAnKTtcbiAgICBzdXBlcignTm8gbWF0Y2hpbmcgZG9jdW1lbnQgZm91bmQgZm9yIGlkIFwiJyArIGRvYy5faWQgK1xuICAgICAgJ1wiIHZlcnNpb24gJyArIGN1cnJlbnRWZXJzaW9uICsgJyBtb2RpZmllZFBhdGhzIFwiJyArIG1vZGlmaWVkUGF0aHNTdHIgKyAnXCInKTtcbiAgICB0aGlzLnZlcnNpb24gPSBjdXJyZW50VmVyc2lvbjtcbiAgICB0aGlzLm1vZGlmaWVkUGF0aHMgPSBtb2RpZmllZFBhdGhzO1xuICB9XG59XG5cblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KFZlcnNpb25FcnJvci5wcm90b3R5cGUsICduYW1lJywge1xuICB2YWx1ZTogJ1ZlcnNpb25FcnJvcidcbn0pO1xuXG4vKiFcbiAqIGV4cG9ydHNcbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IFZlcnNpb25FcnJvcjtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/mongoose/lib/error/version.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/mongoose/lib/helpers/aggregate/prepareDiscriminatorPipeline.js":
/*!*************************************************************************************!*\
  !*** ./node_modules/mongoose/lib/helpers/aggregate/prepareDiscriminatorPipeline.js ***!
  \*************************************************************************************/
/***/ ((module) => {

eval("\n\nmodule.exports = function prepareDiscriminatorPipeline(pipeline, schema, prefix) {\n  const discriminatorMapping = schema && schema.discriminatorMapping;\n  prefix = prefix || '';\n\n  if (discriminatorMapping && !discriminatorMapping.isRoot) {\n    const originalPipeline = pipeline;\n    const filterKey = (prefix.length > 0 ? prefix + '.' : prefix) + discriminatorMapping.key;\n    const discriminatorValue = discriminatorMapping.value;\n\n    // If the first pipeline stage is a match and it doesn't specify a `__t`\n    // key, add the discriminator key to it. This allows for potential\n    // aggregation query optimizations not to be disturbed by this feature.\n    if (originalPipeline[0] != null &&\n        originalPipeline[0].$match &&\n        (originalPipeline[0].$match[filterKey] === undefined || originalPipeline[0].$match[filterKey] === discriminatorValue)) {\n      originalPipeline[0].$match[filterKey] = discriminatorValue;\n      // `originalPipeline` is a ref, so there's no need for\n      // aggregate._pipeline = originalPipeline\n    } else if (originalPipeline[0] != null && originalPipeline[0].$geoNear) {\n      originalPipeline[0].$geoNear.query =\n          originalPipeline[0].$geoNear.query || {};\n      originalPipeline[0].$geoNear.query[filterKey] = discriminatorValue;\n    } else if (originalPipeline[0] != null && originalPipeline[0].$search) {\n      if (originalPipeline[1] && originalPipeline[1].$match != null) {\n        originalPipeline[1].$match[filterKey] = originalPipeline[1].$match[filterKey] || discriminatorValue;\n      } else {\n        const match = {};\n        match[filterKey] = discriminatorValue;\n        originalPipeline.splice(1, 0, { $match: match });\n      }\n    } else {\n      const match = {};\n      match[filterKey] = discriminatorValue;\n      originalPipeline.unshift({ $match: match });\n    }\n  }\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbW9uZ29vc2UvbGliL2hlbHBlcnMvYWdncmVnYXRlL3ByZXBhcmVEaXNjcmltaW5hdG9yUGlwZWxpbmUuanMiLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0Esd0NBQXdDLGVBQWU7QUFDdkQ7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLGlDQUFpQyxlQUFlO0FBQ2hEO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL2FwcDEvLi9ub2RlX21vZHVsZXMvbW9uZ29vc2UvbGliL2hlbHBlcnMvYWdncmVnYXRlL3ByZXBhcmVEaXNjcmltaW5hdG9yUGlwZWxpbmUuanM/MDMyZSJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gcHJlcGFyZURpc2NyaW1pbmF0b3JQaXBlbGluZShwaXBlbGluZSwgc2NoZW1hLCBwcmVmaXgpIHtcbiAgY29uc3QgZGlzY3JpbWluYXRvck1hcHBpbmcgPSBzY2hlbWEgJiYgc2NoZW1hLmRpc2NyaW1pbmF0b3JNYXBwaW5nO1xuICBwcmVmaXggPSBwcmVmaXggfHwgJyc7XG5cbiAgaWYgKGRpc2NyaW1pbmF0b3JNYXBwaW5nICYmICFkaXNjcmltaW5hdG9yTWFwcGluZy5pc1Jvb3QpIHtcbiAgICBjb25zdCBvcmlnaW5hbFBpcGVsaW5lID0gcGlwZWxpbmU7XG4gICAgY29uc3QgZmlsdGVyS2V5ID0gKHByZWZpeC5sZW5ndGggPiAwID8gcHJlZml4ICsgJy4nIDogcHJlZml4KSArIGRpc2NyaW1pbmF0b3JNYXBwaW5nLmtleTtcbiAgICBjb25zdCBkaXNjcmltaW5hdG9yVmFsdWUgPSBkaXNjcmltaW5hdG9yTWFwcGluZy52YWx1ZTtcblxuICAgIC8vIElmIHRoZSBmaXJzdCBwaXBlbGluZSBzdGFnZSBpcyBhIG1hdGNoIGFuZCBpdCBkb2Vzbid0IHNwZWNpZnkgYSBgX190YFxuICAgIC8vIGtleSwgYWRkIHRoZSBkaXNjcmltaW5hdG9yIGtleSB0byBpdC4gVGhpcyBhbGxvd3MgZm9yIHBvdGVudGlhbFxuICAgIC8vIGFnZ3JlZ2F0aW9uIHF1ZXJ5IG9wdGltaXphdGlvbnMgbm90IHRvIGJlIGRpc3R1cmJlZCBieSB0aGlzIGZlYXR1cmUuXG4gICAgaWYgKG9yaWdpbmFsUGlwZWxpbmVbMF0gIT0gbnVsbCAmJlxuICAgICAgICBvcmlnaW5hbFBpcGVsaW5lWzBdLiRtYXRjaCAmJlxuICAgICAgICAob3JpZ2luYWxQaXBlbGluZVswXS4kbWF0Y2hbZmlsdGVyS2V5XSA9PT0gdW5kZWZpbmVkIHx8IG9yaWdpbmFsUGlwZWxpbmVbMF0uJG1hdGNoW2ZpbHRlcktleV0gPT09IGRpc2NyaW1pbmF0b3JWYWx1ZSkpIHtcbiAgICAgIG9yaWdpbmFsUGlwZWxpbmVbMF0uJG1hdGNoW2ZpbHRlcktleV0gPSBkaXNjcmltaW5hdG9yVmFsdWU7XG4gICAgICAvLyBgb3JpZ2luYWxQaXBlbGluZWAgaXMgYSByZWYsIHNvIHRoZXJlJ3Mgbm8gbmVlZCBmb3JcbiAgICAgIC8vIGFnZ3JlZ2F0ZS5fcGlwZWxpbmUgPSBvcmlnaW5hbFBpcGVsaW5lXG4gICAgfSBlbHNlIGlmIChvcmlnaW5hbFBpcGVsaW5lWzBdICE9IG51bGwgJiYgb3JpZ2luYWxQaXBlbGluZVswXS4kZ2VvTmVhcikge1xuICAgICAgb3JpZ2luYWxQaXBlbGluZVswXS4kZ2VvTmVhci5xdWVyeSA9XG4gICAgICAgICAgb3JpZ2luYWxQaXBlbGluZVswXS4kZ2VvTmVhci5xdWVyeSB8fCB7fTtcbiAgICAgIG9yaWdpbmFsUGlwZWxpbmVbMF0uJGdlb05lYXIucXVlcnlbZmlsdGVyS2V5XSA9IGRpc2NyaW1pbmF0b3JWYWx1ZTtcbiAgICB9IGVsc2UgaWYgKG9yaWdpbmFsUGlwZWxpbmVbMF0gIT0gbnVsbCAmJiBvcmlnaW5hbFBpcGVsaW5lWzBdLiRzZWFyY2gpIHtcbiAgICAgIGlmIChvcmlnaW5hbFBpcGVsaW5lWzFdICYmIG9yaWdpbmFsUGlwZWxpbmVbMV0uJG1hdGNoICE9IG51bGwpIHtcbiAgICAgICAgb3JpZ2luYWxQaXBlbGluZVsxXS4kbWF0Y2hbZmlsdGVyS2V5XSA9IG9yaWdpbmFsUGlwZWxpbmVbMV0uJG1hdGNoW2ZpbHRlcktleV0gfHwgZGlzY3JpbWluYXRvclZhbHVlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc3QgbWF0Y2ggPSB7fTtcbiAgICAgICAgbWF0Y2hbZmlsdGVyS2V5XSA9IGRpc2NyaW1pbmF0b3JWYWx1ZTtcbiAgICAgICAgb3JpZ2luYWxQaXBlbGluZS5zcGxpY2UoMSwgMCwgeyAkbWF0Y2g6IG1hdGNoIH0pO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCBtYXRjaCA9IHt9O1xuICAgICAgbWF0Y2hbZmlsdGVyS2V5XSA9IGRpc2NyaW1pbmF0b3JWYWx1ZTtcbiAgICAgIG9yaWdpbmFsUGlwZWxpbmUudW5zaGlmdCh7ICRtYXRjaDogbWF0Y2ggfSk7XG4gICAgfVxuICB9XG59O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/mongoose/lib/helpers/aggregate/prepareDiscriminatorPipeline.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/mongoose/lib/helpers/aggregate/stringifyFunctionOperators.js":
/*!***********************************************************************************!*\
  !*** ./node_modules/mongoose/lib/helpers/aggregate/stringifyFunctionOperators.js ***!
  \***********************************************************************************/
/***/ ((module) => {

eval("\n\nmodule.exports = function stringifyFunctionOperators(pipeline) {\n  if (!Array.isArray(pipeline)) {\n    return;\n  }\n\n  for (const stage of pipeline) {\n    if (stage == null) {\n      continue;\n    }\n\n    const canHaveAccumulator = stage.$group || stage.$bucket || stage.$bucketAuto;\n    if (canHaveAccumulator != null) {\n      for (const key of Object.keys(canHaveAccumulator)) {\n        handleAccumulator(canHaveAccumulator[key]);\n      }\n    }\n\n    const stageType = Object.keys(stage)[0];\n    if (stageType && typeof stage[stageType] === 'object') {\n      const stageOptions = stage[stageType];\n      for (const key of Object.keys(stageOptions)) {\n        if (stageOptions[key] != null &&\n            stageOptions[key].$function != null &&\n            typeof stageOptions[key].$function.body === 'function') {\n          stageOptions[key].$function.body = stageOptions[key].$function.body.toString();\n        }\n      }\n    }\n\n    if (stage.$facet != null) {\n      for (const key of Object.keys(stage.$facet)) {\n        stringifyFunctionOperators(stage.$facet[key]);\n      }\n    }\n  }\n};\n\nfunction handleAccumulator(operator) {\n  if (operator == null || operator.$accumulator == null) {\n    return;\n  }\n\n  for (const key of ['init', 'accumulate', 'merge', 'finalize']) {\n    if (typeof operator.$accumulator[key] === 'function') {\n      operator.$accumulator[key] = String(operator.$accumulator[key]);\n    }\n  }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbW9uZ29vc2UvbGliL2hlbHBlcnMvYWdncmVnYXRlL3N0cmluZ2lmeUZ1bmN0aW9uT3BlcmF0b3JzLmpzIiwibWFwcGluZ3MiOiJBQUFhOztBQUViO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL2FwcDEvLi9ub2RlX21vZHVsZXMvbW9uZ29vc2UvbGliL2hlbHBlcnMvYWdncmVnYXRlL3N0cmluZ2lmeUZ1bmN0aW9uT3BlcmF0b3JzLmpzP2VmZTciXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIHN0cmluZ2lmeUZ1bmN0aW9uT3BlcmF0b3JzKHBpcGVsaW5lKSB7XG4gIGlmICghQXJyYXkuaXNBcnJheShwaXBlbGluZSkpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICBmb3IgKGNvbnN0IHN0YWdlIG9mIHBpcGVsaW5lKSB7XG4gICAgaWYgKHN0YWdlID09IG51bGwpIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIGNvbnN0IGNhbkhhdmVBY2N1bXVsYXRvciA9IHN0YWdlLiRncm91cCB8fCBzdGFnZS4kYnVja2V0IHx8IHN0YWdlLiRidWNrZXRBdXRvO1xuICAgIGlmIChjYW5IYXZlQWNjdW11bGF0b3IgIT0gbnVsbCkge1xuICAgICAgZm9yIChjb25zdCBrZXkgb2YgT2JqZWN0LmtleXMoY2FuSGF2ZUFjY3VtdWxhdG9yKSkge1xuICAgICAgICBoYW5kbGVBY2N1bXVsYXRvcihjYW5IYXZlQWNjdW11bGF0b3Jba2V5XSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgY29uc3Qgc3RhZ2VUeXBlID0gT2JqZWN0LmtleXMoc3RhZ2UpWzBdO1xuICAgIGlmIChzdGFnZVR5cGUgJiYgdHlwZW9mIHN0YWdlW3N0YWdlVHlwZV0gPT09ICdvYmplY3QnKSB7XG4gICAgICBjb25zdCBzdGFnZU9wdGlvbnMgPSBzdGFnZVtzdGFnZVR5cGVdO1xuICAgICAgZm9yIChjb25zdCBrZXkgb2YgT2JqZWN0LmtleXMoc3RhZ2VPcHRpb25zKSkge1xuICAgICAgICBpZiAoc3RhZ2VPcHRpb25zW2tleV0gIT0gbnVsbCAmJlxuICAgICAgICAgICAgc3RhZ2VPcHRpb25zW2tleV0uJGZ1bmN0aW9uICE9IG51bGwgJiZcbiAgICAgICAgICAgIHR5cGVvZiBzdGFnZU9wdGlvbnNba2V5XS4kZnVuY3Rpb24uYm9keSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgIHN0YWdlT3B0aW9uc1trZXldLiRmdW5jdGlvbi5ib2R5ID0gc3RhZ2VPcHRpb25zW2tleV0uJGZ1bmN0aW9uLmJvZHkudG9TdHJpbmcoKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChzdGFnZS4kZmFjZXQgIT0gbnVsbCkge1xuICAgICAgZm9yIChjb25zdCBrZXkgb2YgT2JqZWN0LmtleXMoc3RhZ2UuJGZhY2V0KSkge1xuICAgICAgICBzdHJpbmdpZnlGdW5jdGlvbk9wZXJhdG9ycyhzdGFnZS4kZmFjZXRba2V5XSk7XG4gICAgICB9XG4gICAgfVxuICB9XG59O1xuXG5mdW5jdGlvbiBoYW5kbGVBY2N1bXVsYXRvcihvcGVyYXRvcikge1xuICBpZiAob3BlcmF0b3IgPT0gbnVsbCB8fCBvcGVyYXRvci4kYWNjdW11bGF0b3IgPT0gbnVsbCkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIGZvciAoY29uc3Qga2V5IG9mIFsnaW5pdCcsICdhY2N1bXVsYXRlJywgJ21lcmdlJywgJ2ZpbmFsaXplJ10pIHtcbiAgICBpZiAodHlwZW9mIG9wZXJhdG9yLiRhY2N1bXVsYXRvcltrZXldID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBvcGVyYXRvci4kYWNjdW11bGF0b3Jba2V5XSA9IFN0cmluZyhvcGVyYXRvci4kYWNjdW11bGF0b3Jba2V5XSk7XG4gICAgfVxuICB9XG59XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/mongoose/lib/helpers/aggregate/stringifyFunctionOperators.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/mongoose/lib/helpers/arrayDepth.js":
/*!*********************************************************!*\
  !*** ./node_modules/mongoose/lib/helpers/arrayDepth.js ***!
  \*********************************************************/
/***/ ((module) => {

eval("\n\nmodule.exports = arrayDepth;\n\nfunction arrayDepth(arr) {\n  if (!Array.isArray(arr)) {\n    return { min: 0, max: 0, containsNonArrayItem: true };\n  }\n  if (arr.length === 0) {\n    return { min: 1, max: 1, containsNonArrayItem: false };\n  }\n  if (arr.length === 1 && !Array.isArray(arr[0])) {\n    return { min: 1, max: 1, containsNonArrayItem: false };\n  }\n\n  const res = arrayDepth(arr[0]);\n\n  for (let i = 1; i < arr.length; ++i) {\n    const _res = arrayDepth(arr[i]);\n    if (_res.min < res.min) {\n      res.min = _res.min;\n    }\n    if (_res.max > res.max) {\n      res.max = _res.max;\n    }\n    res.containsNonArrayItem = res.containsNonArrayItem || _res.containsNonArrayItem;\n  }\n\n  res.min = res.min + 1;\n  res.max = res.max + 1;\n\n  return res;\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbW9uZ29vc2UvbGliL2hlbHBlcnMvYXJyYXlEZXB0aC5qcyIsIm1hcHBpbmdzIjoiQUFBYTs7QUFFYjs7QUFFQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLGFBQWE7QUFDYjs7QUFFQTs7QUFFQSxrQkFBa0IsZ0JBQWdCO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9hcHAxLy4vbm9kZV9tb2R1bGVzL21vbmdvb3NlL2xpYi9oZWxwZXJzL2FycmF5RGVwdGguanM/YjZlOCJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbm1vZHVsZS5leHBvcnRzID0gYXJyYXlEZXB0aDtcblxuZnVuY3Rpb24gYXJyYXlEZXB0aChhcnIpIHtcbiAgaWYgKCFBcnJheS5pc0FycmF5KGFycikpIHtcbiAgICByZXR1cm4geyBtaW46IDAsIG1heDogMCwgY29udGFpbnNOb25BcnJheUl0ZW06IHRydWUgfTtcbiAgfVxuICBpZiAoYXJyLmxlbmd0aCA9PT0gMCkge1xuICAgIHJldHVybiB7IG1pbjogMSwgbWF4OiAxLCBjb250YWluc05vbkFycmF5SXRlbTogZmFsc2UgfTtcbiAgfVxuICBpZiAoYXJyLmxlbmd0aCA9PT0gMSAmJiAhQXJyYXkuaXNBcnJheShhcnJbMF0pKSB7XG4gICAgcmV0dXJuIHsgbWluOiAxLCBtYXg6IDEsIGNvbnRhaW5zTm9uQXJyYXlJdGVtOiBmYWxzZSB9O1xuICB9XG5cbiAgY29uc3QgcmVzID0gYXJyYXlEZXB0aChhcnJbMF0pO1xuXG4gIGZvciAobGV0IGkgPSAxOyBpIDwgYXJyLmxlbmd0aDsgKytpKSB7XG4gICAgY29uc3QgX3JlcyA9IGFycmF5RGVwdGgoYXJyW2ldKTtcbiAgICBpZiAoX3Jlcy5taW4gPCByZXMubWluKSB7XG4gICAgICByZXMubWluID0gX3Jlcy5taW47XG4gICAgfVxuICAgIGlmIChfcmVzLm1heCA+IHJlcy5tYXgpIHtcbiAgICAgIHJlcy5tYXggPSBfcmVzLm1heDtcbiAgICB9XG4gICAgcmVzLmNvbnRhaW5zTm9uQXJyYXlJdGVtID0gcmVzLmNvbnRhaW5zTm9uQXJyYXlJdGVtIHx8IF9yZXMuY29udGFpbnNOb25BcnJheUl0ZW07XG4gIH1cblxuICByZXMubWluID0gcmVzLm1pbiArIDE7XG4gIHJlcy5tYXggPSByZXMubWF4ICsgMTtcblxuICByZXR1cm4gcmVzO1xufVxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/mongoose/lib/helpers/arrayDepth.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/mongoose/lib/helpers/clone.js":
/*!****************************************************!*\
  !*** ./node_modules/mongoose/lib/helpers/clone.js ***!
  \****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\n\nconst Decimal = __webpack_require__(/*! ../types/decimal128 */ \"(ssr)/./node_modules/mongoose/lib/types/decimal128.js\");\nconst ObjectId = __webpack_require__(/*! ../types/objectid */ \"(ssr)/./node_modules/mongoose/lib/types/objectid.js\");\nconst specialProperties = __webpack_require__(/*! ./specialProperties */ \"(ssr)/./node_modules/mongoose/lib/helpers/specialProperties.js\");\nconst isMongooseObject = __webpack_require__(/*! ./isMongooseObject */ \"(ssr)/./node_modules/mongoose/lib/helpers/isMongooseObject.js\");\nconst getFunctionName = __webpack_require__(/*! ./getFunctionName */ \"(ssr)/./node_modules/mongoose/lib/helpers/getFunctionName.js\");\nconst isBsonType = __webpack_require__(/*! ./isBsonType */ \"(ssr)/./node_modules/mongoose/lib/helpers/isBsonType.js\");\nconst isMongooseArray = (__webpack_require__(/*! ../types/array/isMongooseArray */ \"(ssr)/./node_modules/mongoose/lib/types/array/isMongooseArray.js\").isMongooseArray);\nconst isObject = __webpack_require__(/*! ./isObject */ \"(ssr)/./node_modules/mongoose/lib/helpers/isObject.js\");\nconst isPOJO = __webpack_require__(/*! ./isPOJO */ \"(ssr)/./node_modules/mongoose/lib/helpers/isPOJO.js\");\nconst symbols = __webpack_require__(/*! ./symbols */ \"(ssr)/./node_modules/mongoose/lib/helpers/symbols.js\");\nconst trustedSymbol = (__webpack_require__(/*! ./query/trusted */ \"(ssr)/./node_modules/mongoose/lib/helpers/query/trusted.js\").trustedSymbol);\n\n/**\n * Object clone with Mongoose natives support.\n *\n * If options.minimize is true, creates a minimal data object. Empty objects and undefined values will not be cloned. This makes the data payload sent to MongoDB as small as possible.\n *\n * Functions are never cloned.\n *\n * @param {Object} obj the object to clone\n * @param {Object} options\n * @param {Boolean} isArrayChild true if cloning immediately underneath an array. Special case for minimize.\n * @return {Object} the cloned object\n * @api private\n */\n\nfunction clone(obj, options, isArrayChild) {\n  if (obj == null) {\n    return obj;\n  }\n\n  if (Array.isArray(obj)) {\n    return cloneArray(isMongooseArray(obj) ? obj.__array : obj, options);\n  }\n\n  if (isMongooseObject(obj)) {\n    // Single nested subdocs should apply getters later in `applyGetters()`\n    // when calling `toObject()`. See gh-7442, gh-8295\n    if (options && options._skipSingleNestedGetters && obj.$isSingleNested) {\n      options = Object.assign({}, options, { getters: false });\n    }\n    const isSingleNested = obj.$isSingleNested;\n\n    if (isPOJO(obj) && obj.$__ != null && obj._doc != null) {\n      return obj._doc;\n    }\n\n    let ret;\n    if (options && options.json && typeof obj.toJSON === 'function') {\n      ret = obj.toJSON(options);\n    } else {\n      ret = obj.toObject(options);\n    }\n\n    if (options && options.minimize && isSingleNested && Object.keys(ret).length === 0) {\n      return undefined;\n    }\n\n    return ret;\n  }\n\n  const objConstructor = obj.constructor;\n\n  if (objConstructor) {\n    switch (getFunctionName(objConstructor)) {\n      case 'Object':\n        return cloneObject(obj, options, isArrayChild);\n      case 'Date':\n        return new objConstructor(+obj);\n      case 'RegExp':\n        return cloneRegExp(obj);\n      default:\n        // ignore\n        break;\n    }\n  }\n\n  if (isBsonType(obj, 'ObjectId')) {\n    if (options && options.flattenObjectIds) {\n      return obj.toJSON();\n    }\n    return new ObjectId(obj.id);\n  }\n\n  if (isBsonType(obj, 'Decimal128')) {\n    if (options && options.flattenDecimals) {\n      return obj.toJSON();\n    }\n    return Decimal.fromString(obj.toString());\n  }\n\n  // object created with Object.create(null)\n  if (!objConstructor && isObject(obj)) {\n    return cloneObject(obj, options, isArrayChild);\n  }\n\n  if (typeof obj === 'object' && obj[symbols.schemaTypeSymbol]) {\n    return obj.clone();\n  }\n\n  // If we're cloning this object to go into a MongoDB command,\n  // and there's a `toBSON()` function, assume this object will be\n  // stored as a primitive in MongoDB and doesn't need to be cloned.\n  if (options && options.bson && typeof obj.toBSON === 'function') {\n    return obj;\n  }\n\n  if (typeof obj.valueOf === 'function') {\n    return obj.valueOf();\n  }\n\n  return cloneObject(obj, options, isArrayChild);\n}\nmodule.exports = clone;\n\n/*!\n * ignore\n */\n\nfunction cloneObject(obj, options, isArrayChild) {\n  const minimize = options && options.minimize;\n  const omitUndefined = options && options.omitUndefined;\n  const seen = options && options._seen;\n  const ret = {};\n  let hasKeys;\n\n  if (seen && seen.has(obj)) {\n    return seen.get(obj);\n  } else if (seen) {\n    seen.set(obj, ret);\n  }\n  if (trustedSymbol in obj) {\n    ret[trustedSymbol] = obj[trustedSymbol];\n  }\n\n  let i = 0;\n  let key = '';\n  const keys = Object.keys(obj);\n  const len = keys.length;\n\n  for (i = 0; i < len; ++i) {\n    if (specialProperties.has(key = keys[i])) {\n      continue;\n    }\n\n    // Don't pass `isArrayChild` down\n    const val = clone(obj[key], options, false);\n\n    if ((minimize === false || omitUndefined) && typeof val === 'undefined') {\n      delete ret[key];\n    } else if (minimize !== true || (typeof val !== 'undefined')) {\n      hasKeys || (hasKeys = true);\n      ret[key] = val;\n    }\n  }\n\n  return minimize && !isArrayChild ? hasKeys && ret : ret;\n}\n\nfunction cloneArray(arr, options) {\n  let i = 0;\n  const len = arr.length;\n  const ret = new Array(len);\n  for (i = 0; i < len; ++i) {\n    ret[i] = clone(arr[i], options, true);\n  }\n\n  return ret;\n}\n\nfunction cloneRegExp(regexp) {\n  const ret = new RegExp(regexp.source, regexp.flags);\n\n  if (ret.lastIndex !== regexp.lastIndex) {\n    ret.lastIndex = regexp.lastIndex;\n  }\n  return ret;\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbW9uZ29vc2UvbGliL2hlbHBlcnMvY2xvbmUuanMiLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWIsZ0JBQWdCLG1CQUFPLENBQUMsa0ZBQXFCO0FBQzdDLGlCQUFpQixtQkFBTyxDQUFDLDhFQUFtQjtBQUM1QywwQkFBMEIsbUJBQU8sQ0FBQywyRkFBcUI7QUFDdkQseUJBQXlCLG1CQUFPLENBQUMseUZBQW9CO0FBQ3JELHdCQUF3QixtQkFBTyxDQUFDLHVGQUFtQjtBQUNuRCxtQkFBbUIsbUJBQU8sQ0FBQyw2RUFBYztBQUN6Qyx3QkFBd0IsK0lBQXlEO0FBQ2pGLGlCQUFpQixtQkFBTyxDQUFDLHlFQUFZO0FBQ3JDLGVBQWUsbUJBQU8sQ0FBQyxxRUFBVTtBQUNqQyxnQkFBZ0IsbUJBQU8sQ0FBQyx1RUFBVztBQUNuQyxzQkFBc0Isd0hBQXdDOztBQUU5RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsV0FBVyxTQUFTO0FBQ3BCLFlBQVksUUFBUTtBQUNwQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQyxhQUFhLGdCQUFnQjtBQUM3RDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxjQUFjLFNBQVM7QUFDdkI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxTQUFTO0FBQ3ZCO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9hcHAxLy4vbm9kZV9tb2R1bGVzL21vbmdvb3NlL2xpYi9oZWxwZXJzL2Nsb25lLmpzPzljMzIiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG5jb25zdCBEZWNpbWFsID0gcmVxdWlyZSgnLi4vdHlwZXMvZGVjaW1hbDEyOCcpO1xuY29uc3QgT2JqZWN0SWQgPSByZXF1aXJlKCcuLi90eXBlcy9vYmplY3RpZCcpO1xuY29uc3Qgc3BlY2lhbFByb3BlcnRpZXMgPSByZXF1aXJlKCcuL3NwZWNpYWxQcm9wZXJ0aWVzJyk7XG5jb25zdCBpc01vbmdvb3NlT2JqZWN0ID0gcmVxdWlyZSgnLi9pc01vbmdvb3NlT2JqZWN0Jyk7XG5jb25zdCBnZXRGdW5jdGlvbk5hbWUgPSByZXF1aXJlKCcuL2dldEZ1bmN0aW9uTmFtZScpO1xuY29uc3QgaXNCc29uVHlwZSA9IHJlcXVpcmUoJy4vaXNCc29uVHlwZScpO1xuY29uc3QgaXNNb25nb29zZUFycmF5ID0gcmVxdWlyZSgnLi4vdHlwZXMvYXJyYXkvaXNNb25nb29zZUFycmF5JykuaXNNb25nb29zZUFycmF5O1xuY29uc3QgaXNPYmplY3QgPSByZXF1aXJlKCcuL2lzT2JqZWN0Jyk7XG5jb25zdCBpc1BPSk8gPSByZXF1aXJlKCcuL2lzUE9KTycpO1xuY29uc3Qgc3ltYm9scyA9IHJlcXVpcmUoJy4vc3ltYm9scycpO1xuY29uc3QgdHJ1c3RlZFN5bWJvbCA9IHJlcXVpcmUoJy4vcXVlcnkvdHJ1c3RlZCcpLnRydXN0ZWRTeW1ib2w7XG5cbi8qKlxuICogT2JqZWN0IGNsb25lIHdpdGggTW9uZ29vc2UgbmF0aXZlcyBzdXBwb3J0LlxuICpcbiAqIElmIG9wdGlvbnMubWluaW1pemUgaXMgdHJ1ZSwgY3JlYXRlcyBhIG1pbmltYWwgZGF0YSBvYmplY3QuIEVtcHR5IG9iamVjdHMgYW5kIHVuZGVmaW5lZCB2YWx1ZXMgd2lsbCBub3QgYmUgY2xvbmVkLiBUaGlzIG1ha2VzIHRoZSBkYXRhIHBheWxvYWQgc2VudCB0byBNb25nb0RCIGFzIHNtYWxsIGFzIHBvc3NpYmxlLlxuICpcbiAqIEZ1bmN0aW9ucyBhcmUgbmV2ZXIgY2xvbmVkLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmogdGhlIG9iamVjdCB0byBjbG9uZVxuICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcbiAqIEBwYXJhbSB7Qm9vbGVhbn0gaXNBcnJheUNoaWxkIHRydWUgaWYgY2xvbmluZyBpbW1lZGlhdGVseSB1bmRlcm5lYXRoIGFuIGFycmF5LiBTcGVjaWFsIGNhc2UgZm9yIG1pbmltaXplLlxuICogQHJldHVybiB7T2JqZWN0fSB0aGUgY2xvbmVkIG9iamVjdFxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZnVuY3Rpb24gY2xvbmUob2JqLCBvcHRpb25zLCBpc0FycmF5Q2hpbGQpIHtcbiAgaWYgKG9iaiA9PSBudWxsKSB7XG4gICAgcmV0dXJuIG9iajtcbiAgfVxuXG4gIGlmIChBcnJheS5pc0FycmF5KG9iaikpIHtcbiAgICByZXR1cm4gY2xvbmVBcnJheShpc01vbmdvb3NlQXJyYXkob2JqKSA/IG9iai5fX2FycmF5IDogb2JqLCBvcHRpb25zKTtcbiAgfVxuXG4gIGlmIChpc01vbmdvb3NlT2JqZWN0KG9iaikpIHtcbiAgICAvLyBTaW5nbGUgbmVzdGVkIHN1YmRvY3Mgc2hvdWxkIGFwcGx5IGdldHRlcnMgbGF0ZXIgaW4gYGFwcGx5R2V0dGVycygpYFxuICAgIC8vIHdoZW4gY2FsbGluZyBgdG9PYmplY3QoKWAuIFNlZSBnaC03NDQyLCBnaC04Mjk1XG4gICAgaWYgKG9wdGlvbnMgJiYgb3B0aW9ucy5fc2tpcFNpbmdsZU5lc3RlZEdldHRlcnMgJiYgb2JqLiRpc1NpbmdsZU5lc3RlZCkge1xuICAgICAgb3B0aW9ucyA9IE9iamVjdC5hc3NpZ24oe30sIG9wdGlvbnMsIHsgZ2V0dGVyczogZmFsc2UgfSk7XG4gICAgfVxuICAgIGNvbnN0IGlzU2luZ2xlTmVzdGVkID0gb2JqLiRpc1NpbmdsZU5lc3RlZDtcblxuICAgIGlmIChpc1BPSk8ob2JqKSAmJiBvYmouJF9fICE9IG51bGwgJiYgb2JqLl9kb2MgIT0gbnVsbCkge1xuICAgICAgcmV0dXJuIG9iai5fZG9jO1xuICAgIH1cblxuICAgIGxldCByZXQ7XG4gICAgaWYgKG9wdGlvbnMgJiYgb3B0aW9ucy5qc29uICYmIHR5cGVvZiBvYmoudG9KU09OID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICByZXQgPSBvYmoudG9KU09OKG9wdGlvbnMpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXQgPSBvYmoudG9PYmplY3Qob3B0aW9ucyk7XG4gICAgfVxuXG4gICAgaWYgKG9wdGlvbnMgJiYgb3B0aW9ucy5taW5pbWl6ZSAmJiBpc1NpbmdsZU5lc3RlZCAmJiBPYmplY3Qua2V5cyhyZXQpLmxlbmd0aCA9PT0gMCkge1xuICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9XG5cbiAgICByZXR1cm4gcmV0O1xuICB9XG5cbiAgY29uc3Qgb2JqQ29uc3RydWN0b3IgPSBvYmouY29uc3RydWN0b3I7XG5cbiAgaWYgKG9iakNvbnN0cnVjdG9yKSB7XG4gICAgc3dpdGNoIChnZXRGdW5jdGlvbk5hbWUob2JqQ29uc3RydWN0b3IpKSB7XG4gICAgICBjYXNlICdPYmplY3QnOlxuICAgICAgICByZXR1cm4gY2xvbmVPYmplY3Qob2JqLCBvcHRpb25zLCBpc0FycmF5Q2hpbGQpO1xuICAgICAgY2FzZSAnRGF0ZSc6XG4gICAgICAgIHJldHVybiBuZXcgb2JqQ29uc3RydWN0b3IoK29iaik7XG4gICAgICBjYXNlICdSZWdFeHAnOlxuICAgICAgICByZXR1cm4gY2xvbmVSZWdFeHAob2JqKTtcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIC8vIGlnbm9yZVxuICAgICAgICBicmVhaztcbiAgICB9XG4gIH1cblxuICBpZiAoaXNCc29uVHlwZShvYmosICdPYmplY3RJZCcpKSB7XG4gICAgaWYgKG9wdGlvbnMgJiYgb3B0aW9ucy5mbGF0dGVuT2JqZWN0SWRzKSB7XG4gICAgICByZXR1cm4gb2JqLnRvSlNPTigpO1xuICAgIH1cbiAgICByZXR1cm4gbmV3IE9iamVjdElkKG9iai5pZCk7XG4gIH1cblxuICBpZiAoaXNCc29uVHlwZShvYmosICdEZWNpbWFsMTI4JykpIHtcbiAgICBpZiAob3B0aW9ucyAmJiBvcHRpb25zLmZsYXR0ZW5EZWNpbWFscykge1xuICAgICAgcmV0dXJuIG9iai50b0pTT04oKTtcbiAgICB9XG4gICAgcmV0dXJuIERlY2ltYWwuZnJvbVN0cmluZyhvYmoudG9TdHJpbmcoKSk7XG4gIH1cblxuICAvLyBvYmplY3QgY3JlYXRlZCB3aXRoIE9iamVjdC5jcmVhdGUobnVsbClcbiAgaWYgKCFvYmpDb25zdHJ1Y3RvciAmJiBpc09iamVjdChvYmopKSB7XG4gICAgcmV0dXJuIGNsb25lT2JqZWN0KG9iaiwgb3B0aW9ucywgaXNBcnJheUNoaWxkKTtcbiAgfVxuXG4gIGlmICh0eXBlb2Ygb2JqID09PSAnb2JqZWN0JyAmJiBvYmpbc3ltYm9scy5zY2hlbWFUeXBlU3ltYm9sXSkge1xuICAgIHJldHVybiBvYmouY2xvbmUoKTtcbiAgfVxuXG4gIC8vIElmIHdlJ3JlIGNsb25pbmcgdGhpcyBvYmplY3QgdG8gZ28gaW50byBhIE1vbmdvREIgY29tbWFuZCxcbiAgLy8gYW5kIHRoZXJlJ3MgYSBgdG9CU09OKClgIGZ1bmN0aW9uLCBhc3N1bWUgdGhpcyBvYmplY3Qgd2lsbCBiZVxuICAvLyBzdG9yZWQgYXMgYSBwcmltaXRpdmUgaW4gTW9uZ29EQiBhbmQgZG9lc24ndCBuZWVkIHRvIGJlIGNsb25lZC5cbiAgaWYgKG9wdGlvbnMgJiYgb3B0aW9ucy5ic29uICYmIHR5cGVvZiBvYmoudG9CU09OID09PSAnZnVuY3Rpb24nKSB7XG4gICAgcmV0dXJuIG9iajtcbiAgfVxuXG4gIGlmICh0eXBlb2Ygb2JqLnZhbHVlT2YgPT09ICdmdW5jdGlvbicpIHtcbiAgICByZXR1cm4gb2JqLnZhbHVlT2YoKTtcbiAgfVxuXG4gIHJldHVybiBjbG9uZU9iamVjdChvYmosIG9wdGlvbnMsIGlzQXJyYXlDaGlsZCk7XG59XG5tb2R1bGUuZXhwb3J0cyA9IGNsb25lO1xuXG4vKiFcbiAqIGlnbm9yZVxuICovXG5cbmZ1bmN0aW9uIGNsb25lT2JqZWN0KG9iaiwgb3B0aW9ucywgaXNBcnJheUNoaWxkKSB7XG4gIGNvbnN0IG1pbmltaXplID0gb3B0aW9ucyAmJiBvcHRpb25zLm1pbmltaXplO1xuICBjb25zdCBvbWl0VW5kZWZpbmVkID0gb3B0aW9ucyAmJiBvcHRpb25zLm9taXRVbmRlZmluZWQ7XG4gIGNvbnN0IHNlZW4gPSBvcHRpb25zICYmIG9wdGlvbnMuX3NlZW47XG4gIGNvbnN0IHJldCA9IHt9O1xuICBsZXQgaGFzS2V5cztcblxuICBpZiAoc2VlbiAmJiBzZWVuLmhhcyhvYmopKSB7XG4gICAgcmV0dXJuIHNlZW4uZ2V0KG9iaik7XG4gIH0gZWxzZSBpZiAoc2Vlbikge1xuICAgIHNlZW4uc2V0KG9iaiwgcmV0KTtcbiAgfVxuICBpZiAodHJ1c3RlZFN5bWJvbCBpbiBvYmopIHtcbiAgICByZXRbdHJ1c3RlZFN5bWJvbF0gPSBvYmpbdHJ1c3RlZFN5bWJvbF07XG4gIH1cblxuICBsZXQgaSA9IDA7XG4gIGxldCBrZXkgPSAnJztcbiAgY29uc3Qga2V5cyA9IE9iamVjdC5rZXlzKG9iaik7XG4gIGNvbnN0IGxlbiA9IGtleXMubGVuZ3RoO1xuXG4gIGZvciAoaSA9IDA7IGkgPCBsZW47ICsraSkge1xuICAgIGlmIChzcGVjaWFsUHJvcGVydGllcy5oYXMoa2V5ID0ga2V5c1tpXSkpIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIC8vIERvbid0IHBhc3MgYGlzQXJyYXlDaGlsZGAgZG93blxuICAgIGNvbnN0IHZhbCA9IGNsb25lKG9ialtrZXldLCBvcHRpb25zLCBmYWxzZSk7XG5cbiAgICBpZiAoKG1pbmltaXplID09PSBmYWxzZSB8fCBvbWl0VW5kZWZpbmVkKSAmJiB0eXBlb2YgdmFsID09PSAndW5kZWZpbmVkJykge1xuICAgICAgZGVsZXRlIHJldFtrZXldO1xuICAgIH0gZWxzZSBpZiAobWluaW1pemUgIT09IHRydWUgfHwgKHR5cGVvZiB2YWwgIT09ICd1bmRlZmluZWQnKSkge1xuICAgICAgaGFzS2V5cyB8fCAoaGFzS2V5cyA9IHRydWUpO1xuICAgICAgcmV0W2tleV0gPSB2YWw7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG1pbmltaXplICYmICFpc0FycmF5Q2hpbGQgPyBoYXNLZXlzICYmIHJldCA6IHJldDtcbn1cblxuZnVuY3Rpb24gY2xvbmVBcnJheShhcnIsIG9wdGlvbnMpIHtcbiAgbGV0IGkgPSAwO1xuICBjb25zdCBsZW4gPSBhcnIubGVuZ3RoO1xuICBjb25zdCByZXQgPSBuZXcgQXJyYXkobGVuKTtcbiAgZm9yIChpID0gMDsgaSA8IGxlbjsgKytpKSB7XG4gICAgcmV0W2ldID0gY2xvbmUoYXJyW2ldLCBvcHRpb25zLCB0cnVlKTtcbiAgfVxuXG4gIHJldHVybiByZXQ7XG59XG5cbmZ1bmN0aW9uIGNsb25lUmVnRXhwKHJlZ2V4cCkge1xuICBjb25zdCByZXQgPSBuZXcgUmVnRXhwKHJlZ2V4cC5zb3VyY2UsIHJlZ2V4cC5mbGFncyk7XG5cbiAgaWYgKHJldC5sYXN0SW5kZXggIT09IHJlZ2V4cC5sYXN0SW5kZXgpIHtcbiAgICByZXQubGFzdEluZGV4ID0gcmVnZXhwLmxhc3RJbmRleDtcbiAgfVxuICByZXR1cm4gcmV0O1xufVxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/mongoose/lib/helpers/clone.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/mongoose/lib/helpers/common.js":
/*!*****************************************************!*\
  !*** ./node_modules/mongoose/lib/helpers/common.js ***!
  \*****************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n\n/*!\n * Module dependencies.\n */\n\nconst Binary = (__webpack_require__(/*! bson */ \"(ssr)/./node_modules/bson/lib/bson.cjs\").Binary);\nconst isBsonType = __webpack_require__(/*! ./isBsonType */ \"(ssr)/./node_modules/mongoose/lib/helpers/isBsonType.js\");\nconst isMongooseObject = __webpack_require__(/*! ./isMongooseObject */ \"(ssr)/./node_modules/mongoose/lib/helpers/isMongooseObject.js\");\nconst MongooseError = __webpack_require__(/*! ../error */ \"(ssr)/./node_modules/mongoose/lib/error/index.js\");\nconst util = __webpack_require__(/*! util */ \"util\");\n\nexports.flatten = flatten;\nexports.modifiedPaths = modifiedPaths;\n\n/*!\n * ignore\n */\n\nfunction flatten(update, path, options, schema) {\n  let keys;\n  if (update && isMongooseObject(update) && !Buffer.isBuffer(update)) {\n    keys = Object.keys(update.toObject({ transform: false, virtuals: false }) || {});\n  } else {\n    keys = Object.keys(update || {});\n  }\n\n  const numKeys = keys.length;\n  const result = {};\n  path = path ? path + '.' : '';\n\n  for (let i = 0; i < numKeys; ++i) {\n    const key = keys[i];\n    const val = update[key];\n    result[path + key] = val;\n\n    // Avoid going into mixed paths if schema is specified\n    const keySchema = schema && schema.path && schema.path(path + key);\n    const isNested = schema && schema.nested && schema.nested[path + key];\n    if (keySchema && keySchema.instance === 'Mixed') continue;\n\n    if (shouldFlatten(val)) {\n      if (options && options.skipArrays && Array.isArray(val)) {\n        continue;\n      }\n      const flat = flatten(val, path + key, options, schema);\n      for (const k in flat) {\n        result[k] = flat[k];\n      }\n      if (Array.isArray(val)) {\n        result[path + key] = val;\n      }\n    }\n\n    if (isNested) {\n      const paths = Object.keys(schema.paths);\n      for (const p of paths) {\n        if (p.startsWith(path + key + '.') && !result.hasOwnProperty(p)) {\n          result[p] = void 0;\n        }\n      }\n    }\n  }\n\n  return result;\n}\n\n/*!\n * ignore\n */\n\nfunction modifiedPaths(update, path, result, recursion = null) {\n  if (update == null || typeof update !== 'object') {\n    return;\n  }\n\n  if (recursion == null) {\n    recursion = {\n      raw: { update, path },\n      trace: new WeakSet()\n    };\n  }\n\n  if (recursion.trace.has(update)) {\n    throw new MongooseError(`a circular reference in the update value, updateValue:\n${util.inspect(recursion.raw.update, { showHidden: false, depth: 1 })}\nupdatePath: '${recursion.raw.path}'`);\n  }\n  recursion.trace.add(update);\n\n  const keys = Object.keys(update || {});\n  const numKeys = keys.length;\n  result = result || {};\n  path = path ? path + '.' : '';\n\n  for (let i = 0; i < numKeys; ++i) {\n    const key = keys[i];\n    let val = update[key];\n\n    const _path = path + key;\n    result[_path] = true;\n    if (!Buffer.isBuffer(val) && isMongooseObject(val)) {\n      val = val.toObject({ transform: false, virtuals: false });\n    }\n    if (shouldFlatten(val)) {\n      modifiedPaths(val, path + key, result, recursion);\n    }\n  }\n  recursion.trace.delete(update);\n\n  return result;\n}\n\n/*!\n * ignore\n */\n\nfunction shouldFlatten(val) {\n  return val &&\n      typeof val === 'object' &&\n      !(val instanceof Date) &&\n      !isBsonType(val, 'ObjectId') &&\n      (!Array.isArray(val) || val.length !== 0) &&\n      !(val instanceof Buffer) &&\n      !isBsonType(val, 'Decimal128') &&\n      !(val instanceof Binary);\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbW9uZ29vc2UvbGliL2hlbHBlcnMvY29tbW9uLmpzIiwibWFwcGluZ3MiOiJBQUFhOztBQUViO0FBQ0E7QUFDQTs7QUFFQSxlQUFlLGtGQUFzQjtBQUNyQyxtQkFBbUIsbUJBQU8sQ0FBQyw2RUFBYztBQUN6Qyx5QkFBeUIsbUJBQU8sQ0FBQyx5RkFBb0I7QUFDckQsc0JBQXNCLG1CQUFPLENBQUMsa0VBQVU7QUFDeEMsYUFBYSxtQkFBTyxDQUFDLGtCQUFNOztBQUUzQixlQUFlO0FBQ2YscUJBQXFCOztBQUVyQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EseUNBQXlDLG1DQUFtQyxPQUFPO0FBQ25GLElBQUk7QUFDSixtQ0FBbUM7QUFDbkM7O0FBRUE7QUFDQTtBQUNBOztBQUVBLGtCQUFrQixhQUFhO0FBQy9CO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxhQUFhLGNBQWM7QUFDM0I7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxFQUFFLHFDQUFxQyw2QkFBNkI7QUFDcEUsZUFBZSxtQkFBbUI7QUFDbEM7QUFDQTs7QUFFQSx1Q0FBdUM7QUFDdkM7QUFDQTtBQUNBOztBQUVBLGtCQUFrQixhQUFhO0FBQy9CO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLG1DQUFtQztBQUM5RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9hcHAxLy4vbm9kZV9tb2R1bGVzL21vbmdvb3NlL2xpYi9oZWxwZXJzL2NvbW1vbi5qcz85NzllIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxuLyohXG4gKiBNb2R1bGUgZGVwZW5kZW5jaWVzLlxuICovXG5cbmNvbnN0IEJpbmFyeSA9IHJlcXVpcmUoJ2Jzb24nKS5CaW5hcnk7XG5jb25zdCBpc0Jzb25UeXBlID0gcmVxdWlyZSgnLi9pc0Jzb25UeXBlJyk7XG5jb25zdCBpc01vbmdvb3NlT2JqZWN0ID0gcmVxdWlyZSgnLi9pc01vbmdvb3NlT2JqZWN0Jyk7XG5jb25zdCBNb25nb29zZUVycm9yID0gcmVxdWlyZSgnLi4vZXJyb3InKTtcbmNvbnN0IHV0aWwgPSByZXF1aXJlKCd1dGlsJyk7XG5cbmV4cG9ydHMuZmxhdHRlbiA9IGZsYXR0ZW47XG5leHBvcnRzLm1vZGlmaWVkUGF0aHMgPSBtb2RpZmllZFBhdGhzO1xuXG4vKiFcbiAqIGlnbm9yZVxuICovXG5cbmZ1bmN0aW9uIGZsYXR0ZW4odXBkYXRlLCBwYXRoLCBvcHRpb25zLCBzY2hlbWEpIHtcbiAgbGV0IGtleXM7XG4gIGlmICh1cGRhdGUgJiYgaXNNb25nb29zZU9iamVjdCh1cGRhdGUpICYmICFCdWZmZXIuaXNCdWZmZXIodXBkYXRlKSkge1xuICAgIGtleXMgPSBPYmplY3Qua2V5cyh1cGRhdGUudG9PYmplY3QoeyB0cmFuc2Zvcm06IGZhbHNlLCB2aXJ0dWFsczogZmFsc2UgfSkgfHwge30pO1xuICB9IGVsc2Uge1xuICAgIGtleXMgPSBPYmplY3Qua2V5cyh1cGRhdGUgfHwge30pO1xuICB9XG5cbiAgY29uc3QgbnVtS2V5cyA9IGtleXMubGVuZ3RoO1xuICBjb25zdCByZXN1bHQgPSB7fTtcbiAgcGF0aCA9IHBhdGggPyBwYXRoICsgJy4nIDogJyc7XG5cbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBudW1LZXlzOyArK2kpIHtcbiAgICBjb25zdCBrZXkgPSBrZXlzW2ldO1xuICAgIGNvbnN0IHZhbCA9IHVwZGF0ZVtrZXldO1xuICAgIHJlc3VsdFtwYXRoICsga2V5XSA9IHZhbDtcblxuICAgIC8vIEF2b2lkIGdvaW5nIGludG8gbWl4ZWQgcGF0aHMgaWYgc2NoZW1hIGlzIHNwZWNpZmllZFxuICAgIGNvbnN0IGtleVNjaGVtYSA9IHNjaGVtYSAmJiBzY2hlbWEucGF0aCAmJiBzY2hlbWEucGF0aChwYXRoICsga2V5KTtcbiAgICBjb25zdCBpc05lc3RlZCA9IHNjaGVtYSAmJiBzY2hlbWEubmVzdGVkICYmIHNjaGVtYS5uZXN0ZWRbcGF0aCArIGtleV07XG4gICAgaWYgKGtleVNjaGVtYSAmJiBrZXlTY2hlbWEuaW5zdGFuY2UgPT09ICdNaXhlZCcpIGNvbnRpbnVlO1xuXG4gICAgaWYgKHNob3VsZEZsYXR0ZW4odmFsKSkge1xuICAgICAgaWYgKG9wdGlvbnMgJiYgb3B0aW9ucy5za2lwQXJyYXlzICYmIEFycmF5LmlzQXJyYXkodmFsKSkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGZsYXQgPSBmbGF0dGVuKHZhbCwgcGF0aCArIGtleSwgb3B0aW9ucywgc2NoZW1hKTtcbiAgICAgIGZvciAoY29uc3QgayBpbiBmbGF0KSB7XG4gICAgICAgIHJlc3VsdFtrXSA9IGZsYXRba107XG4gICAgICB9XG4gICAgICBpZiAoQXJyYXkuaXNBcnJheSh2YWwpKSB7XG4gICAgICAgIHJlc3VsdFtwYXRoICsga2V5XSA9IHZhbDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoaXNOZXN0ZWQpIHtcbiAgICAgIGNvbnN0IHBhdGhzID0gT2JqZWN0LmtleXMoc2NoZW1hLnBhdGhzKTtcbiAgICAgIGZvciAoY29uc3QgcCBvZiBwYXRocykge1xuICAgICAgICBpZiAocC5zdGFydHNXaXRoKHBhdGggKyBrZXkgKyAnLicpICYmICFyZXN1bHQuaGFzT3duUHJvcGVydHkocCkpIHtcbiAgICAgICAgICByZXN1bHRbcF0gPSB2b2lkIDA7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gcmVzdWx0O1xufVxuXG4vKiFcbiAqIGlnbm9yZVxuICovXG5cbmZ1bmN0aW9uIG1vZGlmaWVkUGF0aHModXBkYXRlLCBwYXRoLCByZXN1bHQsIHJlY3Vyc2lvbiA9IG51bGwpIHtcbiAgaWYgKHVwZGF0ZSA9PSBudWxsIHx8IHR5cGVvZiB1cGRhdGUgIT09ICdvYmplY3QnKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgaWYgKHJlY3Vyc2lvbiA9PSBudWxsKSB7XG4gICAgcmVjdXJzaW9uID0ge1xuICAgICAgcmF3OiB7IHVwZGF0ZSwgcGF0aCB9LFxuICAgICAgdHJhY2U6IG5ldyBXZWFrU2V0KClcbiAgICB9O1xuICB9XG5cbiAgaWYgKHJlY3Vyc2lvbi50cmFjZS5oYXModXBkYXRlKSkge1xuICAgIHRocm93IG5ldyBNb25nb29zZUVycm9yKGBhIGNpcmN1bGFyIHJlZmVyZW5jZSBpbiB0aGUgdXBkYXRlIHZhbHVlLCB1cGRhdGVWYWx1ZTpcbiR7dXRpbC5pbnNwZWN0KHJlY3Vyc2lvbi5yYXcudXBkYXRlLCB7IHNob3dIaWRkZW46IGZhbHNlLCBkZXB0aDogMSB9KX1cbnVwZGF0ZVBhdGg6ICcke3JlY3Vyc2lvbi5yYXcucGF0aH0nYCk7XG4gIH1cbiAgcmVjdXJzaW9uLnRyYWNlLmFkZCh1cGRhdGUpO1xuXG4gIGNvbnN0IGtleXMgPSBPYmplY3Qua2V5cyh1cGRhdGUgfHwge30pO1xuICBjb25zdCBudW1LZXlzID0ga2V5cy5sZW5ndGg7XG4gIHJlc3VsdCA9IHJlc3VsdCB8fCB7fTtcbiAgcGF0aCA9IHBhdGggPyBwYXRoICsgJy4nIDogJyc7XG5cbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBudW1LZXlzOyArK2kpIHtcbiAgICBjb25zdCBrZXkgPSBrZXlzW2ldO1xuICAgIGxldCB2YWwgPSB1cGRhdGVba2V5XTtcblxuICAgIGNvbnN0IF9wYXRoID0gcGF0aCArIGtleTtcbiAgICByZXN1bHRbX3BhdGhdID0gdHJ1ZTtcbiAgICBpZiAoIUJ1ZmZlci5pc0J1ZmZlcih2YWwpICYmIGlzTW9uZ29vc2VPYmplY3QodmFsKSkge1xuICAgICAgdmFsID0gdmFsLnRvT2JqZWN0KHsgdHJhbnNmb3JtOiBmYWxzZSwgdmlydHVhbHM6IGZhbHNlIH0pO1xuICAgIH1cbiAgICBpZiAoc2hvdWxkRmxhdHRlbih2YWwpKSB7XG4gICAgICBtb2RpZmllZFBhdGhzKHZhbCwgcGF0aCArIGtleSwgcmVzdWx0LCByZWN1cnNpb24pO1xuICAgIH1cbiAgfVxuICByZWN1cnNpb24udHJhY2UuZGVsZXRlKHVwZGF0ZSk7XG5cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuLyohXG4gKiBpZ25vcmVcbiAqL1xuXG5mdW5jdGlvbiBzaG91bGRGbGF0dGVuKHZhbCkge1xuICByZXR1cm4gdmFsICYmXG4gICAgICB0eXBlb2YgdmFsID09PSAnb2JqZWN0JyAmJlxuICAgICAgISh2YWwgaW5zdGFuY2VvZiBEYXRlKSAmJlxuICAgICAgIWlzQnNvblR5cGUodmFsLCAnT2JqZWN0SWQnKSAmJlxuICAgICAgKCFBcnJheS5pc0FycmF5KHZhbCkgfHwgdmFsLmxlbmd0aCAhPT0gMCkgJiZcbiAgICAgICEodmFsIGluc3RhbmNlb2YgQnVmZmVyKSAmJlxuICAgICAgIWlzQnNvblR5cGUodmFsLCAnRGVjaW1hbDEyOCcpICYmXG4gICAgICAhKHZhbCBpbnN0YW5jZW9mIEJpbmFyeSk7XG59XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/mongoose/lib/helpers/common.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/mongoose/lib/helpers/cursor/eachAsync.js":
/*!***************************************************************!*\
  !*** ./node_modules/mongoose/lib/helpers/cursor/eachAsync.js ***!
  \***************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\n\n/*!\n * Module dependencies.\n */\n\nconst EachAsyncMultiError = __webpack_require__(/*! ../../error/eachAsyncMultiError */ \"(ssr)/./node_modules/mongoose/lib/error/eachAsyncMultiError.js\");\nconst immediate = __webpack_require__(/*! ../immediate */ \"(ssr)/./node_modules/mongoose/lib/helpers/immediate.js\");\n\n/**\n * Execute `fn` for every document in the cursor. If `fn` returns a promise,\n * will wait for the promise to resolve before iterating on to the next one.\n * Returns a promise that resolves when done.\n *\n * @param {Function} next the thunk to call to get the next document\n * @param {Function} fn\n * @param {Object} options\n * @param {Number} [options.batchSize=null] if set, Mongoose will call `fn` with an array of at most `batchSize` documents, instead of a single document\n * @param {Number} [options.parallel=1] maximum number of `fn` calls that Mongoose will run in parallel\n * @param {AbortSignal} [options.signal] allow cancelling this eachAsync(). Once the abort signal is fired, `eachAsync()` will immediately fulfill the returned promise (or call the callback) and not fetch any more documents.\n * @return {Promise}\n * @api public\n * @method eachAsync\n */\n\nmodule.exports = async function eachAsync(next, fn, options) {\n  const parallel = options.parallel || 1;\n  const batchSize = options.batchSize;\n  const signal = options.signal;\n  const continueOnError = options.continueOnError;\n  const aggregatedErrors = [];\n  const enqueue = asyncQueue();\n\n  let aborted = false;\n\n  return new Promise((resolve, reject) => {\n    if (signal != null) {\n      if (signal.aborted) {\n        return resolve(null);\n      }\n\n      signal.addEventListener('abort', () => {\n        aborted = true;\n        return resolve(null);\n      }, { once: true });\n    }\n\n    if (batchSize != null) {\n      if (typeof batchSize !== 'number') {\n        throw new TypeError('batchSize must be a number');\n      } else if (!Number.isInteger(batchSize)) {\n        throw new TypeError('batchSize must be an integer');\n      } else if (batchSize < 1) {\n        throw new TypeError('batchSize must be at least 1');\n      }\n    }\n\n    iterate((err, res) => {\n      if (err != null) {\n        return reject(err);\n      }\n      resolve(res);\n    });\n  });\n\n  function iterate(finalCallback) {\n    let handleResultsInProgress = 0;\n    let currentDocumentIndex = 0;\n\n    let error = null;\n    for (let i = 0; i < parallel; ++i) {\n      enqueue(createFetch());\n    }\n\n    function createFetch() {\n      let documentsBatch = [];\n      let drained = false;\n\n      return fetch;\n\n      function fetch(done) {\n        if (drained || aborted) {\n          return done();\n        } else if (error) {\n          return done();\n        }\n\n        next(function(err, doc) {\n          if (error != null) {\n            return done();\n          }\n          if (err != null) {\n            if (err.name === 'MongoCursorExhaustedError') {\n              // We may end up calling `next()` multiple times on an exhausted\n              // cursor, which leads to an error. In case cursor is exhausted,\n              // just treat it as if the cursor returned no document, which is\n              // how a cursor indicates it is exhausted.\n              doc = null;\n            } else if (continueOnError) {\n              aggregatedErrors.push(err);\n            } else {\n              error = err;\n              finalCallback(err);\n              return done();\n            }\n          }\n          if (doc == null) {\n            drained = true;\n            if (handleResultsInProgress <= 0) {\n              const finalErr = continueOnError ?\n                createEachAsyncMultiError(aggregatedErrors) :\n                error;\n\n              finalCallback(finalErr);\n            } else if (batchSize && documentsBatch.length) {\n              handleNextResult(documentsBatch, currentDocumentIndex++, handleNextResultCallBack);\n            }\n            return done();\n          }\n\n          ++handleResultsInProgress;\n\n          // Kick off the subsequent `next()` before handling the result, but\n          // make sure we know that we still have a result to handle re: #8422\n          immediate(() => done());\n\n          if (batchSize) {\n            documentsBatch.push(doc);\n          }\n\n          // If the current documents size is less than the provided batch size don't process the documents yet\n          if (batchSize && documentsBatch.length !== batchSize) {\n            immediate(() => enqueue(fetch));\n            return;\n          }\n\n          const docsToProcess = batchSize ? documentsBatch : doc;\n\n          function handleNextResultCallBack(err) {\n            if (batchSize) {\n              handleResultsInProgress -= documentsBatch.length;\n              documentsBatch = [];\n            } else {\n              --handleResultsInProgress;\n            }\n            if (err != null) {\n              if (continueOnError) {\n                aggregatedErrors.push(err);\n              } else {\n                error = err;\n                return finalCallback(err);\n              }\n            }\n            if ((drained || aborted) && handleResultsInProgress <= 0) {\n              const finalErr = continueOnError ?\n                createEachAsyncMultiError(aggregatedErrors) :\n                error;\n              return finalCallback(finalErr);\n            }\n\n            immediate(() => enqueue(fetch));\n          }\n\n          handleNextResult(docsToProcess, currentDocumentIndex++, handleNextResultCallBack);\n        });\n      }\n    }\n  }\n\n  function handleNextResult(doc, i, callback) {\n    let maybePromise;\n    try {\n      maybePromise = fn(doc, i);\n    } catch (err) {\n      return callback(err);\n    }\n    if (maybePromise && typeof maybePromise.then === 'function') {\n      maybePromise.then(\n        function() { callback(null); },\n        function(error) {\n          callback(error || new Error('`eachAsync()` promise rejected without error'));\n        });\n    } else {\n      callback(null);\n    }\n  }\n};\n\n// `next()` can only execute one at a time, so make sure we always execute\n// `next()` in series, while still allowing multiple `fn()` instances to run\n// in parallel.\nfunction asyncQueue() {\n  const _queue = [];\n  let inProgress = null;\n  let id = 0;\n\n  return function enqueue(fn) {\n    if (\n      inProgress === null &&\n      _queue.length === 0\n    ) {\n      inProgress = id++;\n      return fn(_step);\n    }\n    _queue.push(fn);\n  };\n\n  function _step() {\n    if (_queue.length !== 0) {\n      inProgress = id++;\n      const fn = _queue.shift();\n      fn(_step);\n    } else {\n      inProgress = null;\n    }\n  }\n}\n\nfunction createEachAsyncMultiError(aggregatedErrors) {\n  if (aggregatedErrors.length === 0) {\n    return null;\n  }\n\n  return new EachAsyncMultiError(aggregatedErrors);\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbW9uZ29vc2UvbGliL2hlbHBlcnMvY3Vyc29yL2VhY2hBc3luYy5qcyIsIm1hcHBpbmdzIjoiQUFBYTs7QUFFYjtBQUNBO0FBQ0E7O0FBRUEsNEJBQTRCLG1CQUFPLENBQUMsdUdBQWlDO0FBQ3JFLGtCQUFrQixtQkFBTyxDQUFDLDRFQUFjOztBQUV4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxVQUFVO0FBQ3JCLFdBQVcsVUFBVTtBQUNyQixXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixXQUFXLGFBQWE7QUFDeEIsWUFBWTtBQUNaO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE9BQU8sSUFBSSxZQUFZO0FBQ3ZCOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxHQUFHOztBQUVIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLG9CQUFvQixjQUFjO0FBQ2xDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQixpQkFBaUI7QUFDdEM7QUFDQTtBQUNBLFNBQVM7QUFDVCxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vYXBwMS8uL25vZGVfbW9kdWxlcy9tb25nb29zZS9saWIvaGVscGVycy9jdXJzb3IvZWFjaEFzeW5jLmpzPzljOTIiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG4vKiFcbiAqIE1vZHVsZSBkZXBlbmRlbmNpZXMuXG4gKi9cblxuY29uc3QgRWFjaEFzeW5jTXVsdGlFcnJvciA9IHJlcXVpcmUoJy4uLy4uL2Vycm9yL2VhY2hBc3luY011bHRpRXJyb3InKTtcbmNvbnN0IGltbWVkaWF0ZSA9IHJlcXVpcmUoJy4uL2ltbWVkaWF0ZScpO1xuXG4vKipcbiAqIEV4ZWN1dGUgYGZuYCBmb3IgZXZlcnkgZG9jdW1lbnQgaW4gdGhlIGN1cnNvci4gSWYgYGZuYCByZXR1cm5zIGEgcHJvbWlzZSxcbiAqIHdpbGwgd2FpdCBmb3IgdGhlIHByb21pc2UgdG8gcmVzb2x2ZSBiZWZvcmUgaXRlcmF0aW5nIG9uIHRvIHRoZSBuZXh0IG9uZS5cbiAqIFJldHVybnMgYSBwcm9taXNlIHRoYXQgcmVzb2x2ZXMgd2hlbiBkb25lLlxuICpcbiAqIEBwYXJhbSB7RnVuY3Rpb259IG5leHQgdGhlIHRodW5rIHRvIGNhbGwgdG8gZ2V0IHRoZSBuZXh0IGRvY3VtZW50XG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmblxuICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcbiAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy5iYXRjaFNpemU9bnVsbF0gaWYgc2V0LCBNb25nb29zZSB3aWxsIGNhbGwgYGZuYCB3aXRoIGFuIGFycmF5IG9mIGF0IG1vc3QgYGJhdGNoU2l6ZWAgZG9jdW1lbnRzLCBpbnN0ZWFkIG9mIGEgc2luZ2xlIGRvY3VtZW50XG4gKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMucGFyYWxsZWw9MV0gbWF4aW11bSBudW1iZXIgb2YgYGZuYCBjYWxscyB0aGF0IE1vbmdvb3NlIHdpbGwgcnVuIGluIHBhcmFsbGVsXG4gKiBAcGFyYW0ge0Fib3J0U2lnbmFsfSBbb3B0aW9ucy5zaWduYWxdIGFsbG93IGNhbmNlbGxpbmcgdGhpcyBlYWNoQXN5bmMoKS4gT25jZSB0aGUgYWJvcnQgc2lnbmFsIGlzIGZpcmVkLCBgZWFjaEFzeW5jKClgIHdpbGwgaW1tZWRpYXRlbHkgZnVsZmlsbCB0aGUgcmV0dXJuZWQgcHJvbWlzZSAob3IgY2FsbCB0aGUgY2FsbGJhY2spIGFuZCBub3QgZmV0Y2ggYW55IG1vcmUgZG9jdW1lbnRzLlxuICogQHJldHVybiB7UHJvbWlzZX1cbiAqIEBhcGkgcHVibGljXG4gKiBAbWV0aG9kIGVhY2hBc3luY1xuICovXG5cbm1vZHVsZS5leHBvcnRzID0gYXN5bmMgZnVuY3Rpb24gZWFjaEFzeW5jKG5leHQsIGZuLCBvcHRpb25zKSB7XG4gIGNvbnN0IHBhcmFsbGVsID0gb3B0aW9ucy5wYXJhbGxlbCB8fCAxO1xuICBjb25zdCBiYXRjaFNpemUgPSBvcHRpb25zLmJhdGNoU2l6ZTtcbiAgY29uc3Qgc2lnbmFsID0gb3B0aW9ucy5zaWduYWw7XG4gIGNvbnN0IGNvbnRpbnVlT25FcnJvciA9IG9wdGlvbnMuY29udGludWVPbkVycm9yO1xuICBjb25zdCBhZ2dyZWdhdGVkRXJyb3JzID0gW107XG4gIGNvbnN0IGVucXVldWUgPSBhc3luY1F1ZXVlKCk7XG5cbiAgbGV0IGFib3J0ZWQgPSBmYWxzZTtcblxuICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgIGlmIChzaWduYWwgIT0gbnVsbCkge1xuICAgICAgaWYgKHNpZ25hbC5hYm9ydGVkKSB7XG4gICAgICAgIHJldHVybiByZXNvbHZlKG51bGwpO1xuICAgICAgfVxuXG4gICAgICBzaWduYWwuYWRkRXZlbnRMaXN0ZW5lcignYWJvcnQnLCAoKSA9PiB7XG4gICAgICAgIGFib3J0ZWQgPSB0cnVlO1xuICAgICAgICByZXR1cm4gcmVzb2x2ZShudWxsKTtcbiAgICAgIH0sIHsgb25jZTogdHJ1ZSB9KTtcbiAgICB9XG5cbiAgICBpZiAoYmF0Y2hTaXplICE9IG51bGwpIHtcbiAgICAgIGlmICh0eXBlb2YgYmF0Y2hTaXplICE9PSAnbnVtYmVyJykge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdiYXRjaFNpemUgbXVzdCBiZSBhIG51bWJlcicpO1xuICAgICAgfSBlbHNlIGlmICghTnVtYmVyLmlzSW50ZWdlcihiYXRjaFNpemUpKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2JhdGNoU2l6ZSBtdXN0IGJlIGFuIGludGVnZXInKTtcbiAgICAgIH0gZWxzZSBpZiAoYmF0Y2hTaXplIDwgMSkge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdiYXRjaFNpemUgbXVzdCBiZSBhdCBsZWFzdCAxJyk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaXRlcmF0ZSgoZXJyLCByZXMpID0+IHtcbiAgICAgIGlmIChlcnIgIT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gcmVqZWN0KGVycik7XG4gICAgICB9XG4gICAgICByZXNvbHZlKHJlcyk7XG4gICAgfSk7XG4gIH0pO1xuXG4gIGZ1bmN0aW9uIGl0ZXJhdGUoZmluYWxDYWxsYmFjaykge1xuICAgIGxldCBoYW5kbGVSZXN1bHRzSW5Qcm9ncmVzcyA9IDA7XG4gICAgbGV0IGN1cnJlbnREb2N1bWVudEluZGV4ID0gMDtcblxuICAgIGxldCBlcnJvciA9IG51bGw7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBwYXJhbGxlbDsgKytpKSB7XG4gICAgICBlbnF1ZXVlKGNyZWF0ZUZldGNoKCkpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGNyZWF0ZUZldGNoKCkge1xuICAgICAgbGV0IGRvY3VtZW50c0JhdGNoID0gW107XG4gICAgICBsZXQgZHJhaW5lZCA9IGZhbHNlO1xuXG4gICAgICByZXR1cm4gZmV0Y2g7XG5cbiAgICAgIGZ1bmN0aW9uIGZldGNoKGRvbmUpIHtcbiAgICAgICAgaWYgKGRyYWluZWQgfHwgYWJvcnRlZCkge1xuICAgICAgICAgIHJldHVybiBkb25lKCk7XG4gICAgICAgIH0gZWxzZSBpZiAoZXJyb3IpIHtcbiAgICAgICAgICByZXR1cm4gZG9uZSgpO1xuICAgICAgICB9XG5cbiAgICAgICAgbmV4dChmdW5jdGlvbihlcnIsIGRvYykge1xuICAgICAgICAgIGlmIChlcnJvciAhPSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gZG9uZSgpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoZXJyICE9IG51bGwpIHtcbiAgICAgICAgICAgIGlmIChlcnIubmFtZSA9PT0gJ01vbmdvQ3Vyc29yRXhoYXVzdGVkRXJyb3InKSB7XG4gICAgICAgICAgICAgIC8vIFdlIG1heSBlbmQgdXAgY2FsbGluZyBgbmV4dCgpYCBtdWx0aXBsZSB0aW1lcyBvbiBhbiBleGhhdXN0ZWRcbiAgICAgICAgICAgICAgLy8gY3Vyc29yLCB3aGljaCBsZWFkcyB0byBhbiBlcnJvci4gSW4gY2FzZSBjdXJzb3IgaXMgZXhoYXVzdGVkLFxuICAgICAgICAgICAgICAvLyBqdXN0IHRyZWF0IGl0IGFzIGlmIHRoZSBjdXJzb3IgcmV0dXJuZWQgbm8gZG9jdW1lbnQsIHdoaWNoIGlzXG4gICAgICAgICAgICAgIC8vIGhvdyBhIGN1cnNvciBpbmRpY2F0ZXMgaXQgaXMgZXhoYXVzdGVkLlxuICAgICAgICAgICAgICBkb2MgPSBudWxsO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChjb250aW51ZU9uRXJyb3IpIHtcbiAgICAgICAgICAgICAgYWdncmVnYXRlZEVycm9ycy5wdXNoKGVycik7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBlcnJvciA9IGVycjtcbiAgICAgICAgICAgICAgZmluYWxDYWxsYmFjayhlcnIpO1xuICAgICAgICAgICAgICByZXR1cm4gZG9uZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoZG9jID09IG51bGwpIHtcbiAgICAgICAgICAgIGRyYWluZWQgPSB0cnVlO1xuICAgICAgICAgICAgaWYgKGhhbmRsZVJlc3VsdHNJblByb2dyZXNzIDw9IDApIHtcbiAgICAgICAgICAgICAgY29uc3QgZmluYWxFcnIgPSBjb250aW51ZU9uRXJyb3IgP1xuICAgICAgICAgICAgICAgIGNyZWF0ZUVhY2hBc3luY011bHRpRXJyb3IoYWdncmVnYXRlZEVycm9ycykgOlxuICAgICAgICAgICAgICAgIGVycm9yO1xuXG4gICAgICAgICAgICAgIGZpbmFsQ2FsbGJhY2soZmluYWxFcnIpO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChiYXRjaFNpemUgJiYgZG9jdW1lbnRzQmF0Y2gubGVuZ3RoKSB7XG4gICAgICAgICAgICAgIGhhbmRsZU5leHRSZXN1bHQoZG9jdW1lbnRzQmF0Y2gsIGN1cnJlbnREb2N1bWVudEluZGV4KyssIGhhbmRsZU5leHRSZXN1bHRDYWxsQmFjayk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gZG9uZSgpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgICsraGFuZGxlUmVzdWx0c0luUHJvZ3Jlc3M7XG5cbiAgICAgICAgICAvLyBLaWNrIG9mZiB0aGUgc3Vic2VxdWVudCBgbmV4dCgpYCBiZWZvcmUgaGFuZGxpbmcgdGhlIHJlc3VsdCwgYnV0XG4gICAgICAgICAgLy8gbWFrZSBzdXJlIHdlIGtub3cgdGhhdCB3ZSBzdGlsbCBoYXZlIGEgcmVzdWx0IHRvIGhhbmRsZSByZTogIzg0MjJcbiAgICAgICAgICBpbW1lZGlhdGUoKCkgPT4gZG9uZSgpKTtcblxuICAgICAgICAgIGlmIChiYXRjaFNpemUpIHtcbiAgICAgICAgICAgIGRvY3VtZW50c0JhdGNoLnB1c2goZG9jKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICAvLyBJZiB0aGUgY3VycmVudCBkb2N1bWVudHMgc2l6ZSBpcyBsZXNzIHRoYW4gdGhlIHByb3ZpZGVkIGJhdGNoIHNpemUgZG9uJ3QgcHJvY2VzcyB0aGUgZG9jdW1lbnRzIHlldFxuICAgICAgICAgIGlmIChiYXRjaFNpemUgJiYgZG9jdW1lbnRzQmF0Y2gubGVuZ3RoICE9PSBiYXRjaFNpemUpIHtcbiAgICAgICAgICAgIGltbWVkaWF0ZSgoKSA9PiBlbnF1ZXVlKGZldGNoKSk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgY29uc3QgZG9jc1RvUHJvY2VzcyA9IGJhdGNoU2l6ZSA/IGRvY3VtZW50c0JhdGNoIDogZG9jO1xuXG4gICAgICAgICAgZnVuY3Rpb24gaGFuZGxlTmV4dFJlc3VsdENhbGxCYWNrKGVycikge1xuICAgICAgICAgICAgaWYgKGJhdGNoU2l6ZSkge1xuICAgICAgICAgICAgICBoYW5kbGVSZXN1bHRzSW5Qcm9ncmVzcyAtPSBkb2N1bWVudHNCYXRjaC5sZW5ndGg7XG4gICAgICAgICAgICAgIGRvY3VtZW50c0JhdGNoID0gW107XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAtLWhhbmRsZVJlc3VsdHNJblByb2dyZXNzO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGVyciAhPSBudWxsKSB7XG4gICAgICAgICAgICAgIGlmIChjb250aW51ZU9uRXJyb3IpIHtcbiAgICAgICAgICAgICAgICBhZ2dyZWdhdGVkRXJyb3JzLnB1c2goZXJyKTtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBlcnJvciA9IGVycjtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmluYWxDYWxsYmFjayhlcnIpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoKGRyYWluZWQgfHwgYWJvcnRlZCkgJiYgaGFuZGxlUmVzdWx0c0luUHJvZ3Jlc3MgPD0gMCkge1xuICAgICAgICAgICAgICBjb25zdCBmaW5hbEVyciA9IGNvbnRpbnVlT25FcnJvciA/XG4gICAgICAgICAgICAgICAgY3JlYXRlRWFjaEFzeW5jTXVsdGlFcnJvcihhZ2dyZWdhdGVkRXJyb3JzKSA6XG4gICAgICAgICAgICAgICAgZXJyb3I7XG4gICAgICAgICAgICAgIHJldHVybiBmaW5hbENhbGxiYWNrKGZpbmFsRXJyKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaW1tZWRpYXRlKCgpID0+IGVucXVldWUoZmV0Y2gpKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBoYW5kbGVOZXh0UmVzdWx0KGRvY3NUb1Byb2Nlc3MsIGN1cnJlbnREb2N1bWVudEluZGV4KyssIGhhbmRsZU5leHRSZXN1bHRDYWxsQmFjayk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGhhbmRsZU5leHRSZXN1bHQoZG9jLCBpLCBjYWxsYmFjaykge1xuICAgIGxldCBtYXliZVByb21pc2U7XG4gICAgdHJ5IHtcbiAgICAgIG1heWJlUHJvbWlzZSA9IGZuKGRvYywgaSk7XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICByZXR1cm4gY2FsbGJhY2soZXJyKTtcbiAgICB9XG4gICAgaWYgKG1heWJlUHJvbWlzZSAmJiB0eXBlb2YgbWF5YmVQcm9taXNlLnRoZW4gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIG1heWJlUHJvbWlzZS50aGVuKFxuICAgICAgICBmdW5jdGlvbigpIHsgY2FsbGJhY2sobnVsbCk7IH0sXG4gICAgICAgIGZ1bmN0aW9uKGVycm9yKSB7XG4gICAgICAgICAgY2FsbGJhY2soZXJyb3IgfHwgbmV3IEVycm9yKCdgZWFjaEFzeW5jKClgIHByb21pc2UgcmVqZWN0ZWQgd2l0aG91dCBlcnJvcicpKTtcbiAgICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNhbGxiYWNrKG51bGwpO1xuICAgIH1cbiAgfVxufTtcblxuLy8gYG5leHQoKWAgY2FuIG9ubHkgZXhlY3V0ZSBvbmUgYXQgYSB0aW1lLCBzbyBtYWtlIHN1cmUgd2UgYWx3YXlzIGV4ZWN1dGVcbi8vIGBuZXh0KClgIGluIHNlcmllcywgd2hpbGUgc3RpbGwgYWxsb3dpbmcgbXVsdGlwbGUgYGZuKClgIGluc3RhbmNlcyB0byBydW5cbi8vIGluIHBhcmFsbGVsLlxuZnVuY3Rpb24gYXN5bmNRdWV1ZSgpIHtcbiAgY29uc3QgX3F1ZXVlID0gW107XG4gIGxldCBpblByb2dyZXNzID0gbnVsbDtcbiAgbGV0IGlkID0gMDtcblxuICByZXR1cm4gZnVuY3Rpb24gZW5xdWV1ZShmbikge1xuICAgIGlmIChcbiAgICAgIGluUHJvZ3Jlc3MgPT09IG51bGwgJiZcbiAgICAgIF9xdWV1ZS5sZW5ndGggPT09IDBcbiAgICApIHtcbiAgICAgIGluUHJvZ3Jlc3MgPSBpZCsrO1xuICAgICAgcmV0dXJuIGZuKF9zdGVwKTtcbiAgICB9XG4gICAgX3F1ZXVlLnB1c2goZm4pO1xuICB9O1xuXG4gIGZ1bmN0aW9uIF9zdGVwKCkge1xuICAgIGlmIChfcXVldWUubGVuZ3RoICE9PSAwKSB7XG4gICAgICBpblByb2dyZXNzID0gaWQrKztcbiAgICAgIGNvbnN0IGZuID0gX3F1ZXVlLnNoaWZ0KCk7XG4gICAgICBmbihfc3RlcCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGluUHJvZ3Jlc3MgPSBudWxsO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBjcmVhdGVFYWNoQXN5bmNNdWx0aUVycm9yKGFnZ3JlZ2F0ZWRFcnJvcnMpIHtcbiAgaWYgKGFnZ3JlZ2F0ZWRFcnJvcnMubGVuZ3RoID09PSAwKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICByZXR1cm4gbmV3IEVhY2hBc3luY011bHRpRXJyb3IoYWdncmVnYXRlZEVycm9ycyk7XG59XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/mongoose/lib/helpers/cursor/eachAsync.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/mongoose/lib/helpers/discriminator/areDiscriminatorValuesEqual.js":
/*!****************************************************************************************!*\
  !*** ./node_modules/mongoose/lib/helpers/discriminator/areDiscriminatorValuesEqual.js ***!
  \****************************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\n\nconst isBsonType = __webpack_require__(/*! ../isBsonType */ \"(ssr)/./node_modules/mongoose/lib/helpers/isBsonType.js\");\n\nmodule.exports = function areDiscriminatorValuesEqual(a, b) {\n  if (typeof a === 'string' && typeof b === 'string') {\n    return a === b;\n  }\n  if (typeof a === 'number' && typeof b === 'number') {\n    return a === b;\n  }\n  if (isBsonType(a, 'ObjectId') && isBsonType(b, 'ObjectId')) {\n    return a.toString() === b.toString();\n  }\n  return false;\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbW9uZ29vc2UvbGliL2hlbHBlcnMvZGlzY3JpbWluYXRvci9hcmVEaXNjcmltaW5hdG9yVmFsdWVzRXF1YWwuanMiLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWIsbUJBQW1CLG1CQUFPLENBQUMsOEVBQWU7O0FBRTFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL2FwcDEvLi9ub2RlX21vZHVsZXMvbW9uZ29vc2UvbGliL2hlbHBlcnMvZGlzY3JpbWluYXRvci9hcmVEaXNjcmltaW5hdG9yVmFsdWVzRXF1YWwuanM/MDcwZiJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbmNvbnN0IGlzQnNvblR5cGUgPSByZXF1aXJlKCcuLi9pc0Jzb25UeXBlJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gYXJlRGlzY3JpbWluYXRvclZhbHVlc0VxdWFsKGEsIGIpIHtcbiAgaWYgKHR5cGVvZiBhID09PSAnc3RyaW5nJyAmJiB0eXBlb2YgYiA9PT0gJ3N0cmluZycpIHtcbiAgICByZXR1cm4gYSA9PT0gYjtcbiAgfVxuICBpZiAodHlwZW9mIGEgPT09ICdudW1iZXInICYmIHR5cGVvZiBiID09PSAnbnVtYmVyJykge1xuICAgIHJldHVybiBhID09PSBiO1xuICB9XG4gIGlmIChpc0Jzb25UeXBlKGEsICdPYmplY3RJZCcpICYmIGlzQnNvblR5cGUoYiwgJ09iamVjdElkJykpIHtcbiAgICByZXR1cm4gYS50b1N0cmluZygpID09PSBiLnRvU3RyaW5nKCk7XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/mongoose/lib/helpers/discriminator/areDiscriminatorValuesEqual.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/mongoose/lib/helpers/discriminator/checkEmbeddedDiscriminatorKeyProjection.js":
/*!****************************************************************************************************!*\
  !*** ./node_modules/mongoose/lib/helpers/discriminator/checkEmbeddedDiscriminatorKeyProjection.js ***!
  \****************************************************************************************************/
/***/ ((module) => {

eval("\n\nmodule.exports = function checkEmbeddedDiscriminatorKeyProjection(userProjection, path, schema, selected, addedPaths) {\n  const userProjectedInPath = Object.keys(userProjection).\n    reduce((cur, key) => cur || key.startsWith(path + '.'), false);\n  const _discriminatorKey = path + '.' + schema.options.discriminatorKey;\n  if (!userProjectedInPath &&\n      addedPaths.length === 1 &&\n      addedPaths[0] === _discriminatorKey) {\n    selected.splice(selected.indexOf(_discriminatorKey), 1);\n  }\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbW9uZ29vc2UvbGliL2hlbHBlcnMvZGlzY3JpbWluYXRvci9jaGVja0VtYmVkZGVkRGlzY3JpbWluYXRvcktleVByb2plY3Rpb24uanMiLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9hcHAxLy4vbm9kZV9tb2R1bGVzL21vbmdvb3NlL2xpYi9oZWxwZXJzL2Rpc2NyaW1pbmF0b3IvY2hlY2tFbWJlZGRlZERpc2NyaW1pbmF0b3JLZXlQcm9qZWN0aW9uLmpzP2NlNzYiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGNoZWNrRW1iZWRkZWREaXNjcmltaW5hdG9yS2V5UHJvamVjdGlvbih1c2VyUHJvamVjdGlvbiwgcGF0aCwgc2NoZW1hLCBzZWxlY3RlZCwgYWRkZWRQYXRocykge1xuICBjb25zdCB1c2VyUHJvamVjdGVkSW5QYXRoID0gT2JqZWN0LmtleXModXNlclByb2plY3Rpb24pLlxuICAgIHJlZHVjZSgoY3VyLCBrZXkpID0+IGN1ciB8fCBrZXkuc3RhcnRzV2l0aChwYXRoICsgJy4nKSwgZmFsc2UpO1xuICBjb25zdCBfZGlzY3JpbWluYXRvcktleSA9IHBhdGggKyAnLicgKyBzY2hlbWEub3B0aW9ucy5kaXNjcmltaW5hdG9yS2V5O1xuICBpZiAoIXVzZXJQcm9qZWN0ZWRJblBhdGggJiZcbiAgICAgIGFkZGVkUGF0aHMubGVuZ3RoID09PSAxICYmXG4gICAgICBhZGRlZFBhdGhzWzBdID09PSBfZGlzY3JpbWluYXRvcktleSkge1xuICAgIHNlbGVjdGVkLnNwbGljZShzZWxlY3RlZC5pbmRleE9mKF9kaXNjcmltaW5hdG9yS2V5KSwgMSk7XG4gIH1cbn07XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/mongoose/lib/helpers/discriminator/checkEmbeddedDiscriminatorKeyProjection.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/mongoose/lib/helpers/discriminator/getConstructor.js":
/*!***************************************************************************!*\
  !*** ./node_modules/mongoose/lib/helpers/discriminator/getConstructor.js ***!
  \***************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\n\nconst getDiscriminatorByValue = __webpack_require__(/*! ./getDiscriminatorByValue */ \"(ssr)/./node_modules/mongoose/lib/helpers/discriminator/getDiscriminatorByValue.js\");\n\n/**\n * Find the correct constructor, taking into account discriminators\n * @api private\n */\n\nmodule.exports = function getConstructor(Constructor, value, defaultDiscriminatorValue) {\n  const discriminatorKey = Constructor.schema.options.discriminatorKey;\n  let discriminatorValue = (value != null && value[discriminatorKey]);\n  if (discriminatorValue == null) {\n    discriminatorValue = defaultDiscriminatorValue;\n  }\n  if (Constructor.discriminators &&\n      discriminatorValue != null) {\n    if (Constructor.discriminators[discriminatorValue]) {\n      Constructor = Constructor.discriminators[discriminatorValue];\n    } else {\n      const constructorByValue = getDiscriminatorByValue(Constructor.discriminators, discriminatorValue);\n      if (constructorByValue) {\n        Constructor = constructorByValue;\n      }\n    }\n  }\n\n  return Constructor;\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbW9uZ29vc2UvbGliL2hlbHBlcnMvZGlzY3JpbWluYXRvci9nZXRDb25zdHJ1Y3Rvci5qcyIsIm1hcHBpbmdzIjoiQUFBYTs7QUFFYixnQ0FBZ0MsbUJBQU8sQ0FBQyxxSEFBMkI7O0FBRW5FO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vYXBwMS8uL25vZGVfbW9kdWxlcy9tb25nb29zZS9saWIvaGVscGVycy9kaXNjcmltaW5hdG9yL2dldENvbnN0cnVjdG9yLmpzP2VmYTkiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG5jb25zdCBnZXREaXNjcmltaW5hdG9yQnlWYWx1ZSA9IHJlcXVpcmUoJy4vZ2V0RGlzY3JpbWluYXRvckJ5VmFsdWUnKTtcblxuLyoqXG4gKiBGaW5kIHRoZSBjb3JyZWN0IGNvbnN0cnVjdG9yLCB0YWtpbmcgaW50byBhY2NvdW50IGRpc2NyaW1pbmF0b3JzXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGdldENvbnN0cnVjdG9yKENvbnN0cnVjdG9yLCB2YWx1ZSwgZGVmYXVsdERpc2NyaW1pbmF0b3JWYWx1ZSkge1xuICBjb25zdCBkaXNjcmltaW5hdG9yS2V5ID0gQ29uc3RydWN0b3Iuc2NoZW1hLm9wdGlvbnMuZGlzY3JpbWluYXRvcktleTtcbiAgbGV0IGRpc2NyaW1pbmF0b3JWYWx1ZSA9ICh2YWx1ZSAhPSBudWxsICYmIHZhbHVlW2Rpc2NyaW1pbmF0b3JLZXldKTtcbiAgaWYgKGRpc2NyaW1pbmF0b3JWYWx1ZSA9PSBudWxsKSB7XG4gICAgZGlzY3JpbWluYXRvclZhbHVlID0gZGVmYXVsdERpc2NyaW1pbmF0b3JWYWx1ZTtcbiAgfVxuICBpZiAoQ29uc3RydWN0b3IuZGlzY3JpbWluYXRvcnMgJiZcbiAgICAgIGRpc2NyaW1pbmF0b3JWYWx1ZSAhPSBudWxsKSB7XG4gICAgaWYgKENvbnN0cnVjdG9yLmRpc2NyaW1pbmF0b3JzW2Rpc2NyaW1pbmF0b3JWYWx1ZV0pIHtcbiAgICAgIENvbnN0cnVjdG9yID0gQ29uc3RydWN0b3IuZGlzY3JpbWluYXRvcnNbZGlzY3JpbWluYXRvclZhbHVlXTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3QgY29uc3RydWN0b3JCeVZhbHVlID0gZ2V0RGlzY3JpbWluYXRvckJ5VmFsdWUoQ29uc3RydWN0b3IuZGlzY3JpbWluYXRvcnMsIGRpc2NyaW1pbmF0b3JWYWx1ZSk7XG4gICAgICBpZiAoY29uc3RydWN0b3JCeVZhbHVlKSB7XG4gICAgICAgIENvbnN0cnVjdG9yID0gY29uc3RydWN0b3JCeVZhbHVlO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBDb25zdHJ1Y3Rvcjtcbn07XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/mongoose/lib/helpers/discriminator/getConstructor.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/mongoose/lib/helpers/discriminator/getDiscriminatorByValue.js":
/*!************************************************************************************!*\
  !*** ./node_modules/mongoose/lib/helpers/discriminator/getDiscriminatorByValue.js ***!
  \************************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\n\nconst areDiscriminatorValuesEqual = __webpack_require__(/*! ./areDiscriminatorValuesEqual */ \"(ssr)/./node_modules/mongoose/lib/helpers/discriminator/areDiscriminatorValuesEqual.js\");\n\n/**\n * returns discriminator by discriminatorMapping.value\n *\n * @param {Object} discriminators\n * @param {string} value\n * @api private\n */\n\nmodule.exports = function getDiscriminatorByValue(discriminators, value) {\n  if (discriminators == null) {\n    return null;\n  }\n  for (const name of Object.keys(discriminators)) {\n    const it = discriminators[name];\n    if (\n      it.schema &&\n      it.schema.discriminatorMapping &&\n      areDiscriminatorValuesEqual(it.schema.discriminatorMapping.value, value)\n    ) {\n      return it;\n    }\n  }\n  return null;\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbW9uZ29vc2UvbGliL2hlbHBlcnMvZGlzY3JpbWluYXRvci9nZXREaXNjcmltaW5hdG9yQnlWYWx1ZS5qcyIsIm1hcHBpbmdzIjoiQUFBYTs7QUFFYixvQ0FBb0MsbUJBQU8sQ0FBQyw2SEFBK0I7O0FBRTNFO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL2FwcDEvLi9ub2RlX21vZHVsZXMvbW9uZ29vc2UvbGliL2hlbHBlcnMvZGlzY3JpbWluYXRvci9nZXREaXNjcmltaW5hdG9yQnlWYWx1ZS5qcz9kOTc2Il0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxuY29uc3QgYXJlRGlzY3JpbWluYXRvclZhbHVlc0VxdWFsID0gcmVxdWlyZSgnLi9hcmVEaXNjcmltaW5hdG9yVmFsdWVzRXF1YWwnKTtcblxuLyoqXG4gKiByZXR1cm5zIGRpc2NyaW1pbmF0b3IgYnkgZGlzY3JpbWluYXRvck1hcHBpbmcudmFsdWVcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gZGlzY3JpbWluYXRvcnNcbiAqIEBwYXJhbSB7c3RyaW5nfSB2YWx1ZVxuICogQGFwaSBwcml2YXRlXG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBnZXREaXNjcmltaW5hdG9yQnlWYWx1ZShkaXNjcmltaW5hdG9ycywgdmFsdWUpIHtcbiAgaWYgKGRpc2NyaW1pbmF0b3JzID09IG51bGwpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICBmb3IgKGNvbnN0IG5hbWUgb2YgT2JqZWN0LmtleXMoZGlzY3JpbWluYXRvcnMpKSB7XG4gICAgY29uc3QgaXQgPSBkaXNjcmltaW5hdG9yc1tuYW1lXTtcbiAgICBpZiAoXG4gICAgICBpdC5zY2hlbWEgJiZcbiAgICAgIGl0LnNjaGVtYS5kaXNjcmltaW5hdG9yTWFwcGluZyAmJlxuICAgICAgYXJlRGlzY3JpbWluYXRvclZhbHVlc0VxdWFsKGl0LnNjaGVtYS5kaXNjcmltaW5hdG9yTWFwcGluZy52YWx1ZSwgdmFsdWUpXG4gICAgKSB7XG4gICAgICByZXR1cm4gaXQ7XG4gICAgfVxuICB9XG4gIHJldHVybiBudWxsO1xufTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/mongoose/lib/helpers/discriminator/getDiscriminatorByValue.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/mongoose/lib/helpers/discriminator/getSchemaDiscriminatorByValue.js":
/*!******************************************************************************************!*\
  !*** ./node_modules/mongoose/lib/helpers/discriminator/getSchemaDiscriminatorByValue.js ***!
  \******************************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\n\nconst areDiscriminatorValuesEqual = __webpack_require__(/*! ./areDiscriminatorValuesEqual */ \"(ssr)/./node_modules/mongoose/lib/helpers/discriminator/areDiscriminatorValuesEqual.js\");\n\n/**\n * returns discriminator by discriminatorMapping.value\n *\n * @param {Schema} schema\n * @param {string} value\n * @api private\n */\n\nmodule.exports = function getSchemaDiscriminatorByValue(schema, value) {\n  if (schema == null || schema.discriminators == null) {\n    return null;\n  }\n  for (const key of Object.keys(schema.discriminators)) {\n    const discriminatorSchema = schema.discriminators[key];\n    if (discriminatorSchema.discriminatorMapping == null) {\n      continue;\n    }\n    if (areDiscriminatorValuesEqual(discriminatorSchema.discriminatorMapping.value, value)) {\n      return discriminatorSchema;\n    }\n  }\n  return null;\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbW9uZ29vc2UvbGliL2hlbHBlcnMvZGlzY3JpbWluYXRvci9nZXRTY2hlbWFEaXNjcmltaW5hdG9yQnlWYWx1ZS5qcyIsIm1hcHBpbmdzIjoiQUFBYTs7QUFFYixvQ0FBb0MsbUJBQU8sQ0FBQyw2SEFBK0I7O0FBRTNFO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9hcHAxLy4vbm9kZV9tb2R1bGVzL21vbmdvb3NlL2xpYi9oZWxwZXJzL2Rpc2NyaW1pbmF0b3IvZ2V0U2NoZW1hRGlzY3JpbWluYXRvckJ5VmFsdWUuanM/NjJmNyJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbmNvbnN0IGFyZURpc2NyaW1pbmF0b3JWYWx1ZXNFcXVhbCA9IHJlcXVpcmUoJy4vYXJlRGlzY3JpbWluYXRvclZhbHVlc0VxdWFsJyk7XG5cbi8qKlxuICogcmV0dXJucyBkaXNjcmltaW5hdG9yIGJ5IGRpc2NyaW1pbmF0b3JNYXBwaW5nLnZhbHVlXG4gKlxuICogQHBhcmFtIHtTY2hlbWF9IHNjaGVtYVxuICogQHBhcmFtIHtzdHJpbmd9IHZhbHVlXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGdldFNjaGVtYURpc2NyaW1pbmF0b3JCeVZhbHVlKHNjaGVtYSwgdmFsdWUpIHtcbiAgaWYgKHNjaGVtYSA9PSBudWxsIHx8IHNjaGVtYS5kaXNjcmltaW5hdG9ycyA9PSBudWxsKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgZm9yIChjb25zdCBrZXkgb2YgT2JqZWN0LmtleXMoc2NoZW1hLmRpc2NyaW1pbmF0b3JzKSkge1xuICAgIGNvbnN0IGRpc2NyaW1pbmF0b3JTY2hlbWEgPSBzY2hlbWEuZGlzY3JpbWluYXRvcnNba2V5XTtcbiAgICBpZiAoZGlzY3JpbWluYXRvclNjaGVtYS5kaXNjcmltaW5hdG9yTWFwcGluZyA9PSBudWxsKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgaWYgKGFyZURpc2NyaW1pbmF0b3JWYWx1ZXNFcXVhbChkaXNjcmltaW5hdG9yU2NoZW1hLmRpc2NyaW1pbmF0b3JNYXBwaW5nLnZhbHVlLCB2YWx1ZSkpIHtcbiAgICAgIHJldHVybiBkaXNjcmltaW5hdG9yU2NoZW1hO1xuICAgIH1cbiAgfVxuICByZXR1cm4gbnVsbDtcbn07XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/mongoose/lib/helpers/discriminator/getSchemaDiscriminatorByValue.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/mongoose/lib/helpers/discriminator/mergeDiscriminatorSchema.js":
/*!*************************************************************************************!*\
  !*** ./node_modules/mongoose/lib/helpers/discriminator/mergeDiscriminatorSchema.js ***!
  \*************************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\nconst schemaMerge = __webpack_require__(/*! ../schema/merge */ \"(ssr)/./node_modules/mongoose/lib/helpers/schema/merge.js\");\nconst specialProperties = __webpack_require__(/*! ../../helpers/specialProperties */ \"(ssr)/./node_modules/mongoose/lib/helpers/specialProperties.js\");\nconst isBsonType = __webpack_require__(/*! ../../helpers/isBsonType */ \"(ssr)/./node_modules/mongoose/lib/helpers/isBsonType.js\");\nconst ObjectId = __webpack_require__(/*! ../../types/objectid */ \"(ssr)/./node_modules/mongoose/lib/types/objectid.js\");\nconst isObject = __webpack_require__(/*! ../../helpers/isObject */ \"(ssr)/./node_modules/mongoose/lib/helpers/isObject.js\");\n/**\n * Merges `from` into `to` without overwriting existing properties.\n *\n * @param {Object} to\n * @param {Object} from\n * @param {String} [path]\n * @api private\n */\n\nmodule.exports = function mergeDiscriminatorSchema(to, from, path, seen) {\n  const keys = Object.keys(from);\n  let i = 0;\n  const len = keys.length;\n  let key;\n\n  path = path || '';\n  seen = seen || new WeakSet();\n\n  if (seen.has(from)) {\n    return;\n  }\n  seen.add(from);\n\n  while (i < len) {\n    key = keys[i++];\n    if (!path) {\n      if (key === 'discriminators' ||\n        key === 'base' ||\n        key === '_applyDiscriminators' ||\n        key === '_userProvidedOptions' ||\n        key === 'options' ||\n        key === 'tree') {\n        continue;\n      }\n    }\n    if (path === 'tree' && from != null && from.instanceOfSchema) {\n      continue;\n    }\n    if (specialProperties.has(key)) {\n      continue;\n    }\n    if (to[key] == null) {\n      to[key] = from[key];\n    } else if (isObject(from[key])) {\n      if (!isObject(to[key])) {\n        to[key] = {};\n      }\n      if (from[key] != null) {\n        // Skip merging schemas if we're creating a discriminator schema and\n        // base schema has a given path as a single nested but discriminator schema\n        // has the path as a document array, or vice versa (gh-9534)\n        if ((from[key].$isSingleNested && to[key].$isMongooseDocumentArray) ||\n              (from[key].$isMongooseDocumentArray && to[key].$isSingleNested) ||\n              (from[key].$isMongooseDocumentArrayElement && to[key].$isMongooseDocumentArrayElement)) {\n          continue;\n        } else if (from[key].instanceOfSchema) {\n          if (to[key].instanceOfSchema) {\n            schemaMerge(to[key], from[key].clone(), true);\n          } else {\n            to[key] = from[key].clone();\n          }\n          continue;\n        } else if (isBsonType(from[key], 'ObjectId')) {\n          to[key] = new ObjectId(from[key]);\n          continue;\n        }\n      }\n      mergeDiscriminatorSchema(to[key], from[key], path ? path + '.' + key : key, seen);\n    }\n  }\n\n  if (from != null && from.instanceOfSchema) {\n    to.tree = Object.assign({}, from.tree, to.tree);\n  }\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbW9uZ29vc2UvbGliL2hlbHBlcnMvZGlzY3JpbWluYXRvci9tZXJnZURpc2NyaW1pbmF0b3JTY2hlbWEuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYixvQkFBb0IsbUJBQU8sQ0FBQyxrRkFBaUI7QUFDN0MsMEJBQTBCLG1CQUFPLENBQUMsdUdBQWlDO0FBQ25FLG1CQUFtQixtQkFBTyxDQUFDLHlGQUEwQjtBQUNyRCxpQkFBaUIsbUJBQU8sQ0FBQyxpRkFBc0I7QUFDL0MsaUJBQWlCLG1CQUFPLENBQUMscUZBQXdCO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDhCQUE4QjtBQUM5QjtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vYXBwMS8uL25vZGVfbW9kdWxlcy9tb25nb29zZS9saWIvaGVscGVycy9kaXNjcmltaW5hdG9yL21lcmdlRGlzY3JpbWluYXRvclNjaGVtYS5qcz85ZGQ1Il0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcbmNvbnN0IHNjaGVtYU1lcmdlID0gcmVxdWlyZSgnLi4vc2NoZW1hL21lcmdlJyk7XG5jb25zdCBzcGVjaWFsUHJvcGVydGllcyA9IHJlcXVpcmUoJy4uLy4uL2hlbHBlcnMvc3BlY2lhbFByb3BlcnRpZXMnKTtcbmNvbnN0IGlzQnNvblR5cGUgPSByZXF1aXJlKCcuLi8uLi9oZWxwZXJzL2lzQnNvblR5cGUnKTtcbmNvbnN0IE9iamVjdElkID0gcmVxdWlyZSgnLi4vLi4vdHlwZXMvb2JqZWN0aWQnKTtcbmNvbnN0IGlzT2JqZWN0ID0gcmVxdWlyZSgnLi4vLi4vaGVscGVycy9pc09iamVjdCcpO1xuLyoqXG4gKiBNZXJnZXMgYGZyb21gIGludG8gYHRvYCB3aXRob3V0IG92ZXJ3cml0aW5nIGV4aXN0aW5nIHByb3BlcnRpZXMuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IHRvXG4gKiBAcGFyYW0ge09iamVjdH0gZnJvbVxuICogQHBhcmFtIHtTdHJpbmd9IFtwYXRoXVxuICogQGFwaSBwcml2YXRlXG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBtZXJnZURpc2NyaW1pbmF0b3JTY2hlbWEodG8sIGZyb20sIHBhdGgsIHNlZW4pIHtcbiAgY29uc3Qga2V5cyA9IE9iamVjdC5rZXlzKGZyb20pO1xuICBsZXQgaSA9IDA7XG4gIGNvbnN0IGxlbiA9IGtleXMubGVuZ3RoO1xuICBsZXQga2V5O1xuXG4gIHBhdGggPSBwYXRoIHx8ICcnO1xuICBzZWVuID0gc2VlbiB8fCBuZXcgV2Vha1NldCgpO1xuXG4gIGlmIChzZWVuLmhhcyhmcm9tKSkge1xuICAgIHJldHVybjtcbiAgfVxuICBzZWVuLmFkZChmcm9tKTtcblxuICB3aGlsZSAoaSA8IGxlbikge1xuICAgIGtleSA9IGtleXNbaSsrXTtcbiAgICBpZiAoIXBhdGgpIHtcbiAgICAgIGlmIChrZXkgPT09ICdkaXNjcmltaW5hdG9ycycgfHxcbiAgICAgICAga2V5ID09PSAnYmFzZScgfHxcbiAgICAgICAga2V5ID09PSAnX2FwcGx5RGlzY3JpbWluYXRvcnMnIHx8XG4gICAgICAgIGtleSA9PT0gJ191c2VyUHJvdmlkZWRPcHRpb25zJyB8fFxuICAgICAgICBrZXkgPT09ICdvcHRpb25zJyB8fFxuICAgICAgICBrZXkgPT09ICd0cmVlJykge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKHBhdGggPT09ICd0cmVlJyAmJiBmcm9tICE9IG51bGwgJiYgZnJvbS5pbnN0YW5jZU9mU2NoZW1hKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgaWYgKHNwZWNpYWxQcm9wZXJ0aWVzLmhhcyhrZXkpKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgaWYgKHRvW2tleV0gPT0gbnVsbCkge1xuICAgICAgdG9ba2V5XSA9IGZyb21ba2V5XTtcbiAgICB9IGVsc2UgaWYgKGlzT2JqZWN0KGZyb21ba2V5XSkpIHtcbiAgICAgIGlmICghaXNPYmplY3QodG9ba2V5XSkpIHtcbiAgICAgICAgdG9ba2V5XSA9IHt9O1xuICAgICAgfVxuICAgICAgaWYgKGZyb21ba2V5XSAhPSBudWxsKSB7XG4gICAgICAgIC8vIFNraXAgbWVyZ2luZyBzY2hlbWFzIGlmIHdlJ3JlIGNyZWF0aW5nIGEgZGlzY3JpbWluYXRvciBzY2hlbWEgYW5kXG4gICAgICAgIC8vIGJhc2Ugc2NoZW1hIGhhcyBhIGdpdmVuIHBhdGggYXMgYSBzaW5nbGUgbmVzdGVkIGJ1dCBkaXNjcmltaW5hdG9yIHNjaGVtYVxuICAgICAgICAvLyBoYXMgdGhlIHBhdGggYXMgYSBkb2N1bWVudCBhcnJheSwgb3IgdmljZSB2ZXJzYSAoZ2gtOTUzNClcbiAgICAgICAgaWYgKChmcm9tW2tleV0uJGlzU2luZ2xlTmVzdGVkICYmIHRvW2tleV0uJGlzTW9uZ29vc2VEb2N1bWVudEFycmF5KSB8fFxuICAgICAgICAgICAgICAoZnJvbVtrZXldLiRpc01vbmdvb3NlRG9jdW1lbnRBcnJheSAmJiB0b1trZXldLiRpc1NpbmdsZU5lc3RlZCkgfHxcbiAgICAgICAgICAgICAgKGZyb21ba2V5XS4kaXNNb25nb29zZURvY3VtZW50QXJyYXlFbGVtZW50ICYmIHRvW2tleV0uJGlzTW9uZ29vc2VEb2N1bWVudEFycmF5RWxlbWVudCkpIHtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfSBlbHNlIGlmIChmcm9tW2tleV0uaW5zdGFuY2VPZlNjaGVtYSkge1xuICAgICAgICAgIGlmICh0b1trZXldLmluc3RhbmNlT2ZTY2hlbWEpIHtcbiAgICAgICAgICAgIHNjaGVtYU1lcmdlKHRvW2tleV0sIGZyb21ba2V5XS5jbG9uZSgpLCB0cnVlKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdG9ba2V5XSA9IGZyb21ba2V5XS5jbG9uZSgpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfSBlbHNlIGlmIChpc0Jzb25UeXBlKGZyb21ba2V5XSwgJ09iamVjdElkJykpIHtcbiAgICAgICAgICB0b1trZXldID0gbmV3IE9iamVjdElkKGZyb21ba2V5XSk7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIG1lcmdlRGlzY3JpbWluYXRvclNjaGVtYSh0b1trZXldLCBmcm9tW2tleV0sIHBhdGggPyBwYXRoICsgJy4nICsga2V5IDoga2V5LCBzZWVuKTtcbiAgICB9XG4gIH1cblxuICBpZiAoZnJvbSAhPSBudWxsICYmIGZyb20uaW5zdGFuY2VPZlNjaGVtYSkge1xuICAgIHRvLnRyZWUgPSBPYmplY3QuYXNzaWduKHt9LCBmcm9tLnRyZWUsIHRvLnRyZWUpO1xuICB9XG59O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/mongoose/lib/helpers/discriminator/mergeDiscriminatorSchema.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/mongoose/lib/helpers/document/applyDefaults.js":
/*!*********************************************************************!*\
  !*** ./node_modules/mongoose/lib/helpers/document/applyDefaults.js ***!
  \*********************************************************************/
/***/ ((module) => {

eval("\n\nmodule.exports = function applyDefaults(doc, fields, exclude, hasIncludedChildren, isBeforeSetters, pathsToSkip) {\n  const paths = Object.keys(doc.$__schema.paths);\n  const plen = paths.length;\n\n  for (let i = 0; i < plen; ++i) {\n    let def;\n    let curPath = '';\n    const p = paths[i];\n\n    if (p === '_id' && doc.$__.skipId) {\n      continue;\n    }\n\n    const type = doc.$__schema.paths[p];\n    const path = type.splitPath();\n    const len = path.length;\n    let included = false;\n    let doc_ = doc._doc;\n    for (let j = 0; j < len; ++j) {\n      if (doc_ == null) {\n        break;\n      }\n\n      const piece = path[j];\n      curPath += (!curPath.length ? '' : '.') + piece;\n\n      if (exclude === true) {\n        if (curPath in fields) {\n          break;\n        }\n      } else if (exclude === false && fields && !included) {\n        const hasSubpaths = type.$isSingleNested || type.$isMongooseDocumentArray;\n        if (curPath in fields || (j === len - 1 && hasSubpaths && hasIncludedChildren != null && hasIncludedChildren[curPath])) {\n          included = true;\n        } else if (hasIncludedChildren != null && !hasIncludedChildren[curPath]) {\n          break;\n        }\n      }\n\n      if (j === len - 1) {\n        if (doc_[piece] !== void 0) {\n          break;\n        }\n\n        if (isBeforeSetters != null) {\n          if (typeof type.defaultValue === 'function') {\n            if (!type.defaultValue.$runBeforeSetters && isBeforeSetters) {\n              break;\n            }\n            if (type.defaultValue.$runBeforeSetters && !isBeforeSetters) {\n              break;\n            }\n          } else if (!isBeforeSetters) {\n            // Non-function defaults should always run **before** setters\n            continue;\n          }\n        }\n\n        if (pathsToSkip && pathsToSkip[curPath]) {\n          break;\n        }\n\n        if (fields && exclude !== null) {\n          if (exclude === true) {\n            // apply defaults to all non-excluded fields\n            if (p in fields) {\n              continue;\n            }\n\n            try {\n              def = type.getDefault(doc, false);\n            } catch (err) {\n              doc.invalidate(p, err);\n              break;\n            }\n\n            if (typeof def !== 'undefined') {\n              doc_[piece] = def;\n              applyChangeTracking(doc, p);\n            }\n          } else if (included) {\n            // selected field\n            try {\n              def = type.getDefault(doc, false);\n            } catch (err) {\n              doc.invalidate(p, err);\n              break;\n            }\n\n            if (typeof def !== 'undefined') {\n              doc_[piece] = def;\n              applyChangeTracking(doc, p);\n            }\n          }\n        } else {\n          try {\n            def = type.getDefault(doc, false);\n          } catch (err) {\n            doc.invalidate(p, err);\n            break;\n          }\n\n          if (typeof def !== 'undefined') {\n            doc_[piece] = def;\n            applyChangeTracking(doc, p);\n          }\n        }\n      } else {\n        doc_ = doc_[piece];\n      }\n    }\n  }\n};\n\n/*!\n * ignore\n */\n\nfunction applyChangeTracking(doc, fullPath) {\n  doc.$__.activePaths.default(fullPath);\n  if (doc.$isSubdocument && doc.$isSingleNested && doc.$parent() != null) {\n    doc.$parent().$__.activePaths.default(doc.$__pathRelativeToParent(fullPath));\n  }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbW9uZ29vc2UvbGliL2hlbHBlcnMvZG9jdW1lbnQvYXBwbHlEZWZhdWx0cy5qcyIsIm1hcHBpbmdzIjoiQUFBYTs7QUFFYjtBQUNBO0FBQ0E7O0FBRUEsa0JBQWtCLFVBQVU7QUFDNUI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLFNBQVM7QUFDN0I7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vYXBwMS8uL25vZGVfbW9kdWxlcy9tb25nb29zZS9saWIvaGVscGVycy9kb2N1bWVudC9hcHBseURlZmF1bHRzLmpzPzQwM2EiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGFwcGx5RGVmYXVsdHMoZG9jLCBmaWVsZHMsIGV4Y2x1ZGUsIGhhc0luY2x1ZGVkQ2hpbGRyZW4sIGlzQmVmb3JlU2V0dGVycywgcGF0aHNUb1NraXApIHtcbiAgY29uc3QgcGF0aHMgPSBPYmplY3Qua2V5cyhkb2MuJF9fc2NoZW1hLnBhdGhzKTtcbiAgY29uc3QgcGxlbiA9IHBhdGhzLmxlbmd0aDtcblxuICBmb3IgKGxldCBpID0gMDsgaSA8IHBsZW47ICsraSkge1xuICAgIGxldCBkZWY7XG4gICAgbGV0IGN1clBhdGggPSAnJztcbiAgICBjb25zdCBwID0gcGF0aHNbaV07XG5cbiAgICBpZiAocCA9PT0gJ19pZCcgJiYgZG9jLiRfXy5za2lwSWQpIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIGNvbnN0IHR5cGUgPSBkb2MuJF9fc2NoZW1hLnBhdGhzW3BdO1xuICAgIGNvbnN0IHBhdGggPSB0eXBlLnNwbGl0UGF0aCgpO1xuICAgIGNvbnN0IGxlbiA9IHBhdGgubGVuZ3RoO1xuICAgIGxldCBpbmNsdWRlZCA9IGZhbHNlO1xuICAgIGxldCBkb2NfID0gZG9jLl9kb2M7XG4gICAgZm9yIChsZXQgaiA9IDA7IGogPCBsZW47ICsraikge1xuICAgICAgaWYgKGRvY18gPT0gbnVsbCkge1xuICAgICAgICBicmVhaztcbiAgICAgIH1cblxuICAgICAgY29uc3QgcGllY2UgPSBwYXRoW2pdO1xuICAgICAgY3VyUGF0aCArPSAoIWN1clBhdGgubGVuZ3RoID8gJycgOiAnLicpICsgcGllY2U7XG5cbiAgICAgIGlmIChleGNsdWRlID09PSB0cnVlKSB7XG4gICAgICAgIGlmIChjdXJQYXRoIGluIGZpZWxkcykge1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKGV4Y2x1ZGUgPT09IGZhbHNlICYmIGZpZWxkcyAmJiAhaW5jbHVkZWQpIHtcbiAgICAgICAgY29uc3QgaGFzU3VicGF0aHMgPSB0eXBlLiRpc1NpbmdsZU5lc3RlZCB8fCB0eXBlLiRpc01vbmdvb3NlRG9jdW1lbnRBcnJheTtcbiAgICAgICAgaWYgKGN1clBhdGggaW4gZmllbGRzIHx8IChqID09PSBsZW4gLSAxICYmIGhhc1N1YnBhdGhzICYmIGhhc0luY2x1ZGVkQ2hpbGRyZW4gIT0gbnVsbCAmJiBoYXNJbmNsdWRlZENoaWxkcmVuW2N1clBhdGhdKSkge1xuICAgICAgICAgIGluY2x1ZGVkID0gdHJ1ZTtcbiAgICAgICAgfSBlbHNlIGlmIChoYXNJbmNsdWRlZENoaWxkcmVuICE9IG51bGwgJiYgIWhhc0luY2x1ZGVkQ2hpbGRyZW5bY3VyUGF0aF0pIHtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAoaiA9PT0gbGVuIC0gMSkge1xuICAgICAgICBpZiAoZG9jX1twaWVjZV0gIT09IHZvaWQgMCkge1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGlzQmVmb3JlU2V0dGVycyAhPSBudWxsKSB7XG4gICAgICAgICAgaWYgKHR5cGVvZiB0eXBlLmRlZmF1bHRWYWx1ZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgaWYgKCF0eXBlLmRlZmF1bHRWYWx1ZS4kcnVuQmVmb3JlU2V0dGVycyAmJiBpc0JlZm9yZVNldHRlcnMpIHtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodHlwZS5kZWZhdWx0VmFsdWUuJHJ1bkJlZm9yZVNldHRlcnMgJiYgIWlzQmVmb3JlU2V0dGVycykge1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2UgaWYgKCFpc0JlZm9yZVNldHRlcnMpIHtcbiAgICAgICAgICAgIC8vIE5vbi1mdW5jdGlvbiBkZWZhdWx0cyBzaG91bGQgYWx3YXlzIHJ1biAqKmJlZm9yZSoqIHNldHRlcnNcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChwYXRoc1RvU2tpcCAmJiBwYXRoc1RvU2tpcFtjdXJQYXRoXSkge1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGZpZWxkcyAmJiBleGNsdWRlICE9PSBudWxsKSB7XG4gICAgICAgICAgaWYgKGV4Y2x1ZGUgPT09IHRydWUpIHtcbiAgICAgICAgICAgIC8vIGFwcGx5IGRlZmF1bHRzIHRvIGFsbCBub24tZXhjbHVkZWQgZmllbGRzXG4gICAgICAgICAgICBpZiAocCBpbiBmaWVsZHMpIHtcbiAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgIGRlZiA9IHR5cGUuZ2V0RGVmYXVsdChkb2MsIGZhbHNlKTtcbiAgICAgICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgICBkb2MuaW52YWxpZGF0ZShwLCBlcnIpO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKHR5cGVvZiBkZWYgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICAgIGRvY19bcGllY2VdID0gZGVmO1xuICAgICAgICAgICAgICBhcHBseUNoYW5nZVRyYWNraW5nKGRvYywgcCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIGlmIChpbmNsdWRlZCkge1xuICAgICAgICAgICAgLy8gc2VsZWN0ZWQgZmllbGRcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgIGRlZiA9IHR5cGUuZ2V0RGVmYXVsdChkb2MsIGZhbHNlKTtcbiAgICAgICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgICBkb2MuaW52YWxpZGF0ZShwLCBlcnIpO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKHR5cGVvZiBkZWYgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICAgIGRvY19bcGllY2VdID0gZGVmO1xuICAgICAgICAgICAgICBhcHBseUNoYW5nZVRyYWNraW5nKGRvYywgcCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICBkZWYgPSB0eXBlLmdldERlZmF1bHQoZG9jLCBmYWxzZSk7XG4gICAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICBkb2MuaW52YWxpZGF0ZShwLCBlcnIpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKHR5cGVvZiBkZWYgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBkb2NfW3BpZWNlXSA9IGRlZjtcbiAgICAgICAgICAgIGFwcGx5Q2hhbmdlVHJhY2tpbmcoZG9jLCBwKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGRvY18gPSBkb2NfW3BpZWNlXTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn07XG5cbi8qIVxuICogaWdub3JlXG4gKi9cblxuZnVuY3Rpb24gYXBwbHlDaGFuZ2VUcmFja2luZyhkb2MsIGZ1bGxQYXRoKSB7XG4gIGRvYy4kX18uYWN0aXZlUGF0aHMuZGVmYXVsdChmdWxsUGF0aCk7XG4gIGlmIChkb2MuJGlzU3ViZG9jdW1lbnQgJiYgZG9jLiRpc1NpbmdsZU5lc3RlZCAmJiBkb2MuJHBhcmVudCgpICE9IG51bGwpIHtcbiAgICBkb2MuJHBhcmVudCgpLiRfXy5hY3RpdmVQYXRocy5kZWZhdWx0KGRvYy4kX19wYXRoUmVsYXRpdmVUb1BhcmVudChmdWxsUGF0aCkpO1xuICB9XG59XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/mongoose/lib/helpers/document/applyDefaults.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/mongoose/lib/helpers/document/cleanModifiedSubpaths.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/mongoose/lib/helpers/document/cleanModifiedSubpaths.js ***!
  \*****************************************************************************/
/***/ ((module) => {

eval("\n\n/*!\n * ignore\n */\n\nmodule.exports = function cleanModifiedSubpaths(doc, path, options) {\n  options = options || {};\n  const skipDocArrays = options.skipDocArrays;\n\n  let deleted = 0;\n  if (!doc) {\n    return deleted;\n  }\n\n  for (const modifiedPath of Object.keys(doc.$__.activePaths.getStatePaths('modify'))) {\n    if (skipDocArrays) {\n      const schemaType = doc.$__schema.path(modifiedPath);\n      if (schemaType && schemaType.$isMongooseDocumentArray) {\n        continue;\n      }\n    }\n    if (modifiedPath.startsWith(path + '.')) {\n      doc.$__.activePaths.clearPath(modifiedPath);\n      ++deleted;\n\n      if (doc.$isSubdocument) {\n        const owner = doc.ownerDocument();\n        const fullPath = doc.$__fullPath(modifiedPath);\n        owner.$__.activePaths.clearPath(fullPath);\n      }\n    }\n  }\n  return deleted;\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbW9uZ29vc2UvbGliL2hlbHBlcnMvZG9jdW1lbnQvY2xlYW5Nb2RpZmllZFN1YnBhdGhzLmpzIiwibWFwcGluZ3MiOiJBQUFhOztBQUViO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vYXBwMS8uL25vZGVfbW9kdWxlcy9tb25nb29zZS9saWIvaGVscGVycy9kb2N1bWVudC9jbGVhbk1vZGlmaWVkU3VicGF0aHMuanM/YTljMCJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbi8qIVxuICogaWdub3JlXG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBjbGVhbk1vZGlmaWVkU3VicGF0aHMoZG9jLCBwYXRoLCBvcHRpb25zKSB7XG4gIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICBjb25zdCBza2lwRG9jQXJyYXlzID0gb3B0aW9ucy5za2lwRG9jQXJyYXlzO1xuXG4gIGxldCBkZWxldGVkID0gMDtcbiAgaWYgKCFkb2MpIHtcbiAgICByZXR1cm4gZGVsZXRlZDtcbiAgfVxuXG4gIGZvciAoY29uc3QgbW9kaWZpZWRQYXRoIG9mIE9iamVjdC5rZXlzKGRvYy4kX18uYWN0aXZlUGF0aHMuZ2V0U3RhdGVQYXRocygnbW9kaWZ5JykpKSB7XG4gICAgaWYgKHNraXBEb2NBcnJheXMpIHtcbiAgICAgIGNvbnN0IHNjaGVtYVR5cGUgPSBkb2MuJF9fc2NoZW1hLnBhdGgobW9kaWZpZWRQYXRoKTtcbiAgICAgIGlmIChzY2hlbWFUeXBlICYmIHNjaGVtYVR5cGUuJGlzTW9uZ29vc2VEb2N1bWVudEFycmF5KSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAobW9kaWZpZWRQYXRoLnN0YXJ0c1dpdGgocGF0aCArICcuJykpIHtcbiAgICAgIGRvYy4kX18uYWN0aXZlUGF0aHMuY2xlYXJQYXRoKG1vZGlmaWVkUGF0aCk7XG4gICAgICArK2RlbGV0ZWQ7XG5cbiAgICAgIGlmIChkb2MuJGlzU3ViZG9jdW1lbnQpIHtcbiAgICAgICAgY29uc3Qgb3duZXIgPSBkb2Mub3duZXJEb2N1bWVudCgpO1xuICAgICAgICBjb25zdCBmdWxsUGF0aCA9IGRvYy4kX19mdWxsUGF0aChtb2RpZmllZFBhdGgpO1xuICAgICAgICBvd25lci4kX18uYWN0aXZlUGF0aHMuY2xlYXJQYXRoKGZ1bGxQYXRoKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIGRlbGV0ZWQ7XG59O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/mongoose/lib/helpers/document/cleanModifiedSubpaths.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/mongoose/lib/helpers/document/compile.js":
/*!***************************************************************!*\
  !*** ./node_modules/mongoose/lib/helpers/document/compile.js ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n\nconst clone = __webpack_require__(/*! ../../helpers/clone */ \"(ssr)/./node_modules/mongoose/lib/helpers/clone.js\");\nconst documentSchemaSymbol = (__webpack_require__(/*! ../../helpers/symbols */ \"(ssr)/./node_modules/mongoose/lib/helpers/symbols.js\").documentSchemaSymbol);\nconst internalToObjectOptions = (__webpack_require__(/*! ../../options */ \"(ssr)/./node_modules/mongoose/lib/options.js\").internalToObjectOptions);\nconst utils = __webpack_require__(/*! ../../utils */ \"(ssr)/./node_modules/mongoose/lib/utils.js\");\n\nlet Document;\nconst getSymbol = (__webpack_require__(/*! ../../helpers/symbols */ \"(ssr)/./node_modules/mongoose/lib/helpers/symbols.js\").getSymbol);\nconst scopeSymbol = (__webpack_require__(/*! ../../helpers/symbols */ \"(ssr)/./node_modules/mongoose/lib/helpers/symbols.js\").scopeSymbol);\n\nconst isPOJO = utils.isPOJO;\n\n/*!\n * exports\n */\n\nexports.compile = compile;\nexports.defineKey = defineKey;\n\nconst _isEmptyOptions = Object.freeze({\n  minimize: true,\n  virtuals: false,\n  getters: false,\n  transform: false\n});\n\nconst noDottedPathGetOptions = Object.freeze({\n  noDottedPath: true\n});\n\n/**\n * Compiles schemas.\n * @param {Object} tree\n * @param {Any} proto\n * @param {String} prefix\n * @param {Object} options\n * @api private\n */\n\nfunction compile(tree, proto, prefix, options) {\n  Document = Document || __webpack_require__(/*! ../../document */ \"(ssr)/./node_modules/mongoose/lib/document.js\");\n  const typeKey = options.typeKey;\n\n  for (const key of Object.keys(tree)) {\n    const limb = tree[key];\n\n    const hasSubprops = isPOJO(limb) &&\n      Object.keys(limb).length > 0 &&\n      (!limb[typeKey] || (typeKey === 'type' && isPOJO(limb.type) && limb.type.type));\n    const subprops = hasSubprops ? limb : null;\n\n    defineKey({ prop: key, subprops: subprops, prototype: proto, prefix: prefix, options: options });\n  }\n}\n\n/**\n * Defines the accessor named prop on the incoming prototype.\n * @param {Object} options\n * @param {String} options.prop\n * @param {Boolean} options.subprops\n * @param {Any} options.prototype\n * @param {String} [options.prefix]\n * @param {Object} options.options\n * @api private\n */\n\nfunction defineKey({ prop, subprops, prototype, prefix, options }) {\n  Document = Document || __webpack_require__(/*! ../../document */ \"(ssr)/./node_modules/mongoose/lib/document.js\");\n  const path = (prefix ? prefix + '.' : '') + prop;\n  prefix = prefix || '';\n  const useGetOptions = prefix ? Object.freeze({}) : noDottedPathGetOptions;\n\n  if (subprops) {\n    Object.defineProperty(prototype, prop, {\n      enumerable: true,\n      configurable: true,\n      get: function() {\n        const _this = this;\n        if (!this.$__.getters) {\n          this.$__.getters = {};\n        }\n\n        if (!this.$__.getters[path]) {\n          const nested = Object.create(Document.prototype, getOwnPropertyDescriptors(this));\n\n          // save scope for nested getters/setters\n          if (!prefix) {\n            nested.$__[scopeSymbol] = this;\n          }\n          nested.$__.nestedPath = path;\n\n          Object.defineProperty(nested, 'schema', {\n            enumerable: false,\n            configurable: true,\n            writable: false,\n            value: prototype.schema\n          });\n\n          Object.defineProperty(nested, '$__schema', {\n            enumerable: false,\n            configurable: true,\n            writable: false,\n            value: prototype.schema\n          });\n\n          Object.defineProperty(nested, documentSchemaSymbol, {\n            enumerable: false,\n            configurable: true,\n            writable: false,\n            value: prototype.schema\n          });\n\n          Object.defineProperty(nested, 'toObject', {\n            enumerable: false,\n            configurable: true,\n            writable: false,\n            value: function() {\n              return clone(_this.get(path, null, {\n                virtuals: this &&\n                  this.schema &&\n                  this.schema.options &&\n                  this.schema.options.toObject &&\n                  this.schema.options.toObject.virtuals || null\n              }));\n            }\n          });\n\n          Object.defineProperty(nested, '$__get', {\n            enumerable: false,\n            configurable: true,\n            writable: false,\n            value: function() {\n              return _this.get(path, null, {\n                virtuals: this && this.schema && this.schema.options && this.schema.options.toObject && this.schema.options.toObject.virtuals || null\n              });\n            }\n          });\n\n          Object.defineProperty(nested, 'toJSON', {\n            enumerable: false,\n            configurable: true,\n            writable: false,\n            value: function() {\n              return _this.get(path, null, {\n                virtuals: this && this.schema && this.schema.options && this.schema.options.toJSON && this.schema.options.toJSON.virtuals || null\n              });\n            }\n          });\n\n          Object.defineProperty(nested, '$__isNested', {\n            enumerable: false,\n            configurable: true,\n            writable: false,\n            value: true\n          });\n\n          Object.defineProperty(nested, '$isEmpty', {\n            enumerable: false,\n            configurable: true,\n            writable: false,\n            value: function() {\n              return Object.keys(this.get(path, null, _isEmptyOptions) || {}).length === 0;\n            }\n          });\n\n          Object.defineProperty(nested, '$__parent', {\n            enumerable: false,\n            configurable: true,\n            writable: false,\n            value: this\n          });\n\n          compile(subprops, nested, path, options);\n          this.$__.getters[path] = nested;\n        }\n\n        return this.$__.getters[path];\n      },\n      set: function(v) {\n        if (v != null && v.$__isNested) {\n          // Convert top-level to POJO, but leave subdocs hydrated so `$set`\n          // can handle them. See gh-9293.\n          v = v.$__get();\n        } else if (v instanceof Document && !v.$__isNested) {\n          v = v.$toObject(internalToObjectOptions);\n        }\n        const doc = this.$__[scopeSymbol] || this;\n        doc.$set(path, v);\n      }\n    });\n  } else {\n    Object.defineProperty(prototype, prop, {\n      enumerable: true,\n      configurable: true,\n      get: function() {\n        return this[getSymbol].call(\n          this.$__[scopeSymbol] || this,\n          path,\n          null,\n          useGetOptions\n        );\n      },\n      set: function(v) {\n        this.$set.call(this.$__[scopeSymbol] || this, path, v);\n      }\n    });\n  }\n}\n\n// gets descriptors for all properties of `object`\n// makes all properties non-enumerable to match previous behavior to #2211\nfunction getOwnPropertyDescriptors(object) {\n  const result = {};\n\n  Object.getOwnPropertyNames(object).forEach(function(key) {\n    const skip = [\n      'isNew',\n      '$__',\n      '$errors',\n      'errors',\n      '_doc',\n      '$locals',\n      '$op',\n      '__parentArray',\n      '__index',\n      '$isDocumentArrayElement'\n    ].indexOf(key) === -1;\n    if (skip) {\n      return;\n    }\n\n    result[key] = Object.getOwnPropertyDescriptor(object, key);\n    result[key].enumerable = false;\n  });\n\n  return result;\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbW9uZ29vc2UvbGliL2hlbHBlcnMvZG9jdW1lbnQvY29tcGlsZS5qcyIsIm1hcHBpbmdzIjoiQUFBYTs7QUFFYixjQUFjLG1CQUFPLENBQUMsK0VBQXFCO0FBQzNDLDZCQUE2QiwrSEFBcUQ7QUFDbEYsZ0NBQWdDLGtIQUFnRDtBQUNoRixjQUFjLG1CQUFPLENBQUMsK0RBQWE7O0FBRW5DO0FBQ0Esa0JBQWtCLG9IQUEwQztBQUM1RCxvQkFBb0Isc0hBQTRDOztBQUVoRTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsZUFBZTtBQUNmLGlCQUFpQjs7QUFFakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLEtBQUs7QUFDaEIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQjtBQUNBOztBQUVBO0FBQ0EseUJBQXlCLG1CQUFPLENBQUMscUVBQWdCO0FBQ2pEOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsZ0JBQWdCLG1GQUFtRjtBQUNuRztBQUNBOztBQUVBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsU0FBUztBQUNwQixXQUFXLEtBQUs7QUFDaEIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQjtBQUNBOztBQUVBLHFCQUFxQiw0Q0FBNEM7QUFDakUseUJBQXlCLG1CQUFPLENBQUMscUVBQWdCO0FBQ2pEO0FBQ0E7QUFDQSxpREFBaUQ7O0FBRWpEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7O0FBRVg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7O0FBRVg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7O0FBRVg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBLFdBQVc7O0FBRVg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQSxXQUFXOztBQUVYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0EsV0FBVzs7QUFFWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVzs7QUFFWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEVBQTRFO0FBQzVFO0FBQ0EsV0FBVzs7QUFFWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVzs7QUFFWDtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vYXBwMS8uL25vZGVfbW9kdWxlcy9tb25nb29zZS9saWIvaGVscGVycy9kb2N1bWVudC9jb21waWxlLmpzPzk5ODgiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG5jb25zdCBjbG9uZSA9IHJlcXVpcmUoJy4uLy4uL2hlbHBlcnMvY2xvbmUnKTtcbmNvbnN0IGRvY3VtZW50U2NoZW1hU3ltYm9sID0gcmVxdWlyZSgnLi4vLi4vaGVscGVycy9zeW1ib2xzJykuZG9jdW1lbnRTY2hlbWFTeW1ib2w7XG5jb25zdCBpbnRlcm5hbFRvT2JqZWN0T3B0aW9ucyA9IHJlcXVpcmUoJy4uLy4uL29wdGlvbnMnKS5pbnRlcm5hbFRvT2JqZWN0T3B0aW9ucztcbmNvbnN0IHV0aWxzID0gcmVxdWlyZSgnLi4vLi4vdXRpbHMnKTtcblxubGV0IERvY3VtZW50O1xuY29uc3QgZ2V0U3ltYm9sID0gcmVxdWlyZSgnLi4vLi4vaGVscGVycy9zeW1ib2xzJykuZ2V0U3ltYm9sO1xuY29uc3Qgc2NvcGVTeW1ib2wgPSByZXF1aXJlKCcuLi8uLi9oZWxwZXJzL3N5bWJvbHMnKS5zY29wZVN5bWJvbDtcblxuY29uc3QgaXNQT0pPID0gdXRpbHMuaXNQT0pPO1xuXG4vKiFcbiAqIGV4cG9ydHNcbiAqL1xuXG5leHBvcnRzLmNvbXBpbGUgPSBjb21waWxlO1xuZXhwb3J0cy5kZWZpbmVLZXkgPSBkZWZpbmVLZXk7XG5cbmNvbnN0IF9pc0VtcHR5T3B0aW9ucyA9IE9iamVjdC5mcmVlemUoe1xuICBtaW5pbWl6ZTogdHJ1ZSxcbiAgdmlydHVhbHM6IGZhbHNlLFxuICBnZXR0ZXJzOiBmYWxzZSxcbiAgdHJhbnNmb3JtOiBmYWxzZVxufSk7XG5cbmNvbnN0IG5vRG90dGVkUGF0aEdldE9wdGlvbnMgPSBPYmplY3QuZnJlZXplKHtcbiAgbm9Eb3R0ZWRQYXRoOiB0cnVlXG59KTtcblxuLyoqXG4gKiBDb21waWxlcyBzY2hlbWFzLlxuICogQHBhcmFtIHtPYmplY3R9IHRyZWVcbiAqIEBwYXJhbSB7QW55fSBwcm90b1xuICogQHBhcmFtIHtTdHJpbmd9IHByZWZpeFxuICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmZ1bmN0aW9uIGNvbXBpbGUodHJlZSwgcHJvdG8sIHByZWZpeCwgb3B0aW9ucykge1xuICBEb2N1bWVudCA9IERvY3VtZW50IHx8IHJlcXVpcmUoJy4uLy4uL2RvY3VtZW50Jyk7XG4gIGNvbnN0IHR5cGVLZXkgPSBvcHRpb25zLnR5cGVLZXk7XG5cbiAgZm9yIChjb25zdCBrZXkgb2YgT2JqZWN0LmtleXModHJlZSkpIHtcbiAgICBjb25zdCBsaW1iID0gdHJlZVtrZXldO1xuXG4gICAgY29uc3QgaGFzU3VicHJvcHMgPSBpc1BPSk8obGltYikgJiZcbiAgICAgIE9iamVjdC5rZXlzKGxpbWIpLmxlbmd0aCA+IDAgJiZcbiAgICAgICghbGltYlt0eXBlS2V5XSB8fCAodHlwZUtleSA9PT0gJ3R5cGUnICYmIGlzUE9KTyhsaW1iLnR5cGUpICYmIGxpbWIudHlwZS50eXBlKSk7XG4gICAgY29uc3Qgc3VicHJvcHMgPSBoYXNTdWJwcm9wcyA/IGxpbWIgOiBudWxsO1xuXG4gICAgZGVmaW5lS2V5KHsgcHJvcDoga2V5LCBzdWJwcm9wczogc3VicHJvcHMsIHByb3RvdHlwZTogcHJvdG8sIHByZWZpeDogcHJlZml4LCBvcHRpb25zOiBvcHRpb25zIH0pO1xuICB9XG59XG5cbi8qKlxuICogRGVmaW5lcyB0aGUgYWNjZXNzb3IgbmFtZWQgcHJvcCBvbiB0aGUgaW5jb21pbmcgcHJvdG90eXBlLlxuICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcbiAqIEBwYXJhbSB7U3RyaW5nfSBvcHRpb25zLnByb3BcbiAqIEBwYXJhbSB7Qm9vbGVhbn0gb3B0aW9ucy5zdWJwcm9wc1xuICogQHBhcmFtIHtBbnl9IG9wdGlvbnMucHJvdG90eXBlXG4gKiBAcGFyYW0ge1N0cmluZ30gW29wdGlvbnMucHJlZml4XVxuICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMub3B0aW9uc1xuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZnVuY3Rpb24gZGVmaW5lS2V5KHsgcHJvcCwgc3VicHJvcHMsIHByb3RvdHlwZSwgcHJlZml4LCBvcHRpb25zIH0pIHtcbiAgRG9jdW1lbnQgPSBEb2N1bWVudCB8fCByZXF1aXJlKCcuLi8uLi9kb2N1bWVudCcpO1xuICBjb25zdCBwYXRoID0gKHByZWZpeCA/IHByZWZpeCArICcuJyA6ICcnKSArIHByb3A7XG4gIHByZWZpeCA9IHByZWZpeCB8fCAnJztcbiAgY29uc3QgdXNlR2V0T3B0aW9ucyA9IHByZWZpeCA/IE9iamVjdC5mcmVlemUoe30pIDogbm9Eb3R0ZWRQYXRoR2V0T3B0aW9ucztcblxuICBpZiAoc3VicHJvcHMpIHtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkocHJvdG90eXBlLCBwcm9wLCB7XG4gICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgY29uc3QgX3RoaXMgPSB0aGlzO1xuICAgICAgICBpZiAoIXRoaXMuJF9fLmdldHRlcnMpIHtcbiAgICAgICAgICB0aGlzLiRfXy5nZXR0ZXJzID0ge307XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIXRoaXMuJF9fLmdldHRlcnNbcGF0aF0pIHtcbiAgICAgICAgICBjb25zdCBuZXN0ZWQgPSBPYmplY3QuY3JlYXRlKERvY3VtZW50LnByb3RvdHlwZSwgZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyh0aGlzKSk7XG5cbiAgICAgICAgICAvLyBzYXZlIHNjb3BlIGZvciBuZXN0ZWQgZ2V0dGVycy9zZXR0ZXJzXG4gICAgICAgICAgaWYgKCFwcmVmaXgpIHtcbiAgICAgICAgICAgIG5lc3RlZC4kX19bc2NvcGVTeW1ib2xdID0gdGhpcztcbiAgICAgICAgICB9XG4gICAgICAgICAgbmVzdGVkLiRfXy5uZXN0ZWRQYXRoID0gcGF0aDtcblxuICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShuZXN0ZWQsICdzY2hlbWEnLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiBmYWxzZSxcbiAgICAgICAgICAgIHZhbHVlOiBwcm90b3R5cGUuc2NoZW1hXG4gICAgICAgICAgfSk7XG5cbiAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobmVzdGVkLCAnJF9fc2NoZW1hJywge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogZmFsc2UsXG4gICAgICAgICAgICB2YWx1ZTogcHJvdG90eXBlLnNjaGVtYVxuICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG5lc3RlZCwgZG9jdW1lbnRTY2hlbWFTeW1ib2wsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IGZhbHNlLFxuICAgICAgICAgICAgdmFsdWU6IHByb3RvdHlwZS5zY2hlbWFcbiAgICAgICAgICB9KTtcblxuICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShuZXN0ZWQsICd0b09iamVjdCcsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IGZhbHNlLFxuICAgICAgICAgICAgdmFsdWU6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICByZXR1cm4gY2xvbmUoX3RoaXMuZ2V0KHBhdGgsIG51bGwsIHtcbiAgICAgICAgICAgICAgICB2aXJ0dWFsczogdGhpcyAmJlxuICAgICAgICAgICAgICAgICAgdGhpcy5zY2hlbWEgJiZcbiAgICAgICAgICAgICAgICAgIHRoaXMuc2NoZW1hLm9wdGlvbnMgJiZcbiAgICAgICAgICAgICAgICAgIHRoaXMuc2NoZW1hLm9wdGlvbnMudG9PYmplY3QgJiZcbiAgICAgICAgICAgICAgICAgIHRoaXMuc2NoZW1hLm9wdGlvbnMudG9PYmplY3QudmlydHVhbHMgfHwgbnVsbFxuICAgICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG5cbiAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobmVzdGVkLCAnJF9fZ2V0Jywge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogZmFsc2UsXG4gICAgICAgICAgICB2YWx1ZTogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgIHJldHVybiBfdGhpcy5nZXQocGF0aCwgbnVsbCwge1xuICAgICAgICAgICAgICAgIHZpcnR1YWxzOiB0aGlzICYmIHRoaXMuc2NoZW1hICYmIHRoaXMuc2NoZW1hLm9wdGlvbnMgJiYgdGhpcy5zY2hlbWEub3B0aW9ucy50b09iamVjdCAmJiB0aGlzLnNjaGVtYS5vcHRpb25zLnRvT2JqZWN0LnZpcnR1YWxzIHx8IG51bGxcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG5cbiAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobmVzdGVkLCAndG9KU09OJywge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogZmFsc2UsXG4gICAgICAgICAgICB2YWx1ZTogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgIHJldHVybiBfdGhpcy5nZXQocGF0aCwgbnVsbCwge1xuICAgICAgICAgICAgICAgIHZpcnR1YWxzOiB0aGlzICYmIHRoaXMuc2NoZW1hICYmIHRoaXMuc2NoZW1hLm9wdGlvbnMgJiYgdGhpcy5zY2hlbWEub3B0aW9ucy50b0pTT04gJiYgdGhpcy5zY2hlbWEub3B0aW9ucy50b0pTT04udmlydHVhbHMgfHwgbnVsbFxuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcblxuICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShuZXN0ZWQsICckX19pc05lc3RlZCcsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IGZhbHNlLFxuICAgICAgICAgICAgdmFsdWU6IHRydWVcbiAgICAgICAgICB9KTtcblxuICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShuZXN0ZWQsICckaXNFbXB0eScsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IGZhbHNlLFxuICAgICAgICAgICAgdmFsdWU6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICByZXR1cm4gT2JqZWN0LmtleXModGhpcy5nZXQocGF0aCwgbnVsbCwgX2lzRW1wdHlPcHRpb25zKSB8fCB7fSkubGVuZ3RoID09PSAwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG5lc3RlZCwgJyRfX3BhcmVudCcsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IGZhbHNlLFxuICAgICAgICAgICAgdmFsdWU6IHRoaXNcbiAgICAgICAgICB9KTtcblxuICAgICAgICAgIGNvbXBpbGUoc3VicHJvcHMsIG5lc3RlZCwgcGF0aCwgb3B0aW9ucyk7XG4gICAgICAgICAgdGhpcy4kX18uZ2V0dGVyc1twYXRoXSA9IG5lc3RlZDtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0aGlzLiRfXy5nZXR0ZXJzW3BhdGhdO1xuICAgICAgfSxcbiAgICAgIHNldDogZnVuY3Rpb24odikge1xuICAgICAgICBpZiAodiAhPSBudWxsICYmIHYuJF9faXNOZXN0ZWQpIHtcbiAgICAgICAgICAvLyBDb252ZXJ0IHRvcC1sZXZlbCB0byBQT0pPLCBidXQgbGVhdmUgc3ViZG9jcyBoeWRyYXRlZCBzbyBgJHNldGBcbiAgICAgICAgICAvLyBjYW4gaGFuZGxlIHRoZW0uIFNlZSBnaC05MjkzLlxuICAgICAgICAgIHYgPSB2LiRfX2dldCgpO1xuICAgICAgICB9IGVsc2UgaWYgKHYgaW5zdGFuY2VvZiBEb2N1bWVudCAmJiAhdi4kX19pc05lc3RlZCkge1xuICAgICAgICAgIHYgPSB2LiR0b09iamVjdChpbnRlcm5hbFRvT2JqZWN0T3B0aW9ucyk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgZG9jID0gdGhpcy4kX19bc2NvcGVTeW1ib2xdIHx8IHRoaXM7XG4gICAgICAgIGRvYy4kc2V0KHBhdGgsIHYpO1xuICAgICAgfVxuICAgIH0pO1xuICB9IGVsc2Uge1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShwcm90b3R5cGUsIHByb3AsIHtcbiAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpc1tnZXRTeW1ib2xdLmNhbGwoXG4gICAgICAgICAgdGhpcy4kX19bc2NvcGVTeW1ib2xdIHx8IHRoaXMsXG4gICAgICAgICAgcGF0aCxcbiAgICAgICAgICBudWxsLFxuICAgICAgICAgIHVzZUdldE9wdGlvbnNcbiAgICAgICAgKTtcbiAgICAgIH0sXG4gICAgICBzZXQ6IGZ1bmN0aW9uKHYpIHtcbiAgICAgICAgdGhpcy4kc2V0LmNhbGwodGhpcy4kX19bc2NvcGVTeW1ib2xdIHx8IHRoaXMsIHBhdGgsIHYpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG59XG5cbi8vIGdldHMgZGVzY3JpcHRvcnMgZm9yIGFsbCBwcm9wZXJ0aWVzIG9mIGBvYmplY3RgXG4vLyBtYWtlcyBhbGwgcHJvcGVydGllcyBub24tZW51bWVyYWJsZSB0byBtYXRjaCBwcmV2aW91cyBiZWhhdmlvciB0byAjMjIxMVxuZnVuY3Rpb24gZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyhvYmplY3QpIHtcbiAgY29uc3QgcmVzdWx0ID0ge307XG5cbiAgT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMob2JqZWN0KS5mb3JFYWNoKGZ1bmN0aW9uKGtleSkge1xuICAgIGNvbnN0IHNraXAgPSBbXG4gICAgICAnaXNOZXcnLFxuICAgICAgJyRfXycsXG4gICAgICAnJGVycm9ycycsXG4gICAgICAnZXJyb3JzJyxcbiAgICAgICdfZG9jJyxcbiAgICAgICckbG9jYWxzJyxcbiAgICAgICckb3AnLFxuICAgICAgJ19fcGFyZW50QXJyYXknLFxuICAgICAgJ19faW5kZXgnLFxuICAgICAgJyRpc0RvY3VtZW50QXJyYXlFbGVtZW50J1xuICAgIF0uaW5kZXhPZihrZXkpID09PSAtMTtcbiAgICBpZiAoc2tpcCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHJlc3VsdFtrZXldID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihvYmplY3QsIGtleSk7XG4gICAgcmVzdWx0W2tleV0uZW51bWVyYWJsZSA9IGZhbHNlO1xuICB9KTtcblxuICByZXR1cm4gcmVzdWx0O1xufVxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/mongoose/lib/helpers/document/compile.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/mongoose/lib/helpers/document/getDeepestSubdocumentForPath.js":
/*!************************************************************************************!*\
  !*** ./node_modules/mongoose/lib/helpers/document/getDeepestSubdocumentForPath.js ***!
  \************************************************************************************/
/***/ ((module) => {

eval("\n\n/**\n * Find the deepest subdocument along a given path to ensure setter functions run\n * with the correct subdocument as `this`. If no subdocuments, returns the top-level\n * document.\n *\n * @param {Document} doc\n * @param {String[]} parts\n * @param {Schema} schema\n * @returns Document\n */\n\nmodule.exports = function getDeepestSubdocumentForPath(doc, parts, schema) {\n  let curPath = parts[0];\n  let curSchema = schema;\n  let subdoc = doc;\n  for (let i = 0; i < parts.length - 1; ++i) {\n    const curSchemaType = curSchema.path(curPath);\n    if (curSchemaType && curSchemaType.schema) {\n      let newSubdoc = subdoc.get(curPath);\n      curSchema = curSchemaType.schema;\n      curPath = parts[i + 1];\n      if (Array.isArray(newSubdoc) && !isNaN(curPath)) {\n        newSubdoc = newSubdoc[curPath];\n        curPath = '';\n      }\n      if (newSubdoc == null) {\n        break;\n      }\n      subdoc = newSubdoc;\n    } else {\n      curPath += curPath.length ? '.' + parts[i + 1] : parts[i + 1];\n    }\n  }\n\n  return subdoc;\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbW9uZ29vc2UvbGliL2hlbHBlcnMvZG9jdW1lbnQvZ2V0RGVlcGVzdFN1YmRvY3VtZW50Rm9yUGF0aC5qcyIsIm1hcHBpbmdzIjoiQUFBYTs7QUFFYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxVQUFVO0FBQ3JCLFdBQVcsVUFBVTtBQUNyQixXQUFXLFFBQVE7QUFDbkI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixzQkFBc0I7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBOztBQUVBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9hcHAxLy4vbm9kZV9tb2R1bGVzL21vbmdvb3NlL2xpYi9oZWxwZXJzL2RvY3VtZW50L2dldERlZXBlc3RTdWJkb2N1bWVudEZvclBhdGguanM/ODZjMyJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbi8qKlxuICogRmluZCB0aGUgZGVlcGVzdCBzdWJkb2N1bWVudCBhbG9uZyBhIGdpdmVuIHBhdGggdG8gZW5zdXJlIHNldHRlciBmdW5jdGlvbnMgcnVuXG4gKiB3aXRoIHRoZSBjb3JyZWN0IHN1YmRvY3VtZW50IGFzIGB0aGlzYC4gSWYgbm8gc3ViZG9jdW1lbnRzLCByZXR1cm5zIHRoZSB0b3AtbGV2ZWxcbiAqIGRvY3VtZW50LlxuICpcbiAqIEBwYXJhbSB7RG9jdW1lbnR9IGRvY1xuICogQHBhcmFtIHtTdHJpbmdbXX0gcGFydHNcbiAqIEBwYXJhbSB7U2NoZW1hfSBzY2hlbWFcbiAqIEByZXR1cm5zIERvY3VtZW50XG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBnZXREZWVwZXN0U3ViZG9jdW1lbnRGb3JQYXRoKGRvYywgcGFydHMsIHNjaGVtYSkge1xuICBsZXQgY3VyUGF0aCA9IHBhcnRzWzBdO1xuICBsZXQgY3VyU2NoZW1hID0gc2NoZW1hO1xuICBsZXQgc3ViZG9jID0gZG9jO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IHBhcnRzLmxlbmd0aCAtIDE7ICsraSkge1xuICAgIGNvbnN0IGN1clNjaGVtYVR5cGUgPSBjdXJTY2hlbWEucGF0aChjdXJQYXRoKTtcbiAgICBpZiAoY3VyU2NoZW1hVHlwZSAmJiBjdXJTY2hlbWFUeXBlLnNjaGVtYSkge1xuICAgICAgbGV0IG5ld1N1YmRvYyA9IHN1YmRvYy5nZXQoY3VyUGF0aCk7XG4gICAgICBjdXJTY2hlbWEgPSBjdXJTY2hlbWFUeXBlLnNjaGVtYTtcbiAgICAgIGN1clBhdGggPSBwYXJ0c1tpICsgMV07XG4gICAgICBpZiAoQXJyYXkuaXNBcnJheShuZXdTdWJkb2MpICYmICFpc05hTihjdXJQYXRoKSkge1xuICAgICAgICBuZXdTdWJkb2MgPSBuZXdTdWJkb2NbY3VyUGF0aF07XG4gICAgICAgIGN1clBhdGggPSAnJztcbiAgICAgIH1cbiAgICAgIGlmIChuZXdTdWJkb2MgPT0gbnVsbCkge1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIHN1YmRvYyA9IG5ld1N1YmRvYztcbiAgICB9IGVsc2Uge1xuICAgICAgY3VyUGF0aCArPSBjdXJQYXRoLmxlbmd0aCA/ICcuJyArIHBhcnRzW2kgKyAxXSA6IHBhcnRzW2kgKyAxXTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gc3ViZG9jO1xufTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/mongoose/lib/helpers/document/getDeepestSubdocumentForPath.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/mongoose/lib/helpers/document/getEmbeddedDiscriminatorPath.js":
/*!************************************************************************************!*\
  !*** ./node_modules/mongoose/lib/helpers/document/getEmbeddedDiscriminatorPath.js ***!
  \************************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\n\nconst get = __webpack_require__(/*! ../get */ \"(ssr)/./node_modules/mongoose/lib/helpers/get.js\");\nconst getSchemaDiscriminatorByValue = __webpack_require__(/*! ../discriminator/getSchemaDiscriminatorByValue */ \"(ssr)/./node_modules/mongoose/lib/helpers/discriminator/getSchemaDiscriminatorByValue.js\");\n\n/**\n * Like `schema.path()`, except with a document, because impossible to\n * determine path type without knowing the embedded discriminator key.\n *\n * @param {Document} doc\n * @param {String|String[]} path\n * @param {Object} [options]\n * @api private\n */\n\nmodule.exports = function getEmbeddedDiscriminatorPath(doc, path, options) {\n  options = options || {};\n  const typeOnly = options.typeOnly;\n  const parts = Array.isArray(path) ?\n    path :\n    (path.indexOf('.') === -1 ? [path] : path.split('.'));\n  let schemaType = null;\n  let type = 'adhocOrUndefined';\n\n  const schema = getSchemaDiscriminatorByValue(doc.schema, doc.get(doc.schema.options.discriminatorKey)) || doc.schema;\n\n  for (let i = 0; i < parts.length; ++i) {\n    const subpath = parts.slice(0, i + 1).join('.');\n    schemaType = schema.path(subpath);\n    if (schemaType == null) {\n      type = 'adhocOrUndefined';\n      continue;\n    }\n    if (schemaType.instance === 'Mixed') {\n      return typeOnly ? 'real' : schemaType;\n    }\n    type = schema.pathType(subpath);\n    if ((schemaType.$isSingleNested || schemaType.$isMongooseDocumentArrayElement) &&\n    schemaType.schema.discriminators != null) {\n      const discriminators = schemaType.schema.discriminators;\n      const discriminatorKey = doc.get(subpath + '.' +\n        get(schemaType, 'schema.options.discriminatorKey'));\n      if (discriminatorKey == null || discriminators[discriminatorKey] == null) {\n        continue;\n      }\n      const rest = parts.slice(i + 1).join('.');\n      return getEmbeddedDiscriminatorPath(doc.get(subpath), rest, options);\n    }\n  }\n\n  // Are we getting the whole schema or just the type, 'real', 'nested', etc.\n  return typeOnly ? type : schemaType;\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbW9uZ29vc2UvbGliL2hlbHBlcnMvZG9jdW1lbnQvZ2V0RW1iZWRkZWREaXNjcmltaW5hdG9yUGF0aC5qcyIsIm1hcHBpbmdzIjoiQUFBYTs7QUFFYixZQUFZLG1CQUFPLENBQUMsZ0VBQVE7QUFDNUIsc0NBQXNDLG1CQUFPLENBQUMsZ0pBQWdEOztBQUU5RjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsVUFBVTtBQUNyQixXQUFXLGlCQUFpQjtBQUM1QixXQUFXLFFBQVE7QUFDbkI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBLGtCQUFrQixrQkFBa0I7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vYXBwMS8uL25vZGVfbW9kdWxlcy9tb25nb29zZS9saWIvaGVscGVycy9kb2N1bWVudC9nZXRFbWJlZGRlZERpc2NyaW1pbmF0b3JQYXRoLmpzPzMzNzIiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG5jb25zdCBnZXQgPSByZXF1aXJlKCcuLi9nZXQnKTtcbmNvbnN0IGdldFNjaGVtYURpc2NyaW1pbmF0b3JCeVZhbHVlID0gcmVxdWlyZSgnLi4vZGlzY3JpbWluYXRvci9nZXRTY2hlbWFEaXNjcmltaW5hdG9yQnlWYWx1ZScpO1xuXG4vKipcbiAqIExpa2UgYHNjaGVtYS5wYXRoKClgLCBleGNlcHQgd2l0aCBhIGRvY3VtZW50LCBiZWNhdXNlIGltcG9zc2libGUgdG9cbiAqIGRldGVybWluZSBwYXRoIHR5cGUgd2l0aG91dCBrbm93aW5nIHRoZSBlbWJlZGRlZCBkaXNjcmltaW5hdG9yIGtleS5cbiAqXG4gKiBAcGFyYW0ge0RvY3VtZW50fSBkb2NcbiAqIEBwYXJhbSB7U3RyaW5nfFN0cmluZ1tdfSBwYXRoXG4gKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGdldEVtYmVkZGVkRGlzY3JpbWluYXRvclBhdGgoZG9jLCBwYXRoLCBvcHRpb25zKSB7XG4gIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICBjb25zdCB0eXBlT25seSA9IG9wdGlvbnMudHlwZU9ubHk7XG4gIGNvbnN0IHBhcnRzID0gQXJyYXkuaXNBcnJheShwYXRoKSA/XG4gICAgcGF0aCA6XG4gICAgKHBhdGguaW5kZXhPZignLicpID09PSAtMSA/IFtwYXRoXSA6IHBhdGguc3BsaXQoJy4nKSk7XG4gIGxldCBzY2hlbWFUeXBlID0gbnVsbDtcbiAgbGV0IHR5cGUgPSAnYWRob2NPclVuZGVmaW5lZCc7XG5cbiAgY29uc3Qgc2NoZW1hID0gZ2V0U2NoZW1hRGlzY3JpbWluYXRvckJ5VmFsdWUoZG9jLnNjaGVtYSwgZG9jLmdldChkb2Muc2NoZW1hLm9wdGlvbnMuZGlzY3JpbWluYXRvcktleSkpIHx8IGRvYy5zY2hlbWE7XG5cbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBwYXJ0cy5sZW5ndGg7ICsraSkge1xuICAgIGNvbnN0IHN1YnBhdGggPSBwYXJ0cy5zbGljZSgwLCBpICsgMSkuam9pbignLicpO1xuICAgIHNjaGVtYVR5cGUgPSBzY2hlbWEucGF0aChzdWJwYXRoKTtcbiAgICBpZiAoc2NoZW1hVHlwZSA9PSBudWxsKSB7XG4gICAgICB0eXBlID0gJ2FkaG9jT3JVbmRlZmluZWQnO1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIGlmIChzY2hlbWFUeXBlLmluc3RhbmNlID09PSAnTWl4ZWQnKSB7XG4gICAgICByZXR1cm4gdHlwZU9ubHkgPyAncmVhbCcgOiBzY2hlbWFUeXBlO1xuICAgIH1cbiAgICB0eXBlID0gc2NoZW1hLnBhdGhUeXBlKHN1YnBhdGgpO1xuICAgIGlmICgoc2NoZW1hVHlwZS4kaXNTaW5nbGVOZXN0ZWQgfHwgc2NoZW1hVHlwZS4kaXNNb25nb29zZURvY3VtZW50QXJyYXlFbGVtZW50KSAmJlxuICAgIHNjaGVtYVR5cGUuc2NoZW1hLmRpc2NyaW1pbmF0b3JzICE9IG51bGwpIHtcbiAgICAgIGNvbnN0IGRpc2NyaW1pbmF0b3JzID0gc2NoZW1hVHlwZS5zY2hlbWEuZGlzY3JpbWluYXRvcnM7XG4gICAgICBjb25zdCBkaXNjcmltaW5hdG9yS2V5ID0gZG9jLmdldChzdWJwYXRoICsgJy4nICtcbiAgICAgICAgZ2V0KHNjaGVtYVR5cGUsICdzY2hlbWEub3B0aW9ucy5kaXNjcmltaW5hdG9yS2V5JykpO1xuICAgICAgaWYgKGRpc2NyaW1pbmF0b3JLZXkgPT0gbnVsbCB8fCBkaXNjcmltaW5hdG9yc1tkaXNjcmltaW5hdG9yS2V5XSA9PSBudWxsKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgY29uc3QgcmVzdCA9IHBhcnRzLnNsaWNlKGkgKyAxKS5qb2luKCcuJyk7XG4gICAgICByZXR1cm4gZ2V0RW1iZWRkZWREaXNjcmltaW5hdG9yUGF0aChkb2MuZ2V0KHN1YnBhdGgpLCByZXN0LCBvcHRpb25zKTtcbiAgICB9XG4gIH1cblxuICAvLyBBcmUgd2UgZ2V0dGluZyB0aGUgd2hvbGUgc2NoZW1hIG9yIGp1c3QgdGhlIHR5cGUsICdyZWFsJywgJ25lc3RlZCcsIGV0Yy5cbiAgcmV0dXJuIHR5cGVPbmx5ID8gdHlwZSA6IHNjaGVtYVR5cGU7XG59O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/mongoose/lib/helpers/document/getEmbeddedDiscriminatorPath.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/mongoose/lib/helpers/document/handleSpreadDoc.js":
/*!***********************************************************************!*\
  !*** ./node_modules/mongoose/lib/helpers/document/handleSpreadDoc.js ***!
  \***********************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\n\nconst utils = __webpack_require__(/*! ../../utils */ \"(ssr)/./node_modules/mongoose/lib/utils.js\");\n\nconst keysToSkip = new Set(['__index', '__parentArray', '_doc']);\n\n/**\n * Using spread operator on a Mongoose document gives you a\n * POJO that has a tendency to cause infinite recursion. So\n * we use this function on `set()` to prevent that.\n */\n\nmodule.exports = function handleSpreadDoc(v, includeExtraKeys) {\n  if (utils.isPOJO(v) && v.$__ != null && v._doc != null) {\n    if (includeExtraKeys) {\n      const extraKeys = {};\n      for (const key of Object.keys(v)) {\n        if (typeof key === 'symbol') {\n          continue;\n        }\n        if (key[0] === '$') {\n          continue;\n        }\n        if (keysToSkip.has(key)) {\n          continue;\n        }\n        extraKeys[key] = v[key];\n      }\n      return { ...v._doc, ...extraKeys };\n    }\n    return v._doc;\n  }\n\n  return v;\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbW9uZ29vc2UvbGliL2hlbHBlcnMvZG9jdW1lbnQvaGFuZGxlU3ByZWFkRG9jLmpzIiwibWFwcGluZ3MiOiJBQUFhOztBQUViLGNBQWMsbUJBQU8sQ0FBQywrREFBYTs7QUFFbkM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7O0FBRUE7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL2FwcDEvLi9ub2RlX21vZHVsZXMvbW9uZ29vc2UvbGliL2hlbHBlcnMvZG9jdW1lbnQvaGFuZGxlU3ByZWFkRG9jLmpzP2Q3NGUiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG5jb25zdCB1dGlscyA9IHJlcXVpcmUoJy4uLy4uL3V0aWxzJyk7XG5cbmNvbnN0IGtleXNUb1NraXAgPSBuZXcgU2V0KFsnX19pbmRleCcsICdfX3BhcmVudEFycmF5JywgJ19kb2MnXSk7XG5cbi8qKlxuICogVXNpbmcgc3ByZWFkIG9wZXJhdG9yIG9uIGEgTW9uZ29vc2UgZG9jdW1lbnQgZ2l2ZXMgeW91IGFcbiAqIFBPSk8gdGhhdCBoYXMgYSB0ZW5kZW5jeSB0byBjYXVzZSBpbmZpbml0ZSByZWN1cnNpb24uIFNvXG4gKiB3ZSB1c2UgdGhpcyBmdW5jdGlvbiBvbiBgc2V0KClgIHRvIHByZXZlbnQgdGhhdC5cbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGhhbmRsZVNwcmVhZERvYyh2LCBpbmNsdWRlRXh0cmFLZXlzKSB7XG4gIGlmICh1dGlscy5pc1BPSk8odikgJiYgdi4kX18gIT0gbnVsbCAmJiB2Ll9kb2MgIT0gbnVsbCkge1xuICAgIGlmIChpbmNsdWRlRXh0cmFLZXlzKSB7XG4gICAgICBjb25zdCBleHRyYUtleXMgPSB7fTtcbiAgICAgIGZvciAoY29uc3Qga2V5IG9mIE9iamVjdC5rZXlzKHYpKSB7XG4gICAgICAgIGlmICh0eXBlb2Yga2V5ID09PSAnc3ltYm9sJykge1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChrZXlbMF0gPT09ICckJykge1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChrZXlzVG9Ta2lwLmhhcyhrZXkpKSB7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgZXh0cmFLZXlzW2tleV0gPSB2W2tleV07XG4gICAgICB9XG4gICAgICByZXR1cm4geyAuLi52Ll9kb2MsIC4uLmV4dHJhS2V5cyB9O1xuICAgIH1cbiAgICByZXR1cm4gdi5fZG9jO1xuICB9XG5cbiAgcmV0dXJuIHY7XG59O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/mongoose/lib/helpers/document/handleSpreadDoc.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/mongoose/lib/helpers/each.js":
/*!***************************************************!*\
  !*** ./node_modules/mongoose/lib/helpers/each.js ***!
  \***************************************************/
/***/ ((module) => {

eval("\n\nmodule.exports = function each(arr, cb, done) {\n  if (arr.length === 0) {\n    return done();\n  }\n\n  let remaining = arr.length;\n  let err = null;\n  for (const v of arr) {\n    cb(v, function(_err) {\n      if (err != null) {\n        return;\n      }\n      if (_err != null) {\n        err = _err;\n        return done(err);\n      }\n\n      if (--remaining <= 0) {\n        return done();\n      }\n    });\n  }\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbW9uZ29vc2UvbGliL2hlbHBlcnMvZWFjaC5qcyIsIm1hcHBpbmdzIjoiQUFBYTs7QUFFYjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vYXBwMS8uL25vZGVfbW9kdWxlcy9tb25nb29zZS9saWIvaGVscGVycy9lYWNoLmpzPzdhZjIiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGVhY2goYXJyLCBjYiwgZG9uZSkge1xuICBpZiAoYXJyLmxlbmd0aCA9PT0gMCkge1xuICAgIHJldHVybiBkb25lKCk7XG4gIH1cblxuICBsZXQgcmVtYWluaW5nID0gYXJyLmxlbmd0aDtcbiAgbGV0IGVyciA9IG51bGw7XG4gIGZvciAoY29uc3QgdiBvZiBhcnIpIHtcbiAgICBjYih2LCBmdW5jdGlvbihfZXJyKSB7XG4gICAgICBpZiAoZXJyICE9IG51bGwpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgaWYgKF9lcnIgIT0gbnVsbCkge1xuICAgICAgICBlcnIgPSBfZXJyO1xuICAgICAgICByZXR1cm4gZG9uZShlcnIpO1xuICAgICAgfVxuXG4gICAgICBpZiAoLS1yZW1haW5pbmcgPD0gMCkge1xuICAgICAgICByZXR1cm4gZG9uZSgpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG59O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/mongoose/lib/helpers/each.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/mongoose/lib/helpers/error/combinePathErrors.js":
/*!**********************************************************************!*\
  !*** ./node_modules/mongoose/lib/helpers/error/combinePathErrors.js ***!
  \**********************************************************************/
/***/ ((module) => {

eval("\n\n/*!\n * ignore\n */\n\nmodule.exports = function combinePathErrors(err) {\n  const keys = Object.keys(err.errors || {});\n  const len = keys.length;\n  const msgs = [];\n  let key;\n\n  for (let i = 0; i < len; ++i) {\n    key = keys[i];\n    if (err === err.errors[key]) {\n      continue;\n    }\n    msgs.push(key + ': ' + err.errors[key].message);\n  }\n\n  return msgs.join(', ');\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbW9uZ29vc2UvbGliL2hlbHBlcnMvZXJyb3IvY29tYmluZVBhdGhFcnJvcnMuanMiLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWI7QUFDQTtBQUNBOztBQUVBO0FBQ0EsMkNBQTJDO0FBQzNDO0FBQ0E7QUFDQTs7QUFFQSxrQkFBa0IsU0FBUztBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL2FwcDEvLi9ub2RlX21vZHVsZXMvbW9uZ29vc2UvbGliL2hlbHBlcnMvZXJyb3IvY29tYmluZVBhdGhFcnJvcnMuanM/Zjc2NCJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbi8qIVxuICogaWdub3JlXG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBjb21iaW5lUGF0aEVycm9ycyhlcnIpIHtcbiAgY29uc3Qga2V5cyA9IE9iamVjdC5rZXlzKGVyci5lcnJvcnMgfHwge30pO1xuICBjb25zdCBsZW4gPSBrZXlzLmxlbmd0aDtcbiAgY29uc3QgbXNncyA9IFtdO1xuICBsZXQga2V5O1xuXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgbGVuOyArK2kpIHtcbiAgICBrZXkgPSBrZXlzW2ldO1xuICAgIGlmIChlcnIgPT09IGVyci5lcnJvcnNba2V5XSkge1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIG1zZ3MucHVzaChrZXkgKyAnOiAnICsgZXJyLmVycm9yc1trZXldLm1lc3NhZ2UpO1xuICB9XG5cbiAgcmV0dXJuIG1zZ3Muam9pbignLCAnKTtcbn07XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/mongoose/lib/helpers/error/combinePathErrors.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/mongoose/lib/helpers/firstKey.js":
/*!*******************************************************!*\
  !*** ./node_modules/mongoose/lib/helpers/firstKey.js ***!
  \*******************************************************/
/***/ ((module) => {

eval("\n\nmodule.exports = function firstKey(obj) {\n  if (obj == null) {\n    return null;\n  }\n  return Object.keys(obj)[0];\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbW9uZ29vc2UvbGliL2hlbHBlcnMvZmlyc3RLZXkuanMiLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vYXBwMS8uL25vZGVfbW9kdWxlcy9tb25nb29zZS9saWIvaGVscGVycy9maXJzdEtleS5qcz83YjdlIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBmaXJzdEtleShvYmopIHtcbiAgaWYgKG9iaiA9PSBudWxsKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgcmV0dXJuIE9iamVjdC5rZXlzKG9iailbMF07XG59O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/mongoose/lib/helpers/firstKey.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/mongoose/lib/helpers/get.js":
/*!**************************************************!*\
  !*** ./node_modules/mongoose/lib/helpers/get.js ***!
  \**************************************************/
/***/ ((module) => {

eval("\n\n/**\n * Simplified lodash.get to work around the annoying null quirk. See:\n * https://github.com/lodash/lodash/issues/3659\n * @api private\n */\n\nmodule.exports = function get(obj, path, def) {\n  let parts;\n  let isPathArray = false;\n  if (typeof path === 'string') {\n    if (path.indexOf('.') === -1) {\n      const _v = getProperty(obj, path);\n      if (_v == null) {\n        return def;\n      }\n      return _v;\n    }\n\n    parts = path.split('.');\n  } else {\n    isPathArray = true;\n    parts = path;\n\n    if (parts.length === 1) {\n      const _v = getProperty(obj, parts[0]);\n      if (_v == null) {\n        return def;\n      }\n      return _v;\n    }\n  }\n  let rest = path;\n  let cur = obj;\n  for (const part of parts) {\n    if (cur == null) {\n      return def;\n    }\n\n    // `lib/cast.js` depends on being able to get dotted paths in updates,\n    // like `{ $set: { 'a.b': 42 } }`\n    if (!isPathArray && cur[rest] != null) {\n      return cur[rest];\n    }\n\n    cur = getProperty(cur, part);\n\n    if (!isPathArray) {\n      rest = rest.substr(part.length + 1);\n    }\n  }\n\n  return cur == null ? def : cur;\n};\n\nfunction getProperty(obj, prop) {\n  if (obj == null) {\n    return obj;\n  }\n  if (obj instanceof Map) {\n    return obj.get(prop);\n  }\n  return obj[prop];\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbW9uZ29vc2UvbGliL2hlbHBlcnMvZ2V0LmpzIiwibWFwcGluZ3MiOiJBQUFhOztBQUViO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLElBQUk7QUFDSjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxlQUFlLFFBQVEsYUFBYTtBQUNwQztBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9hcHAxLy4vbm9kZV9tb2R1bGVzL21vbmdvb3NlL2xpYi9oZWxwZXJzL2dldC5qcz85MjY5Il0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxuLyoqXG4gKiBTaW1wbGlmaWVkIGxvZGFzaC5nZXQgdG8gd29yayBhcm91bmQgdGhlIGFubm95aW5nIG51bGwgcXVpcmsuIFNlZTpcbiAqIGh0dHBzOi8vZ2l0aHViLmNvbS9sb2Rhc2gvbG9kYXNoL2lzc3Vlcy8zNjU5XG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGdldChvYmosIHBhdGgsIGRlZikge1xuICBsZXQgcGFydHM7XG4gIGxldCBpc1BhdGhBcnJheSA9IGZhbHNlO1xuICBpZiAodHlwZW9mIHBhdGggPT09ICdzdHJpbmcnKSB7XG4gICAgaWYgKHBhdGguaW5kZXhPZignLicpID09PSAtMSkge1xuICAgICAgY29uc3QgX3YgPSBnZXRQcm9wZXJ0eShvYmosIHBhdGgpO1xuICAgICAgaWYgKF92ID09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIGRlZjtcbiAgICAgIH1cbiAgICAgIHJldHVybiBfdjtcbiAgICB9XG5cbiAgICBwYXJ0cyA9IHBhdGguc3BsaXQoJy4nKTtcbiAgfSBlbHNlIHtcbiAgICBpc1BhdGhBcnJheSA9IHRydWU7XG4gICAgcGFydHMgPSBwYXRoO1xuXG4gICAgaWYgKHBhcnRzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgY29uc3QgX3YgPSBnZXRQcm9wZXJ0eShvYmosIHBhcnRzWzBdKTtcbiAgICAgIGlmIChfdiA9PSBudWxsKSB7XG4gICAgICAgIHJldHVybiBkZWY7XG4gICAgICB9XG4gICAgICByZXR1cm4gX3Y7XG4gICAgfVxuICB9XG4gIGxldCByZXN0ID0gcGF0aDtcbiAgbGV0IGN1ciA9IG9iajtcbiAgZm9yIChjb25zdCBwYXJ0IG9mIHBhcnRzKSB7XG4gICAgaWYgKGN1ciA9PSBudWxsKSB7XG4gICAgICByZXR1cm4gZGVmO1xuICAgIH1cblxuICAgIC8vIGBsaWIvY2FzdC5qc2AgZGVwZW5kcyBvbiBiZWluZyBhYmxlIHRvIGdldCBkb3R0ZWQgcGF0aHMgaW4gdXBkYXRlcyxcbiAgICAvLyBsaWtlIGB7ICRzZXQ6IHsgJ2EuYic6IDQyIH0gfWBcbiAgICBpZiAoIWlzUGF0aEFycmF5ICYmIGN1cltyZXN0XSAhPSBudWxsKSB7XG4gICAgICByZXR1cm4gY3VyW3Jlc3RdO1xuICAgIH1cblxuICAgIGN1ciA9IGdldFByb3BlcnR5KGN1ciwgcGFydCk7XG5cbiAgICBpZiAoIWlzUGF0aEFycmF5KSB7XG4gICAgICByZXN0ID0gcmVzdC5zdWJzdHIocGFydC5sZW5ndGggKyAxKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gY3VyID09IG51bGwgPyBkZWYgOiBjdXI7XG59O1xuXG5mdW5jdGlvbiBnZXRQcm9wZXJ0eShvYmosIHByb3ApIHtcbiAgaWYgKG9iaiA9PSBudWxsKSB7XG4gICAgcmV0dXJuIG9iajtcbiAgfVxuICBpZiAob2JqIGluc3RhbmNlb2YgTWFwKSB7XG4gICAgcmV0dXJuIG9iai5nZXQocHJvcCk7XG4gIH1cbiAgcmV0dXJuIG9ialtwcm9wXTtcbn1cbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/mongoose/lib/helpers/get.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/mongoose/lib/helpers/getConstructorName.js":
/*!*****************************************************************!*\
  !*** ./node_modules/mongoose/lib/helpers/getConstructorName.js ***!
  \*****************************************************************/
/***/ ((module) => {

eval("\n\n/**\n * If `val` is an object, returns constructor name, if possible. Otherwise returns undefined.\n * @api private\n */\n\nmodule.exports = function getConstructorName(val) {\n  if (val == null) {\n    return void 0;\n  }\n  if (typeof val.constructor !== 'function') {\n    return void 0;\n  }\n  return val.constructor.name;\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbW9uZ29vc2UvbGliL2hlbHBlcnMvZ2V0Q29uc3RydWN0b3JOYW1lLmpzIiwibWFwcGluZ3MiOiJBQUFhOztBQUViO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL2FwcDEvLi9ub2RlX21vZHVsZXMvbW9uZ29vc2UvbGliL2hlbHBlcnMvZ2V0Q29uc3RydWN0b3JOYW1lLmpzP2FiYjEiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG4vKipcbiAqIElmIGB2YWxgIGlzIGFuIG9iamVjdCwgcmV0dXJucyBjb25zdHJ1Y3RvciBuYW1lLCBpZiBwb3NzaWJsZS4gT3RoZXJ3aXNlIHJldHVybnMgdW5kZWZpbmVkLlxuICogQGFwaSBwcml2YXRlXG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBnZXRDb25zdHJ1Y3Rvck5hbWUodmFsKSB7XG4gIGlmICh2YWwgPT0gbnVsbCkge1xuICAgIHJldHVybiB2b2lkIDA7XG4gIH1cbiAgaWYgKHR5cGVvZiB2YWwuY29uc3RydWN0b3IgIT09ICdmdW5jdGlvbicpIHtcbiAgICByZXR1cm4gdm9pZCAwO1xuICB9XG4gIHJldHVybiB2YWwuY29uc3RydWN0b3IubmFtZTtcbn07XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/mongoose/lib/helpers/getConstructorName.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/mongoose/lib/helpers/getDefaultBulkwriteResult.js":
/*!************************************************************************!*\
  !*** ./node_modules/mongoose/lib/helpers/getDefaultBulkwriteResult.js ***!
  \************************************************************************/
/***/ ((module) => {

eval("\nfunction getDefaultBulkwriteResult() {\n  return {\n    result: {\n      ok: 1,\n      writeErrors: [],\n      writeConcernErrors: [],\n      insertedIds: [],\n      nInserted: 0,\n      nUpserted: 0,\n      nMatched: 0,\n      nModified: 0,\n      nRemoved: 0,\n      upserted: []\n    },\n    insertedCount: 0,\n    matchedCount: 0,\n    modifiedCount: 0,\n    deletedCount: 0,\n    upsertedCount: 0,\n    upsertedIds: {},\n    insertedIds: {},\n    n: 0\n  };\n}\n\nmodule.exports = getDefaultBulkwriteResult;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbW9uZ29vc2UvbGliL2hlbHBlcnMvZ2V0RGVmYXVsdEJ1bGt3cml0ZVJlc3VsdC5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUI7QUFDbkIsbUJBQW1CO0FBQ25CO0FBQ0E7QUFDQTs7QUFFQSIsInNvdXJjZXMiOlsid2VicGFjazovL2FwcDEvLi9ub2RlX21vZHVsZXMvbW9uZ29vc2UvbGliL2hlbHBlcnMvZ2V0RGVmYXVsdEJ1bGt3cml0ZVJlc3VsdC5qcz8wOTZjIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcbmZ1bmN0aW9uIGdldERlZmF1bHRCdWxrd3JpdGVSZXN1bHQoKSB7XG4gIHJldHVybiB7XG4gICAgcmVzdWx0OiB7XG4gICAgICBvazogMSxcbiAgICAgIHdyaXRlRXJyb3JzOiBbXSxcbiAgICAgIHdyaXRlQ29uY2VybkVycm9yczogW10sXG4gICAgICBpbnNlcnRlZElkczogW10sXG4gICAgICBuSW5zZXJ0ZWQ6IDAsXG4gICAgICBuVXBzZXJ0ZWQ6IDAsXG4gICAgICBuTWF0Y2hlZDogMCxcbiAgICAgIG5Nb2RpZmllZDogMCxcbiAgICAgIG5SZW1vdmVkOiAwLFxuICAgICAgdXBzZXJ0ZWQ6IFtdXG4gICAgfSxcbiAgICBpbnNlcnRlZENvdW50OiAwLFxuICAgIG1hdGNoZWRDb3VudDogMCxcbiAgICBtb2RpZmllZENvdW50OiAwLFxuICAgIGRlbGV0ZWRDb3VudDogMCxcbiAgICB1cHNlcnRlZENvdW50OiAwLFxuICAgIHVwc2VydGVkSWRzOiB7fSxcbiAgICBpbnNlcnRlZElkczoge30sXG4gICAgbjogMFxuICB9O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGdldERlZmF1bHRCdWxrd3JpdGVSZXN1bHQ7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/mongoose/lib/helpers/getDefaultBulkwriteResult.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/mongoose/lib/helpers/getFunctionName.js":
/*!**************************************************************!*\
  !*** ./node_modules/mongoose/lib/helpers/getFunctionName.js ***!
  \**************************************************************/
/***/ ((module) => {

eval("\n\nconst functionNameRE = /^function\\s*([^\\s(]+)/;\n\nmodule.exports = function(fn) {\n  return (\n    fn.name ||\n    (fn.toString().trim().match(functionNameRE) || [])[1]\n  );\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbW9uZ29vc2UvbGliL2hlbHBlcnMvZ2V0RnVuY3Rpb25OYW1lLmpzIiwibWFwcGluZ3MiOiJBQUFhOztBQUViOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL2FwcDEvLi9ub2RlX21vZHVsZXMvbW9uZ29vc2UvbGliL2hlbHBlcnMvZ2V0RnVuY3Rpb25OYW1lLmpzPzI5ZjEiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG5jb25zdCBmdW5jdGlvbk5hbWVSRSA9IC9eZnVuY3Rpb25cXHMqKFteXFxzKF0rKS87XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oZm4pIHtcbiAgcmV0dXJuIChcbiAgICBmbi5uYW1lIHx8XG4gICAgKGZuLnRvU3RyaW5nKCkudHJpbSgpLm1hdGNoKGZ1bmN0aW9uTmFtZVJFKSB8fCBbXSlbMV1cbiAgKTtcbn07XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/mongoose/lib/helpers/getFunctionName.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/mongoose/lib/helpers/immediate.js":
/*!********************************************************!*\
  !*** ./node_modules/mongoose/lib/helpers/immediate.js ***!
  \********************************************************/
/***/ ((module) => {

eval("/*!\n * Centralize this so we can more easily work around issues with people\n * stubbing out `process.nextTick()` in tests using sinon:\n * https://github.com/sinonjs/lolex#automatically-incrementing-mocked-time\n * See gh-6074\n */\n\n\n\nconst nextTick = typeof process !== 'undefined' && typeof process.nextTick === 'function' ?\n  process.nextTick.bind(process) :\n  cb => setTimeout(cb, 0); // Fallback for browser build\n\nmodule.exports = function immediate(cb) {\n  return nextTick(cb);\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbW9uZ29vc2UvbGliL2hlbHBlcnMvaW1tZWRpYXRlLmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFYTs7QUFFYjtBQUNBO0FBQ0EsMkJBQTJCOztBQUUzQjtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9hcHAxLy4vbm9kZV9tb2R1bGVzL21vbmdvb3NlL2xpYi9oZWxwZXJzL2ltbWVkaWF0ZS5qcz9kNTMxIl0sInNvdXJjZXNDb250ZW50IjpbIi8qIVxuICogQ2VudHJhbGl6ZSB0aGlzIHNvIHdlIGNhbiBtb3JlIGVhc2lseSB3b3JrIGFyb3VuZCBpc3N1ZXMgd2l0aCBwZW9wbGVcbiAqIHN0dWJiaW5nIG91dCBgcHJvY2Vzcy5uZXh0VGljaygpYCBpbiB0ZXN0cyB1c2luZyBzaW5vbjpcbiAqIGh0dHBzOi8vZ2l0aHViLmNvbS9zaW5vbmpzL2xvbGV4I2F1dG9tYXRpY2FsbHktaW5jcmVtZW50aW5nLW1vY2tlZC10aW1lXG4gKiBTZWUgZ2gtNjA3NFxuICovXG5cbid1c2Ugc3RyaWN0JztcblxuY29uc3QgbmV4dFRpY2sgPSB0eXBlb2YgcHJvY2VzcyAhPT0gJ3VuZGVmaW5lZCcgJiYgdHlwZW9mIHByb2Nlc3MubmV4dFRpY2sgPT09ICdmdW5jdGlvbicgP1xuICBwcm9jZXNzLm5leHRUaWNrLmJpbmQocHJvY2VzcykgOlxuICBjYiA9PiBzZXRUaW1lb3V0KGNiLCAwKTsgLy8gRmFsbGJhY2sgZm9yIGJyb3dzZXIgYnVpbGRcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBpbW1lZGlhdGUoY2IpIHtcbiAgcmV0dXJuIG5leHRUaWNrKGNiKTtcbn07XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/mongoose/lib/helpers/immediate.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/mongoose/lib/helpers/indexes/applySchemaCollation.js":
/*!***************************************************************************!*\
  !*** ./node_modules/mongoose/lib/helpers/indexes/applySchemaCollation.js ***!
  \***************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\n\nconst isTextIndex = __webpack_require__(/*! ./isTextIndex */ \"(ssr)/./node_modules/mongoose/lib/helpers/indexes/isTextIndex.js\");\n\nmodule.exports = function applySchemaCollation(indexKeys, indexOptions, schemaOptions) {\n  if (isTextIndex(indexKeys)) {\n    return;\n  }\n\n  if (schemaOptions.hasOwnProperty('collation') && !indexOptions.hasOwnProperty('collation')) {\n    indexOptions.collation = schemaOptions.collation;\n  }\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbW9uZ29vc2UvbGliL2hlbHBlcnMvaW5kZXhlcy9hcHBseVNjaGVtYUNvbGxhdGlvbi5qcyIsIm1hcHBpbmdzIjoiQUFBYTs7QUFFYixvQkFBb0IsbUJBQU8sQ0FBQyx1RkFBZTs7QUFFM0M7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9hcHAxLy4vbm9kZV9tb2R1bGVzL21vbmdvb3NlL2xpYi9oZWxwZXJzL2luZGV4ZXMvYXBwbHlTY2hlbWFDb2xsYXRpb24uanM/NzZiMSJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbmNvbnN0IGlzVGV4dEluZGV4ID0gcmVxdWlyZSgnLi9pc1RleHRJbmRleCcpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGFwcGx5U2NoZW1hQ29sbGF0aW9uKGluZGV4S2V5cywgaW5kZXhPcHRpb25zLCBzY2hlbWFPcHRpb25zKSB7XG4gIGlmIChpc1RleHRJbmRleChpbmRleEtleXMpKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgaWYgKHNjaGVtYU9wdGlvbnMuaGFzT3duUHJvcGVydHkoJ2NvbGxhdGlvbicpICYmICFpbmRleE9wdGlvbnMuaGFzT3duUHJvcGVydHkoJ2NvbGxhdGlvbicpKSB7XG4gICAgaW5kZXhPcHRpb25zLmNvbGxhdGlvbiA9IHNjaGVtYU9wdGlvbnMuY29sbGF0aW9uO1xuICB9XG59O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/mongoose/lib/helpers/indexes/applySchemaCollation.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/mongoose/lib/helpers/indexes/decorateDiscriminatorIndexOptions.js":
/*!****************************************************************************************!*\
  !*** ./node_modules/mongoose/lib/helpers/indexes/decorateDiscriminatorIndexOptions.js ***!
  \****************************************************************************************/
/***/ ((module) => {

eval("\n\nmodule.exports = function decorateDiscriminatorIndexOptions(schema, indexOptions) {\n  // If the model is a discriminator and has an index, add a\n  // partialFilterExpression by default so the index will only apply\n  // to that discriminator.\n  const discriminatorName = schema.discriminatorMapping && schema.discriminatorMapping.value;\n  if (discriminatorName && !('sparse' in indexOptions)) {\n    const discriminatorKey = schema.options.discriminatorKey;\n    indexOptions.partialFilterExpression = indexOptions.partialFilterExpression || {};\n    indexOptions.partialFilterExpression[discriminatorKey] = discriminatorName;\n  }\n  return indexOptions;\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbW9uZ29vc2UvbGliL2hlbHBlcnMvaW5kZXhlcy9kZWNvcmF0ZURpc2NyaW1pbmF0b3JJbmRleE9wdGlvbnMuanMiLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vYXBwMS8uL25vZGVfbW9kdWxlcy9tb25nb29zZS9saWIvaGVscGVycy9pbmRleGVzL2RlY29yYXRlRGlzY3JpbWluYXRvckluZGV4T3B0aW9ucy5qcz84NmM2Il0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBkZWNvcmF0ZURpc2NyaW1pbmF0b3JJbmRleE9wdGlvbnMoc2NoZW1hLCBpbmRleE9wdGlvbnMpIHtcbiAgLy8gSWYgdGhlIG1vZGVsIGlzIGEgZGlzY3JpbWluYXRvciBhbmQgaGFzIGFuIGluZGV4LCBhZGQgYVxuICAvLyBwYXJ0aWFsRmlsdGVyRXhwcmVzc2lvbiBieSBkZWZhdWx0IHNvIHRoZSBpbmRleCB3aWxsIG9ubHkgYXBwbHlcbiAgLy8gdG8gdGhhdCBkaXNjcmltaW5hdG9yLlxuICBjb25zdCBkaXNjcmltaW5hdG9yTmFtZSA9IHNjaGVtYS5kaXNjcmltaW5hdG9yTWFwcGluZyAmJiBzY2hlbWEuZGlzY3JpbWluYXRvck1hcHBpbmcudmFsdWU7XG4gIGlmIChkaXNjcmltaW5hdG9yTmFtZSAmJiAhKCdzcGFyc2UnIGluIGluZGV4T3B0aW9ucykpIHtcbiAgICBjb25zdCBkaXNjcmltaW5hdG9yS2V5ID0gc2NoZW1hLm9wdGlvbnMuZGlzY3JpbWluYXRvcktleTtcbiAgICBpbmRleE9wdGlvbnMucGFydGlhbEZpbHRlckV4cHJlc3Npb24gPSBpbmRleE9wdGlvbnMucGFydGlhbEZpbHRlckV4cHJlc3Npb24gfHwge307XG4gICAgaW5kZXhPcHRpb25zLnBhcnRpYWxGaWx0ZXJFeHByZXNzaW9uW2Rpc2NyaW1pbmF0b3JLZXldID0gZGlzY3JpbWluYXRvck5hbWU7XG4gIH1cbiAgcmV0dXJuIGluZGV4T3B0aW9ucztcbn07XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/mongoose/lib/helpers/indexes/decorateDiscriminatorIndexOptions.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/mongoose/lib/helpers/indexes/getRelatedIndexes.js":
/*!************************************************************************!*\
  !*** ./node_modules/mongoose/lib/helpers/indexes/getRelatedIndexes.js ***!
  \************************************************************************/
/***/ ((module) => {

eval("\n\nfunction getRelatedSchemaIndexes(model, schemaIndexes) {\n  return getRelatedIndexes({\n    baseModelName: model.baseModelName,\n    discriminatorMapping: model.schema.discriminatorMapping,\n    indexes: schemaIndexes,\n    indexesType: 'schema'\n  });\n}\n\nfunction getRelatedDBIndexes(model, dbIndexes) {\n  return getRelatedIndexes({\n    baseModelName: model.baseModelName,\n    discriminatorMapping: model.schema.discriminatorMapping,\n    indexes: dbIndexes,\n    indexesType: 'db'\n  });\n}\n\nmodule.exports = {\n  getRelatedSchemaIndexes,\n  getRelatedDBIndexes\n};\n\nfunction getRelatedIndexes({\n  baseModelName,\n  discriminatorMapping,\n  indexes,\n  indexesType\n}) {\n  const discriminatorKey = discriminatorMapping && discriminatorMapping.key;\n  const discriminatorValue = discriminatorMapping && discriminatorMapping.value;\n\n  if (!discriminatorKey) {\n    return indexes;\n  }\n\n  const isChildDiscriminatorModel = Boolean(baseModelName);\n  if (isChildDiscriminatorModel) {\n    return indexes.filter(index => {\n      const partialFilterExpression = getPartialFilterExpression(index, indexesType);\n      return partialFilterExpression && partialFilterExpression[discriminatorKey] === discriminatorValue;\n    });\n  }\n\n  return indexes.filter(index => {\n    const partialFilterExpression = getPartialFilterExpression(index, indexesType);\n    return !partialFilterExpression || !partialFilterExpression[discriminatorKey];\n  });\n}\n\nfunction getPartialFilterExpression(index, indexesType) {\n  if (indexesType === 'schema') {\n    const options = index[1];\n    return options && options.partialFilterExpression;\n  }\n  return index.partialFilterExpression;\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbW9uZ29vc2UvbGliL2hlbHBlcnMvaW5kZXhlcy9nZXRSZWxhdGVkSW5kZXhlcy5qcyIsIm1hcHBpbmdzIjoiQUFBYTs7QUFFYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9hcHAxLy4vbm9kZV9tb2R1bGVzL21vbmdvb3NlL2xpYi9oZWxwZXJzL2luZGV4ZXMvZ2V0UmVsYXRlZEluZGV4ZXMuanM/ZDJlMSJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbmZ1bmN0aW9uIGdldFJlbGF0ZWRTY2hlbWFJbmRleGVzKG1vZGVsLCBzY2hlbWFJbmRleGVzKSB7XG4gIHJldHVybiBnZXRSZWxhdGVkSW5kZXhlcyh7XG4gICAgYmFzZU1vZGVsTmFtZTogbW9kZWwuYmFzZU1vZGVsTmFtZSxcbiAgICBkaXNjcmltaW5hdG9yTWFwcGluZzogbW9kZWwuc2NoZW1hLmRpc2NyaW1pbmF0b3JNYXBwaW5nLFxuICAgIGluZGV4ZXM6IHNjaGVtYUluZGV4ZXMsXG4gICAgaW5kZXhlc1R5cGU6ICdzY2hlbWEnXG4gIH0pO1xufVxuXG5mdW5jdGlvbiBnZXRSZWxhdGVkREJJbmRleGVzKG1vZGVsLCBkYkluZGV4ZXMpIHtcbiAgcmV0dXJuIGdldFJlbGF0ZWRJbmRleGVzKHtcbiAgICBiYXNlTW9kZWxOYW1lOiBtb2RlbC5iYXNlTW9kZWxOYW1lLFxuICAgIGRpc2NyaW1pbmF0b3JNYXBwaW5nOiBtb2RlbC5zY2hlbWEuZGlzY3JpbWluYXRvck1hcHBpbmcsXG4gICAgaW5kZXhlczogZGJJbmRleGVzLFxuICAgIGluZGV4ZXNUeXBlOiAnZGInXG4gIH0pO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgZ2V0UmVsYXRlZFNjaGVtYUluZGV4ZXMsXG4gIGdldFJlbGF0ZWREQkluZGV4ZXNcbn07XG5cbmZ1bmN0aW9uIGdldFJlbGF0ZWRJbmRleGVzKHtcbiAgYmFzZU1vZGVsTmFtZSxcbiAgZGlzY3JpbWluYXRvck1hcHBpbmcsXG4gIGluZGV4ZXMsXG4gIGluZGV4ZXNUeXBlXG59KSB7XG4gIGNvbnN0IGRpc2NyaW1pbmF0b3JLZXkgPSBkaXNjcmltaW5hdG9yTWFwcGluZyAmJiBkaXNjcmltaW5hdG9yTWFwcGluZy5rZXk7XG4gIGNvbnN0IGRpc2NyaW1pbmF0b3JWYWx1ZSA9IGRpc2NyaW1pbmF0b3JNYXBwaW5nICYmIGRpc2NyaW1pbmF0b3JNYXBwaW5nLnZhbHVlO1xuXG4gIGlmICghZGlzY3JpbWluYXRvcktleSkge1xuICAgIHJldHVybiBpbmRleGVzO1xuICB9XG5cbiAgY29uc3QgaXNDaGlsZERpc2NyaW1pbmF0b3JNb2RlbCA9IEJvb2xlYW4oYmFzZU1vZGVsTmFtZSk7XG4gIGlmIChpc0NoaWxkRGlzY3JpbWluYXRvck1vZGVsKSB7XG4gICAgcmV0dXJuIGluZGV4ZXMuZmlsdGVyKGluZGV4ID0+IHtcbiAgICAgIGNvbnN0IHBhcnRpYWxGaWx0ZXJFeHByZXNzaW9uID0gZ2V0UGFydGlhbEZpbHRlckV4cHJlc3Npb24oaW5kZXgsIGluZGV4ZXNUeXBlKTtcbiAgICAgIHJldHVybiBwYXJ0aWFsRmlsdGVyRXhwcmVzc2lvbiAmJiBwYXJ0aWFsRmlsdGVyRXhwcmVzc2lvbltkaXNjcmltaW5hdG9yS2V5XSA9PT0gZGlzY3JpbWluYXRvclZhbHVlO1xuICAgIH0pO1xuICB9XG5cbiAgcmV0dXJuIGluZGV4ZXMuZmlsdGVyKGluZGV4ID0+IHtcbiAgICBjb25zdCBwYXJ0aWFsRmlsdGVyRXhwcmVzc2lvbiA9IGdldFBhcnRpYWxGaWx0ZXJFeHByZXNzaW9uKGluZGV4LCBpbmRleGVzVHlwZSk7XG4gICAgcmV0dXJuICFwYXJ0aWFsRmlsdGVyRXhwcmVzc2lvbiB8fCAhcGFydGlhbEZpbHRlckV4cHJlc3Npb25bZGlzY3JpbWluYXRvcktleV07XG4gIH0pO1xufVxuXG5mdW5jdGlvbiBnZXRQYXJ0aWFsRmlsdGVyRXhwcmVzc2lvbihpbmRleCwgaW5kZXhlc1R5cGUpIHtcbiAgaWYgKGluZGV4ZXNUeXBlID09PSAnc2NoZW1hJykge1xuICAgIGNvbnN0IG9wdGlvbnMgPSBpbmRleFsxXTtcbiAgICByZXR1cm4gb3B0aW9ucyAmJiBvcHRpb25zLnBhcnRpYWxGaWx0ZXJFeHByZXNzaW9uO1xuICB9XG4gIHJldHVybiBpbmRleC5wYXJ0aWFsRmlsdGVyRXhwcmVzc2lvbjtcbn1cbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/mongoose/lib/helpers/indexes/getRelatedIndexes.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/mongoose/lib/helpers/indexes/isDefaultIdIndex.js":
/*!***********************************************************************!*\
  !*** ./node_modules/mongoose/lib/helpers/indexes/isDefaultIdIndex.js ***!
  \***********************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\n\nconst get = __webpack_require__(/*! ../get */ \"(ssr)/./node_modules/mongoose/lib/helpers/get.js\");\n\nmodule.exports = function isDefaultIdIndex(index) {\n  if (Array.isArray(index)) {\n    // Mongoose syntax\n    const keys = Object.keys(index[0]);\n    return keys.length === 1 && keys[0] === '_id' && index[0]._id !== 'hashed';\n  }\n\n  if (typeof index !== 'object') {\n    return false;\n  }\n\n  const key = get(index, 'key', {});\n  return Object.keys(key).length === 1 && key.hasOwnProperty('_id');\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbW9uZ29vc2UvbGliL2hlbHBlcnMvaW5kZXhlcy9pc0RlZmF1bHRJZEluZGV4LmpzIiwibWFwcGluZ3MiOiJBQUFhOztBQUViLFlBQVksbUJBQU8sQ0FBQyxnRUFBUTs7QUFFNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxrQ0FBa0M7QUFDbEM7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL2FwcDEvLi9ub2RlX21vZHVsZXMvbW9uZ29vc2UvbGliL2hlbHBlcnMvaW5kZXhlcy9pc0RlZmF1bHRJZEluZGV4LmpzPzM5MjAiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG5jb25zdCBnZXQgPSByZXF1aXJlKCcuLi9nZXQnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBpc0RlZmF1bHRJZEluZGV4KGluZGV4KSB7XG4gIGlmIChBcnJheS5pc0FycmF5KGluZGV4KSkge1xuICAgIC8vIE1vbmdvb3NlIHN5bnRheFxuICAgIGNvbnN0IGtleXMgPSBPYmplY3Qua2V5cyhpbmRleFswXSk7XG4gICAgcmV0dXJuIGtleXMubGVuZ3RoID09PSAxICYmIGtleXNbMF0gPT09ICdfaWQnICYmIGluZGV4WzBdLl9pZCAhPT0gJ2hhc2hlZCc7XG4gIH1cblxuICBpZiAodHlwZW9mIGluZGV4ICE9PSAnb2JqZWN0Jykge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIGNvbnN0IGtleSA9IGdldChpbmRleCwgJ2tleScsIHt9KTtcbiAgcmV0dXJuIE9iamVjdC5rZXlzKGtleSkubGVuZ3RoID09PSAxICYmIGtleS5oYXNPd25Qcm9wZXJ0eSgnX2lkJyk7XG59O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/mongoose/lib/helpers/indexes/isDefaultIdIndex.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/mongoose/lib/helpers/indexes/isIndexEqual.js":
/*!*******************************************************************!*\
  !*** ./node_modules/mongoose/lib/helpers/indexes/isIndexEqual.js ***!
  \*******************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\n\nconst get = __webpack_require__(/*! ../get */ \"(ssr)/./node_modules/mongoose/lib/helpers/get.js\");\nconst utils = __webpack_require__(/*! ../../utils */ \"(ssr)/./node_modules/mongoose/lib/utils.js\");\n/**\n * Given a Mongoose index definition (key + options objects) and a MongoDB server\n * index definition, determine if the two indexes are equal.\n *\n * @param {Object} schemaIndexKeysObject the Mongoose index spec\n * @param {Object} options the Mongoose index definition's options\n * @param {Object} dbIndex the index in MongoDB as returned by `listIndexes()`\n * @api private\n */\n\nmodule.exports = function isIndexEqual(schemaIndexKeysObject, options, dbIndex) {\n  // Special case: text indexes have a special format in the db. For example,\n  // `{ name: 'text' }` becomes:\n  // {\n  //   v: 2,\n  //   key: { _fts: 'text', _ftsx: 1 },\n  //   name: 'name_text',\n  //   ns: 'test.tests',\n  //   background: true,\n  //   weights: { name: 1 },\n  //   default_language: 'english',\n  //   language_override: 'language',\n  //   textIndexVersion: 3\n  // }\n  if (dbIndex.textIndexVersion != null) {\n    delete dbIndex.key._fts;\n    delete dbIndex.key._ftsx;\n    const weights = { ...dbIndex.weights, ...dbIndex.key };\n    if (Object.keys(weights).length !== Object.keys(schemaIndexKeysObject).length) {\n      return false;\n    }\n    for (const prop of Object.keys(weights)) {\n      if (!(prop in schemaIndexKeysObject)) {\n        return false;\n      }\n      const weight = weights[prop];\n      if (weight !== get(options, 'weights.' + prop) && !(weight === 1 && get(options, 'weights.' + prop) == null)) {\n        return false;\n      }\n    }\n\n    if (options['default_language'] !== dbIndex['default_language']) {\n      return dbIndex['default_language'] === 'english' && options['default_language'] == null;\n    }\n\n    return true;\n  }\n\n  const optionKeys = [\n    'unique',\n    'partialFilterExpression',\n    'sparse',\n    'expireAfterSeconds',\n    'collation'\n  ];\n  for (const key of optionKeys) {\n    if (!(key in options) && !(key in dbIndex)) {\n      continue;\n    }\n    if (key === 'collation') {\n      if (options[key] == null || dbIndex[key] == null) {\n        return options[key] == null && dbIndex[key] == null;\n      }\n      const definedKeys = Object.keys(options.collation);\n      const schemaCollation = options.collation;\n      const dbCollation = dbIndex.collation;\n      for (const opt of definedKeys) {\n        if (get(schemaCollation, opt) !== get(dbCollation, opt)) {\n          return false;\n        }\n      }\n    } else if (!utils.deepEqual(options[key], dbIndex[key])) {\n      return false;\n    }\n  }\n\n  const schemaIndexKeys = Object.keys(schemaIndexKeysObject);\n  const dbIndexKeys = Object.keys(dbIndex.key);\n  if (schemaIndexKeys.length !== dbIndexKeys.length) {\n    return false;\n  }\n  for (let i = 0; i < schemaIndexKeys.length; ++i) {\n    if (schemaIndexKeys[i] !== dbIndexKeys[i]) {\n      return false;\n    }\n    if (!utils.deepEqual(schemaIndexKeysObject[schemaIndexKeys[i]], dbIndex.key[dbIndexKeys[i]])) {\n      return false;\n    }\n  }\n\n  return true;\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbW9uZ29vc2UvbGliL2hlbHBlcnMvaW5kZXhlcy9pc0luZGV4RXF1YWwuanMiLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWIsWUFBWSxtQkFBTyxDQUFDLGdFQUFRO0FBQzVCLGNBQWMsbUJBQU8sQ0FBQywrREFBYTtBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFFBQVEsY0FBYztBQUN0QjtBQUNBO0FBQ0EsY0FBYyx3QkFBd0I7QUFDdEM7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLFNBQVM7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsNEJBQTRCO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9hcHAxLy4vbm9kZV9tb2R1bGVzL21vbmdvb3NlL2xpYi9oZWxwZXJzL2luZGV4ZXMvaXNJbmRleEVxdWFsLmpzP2VmOGUiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG5jb25zdCBnZXQgPSByZXF1aXJlKCcuLi9nZXQnKTtcbmNvbnN0IHV0aWxzID0gcmVxdWlyZSgnLi4vLi4vdXRpbHMnKTtcbi8qKlxuICogR2l2ZW4gYSBNb25nb29zZSBpbmRleCBkZWZpbml0aW9uIChrZXkgKyBvcHRpb25zIG9iamVjdHMpIGFuZCBhIE1vbmdvREIgc2VydmVyXG4gKiBpbmRleCBkZWZpbml0aW9uLCBkZXRlcm1pbmUgaWYgdGhlIHR3byBpbmRleGVzIGFyZSBlcXVhbC5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gc2NoZW1hSW5kZXhLZXlzT2JqZWN0IHRoZSBNb25nb29zZSBpbmRleCBzcGVjXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyB0aGUgTW9uZ29vc2UgaW5kZXggZGVmaW5pdGlvbidzIG9wdGlvbnNcbiAqIEBwYXJhbSB7T2JqZWN0fSBkYkluZGV4IHRoZSBpbmRleCBpbiBNb25nb0RCIGFzIHJldHVybmVkIGJ5IGBsaXN0SW5kZXhlcygpYFxuICogQGFwaSBwcml2YXRlXG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBpc0luZGV4RXF1YWwoc2NoZW1hSW5kZXhLZXlzT2JqZWN0LCBvcHRpb25zLCBkYkluZGV4KSB7XG4gIC8vIFNwZWNpYWwgY2FzZTogdGV4dCBpbmRleGVzIGhhdmUgYSBzcGVjaWFsIGZvcm1hdCBpbiB0aGUgZGIuIEZvciBleGFtcGxlLFxuICAvLyBgeyBuYW1lOiAndGV4dCcgfWAgYmVjb21lczpcbiAgLy8ge1xuICAvLyAgIHY6IDIsXG4gIC8vICAga2V5OiB7IF9mdHM6ICd0ZXh0JywgX2Z0c3g6IDEgfSxcbiAgLy8gICBuYW1lOiAnbmFtZV90ZXh0JyxcbiAgLy8gICBuczogJ3Rlc3QudGVzdHMnLFxuICAvLyAgIGJhY2tncm91bmQ6IHRydWUsXG4gIC8vICAgd2VpZ2h0czogeyBuYW1lOiAxIH0sXG4gIC8vICAgZGVmYXVsdF9sYW5ndWFnZTogJ2VuZ2xpc2gnLFxuICAvLyAgIGxhbmd1YWdlX292ZXJyaWRlOiAnbGFuZ3VhZ2UnLFxuICAvLyAgIHRleHRJbmRleFZlcnNpb246IDNcbiAgLy8gfVxuICBpZiAoZGJJbmRleC50ZXh0SW5kZXhWZXJzaW9uICE9IG51bGwpIHtcbiAgICBkZWxldGUgZGJJbmRleC5rZXkuX2Z0cztcbiAgICBkZWxldGUgZGJJbmRleC5rZXkuX2Z0c3g7XG4gICAgY29uc3Qgd2VpZ2h0cyA9IHsgLi4uZGJJbmRleC53ZWlnaHRzLCAuLi5kYkluZGV4LmtleSB9O1xuICAgIGlmIChPYmplY3Qua2V5cyh3ZWlnaHRzKS5sZW5ndGggIT09IE9iamVjdC5rZXlzKHNjaGVtYUluZGV4S2V5c09iamVjdCkubGVuZ3RoKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGZvciAoY29uc3QgcHJvcCBvZiBPYmplY3Qua2V5cyh3ZWlnaHRzKSkge1xuICAgICAgaWYgKCEocHJvcCBpbiBzY2hlbWFJbmRleEtleXNPYmplY3QpKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHdlaWdodCA9IHdlaWdodHNbcHJvcF07XG4gICAgICBpZiAod2VpZ2h0ICE9PSBnZXQob3B0aW9ucywgJ3dlaWdodHMuJyArIHByb3ApICYmICEod2VpZ2h0ID09PSAxICYmIGdldChvcHRpb25zLCAnd2VpZ2h0cy4nICsgcHJvcCkgPT0gbnVsbCkpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChvcHRpb25zWydkZWZhdWx0X2xhbmd1YWdlJ10gIT09IGRiSW5kZXhbJ2RlZmF1bHRfbGFuZ3VhZ2UnXSkge1xuICAgICAgcmV0dXJuIGRiSW5kZXhbJ2RlZmF1bHRfbGFuZ3VhZ2UnXSA9PT0gJ2VuZ2xpc2gnICYmIG9wdGlvbnNbJ2RlZmF1bHRfbGFuZ3VhZ2UnXSA9PSBudWxsO1xuICAgIH1cblxuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgY29uc3Qgb3B0aW9uS2V5cyA9IFtcbiAgICAndW5pcXVlJyxcbiAgICAncGFydGlhbEZpbHRlckV4cHJlc3Npb24nLFxuICAgICdzcGFyc2UnLFxuICAgICdleHBpcmVBZnRlclNlY29uZHMnLFxuICAgICdjb2xsYXRpb24nXG4gIF07XG4gIGZvciAoY29uc3Qga2V5IG9mIG9wdGlvbktleXMpIHtcbiAgICBpZiAoIShrZXkgaW4gb3B0aW9ucykgJiYgIShrZXkgaW4gZGJJbmRleCkpIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICBpZiAoa2V5ID09PSAnY29sbGF0aW9uJykge1xuICAgICAgaWYgKG9wdGlvbnNba2V5XSA9PSBudWxsIHx8IGRiSW5kZXhba2V5XSA9PSBudWxsKSB7XG4gICAgICAgIHJldHVybiBvcHRpb25zW2tleV0gPT0gbnVsbCAmJiBkYkluZGV4W2tleV0gPT0gbnVsbDtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGRlZmluZWRLZXlzID0gT2JqZWN0LmtleXMob3B0aW9ucy5jb2xsYXRpb24pO1xuICAgICAgY29uc3Qgc2NoZW1hQ29sbGF0aW9uID0gb3B0aW9ucy5jb2xsYXRpb247XG4gICAgICBjb25zdCBkYkNvbGxhdGlvbiA9IGRiSW5kZXguY29sbGF0aW9uO1xuICAgICAgZm9yIChjb25zdCBvcHQgb2YgZGVmaW5lZEtleXMpIHtcbiAgICAgICAgaWYgKGdldChzY2hlbWFDb2xsYXRpb24sIG9wdCkgIT09IGdldChkYkNvbGxhdGlvbiwgb3B0KSkge1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoIXV0aWxzLmRlZXBFcXVhbChvcHRpb25zW2tleV0sIGRiSW5kZXhba2V5XSkpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cblxuICBjb25zdCBzY2hlbWFJbmRleEtleXMgPSBPYmplY3Qua2V5cyhzY2hlbWFJbmRleEtleXNPYmplY3QpO1xuICBjb25zdCBkYkluZGV4S2V5cyA9IE9iamVjdC5rZXlzKGRiSW5kZXgua2V5KTtcbiAgaWYgKHNjaGVtYUluZGV4S2V5cy5sZW5ndGggIT09IGRiSW5kZXhLZXlzLmxlbmd0aCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBmb3IgKGxldCBpID0gMDsgaSA8IHNjaGVtYUluZGV4S2V5cy5sZW5ndGg7ICsraSkge1xuICAgIGlmIChzY2hlbWFJbmRleEtleXNbaV0gIT09IGRiSW5kZXhLZXlzW2ldKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGlmICghdXRpbHMuZGVlcEVxdWFsKHNjaGVtYUluZGV4S2V5c09iamVjdFtzY2hlbWFJbmRleEtleXNbaV1dLCBkYkluZGV4LmtleVtkYkluZGV4S2V5c1tpXV0pKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHRydWU7XG59O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/mongoose/lib/helpers/indexes/isIndexEqual.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/mongoose/lib/helpers/indexes/isTextIndex.js":
/*!******************************************************************!*\
  !*** ./node_modules/mongoose/lib/helpers/indexes/isTextIndex.js ***!
  \******************************************************************/
/***/ ((module) => {

eval("\n\n/**\n * Returns `true` if the given index options have a `text` option.\n */\n\nmodule.exports = function isTextIndex(indexKeys) {\n  let isTextIndex = false;\n  for (const key of Object.keys(indexKeys)) {\n    if (indexKeys[key] === 'text') {\n      isTextIndex = true;\n    }\n  }\n\n  return isTextIndex;\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbW9uZ29vc2UvbGliL2hlbHBlcnMvaW5kZXhlcy9pc1RleHRJbmRleC5qcyIsIm1hcHBpbmdzIjoiQUFBYTs7QUFFYjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL2FwcDEvLi9ub2RlX21vZHVsZXMvbW9uZ29vc2UvbGliL2hlbHBlcnMvaW5kZXhlcy9pc1RleHRJbmRleC5qcz8zODk5Il0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxuLyoqXG4gKiBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgZ2l2ZW4gaW5kZXggb3B0aW9ucyBoYXZlIGEgYHRleHRgIG9wdGlvbi5cbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGlzVGV4dEluZGV4KGluZGV4S2V5cykge1xuICBsZXQgaXNUZXh0SW5kZXggPSBmYWxzZTtcbiAgZm9yIChjb25zdCBrZXkgb2YgT2JqZWN0LmtleXMoaW5kZXhLZXlzKSkge1xuICAgIGlmIChpbmRleEtleXNba2V5XSA9PT0gJ3RleHQnKSB7XG4gICAgICBpc1RleHRJbmRleCA9IHRydWU7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGlzVGV4dEluZGV4O1xufTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/mongoose/lib/helpers/indexes/isTextIndex.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/mongoose/lib/helpers/isAsyncFunction.js":
/*!**************************************************************!*\
  !*** ./node_modules/mongoose/lib/helpers/isAsyncFunction.js ***!
  \**************************************************************/
/***/ ((module) => {

eval("\n\nmodule.exports = function isAsyncFunction(v) {\n  return (\n    typeof v === 'function' &&\n    v.constructor &&\n    v.constructor.name === 'AsyncFunction'\n  );\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbW9uZ29vc2UvbGliL2hlbHBlcnMvaXNBc3luY0Z1bmN0aW9uLmpzIiwibWFwcGluZ3MiOiJBQUFhOztBQUViO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vYXBwMS8uL25vZGVfbW9kdWxlcy9tb25nb29zZS9saWIvaGVscGVycy9pc0FzeW5jRnVuY3Rpb24uanM/NzkwOSJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gaXNBc3luY0Z1bmN0aW9uKHYpIHtcbiAgcmV0dXJuIChcbiAgICB0eXBlb2YgdiA9PT0gJ2Z1bmN0aW9uJyAmJlxuICAgIHYuY29uc3RydWN0b3IgJiZcbiAgICB2LmNvbnN0cnVjdG9yLm5hbWUgPT09ICdBc3luY0Z1bmN0aW9uJ1xuICApO1xufTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/mongoose/lib/helpers/isAsyncFunction.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/mongoose/lib/helpers/isBsonType.js":
/*!*********************************************************!*\
  !*** ./node_modules/mongoose/lib/helpers/isBsonType.js ***!
  \*********************************************************/
/***/ ((module) => {

eval("\n\n/**\n * Get the bson type, if it exists\n * @api private\n */\n\nfunction isBsonType(obj, typename) {\n  return (\n    typeof obj === 'object' &&\n    obj !== null &&\n    obj._bsontype === typename\n  );\n}\n\nmodule.exports = isBsonType;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbW9uZ29vc2UvbGliL2hlbHBlcnMvaXNCc29uVHlwZS5qcyIsIm1hcHBpbmdzIjoiQUFBYTs7QUFFYjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSIsInNvdXJjZXMiOlsid2VicGFjazovL2FwcDEvLi9ub2RlX21vZHVsZXMvbW9uZ29vc2UvbGliL2hlbHBlcnMvaXNCc29uVHlwZS5qcz9kNDE3Il0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxuLyoqXG4gKiBHZXQgdGhlIGJzb24gdHlwZSwgaWYgaXQgZXhpc3RzXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5mdW5jdGlvbiBpc0Jzb25UeXBlKG9iaiwgdHlwZW5hbWUpIHtcbiAgcmV0dXJuIChcbiAgICB0eXBlb2Ygb2JqID09PSAnb2JqZWN0JyAmJlxuICAgIG9iaiAhPT0gbnVsbCAmJlxuICAgIG9iai5fYnNvbnR5cGUgPT09IHR5cGVuYW1lXG4gICk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gaXNCc29uVHlwZTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/mongoose/lib/helpers/isBsonType.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/mongoose/lib/helpers/isMongooseObject.js":
/*!***************************************************************!*\
  !*** ./node_modules/mongoose/lib/helpers/isMongooseObject.js ***!
  \***************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\n\nconst isMongooseArray = (__webpack_require__(/*! ../types/array/isMongooseArray */ \"(ssr)/./node_modules/mongoose/lib/types/array/isMongooseArray.js\").isMongooseArray);\n/**\n * Returns if `v` is a mongoose object that has a `toObject()` method we can use.\n *\n * This is for compatibility with libs like Date.js which do foolish things to Natives.\n *\n * @param {Any} v\n * @api private\n */\n\nmodule.exports = function(v) {\n  return (\n    v != null && (\n      isMongooseArray(v) || // Array or Document Array\n      v.$__ != null || // Document\n      v.isMongooseBuffer || // Buffer\n      v.$isMongooseMap // Map\n    )\n  );\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbW9uZ29vc2UvbGliL2hlbHBlcnMvaXNNb25nb29zZU9iamVjdC5qcyIsIm1hcHBpbmdzIjoiQUFBYTs7QUFFYix3QkFBd0IsK0lBQXlEO0FBQ2pGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLEtBQUs7QUFDaEI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL2FwcDEvLi9ub2RlX21vZHVsZXMvbW9uZ29vc2UvbGliL2hlbHBlcnMvaXNNb25nb29zZU9iamVjdC5qcz83MGE3Il0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxuY29uc3QgaXNNb25nb29zZUFycmF5ID0gcmVxdWlyZSgnLi4vdHlwZXMvYXJyYXkvaXNNb25nb29zZUFycmF5JykuaXNNb25nb29zZUFycmF5O1xuLyoqXG4gKiBSZXR1cm5zIGlmIGB2YCBpcyBhIG1vbmdvb3NlIG9iamVjdCB0aGF0IGhhcyBhIGB0b09iamVjdCgpYCBtZXRob2Qgd2UgY2FuIHVzZS5cbiAqXG4gKiBUaGlzIGlzIGZvciBjb21wYXRpYmlsaXR5IHdpdGggbGlicyBsaWtlIERhdGUuanMgd2hpY2ggZG8gZm9vbGlzaCB0aGluZ3MgdG8gTmF0aXZlcy5cbiAqXG4gKiBAcGFyYW0ge0FueX0gdlxuICogQGFwaSBwcml2YXRlXG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbih2KSB7XG4gIHJldHVybiAoXG4gICAgdiAhPSBudWxsICYmIChcbiAgICAgIGlzTW9uZ29vc2VBcnJheSh2KSB8fCAvLyBBcnJheSBvciBEb2N1bWVudCBBcnJheVxuICAgICAgdi4kX18gIT0gbnVsbCB8fCAvLyBEb2N1bWVudFxuICAgICAgdi5pc01vbmdvb3NlQnVmZmVyIHx8IC8vIEJ1ZmZlclxuICAgICAgdi4kaXNNb25nb29zZU1hcCAvLyBNYXBcbiAgICApXG4gICk7XG59O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/mongoose/lib/helpers/isMongooseObject.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/mongoose/lib/helpers/isObject.js":
/*!*******************************************************!*\
  !*** ./node_modules/mongoose/lib/helpers/isObject.js ***!
  \*******************************************************/
/***/ ((module) => {

eval("\n\n/**\n * Determines if `arg` is an object.\n *\n * @param {Object|Array|String|Function|RegExp|any} arg\n * @api private\n * @return {Boolean}\n */\n\nmodule.exports = function(arg) {\n  return (\n    Buffer.isBuffer(arg) ||\n    Object.prototype.toString.call(arg) === '[object Object]'\n  );\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbW9uZ29vc2UvbGliL2hlbHBlcnMvaXNPYmplY3QuanMiLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWI7QUFDQTtBQUNBO0FBQ0EsV0FBVyx5Q0FBeUM7QUFDcEQ7QUFDQSxZQUFZO0FBQ1o7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vYXBwMS8uL25vZGVfbW9kdWxlcy9tb25nb29zZS9saWIvaGVscGVycy9pc09iamVjdC5qcz8zNzViIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxuLyoqXG4gKiBEZXRlcm1pbmVzIGlmIGBhcmdgIGlzIGFuIG9iamVjdC5cbiAqXG4gKiBAcGFyYW0ge09iamVjdHxBcnJheXxTdHJpbmd8RnVuY3Rpb258UmVnRXhwfGFueX0gYXJnXG4gKiBAYXBpIHByaXZhdGVcbiAqIEByZXR1cm4ge0Jvb2xlYW59XG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihhcmcpIHtcbiAgcmV0dXJuIChcbiAgICBCdWZmZXIuaXNCdWZmZXIoYXJnKSB8fFxuICAgIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChhcmcpID09PSAnW29iamVjdCBPYmplY3RdJ1xuICApO1xufTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/mongoose/lib/helpers/isObject.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/mongoose/lib/helpers/isPOJO.js":
/*!*****************************************************!*\
  !*** ./node_modules/mongoose/lib/helpers/isPOJO.js ***!
  \*****************************************************/
/***/ ((module) => {

eval("\n\nmodule.exports = function isPOJO(arg) {\n  if (arg == null || typeof arg !== 'object') {\n    return false;\n  }\n  const proto = Object.getPrototypeOf(arg);\n  // Prototype may be null if you used `Object.create(null)`\n  // Checking `proto`'s constructor is safe because `getPrototypeOf()`\n  // explicitly crosses the boundary from object data to object metadata\n  return !proto || proto.constructor.name === 'Object';\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbW9uZ29vc2UvbGliL2hlbHBlcnMvaXNQT0pPLmpzIiwibWFwcGluZ3MiOiJBQUFhOztBQUViO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vYXBwMS8uL25vZGVfbW9kdWxlcy9tb25nb29zZS9saWIvaGVscGVycy9pc1BPSk8uanM/Y2VhOSJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gaXNQT0pPKGFyZykge1xuICBpZiAoYXJnID09IG51bGwgfHwgdHlwZW9mIGFyZyAhPT0gJ29iamVjdCcpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgY29uc3QgcHJvdG8gPSBPYmplY3QuZ2V0UHJvdG90eXBlT2YoYXJnKTtcbiAgLy8gUHJvdG90eXBlIG1heSBiZSBudWxsIGlmIHlvdSB1c2VkIGBPYmplY3QuY3JlYXRlKG51bGwpYFxuICAvLyBDaGVja2luZyBgcHJvdG9gJ3MgY29uc3RydWN0b3IgaXMgc2FmZSBiZWNhdXNlIGBnZXRQcm90b3R5cGVPZigpYFxuICAvLyBleHBsaWNpdGx5IGNyb3NzZXMgdGhlIGJvdW5kYXJ5IGZyb20gb2JqZWN0IGRhdGEgdG8gb2JqZWN0IG1ldGFkYXRhXG4gIHJldHVybiAhcHJvdG8gfHwgcHJvdG8uY29uc3RydWN0b3IubmFtZSA9PT0gJ09iamVjdCc7XG59O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/mongoose/lib/helpers/isPOJO.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/mongoose/lib/helpers/isPromise.js":
/*!********************************************************!*\
  !*** ./node_modules/mongoose/lib/helpers/isPromise.js ***!
  \********************************************************/
/***/ ((module) => {

eval("\nfunction isPromise(val) {\n  return !!val && (typeof val === 'object' || typeof val === 'function') && typeof val.then === 'function';\n}\n\nmodule.exports = isPromise;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbW9uZ29vc2UvbGliL2hlbHBlcnMvaXNQcm9taXNlLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQTtBQUNBOztBQUVBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vYXBwMS8uL25vZGVfbW9kdWxlcy9tb25nb29zZS9saWIvaGVscGVycy9pc1Byb21pc2UuanM/YmY5NCJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5mdW5jdGlvbiBpc1Byb21pc2UodmFsKSB7XG4gIHJldHVybiAhIXZhbCAmJiAodHlwZW9mIHZhbCA9PT0gJ29iamVjdCcgfHwgdHlwZW9mIHZhbCA9PT0gJ2Z1bmN0aW9uJykgJiYgdHlwZW9mIHZhbC50aGVuID09PSAnZnVuY3Rpb24nO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGlzUHJvbWlzZTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/mongoose/lib/helpers/isPromise.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/mongoose/lib/helpers/isSimpleValidator.js":
/*!****************************************************************!*\
  !*** ./node_modules/mongoose/lib/helpers/isSimpleValidator.js ***!
  \****************************************************************/
/***/ ((module) => {

eval("\n\n/**\n * Determines if `arg` is a flat object.\n *\n * @param {Object|Array|String|Function|RegExp|any} arg\n * @api private\n * @return {Boolean}\n */\n\nmodule.exports = function isSimpleValidator(obj) {\n  const keys = Object.keys(obj);\n  let result = true;\n  for (let i = 0, len = keys.length; i < len; ++i) {\n    if (typeof obj[keys[i]] === 'object' && obj[keys[i]] !== null) {\n      result = false;\n      break;\n    }\n  }\n\n  return result;\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbW9uZ29vc2UvbGliL2hlbHBlcnMvaXNTaW1wbGVWYWxpZGF0b3IuanMiLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWI7QUFDQTtBQUNBO0FBQ0EsV0FBVyx5Q0FBeUM7QUFDcEQ7QUFDQSxZQUFZO0FBQ1o7O0FBRUE7QUFDQTtBQUNBO0FBQ0EscUNBQXFDLFNBQVM7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vYXBwMS8uL25vZGVfbW9kdWxlcy9tb25nb29zZS9saWIvaGVscGVycy9pc1NpbXBsZVZhbGlkYXRvci5qcz8wMjBiIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxuLyoqXG4gKiBEZXRlcm1pbmVzIGlmIGBhcmdgIGlzIGEgZmxhdCBvYmplY3QuXG4gKlxuICogQHBhcmFtIHtPYmplY3R8QXJyYXl8U3RyaW5nfEZ1bmN0aW9ufFJlZ0V4cHxhbnl9IGFyZ1xuICogQGFwaSBwcml2YXRlXG4gKiBAcmV0dXJuIHtCb29sZWFufVxuICovXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gaXNTaW1wbGVWYWxpZGF0b3Iob2JqKSB7XG4gIGNvbnN0IGtleXMgPSBPYmplY3Qua2V5cyhvYmopO1xuICBsZXQgcmVzdWx0ID0gdHJ1ZTtcbiAgZm9yIChsZXQgaSA9IDAsIGxlbiA9IGtleXMubGVuZ3RoOyBpIDwgbGVuOyArK2kpIHtcbiAgICBpZiAodHlwZW9mIG9ialtrZXlzW2ldXSA9PT0gJ29iamVjdCcgJiYgb2JqW2tleXNbaV1dICE9PSBudWxsKSB7XG4gICAgICByZXN1bHQgPSBmYWxzZTtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiByZXN1bHQ7XG59O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/mongoose/lib/helpers/isSimpleValidator.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/mongoose/lib/helpers/minimize.js":
/*!*******************************************************!*\
  !*** ./node_modules/mongoose/lib/helpers/minimize.js ***!
  \*******************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\n\nconst { isPOJO } = __webpack_require__(/*! ../utils */ \"(ssr)/./node_modules/mongoose/lib/utils.js\");\n\nmodule.exports = minimize;\n\n/**\n * Minimizes an object, removing undefined values and empty objects\n *\n * @param {Object} object to minimize\n * @return {Object|undefined}\n * @api private\n */\n\nfunction minimize(obj) {\n  const keys = Object.keys(obj);\n  let i = keys.length;\n  let hasKeys;\n  let key;\n  let val;\n\n  while (i--) {\n    key = keys[i];\n    val = obj[key];\n\n    if (isPOJO(val)) {\n      obj[key] = minimize(val);\n    }\n\n    if (undefined === obj[key]) {\n      delete obj[key];\n      continue;\n    }\n\n    hasKeys = true;\n  }\n\n  return hasKeys\n    ? obj\n    : undefined;\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbW9uZ29vc2UvbGliL2hlbHBlcnMvbWluaW1pemUuanMiLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWIsUUFBUSxTQUFTLEVBQUUsbUJBQU8sQ0FBQyw0REFBVTs7QUFFckM7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFlBQVk7QUFDWjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9hcHAxLy4vbm9kZV9tb2R1bGVzL21vbmdvb3NlL2xpYi9oZWxwZXJzL21pbmltaXplLmpzPzQ1MTUiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG5jb25zdCB7IGlzUE9KTyB9ID0gcmVxdWlyZSgnLi4vdXRpbHMnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBtaW5pbWl6ZTtcblxuLyoqXG4gKiBNaW5pbWl6ZXMgYW4gb2JqZWN0LCByZW1vdmluZyB1bmRlZmluZWQgdmFsdWVzIGFuZCBlbXB0eSBvYmplY3RzXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCB0byBtaW5pbWl6ZVxuICogQHJldHVybiB7T2JqZWN0fHVuZGVmaW5lZH1cbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmZ1bmN0aW9uIG1pbmltaXplKG9iaikge1xuICBjb25zdCBrZXlzID0gT2JqZWN0LmtleXMob2JqKTtcbiAgbGV0IGkgPSBrZXlzLmxlbmd0aDtcbiAgbGV0IGhhc0tleXM7XG4gIGxldCBrZXk7XG4gIGxldCB2YWw7XG5cbiAgd2hpbGUgKGktLSkge1xuICAgIGtleSA9IGtleXNbaV07XG4gICAgdmFsID0gb2JqW2tleV07XG5cbiAgICBpZiAoaXNQT0pPKHZhbCkpIHtcbiAgICAgIG9ialtrZXldID0gbWluaW1pemUodmFsKTtcbiAgICB9XG5cbiAgICBpZiAodW5kZWZpbmVkID09PSBvYmpba2V5XSkge1xuICAgICAgZGVsZXRlIG9ialtrZXldO1xuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgaGFzS2V5cyA9IHRydWU7XG4gIH1cblxuICByZXR1cm4gaGFzS2V5c1xuICAgID8gb2JqXG4gICAgOiB1bmRlZmluZWQ7XG59XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/mongoose/lib/helpers/minimize.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/mongoose/lib/helpers/model/applyDefaultsToPOJO.js":
/*!************************************************************************!*\
  !*** ./node_modules/mongoose/lib/helpers/model/applyDefaultsToPOJO.js ***!
  \************************************************************************/
/***/ ((module) => {

eval("\n\nmodule.exports = function applyDefaultsToPOJO(doc, schema) {\n  const paths = Object.keys(schema.paths);\n  const plen = paths.length;\n\n  for (let i = 0; i < plen; ++i) {\n    let curPath = '';\n    const p = paths[i];\n\n    const type = schema.paths[p];\n    const path = type.splitPath();\n    const len = path.length;\n    let doc_ = doc;\n    for (let j = 0; j < len; ++j) {\n      if (doc_ == null) {\n        break;\n      }\n\n      const piece = path[j];\n      curPath += (!curPath.length ? '' : '.') + piece;\n\n      if (j === len - 1) {\n        if (typeof doc_[piece] !== 'undefined') {\n          if (type.$isSingleNested) {\n            applyDefaultsToPOJO(doc_[piece], type.caster.schema);\n          } else if (type.$isMongooseDocumentArray && Array.isArray(doc_[piece])) {\n            doc_[piece].forEach(el => applyDefaultsToPOJO(el, type.schema));\n          }\n\n          break;\n        }\n\n        const def = type.getDefault(doc, false, { skipCast: true });\n        if (typeof def !== 'undefined') {\n          doc_[piece] = def;\n\n          if (type.$isSingleNested) {\n            applyDefaultsToPOJO(def, type.caster.schema);\n          } else if (type.$isMongooseDocumentArray && Array.isArray(def)) {\n            def.forEach(el => applyDefaultsToPOJO(el, type.schema));\n          }\n        }\n      } else {\n        if (doc_[piece] == null) {\n          doc_[piece] = {};\n        }\n        doc_ = doc_[piece];\n      }\n    }\n  }\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbW9uZ29vc2UvbGliL2hlbHBlcnMvbW9kZWwvYXBwbHlEZWZhdWx0c1RvUE9KTy5qcyIsIm1hcHBpbmdzIjoiQUFBYTs7QUFFYjtBQUNBO0FBQ0E7O0FBRUEsa0JBQWtCLFVBQVU7QUFDNUI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixTQUFTO0FBQzdCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxrREFBa0QsZ0JBQWdCO0FBQ2xFO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL2FwcDEvLi9ub2RlX21vZHVsZXMvbW9uZ29vc2UvbGliL2hlbHBlcnMvbW9kZWwvYXBwbHlEZWZhdWx0c1RvUE9KTy5qcz9lZWIyIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBhcHBseURlZmF1bHRzVG9QT0pPKGRvYywgc2NoZW1hKSB7XG4gIGNvbnN0IHBhdGhzID0gT2JqZWN0LmtleXMoc2NoZW1hLnBhdGhzKTtcbiAgY29uc3QgcGxlbiA9IHBhdGhzLmxlbmd0aDtcblxuICBmb3IgKGxldCBpID0gMDsgaSA8IHBsZW47ICsraSkge1xuICAgIGxldCBjdXJQYXRoID0gJyc7XG4gICAgY29uc3QgcCA9IHBhdGhzW2ldO1xuXG4gICAgY29uc3QgdHlwZSA9IHNjaGVtYS5wYXRoc1twXTtcbiAgICBjb25zdCBwYXRoID0gdHlwZS5zcGxpdFBhdGgoKTtcbiAgICBjb25zdCBsZW4gPSBwYXRoLmxlbmd0aDtcbiAgICBsZXQgZG9jXyA9IGRvYztcbiAgICBmb3IgKGxldCBqID0gMDsgaiA8IGxlbjsgKytqKSB7XG4gICAgICBpZiAoZG9jXyA9PSBudWxsKSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuXG4gICAgICBjb25zdCBwaWVjZSA9IHBhdGhbal07XG4gICAgICBjdXJQYXRoICs9ICghY3VyUGF0aC5sZW5ndGggPyAnJyA6ICcuJykgKyBwaWVjZTtcblxuICAgICAgaWYgKGogPT09IGxlbiAtIDEpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBkb2NfW3BpZWNlXSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICBpZiAodHlwZS4kaXNTaW5nbGVOZXN0ZWQpIHtcbiAgICAgICAgICAgIGFwcGx5RGVmYXVsdHNUb1BPSk8oZG9jX1twaWVjZV0sIHR5cGUuY2FzdGVyLnNjaGVtYSk7XG4gICAgICAgICAgfSBlbHNlIGlmICh0eXBlLiRpc01vbmdvb3NlRG9jdW1lbnRBcnJheSAmJiBBcnJheS5pc0FycmF5KGRvY19bcGllY2VdKSkge1xuICAgICAgICAgICAgZG9jX1twaWVjZV0uZm9yRWFjaChlbCA9PiBhcHBseURlZmF1bHRzVG9QT0pPKGVsLCB0eXBlLnNjaGVtYSkpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgZGVmID0gdHlwZS5nZXREZWZhdWx0KGRvYywgZmFsc2UsIHsgc2tpcENhc3Q6IHRydWUgfSk7XG4gICAgICAgIGlmICh0eXBlb2YgZGVmICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgIGRvY19bcGllY2VdID0gZGVmO1xuXG4gICAgICAgICAgaWYgKHR5cGUuJGlzU2luZ2xlTmVzdGVkKSB7XG4gICAgICAgICAgICBhcHBseURlZmF1bHRzVG9QT0pPKGRlZiwgdHlwZS5jYXN0ZXIuc2NoZW1hKTtcbiAgICAgICAgICB9IGVsc2UgaWYgKHR5cGUuJGlzTW9uZ29vc2VEb2N1bWVudEFycmF5ICYmIEFycmF5LmlzQXJyYXkoZGVmKSkge1xuICAgICAgICAgICAgZGVmLmZvckVhY2goZWwgPT4gYXBwbHlEZWZhdWx0c1RvUE9KTyhlbCwgdHlwZS5zY2hlbWEpKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmIChkb2NfW3BpZWNlXSA9PSBudWxsKSB7XG4gICAgICAgICAgZG9jX1twaWVjZV0gPSB7fTtcbiAgICAgICAgfVxuICAgICAgICBkb2NfID0gZG9jX1twaWVjZV07XG4gICAgICB9XG4gICAgfVxuICB9XG59O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/mongoose/lib/helpers/model/applyDefaultsToPOJO.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/mongoose/lib/helpers/model/applyHooks.js":
/*!***************************************************************!*\
  !*** ./node_modules/mongoose/lib/helpers/model/applyHooks.js ***!
  \***************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\n\nconst symbols = __webpack_require__(/*! ../../schema/symbols */ \"(ssr)/./node_modules/mongoose/lib/schema/symbols.js\");\nconst promiseOrCallback = __webpack_require__(/*! ../promiseOrCallback */ \"(ssr)/./node_modules/mongoose/lib/helpers/promiseOrCallback.js\");\n\n/*!\n * ignore\n */\n\nmodule.exports = applyHooks;\n\n/*!\n * ignore\n */\n\napplyHooks.middlewareFunctions = [\n  'deleteOne',\n  'save',\n  'validate',\n  'remove',\n  'updateOne',\n  'init'\n];\n\n/*!\n * ignore\n */\n\nconst alreadyHookedFunctions = new Set(applyHooks.middlewareFunctions.flatMap(fn => ([fn, `$__${fn}`])));\n\n/**\n * Register hooks for this model\n *\n * @param {Model} model\n * @param {Schema} schema\n * @param {Object} options\n * @api private\n */\n\nfunction applyHooks(model, schema, options) {\n  options = options || {};\n\n  const kareemOptions = {\n    useErrorHandlers: true,\n    numCallbackParams: 1,\n    nullResultByDefault: true,\n    contextParameter: true\n  };\n  const objToDecorate = options.decorateDoc ? model : model.prototype;\n\n  model.$appliedHooks = true;\n  for (const key of Object.keys(schema.paths)) {\n    const type = schema.paths[key];\n    let childModel = null;\n    if (type.$isSingleNested) {\n      childModel = type.caster;\n    } else if (type.$isMongooseDocumentArray) {\n      childModel = type.Constructor;\n    } else {\n      continue;\n    }\n\n    if (childModel.$appliedHooks) {\n      continue;\n    }\n\n    applyHooks(childModel, type.schema, { ...options, isChildSchema: true });\n    if (childModel.discriminators != null) {\n      const keys = Object.keys(childModel.discriminators);\n      for (const key of keys) {\n        applyHooks(childModel.discriminators[key],\n          childModel.discriminators[key].schema, options);\n      }\n    }\n  }\n\n  // Built-in hooks rely on hooking internal functions in order to support\n  // promises and make it so that `doc.save.toString()` provides meaningful\n  // information.\n\n  const middleware = schema.s.hooks.\n    filter(hook => {\n      if (hook.name === 'updateOne' || hook.name === 'deleteOne') {\n        return !!hook['document'];\n      }\n      if (hook.name === 'remove' || hook.name === 'init') {\n        return hook['document'] == null || !!hook['document'];\n      }\n      if (hook.query != null || hook.document != null) {\n        return hook.document !== false;\n      }\n      return true;\n    }).\n    filter(hook => {\n      // If user has overwritten the method, don't apply built-in middleware\n      if (schema.methods[hook.name]) {\n        return !hook.fn[symbols.builtInMiddleware];\n      }\n\n      return true;\n    });\n\n  model._middleware = middleware;\n\n  objToDecorate.$__originalValidate = objToDecorate.$__originalValidate || objToDecorate.$__validate;\n\n  const internalMethodsToWrap = options && options.isChildSchema ? ['save', 'validate', 'deleteOne'] : ['save', 'validate'];\n  for (const method of internalMethodsToWrap) {\n    const toWrap = method === 'validate' ? '$__originalValidate' : `$__${method}`;\n    const wrapped = middleware.\n      createWrapper(method, objToDecorate[toWrap], null, kareemOptions);\n    objToDecorate[`$__${method}`] = wrapped;\n  }\n  objToDecorate.$__init = middleware.\n    createWrapperSync('init', objToDecorate.$__init, null, kareemOptions);\n\n  // Support hooks for custom methods\n  const customMethods = Object.keys(schema.methods);\n  const customMethodOptions = Object.assign({}, kareemOptions, {\n    // Only use `checkForPromise` for custom methods, because mongoose\n    // query thunks are not as consistent as I would like about returning\n    // a nullish value rather than the query. If a query thunk returns\n    // a query, `checkForPromise` causes infinite recursion\n    checkForPromise: true\n  });\n  for (const method of customMethods) {\n    if (alreadyHookedFunctions.has(method)) {\n      continue;\n    }\n    if (!middleware.hasHooks(method)) {\n      // Don't wrap if there are no hooks for the custom method to avoid\n      // surprises. Also, `createWrapper()` enforces consistent async,\n      // so wrapping a sync method would break it.\n      continue;\n    }\n    const originalMethod = objToDecorate[method];\n    objToDecorate[method] = function() {\n      const args = Array.prototype.slice.call(arguments);\n      const cb = args.slice(-1).pop();\n      const argsWithoutCallback = typeof cb === 'function' ?\n        args.slice(0, args.length - 1) : args;\n      return promiseOrCallback(cb, callback => {\n        return this[`$__${method}`].apply(this,\n          argsWithoutCallback.concat([callback]));\n      }, model.events);\n    };\n    objToDecorate[`$__${method}`] = middleware.\n      createWrapper(method, originalMethod, null, customMethodOptions);\n  }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbW9uZ29vc2UvbGliL2hlbHBlcnMvbW9kZWwvYXBwbHlIb29rcy5qcyIsIm1hcHBpbmdzIjoiQUFBYTs7QUFFYixnQkFBZ0IsbUJBQU8sQ0FBQyxpRkFBc0I7QUFDOUMsMEJBQTBCLG1CQUFPLENBQUMsNEZBQXNCOztBQUV4RDtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLGdHQUFnRyxHQUFHOztBQUVuRztBQUNBO0FBQ0E7QUFDQSxXQUFXLE9BQU87QUFDbEIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLDBDQUEwQyxpQ0FBaUM7QUFDM0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLOztBQUVMOztBQUVBOztBQUVBO0FBQ0E7QUFDQSx5RUFBeUUsT0FBTztBQUNoRjtBQUNBO0FBQ0Esd0JBQXdCLE9BQU87QUFDL0I7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSw4Q0FBOEM7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLE9BQU87QUFDakM7QUFDQSxPQUFPO0FBQ1A7QUFDQSx3QkFBd0IsT0FBTztBQUMvQjtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9hcHAxLy4vbm9kZV9tb2R1bGVzL21vbmdvb3NlL2xpYi9oZWxwZXJzL21vZGVsL2FwcGx5SG9va3MuanM/ODI2YyJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbmNvbnN0IHN5bWJvbHMgPSByZXF1aXJlKCcuLi8uLi9zY2hlbWEvc3ltYm9scycpO1xuY29uc3QgcHJvbWlzZU9yQ2FsbGJhY2sgPSByZXF1aXJlKCcuLi9wcm9taXNlT3JDYWxsYmFjaycpO1xuXG4vKiFcbiAqIGlnbm9yZVxuICovXG5cbm1vZHVsZS5leHBvcnRzID0gYXBwbHlIb29rcztcblxuLyohXG4gKiBpZ25vcmVcbiAqL1xuXG5hcHBseUhvb2tzLm1pZGRsZXdhcmVGdW5jdGlvbnMgPSBbXG4gICdkZWxldGVPbmUnLFxuICAnc2F2ZScsXG4gICd2YWxpZGF0ZScsXG4gICdyZW1vdmUnLFxuICAndXBkYXRlT25lJyxcbiAgJ2luaXQnXG5dO1xuXG4vKiFcbiAqIGlnbm9yZVxuICovXG5cbmNvbnN0IGFscmVhZHlIb29rZWRGdW5jdGlvbnMgPSBuZXcgU2V0KGFwcGx5SG9va3MubWlkZGxld2FyZUZ1bmN0aW9ucy5mbGF0TWFwKGZuID0+IChbZm4sIGAkX18ke2ZufWBdKSkpO1xuXG4vKipcbiAqIFJlZ2lzdGVyIGhvb2tzIGZvciB0aGlzIG1vZGVsXG4gKlxuICogQHBhcmFtIHtNb2RlbH0gbW9kZWxcbiAqIEBwYXJhbSB7U2NoZW1hfSBzY2hlbWFcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5mdW5jdGlvbiBhcHBseUhvb2tzKG1vZGVsLCBzY2hlbWEsIG9wdGlvbnMpIHtcbiAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG5cbiAgY29uc3Qga2FyZWVtT3B0aW9ucyA9IHtcbiAgICB1c2VFcnJvckhhbmRsZXJzOiB0cnVlLFxuICAgIG51bUNhbGxiYWNrUGFyYW1zOiAxLFxuICAgIG51bGxSZXN1bHRCeURlZmF1bHQ6IHRydWUsXG4gICAgY29udGV4dFBhcmFtZXRlcjogdHJ1ZVxuICB9O1xuICBjb25zdCBvYmpUb0RlY29yYXRlID0gb3B0aW9ucy5kZWNvcmF0ZURvYyA/IG1vZGVsIDogbW9kZWwucHJvdG90eXBlO1xuXG4gIG1vZGVsLiRhcHBsaWVkSG9va3MgPSB0cnVlO1xuICBmb3IgKGNvbnN0IGtleSBvZiBPYmplY3Qua2V5cyhzY2hlbWEucGF0aHMpKSB7XG4gICAgY29uc3QgdHlwZSA9IHNjaGVtYS5wYXRoc1trZXldO1xuICAgIGxldCBjaGlsZE1vZGVsID0gbnVsbDtcbiAgICBpZiAodHlwZS4kaXNTaW5nbGVOZXN0ZWQpIHtcbiAgICAgIGNoaWxkTW9kZWwgPSB0eXBlLmNhc3RlcjtcbiAgICB9IGVsc2UgaWYgKHR5cGUuJGlzTW9uZ29vc2VEb2N1bWVudEFycmF5KSB7XG4gICAgICBjaGlsZE1vZGVsID0gdHlwZS5Db25zdHJ1Y3RvcjtcbiAgICB9IGVsc2Uge1xuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgaWYgKGNoaWxkTW9kZWwuJGFwcGxpZWRIb29rcykge1xuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgYXBwbHlIb29rcyhjaGlsZE1vZGVsLCB0eXBlLnNjaGVtYSwgeyAuLi5vcHRpb25zLCBpc0NoaWxkU2NoZW1hOiB0cnVlIH0pO1xuICAgIGlmIChjaGlsZE1vZGVsLmRpc2NyaW1pbmF0b3JzICE9IG51bGwpIHtcbiAgICAgIGNvbnN0IGtleXMgPSBPYmplY3Qua2V5cyhjaGlsZE1vZGVsLmRpc2NyaW1pbmF0b3JzKTtcbiAgICAgIGZvciAoY29uc3Qga2V5IG9mIGtleXMpIHtcbiAgICAgICAgYXBwbHlIb29rcyhjaGlsZE1vZGVsLmRpc2NyaW1pbmF0b3JzW2tleV0sXG4gICAgICAgICAgY2hpbGRNb2RlbC5kaXNjcmltaW5hdG9yc1trZXldLnNjaGVtYSwgb3B0aW9ucyk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLy8gQnVpbHQtaW4gaG9va3MgcmVseSBvbiBob29raW5nIGludGVybmFsIGZ1bmN0aW9ucyBpbiBvcmRlciB0byBzdXBwb3J0XG4gIC8vIHByb21pc2VzIGFuZCBtYWtlIGl0IHNvIHRoYXQgYGRvYy5zYXZlLnRvU3RyaW5nKClgIHByb3ZpZGVzIG1lYW5pbmdmdWxcbiAgLy8gaW5mb3JtYXRpb24uXG5cbiAgY29uc3QgbWlkZGxld2FyZSA9IHNjaGVtYS5zLmhvb2tzLlxuICAgIGZpbHRlcihob29rID0+IHtcbiAgICAgIGlmIChob29rLm5hbWUgPT09ICd1cGRhdGVPbmUnIHx8IGhvb2submFtZSA9PT0gJ2RlbGV0ZU9uZScpIHtcbiAgICAgICAgcmV0dXJuICEhaG9va1snZG9jdW1lbnQnXTtcbiAgICAgIH1cbiAgICAgIGlmIChob29rLm5hbWUgPT09ICdyZW1vdmUnIHx8IGhvb2submFtZSA9PT0gJ2luaXQnKSB7XG4gICAgICAgIHJldHVybiBob29rWydkb2N1bWVudCddID09IG51bGwgfHwgISFob29rWydkb2N1bWVudCddO1xuICAgICAgfVxuICAgICAgaWYgKGhvb2sucXVlcnkgIT0gbnVsbCB8fCBob29rLmRvY3VtZW50ICE9IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIGhvb2suZG9jdW1lbnQgIT09IGZhbHNlO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSkuXG4gICAgZmlsdGVyKGhvb2sgPT4ge1xuICAgICAgLy8gSWYgdXNlciBoYXMgb3ZlcndyaXR0ZW4gdGhlIG1ldGhvZCwgZG9uJ3QgYXBwbHkgYnVpbHQtaW4gbWlkZGxld2FyZVxuICAgICAgaWYgKHNjaGVtYS5tZXRob2RzW2hvb2submFtZV0pIHtcbiAgICAgICAgcmV0dXJuICFob29rLmZuW3N5bWJvbHMuYnVpbHRJbk1pZGRsZXdhcmVdO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9KTtcblxuICBtb2RlbC5fbWlkZGxld2FyZSA9IG1pZGRsZXdhcmU7XG5cbiAgb2JqVG9EZWNvcmF0ZS4kX19vcmlnaW5hbFZhbGlkYXRlID0gb2JqVG9EZWNvcmF0ZS4kX19vcmlnaW5hbFZhbGlkYXRlIHx8IG9ialRvRGVjb3JhdGUuJF9fdmFsaWRhdGU7XG5cbiAgY29uc3QgaW50ZXJuYWxNZXRob2RzVG9XcmFwID0gb3B0aW9ucyAmJiBvcHRpb25zLmlzQ2hpbGRTY2hlbWEgPyBbJ3NhdmUnLCAndmFsaWRhdGUnLCAnZGVsZXRlT25lJ10gOiBbJ3NhdmUnLCAndmFsaWRhdGUnXTtcbiAgZm9yIChjb25zdCBtZXRob2Qgb2YgaW50ZXJuYWxNZXRob2RzVG9XcmFwKSB7XG4gICAgY29uc3QgdG9XcmFwID0gbWV0aG9kID09PSAndmFsaWRhdGUnID8gJyRfX29yaWdpbmFsVmFsaWRhdGUnIDogYCRfXyR7bWV0aG9kfWA7XG4gICAgY29uc3Qgd3JhcHBlZCA9IG1pZGRsZXdhcmUuXG4gICAgICBjcmVhdGVXcmFwcGVyKG1ldGhvZCwgb2JqVG9EZWNvcmF0ZVt0b1dyYXBdLCBudWxsLCBrYXJlZW1PcHRpb25zKTtcbiAgICBvYmpUb0RlY29yYXRlW2AkX18ke21ldGhvZH1gXSA9IHdyYXBwZWQ7XG4gIH1cbiAgb2JqVG9EZWNvcmF0ZS4kX19pbml0ID0gbWlkZGxld2FyZS5cbiAgICBjcmVhdGVXcmFwcGVyU3luYygnaW5pdCcsIG9ialRvRGVjb3JhdGUuJF9faW5pdCwgbnVsbCwga2FyZWVtT3B0aW9ucyk7XG5cbiAgLy8gU3VwcG9ydCBob29rcyBmb3IgY3VzdG9tIG1ldGhvZHNcbiAgY29uc3QgY3VzdG9tTWV0aG9kcyA9IE9iamVjdC5rZXlzKHNjaGVtYS5tZXRob2RzKTtcbiAgY29uc3QgY3VzdG9tTWV0aG9kT3B0aW9ucyA9IE9iamVjdC5hc3NpZ24oe30sIGthcmVlbU9wdGlvbnMsIHtcbiAgICAvLyBPbmx5IHVzZSBgY2hlY2tGb3JQcm9taXNlYCBmb3IgY3VzdG9tIG1ldGhvZHMsIGJlY2F1c2UgbW9uZ29vc2VcbiAgICAvLyBxdWVyeSB0aHVua3MgYXJlIG5vdCBhcyBjb25zaXN0ZW50IGFzIEkgd291bGQgbGlrZSBhYm91dCByZXR1cm5pbmdcbiAgICAvLyBhIG51bGxpc2ggdmFsdWUgcmF0aGVyIHRoYW4gdGhlIHF1ZXJ5LiBJZiBhIHF1ZXJ5IHRodW5rIHJldHVybnNcbiAgICAvLyBhIHF1ZXJ5LCBgY2hlY2tGb3JQcm9taXNlYCBjYXVzZXMgaW5maW5pdGUgcmVjdXJzaW9uXG4gICAgY2hlY2tGb3JQcm9taXNlOiB0cnVlXG4gIH0pO1xuICBmb3IgKGNvbnN0IG1ldGhvZCBvZiBjdXN0b21NZXRob2RzKSB7XG4gICAgaWYgKGFscmVhZHlIb29rZWRGdW5jdGlvbnMuaGFzKG1ldGhvZCkpIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICBpZiAoIW1pZGRsZXdhcmUuaGFzSG9va3MobWV0aG9kKSkge1xuICAgICAgLy8gRG9uJ3Qgd3JhcCBpZiB0aGVyZSBhcmUgbm8gaG9va3MgZm9yIHRoZSBjdXN0b20gbWV0aG9kIHRvIGF2b2lkXG4gICAgICAvLyBzdXJwcmlzZXMuIEFsc28sIGBjcmVhdGVXcmFwcGVyKClgIGVuZm9yY2VzIGNvbnNpc3RlbnQgYXN5bmMsXG4gICAgICAvLyBzbyB3cmFwcGluZyBhIHN5bmMgbWV0aG9kIHdvdWxkIGJyZWFrIGl0LlxuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIGNvbnN0IG9yaWdpbmFsTWV0aG9kID0gb2JqVG9EZWNvcmF0ZVttZXRob2RdO1xuICAgIG9ialRvRGVjb3JhdGVbbWV0aG9kXSA9IGZ1bmN0aW9uKCkge1xuICAgICAgY29uc3QgYXJncyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cyk7XG4gICAgICBjb25zdCBjYiA9IGFyZ3Muc2xpY2UoLTEpLnBvcCgpO1xuICAgICAgY29uc3QgYXJnc1dpdGhvdXRDYWxsYmFjayA9IHR5cGVvZiBjYiA9PT0gJ2Z1bmN0aW9uJyA/XG4gICAgICAgIGFyZ3Muc2xpY2UoMCwgYXJncy5sZW5ndGggLSAxKSA6IGFyZ3M7XG4gICAgICByZXR1cm4gcHJvbWlzZU9yQ2FsbGJhY2soY2IsIGNhbGxiYWNrID0+IHtcbiAgICAgICAgcmV0dXJuIHRoaXNbYCRfXyR7bWV0aG9kfWBdLmFwcGx5KHRoaXMsXG4gICAgICAgICAgYXJnc1dpdGhvdXRDYWxsYmFjay5jb25jYXQoW2NhbGxiYWNrXSkpO1xuICAgICAgfSwgbW9kZWwuZXZlbnRzKTtcbiAgICB9O1xuICAgIG9ialRvRGVjb3JhdGVbYCRfXyR7bWV0aG9kfWBdID0gbWlkZGxld2FyZS5cbiAgICAgIGNyZWF0ZVdyYXBwZXIobWV0aG9kLCBvcmlnaW5hbE1ldGhvZCwgbnVsbCwgY3VzdG9tTWV0aG9kT3B0aW9ucyk7XG4gIH1cbn1cbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/mongoose/lib/helpers/model/applyHooks.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/mongoose/lib/helpers/model/applyMethods.js":
/*!*****************************************************************!*\
  !*** ./node_modules/mongoose/lib/helpers/model/applyMethods.js ***!
  \*****************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\n\nconst get = __webpack_require__(/*! ../get */ \"(ssr)/./node_modules/mongoose/lib/helpers/get.js\");\nconst utils = __webpack_require__(/*! ../../utils */ \"(ssr)/./node_modules/mongoose/lib/utils.js\");\n\n/**\n * Register methods for this model\n *\n * @param {Model} model\n * @param {Schema} schema\n * @api private\n */\n\nmodule.exports = function applyMethods(model, schema) {\n  const Model = __webpack_require__(/*! ../../model */ \"(ssr)/./node_modules/mongoose/lib/model.js\");\n\n  function apply(method, schema) {\n    Object.defineProperty(model.prototype, method, {\n      get: function() {\n        const h = {};\n        for (const k in schema.methods[method]) {\n          h[k] = schema.methods[method][k].bind(this);\n        }\n        return h;\n      },\n      configurable: true\n    });\n  }\n  for (const method of Object.keys(schema.methods)) {\n    const fn = schema.methods[method];\n    if (schema.tree.hasOwnProperty(method)) {\n      throw new Error('You have a method and a property in your schema both ' +\n        'named \"' + method + '\"');\n    }\n\n    // Avoid making custom methods if user sets a method to itself, e.g.\n    // `schema.method(save, Document.prototype.save)`. Can happen when\n    // calling `loadClass()` with a class that `extends Document`. See gh-12254\n    if (typeof fn === 'function' &&\n        Model.prototype[method] === fn) {\n      delete schema.methods[method];\n      continue;\n    }\n\n    if (schema.reserved[method] &&\n        !get(schema, `methodOptions.${method}.suppressWarning`, false)) {\n      utils.warn(`mongoose: the method name \"${method}\" is used by mongoose ` +\n        'internally, overwriting it may cause bugs. If you\\'re sure you know ' +\n        'what you\\'re doing, you can suppress this error by using ' +\n        `\\`schema.method('${method}', fn, { suppressWarning: true })\\`.`);\n    }\n    if (typeof fn === 'function') {\n      model.prototype[method] = fn;\n    } else {\n      apply(method, schema);\n    }\n  }\n\n  // Recursively call `applyMethods()` on child schemas\n  model.$appliedMethods = true;\n  for (const key of Object.keys(schema.paths)) {\n    const type = schema.paths[key];\n    if (type.$isSingleNested && !type.caster.$appliedMethods) {\n      applyMethods(type.caster, type.schema);\n    }\n    if (type.$isMongooseDocumentArray && !type.Constructor.$appliedMethods) {\n      applyMethods(type.Constructor, type.schema);\n    }\n  }\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbW9uZ29vc2UvbGliL2hlbHBlcnMvbW9kZWwvYXBwbHlNZXRob2RzLmpzIiwibWFwcGluZ3MiOiJBQUFhOztBQUViLFlBQVksbUJBQU8sQ0FBQyxnRUFBUTtBQUM1QixjQUFjLG1CQUFPLENBQUMsK0RBQWE7O0FBRW5DO0FBQ0E7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQixXQUFXLFFBQVE7QUFDbkI7QUFDQTs7QUFFQTtBQUNBLGdCQUFnQixtQkFBTyxDQUFDLCtEQUFhOztBQUVyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxzQ0FBc0MsT0FBTztBQUM3QywrQ0FBK0MsT0FBTztBQUN0RDtBQUNBO0FBQ0EsNEJBQTRCLE9BQU8sU0FBUyx1QkFBdUI7QUFDbkU7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9hcHAxLy4vbm9kZV9tb2R1bGVzL21vbmdvb3NlL2xpYi9oZWxwZXJzL21vZGVsL2FwcGx5TWV0aG9kcy5qcz85ZWEyIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxuY29uc3QgZ2V0ID0gcmVxdWlyZSgnLi4vZ2V0Jyk7XG5jb25zdCB1dGlscyA9IHJlcXVpcmUoJy4uLy4uL3V0aWxzJyk7XG5cbi8qKlxuICogUmVnaXN0ZXIgbWV0aG9kcyBmb3IgdGhpcyBtb2RlbFxuICpcbiAqIEBwYXJhbSB7TW9kZWx9IG1vZGVsXG4gKiBAcGFyYW0ge1NjaGVtYX0gc2NoZW1hXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGFwcGx5TWV0aG9kcyhtb2RlbCwgc2NoZW1hKSB7XG4gIGNvbnN0IE1vZGVsID0gcmVxdWlyZSgnLi4vLi4vbW9kZWwnKTtcblxuICBmdW5jdGlvbiBhcHBseShtZXRob2QsIHNjaGVtYSkge1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShtb2RlbC5wcm90b3R5cGUsIG1ldGhvZCwge1xuICAgICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgY29uc3QgaCA9IHt9O1xuICAgICAgICBmb3IgKGNvbnN0IGsgaW4gc2NoZW1hLm1ldGhvZHNbbWV0aG9kXSkge1xuICAgICAgICAgIGhba10gPSBzY2hlbWEubWV0aG9kc1ttZXRob2RdW2tdLmJpbmQodGhpcyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGg7XG4gICAgICB9LFxuICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gIH1cbiAgZm9yIChjb25zdCBtZXRob2Qgb2YgT2JqZWN0LmtleXMoc2NoZW1hLm1ldGhvZHMpKSB7XG4gICAgY29uc3QgZm4gPSBzY2hlbWEubWV0aG9kc1ttZXRob2RdO1xuICAgIGlmIChzY2hlbWEudHJlZS5oYXNPd25Qcm9wZXJ0eShtZXRob2QpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1lvdSBoYXZlIGEgbWV0aG9kIGFuZCBhIHByb3BlcnR5IGluIHlvdXIgc2NoZW1hIGJvdGggJyArXG4gICAgICAgICduYW1lZCBcIicgKyBtZXRob2QgKyAnXCInKTtcbiAgICB9XG5cbiAgICAvLyBBdm9pZCBtYWtpbmcgY3VzdG9tIG1ldGhvZHMgaWYgdXNlciBzZXRzIGEgbWV0aG9kIHRvIGl0c2VsZiwgZS5nLlxuICAgIC8vIGBzY2hlbWEubWV0aG9kKHNhdmUsIERvY3VtZW50LnByb3RvdHlwZS5zYXZlKWAuIENhbiBoYXBwZW4gd2hlblxuICAgIC8vIGNhbGxpbmcgYGxvYWRDbGFzcygpYCB3aXRoIGEgY2xhc3MgdGhhdCBgZXh0ZW5kcyBEb2N1bWVudGAuIFNlZSBnaC0xMjI1NFxuICAgIGlmICh0eXBlb2YgZm4gPT09ICdmdW5jdGlvbicgJiZcbiAgICAgICAgTW9kZWwucHJvdG90eXBlW21ldGhvZF0gPT09IGZuKSB7XG4gICAgICBkZWxldGUgc2NoZW1hLm1ldGhvZHNbbWV0aG9kXTtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIGlmIChzY2hlbWEucmVzZXJ2ZWRbbWV0aG9kXSAmJlxuICAgICAgICAhZ2V0KHNjaGVtYSwgYG1ldGhvZE9wdGlvbnMuJHttZXRob2R9LnN1cHByZXNzV2FybmluZ2AsIGZhbHNlKSkge1xuICAgICAgdXRpbHMud2FybihgbW9uZ29vc2U6IHRoZSBtZXRob2QgbmFtZSBcIiR7bWV0aG9kfVwiIGlzIHVzZWQgYnkgbW9uZ29vc2UgYCArXG4gICAgICAgICdpbnRlcm5hbGx5LCBvdmVyd3JpdGluZyBpdCBtYXkgY2F1c2UgYnVncy4gSWYgeW91XFwncmUgc3VyZSB5b3Uga25vdyAnICtcbiAgICAgICAgJ3doYXQgeW91XFwncmUgZG9pbmcsIHlvdSBjYW4gc3VwcHJlc3MgdGhpcyBlcnJvciBieSB1c2luZyAnICtcbiAgICAgICAgYFxcYHNjaGVtYS5tZXRob2QoJyR7bWV0aG9kfScsIGZuLCB7IHN1cHByZXNzV2FybmluZzogdHJ1ZSB9KVxcYC5gKTtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBmbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgbW9kZWwucHJvdG90eXBlW21ldGhvZF0gPSBmbjtcbiAgICB9IGVsc2Uge1xuICAgICAgYXBwbHkobWV0aG9kLCBzY2hlbWEpO1xuICAgIH1cbiAgfVxuXG4gIC8vIFJlY3Vyc2l2ZWx5IGNhbGwgYGFwcGx5TWV0aG9kcygpYCBvbiBjaGlsZCBzY2hlbWFzXG4gIG1vZGVsLiRhcHBsaWVkTWV0aG9kcyA9IHRydWU7XG4gIGZvciAoY29uc3Qga2V5IG9mIE9iamVjdC5rZXlzKHNjaGVtYS5wYXRocykpIHtcbiAgICBjb25zdCB0eXBlID0gc2NoZW1hLnBhdGhzW2tleV07XG4gICAgaWYgKHR5cGUuJGlzU2luZ2xlTmVzdGVkICYmICF0eXBlLmNhc3Rlci4kYXBwbGllZE1ldGhvZHMpIHtcbiAgICAgIGFwcGx5TWV0aG9kcyh0eXBlLmNhc3RlciwgdHlwZS5zY2hlbWEpO1xuICAgIH1cbiAgICBpZiAodHlwZS4kaXNNb25nb29zZURvY3VtZW50QXJyYXkgJiYgIXR5cGUuQ29uc3RydWN0b3IuJGFwcGxpZWRNZXRob2RzKSB7XG4gICAgICBhcHBseU1ldGhvZHModHlwZS5Db25zdHJ1Y3RvciwgdHlwZS5zY2hlbWEpO1xuICAgIH1cbiAgfVxufTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/mongoose/lib/helpers/model/applyMethods.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/mongoose/lib/helpers/model/applyStaticHooks.js":
/*!*********************************************************************!*\
  !*** ./node_modules/mongoose/lib/helpers/model/applyStaticHooks.js ***!
  \*********************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\n\nconst middlewareFunctions = (__webpack_require__(/*! ../query/applyQueryMiddleware */ \"(ssr)/./node_modules/mongoose/lib/helpers/query/applyQueryMiddleware.js\").middlewareFunctions);\nconst promiseOrCallback = __webpack_require__(/*! ../promiseOrCallback */ \"(ssr)/./node_modules/mongoose/lib/helpers/promiseOrCallback.js\");\n\nmodule.exports = function applyStaticHooks(model, hooks, statics) {\n  const kareemOptions = {\n    useErrorHandlers: true,\n    numCallbackParams: 1\n  };\n\n  hooks = hooks.filter(hook => {\n    // If the custom static overwrites an existing query middleware, don't apply\n    // middleware to it by default. This avoids a potential backwards breaking\n    // change with plugins like `mongoose-delete` that use statics to overwrite\n    // built-in Mongoose functions.\n    if (middlewareFunctions.indexOf(hook.name) !== -1) {\n      return !!hook.model;\n    }\n    return hook.model !== false;\n  });\n\n  model.$__insertMany = hooks.createWrapper('insertMany',\n    model.$__insertMany, model, kareemOptions);\n\n  for (const key of Object.keys(statics)) {\n    if (hooks.hasHooks(key)) {\n      const original = model[key];\n\n      model[key] = function() {\n        const numArgs = arguments.length;\n        const lastArg = numArgs > 0 ? arguments[numArgs - 1] : null;\n        const cb = typeof lastArg === 'function' ? lastArg : null;\n        const args = Array.prototype.slice.\n          call(arguments, 0, cb == null ? numArgs : numArgs - 1);\n        // Special case: can't use `Kareem#wrap()` because it doesn't currently\n        // support wrapped functions that return a promise.\n        return promiseOrCallback(cb, callback => {\n          hooks.execPre(key, model, args, function(err) {\n            if (err != null) {\n              return callback(err);\n            }\n\n            let postCalled = 0;\n            const ret = original.apply(model, args.concat(post));\n            if (ret != null && typeof ret.then === 'function') {\n              ret.then(res => post(null, res), err => post(err));\n            }\n\n            function post(error, res) {\n              if (postCalled++ > 0) {\n                return;\n              }\n\n              if (error != null) {\n                return callback(error);\n              }\n\n              hooks.execPost(key, model, [res], function(error) {\n                if (error != null) {\n                  return callback(error);\n                }\n                callback(null, res);\n              });\n            }\n          });\n        }, model.events);\n      };\n    }\n  }\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbW9uZ29vc2UvbGliL2hlbHBlcnMvbW9kZWwvYXBwbHlTdGF0aWNIb29rcy5qcyIsIm1hcHBpbmdzIjoiQUFBYTs7QUFFYiw0QkFBNEIseUpBQTREO0FBQ3hGLDBCQUEwQixtQkFBTyxDQUFDLDRGQUFzQjs7QUFFeEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQSxXQUFXO0FBQ1gsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vYXBwMS8uL25vZGVfbW9kdWxlcy9tb25nb29zZS9saWIvaGVscGVycy9tb2RlbC9hcHBseVN0YXRpY0hvb2tzLmpzPzc1YjMiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG5jb25zdCBtaWRkbGV3YXJlRnVuY3Rpb25zID0gcmVxdWlyZSgnLi4vcXVlcnkvYXBwbHlRdWVyeU1pZGRsZXdhcmUnKS5taWRkbGV3YXJlRnVuY3Rpb25zO1xuY29uc3QgcHJvbWlzZU9yQ2FsbGJhY2sgPSByZXF1aXJlKCcuLi9wcm9taXNlT3JDYWxsYmFjaycpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGFwcGx5U3RhdGljSG9va3MobW9kZWwsIGhvb2tzLCBzdGF0aWNzKSB7XG4gIGNvbnN0IGthcmVlbU9wdGlvbnMgPSB7XG4gICAgdXNlRXJyb3JIYW5kbGVyczogdHJ1ZSxcbiAgICBudW1DYWxsYmFja1BhcmFtczogMVxuICB9O1xuXG4gIGhvb2tzID0gaG9va3MuZmlsdGVyKGhvb2sgPT4ge1xuICAgIC8vIElmIHRoZSBjdXN0b20gc3RhdGljIG92ZXJ3cml0ZXMgYW4gZXhpc3RpbmcgcXVlcnkgbWlkZGxld2FyZSwgZG9uJ3QgYXBwbHlcbiAgICAvLyBtaWRkbGV3YXJlIHRvIGl0IGJ5IGRlZmF1bHQuIFRoaXMgYXZvaWRzIGEgcG90ZW50aWFsIGJhY2t3YXJkcyBicmVha2luZ1xuICAgIC8vIGNoYW5nZSB3aXRoIHBsdWdpbnMgbGlrZSBgbW9uZ29vc2UtZGVsZXRlYCB0aGF0IHVzZSBzdGF0aWNzIHRvIG92ZXJ3cml0ZVxuICAgIC8vIGJ1aWx0LWluIE1vbmdvb3NlIGZ1bmN0aW9ucy5cbiAgICBpZiAobWlkZGxld2FyZUZ1bmN0aW9ucy5pbmRleE9mKGhvb2submFtZSkgIT09IC0xKSB7XG4gICAgICByZXR1cm4gISFob29rLm1vZGVsO1xuICAgIH1cbiAgICByZXR1cm4gaG9vay5tb2RlbCAhPT0gZmFsc2U7XG4gIH0pO1xuXG4gIG1vZGVsLiRfX2luc2VydE1hbnkgPSBob29rcy5jcmVhdGVXcmFwcGVyKCdpbnNlcnRNYW55JyxcbiAgICBtb2RlbC4kX19pbnNlcnRNYW55LCBtb2RlbCwga2FyZWVtT3B0aW9ucyk7XG5cbiAgZm9yIChjb25zdCBrZXkgb2YgT2JqZWN0LmtleXMoc3RhdGljcykpIHtcbiAgICBpZiAoaG9va3MuaGFzSG9va3Moa2V5KSkge1xuICAgICAgY29uc3Qgb3JpZ2luYWwgPSBtb2RlbFtrZXldO1xuXG4gICAgICBtb2RlbFtrZXldID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIGNvbnN0IG51bUFyZ3MgPSBhcmd1bWVudHMubGVuZ3RoO1xuICAgICAgICBjb25zdCBsYXN0QXJnID0gbnVtQXJncyA+IDAgPyBhcmd1bWVudHNbbnVtQXJncyAtIDFdIDogbnVsbDtcbiAgICAgICAgY29uc3QgY2IgPSB0eXBlb2YgbGFzdEFyZyA9PT0gJ2Z1bmN0aW9uJyA/IGxhc3RBcmcgOiBudWxsO1xuICAgICAgICBjb25zdCBhcmdzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLlxuICAgICAgICAgIGNhbGwoYXJndW1lbnRzLCAwLCBjYiA9PSBudWxsID8gbnVtQXJncyA6IG51bUFyZ3MgLSAxKTtcbiAgICAgICAgLy8gU3BlY2lhbCBjYXNlOiBjYW4ndCB1c2UgYEthcmVlbSN3cmFwKClgIGJlY2F1c2UgaXQgZG9lc24ndCBjdXJyZW50bHlcbiAgICAgICAgLy8gc3VwcG9ydCB3cmFwcGVkIGZ1bmN0aW9ucyB0aGF0IHJldHVybiBhIHByb21pc2UuXG4gICAgICAgIHJldHVybiBwcm9taXNlT3JDYWxsYmFjayhjYiwgY2FsbGJhY2sgPT4ge1xuICAgICAgICAgIGhvb2tzLmV4ZWNQcmUoa2V5LCBtb2RlbCwgYXJncywgZnVuY3Rpb24oZXJyKSB7XG4gICAgICAgICAgICBpZiAoZXJyICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGNhbGxiYWNrKGVycik7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGxldCBwb3N0Q2FsbGVkID0gMDtcbiAgICAgICAgICAgIGNvbnN0IHJldCA9IG9yaWdpbmFsLmFwcGx5KG1vZGVsLCBhcmdzLmNvbmNhdChwb3N0KSk7XG4gICAgICAgICAgICBpZiAocmV0ICE9IG51bGwgJiYgdHlwZW9mIHJldC50aGVuID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgIHJldC50aGVuKHJlcyA9PiBwb3N0KG51bGwsIHJlcyksIGVyciA9PiBwb3N0KGVycikpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBmdW5jdGlvbiBwb3N0KGVycm9yLCByZXMpIHtcbiAgICAgICAgICAgICAgaWYgKHBvc3RDYWxsZWQrKyA+IDApIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICBpZiAoZXJyb3IgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBjYWxsYmFjayhlcnJvcik7XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICBob29rcy5leGVjUG9zdChrZXksIG1vZGVsLCBbcmVzXSwgZnVuY3Rpb24oZXJyb3IpIHtcbiAgICAgICAgICAgICAgICBpZiAoZXJyb3IgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIGNhbGxiYWNrKGVycm9yKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2FsbGJhY2sobnVsbCwgcmVzKTtcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG4gICAgICAgIH0sIG1vZGVsLmV2ZW50cyk7XG4gICAgICB9O1xuICAgIH1cbiAgfVxufTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/mongoose/lib/helpers/model/applyStaticHooks.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/mongoose/lib/helpers/model/applyStatics.js":
/*!*****************************************************************!*\
  !*** ./node_modules/mongoose/lib/helpers/model/applyStatics.js ***!
  \*****************************************************************/
/***/ ((module) => {

eval("\n\n/**\n * Register statics for this model\n * @param {Model} model\n * @param {Schema} schema\n * @api private\n */\nmodule.exports = function applyStatics(model, schema) {\n  for (const i in schema.statics) {\n    model[i] = schema.statics[i];\n  }\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbW9uZ29vc2UvbGliL2hlbHBlcnMvbW9kZWwvYXBwbHlTdGF0aWNzLmpzIiwibWFwcGluZ3MiOiJBQUFhOztBQUViO0FBQ0E7QUFDQSxXQUFXLE9BQU87QUFDbEIsV0FBVyxRQUFRO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vYXBwMS8uL25vZGVfbW9kdWxlcy9tb25nb29zZS9saWIvaGVscGVycy9tb2RlbC9hcHBseVN0YXRpY3MuanM/YmQ2NiJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbi8qKlxuICogUmVnaXN0ZXIgc3RhdGljcyBmb3IgdGhpcyBtb2RlbFxuICogQHBhcmFtIHtNb2RlbH0gbW9kZWxcbiAqIEBwYXJhbSB7U2NoZW1hfSBzY2hlbWFcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGFwcGx5U3RhdGljcyhtb2RlbCwgc2NoZW1hKSB7XG4gIGZvciAoY29uc3QgaSBpbiBzY2hlbWEuc3RhdGljcykge1xuICAgIG1vZGVsW2ldID0gc2NoZW1hLnN0YXRpY3NbaV07XG4gIH1cbn07XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/mongoose/lib/helpers/model/applyStatics.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/mongoose/lib/helpers/model/castBulkWrite.js":
/*!******************************************************************!*\
  !*** ./node_modules/mongoose/lib/helpers/model/castBulkWrite.js ***!
  \******************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\n\nconst MongooseError = __webpack_require__(/*! ../../error/mongooseError */ \"(ssr)/./node_modules/mongoose/lib/error/mongooseError.js\");\nconst getDiscriminatorByValue = __webpack_require__(/*! ../../helpers/discriminator/getDiscriminatorByValue */ \"(ssr)/./node_modules/mongoose/lib/helpers/discriminator/getDiscriminatorByValue.js\");\nconst applyTimestampsToChildren = __webpack_require__(/*! ../update/applyTimestampsToChildren */ \"(ssr)/./node_modules/mongoose/lib/helpers/update/applyTimestampsToChildren.js\");\nconst applyTimestampsToUpdate = __webpack_require__(/*! ../update/applyTimestampsToUpdate */ \"(ssr)/./node_modules/mongoose/lib/helpers/update/applyTimestampsToUpdate.js\");\nconst cast = __webpack_require__(/*! ../../cast */ \"(ssr)/./node_modules/mongoose/lib/cast.js\");\nconst castUpdate = __webpack_require__(/*! ../query/castUpdate */ \"(ssr)/./node_modules/mongoose/lib/helpers/query/castUpdate.js\");\nconst decorateUpdateWithVersionKey = __webpack_require__(/*! ../update/decorateUpdateWithVersionKey */ \"(ssr)/./node_modules/mongoose/lib/helpers/update/decorateUpdateWithVersionKey.js\");\nconst { inspect } = __webpack_require__(/*! util */ \"util\");\nconst setDefaultsOnInsert = __webpack_require__(/*! ../setDefaultsOnInsert */ \"(ssr)/./node_modules/mongoose/lib/helpers/setDefaultsOnInsert.js\");\n\n/**\n * Given a model and a bulkWrite op, return a thunk that handles casting and\n * validating the individual op.\n * @param {Model} originalModel\n * @param {Object} op\n * @param {Object} [options]\n * @api private\n */\n\nmodule.exports = function castBulkWrite(originalModel, op, options) {\n  const now = originalModel.base.now();\n\n  const globalSetDefaultsOnInsert = originalModel.base.options.setDefaultsOnInsert;\n  if (op['insertOne']) {\n    return (callback) => {\n      const model = decideModelByObject(originalModel, op['insertOne']['document']);\n\n      const doc = new model(op['insertOne']['document']);\n      if (model.schema.options.timestamps && options.timestamps !== false) {\n        doc.initializeTimestamps();\n      }\n      if (options.session != null) {\n        doc.$session(options.session);\n      }\n      const versionKey = model?.schema?.options?.versionKey;\n      if (versionKey && doc[versionKey] == null) {\n        doc[versionKey] = 0;\n      }\n      op['insertOne']['document'] = doc;\n\n      if (options.skipValidation || op['insertOne'].skipValidation) {\n        callback(null);\n        return;\n      }\n\n      op['insertOne']['document'].$validate().then(\n        () => { callback(null); },\n        err => { callback(err, null); }\n      );\n    };\n  } else if (op['updateOne']) {\n    return (callback) => {\n      try {\n        if (!op['updateOne']['filter']) {\n          throw new Error('Must provide a filter object.');\n        }\n        if (!op['updateOne']['update']) {\n          throw new Error('Must provide an update object.');\n        }\n\n        const model = decideModelByObject(originalModel, op['updateOne']['filter']);\n        const schema = model.schema;\n        const strict = options.strict != null ? options.strict : model.schema.options.strict;\n\n        _addDiscriminatorToObject(schema, op['updateOne']['filter']);\n\n        if (model.schema.$timestamps != null && op['updateOne'].timestamps !== false) {\n          const createdAt = model.schema.$timestamps.createdAt;\n          const updatedAt = model.schema.$timestamps.updatedAt;\n          applyTimestampsToUpdate(now, createdAt, updatedAt, op['updateOne']['update'], {});\n        }\n\n        if (op['updateOne'].timestamps !== false) {\n          applyTimestampsToChildren(now, op['updateOne']['update'], model.schema);\n        }\n\n        const shouldSetDefaultsOnInsert = op['updateOne'].setDefaultsOnInsert == null ?\n          globalSetDefaultsOnInsert :\n          op['updateOne'].setDefaultsOnInsert;\n        if (shouldSetDefaultsOnInsert !== false) {\n          setDefaultsOnInsert(op['updateOne']['filter'], model.schema, op['updateOne']['update'], {\n            setDefaultsOnInsert: true,\n            upsert: op['updateOne'].upsert\n          });\n        }\n\n        decorateUpdateWithVersionKey(\n          op['updateOne']['update'],\n          op['updateOne'],\n          model.schema.options.versionKey\n        );\n\n        op['updateOne']['filter'] = cast(model.schema, op['updateOne']['filter'], {\n          strict: strict,\n          upsert: op['updateOne'].upsert\n        });\n\n        op['updateOne']['update'] = castUpdate(model.schema, op['updateOne']['update'], {\n          strict: strict,\n          upsert: op['updateOne'].upsert\n        }, model, op['updateOne']['filter']);\n      } catch (error) {\n        return callback(error, null);\n      }\n\n      callback(null);\n    };\n  } else if (op['updateMany']) {\n    return (callback) => {\n      try {\n        if (!op['updateMany']['filter']) {\n          throw new Error('Must provide a filter object.');\n        }\n        if (!op['updateMany']['update']) {\n          throw new Error('Must provide an update object.');\n        }\n\n        const model = decideModelByObject(originalModel, op['updateMany']['filter']);\n        const schema = model.schema;\n        const strict = options.strict != null ? options.strict : model.schema.options.strict;\n\n        const shouldSetDefaultsOnInsert = op['updateMany'].setDefaultsOnInsert == null ?\n          globalSetDefaultsOnInsert :\n          op['updateMany'].setDefaultsOnInsert;\n\n        if (shouldSetDefaultsOnInsert !== false) {\n          setDefaultsOnInsert(op['updateMany']['filter'], model.schema, op['updateMany']['update'], {\n            setDefaultsOnInsert: true,\n            upsert: op['updateMany'].upsert\n          });\n        }\n\n        if (model.schema.$timestamps != null && op['updateMany'].timestamps !== false) {\n          const createdAt = model.schema.$timestamps.createdAt;\n          const updatedAt = model.schema.$timestamps.updatedAt;\n          applyTimestampsToUpdate(now, createdAt, updatedAt, op['updateMany']['update'], {});\n        }\n        if (op['updateMany'].timestamps !== false) {\n          applyTimestampsToChildren(now, op['updateMany']['update'], model.schema);\n        }\n\n        _addDiscriminatorToObject(schema, op['updateMany']['filter']);\n\n        decorateUpdateWithVersionKey(\n          op['updateMany']['update'],\n          op['updateMany'],\n          model.schema.options.versionKey\n        );\n\n        op['updateMany']['filter'] = cast(model.schema, op['updateMany']['filter'], {\n          strict: strict,\n          upsert: op['updateMany'].upsert\n        });\n\n        op['updateMany']['update'] = castUpdate(model.schema, op['updateMany']['update'], {\n          strict: strict,\n          upsert: op['updateMany'].upsert\n        }, model, op['updateMany']['filter']);\n      } catch (error) {\n        return callback(error, null);\n      }\n\n      callback(null);\n    };\n  } else if (op['replaceOne']) {\n    return (callback) => {\n      const model = decideModelByObject(originalModel, op['replaceOne']['filter']);\n      const schema = model.schema;\n      const strict = options.strict != null ? options.strict : model.schema.options.strict;\n\n      _addDiscriminatorToObject(schema, op['replaceOne']['filter']);\n      try {\n        op['replaceOne']['filter'] = cast(model.schema, op['replaceOne']['filter'], {\n          strict: strict,\n          upsert: op['replaceOne'].upsert\n        });\n      } catch (error) {\n        return callback(error, null);\n      }\n\n      // set `skipId`, otherwise we get \"_id field cannot be changed\"\n      const doc = new model(op['replaceOne']['replacement'], strict, true);\n      if (model.schema.options.timestamps) {\n        doc.initializeTimestamps();\n      }\n      if (options.session != null) {\n        doc.$session(options.session);\n      }\n      const versionKey = model?.schema?.options?.versionKey;\n      if (versionKey && doc[versionKey] == null) {\n        doc[versionKey] = 0;\n      }\n      op['replaceOne']['replacement'] = doc;\n\n      if (options.skipValidation || op['replaceOne'].skipValidation) {\n        op['replaceOne']['replacement'] = op['replaceOne']['replacement'].toBSON();\n        callback(null);\n        return;\n      }\n\n      op['replaceOne']['replacement'].$validate().then(\n        () => {\n          op['replaceOne']['replacement'] = op['replaceOne']['replacement'].toBSON();\n          callback(null);\n        },\n        error => {\n          callback(error, null);\n        }\n      );\n    };\n  } else if (op['deleteOne']) {\n    return (callback) => {\n      const model = decideModelByObject(originalModel, op['deleteOne']['filter']);\n      const schema = model.schema;\n\n      _addDiscriminatorToObject(schema, op['deleteOne']['filter']);\n\n      try {\n        op['deleteOne']['filter'] = cast(model.schema,\n          op['deleteOne']['filter']);\n      } catch (error) {\n        return callback(error, null);\n      }\n\n      callback(null);\n    };\n  } else if (op['deleteMany']) {\n    return (callback) => {\n      const model = decideModelByObject(originalModel, op['deleteMany']['filter']);\n      const schema = model.schema;\n\n      _addDiscriminatorToObject(schema, op['deleteMany']['filter']);\n\n      try {\n        op['deleteMany']['filter'] = cast(model.schema,\n          op['deleteMany']['filter']);\n      } catch (error) {\n        return callback(error, null);\n      }\n\n      callback(null);\n    };\n  } else {\n    return (callback) => {\n      const error = new MongooseError(`Invalid op passed to \\`bulkWrite()\\`: ${inspect(op)}`);\n      callback(error, null);\n    };\n  }\n};\n\nfunction _addDiscriminatorToObject(schema, obj) {\n  if (schema == null) {\n    return;\n  }\n  if (schema.discriminatorMapping && !schema.discriminatorMapping.isRoot) {\n    obj[schema.discriminatorMapping.key] = schema.discriminatorMapping.value;\n  }\n}\n\n/**\n * gets discriminator model if discriminator key is present in object\n * @api private\n */\n\nfunction decideModelByObject(model, object) {\n  const discriminatorKey = model.schema.options.discriminatorKey;\n  if (object != null && object.hasOwnProperty(discriminatorKey)) {\n    model = getDiscriminatorByValue(model.discriminators, object[discriminatorKey]) || model;\n  }\n  return model;\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbW9uZ29vc2UvbGliL2hlbHBlcnMvbW9kZWwvY2FzdEJ1bGtXcml0ZS5qcyIsIm1hcHBpbmdzIjoiQUFBYTs7QUFFYixzQkFBc0IsbUJBQU8sQ0FBQywyRkFBMkI7QUFDekQsZ0NBQWdDLG1CQUFPLENBQUMsK0lBQXFEO0FBQzdGLGtDQUFrQyxtQkFBTyxDQUFDLDBIQUFxQztBQUMvRSxnQ0FBZ0MsbUJBQU8sQ0FBQyxzSEFBbUM7QUFDM0UsYUFBYSxtQkFBTyxDQUFDLDZEQUFZO0FBQ2pDLG1CQUFtQixtQkFBTyxDQUFDLDBGQUFxQjtBQUNoRCxxQ0FBcUMsbUJBQU8sQ0FBQyxnSUFBd0M7QUFDckYsUUFBUSxVQUFVLEVBQUUsbUJBQU8sQ0FBQyxrQkFBTTtBQUNsQyw0QkFBNEIsbUJBQU8sQ0FBQyxnR0FBd0I7O0FBRTVEO0FBQ0E7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQixXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxnQkFBZ0IsaUJBQWlCO0FBQ2pDLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLDBGQUEwRjtBQUMxRjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxRQUFRO0FBQ1I7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDs7QUFFQTtBQUNBO0FBQ0E7QUFDQSwyRkFBMkY7QUFDM0Y7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxRQUFRO0FBQ1I7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsUUFBUTtBQUNSO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsK0VBQStFLFlBQVk7QUFDM0Y7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL2FwcDEvLi9ub2RlX21vZHVsZXMvbW9uZ29vc2UvbGliL2hlbHBlcnMvbW9kZWwvY2FzdEJ1bGtXcml0ZS5qcz85MjI1Il0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxuY29uc3QgTW9uZ29vc2VFcnJvciA9IHJlcXVpcmUoJy4uLy4uL2Vycm9yL21vbmdvb3NlRXJyb3InKTtcbmNvbnN0IGdldERpc2NyaW1pbmF0b3JCeVZhbHVlID0gcmVxdWlyZSgnLi4vLi4vaGVscGVycy9kaXNjcmltaW5hdG9yL2dldERpc2NyaW1pbmF0b3JCeVZhbHVlJyk7XG5jb25zdCBhcHBseVRpbWVzdGFtcHNUb0NoaWxkcmVuID0gcmVxdWlyZSgnLi4vdXBkYXRlL2FwcGx5VGltZXN0YW1wc1RvQ2hpbGRyZW4nKTtcbmNvbnN0IGFwcGx5VGltZXN0YW1wc1RvVXBkYXRlID0gcmVxdWlyZSgnLi4vdXBkYXRlL2FwcGx5VGltZXN0YW1wc1RvVXBkYXRlJyk7XG5jb25zdCBjYXN0ID0gcmVxdWlyZSgnLi4vLi4vY2FzdCcpO1xuY29uc3QgY2FzdFVwZGF0ZSA9IHJlcXVpcmUoJy4uL3F1ZXJ5L2Nhc3RVcGRhdGUnKTtcbmNvbnN0IGRlY29yYXRlVXBkYXRlV2l0aFZlcnNpb25LZXkgPSByZXF1aXJlKCcuLi91cGRhdGUvZGVjb3JhdGVVcGRhdGVXaXRoVmVyc2lvbktleScpO1xuY29uc3QgeyBpbnNwZWN0IH0gPSByZXF1aXJlKCd1dGlsJyk7XG5jb25zdCBzZXREZWZhdWx0c09uSW5zZXJ0ID0gcmVxdWlyZSgnLi4vc2V0RGVmYXVsdHNPbkluc2VydCcpO1xuXG4vKipcbiAqIEdpdmVuIGEgbW9kZWwgYW5kIGEgYnVsa1dyaXRlIG9wLCByZXR1cm4gYSB0aHVuayB0aGF0IGhhbmRsZXMgY2FzdGluZyBhbmRcbiAqIHZhbGlkYXRpbmcgdGhlIGluZGl2aWR1YWwgb3AuXG4gKiBAcGFyYW0ge01vZGVsfSBvcmlnaW5hbE1vZGVsXG4gKiBAcGFyYW0ge09iamVjdH0gb3BcbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc11cbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gY2FzdEJ1bGtXcml0ZShvcmlnaW5hbE1vZGVsLCBvcCwgb3B0aW9ucykge1xuICBjb25zdCBub3cgPSBvcmlnaW5hbE1vZGVsLmJhc2Uubm93KCk7XG5cbiAgY29uc3QgZ2xvYmFsU2V0RGVmYXVsdHNPbkluc2VydCA9IG9yaWdpbmFsTW9kZWwuYmFzZS5vcHRpb25zLnNldERlZmF1bHRzT25JbnNlcnQ7XG4gIGlmIChvcFsnaW5zZXJ0T25lJ10pIHtcbiAgICByZXR1cm4gKGNhbGxiYWNrKSA9PiB7XG4gICAgICBjb25zdCBtb2RlbCA9IGRlY2lkZU1vZGVsQnlPYmplY3Qob3JpZ2luYWxNb2RlbCwgb3BbJ2luc2VydE9uZSddWydkb2N1bWVudCddKTtcblxuICAgICAgY29uc3QgZG9jID0gbmV3IG1vZGVsKG9wWydpbnNlcnRPbmUnXVsnZG9jdW1lbnQnXSk7XG4gICAgICBpZiAobW9kZWwuc2NoZW1hLm9wdGlvbnMudGltZXN0YW1wcyAmJiBvcHRpb25zLnRpbWVzdGFtcHMgIT09IGZhbHNlKSB7XG4gICAgICAgIGRvYy5pbml0aWFsaXplVGltZXN0YW1wcygpO1xuICAgICAgfVxuICAgICAgaWYgKG9wdGlvbnMuc2Vzc2lvbiAhPSBudWxsKSB7XG4gICAgICAgIGRvYy4kc2Vzc2lvbihvcHRpb25zLnNlc3Npb24pO1xuICAgICAgfVxuICAgICAgY29uc3QgdmVyc2lvbktleSA9IG1vZGVsPy5zY2hlbWE/Lm9wdGlvbnM/LnZlcnNpb25LZXk7XG4gICAgICBpZiAodmVyc2lvbktleSAmJiBkb2NbdmVyc2lvbktleV0gPT0gbnVsbCkge1xuICAgICAgICBkb2NbdmVyc2lvbktleV0gPSAwO1xuICAgICAgfVxuICAgICAgb3BbJ2luc2VydE9uZSddWydkb2N1bWVudCddID0gZG9jO1xuXG4gICAgICBpZiAob3B0aW9ucy5za2lwVmFsaWRhdGlvbiB8fCBvcFsnaW5zZXJ0T25lJ10uc2tpcFZhbGlkYXRpb24pIHtcbiAgICAgICAgY2FsbGJhY2sobnVsbCk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgb3BbJ2luc2VydE9uZSddWydkb2N1bWVudCddLiR2YWxpZGF0ZSgpLnRoZW4oXG4gICAgICAgICgpID0+IHsgY2FsbGJhY2sobnVsbCk7IH0sXG4gICAgICAgIGVyciA9PiB7IGNhbGxiYWNrKGVyciwgbnVsbCk7IH1cbiAgICAgICk7XG4gICAgfTtcbiAgfSBlbHNlIGlmIChvcFsndXBkYXRlT25lJ10pIHtcbiAgICByZXR1cm4gKGNhbGxiYWNrKSA9PiB7XG4gICAgICB0cnkge1xuICAgICAgICBpZiAoIW9wWyd1cGRhdGVPbmUnXVsnZmlsdGVyJ10pIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ011c3QgcHJvdmlkZSBhIGZpbHRlciBvYmplY3QuJyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFvcFsndXBkYXRlT25lJ11bJ3VwZGF0ZSddKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdNdXN0IHByb3ZpZGUgYW4gdXBkYXRlIG9iamVjdC4nKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IG1vZGVsID0gZGVjaWRlTW9kZWxCeU9iamVjdChvcmlnaW5hbE1vZGVsLCBvcFsndXBkYXRlT25lJ11bJ2ZpbHRlciddKTtcbiAgICAgICAgY29uc3Qgc2NoZW1hID0gbW9kZWwuc2NoZW1hO1xuICAgICAgICBjb25zdCBzdHJpY3QgPSBvcHRpb25zLnN0cmljdCAhPSBudWxsID8gb3B0aW9ucy5zdHJpY3QgOiBtb2RlbC5zY2hlbWEub3B0aW9ucy5zdHJpY3Q7XG5cbiAgICAgICAgX2FkZERpc2NyaW1pbmF0b3JUb09iamVjdChzY2hlbWEsIG9wWyd1cGRhdGVPbmUnXVsnZmlsdGVyJ10pO1xuXG4gICAgICAgIGlmIChtb2RlbC5zY2hlbWEuJHRpbWVzdGFtcHMgIT0gbnVsbCAmJiBvcFsndXBkYXRlT25lJ10udGltZXN0YW1wcyAhPT0gZmFsc2UpIHtcbiAgICAgICAgICBjb25zdCBjcmVhdGVkQXQgPSBtb2RlbC5zY2hlbWEuJHRpbWVzdGFtcHMuY3JlYXRlZEF0O1xuICAgICAgICAgIGNvbnN0IHVwZGF0ZWRBdCA9IG1vZGVsLnNjaGVtYS4kdGltZXN0YW1wcy51cGRhdGVkQXQ7XG4gICAgICAgICAgYXBwbHlUaW1lc3RhbXBzVG9VcGRhdGUobm93LCBjcmVhdGVkQXQsIHVwZGF0ZWRBdCwgb3BbJ3VwZGF0ZU9uZSddWyd1cGRhdGUnXSwge30pO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKG9wWyd1cGRhdGVPbmUnXS50aW1lc3RhbXBzICE9PSBmYWxzZSkge1xuICAgICAgICAgIGFwcGx5VGltZXN0YW1wc1RvQ2hpbGRyZW4obm93LCBvcFsndXBkYXRlT25lJ11bJ3VwZGF0ZSddLCBtb2RlbC5zY2hlbWEpO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3Qgc2hvdWxkU2V0RGVmYXVsdHNPbkluc2VydCA9IG9wWyd1cGRhdGVPbmUnXS5zZXREZWZhdWx0c09uSW5zZXJ0ID09IG51bGwgP1xuICAgICAgICAgIGdsb2JhbFNldERlZmF1bHRzT25JbnNlcnQgOlxuICAgICAgICAgIG9wWyd1cGRhdGVPbmUnXS5zZXREZWZhdWx0c09uSW5zZXJ0O1xuICAgICAgICBpZiAoc2hvdWxkU2V0RGVmYXVsdHNPbkluc2VydCAhPT0gZmFsc2UpIHtcbiAgICAgICAgICBzZXREZWZhdWx0c09uSW5zZXJ0KG9wWyd1cGRhdGVPbmUnXVsnZmlsdGVyJ10sIG1vZGVsLnNjaGVtYSwgb3BbJ3VwZGF0ZU9uZSddWyd1cGRhdGUnXSwge1xuICAgICAgICAgICAgc2V0RGVmYXVsdHNPbkluc2VydDogdHJ1ZSxcbiAgICAgICAgICAgIHVwc2VydDogb3BbJ3VwZGF0ZU9uZSddLnVwc2VydFxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgZGVjb3JhdGVVcGRhdGVXaXRoVmVyc2lvbktleShcbiAgICAgICAgICBvcFsndXBkYXRlT25lJ11bJ3VwZGF0ZSddLFxuICAgICAgICAgIG9wWyd1cGRhdGVPbmUnXSxcbiAgICAgICAgICBtb2RlbC5zY2hlbWEub3B0aW9ucy52ZXJzaW9uS2V5XG4gICAgICAgICk7XG5cbiAgICAgICAgb3BbJ3VwZGF0ZU9uZSddWydmaWx0ZXInXSA9IGNhc3QobW9kZWwuc2NoZW1hLCBvcFsndXBkYXRlT25lJ11bJ2ZpbHRlciddLCB7XG4gICAgICAgICAgc3RyaWN0OiBzdHJpY3QsXG4gICAgICAgICAgdXBzZXJ0OiBvcFsndXBkYXRlT25lJ10udXBzZXJ0XG4gICAgICAgIH0pO1xuXG4gICAgICAgIG9wWyd1cGRhdGVPbmUnXVsndXBkYXRlJ10gPSBjYXN0VXBkYXRlKG1vZGVsLnNjaGVtYSwgb3BbJ3VwZGF0ZU9uZSddWyd1cGRhdGUnXSwge1xuICAgICAgICAgIHN0cmljdDogc3RyaWN0LFxuICAgICAgICAgIHVwc2VydDogb3BbJ3VwZGF0ZU9uZSddLnVwc2VydFxuICAgICAgICB9LCBtb2RlbCwgb3BbJ3VwZGF0ZU9uZSddWydmaWx0ZXInXSk7XG4gICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICByZXR1cm4gY2FsbGJhY2soZXJyb3IsIG51bGwpO1xuICAgICAgfVxuXG4gICAgICBjYWxsYmFjayhudWxsKTtcbiAgICB9O1xuICB9IGVsc2UgaWYgKG9wWyd1cGRhdGVNYW55J10pIHtcbiAgICByZXR1cm4gKGNhbGxiYWNrKSA9PiB7XG4gICAgICB0cnkge1xuICAgICAgICBpZiAoIW9wWyd1cGRhdGVNYW55J11bJ2ZpbHRlciddKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdNdXN0IHByb3ZpZGUgYSBmaWx0ZXIgb2JqZWN0LicpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghb3BbJ3VwZGF0ZU1hbnknXVsndXBkYXRlJ10pIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ011c3QgcHJvdmlkZSBhbiB1cGRhdGUgb2JqZWN0LicpO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgbW9kZWwgPSBkZWNpZGVNb2RlbEJ5T2JqZWN0KG9yaWdpbmFsTW9kZWwsIG9wWyd1cGRhdGVNYW55J11bJ2ZpbHRlciddKTtcbiAgICAgICAgY29uc3Qgc2NoZW1hID0gbW9kZWwuc2NoZW1hO1xuICAgICAgICBjb25zdCBzdHJpY3QgPSBvcHRpb25zLnN0cmljdCAhPSBudWxsID8gb3B0aW9ucy5zdHJpY3QgOiBtb2RlbC5zY2hlbWEub3B0aW9ucy5zdHJpY3Q7XG5cbiAgICAgICAgY29uc3Qgc2hvdWxkU2V0RGVmYXVsdHNPbkluc2VydCA9IG9wWyd1cGRhdGVNYW55J10uc2V0RGVmYXVsdHNPbkluc2VydCA9PSBudWxsID9cbiAgICAgICAgICBnbG9iYWxTZXREZWZhdWx0c09uSW5zZXJ0IDpcbiAgICAgICAgICBvcFsndXBkYXRlTWFueSddLnNldERlZmF1bHRzT25JbnNlcnQ7XG5cbiAgICAgICAgaWYgKHNob3VsZFNldERlZmF1bHRzT25JbnNlcnQgIT09IGZhbHNlKSB7XG4gICAgICAgICAgc2V0RGVmYXVsdHNPbkluc2VydChvcFsndXBkYXRlTWFueSddWydmaWx0ZXInXSwgbW9kZWwuc2NoZW1hLCBvcFsndXBkYXRlTWFueSddWyd1cGRhdGUnXSwge1xuICAgICAgICAgICAgc2V0RGVmYXVsdHNPbkluc2VydDogdHJ1ZSxcbiAgICAgICAgICAgIHVwc2VydDogb3BbJ3VwZGF0ZU1hbnknXS51cHNlcnRcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChtb2RlbC5zY2hlbWEuJHRpbWVzdGFtcHMgIT0gbnVsbCAmJiBvcFsndXBkYXRlTWFueSddLnRpbWVzdGFtcHMgIT09IGZhbHNlKSB7XG4gICAgICAgICAgY29uc3QgY3JlYXRlZEF0ID0gbW9kZWwuc2NoZW1hLiR0aW1lc3RhbXBzLmNyZWF0ZWRBdDtcbiAgICAgICAgICBjb25zdCB1cGRhdGVkQXQgPSBtb2RlbC5zY2hlbWEuJHRpbWVzdGFtcHMudXBkYXRlZEF0O1xuICAgICAgICAgIGFwcGx5VGltZXN0YW1wc1RvVXBkYXRlKG5vdywgY3JlYXRlZEF0LCB1cGRhdGVkQXQsIG9wWyd1cGRhdGVNYW55J11bJ3VwZGF0ZSddLCB7fSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG9wWyd1cGRhdGVNYW55J10udGltZXN0YW1wcyAhPT0gZmFsc2UpIHtcbiAgICAgICAgICBhcHBseVRpbWVzdGFtcHNUb0NoaWxkcmVuKG5vdywgb3BbJ3VwZGF0ZU1hbnknXVsndXBkYXRlJ10sIG1vZGVsLnNjaGVtYSk7XG4gICAgICAgIH1cblxuICAgICAgICBfYWRkRGlzY3JpbWluYXRvclRvT2JqZWN0KHNjaGVtYSwgb3BbJ3VwZGF0ZU1hbnknXVsnZmlsdGVyJ10pO1xuXG4gICAgICAgIGRlY29yYXRlVXBkYXRlV2l0aFZlcnNpb25LZXkoXG4gICAgICAgICAgb3BbJ3VwZGF0ZU1hbnknXVsndXBkYXRlJ10sXG4gICAgICAgICAgb3BbJ3VwZGF0ZU1hbnknXSxcbiAgICAgICAgICBtb2RlbC5zY2hlbWEub3B0aW9ucy52ZXJzaW9uS2V5XG4gICAgICAgICk7XG5cbiAgICAgICAgb3BbJ3VwZGF0ZU1hbnknXVsnZmlsdGVyJ10gPSBjYXN0KG1vZGVsLnNjaGVtYSwgb3BbJ3VwZGF0ZU1hbnknXVsnZmlsdGVyJ10sIHtcbiAgICAgICAgICBzdHJpY3Q6IHN0cmljdCxcbiAgICAgICAgICB1cHNlcnQ6IG9wWyd1cGRhdGVNYW55J10udXBzZXJ0XG4gICAgICAgIH0pO1xuXG4gICAgICAgIG9wWyd1cGRhdGVNYW55J11bJ3VwZGF0ZSddID0gY2FzdFVwZGF0ZShtb2RlbC5zY2hlbWEsIG9wWyd1cGRhdGVNYW55J11bJ3VwZGF0ZSddLCB7XG4gICAgICAgICAgc3RyaWN0OiBzdHJpY3QsXG4gICAgICAgICAgdXBzZXJ0OiBvcFsndXBkYXRlTWFueSddLnVwc2VydFxuICAgICAgICB9LCBtb2RlbCwgb3BbJ3VwZGF0ZU1hbnknXVsnZmlsdGVyJ10pO1xuICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgcmV0dXJuIGNhbGxiYWNrKGVycm9yLCBudWxsKTtcbiAgICAgIH1cblxuICAgICAgY2FsbGJhY2sobnVsbCk7XG4gICAgfTtcbiAgfSBlbHNlIGlmIChvcFsncmVwbGFjZU9uZSddKSB7XG4gICAgcmV0dXJuIChjYWxsYmFjaykgPT4ge1xuICAgICAgY29uc3QgbW9kZWwgPSBkZWNpZGVNb2RlbEJ5T2JqZWN0KG9yaWdpbmFsTW9kZWwsIG9wWydyZXBsYWNlT25lJ11bJ2ZpbHRlciddKTtcbiAgICAgIGNvbnN0IHNjaGVtYSA9IG1vZGVsLnNjaGVtYTtcbiAgICAgIGNvbnN0IHN0cmljdCA9IG9wdGlvbnMuc3RyaWN0ICE9IG51bGwgPyBvcHRpb25zLnN0cmljdCA6IG1vZGVsLnNjaGVtYS5vcHRpb25zLnN0cmljdDtcblxuICAgICAgX2FkZERpc2NyaW1pbmF0b3JUb09iamVjdChzY2hlbWEsIG9wWydyZXBsYWNlT25lJ11bJ2ZpbHRlciddKTtcbiAgICAgIHRyeSB7XG4gICAgICAgIG9wWydyZXBsYWNlT25lJ11bJ2ZpbHRlciddID0gY2FzdChtb2RlbC5zY2hlbWEsIG9wWydyZXBsYWNlT25lJ11bJ2ZpbHRlciddLCB7XG4gICAgICAgICAgc3RyaWN0OiBzdHJpY3QsXG4gICAgICAgICAgdXBzZXJ0OiBvcFsncmVwbGFjZU9uZSddLnVwc2VydFxuICAgICAgICB9KTtcbiAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIHJldHVybiBjYWxsYmFjayhlcnJvciwgbnVsbCk7XG4gICAgICB9XG5cbiAgICAgIC8vIHNldCBgc2tpcElkYCwgb3RoZXJ3aXNlIHdlIGdldCBcIl9pZCBmaWVsZCBjYW5ub3QgYmUgY2hhbmdlZFwiXG4gICAgICBjb25zdCBkb2MgPSBuZXcgbW9kZWwob3BbJ3JlcGxhY2VPbmUnXVsncmVwbGFjZW1lbnQnXSwgc3RyaWN0LCB0cnVlKTtcbiAgICAgIGlmIChtb2RlbC5zY2hlbWEub3B0aW9ucy50aW1lc3RhbXBzKSB7XG4gICAgICAgIGRvYy5pbml0aWFsaXplVGltZXN0YW1wcygpO1xuICAgICAgfVxuICAgICAgaWYgKG9wdGlvbnMuc2Vzc2lvbiAhPSBudWxsKSB7XG4gICAgICAgIGRvYy4kc2Vzc2lvbihvcHRpb25zLnNlc3Npb24pO1xuICAgICAgfVxuICAgICAgY29uc3QgdmVyc2lvbktleSA9IG1vZGVsPy5zY2hlbWE/Lm9wdGlvbnM/LnZlcnNpb25LZXk7XG4gICAgICBpZiAodmVyc2lvbktleSAmJiBkb2NbdmVyc2lvbktleV0gPT0gbnVsbCkge1xuICAgICAgICBkb2NbdmVyc2lvbktleV0gPSAwO1xuICAgICAgfVxuICAgICAgb3BbJ3JlcGxhY2VPbmUnXVsncmVwbGFjZW1lbnQnXSA9IGRvYztcblxuICAgICAgaWYgKG9wdGlvbnMuc2tpcFZhbGlkYXRpb24gfHwgb3BbJ3JlcGxhY2VPbmUnXS5za2lwVmFsaWRhdGlvbikge1xuICAgICAgICBvcFsncmVwbGFjZU9uZSddWydyZXBsYWNlbWVudCddID0gb3BbJ3JlcGxhY2VPbmUnXVsncmVwbGFjZW1lbnQnXS50b0JTT04oKTtcbiAgICAgICAgY2FsbGJhY2sobnVsbCk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgb3BbJ3JlcGxhY2VPbmUnXVsncmVwbGFjZW1lbnQnXS4kdmFsaWRhdGUoKS50aGVuKFxuICAgICAgICAoKSA9PiB7XG4gICAgICAgICAgb3BbJ3JlcGxhY2VPbmUnXVsncmVwbGFjZW1lbnQnXSA9IG9wWydyZXBsYWNlT25lJ11bJ3JlcGxhY2VtZW50J10udG9CU09OKCk7XG4gICAgICAgICAgY2FsbGJhY2sobnVsbCk7XG4gICAgICAgIH0sXG4gICAgICAgIGVycm9yID0+IHtcbiAgICAgICAgICBjYWxsYmFjayhlcnJvciwgbnVsbCk7XG4gICAgICAgIH1cbiAgICAgICk7XG4gICAgfTtcbiAgfSBlbHNlIGlmIChvcFsnZGVsZXRlT25lJ10pIHtcbiAgICByZXR1cm4gKGNhbGxiYWNrKSA9PiB7XG4gICAgICBjb25zdCBtb2RlbCA9IGRlY2lkZU1vZGVsQnlPYmplY3Qob3JpZ2luYWxNb2RlbCwgb3BbJ2RlbGV0ZU9uZSddWydmaWx0ZXInXSk7XG4gICAgICBjb25zdCBzY2hlbWEgPSBtb2RlbC5zY2hlbWE7XG5cbiAgICAgIF9hZGREaXNjcmltaW5hdG9yVG9PYmplY3Qoc2NoZW1hLCBvcFsnZGVsZXRlT25lJ11bJ2ZpbHRlciddKTtcblxuICAgICAgdHJ5IHtcbiAgICAgICAgb3BbJ2RlbGV0ZU9uZSddWydmaWx0ZXInXSA9IGNhc3QobW9kZWwuc2NoZW1hLFxuICAgICAgICAgIG9wWydkZWxldGVPbmUnXVsnZmlsdGVyJ10pO1xuICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgcmV0dXJuIGNhbGxiYWNrKGVycm9yLCBudWxsKTtcbiAgICAgIH1cblxuICAgICAgY2FsbGJhY2sobnVsbCk7XG4gICAgfTtcbiAgfSBlbHNlIGlmIChvcFsnZGVsZXRlTWFueSddKSB7XG4gICAgcmV0dXJuIChjYWxsYmFjaykgPT4ge1xuICAgICAgY29uc3QgbW9kZWwgPSBkZWNpZGVNb2RlbEJ5T2JqZWN0KG9yaWdpbmFsTW9kZWwsIG9wWydkZWxldGVNYW55J11bJ2ZpbHRlciddKTtcbiAgICAgIGNvbnN0IHNjaGVtYSA9IG1vZGVsLnNjaGVtYTtcblxuICAgICAgX2FkZERpc2NyaW1pbmF0b3JUb09iamVjdChzY2hlbWEsIG9wWydkZWxldGVNYW55J11bJ2ZpbHRlciddKTtcblxuICAgICAgdHJ5IHtcbiAgICAgICAgb3BbJ2RlbGV0ZU1hbnknXVsnZmlsdGVyJ10gPSBjYXN0KG1vZGVsLnNjaGVtYSxcbiAgICAgICAgICBvcFsnZGVsZXRlTWFueSddWydmaWx0ZXInXSk7XG4gICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICByZXR1cm4gY2FsbGJhY2soZXJyb3IsIG51bGwpO1xuICAgICAgfVxuXG4gICAgICBjYWxsYmFjayhudWxsKTtcbiAgICB9O1xuICB9IGVsc2Uge1xuICAgIHJldHVybiAoY2FsbGJhY2spID0+IHtcbiAgICAgIGNvbnN0IGVycm9yID0gbmV3IE1vbmdvb3NlRXJyb3IoYEludmFsaWQgb3AgcGFzc2VkIHRvIFxcYGJ1bGtXcml0ZSgpXFxgOiAke2luc3BlY3Qob3ApfWApO1xuICAgICAgY2FsbGJhY2soZXJyb3IsIG51bGwpO1xuICAgIH07XG4gIH1cbn07XG5cbmZ1bmN0aW9uIF9hZGREaXNjcmltaW5hdG9yVG9PYmplY3Qoc2NoZW1hLCBvYmopIHtcbiAgaWYgKHNjaGVtYSA9PSBudWxsKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGlmIChzY2hlbWEuZGlzY3JpbWluYXRvck1hcHBpbmcgJiYgIXNjaGVtYS5kaXNjcmltaW5hdG9yTWFwcGluZy5pc1Jvb3QpIHtcbiAgICBvYmpbc2NoZW1hLmRpc2NyaW1pbmF0b3JNYXBwaW5nLmtleV0gPSBzY2hlbWEuZGlzY3JpbWluYXRvck1hcHBpbmcudmFsdWU7XG4gIH1cbn1cblxuLyoqXG4gKiBnZXRzIGRpc2NyaW1pbmF0b3IgbW9kZWwgaWYgZGlzY3JpbWluYXRvciBrZXkgaXMgcHJlc2VudCBpbiBvYmplY3RcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmZ1bmN0aW9uIGRlY2lkZU1vZGVsQnlPYmplY3QobW9kZWwsIG9iamVjdCkge1xuICBjb25zdCBkaXNjcmltaW5hdG9yS2V5ID0gbW9kZWwuc2NoZW1hLm9wdGlvbnMuZGlzY3JpbWluYXRvcktleTtcbiAgaWYgKG9iamVjdCAhPSBudWxsICYmIG9iamVjdC5oYXNPd25Qcm9wZXJ0eShkaXNjcmltaW5hdG9yS2V5KSkge1xuICAgIG1vZGVsID0gZ2V0RGlzY3JpbWluYXRvckJ5VmFsdWUobW9kZWwuZGlzY3JpbWluYXRvcnMsIG9iamVjdFtkaXNjcmltaW5hdG9yS2V5XSkgfHwgbW9kZWw7XG4gIH1cbiAgcmV0dXJuIG1vZGVsO1xufVxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/mongoose/lib/helpers/model/castBulkWrite.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/mongoose/lib/helpers/model/discriminator.js":
/*!******************************************************************!*\
  !*** ./node_modules/mongoose/lib/helpers/model/discriminator.js ***!
  \******************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\n\nconst Mixed = __webpack_require__(/*! ../../schema/mixed */ \"(ssr)/./node_modules/mongoose/lib/schema/mixed.js\");\nconst applyBuiltinPlugins = __webpack_require__(/*! ../schema/applyBuiltinPlugins */ \"(ssr)/./node_modules/mongoose/lib/helpers/schema/applyBuiltinPlugins.js\");\nconst clone = __webpack_require__(/*! ../clone */ \"(ssr)/./node_modules/mongoose/lib/helpers/clone.js\");\nconst defineKey = (__webpack_require__(/*! ../document/compile */ \"(ssr)/./node_modules/mongoose/lib/helpers/document/compile.js\").defineKey);\nconst get = __webpack_require__(/*! ../get */ \"(ssr)/./node_modules/mongoose/lib/helpers/get.js\");\nconst utils = __webpack_require__(/*! ../../utils */ \"(ssr)/./node_modules/mongoose/lib/utils.js\");\nconst mergeDiscriminatorSchema = __webpack_require__(/*! ../../helpers/discriminator/mergeDiscriminatorSchema */ \"(ssr)/./node_modules/mongoose/lib/helpers/discriminator/mergeDiscriminatorSchema.js\");\n\nconst CUSTOMIZABLE_DISCRIMINATOR_OPTIONS = {\n  toJSON: true,\n  toObject: true,\n  _id: true,\n  id: true,\n  virtuals: true,\n  methods: true\n};\n\n/*!\n * ignore\n */\n\nmodule.exports = function discriminator(model, name, schema, tiedValue, applyPlugins, mergeHooks) {\n  if (!(schema && schema.instanceOfSchema)) {\n    throw new Error('You must pass a valid discriminator Schema');\n  }\n\n  mergeHooks = mergeHooks == null ? true : mergeHooks;\n\n  if (model.schema.discriminatorMapping &&\n      !model.schema.discriminatorMapping.isRoot) {\n    throw new Error('Discriminator \"' + name +\n        '\" can only be a discriminator of the root model');\n  }\n\n  if (applyPlugins) {\n    const applyPluginsToDiscriminators = get(model.base,\n      'options.applyPluginsToDiscriminators', false) || !mergeHooks;\n    // Even if `applyPluginsToDiscriminators` isn't set, we should still apply\n    // global plugins to schemas embedded in the discriminator schema (gh-7370)\n    model.base._applyPlugins(schema, {\n      skipTopLevel: !applyPluginsToDiscriminators\n    });\n  } else if (!mergeHooks) {\n    applyBuiltinPlugins(schema);\n  }\n\n  const key = model.schema.options.discriminatorKey;\n\n  const existingPath = model.schema.path(key);\n  if (existingPath != null) {\n    if (!utils.hasUserDefinedProperty(existingPath.options, 'select')) {\n      existingPath.options.select = true;\n    }\n    existingPath.options.$skipDiscriminatorCheck = true;\n  } else {\n    const baseSchemaAddition = {};\n    baseSchemaAddition[key] = {\n      default: void 0,\n      select: true,\n      $skipDiscriminatorCheck: true\n    };\n    baseSchemaAddition[key][model.schema.options.typeKey] = String;\n    model.schema.add(baseSchemaAddition);\n    defineKey({\n      prop: key,\n      prototype: model.prototype,\n      options: model.schema.options\n    });\n  }\n\n  if (schema.path(key) && schema.path(key).options.$skipDiscriminatorCheck !== true) {\n    throw new Error('Discriminator \"' + name +\n        '\" cannot have field with name \"' + key + '\"');\n  }\n\n  let value = name;\n  if ((typeof tiedValue === 'string' && tiedValue.length) || tiedValue != null) {\n    value = tiedValue;\n  }\n\n  function merge(schema, baseSchema) {\n    // Retain original schema before merging base schema\n    schema._baseSchema = baseSchema;\n    if (baseSchema.paths._id &&\n        baseSchema.paths._id.options &&\n        !baseSchema.paths._id.options.auto) {\n      schema.remove('_id');\n    }\n\n    // Find conflicting paths: if something is a path in the base schema\n    // and a nested path in the child schema, overwrite the base schema path.\n    // See gh-6076\n    const baseSchemaPaths = Object.keys(baseSchema.paths);\n    const conflictingPaths = [];\n\n    for (const path of baseSchemaPaths) {\n      if (schema.nested[path]) {\n        conflictingPaths.push(path);\n        continue;\n      }\n\n      if (path.indexOf('.') === -1) {\n        continue;\n      }\n      const sp = path.split('.').slice(0, -1);\n      let cur = '';\n      for (const piece of sp) {\n        cur += (cur.length ? '.' : '') + piece;\n        if (schema.paths[cur] instanceof Mixed ||\n            schema.singleNestedPaths[cur] instanceof Mixed) {\n          conflictingPaths.push(path);\n        }\n      }\n    }\n\n    mergeDiscriminatorSchema(schema, baseSchema);\n\n    // Clean up conflicting paths _after_ merging re: gh-6076\n    for (const conflictingPath of conflictingPaths) {\n      delete schema.paths[conflictingPath];\n    }\n\n    // Rebuild schema models because schemas may have been merged re: #7884\n    schema.childSchemas.forEach(obj => {\n      obj.model.prototype.$__setSchema(obj.schema);\n    });\n\n    const obj = {};\n    obj[key] = {\n      default: value,\n      select: true,\n      set: function(newName) {\n        if (newName === value || (Array.isArray(value) && utils.deepEqual(newName, value))) {\n          return value;\n        }\n        throw new Error('Can\\'t set discriminator key \"' + key + '\"');\n      },\n      $skipDiscriminatorCheck: true\n    };\n    obj[key][schema.options.typeKey] = existingPath ? existingPath.options[schema.options.typeKey] : String;\n    schema.add(obj);\n\n    schema.discriminatorMapping = { key: key, value: value, isRoot: false };\n\n    if (baseSchema.options.collection) {\n      schema.options.collection = baseSchema.options.collection;\n    }\n    const toJSON = schema.options.toJSON;\n    const toObject = schema.options.toObject;\n    const _id = schema.options._id;\n    const id = schema.options.id;\n\n    const keys = Object.keys(schema.options);\n    schema.options.discriminatorKey = baseSchema.options.discriminatorKey;\n    const userProvidedOptions = schema._userProvidedOptions;\n    for (const _key of keys) {\n      if (!CUSTOMIZABLE_DISCRIMINATOR_OPTIONS[_key]) {\n        // Use `schema.options` in `deepEqual()` because of `discriminatorKey`\n        // set above. We don't allow customizing discriminator key, always\n        // overwrite. See gh-9238\n        if (_key in userProvidedOptions && !utils.deepEqual(schema.options[_key], baseSchema.options[_key])) {\n          throw new Error('Can\\'t customize discriminator option ' + _key +\n            ' (can only modify ' +\n            Object.keys(CUSTOMIZABLE_DISCRIMINATOR_OPTIONS).join(', ') +\n            ')');\n        }\n      }\n    }\n    schema.options = clone(baseSchema.options);\n\n    for (const _key of Object.keys(userProvidedOptions)) {\n      schema.options[_key] = userProvidedOptions[_key];\n    }\n    if (toJSON) schema.options.toJSON = toJSON;\n    if (toObject) schema.options.toObject = toObject;\n    if (typeof _id !== 'undefined') {\n      schema.options._id = _id;\n    }\n    schema.options.id = id;\n    if (mergeHooks) {\n      schema.s.hooks = model.schema.s.hooks.merge(schema.s.hooks);\n    }\n    if (applyPlugins) {\n      schema.plugins = Array.prototype.slice.call(baseSchema.plugins);\n    }\n    schema.callQueue = baseSchema.callQueue.concat(schema.callQueue);\n    delete schema._requiredpaths; // reset just in case Schema#requiredPaths() was called on either schema\n  }\n\n  // merges base schema into new discriminator schema and sets new type field.\n  merge(schema, model.schema);\n\n  if (!model.discriminators) {\n    model.discriminators = {};\n  }\n\n  if (!model.schema.discriminatorMapping) {\n    model.schema.discriminatorMapping = { key: key, value: null, isRoot: true };\n  }\n  if (!model.schema.discriminators) {\n    model.schema.discriminators = {};\n  }\n\n  model.schema.discriminators[name] = schema;\n\n  if (model.discriminators[name] && !schema.options.overwriteModels) {\n    throw new Error('Discriminator with name \"' + name + '\" already exists');\n  }\n\n  return schema;\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbW9uZ29vc2UvbGliL2hlbHBlcnMvbW9kZWwvZGlzY3JpbWluYXRvci5qcyIsIm1hcHBpbmdzIjoiQUFBYTs7QUFFYixjQUFjLG1CQUFPLENBQUMsNkVBQW9CO0FBQzFDLDRCQUE0QixtQkFBTyxDQUFDLDhHQUErQjtBQUNuRSxjQUFjLG1CQUFPLENBQUMsb0VBQVU7QUFDaEMsa0JBQWtCLDJIQUF3QztBQUMxRCxZQUFZLG1CQUFPLENBQUMsZ0VBQVE7QUFDNUIsY0FBYyxtQkFBTyxDQUFDLCtEQUFhO0FBQ25DLGlDQUFpQyxtQkFBTyxDQUFDLGlKQUFzRDs7QUFFL0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxJQUFJO0FBQ0o7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBOztBQUVBLG9DQUFvQzs7QUFFcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQztBQUNsQzs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDBDQUEwQztBQUMxQztBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL2FwcDEvLi9ub2RlX21vZHVsZXMvbW9uZ29vc2UvbGliL2hlbHBlcnMvbW9kZWwvZGlzY3JpbWluYXRvci5qcz8xOGZmIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxuY29uc3QgTWl4ZWQgPSByZXF1aXJlKCcuLi8uLi9zY2hlbWEvbWl4ZWQnKTtcbmNvbnN0IGFwcGx5QnVpbHRpblBsdWdpbnMgPSByZXF1aXJlKCcuLi9zY2hlbWEvYXBwbHlCdWlsdGluUGx1Z2lucycpO1xuY29uc3QgY2xvbmUgPSByZXF1aXJlKCcuLi9jbG9uZScpO1xuY29uc3QgZGVmaW5lS2V5ID0gcmVxdWlyZSgnLi4vZG9jdW1lbnQvY29tcGlsZScpLmRlZmluZUtleTtcbmNvbnN0IGdldCA9IHJlcXVpcmUoJy4uL2dldCcpO1xuY29uc3QgdXRpbHMgPSByZXF1aXJlKCcuLi8uLi91dGlscycpO1xuY29uc3QgbWVyZ2VEaXNjcmltaW5hdG9yU2NoZW1hID0gcmVxdWlyZSgnLi4vLi4vaGVscGVycy9kaXNjcmltaW5hdG9yL21lcmdlRGlzY3JpbWluYXRvclNjaGVtYScpO1xuXG5jb25zdCBDVVNUT01JWkFCTEVfRElTQ1JJTUlOQVRPUl9PUFRJT05TID0ge1xuICB0b0pTT046IHRydWUsXG4gIHRvT2JqZWN0OiB0cnVlLFxuICBfaWQ6IHRydWUsXG4gIGlkOiB0cnVlLFxuICB2aXJ0dWFsczogdHJ1ZSxcbiAgbWV0aG9kczogdHJ1ZVxufTtcblxuLyohXG4gKiBpZ25vcmVcbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGRpc2NyaW1pbmF0b3IobW9kZWwsIG5hbWUsIHNjaGVtYSwgdGllZFZhbHVlLCBhcHBseVBsdWdpbnMsIG1lcmdlSG9va3MpIHtcbiAgaWYgKCEoc2NoZW1hICYmIHNjaGVtYS5pbnN0YW5jZU9mU2NoZW1hKSkge1xuICAgIHRocm93IG5ldyBFcnJvcignWW91IG11c3QgcGFzcyBhIHZhbGlkIGRpc2NyaW1pbmF0b3IgU2NoZW1hJyk7XG4gIH1cblxuICBtZXJnZUhvb2tzID0gbWVyZ2VIb29rcyA9PSBudWxsID8gdHJ1ZSA6IG1lcmdlSG9va3M7XG5cbiAgaWYgKG1vZGVsLnNjaGVtYS5kaXNjcmltaW5hdG9yTWFwcGluZyAmJlxuICAgICAgIW1vZGVsLnNjaGVtYS5kaXNjcmltaW5hdG9yTWFwcGluZy5pc1Jvb3QpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0Rpc2NyaW1pbmF0b3IgXCInICsgbmFtZSArXG4gICAgICAgICdcIiBjYW4gb25seSBiZSBhIGRpc2NyaW1pbmF0b3Igb2YgdGhlIHJvb3QgbW9kZWwnKTtcbiAgfVxuXG4gIGlmIChhcHBseVBsdWdpbnMpIHtcbiAgICBjb25zdCBhcHBseVBsdWdpbnNUb0Rpc2NyaW1pbmF0b3JzID0gZ2V0KG1vZGVsLmJhc2UsXG4gICAgICAnb3B0aW9ucy5hcHBseVBsdWdpbnNUb0Rpc2NyaW1pbmF0b3JzJywgZmFsc2UpIHx8ICFtZXJnZUhvb2tzO1xuICAgIC8vIEV2ZW4gaWYgYGFwcGx5UGx1Z2luc1RvRGlzY3JpbWluYXRvcnNgIGlzbid0IHNldCwgd2Ugc2hvdWxkIHN0aWxsIGFwcGx5XG4gICAgLy8gZ2xvYmFsIHBsdWdpbnMgdG8gc2NoZW1hcyBlbWJlZGRlZCBpbiB0aGUgZGlzY3JpbWluYXRvciBzY2hlbWEgKGdoLTczNzApXG4gICAgbW9kZWwuYmFzZS5fYXBwbHlQbHVnaW5zKHNjaGVtYSwge1xuICAgICAgc2tpcFRvcExldmVsOiAhYXBwbHlQbHVnaW5zVG9EaXNjcmltaW5hdG9yc1xuICAgIH0pO1xuICB9IGVsc2UgaWYgKCFtZXJnZUhvb2tzKSB7XG4gICAgYXBwbHlCdWlsdGluUGx1Z2lucyhzY2hlbWEpO1xuICB9XG5cbiAgY29uc3Qga2V5ID0gbW9kZWwuc2NoZW1hLm9wdGlvbnMuZGlzY3JpbWluYXRvcktleTtcblxuICBjb25zdCBleGlzdGluZ1BhdGggPSBtb2RlbC5zY2hlbWEucGF0aChrZXkpO1xuICBpZiAoZXhpc3RpbmdQYXRoICE9IG51bGwpIHtcbiAgICBpZiAoIXV0aWxzLmhhc1VzZXJEZWZpbmVkUHJvcGVydHkoZXhpc3RpbmdQYXRoLm9wdGlvbnMsICdzZWxlY3QnKSkge1xuICAgICAgZXhpc3RpbmdQYXRoLm9wdGlvbnMuc2VsZWN0ID0gdHJ1ZTtcbiAgICB9XG4gICAgZXhpc3RpbmdQYXRoLm9wdGlvbnMuJHNraXBEaXNjcmltaW5hdG9yQ2hlY2sgPSB0cnVlO1xuICB9IGVsc2Uge1xuICAgIGNvbnN0IGJhc2VTY2hlbWFBZGRpdGlvbiA9IHt9O1xuICAgIGJhc2VTY2hlbWFBZGRpdGlvbltrZXldID0ge1xuICAgICAgZGVmYXVsdDogdm9pZCAwLFxuICAgICAgc2VsZWN0OiB0cnVlLFxuICAgICAgJHNraXBEaXNjcmltaW5hdG9yQ2hlY2s6IHRydWVcbiAgICB9O1xuICAgIGJhc2VTY2hlbWFBZGRpdGlvbltrZXldW21vZGVsLnNjaGVtYS5vcHRpb25zLnR5cGVLZXldID0gU3RyaW5nO1xuICAgIG1vZGVsLnNjaGVtYS5hZGQoYmFzZVNjaGVtYUFkZGl0aW9uKTtcbiAgICBkZWZpbmVLZXkoe1xuICAgICAgcHJvcDoga2V5LFxuICAgICAgcHJvdG90eXBlOiBtb2RlbC5wcm90b3R5cGUsXG4gICAgICBvcHRpb25zOiBtb2RlbC5zY2hlbWEub3B0aW9uc1xuICAgIH0pO1xuICB9XG5cbiAgaWYgKHNjaGVtYS5wYXRoKGtleSkgJiYgc2NoZW1hLnBhdGgoa2V5KS5vcHRpb25zLiRza2lwRGlzY3JpbWluYXRvckNoZWNrICE9PSB0cnVlKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdEaXNjcmltaW5hdG9yIFwiJyArIG5hbWUgK1xuICAgICAgICAnXCIgY2Fubm90IGhhdmUgZmllbGQgd2l0aCBuYW1lIFwiJyArIGtleSArICdcIicpO1xuICB9XG5cbiAgbGV0IHZhbHVlID0gbmFtZTtcbiAgaWYgKCh0eXBlb2YgdGllZFZhbHVlID09PSAnc3RyaW5nJyAmJiB0aWVkVmFsdWUubGVuZ3RoKSB8fCB0aWVkVmFsdWUgIT0gbnVsbCkge1xuICAgIHZhbHVlID0gdGllZFZhbHVlO1xuICB9XG5cbiAgZnVuY3Rpb24gbWVyZ2Uoc2NoZW1hLCBiYXNlU2NoZW1hKSB7XG4gICAgLy8gUmV0YWluIG9yaWdpbmFsIHNjaGVtYSBiZWZvcmUgbWVyZ2luZyBiYXNlIHNjaGVtYVxuICAgIHNjaGVtYS5fYmFzZVNjaGVtYSA9IGJhc2VTY2hlbWE7XG4gICAgaWYgKGJhc2VTY2hlbWEucGF0aHMuX2lkICYmXG4gICAgICAgIGJhc2VTY2hlbWEucGF0aHMuX2lkLm9wdGlvbnMgJiZcbiAgICAgICAgIWJhc2VTY2hlbWEucGF0aHMuX2lkLm9wdGlvbnMuYXV0bykge1xuICAgICAgc2NoZW1hLnJlbW92ZSgnX2lkJyk7XG4gICAgfVxuXG4gICAgLy8gRmluZCBjb25mbGljdGluZyBwYXRoczogaWYgc29tZXRoaW5nIGlzIGEgcGF0aCBpbiB0aGUgYmFzZSBzY2hlbWFcbiAgICAvLyBhbmQgYSBuZXN0ZWQgcGF0aCBpbiB0aGUgY2hpbGQgc2NoZW1hLCBvdmVyd3JpdGUgdGhlIGJhc2Ugc2NoZW1hIHBhdGguXG4gICAgLy8gU2VlIGdoLTYwNzZcbiAgICBjb25zdCBiYXNlU2NoZW1hUGF0aHMgPSBPYmplY3Qua2V5cyhiYXNlU2NoZW1hLnBhdGhzKTtcbiAgICBjb25zdCBjb25mbGljdGluZ1BhdGhzID0gW107XG5cbiAgICBmb3IgKGNvbnN0IHBhdGggb2YgYmFzZVNjaGVtYVBhdGhzKSB7XG4gICAgICBpZiAoc2NoZW1hLm5lc3RlZFtwYXRoXSkge1xuICAgICAgICBjb25mbGljdGluZ1BhdGhzLnB1c2gocGF0aCk7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuXG4gICAgICBpZiAocGF0aC5pbmRleE9mKCcuJykgPT09IC0xKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgY29uc3Qgc3AgPSBwYXRoLnNwbGl0KCcuJykuc2xpY2UoMCwgLTEpO1xuICAgICAgbGV0IGN1ciA9ICcnO1xuICAgICAgZm9yIChjb25zdCBwaWVjZSBvZiBzcCkge1xuICAgICAgICBjdXIgKz0gKGN1ci5sZW5ndGggPyAnLicgOiAnJykgKyBwaWVjZTtcbiAgICAgICAgaWYgKHNjaGVtYS5wYXRoc1tjdXJdIGluc3RhbmNlb2YgTWl4ZWQgfHxcbiAgICAgICAgICAgIHNjaGVtYS5zaW5nbGVOZXN0ZWRQYXRoc1tjdXJdIGluc3RhbmNlb2YgTWl4ZWQpIHtcbiAgICAgICAgICBjb25mbGljdGluZ1BhdGhzLnB1c2gocGF0aCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBtZXJnZURpc2NyaW1pbmF0b3JTY2hlbWEoc2NoZW1hLCBiYXNlU2NoZW1hKTtcblxuICAgIC8vIENsZWFuIHVwIGNvbmZsaWN0aW5nIHBhdGhzIF9hZnRlcl8gbWVyZ2luZyByZTogZ2gtNjA3NlxuICAgIGZvciAoY29uc3QgY29uZmxpY3RpbmdQYXRoIG9mIGNvbmZsaWN0aW5nUGF0aHMpIHtcbiAgICAgIGRlbGV0ZSBzY2hlbWEucGF0aHNbY29uZmxpY3RpbmdQYXRoXTtcbiAgICB9XG5cbiAgICAvLyBSZWJ1aWxkIHNjaGVtYSBtb2RlbHMgYmVjYXVzZSBzY2hlbWFzIG1heSBoYXZlIGJlZW4gbWVyZ2VkIHJlOiAjNzg4NFxuICAgIHNjaGVtYS5jaGlsZFNjaGVtYXMuZm9yRWFjaChvYmogPT4ge1xuICAgICAgb2JqLm1vZGVsLnByb3RvdHlwZS4kX19zZXRTY2hlbWEob2JqLnNjaGVtYSk7XG4gICAgfSk7XG5cbiAgICBjb25zdCBvYmogPSB7fTtcbiAgICBvYmpba2V5XSA9IHtcbiAgICAgIGRlZmF1bHQ6IHZhbHVlLFxuICAgICAgc2VsZWN0OiB0cnVlLFxuICAgICAgc2V0OiBmdW5jdGlvbihuZXdOYW1lKSB7XG4gICAgICAgIGlmIChuZXdOYW1lID09PSB2YWx1ZSB8fCAoQXJyYXkuaXNBcnJheSh2YWx1ZSkgJiYgdXRpbHMuZGVlcEVxdWFsKG5ld05hbWUsIHZhbHVlKSkpIHtcbiAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgIH1cbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdDYW5cXCd0IHNldCBkaXNjcmltaW5hdG9yIGtleSBcIicgKyBrZXkgKyAnXCInKTtcbiAgICAgIH0sXG4gICAgICAkc2tpcERpc2NyaW1pbmF0b3JDaGVjazogdHJ1ZVxuICAgIH07XG4gICAgb2JqW2tleV1bc2NoZW1hLm9wdGlvbnMudHlwZUtleV0gPSBleGlzdGluZ1BhdGggPyBleGlzdGluZ1BhdGgub3B0aW9uc1tzY2hlbWEub3B0aW9ucy50eXBlS2V5XSA6IFN0cmluZztcbiAgICBzY2hlbWEuYWRkKG9iaik7XG5cbiAgICBzY2hlbWEuZGlzY3JpbWluYXRvck1hcHBpbmcgPSB7IGtleToga2V5LCB2YWx1ZTogdmFsdWUsIGlzUm9vdDogZmFsc2UgfTtcblxuICAgIGlmIChiYXNlU2NoZW1hLm9wdGlvbnMuY29sbGVjdGlvbikge1xuICAgICAgc2NoZW1hLm9wdGlvbnMuY29sbGVjdGlvbiA9IGJhc2VTY2hlbWEub3B0aW9ucy5jb2xsZWN0aW9uO1xuICAgIH1cbiAgICBjb25zdCB0b0pTT04gPSBzY2hlbWEub3B0aW9ucy50b0pTT047XG4gICAgY29uc3QgdG9PYmplY3QgPSBzY2hlbWEub3B0aW9ucy50b09iamVjdDtcbiAgICBjb25zdCBfaWQgPSBzY2hlbWEub3B0aW9ucy5faWQ7XG4gICAgY29uc3QgaWQgPSBzY2hlbWEub3B0aW9ucy5pZDtcblxuICAgIGNvbnN0IGtleXMgPSBPYmplY3Qua2V5cyhzY2hlbWEub3B0aW9ucyk7XG4gICAgc2NoZW1hLm9wdGlvbnMuZGlzY3JpbWluYXRvcktleSA9IGJhc2VTY2hlbWEub3B0aW9ucy5kaXNjcmltaW5hdG9yS2V5O1xuICAgIGNvbnN0IHVzZXJQcm92aWRlZE9wdGlvbnMgPSBzY2hlbWEuX3VzZXJQcm92aWRlZE9wdGlvbnM7XG4gICAgZm9yIChjb25zdCBfa2V5IG9mIGtleXMpIHtcbiAgICAgIGlmICghQ1VTVE9NSVpBQkxFX0RJU0NSSU1JTkFUT1JfT1BUSU9OU1tfa2V5XSkge1xuICAgICAgICAvLyBVc2UgYHNjaGVtYS5vcHRpb25zYCBpbiBgZGVlcEVxdWFsKClgIGJlY2F1c2Ugb2YgYGRpc2NyaW1pbmF0b3JLZXlgXG4gICAgICAgIC8vIHNldCBhYm92ZS4gV2UgZG9uJ3QgYWxsb3cgY3VzdG9taXppbmcgZGlzY3JpbWluYXRvciBrZXksIGFsd2F5c1xuICAgICAgICAvLyBvdmVyd3JpdGUuIFNlZSBnaC05MjM4XG4gICAgICAgIGlmIChfa2V5IGluIHVzZXJQcm92aWRlZE9wdGlvbnMgJiYgIXV0aWxzLmRlZXBFcXVhbChzY2hlbWEub3B0aW9uc1tfa2V5XSwgYmFzZVNjaGVtYS5vcHRpb25zW19rZXldKSkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcignQ2FuXFwndCBjdXN0b21pemUgZGlzY3JpbWluYXRvciBvcHRpb24gJyArIF9rZXkgK1xuICAgICAgICAgICAgJyAoY2FuIG9ubHkgbW9kaWZ5ICcgK1xuICAgICAgICAgICAgT2JqZWN0LmtleXMoQ1VTVE9NSVpBQkxFX0RJU0NSSU1JTkFUT1JfT1BUSU9OUykuam9pbignLCAnKSArXG4gICAgICAgICAgICAnKScpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHNjaGVtYS5vcHRpb25zID0gY2xvbmUoYmFzZVNjaGVtYS5vcHRpb25zKTtcblxuICAgIGZvciAoY29uc3QgX2tleSBvZiBPYmplY3Qua2V5cyh1c2VyUHJvdmlkZWRPcHRpb25zKSkge1xuICAgICAgc2NoZW1hLm9wdGlvbnNbX2tleV0gPSB1c2VyUHJvdmlkZWRPcHRpb25zW19rZXldO1xuICAgIH1cbiAgICBpZiAodG9KU09OKSBzY2hlbWEub3B0aW9ucy50b0pTT04gPSB0b0pTT047XG4gICAgaWYgKHRvT2JqZWN0KSBzY2hlbWEub3B0aW9ucy50b09iamVjdCA9IHRvT2JqZWN0O1xuICAgIGlmICh0eXBlb2YgX2lkICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgc2NoZW1hLm9wdGlvbnMuX2lkID0gX2lkO1xuICAgIH1cbiAgICBzY2hlbWEub3B0aW9ucy5pZCA9IGlkO1xuICAgIGlmIChtZXJnZUhvb2tzKSB7XG4gICAgICBzY2hlbWEucy5ob29rcyA9IG1vZGVsLnNjaGVtYS5zLmhvb2tzLm1lcmdlKHNjaGVtYS5zLmhvb2tzKTtcbiAgICB9XG4gICAgaWYgKGFwcGx5UGx1Z2lucykge1xuICAgICAgc2NoZW1hLnBsdWdpbnMgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChiYXNlU2NoZW1hLnBsdWdpbnMpO1xuICAgIH1cbiAgICBzY2hlbWEuY2FsbFF1ZXVlID0gYmFzZVNjaGVtYS5jYWxsUXVldWUuY29uY2F0KHNjaGVtYS5jYWxsUXVldWUpO1xuICAgIGRlbGV0ZSBzY2hlbWEuX3JlcXVpcmVkcGF0aHM7IC8vIHJlc2V0IGp1c3QgaW4gY2FzZSBTY2hlbWEjcmVxdWlyZWRQYXRocygpIHdhcyBjYWxsZWQgb24gZWl0aGVyIHNjaGVtYVxuICB9XG5cbiAgLy8gbWVyZ2VzIGJhc2Ugc2NoZW1hIGludG8gbmV3IGRpc2NyaW1pbmF0b3Igc2NoZW1hIGFuZCBzZXRzIG5ldyB0eXBlIGZpZWxkLlxuICBtZXJnZShzY2hlbWEsIG1vZGVsLnNjaGVtYSk7XG5cbiAgaWYgKCFtb2RlbC5kaXNjcmltaW5hdG9ycykge1xuICAgIG1vZGVsLmRpc2NyaW1pbmF0b3JzID0ge307XG4gIH1cblxuICBpZiAoIW1vZGVsLnNjaGVtYS5kaXNjcmltaW5hdG9yTWFwcGluZykge1xuICAgIG1vZGVsLnNjaGVtYS5kaXNjcmltaW5hdG9yTWFwcGluZyA9IHsga2V5OiBrZXksIHZhbHVlOiBudWxsLCBpc1Jvb3Q6IHRydWUgfTtcbiAgfVxuICBpZiAoIW1vZGVsLnNjaGVtYS5kaXNjcmltaW5hdG9ycykge1xuICAgIG1vZGVsLnNjaGVtYS5kaXNjcmltaW5hdG9ycyA9IHt9O1xuICB9XG5cbiAgbW9kZWwuc2NoZW1hLmRpc2NyaW1pbmF0b3JzW25hbWVdID0gc2NoZW1hO1xuXG4gIGlmIChtb2RlbC5kaXNjcmltaW5hdG9yc1tuYW1lXSAmJiAhc2NoZW1hLm9wdGlvbnMub3ZlcndyaXRlTW9kZWxzKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdEaXNjcmltaW5hdG9yIHdpdGggbmFtZSBcIicgKyBuYW1lICsgJ1wiIGFscmVhZHkgZXhpc3RzJyk7XG4gIH1cblxuICByZXR1cm4gc2NoZW1hO1xufTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/mongoose/lib/helpers/model/discriminator.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/mongoose/lib/helpers/model/pushNestedArrayPaths.js":
/*!*************************************************************************!*\
  !*** ./node_modules/mongoose/lib/helpers/model/pushNestedArrayPaths.js ***!
  \*************************************************************************/
/***/ ((module) => {

eval("\n\nmodule.exports = function pushNestedArrayPaths(paths, nestedArray, path) {\n  if (nestedArray == null) {\n    return;\n  }\n\n  for (let i = 0; i < nestedArray.length; ++i) {\n    if (Array.isArray(nestedArray[i])) {\n      pushNestedArrayPaths(paths, nestedArray[i], path + '.' + i);\n    } else {\n      paths.push(path + '.' + i);\n    }\n  }\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbW9uZ29vc2UvbGliL2hlbHBlcnMvbW9kZWwvcHVzaE5lc3RlZEFycmF5UGF0aHMuanMiLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWI7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsa0JBQWtCLHdCQUF3QjtBQUMxQztBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vYXBwMS8uL25vZGVfbW9kdWxlcy9tb25nb29zZS9saWIvaGVscGVycy9tb2RlbC9wdXNoTmVzdGVkQXJyYXlQYXRocy5qcz9mYTExIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBwdXNoTmVzdGVkQXJyYXlQYXRocyhwYXRocywgbmVzdGVkQXJyYXksIHBhdGgpIHtcbiAgaWYgKG5lc3RlZEFycmF5ID09IG51bGwpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICBmb3IgKGxldCBpID0gMDsgaSA8IG5lc3RlZEFycmF5Lmxlbmd0aDsgKytpKSB7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkobmVzdGVkQXJyYXlbaV0pKSB7XG4gICAgICBwdXNoTmVzdGVkQXJyYXlQYXRocyhwYXRocywgbmVzdGVkQXJyYXlbaV0sIHBhdGggKyAnLicgKyBpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcGF0aHMucHVzaChwYXRoICsgJy4nICsgaSk7XG4gICAgfVxuICB9XG59O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/mongoose/lib/helpers/model/pushNestedArrayPaths.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/mongoose/lib/helpers/parallelLimit.js":
/*!************************************************************!*\
  !*** ./node_modules/mongoose/lib/helpers/parallelLimit.js ***!
  \************************************************************/
/***/ ((module) => {

eval("\n\nmodule.exports = parallelLimit;\n\n/*!\n * ignore\n */\n\nfunction parallelLimit(fns, limit, callback) {\n  let numInProgress = 0;\n  let numFinished = 0;\n  let error = null;\n\n  if (limit <= 0) {\n    throw new Error('Limit must be positive');\n  }\n\n  if (fns.length === 0) {\n    return callback(null, []);\n  }\n\n  for (let i = 0; i < fns.length && i < limit; ++i) {\n    _start();\n  }\n\n  function _start() {\n    fns[numFinished + numInProgress](_done(numFinished + numInProgress));\n    ++numInProgress;\n  }\n\n  const results = [];\n\n  function _done(index) {\n    return (err, res) => {\n      --numInProgress;\n      ++numFinished;\n\n      if (error != null) {\n        return;\n      }\n      if (err != null) {\n        error = err;\n        return callback(error);\n      }\n\n      results[index] = res;\n\n      if (numFinished === fns.length) {\n        return callback(null, results);\n      } else if (numFinished + numInProgress < fns.length) {\n        _start();\n      }\n    };\n  }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbW9uZ29vc2UvbGliL2hlbHBlcnMvcGFyYWxsZWxMaW1pdC5qcyIsIm1hcHBpbmdzIjoiQUFBYTs7QUFFYjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxrQkFBa0IsNkJBQTZCO0FBQy9DO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vYXBwMS8uL25vZGVfbW9kdWxlcy9tb25nb29zZS9saWIvaGVscGVycy9wYXJhbGxlbExpbWl0LmpzPzhmOGQiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHBhcmFsbGVsTGltaXQ7XG5cbi8qIVxuICogaWdub3JlXG4gKi9cblxuZnVuY3Rpb24gcGFyYWxsZWxMaW1pdChmbnMsIGxpbWl0LCBjYWxsYmFjaykge1xuICBsZXQgbnVtSW5Qcm9ncmVzcyA9IDA7XG4gIGxldCBudW1GaW5pc2hlZCA9IDA7XG4gIGxldCBlcnJvciA9IG51bGw7XG5cbiAgaWYgKGxpbWl0IDw9IDApIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0xpbWl0IG11c3QgYmUgcG9zaXRpdmUnKTtcbiAgfVxuXG4gIGlmIChmbnMubGVuZ3RoID09PSAwKSB7XG4gICAgcmV0dXJuIGNhbGxiYWNrKG51bGwsIFtdKTtcbiAgfVxuXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgZm5zLmxlbmd0aCAmJiBpIDwgbGltaXQ7ICsraSkge1xuICAgIF9zdGFydCgpO1xuICB9XG5cbiAgZnVuY3Rpb24gX3N0YXJ0KCkge1xuICAgIGZuc1tudW1GaW5pc2hlZCArIG51bUluUHJvZ3Jlc3NdKF9kb25lKG51bUZpbmlzaGVkICsgbnVtSW5Qcm9ncmVzcykpO1xuICAgICsrbnVtSW5Qcm9ncmVzcztcbiAgfVxuXG4gIGNvbnN0IHJlc3VsdHMgPSBbXTtcblxuICBmdW5jdGlvbiBfZG9uZShpbmRleCkge1xuICAgIHJldHVybiAoZXJyLCByZXMpID0+IHtcbiAgICAgIC0tbnVtSW5Qcm9ncmVzcztcbiAgICAgICsrbnVtRmluaXNoZWQ7XG5cbiAgICAgIGlmIChlcnJvciAhPSBudWxsKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGlmIChlcnIgIT0gbnVsbCkge1xuICAgICAgICBlcnJvciA9IGVycjtcbiAgICAgICAgcmV0dXJuIGNhbGxiYWNrKGVycm9yKTtcbiAgICAgIH1cblxuICAgICAgcmVzdWx0c1tpbmRleF0gPSByZXM7XG5cbiAgICAgIGlmIChudW1GaW5pc2hlZCA9PT0gZm5zLmxlbmd0aCkge1xuICAgICAgICByZXR1cm4gY2FsbGJhY2sobnVsbCwgcmVzdWx0cyk7XG4gICAgICB9IGVsc2UgaWYgKG51bUZpbmlzaGVkICsgbnVtSW5Qcm9ncmVzcyA8IGZucy5sZW5ndGgpIHtcbiAgICAgICAgX3N0YXJ0KCk7XG4gICAgICB9XG4gICAgfTtcbiAgfVxufVxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/mongoose/lib/helpers/parallelLimit.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/mongoose/lib/helpers/path/parentPaths.js":
/*!***************************************************************!*\
  !*** ./node_modules/mongoose/lib/helpers/path/parentPaths.js ***!
  \***************************************************************/
/***/ ((module) => {

eval("\n\nconst dotRE = /\\./g;\nmodule.exports = function parentPaths(path) {\n  if (path.indexOf('.') === -1) {\n    return [path];\n  }\n  const pieces = path.split(dotRE);\n  const len = pieces.length;\n  const ret = new Array(len);\n  let cur = '';\n  for (let i = 0; i < len; ++i) {\n    cur += (cur.length !== 0) ? '.' + pieces[i] : pieces[i];\n    ret[i] = cur;\n  }\n\n  return ret;\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbW9uZ29vc2UvbGliL2hlbHBlcnMvcGF0aC9wYXJlbnRQYXRocy5qcyIsIm1hcHBpbmdzIjoiQUFBYTs7QUFFYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsU0FBUztBQUMzQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL2FwcDEvLi9ub2RlX21vZHVsZXMvbW9uZ29vc2UvbGliL2hlbHBlcnMvcGF0aC9wYXJlbnRQYXRocy5qcz82OTc5Il0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxuY29uc3QgZG90UkUgPSAvXFwuL2c7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIHBhcmVudFBhdGhzKHBhdGgpIHtcbiAgaWYgKHBhdGguaW5kZXhPZignLicpID09PSAtMSkge1xuICAgIHJldHVybiBbcGF0aF07XG4gIH1cbiAgY29uc3QgcGllY2VzID0gcGF0aC5zcGxpdChkb3RSRSk7XG4gIGNvbnN0IGxlbiA9IHBpZWNlcy5sZW5ndGg7XG4gIGNvbnN0IHJldCA9IG5ldyBBcnJheShsZW4pO1xuICBsZXQgY3VyID0gJyc7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgbGVuOyArK2kpIHtcbiAgICBjdXIgKz0gKGN1ci5sZW5ndGggIT09IDApID8gJy4nICsgcGllY2VzW2ldIDogcGllY2VzW2ldO1xuICAgIHJldFtpXSA9IGN1cjtcbiAgfVxuXG4gIHJldHVybiByZXQ7XG59O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/mongoose/lib/helpers/path/parentPaths.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/mongoose/lib/helpers/path/setDottedPath.js":
/*!*****************************************************************!*\
  !*** ./node_modules/mongoose/lib/helpers/path/setDottedPath.js ***!
  \*****************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\n\nconst specialProperties = __webpack_require__(/*! ../specialProperties */ \"(ssr)/./node_modules/mongoose/lib/helpers/specialProperties.js\");\n\n\nmodule.exports = function setDottedPath(obj, path, val) {\n  if (path.indexOf('.') === -1) {\n    if (specialProperties.has(path)) {\n      return;\n    }\n\n    obj[path] = val;\n    return;\n  }\n  const parts = path.split('.');\n\n  const last = parts.pop();\n  let cur = obj;\n  for (const part of parts) {\n    if (specialProperties.has(part)) {\n      continue;\n    }\n    if (cur[part] == null) {\n      cur[part] = {};\n    }\n\n    cur = cur[part];\n  }\n\n  if (!specialProperties.has(last)) {\n    cur[last] = val;\n  }\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbW9uZ29vc2UvbGliL2hlbHBlcnMvcGF0aC9zZXREb3R0ZWRQYXRoLmpzIiwibWFwcGluZ3MiOiJBQUFhOztBQUViLDBCQUEwQixtQkFBTyxDQUFDLDRGQUFzQjs7O0FBR3hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9hcHAxLy4vbm9kZV9tb2R1bGVzL21vbmdvb3NlL2xpYi9oZWxwZXJzL3BhdGgvc2V0RG90dGVkUGF0aC5qcz8yZGJlIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxuY29uc3Qgc3BlY2lhbFByb3BlcnRpZXMgPSByZXF1aXJlKCcuLi9zcGVjaWFsUHJvcGVydGllcycpO1xuXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gc2V0RG90dGVkUGF0aChvYmosIHBhdGgsIHZhbCkge1xuICBpZiAocGF0aC5pbmRleE9mKCcuJykgPT09IC0xKSB7XG4gICAgaWYgKHNwZWNpYWxQcm9wZXJ0aWVzLmhhcyhwYXRoKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIG9ialtwYXRoXSA9IHZhbDtcbiAgICByZXR1cm47XG4gIH1cbiAgY29uc3QgcGFydHMgPSBwYXRoLnNwbGl0KCcuJyk7XG5cbiAgY29uc3QgbGFzdCA9IHBhcnRzLnBvcCgpO1xuICBsZXQgY3VyID0gb2JqO1xuICBmb3IgKGNvbnN0IHBhcnQgb2YgcGFydHMpIHtcbiAgICBpZiAoc3BlY2lhbFByb3BlcnRpZXMuaGFzKHBhcnQpKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgaWYgKGN1cltwYXJ0XSA9PSBudWxsKSB7XG4gICAgICBjdXJbcGFydF0gPSB7fTtcbiAgICB9XG5cbiAgICBjdXIgPSBjdXJbcGFydF07XG4gIH1cblxuICBpZiAoIXNwZWNpYWxQcm9wZXJ0aWVzLmhhcyhsYXN0KSkge1xuICAgIGN1cltsYXN0XSA9IHZhbDtcbiAgfVxufTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/mongoose/lib/helpers/path/setDottedPath.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/mongoose/lib/helpers/pluralize.js":
/*!********************************************************!*\
  !*** ./node_modules/mongoose/lib/helpers/pluralize.js ***!
  \********************************************************/
/***/ ((module, exports) => {

eval("\n\nmodule.exports = pluralize;\n\n/**\n * Pluralization rules.\n */\n\nexports.pluralization = [\n  [/human$/gi, 'humans'],\n  [/(m)an$/gi, '$1en'],\n  [/(pe)rson$/gi, '$1ople'],\n  [/(child)$/gi, '$1ren'],\n  [/^(ox)$/gi, '$1en'],\n  [/(ax|test)is$/gi, '$1es'],\n  [/(octop|vir)us$/gi, '$1i'],\n  [/(alias|status)$/gi, '$1es'],\n  [/(bu)s$/gi, '$1ses'],\n  [/(buffal|tomat|potat)o$/gi, '$1oes'],\n  [/([ti])um$/gi, '$1a'],\n  [/sis$/gi, 'ses'],\n  [/(?:([^f])fe|([lr])f)$/gi, '$1$2ves'],\n  [/(hive)$/gi, '$1s'],\n  [/([^aeiouy]|qu)y$/gi, '$1ies'],\n  [/(x|ch|ss|sh)$/gi, '$1es'],\n  [/(matr|vert|ind)ix|ex$/gi, '$1ices'],\n  [/([m|l])ouse$/gi, '$1ice'],\n  [/(kn|w|l)ife$/gi, '$1ives'],\n  [/(quiz)$/gi, '$1zes'],\n  [/^goose$/i, 'geese'],\n  [/s$/gi, 's'],\n  [/([^a-z])$/, '$1'],\n  [/$/gi, 's']\n];\nconst rules = exports.pluralization;\n\n/**\n * Uncountable words.\n *\n * These words are applied while processing the argument to `toCollectionName`.\n * @api public\n */\n\nexports.uncountables = [\n  'advice',\n  'energy',\n  'excretion',\n  'digestion',\n  'cooperation',\n  'health',\n  'justice',\n  'labour',\n  'machinery',\n  'equipment',\n  'information',\n  'pollution',\n  'sewage',\n  'paper',\n  'money',\n  'species',\n  'series',\n  'rain',\n  'rice',\n  'fish',\n  'sheep',\n  'moose',\n  'deer',\n  'news',\n  'expertise',\n  'status',\n  'media'\n];\nconst uncountables = exports.uncountables;\n\n/**\n * Pluralize function.\n *\n * @author TJ Holowaychuk (extracted from _ext.js_)\n * @param {String} string to pluralize\n * @api private\n */\n\nfunction pluralize(str) {\n  let found;\n  str = str.toLowerCase();\n  if (!~uncountables.indexOf(str)) {\n    found = rules.filter(function(rule) {\n      return str.match(rule[0]);\n    });\n    if (found[0]) {\n      return str.replace(found[0][0], found[0][1]);\n    }\n  }\n  return str;\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbW9uZ29vc2UvbGliL2hlbHBlcnMvcGx1cmFsaXplLmpzIiwibWFwcGluZ3MiOiJBQUFhOztBQUViOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vYXBwMS8uL25vZGVfbW9kdWxlcy9tb25nb29zZS9saWIvaGVscGVycy9wbHVyYWxpemUuanM/ZWM1NSJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbm1vZHVsZS5leHBvcnRzID0gcGx1cmFsaXplO1xuXG4vKipcbiAqIFBsdXJhbGl6YXRpb24gcnVsZXMuXG4gKi9cblxuZXhwb3J0cy5wbHVyYWxpemF0aW9uID0gW1xuICBbL2h1bWFuJC9naSwgJ2h1bWFucyddLFxuICBbLyhtKWFuJC9naSwgJyQxZW4nXSxcbiAgWy8ocGUpcnNvbiQvZ2ksICckMW9wbGUnXSxcbiAgWy8oY2hpbGQpJC9naSwgJyQxcmVuJ10sXG4gIFsvXihveCkkL2dpLCAnJDFlbiddLFxuICBbLyhheHx0ZXN0KWlzJC9naSwgJyQxZXMnXSxcbiAgWy8ob2N0b3B8dmlyKXVzJC9naSwgJyQxaSddLFxuICBbLyhhbGlhc3xzdGF0dXMpJC9naSwgJyQxZXMnXSxcbiAgWy8oYnUpcyQvZ2ksICckMXNlcyddLFxuICBbLyhidWZmYWx8dG9tYXR8cG90YXQpbyQvZ2ksICckMW9lcyddLFxuICBbLyhbdGldKXVtJC9naSwgJyQxYSddLFxuICBbL3NpcyQvZ2ksICdzZXMnXSxcbiAgWy8oPzooW15mXSlmZXwoW2xyXSlmKSQvZ2ksICckMSQydmVzJ10sXG4gIFsvKGhpdmUpJC9naSwgJyQxcyddLFxuICBbLyhbXmFlaW91eV18cXUpeSQvZ2ksICckMWllcyddLFxuICBbLyh4fGNofHNzfHNoKSQvZ2ksICckMWVzJ10sXG4gIFsvKG1hdHJ8dmVydHxpbmQpaXh8ZXgkL2dpLCAnJDFpY2VzJ10sXG4gIFsvKFttfGxdKW91c2UkL2dpLCAnJDFpY2UnXSxcbiAgWy8oa258d3xsKWlmZSQvZ2ksICckMWl2ZXMnXSxcbiAgWy8ocXVpeikkL2dpLCAnJDF6ZXMnXSxcbiAgWy9eZ29vc2UkL2ksICdnZWVzZSddLFxuICBbL3MkL2dpLCAncyddLFxuICBbLyhbXmEtel0pJC8sICckMSddLFxuICBbLyQvZ2ksICdzJ11cbl07XG5jb25zdCBydWxlcyA9IGV4cG9ydHMucGx1cmFsaXphdGlvbjtcblxuLyoqXG4gKiBVbmNvdW50YWJsZSB3b3Jkcy5cbiAqXG4gKiBUaGVzZSB3b3JkcyBhcmUgYXBwbGllZCB3aGlsZSBwcm9jZXNzaW5nIHRoZSBhcmd1bWVudCB0byBgdG9Db2xsZWN0aW9uTmFtZWAuXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmV4cG9ydHMudW5jb3VudGFibGVzID0gW1xuICAnYWR2aWNlJyxcbiAgJ2VuZXJneScsXG4gICdleGNyZXRpb24nLFxuICAnZGlnZXN0aW9uJyxcbiAgJ2Nvb3BlcmF0aW9uJyxcbiAgJ2hlYWx0aCcsXG4gICdqdXN0aWNlJyxcbiAgJ2xhYm91cicsXG4gICdtYWNoaW5lcnknLFxuICAnZXF1aXBtZW50JyxcbiAgJ2luZm9ybWF0aW9uJyxcbiAgJ3BvbGx1dGlvbicsXG4gICdzZXdhZ2UnLFxuICAncGFwZXInLFxuICAnbW9uZXknLFxuICAnc3BlY2llcycsXG4gICdzZXJpZXMnLFxuICAncmFpbicsXG4gICdyaWNlJyxcbiAgJ2Zpc2gnLFxuICAnc2hlZXAnLFxuICAnbW9vc2UnLFxuICAnZGVlcicsXG4gICduZXdzJyxcbiAgJ2V4cGVydGlzZScsXG4gICdzdGF0dXMnLFxuICAnbWVkaWEnXG5dO1xuY29uc3QgdW5jb3VudGFibGVzID0gZXhwb3J0cy51bmNvdW50YWJsZXM7XG5cbi8qKlxuICogUGx1cmFsaXplIGZ1bmN0aW9uLlxuICpcbiAqIEBhdXRob3IgVEogSG9sb3dheWNodWsgKGV4dHJhY3RlZCBmcm9tIF9leHQuanNfKVxuICogQHBhcmFtIHtTdHJpbmd9IHN0cmluZyB0byBwbHVyYWxpemVcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmZ1bmN0aW9uIHBsdXJhbGl6ZShzdHIpIHtcbiAgbGV0IGZvdW5kO1xuICBzdHIgPSBzdHIudG9Mb3dlckNhc2UoKTtcbiAgaWYgKCF+dW5jb3VudGFibGVzLmluZGV4T2Yoc3RyKSkge1xuICAgIGZvdW5kID0gcnVsZXMuZmlsdGVyKGZ1bmN0aW9uKHJ1bGUpIHtcbiAgICAgIHJldHVybiBzdHIubWF0Y2gocnVsZVswXSk7XG4gICAgfSk7XG4gICAgaWYgKGZvdW5kWzBdKSB7XG4gICAgICByZXR1cm4gc3RyLnJlcGxhY2UoZm91bmRbMF1bMF0sIGZvdW5kWzBdWzFdKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHN0cjtcbn1cbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/mongoose/lib/helpers/pluralize.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/mongoose/lib/helpers/populate/assignRawDocsToIdStructure.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/mongoose/lib/helpers/populate/assignRawDocsToIdStructure.js ***!
  \**********************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\n\nconst clone = __webpack_require__(/*! ../../helpers/clone */ \"(ssr)/./node_modules/mongoose/lib/helpers/clone.js\");\nconst leanPopulateMap = __webpack_require__(/*! ./leanPopulateMap */ \"(ssr)/./node_modules/mongoose/lib/helpers/populate/leanPopulateMap.js\");\nconst modelSymbol = (__webpack_require__(/*! ../symbols */ \"(ssr)/./node_modules/mongoose/lib/helpers/symbols.js\").modelSymbol);\nconst utils = __webpack_require__(/*! ../../utils */ \"(ssr)/./node_modules/mongoose/lib/utils.js\");\n\nmodule.exports = assignRawDocsToIdStructure;\n\nconst kHasArray = Symbol('mongoose#assignRawDocsToIdStructure#hasArray');\n\n/**\n * Assign `vals` returned by mongo query to the `rawIds`\n * structure returned from utils.getVals() honoring\n * query sort order if specified by user.\n *\n * This can be optimized.\n *\n * Rules:\n *\n *   if the value of the path is not an array, use findOne rules, else find.\n *   for findOne the results are assigned directly to doc path (including null results).\n *   for find, if user specified sort order, results are assigned directly\n *   else documents are put back in original order of array if found in results\n *\n * @param {Array} rawIds\n * @param {Array} resultDocs\n * @param {Array} resultOrder\n * @param {Object} options\n * @param {Boolean} recursed\n * @api private\n */\n\nfunction assignRawDocsToIdStructure(rawIds, resultDocs, resultOrder, options, recursed) {\n  // honor user specified sort order\n  const newOrder = [];\n  const sorting = options.sort && rawIds.length > 1;\n  const nullIfNotFound = options.$nullIfNotFound;\n  let doc;\n  let sid;\n  let id;\n\n  if (utils.isMongooseArray(rawIds)) {\n    rawIds = rawIds.__array;\n  }\n\n  let i = 0;\n  const len = rawIds.length;\n\n  if (sorting && recursed && options[kHasArray] === undefined) {\n    options[kHasArray] = false;\n    for (const key in resultOrder) {\n      if (Array.isArray(resultOrder[key])) {\n        options[kHasArray] = true;\n        break;\n      }\n    }\n  }\n\n  for (i = 0; i < len; ++i) {\n    id = rawIds[i];\n\n    if (Array.isArray(id)) {\n      // handle [ [id0, id2], [id3] ]\n      assignRawDocsToIdStructure(id, resultDocs, resultOrder, options, true);\n      newOrder.push(id);\n      continue;\n    }\n\n    if (id === null && sorting === false) {\n      // keep nulls for findOne unless sorting, which always\n      // removes them (backward compat)\n      newOrder.push(id);\n      continue;\n    }\n\n    sid = String(id);\n    doc = resultDocs[sid];\n    // If user wants separate copies of same doc, use this option\n    if (options.clone && doc != null) {\n      if (options.lean) {\n        const _model = leanPopulateMap.get(doc);\n        doc = clone(doc);\n        leanPopulateMap.set(doc, _model);\n      } else {\n        doc = doc.constructor.hydrate(doc._doc);\n      }\n    }\n\n    if (recursed) {\n      if (doc) {\n        if (sorting) {\n          const _resultOrder = resultOrder[sid];\n          if (options[kHasArray]) {\n            // If result arrays, rely on the MongoDB server response for ordering\n            newOrder.push(doc);\n          } else {\n            newOrder[_resultOrder] = doc;\n          }\n        } else {\n          newOrder.push(doc);\n        }\n      } else if (id != null && id[modelSymbol] != null) {\n        newOrder.push(id);\n      } else {\n        newOrder.push(options.retainNullValues || nullIfNotFound ? null : id);\n      }\n    } else {\n      // apply findOne behavior - if document in results, assign, else assign null\n      newOrder[i] = doc || null;\n    }\n  }\n\n  rawIds.length = 0;\n  if (newOrder.length) {\n    // reassign the documents based on corrected order\n\n    // forEach skips over sparse entries in arrays so we\n    // can safely use this to our advantage dealing with sorted\n    // result sets too.\n    newOrder.forEach(function(doc, i) {\n      rawIds[i] = doc;\n    });\n  }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbW9uZ29vc2UvbGliL2hlbHBlcnMvcG9wdWxhdGUvYXNzaWduUmF3RG9jc1RvSWRTdHJ1Y3R1cmUuanMiLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWIsY0FBYyxtQkFBTyxDQUFDLCtFQUFxQjtBQUMzQyx3QkFBd0IsbUJBQU8sQ0FBQyxnR0FBbUI7QUFDbkQsb0JBQW9CLDJHQUFpQztBQUNyRCxjQUFjLG1CQUFPLENBQUMsK0RBQWE7O0FBRW5DOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE9BQU87QUFDbEIsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsT0FBTztBQUNsQixXQUFXLFFBQVE7QUFDbkIsV0FBVyxTQUFTO0FBQ3BCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsY0FBYyxTQUFTO0FBQ3ZCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL2FwcDEvLi9ub2RlX21vZHVsZXMvbW9uZ29vc2UvbGliL2hlbHBlcnMvcG9wdWxhdGUvYXNzaWduUmF3RG9jc1RvSWRTdHJ1Y3R1cmUuanM/MWIxZiJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbmNvbnN0IGNsb25lID0gcmVxdWlyZSgnLi4vLi4vaGVscGVycy9jbG9uZScpO1xuY29uc3QgbGVhblBvcHVsYXRlTWFwID0gcmVxdWlyZSgnLi9sZWFuUG9wdWxhdGVNYXAnKTtcbmNvbnN0IG1vZGVsU3ltYm9sID0gcmVxdWlyZSgnLi4vc3ltYm9scycpLm1vZGVsU3ltYm9sO1xuY29uc3QgdXRpbHMgPSByZXF1aXJlKCcuLi8uLi91dGlscycpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGFzc2lnblJhd0RvY3NUb0lkU3RydWN0dXJlO1xuXG5jb25zdCBrSGFzQXJyYXkgPSBTeW1ib2woJ21vbmdvb3NlI2Fzc2lnblJhd0RvY3NUb0lkU3RydWN0dXJlI2hhc0FycmF5Jyk7XG5cbi8qKlxuICogQXNzaWduIGB2YWxzYCByZXR1cm5lZCBieSBtb25nbyBxdWVyeSB0byB0aGUgYHJhd0lkc2BcbiAqIHN0cnVjdHVyZSByZXR1cm5lZCBmcm9tIHV0aWxzLmdldFZhbHMoKSBob25vcmluZ1xuICogcXVlcnkgc29ydCBvcmRlciBpZiBzcGVjaWZpZWQgYnkgdXNlci5cbiAqXG4gKiBUaGlzIGNhbiBiZSBvcHRpbWl6ZWQuXG4gKlxuICogUnVsZXM6XG4gKlxuICogICBpZiB0aGUgdmFsdWUgb2YgdGhlIHBhdGggaXMgbm90IGFuIGFycmF5LCB1c2UgZmluZE9uZSBydWxlcywgZWxzZSBmaW5kLlxuICogICBmb3IgZmluZE9uZSB0aGUgcmVzdWx0cyBhcmUgYXNzaWduZWQgZGlyZWN0bHkgdG8gZG9jIHBhdGggKGluY2x1ZGluZyBudWxsIHJlc3VsdHMpLlxuICogICBmb3IgZmluZCwgaWYgdXNlciBzcGVjaWZpZWQgc29ydCBvcmRlciwgcmVzdWx0cyBhcmUgYXNzaWduZWQgZGlyZWN0bHlcbiAqICAgZWxzZSBkb2N1bWVudHMgYXJlIHB1dCBiYWNrIGluIG9yaWdpbmFsIG9yZGVyIG9mIGFycmF5IGlmIGZvdW5kIGluIHJlc3VsdHNcbiAqXG4gKiBAcGFyYW0ge0FycmF5fSByYXdJZHNcbiAqIEBwYXJhbSB7QXJyYXl9IHJlc3VsdERvY3NcbiAqIEBwYXJhbSB7QXJyYXl9IHJlc3VsdE9yZGVyXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xuICogQHBhcmFtIHtCb29sZWFufSByZWN1cnNlZFxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZnVuY3Rpb24gYXNzaWduUmF3RG9jc1RvSWRTdHJ1Y3R1cmUocmF3SWRzLCByZXN1bHREb2NzLCByZXN1bHRPcmRlciwgb3B0aW9ucywgcmVjdXJzZWQpIHtcbiAgLy8gaG9ub3IgdXNlciBzcGVjaWZpZWQgc29ydCBvcmRlclxuICBjb25zdCBuZXdPcmRlciA9IFtdO1xuICBjb25zdCBzb3J0aW5nID0gb3B0aW9ucy5zb3J0ICYmIHJhd0lkcy5sZW5ndGggPiAxO1xuICBjb25zdCBudWxsSWZOb3RGb3VuZCA9IG9wdGlvbnMuJG51bGxJZk5vdEZvdW5kO1xuICBsZXQgZG9jO1xuICBsZXQgc2lkO1xuICBsZXQgaWQ7XG5cbiAgaWYgKHV0aWxzLmlzTW9uZ29vc2VBcnJheShyYXdJZHMpKSB7XG4gICAgcmF3SWRzID0gcmF3SWRzLl9fYXJyYXk7XG4gIH1cblxuICBsZXQgaSA9IDA7XG4gIGNvbnN0IGxlbiA9IHJhd0lkcy5sZW5ndGg7XG5cbiAgaWYgKHNvcnRpbmcgJiYgcmVjdXJzZWQgJiYgb3B0aW9uc1trSGFzQXJyYXldID09PSB1bmRlZmluZWQpIHtcbiAgICBvcHRpb25zW2tIYXNBcnJheV0gPSBmYWxzZTtcbiAgICBmb3IgKGNvbnN0IGtleSBpbiByZXN1bHRPcmRlcikge1xuICAgICAgaWYgKEFycmF5LmlzQXJyYXkocmVzdWx0T3JkZXJba2V5XSkpIHtcbiAgICAgICAgb3B0aW9uc1trSGFzQXJyYXldID0gdHJ1ZTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgZm9yIChpID0gMDsgaSA8IGxlbjsgKytpKSB7XG4gICAgaWQgPSByYXdJZHNbaV07XG5cbiAgICBpZiAoQXJyYXkuaXNBcnJheShpZCkpIHtcbiAgICAgIC8vIGhhbmRsZSBbIFtpZDAsIGlkMl0sIFtpZDNdIF1cbiAgICAgIGFzc2lnblJhd0RvY3NUb0lkU3RydWN0dXJlKGlkLCByZXN1bHREb2NzLCByZXN1bHRPcmRlciwgb3B0aW9ucywgdHJ1ZSk7XG4gICAgICBuZXdPcmRlci5wdXNoKGlkKTtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIGlmIChpZCA9PT0gbnVsbCAmJiBzb3J0aW5nID09PSBmYWxzZSkge1xuICAgICAgLy8ga2VlcCBudWxscyBmb3IgZmluZE9uZSB1bmxlc3Mgc29ydGluZywgd2hpY2ggYWx3YXlzXG4gICAgICAvLyByZW1vdmVzIHRoZW0gKGJhY2t3YXJkIGNvbXBhdClcbiAgICAgIG5ld09yZGVyLnB1c2goaWQpO1xuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgc2lkID0gU3RyaW5nKGlkKTtcbiAgICBkb2MgPSByZXN1bHREb2NzW3NpZF07XG4gICAgLy8gSWYgdXNlciB3YW50cyBzZXBhcmF0ZSBjb3BpZXMgb2Ygc2FtZSBkb2MsIHVzZSB0aGlzIG9wdGlvblxuICAgIGlmIChvcHRpb25zLmNsb25lICYmIGRvYyAhPSBudWxsKSB7XG4gICAgICBpZiAob3B0aW9ucy5sZWFuKSB7XG4gICAgICAgIGNvbnN0IF9tb2RlbCA9IGxlYW5Qb3B1bGF0ZU1hcC5nZXQoZG9jKTtcbiAgICAgICAgZG9jID0gY2xvbmUoZG9jKTtcbiAgICAgICAgbGVhblBvcHVsYXRlTWFwLnNldChkb2MsIF9tb2RlbCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBkb2MgPSBkb2MuY29uc3RydWN0b3IuaHlkcmF0ZShkb2MuX2RvYyk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHJlY3Vyc2VkKSB7XG4gICAgICBpZiAoZG9jKSB7XG4gICAgICAgIGlmIChzb3J0aW5nKSB7XG4gICAgICAgICAgY29uc3QgX3Jlc3VsdE9yZGVyID0gcmVzdWx0T3JkZXJbc2lkXTtcbiAgICAgICAgICBpZiAob3B0aW9uc1trSGFzQXJyYXldKSB7XG4gICAgICAgICAgICAvLyBJZiByZXN1bHQgYXJyYXlzLCByZWx5IG9uIHRoZSBNb25nb0RCIHNlcnZlciByZXNwb25zZSBmb3Igb3JkZXJpbmdcbiAgICAgICAgICAgIG5ld09yZGVyLnB1c2goZG9jKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbmV3T3JkZXJbX3Jlc3VsdE9yZGVyXSA9IGRvYztcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgbmV3T3JkZXIucHVzaChkb2MpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKGlkICE9IG51bGwgJiYgaWRbbW9kZWxTeW1ib2xdICE9IG51bGwpIHtcbiAgICAgICAgbmV3T3JkZXIucHVzaChpZCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBuZXdPcmRlci5wdXNoKG9wdGlvbnMucmV0YWluTnVsbFZhbHVlcyB8fCBudWxsSWZOb3RGb3VuZCA/IG51bGwgOiBpZCk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIGFwcGx5IGZpbmRPbmUgYmVoYXZpb3IgLSBpZiBkb2N1bWVudCBpbiByZXN1bHRzLCBhc3NpZ24sIGVsc2UgYXNzaWduIG51bGxcbiAgICAgIG5ld09yZGVyW2ldID0gZG9jIHx8IG51bGw7XG4gICAgfVxuICB9XG5cbiAgcmF3SWRzLmxlbmd0aCA9IDA7XG4gIGlmIChuZXdPcmRlci5sZW5ndGgpIHtcbiAgICAvLyByZWFzc2lnbiB0aGUgZG9jdW1lbnRzIGJhc2VkIG9uIGNvcnJlY3RlZCBvcmRlclxuXG4gICAgLy8gZm9yRWFjaCBza2lwcyBvdmVyIHNwYXJzZSBlbnRyaWVzIGluIGFycmF5cyBzbyB3ZVxuICAgIC8vIGNhbiBzYWZlbHkgdXNlIHRoaXMgdG8gb3VyIGFkdmFudGFnZSBkZWFsaW5nIHdpdGggc29ydGVkXG4gICAgLy8gcmVzdWx0IHNldHMgdG9vLlxuICAgIG5ld09yZGVyLmZvckVhY2goZnVuY3Rpb24oZG9jLCBpKSB7XG4gICAgICByYXdJZHNbaV0gPSBkb2M7XG4gICAgfSk7XG4gIH1cbn1cbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/mongoose/lib/helpers/populate/assignRawDocsToIdStructure.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/mongoose/lib/helpers/populate/assignVals.js":
/*!******************************************************************!*\
  !*** ./node_modules/mongoose/lib/helpers/populate/assignVals.js ***!
  \******************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\n\nconst MongooseMap = __webpack_require__(/*! ../../types/map */ \"(ssr)/./node_modules/mongoose/lib/types/map.js\");\nconst SkipPopulateValue = __webpack_require__(/*! ./skipPopulateValue */ \"(ssr)/./node_modules/mongoose/lib/helpers/populate/skipPopulateValue.js\");\nconst assignRawDocsToIdStructure = __webpack_require__(/*! ./assignRawDocsToIdStructure */ \"(ssr)/./node_modules/mongoose/lib/helpers/populate/assignRawDocsToIdStructure.js\");\nconst get = __webpack_require__(/*! ../get */ \"(ssr)/./node_modules/mongoose/lib/helpers/get.js\");\nconst getVirtual = __webpack_require__(/*! ./getVirtual */ \"(ssr)/./node_modules/mongoose/lib/helpers/populate/getVirtual.js\");\nconst leanPopulateMap = __webpack_require__(/*! ./leanPopulateMap */ \"(ssr)/./node_modules/mongoose/lib/helpers/populate/leanPopulateMap.js\");\nconst lookupLocalFields = __webpack_require__(/*! ./lookupLocalFields */ \"(ssr)/./node_modules/mongoose/lib/helpers/populate/lookupLocalFields.js\");\nconst markArraySubdocsPopulated = __webpack_require__(/*! ./markArraySubdocsPopulated */ \"(ssr)/./node_modules/mongoose/lib/helpers/populate/markArraySubdocsPopulated.js\");\nconst mpath = __webpack_require__(/*! mpath */ \"(ssr)/./node_modules/mpath/index.js\");\nconst sift = (__webpack_require__(/*! sift */ \"(ssr)/./node_modules/sift/index.js\")[\"default\"]);\nconst utils = __webpack_require__(/*! ../../utils */ \"(ssr)/./node_modules/mongoose/lib/utils.js\");\nconst { populateModelSymbol } = __webpack_require__(/*! ../symbols */ \"(ssr)/./node_modules/mongoose/lib/helpers/symbols.js\");\n\nmodule.exports = function assignVals(o) {\n  // Options that aren't explicitly listed in `populateOptions`\n  const userOptions = Object.assign({}, get(o, 'allOptions.options.options'), get(o, 'allOptions.options'));\n  // `o.options` contains options explicitly listed in `populateOptions`, like\n  // `match` and `limit`.\n  const populateOptions = Object.assign({}, o.options, userOptions, {\n    justOne: o.justOne\n  });\n  populateOptions.$nullIfNotFound = o.isVirtual;\n  const populatedModel = o.populatedModel;\n\n  const originalIds = [].concat(o.rawIds);\n\n  // replace the original ids in our intermediate _ids structure\n  // with the documents found by query\n  o.allIds = [].concat(o.allIds);\n  assignRawDocsToIdStructure(o.rawIds, o.rawDocs, o.rawOrder, populateOptions);\n\n  // now update the original documents being populated using the\n  // result structure that contains real documents.\n  const docs = o.docs;\n  const rawIds = o.rawIds;\n  const options = o.options;\n  const count = o.count && o.isVirtual;\n  let i;\n\n  function setValue(val) {\n    if (count) {\n      return val;\n    }\n    if (val instanceof SkipPopulateValue) {\n      return val.val;\n    }\n    if (val === void 0) {\n      return val;\n    }\n\n    const _allIds = o.allIds[i];\n\n    if (o.path.endsWith('.$*')) {\n      // Skip maps re: gh-12494\n      return valueFilter(val, options, populateOptions, _allIds);\n    }\n\n    if (o.justOne === true && Array.isArray(val)) {\n      // Might be an embedded discriminator (re: gh-9244) with multiple models, so make sure to pick the right\n      // model before assigning.\n      const ret = [];\n      for (const doc of val) {\n        const _docPopulatedModel = leanPopulateMap.get(doc);\n        if (_docPopulatedModel == null || _docPopulatedModel === populatedModel) {\n          ret.push(doc);\n        }\n      }\n      // Since we don't want to have to create a new mongoosearray, make sure to\n      // modify the array in place\n      while (val.length > ret.length) {\n        Array.prototype.pop.apply(val, []);\n      }\n      for (let i = 0; i < ret.length; ++i) {\n        val[i] = ret[i];\n      }\n\n      return valueFilter(val[0], options, populateOptions, _allIds);\n    } else if (o.justOne === false && !Array.isArray(val)) {\n      return valueFilter([val], options, populateOptions, _allIds);\n    }\n    return valueFilter(val, options, populateOptions, _allIds);\n  }\n\n  for (i = 0; i < docs.length; ++i) {\n    const _path = o.path.endsWith('.$*') ? o.path.slice(0, -3) : o.path;\n    const existingVal = mpath.get(_path, docs[i], lookupLocalFields);\n    if (existingVal == null && !getVirtual(o.originalModel.schema, _path)) {\n      continue;\n    }\n\n    let valueToSet;\n    if (count) {\n      valueToSet = numDocs(rawIds[i]);\n    } else if (Array.isArray(o.match)) {\n      valueToSet = Array.isArray(rawIds[i]) ?\n        rawIds[i].filter(sift(o.match[i])) :\n        [rawIds[i]].filter(sift(o.match[i]))[0];\n    } else {\n      valueToSet = rawIds[i];\n    }\n\n    // If we're populating a map, the existing value will be an object, so\n    // we need to transform again\n    const originalSchema = o.originalModel.schema;\n    const isDoc = get(docs[i], '$__', null) != null;\n    let isMap = isDoc ?\n      existingVal instanceof Map :\n      utils.isPOJO(existingVal);\n    // If we pass the first check, also make sure the local field's schematype\n    // is map (re: gh-6460)\n    isMap = isMap && get(originalSchema._getSchema(_path), '$isSchemaMap');\n    if (!o.isVirtual && isMap) {\n      const _keys = existingVal instanceof Map ?\n        Array.from(existingVal.keys()) :\n        Object.keys(existingVal);\n      valueToSet = valueToSet.reduce((cur, v, i) => {\n        cur.set(_keys[i], v);\n        return cur;\n      }, new Map());\n    }\n\n    if (isDoc && Array.isArray(valueToSet)) {\n      for (const val of valueToSet) {\n        if (val != null && val.$__ != null) {\n          val.$__.parent = docs[i];\n        }\n      }\n    } else if (isDoc && valueToSet != null && valueToSet.$__ != null) {\n      valueToSet.$__.parent = docs[i];\n    }\n\n    if (o.isVirtual && isDoc) {\n      docs[i].$populated(_path, o.justOne ? originalIds[0] : originalIds, o.allOptions);\n      // If virtual populate and doc is already init-ed, need to walk through\n      // the actual doc to set rather than setting `_doc` directly\n      if (Array.isArray(valueToSet)) {\n        valueToSet = valueToSet.map(v => v == null ? void 0 : v);\n      }\n      mpath.set(_path, valueToSet, docs[i], void 0, setValue, false);\n      continue;\n    }\n\n    const parts = _path.split('.');\n    let cur = docs[i];\n    const curPath = parts[0];\n    for (let j = 0; j < parts.length - 1; ++j) {\n      // If we get to an array with a dotted path, like `arr.foo`, don't set\n      // `foo` on the array.\n      if (Array.isArray(cur) && !utils.isArrayIndex(parts[j])) {\n        break;\n      }\n\n      if (parts[j] === '$*') {\n        break;\n      }\n\n      if (cur[parts[j]] == null) {\n        // If nothing to set, avoid creating an unnecessary array. Otherwise\n        // we'll end up with a single doc in the array with only defaults.\n        // See gh-8342, gh-8455\n        const schematype = originalSchema._getSchema(curPath);\n        if (valueToSet == null && schematype != null && schematype.$isMongooseArray) {\n          break;\n        }\n        cur[parts[j]] = {};\n      }\n      cur = cur[parts[j]];\n      // If the property in MongoDB is a primitive, we won't be able to populate\n      // the nested path, so skip it. See gh-7545\n      if (typeof cur !== 'object') {\n        break;\n      }\n    }\n    if (docs[i].$__) {\n      o.allOptions.options[populateModelSymbol] = o.allOptions.model;\n      docs[i].$populated(_path, o.unpopulatedValues[i], o.allOptions.options);\n\n      if (valueToSet != null && valueToSet.$__ != null) {\n        valueToSet.$__.wasPopulated = { value: o.unpopulatedValues[i] };\n      }\n\n      if (valueToSet instanceof Map && !valueToSet.$isMongooseMap) {\n        valueToSet = new MongooseMap(valueToSet, _path, docs[i], docs[i].schema.path(_path).$__schemaType);\n      }\n    }\n\n    // If lean, need to check that each individual virtual respects\n    // `justOne`, because you may have a populated virtual with `justOne`\n    // underneath an array. See gh-6867\n    mpath.set(_path, valueToSet, docs[i], lookupLocalFields, setValue, false);\n\n    if (docs[i].$__) {\n      markArraySubdocsPopulated(docs[i], [o.allOptions.options]);\n    }\n  }\n};\n\nfunction numDocs(v) {\n  if (Array.isArray(v)) {\n    // If setting underneath an array of populated subdocs, we may have an\n    // array of arrays. See gh-7573\n    if (v.some(el => Array.isArray(el) || el === null)) {\n      return v.map(el => {\n        if (el == null) {\n          return 0;\n        }\n        if (Array.isArray(el)) {\n          return el.filter(el => el != null).length;\n        }\n        return 1;\n      });\n    }\n    return v.filter(el => el != null).length;\n  }\n  return v == null ? 0 : 1;\n}\n\n/**\n * 1) Apply backwards compatible find/findOne behavior to sub documents\n *\n *    find logic:\n *      a) filter out non-documents\n *      b) remove _id from sub docs when user specified\n *\n *    findOne\n *      a) if no doc found, set to null\n *      b) remove _id from sub docs when user specified\n *\n * 2) Remove _ids when specified by users query.\n *\n * background:\n * _ids are left in the query even when user excludes them so\n * that population mapping can occur.\n * @param {Any} val\n * @param {Object} assignmentOpts\n * @param {Object} populateOptions\n * @param {Function} [populateOptions.transform]\n * @param {Boolean} allIds\n * @api private\n */\n\nfunction valueFilter(val, assignmentOpts, populateOptions, allIds) {\n  const userSpecifiedTransform = typeof populateOptions.transform === 'function';\n  const transform = userSpecifiedTransform ? populateOptions.transform : noop;\n  if (Array.isArray(val)) {\n    // find logic\n    const ret = [];\n    const numValues = val.length;\n    for (let i = 0; i < numValues; ++i) {\n      let subdoc = val[i];\n      const _allIds = Array.isArray(allIds) ? allIds[i] : allIds;\n      if (!isPopulatedObject(subdoc) && (!populateOptions.retainNullValues || subdoc != null) && !userSpecifiedTransform) {\n        continue;\n      } else if (!populateOptions.retainNullValues && subdoc == null) {\n        continue;\n      } else if (userSpecifiedTransform) {\n        subdoc = transform(isPopulatedObject(subdoc) ? subdoc : null, _allIds);\n      }\n      maybeRemoveId(subdoc, assignmentOpts);\n      ret.push(subdoc);\n      if (assignmentOpts.originalLimit &&\n          ret.length >= assignmentOpts.originalLimit) {\n        break;\n      }\n    }\n\n    const rLen = ret.length;\n    // Since we don't want to have to create a new mongoosearray, make sure to\n    // modify the array in place\n    while (val.length > rLen) {\n      Array.prototype.pop.apply(val, []);\n    }\n    let i = 0;\n    if (utils.isMongooseArray(val)) {\n      for (i = 0; i < rLen; ++i) {\n        val.set(i, ret[i], true);\n      }\n    } else {\n      for (i = 0; i < rLen; ++i) {\n        val[i] = ret[i];\n      }\n    }\n    return val;\n  }\n\n  // findOne\n  if (isPopulatedObject(val) || utils.isPOJO(val)) {\n    maybeRemoveId(val, assignmentOpts);\n    return transform(val, allIds);\n  }\n  if (val instanceof Map) {\n    return val;\n  }\n\n  if (populateOptions.justOne === false) {\n    return [];\n  }\n\n  return val == null ? transform(val, allIds) : transform(null, allIds);\n}\n\n/**\n * Remove _id from `subdoc` if user specified \"lean\" query option\n * @param {Document} subdoc\n * @param {Object} assignmentOpts\n * @api private\n */\n\nfunction maybeRemoveId(subdoc, assignmentOpts) {\n  if (subdoc != null && assignmentOpts.excludeId) {\n    if (typeof subdoc.$__setValue === 'function') {\n      delete subdoc._doc._id;\n    } else {\n      delete subdoc._id;\n    }\n  }\n}\n\n/**\n * Determine if `obj` is something we can set a populated path to. Can be a\n * document, a lean document, or an array/map that contains docs.\n * @param {Any} obj\n * @api private\n */\n\nfunction isPopulatedObject(obj) {\n  if (obj == null) {\n    return false;\n  }\n\n  return Array.isArray(obj) ||\n    obj.$isMongooseMap ||\n    obj.$__ != null ||\n    leanPopulateMap.has(obj);\n}\n\nfunction noop(v) {\n  return v;\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbW9uZ29vc2UvbGliL2hlbHBlcnMvcG9wdWxhdGUvYXNzaWduVmFscy5qcyIsIm1hcHBpbmdzIjoiQUFBYTs7QUFFYixvQkFBb0IsbUJBQU8sQ0FBQyx1RUFBaUI7QUFDN0MsMEJBQTBCLG1CQUFPLENBQUMsb0dBQXFCO0FBQ3ZELG1DQUFtQyxtQkFBTyxDQUFDLHNIQUE4QjtBQUN6RSxZQUFZLG1CQUFPLENBQUMsZ0VBQVE7QUFDNUIsbUJBQW1CLG1CQUFPLENBQUMsc0ZBQWM7QUFDekMsd0JBQXdCLG1CQUFPLENBQUMsZ0dBQW1CO0FBQ25ELDBCQUEwQixtQkFBTyxDQUFDLG9HQUFxQjtBQUN2RCxrQ0FBa0MsbUJBQU8sQ0FBQyxvSEFBNkI7QUFDdkUsY0FBYyxtQkFBTyxDQUFDLGtEQUFPO0FBQzdCLGFBQWEsa0ZBQXVCO0FBQ3BDLGNBQWMsbUJBQU8sQ0FBQywrREFBYTtBQUNuQyxRQUFRLHNCQUFzQixFQUFFLG1CQUFPLENBQUMsd0VBQVk7O0FBRXBEO0FBQ0E7QUFDQSxzQ0FBc0M7QUFDdEM7QUFDQTtBQUNBLDBDQUEwQztBQUMxQztBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixnQkFBZ0I7QUFDdEM7QUFDQTs7QUFFQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxjQUFjLGlCQUFpQjtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixzQkFBc0I7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHdDQUF3QztBQUN4Qzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLEtBQUs7QUFDaEIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixXQUFXLFVBQVU7QUFDckIsV0FBVyxTQUFTO0FBQ3BCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsZUFBZTtBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixVQUFVO0FBQzVCO0FBQ0E7QUFDQSxNQUFNO0FBQ04sa0JBQWtCLFVBQVU7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxXQUFXLFVBQVU7QUFDckIsV0FBVyxRQUFRO0FBQ25CO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxLQUFLO0FBQ2hCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9hcHAxLy4vbm9kZV9tb2R1bGVzL21vbmdvb3NlL2xpYi9oZWxwZXJzL3BvcHVsYXRlL2Fzc2lnblZhbHMuanM/NDAzZSJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbmNvbnN0IE1vbmdvb3NlTWFwID0gcmVxdWlyZSgnLi4vLi4vdHlwZXMvbWFwJyk7XG5jb25zdCBTa2lwUG9wdWxhdGVWYWx1ZSA9IHJlcXVpcmUoJy4vc2tpcFBvcHVsYXRlVmFsdWUnKTtcbmNvbnN0IGFzc2lnblJhd0RvY3NUb0lkU3RydWN0dXJlID0gcmVxdWlyZSgnLi9hc3NpZ25SYXdEb2NzVG9JZFN0cnVjdHVyZScpO1xuY29uc3QgZ2V0ID0gcmVxdWlyZSgnLi4vZ2V0Jyk7XG5jb25zdCBnZXRWaXJ0dWFsID0gcmVxdWlyZSgnLi9nZXRWaXJ0dWFsJyk7XG5jb25zdCBsZWFuUG9wdWxhdGVNYXAgPSByZXF1aXJlKCcuL2xlYW5Qb3B1bGF0ZU1hcCcpO1xuY29uc3QgbG9va3VwTG9jYWxGaWVsZHMgPSByZXF1aXJlKCcuL2xvb2t1cExvY2FsRmllbGRzJyk7XG5jb25zdCBtYXJrQXJyYXlTdWJkb2NzUG9wdWxhdGVkID0gcmVxdWlyZSgnLi9tYXJrQXJyYXlTdWJkb2NzUG9wdWxhdGVkJyk7XG5jb25zdCBtcGF0aCA9IHJlcXVpcmUoJ21wYXRoJyk7XG5jb25zdCBzaWZ0ID0gcmVxdWlyZSgnc2lmdCcpLmRlZmF1bHQ7XG5jb25zdCB1dGlscyA9IHJlcXVpcmUoJy4uLy4uL3V0aWxzJyk7XG5jb25zdCB7IHBvcHVsYXRlTW9kZWxTeW1ib2wgfSA9IHJlcXVpcmUoJy4uL3N5bWJvbHMnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBhc3NpZ25WYWxzKG8pIHtcbiAgLy8gT3B0aW9ucyB0aGF0IGFyZW4ndCBleHBsaWNpdGx5IGxpc3RlZCBpbiBgcG9wdWxhdGVPcHRpb25zYFxuICBjb25zdCB1c2VyT3B0aW9ucyA9IE9iamVjdC5hc3NpZ24oe30sIGdldChvLCAnYWxsT3B0aW9ucy5vcHRpb25zLm9wdGlvbnMnKSwgZ2V0KG8sICdhbGxPcHRpb25zLm9wdGlvbnMnKSk7XG4gIC8vIGBvLm9wdGlvbnNgIGNvbnRhaW5zIG9wdGlvbnMgZXhwbGljaXRseSBsaXN0ZWQgaW4gYHBvcHVsYXRlT3B0aW9uc2AsIGxpa2VcbiAgLy8gYG1hdGNoYCBhbmQgYGxpbWl0YC5cbiAgY29uc3QgcG9wdWxhdGVPcHRpb25zID0gT2JqZWN0LmFzc2lnbih7fSwgby5vcHRpb25zLCB1c2VyT3B0aW9ucywge1xuICAgIGp1c3RPbmU6IG8uanVzdE9uZVxuICB9KTtcbiAgcG9wdWxhdGVPcHRpb25zLiRudWxsSWZOb3RGb3VuZCA9IG8uaXNWaXJ0dWFsO1xuICBjb25zdCBwb3B1bGF0ZWRNb2RlbCA9IG8ucG9wdWxhdGVkTW9kZWw7XG5cbiAgY29uc3Qgb3JpZ2luYWxJZHMgPSBbXS5jb25jYXQoby5yYXdJZHMpO1xuXG4gIC8vIHJlcGxhY2UgdGhlIG9yaWdpbmFsIGlkcyBpbiBvdXIgaW50ZXJtZWRpYXRlIF9pZHMgc3RydWN0dXJlXG4gIC8vIHdpdGggdGhlIGRvY3VtZW50cyBmb3VuZCBieSBxdWVyeVxuICBvLmFsbElkcyA9IFtdLmNvbmNhdChvLmFsbElkcyk7XG4gIGFzc2lnblJhd0RvY3NUb0lkU3RydWN0dXJlKG8ucmF3SWRzLCBvLnJhd0RvY3MsIG8ucmF3T3JkZXIsIHBvcHVsYXRlT3B0aW9ucyk7XG5cbiAgLy8gbm93IHVwZGF0ZSB0aGUgb3JpZ2luYWwgZG9jdW1lbnRzIGJlaW5nIHBvcHVsYXRlZCB1c2luZyB0aGVcbiAgLy8gcmVzdWx0IHN0cnVjdHVyZSB0aGF0IGNvbnRhaW5zIHJlYWwgZG9jdW1lbnRzLlxuICBjb25zdCBkb2NzID0gby5kb2NzO1xuICBjb25zdCByYXdJZHMgPSBvLnJhd0lkcztcbiAgY29uc3Qgb3B0aW9ucyA9IG8ub3B0aW9ucztcbiAgY29uc3QgY291bnQgPSBvLmNvdW50ICYmIG8uaXNWaXJ0dWFsO1xuICBsZXQgaTtcblxuICBmdW5jdGlvbiBzZXRWYWx1ZSh2YWwpIHtcbiAgICBpZiAoY291bnQpIHtcbiAgICAgIHJldHVybiB2YWw7XG4gICAgfVxuICAgIGlmICh2YWwgaW5zdGFuY2VvZiBTa2lwUG9wdWxhdGVWYWx1ZSkge1xuICAgICAgcmV0dXJuIHZhbC52YWw7XG4gICAgfVxuICAgIGlmICh2YWwgPT09IHZvaWQgMCkge1xuICAgICAgcmV0dXJuIHZhbDtcbiAgICB9XG5cbiAgICBjb25zdCBfYWxsSWRzID0gby5hbGxJZHNbaV07XG5cbiAgICBpZiAoby5wYXRoLmVuZHNXaXRoKCcuJConKSkge1xuICAgICAgLy8gU2tpcCBtYXBzIHJlOiBnaC0xMjQ5NFxuICAgICAgcmV0dXJuIHZhbHVlRmlsdGVyKHZhbCwgb3B0aW9ucywgcG9wdWxhdGVPcHRpb25zLCBfYWxsSWRzKTtcbiAgICB9XG5cbiAgICBpZiAoby5qdXN0T25lID09PSB0cnVlICYmIEFycmF5LmlzQXJyYXkodmFsKSkge1xuICAgICAgLy8gTWlnaHQgYmUgYW4gZW1iZWRkZWQgZGlzY3JpbWluYXRvciAocmU6IGdoLTkyNDQpIHdpdGggbXVsdGlwbGUgbW9kZWxzLCBzbyBtYWtlIHN1cmUgdG8gcGljayB0aGUgcmlnaHRcbiAgICAgIC8vIG1vZGVsIGJlZm9yZSBhc3NpZ25pbmcuXG4gICAgICBjb25zdCByZXQgPSBbXTtcbiAgICAgIGZvciAoY29uc3QgZG9jIG9mIHZhbCkge1xuICAgICAgICBjb25zdCBfZG9jUG9wdWxhdGVkTW9kZWwgPSBsZWFuUG9wdWxhdGVNYXAuZ2V0KGRvYyk7XG4gICAgICAgIGlmIChfZG9jUG9wdWxhdGVkTW9kZWwgPT0gbnVsbCB8fCBfZG9jUG9wdWxhdGVkTW9kZWwgPT09IHBvcHVsYXRlZE1vZGVsKSB7XG4gICAgICAgICAgcmV0LnB1c2goZG9jKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgLy8gU2luY2Ugd2UgZG9uJ3Qgd2FudCB0byBoYXZlIHRvIGNyZWF0ZSBhIG5ldyBtb25nb29zZWFycmF5LCBtYWtlIHN1cmUgdG9cbiAgICAgIC8vIG1vZGlmeSB0aGUgYXJyYXkgaW4gcGxhY2VcbiAgICAgIHdoaWxlICh2YWwubGVuZ3RoID4gcmV0Lmxlbmd0aCkge1xuICAgICAgICBBcnJheS5wcm90b3R5cGUucG9wLmFwcGx5KHZhbCwgW10pO1xuICAgICAgfVxuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCByZXQubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgdmFsW2ldID0gcmV0W2ldO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdmFsdWVGaWx0ZXIodmFsWzBdLCBvcHRpb25zLCBwb3B1bGF0ZU9wdGlvbnMsIF9hbGxJZHMpO1xuICAgIH0gZWxzZSBpZiAoby5qdXN0T25lID09PSBmYWxzZSAmJiAhQXJyYXkuaXNBcnJheSh2YWwpKSB7XG4gICAgICByZXR1cm4gdmFsdWVGaWx0ZXIoW3ZhbF0sIG9wdGlvbnMsIHBvcHVsYXRlT3B0aW9ucywgX2FsbElkcyk7XG4gICAgfVxuICAgIHJldHVybiB2YWx1ZUZpbHRlcih2YWwsIG9wdGlvbnMsIHBvcHVsYXRlT3B0aW9ucywgX2FsbElkcyk7XG4gIH1cblxuICBmb3IgKGkgPSAwOyBpIDwgZG9jcy5sZW5ndGg7ICsraSkge1xuICAgIGNvbnN0IF9wYXRoID0gby5wYXRoLmVuZHNXaXRoKCcuJConKSA/IG8ucGF0aC5zbGljZSgwLCAtMykgOiBvLnBhdGg7XG4gICAgY29uc3QgZXhpc3RpbmdWYWwgPSBtcGF0aC5nZXQoX3BhdGgsIGRvY3NbaV0sIGxvb2t1cExvY2FsRmllbGRzKTtcbiAgICBpZiAoZXhpc3RpbmdWYWwgPT0gbnVsbCAmJiAhZ2V0VmlydHVhbChvLm9yaWdpbmFsTW9kZWwuc2NoZW1hLCBfcGF0aCkpIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIGxldCB2YWx1ZVRvU2V0O1xuICAgIGlmIChjb3VudCkge1xuICAgICAgdmFsdWVUb1NldCA9IG51bURvY3MocmF3SWRzW2ldKTtcbiAgICB9IGVsc2UgaWYgKEFycmF5LmlzQXJyYXkoby5tYXRjaCkpIHtcbiAgICAgIHZhbHVlVG9TZXQgPSBBcnJheS5pc0FycmF5KHJhd0lkc1tpXSkgP1xuICAgICAgICByYXdJZHNbaV0uZmlsdGVyKHNpZnQoby5tYXRjaFtpXSkpIDpcbiAgICAgICAgW3Jhd0lkc1tpXV0uZmlsdGVyKHNpZnQoby5tYXRjaFtpXSkpWzBdO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YWx1ZVRvU2V0ID0gcmF3SWRzW2ldO1xuICAgIH1cblxuICAgIC8vIElmIHdlJ3JlIHBvcHVsYXRpbmcgYSBtYXAsIHRoZSBleGlzdGluZyB2YWx1ZSB3aWxsIGJlIGFuIG9iamVjdCwgc29cbiAgICAvLyB3ZSBuZWVkIHRvIHRyYW5zZm9ybSBhZ2FpblxuICAgIGNvbnN0IG9yaWdpbmFsU2NoZW1hID0gby5vcmlnaW5hbE1vZGVsLnNjaGVtYTtcbiAgICBjb25zdCBpc0RvYyA9IGdldChkb2NzW2ldLCAnJF9fJywgbnVsbCkgIT0gbnVsbDtcbiAgICBsZXQgaXNNYXAgPSBpc0RvYyA/XG4gICAgICBleGlzdGluZ1ZhbCBpbnN0YW5jZW9mIE1hcCA6XG4gICAgICB1dGlscy5pc1BPSk8oZXhpc3RpbmdWYWwpO1xuICAgIC8vIElmIHdlIHBhc3MgdGhlIGZpcnN0IGNoZWNrLCBhbHNvIG1ha2Ugc3VyZSB0aGUgbG9jYWwgZmllbGQncyBzY2hlbWF0eXBlXG4gICAgLy8gaXMgbWFwIChyZTogZ2gtNjQ2MClcbiAgICBpc01hcCA9IGlzTWFwICYmIGdldChvcmlnaW5hbFNjaGVtYS5fZ2V0U2NoZW1hKF9wYXRoKSwgJyRpc1NjaGVtYU1hcCcpO1xuICAgIGlmICghby5pc1ZpcnR1YWwgJiYgaXNNYXApIHtcbiAgICAgIGNvbnN0IF9rZXlzID0gZXhpc3RpbmdWYWwgaW5zdGFuY2VvZiBNYXAgP1xuICAgICAgICBBcnJheS5mcm9tKGV4aXN0aW5nVmFsLmtleXMoKSkgOlxuICAgICAgICBPYmplY3Qua2V5cyhleGlzdGluZ1ZhbCk7XG4gICAgICB2YWx1ZVRvU2V0ID0gdmFsdWVUb1NldC5yZWR1Y2UoKGN1ciwgdiwgaSkgPT4ge1xuICAgICAgICBjdXIuc2V0KF9rZXlzW2ldLCB2KTtcbiAgICAgICAgcmV0dXJuIGN1cjtcbiAgICAgIH0sIG5ldyBNYXAoKSk7XG4gICAgfVxuXG4gICAgaWYgKGlzRG9jICYmIEFycmF5LmlzQXJyYXkodmFsdWVUb1NldCkpIHtcbiAgICAgIGZvciAoY29uc3QgdmFsIG9mIHZhbHVlVG9TZXQpIHtcbiAgICAgICAgaWYgKHZhbCAhPSBudWxsICYmIHZhbC4kX18gIT0gbnVsbCkge1xuICAgICAgICAgIHZhbC4kX18ucGFyZW50ID0gZG9jc1tpXTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoaXNEb2MgJiYgdmFsdWVUb1NldCAhPSBudWxsICYmIHZhbHVlVG9TZXQuJF9fICE9IG51bGwpIHtcbiAgICAgIHZhbHVlVG9TZXQuJF9fLnBhcmVudCA9IGRvY3NbaV07XG4gICAgfVxuXG4gICAgaWYgKG8uaXNWaXJ0dWFsICYmIGlzRG9jKSB7XG4gICAgICBkb2NzW2ldLiRwb3B1bGF0ZWQoX3BhdGgsIG8uanVzdE9uZSA/IG9yaWdpbmFsSWRzWzBdIDogb3JpZ2luYWxJZHMsIG8uYWxsT3B0aW9ucyk7XG4gICAgICAvLyBJZiB2aXJ0dWFsIHBvcHVsYXRlIGFuZCBkb2MgaXMgYWxyZWFkeSBpbml0LWVkLCBuZWVkIHRvIHdhbGsgdGhyb3VnaFxuICAgICAgLy8gdGhlIGFjdHVhbCBkb2MgdG8gc2V0IHJhdGhlciB0aGFuIHNldHRpbmcgYF9kb2NgIGRpcmVjdGx5XG4gICAgICBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZVRvU2V0KSkge1xuICAgICAgICB2YWx1ZVRvU2V0ID0gdmFsdWVUb1NldC5tYXAodiA9PiB2ID09IG51bGwgPyB2b2lkIDAgOiB2KTtcbiAgICAgIH1cbiAgICAgIG1wYXRoLnNldChfcGF0aCwgdmFsdWVUb1NldCwgZG9jc1tpXSwgdm9pZCAwLCBzZXRWYWx1ZSwgZmFsc2UpO1xuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgY29uc3QgcGFydHMgPSBfcGF0aC5zcGxpdCgnLicpO1xuICAgIGxldCBjdXIgPSBkb2NzW2ldO1xuICAgIGNvbnN0IGN1clBhdGggPSBwYXJ0c1swXTtcbiAgICBmb3IgKGxldCBqID0gMDsgaiA8IHBhcnRzLmxlbmd0aCAtIDE7ICsraikge1xuICAgICAgLy8gSWYgd2UgZ2V0IHRvIGFuIGFycmF5IHdpdGggYSBkb3R0ZWQgcGF0aCwgbGlrZSBgYXJyLmZvb2AsIGRvbid0IHNldFxuICAgICAgLy8gYGZvb2Agb24gdGhlIGFycmF5LlxuICAgICAgaWYgKEFycmF5LmlzQXJyYXkoY3VyKSAmJiAhdXRpbHMuaXNBcnJheUluZGV4KHBhcnRzW2pdKSkge1xuICAgICAgICBicmVhaztcbiAgICAgIH1cblxuICAgICAgaWYgKHBhcnRzW2pdID09PSAnJConKSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuXG4gICAgICBpZiAoY3VyW3BhcnRzW2pdXSA9PSBudWxsKSB7XG4gICAgICAgIC8vIElmIG5vdGhpbmcgdG8gc2V0LCBhdm9pZCBjcmVhdGluZyBhbiB1bm5lY2Vzc2FyeSBhcnJheS4gT3RoZXJ3aXNlXG4gICAgICAgIC8vIHdlJ2xsIGVuZCB1cCB3aXRoIGEgc2luZ2xlIGRvYyBpbiB0aGUgYXJyYXkgd2l0aCBvbmx5IGRlZmF1bHRzLlxuICAgICAgICAvLyBTZWUgZ2gtODM0MiwgZ2gtODQ1NVxuICAgICAgICBjb25zdCBzY2hlbWF0eXBlID0gb3JpZ2luYWxTY2hlbWEuX2dldFNjaGVtYShjdXJQYXRoKTtcbiAgICAgICAgaWYgKHZhbHVlVG9TZXQgPT0gbnVsbCAmJiBzY2hlbWF0eXBlICE9IG51bGwgJiYgc2NoZW1hdHlwZS4kaXNNb25nb29zZUFycmF5KSB7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgY3VyW3BhcnRzW2pdXSA9IHt9O1xuICAgICAgfVxuICAgICAgY3VyID0gY3VyW3BhcnRzW2pdXTtcbiAgICAgIC8vIElmIHRoZSBwcm9wZXJ0eSBpbiBNb25nb0RCIGlzIGEgcHJpbWl0aXZlLCB3ZSB3b24ndCBiZSBhYmxlIHRvIHBvcHVsYXRlXG4gICAgICAvLyB0aGUgbmVzdGVkIHBhdGgsIHNvIHNraXAgaXQuIFNlZSBnaC03NTQ1XG4gICAgICBpZiAodHlwZW9mIGN1ciAhPT0gJ29iamVjdCcpIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChkb2NzW2ldLiRfXykge1xuICAgICAgby5hbGxPcHRpb25zLm9wdGlvbnNbcG9wdWxhdGVNb2RlbFN5bWJvbF0gPSBvLmFsbE9wdGlvbnMubW9kZWw7XG4gICAgICBkb2NzW2ldLiRwb3B1bGF0ZWQoX3BhdGgsIG8udW5wb3B1bGF0ZWRWYWx1ZXNbaV0sIG8uYWxsT3B0aW9ucy5vcHRpb25zKTtcblxuICAgICAgaWYgKHZhbHVlVG9TZXQgIT0gbnVsbCAmJiB2YWx1ZVRvU2V0LiRfXyAhPSBudWxsKSB7XG4gICAgICAgIHZhbHVlVG9TZXQuJF9fLndhc1BvcHVsYXRlZCA9IHsgdmFsdWU6IG8udW5wb3B1bGF0ZWRWYWx1ZXNbaV0gfTtcbiAgICAgIH1cblxuICAgICAgaWYgKHZhbHVlVG9TZXQgaW5zdGFuY2VvZiBNYXAgJiYgIXZhbHVlVG9TZXQuJGlzTW9uZ29vc2VNYXApIHtcbiAgICAgICAgdmFsdWVUb1NldCA9IG5ldyBNb25nb29zZU1hcCh2YWx1ZVRvU2V0LCBfcGF0aCwgZG9jc1tpXSwgZG9jc1tpXS5zY2hlbWEucGF0aChfcGF0aCkuJF9fc2NoZW1hVHlwZSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gSWYgbGVhbiwgbmVlZCB0byBjaGVjayB0aGF0IGVhY2ggaW5kaXZpZHVhbCB2aXJ0dWFsIHJlc3BlY3RzXG4gICAgLy8gYGp1c3RPbmVgLCBiZWNhdXNlIHlvdSBtYXkgaGF2ZSBhIHBvcHVsYXRlZCB2aXJ0dWFsIHdpdGggYGp1c3RPbmVgXG4gICAgLy8gdW5kZXJuZWF0aCBhbiBhcnJheS4gU2VlIGdoLTY4NjdcbiAgICBtcGF0aC5zZXQoX3BhdGgsIHZhbHVlVG9TZXQsIGRvY3NbaV0sIGxvb2t1cExvY2FsRmllbGRzLCBzZXRWYWx1ZSwgZmFsc2UpO1xuXG4gICAgaWYgKGRvY3NbaV0uJF9fKSB7XG4gICAgICBtYXJrQXJyYXlTdWJkb2NzUG9wdWxhdGVkKGRvY3NbaV0sIFtvLmFsbE9wdGlvbnMub3B0aW9uc10pO1xuICAgIH1cbiAgfVxufTtcblxuZnVuY3Rpb24gbnVtRG9jcyh2KSB7XG4gIGlmIChBcnJheS5pc0FycmF5KHYpKSB7XG4gICAgLy8gSWYgc2V0dGluZyB1bmRlcm5lYXRoIGFuIGFycmF5IG9mIHBvcHVsYXRlZCBzdWJkb2NzLCB3ZSBtYXkgaGF2ZSBhblxuICAgIC8vIGFycmF5IG9mIGFycmF5cy4gU2VlIGdoLTc1NzNcbiAgICBpZiAodi5zb21lKGVsID0+IEFycmF5LmlzQXJyYXkoZWwpIHx8IGVsID09PSBudWxsKSkge1xuICAgICAgcmV0dXJuIHYubWFwKGVsID0+IHtcbiAgICAgICAgaWYgKGVsID09IG51bGwpIHtcbiAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShlbCkpIHtcbiAgICAgICAgICByZXR1cm4gZWwuZmlsdGVyKGVsID0+IGVsICE9IG51bGwpLmxlbmd0aDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gMTtcbiAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gdi5maWx0ZXIoZWwgPT4gZWwgIT0gbnVsbCkubGVuZ3RoO1xuICB9XG4gIHJldHVybiB2ID09IG51bGwgPyAwIDogMTtcbn1cblxuLyoqXG4gKiAxKSBBcHBseSBiYWNrd2FyZHMgY29tcGF0aWJsZSBmaW5kL2ZpbmRPbmUgYmVoYXZpb3IgdG8gc3ViIGRvY3VtZW50c1xuICpcbiAqICAgIGZpbmQgbG9naWM6XG4gKiAgICAgIGEpIGZpbHRlciBvdXQgbm9uLWRvY3VtZW50c1xuICogICAgICBiKSByZW1vdmUgX2lkIGZyb20gc3ViIGRvY3Mgd2hlbiB1c2VyIHNwZWNpZmllZFxuICpcbiAqICAgIGZpbmRPbmVcbiAqICAgICAgYSkgaWYgbm8gZG9jIGZvdW5kLCBzZXQgdG8gbnVsbFxuICogICAgICBiKSByZW1vdmUgX2lkIGZyb20gc3ViIGRvY3Mgd2hlbiB1c2VyIHNwZWNpZmllZFxuICpcbiAqIDIpIFJlbW92ZSBfaWRzIHdoZW4gc3BlY2lmaWVkIGJ5IHVzZXJzIHF1ZXJ5LlxuICpcbiAqIGJhY2tncm91bmQ6XG4gKiBfaWRzIGFyZSBsZWZ0IGluIHRoZSBxdWVyeSBldmVuIHdoZW4gdXNlciBleGNsdWRlcyB0aGVtIHNvXG4gKiB0aGF0IHBvcHVsYXRpb24gbWFwcGluZyBjYW4gb2NjdXIuXG4gKiBAcGFyYW0ge0FueX0gdmFsXG4gKiBAcGFyYW0ge09iamVjdH0gYXNzaWdubWVudE9wdHNcbiAqIEBwYXJhbSB7T2JqZWN0fSBwb3B1bGF0ZU9wdGlvbnNcbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtwb3B1bGF0ZU9wdGlvbnMudHJhbnNmb3JtXVxuICogQHBhcmFtIHtCb29sZWFufSBhbGxJZHNcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmZ1bmN0aW9uIHZhbHVlRmlsdGVyKHZhbCwgYXNzaWdubWVudE9wdHMsIHBvcHVsYXRlT3B0aW9ucywgYWxsSWRzKSB7XG4gIGNvbnN0IHVzZXJTcGVjaWZpZWRUcmFuc2Zvcm0gPSB0eXBlb2YgcG9wdWxhdGVPcHRpb25zLnRyYW5zZm9ybSA9PT0gJ2Z1bmN0aW9uJztcbiAgY29uc3QgdHJhbnNmb3JtID0gdXNlclNwZWNpZmllZFRyYW5zZm9ybSA/IHBvcHVsYXRlT3B0aW9ucy50cmFuc2Zvcm0gOiBub29wO1xuICBpZiAoQXJyYXkuaXNBcnJheSh2YWwpKSB7XG4gICAgLy8gZmluZCBsb2dpY1xuICAgIGNvbnN0IHJldCA9IFtdO1xuICAgIGNvbnN0IG51bVZhbHVlcyA9IHZhbC5sZW5ndGg7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBudW1WYWx1ZXM7ICsraSkge1xuICAgICAgbGV0IHN1YmRvYyA9IHZhbFtpXTtcbiAgICAgIGNvbnN0IF9hbGxJZHMgPSBBcnJheS5pc0FycmF5KGFsbElkcykgPyBhbGxJZHNbaV0gOiBhbGxJZHM7XG4gICAgICBpZiAoIWlzUG9wdWxhdGVkT2JqZWN0KHN1YmRvYykgJiYgKCFwb3B1bGF0ZU9wdGlvbnMucmV0YWluTnVsbFZhbHVlcyB8fCBzdWJkb2MgIT0gbnVsbCkgJiYgIXVzZXJTcGVjaWZpZWRUcmFuc2Zvcm0pIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9IGVsc2UgaWYgKCFwb3B1bGF0ZU9wdGlvbnMucmV0YWluTnVsbFZhbHVlcyAmJiBzdWJkb2MgPT0gbnVsbCkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH0gZWxzZSBpZiAodXNlclNwZWNpZmllZFRyYW5zZm9ybSkge1xuICAgICAgICBzdWJkb2MgPSB0cmFuc2Zvcm0oaXNQb3B1bGF0ZWRPYmplY3Qoc3ViZG9jKSA/IHN1YmRvYyA6IG51bGwsIF9hbGxJZHMpO1xuICAgICAgfVxuICAgICAgbWF5YmVSZW1vdmVJZChzdWJkb2MsIGFzc2lnbm1lbnRPcHRzKTtcbiAgICAgIHJldC5wdXNoKHN1YmRvYyk7XG4gICAgICBpZiAoYXNzaWdubWVudE9wdHMub3JpZ2luYWxMaW1pdCAmJlxuICAgICAgICAgIHJldC5sZW5ndGggPj0gYXNzaWdubWVudE9wdHMub3JpZ2luYWxMaW1pdCkge1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG5cbiAgICBjb25zdCByTGVuID0gcmV0Lmxlbmd0aDtcbiAgICAvLyBTaW5jZSB3ZSBkb24ndCB3YW50IHRvIGhhdmUgdG8gY3JlYXRlIGEgbmV3IG1vbmdvb3NlYXJyYXksIG1ha2Ugc3VyZSB0b1xuICAgIC8vIG1vZGlmeSB0aGUgYXJyYXkgaW4gcGxhY2VcbiAgICB3aGlsZSAodmFsLmxlbmd0aCA+IHJMZW4pIHtcbiAgICAgIEFycmF5LnByb3RvdHlwZS5wb3AuYXBwbHkodmFsLCBbXSk7XG4gICAgfVxuICAgIGxldCBpID0gMDtcbiAgICBpZiAodXRpbHMuaXNNb25nb29zZUFycmF5KHZhbCkpIHtcbiAgICAgIGZvciAoaSA9IDA7IGkgPCByTGVuOyArK2kpIHtcbiAgICAgICAgdmFsLnNldChpLCByZXRbaV0sIHRydWUpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBmb3IgKGkgPSAwOyBpIDwgckxlbjsgKytpKSB7XG4gICAgICAgIHZhbFtpXSA9IHJldFtpXTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHZhbDtcbiAgfVxuXG4gIC8vIGZpbmRPbmVcbiAgaWYgKGlzUG9wdWxhdGVkT2JqZWN0KHZhbCkgfHwgdXRpbHMuaXNQT0pPKHZhbCkpIHtcbiAgICBtYXliZVJlbW92ZUlkKHZhbCwgYXNzaWdubWVudE9wdHMpO1xuICAgIHJldHVybiB0cmFuc2Zvcm0odmFsLCBhbGxJZHMpO1xuICB9XG4gIGlmICh2YWwgaW5zdGFuY2VvZiBNYXApIHtcbiAgICByZXR1cm4gdmFsO1xuICB9XG5cbiAgaWYgKHBvcHVsYXRlT3B0aW9ucy5qdXN0T25lID09PSBmYWxzZSkge1xuICAgIHJldHVybiBbXTtcbiAgfVxuXG4gIHJldHVybiB2YWwgPT0gbnVsbCA/IHRyYW5zZm9ybSh2YWwsIGFsbElkcykgOiB0cmFuc2Zvcm0obnVsbCwgYWxsSWRzKTtcbn1cblxuLyoqXG4gKiBSZW1vdmUgX2lkIGZyb20gYHN1YmRvY2AgaWYgdXNlciBzcGVjaWZpZWQgXCJsZWFuXCIgcXVlcnkgb3B0aW9uXG4gKiBAcGFyYW0ge0RvY3VtZW50fSBzdWJkb2NcbiAqIEBwYXJhbSB7T2JqZWN0fSBhc3NpZ25tZW50T3B0c1xuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZnVuY3Rpb24gbWF5YmVSZW1vdmVJZChzdWJkb2MsIGFzc2lnbm1lbnRPcHRzKSB7XG4gIGlmIChzdWJkb2MgIT0gbnVsbCAmJiBhc3NpZ25tZW50T3B0cy5leGNsdWRlSWQpIHtcbiAgICBpZiAodHlwZW9mIHN1YmRvYy4kX19zZXRWYWx1ZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgZGVsZXRlIHN1YmRvYy5fZG9jLl9pZDtcbiAgICB9IGVsc2Uge1xuICAgICAgZGVsZXRlIHN1YmRvYy5faWQ7XG4gICAgfVxuICB9XG59XG5cbi8qKlxuICogRGV0ZXJtaW5lIGlmIGBvYmpgIGlzIHNvbWV0aGluZyB3ZSBjYW4gc2V0IGEgcG9wdWxhdGVkIHBhdGggdG8uIENhbiBiZSBhXG4gKiBkb2N1bWVudCwgYSBsZWFuIGRvY3VtZW50LCBvciBhbiBhcnJheS9tYXAgdGhhdCBjb250YWlucyBkb2NzLlxuICogQHBhcmFtIHtBbnl9IG9ialxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZnVuY3Rpb24gaXNQb3B1bGF0ZWRPYmplY3Qob2JqKSB7XG4gIGlmIChvYmogPT0gbnVsbCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHJldHVybiBBcnJheS5pc0FycmF5KG9iaikgfHxcbiAgICBvYmouJGlzTW9uZ29vc2VNYXAgfHxcbiAgICBvYmouJF9fICE9IG51bGwgfHxcbiAgICBsZWFuUG9wdWxhdGVNYXAuaGFzKG9iaik7XG59XG5cbmZ1bmN0aW9uIG5vb3Aodikge1xuICByZXR1cm4gdjtcbn1cbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/mongoose/lib/helpers/populate/assignVals.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/mongoose/lib/helpers/populate/createPopulateQueryFilter.js":
/*!*********************************************************************************!*\
  !*** ./node_modules/mongoose/lib/helpers/populate/createPopulateQueryFilter.js ***!
  \*********************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\n\nconst SkipPopulateValue = __webpack_require__(/*! ./skipPopulateValue */ \"(ssr)/./node_modules/mongoose/lib/helpers/populate/skipPopulateValue.js\");\nconst parentPaths = __webpack_require__(/*! ../path/parentPaths */ \"(ssr)/./node_modules/mongoose/lib/helpers/path/parentPaths.js\");\nconst { trusted } = __webpack_require__(/*! ../query/trusted */ \"(ssr)/./node_modules/mongoose/lib/helpers/query/trusted.js\");\nconst hasDollarKeys = __webpack_require__(/*! ../query/hasDollarKeys */ \"(ssr)/./node_modules/mongoose/lib/helpers/query/hasDollarKeys.js\");\n\nmodule.exports = function createPopulateQueryFilter(ids, _match, _foreignField, model, skipInvalidIds) {\n  const match = _formatMatch(_match);\n\n  if (_foreignField.size === 1) {\n    const foreignField = Array.from(_foreignField)[0];\n    const foreignSchemaType = model.schema.path(foreignField);\n    if (foreignField !== '_id' || !match['_id']) {\n      ids = _filterInvalidIds(ids, foreignSchemaType, skipInvalidIds);\n      match[foreignField] = trusted({ $in: ids });\n    } else if (foreignField === '_id' && match['_id']) {\n      const userSpecifiedMatch = hasDollarKeys(match[foreignField]) ?\n        match[foreignField] :\n        { $eq: match[foreignField] };\n      match[foreignField] = { ...trusted({ $in: ids }), ...userSpecifiedMatch };\n    }\n\n    const _parentPaths = parentPaths(foreignField);\n    for (let i = 0; i < _parentPaths.length - 1; ++i) {\n      const cur = _parentPaths[i];\n      if (match[cur] != null && match[cur].$elemMatch != null) {\n        match[cur].$elemMatch[foreignField.slice(cur.length + 1)] = trusted({ $in: ids });\n        delete match[foreignField];\n        break;\n      }\n    }\n  } else {\n    const $or = [];\n    if (Array.isArray(match.$or)) {\n      match.$and = [{ $or: match.$or }, { $or: $or }];\n      delete match.$or;\n    } else {\n      match.$or = $or;\n    }\n    for (const foreignField of _foreignField) {\n      if (foreignField !== '_id' || !match['_id']) {\n        const foreignSchemaType = model.schema.path(foreignField);\n        ids = _filterInvalidIds(ids, foreignSchemaType, skipInvalidIds);\n        $or.push({ [foreignField]: { $in: ids } });\n      } else if (foreignField === '_id' && match['_id']) {\n        const userSpecifiedMatch = hasDollarKeys(match[foreignField]) ?\n          match[foreignField] :\n          { $eq: match[foreignField] };\n        match[foreignField] = { ...trusted({ $in: ids }), ...userSpecifiedMatch };\n      }\n    }\n  }\n\n  return match;\n};\n\n/**\n * Optionally filter out invalid ids that don't conform to foreign field's schema\n * to avoid cast errors (gh-7706)\n * @param {Array} ids\n * @param {SchemaType} foreignSchemaType\n * @param {Boolean} [skipInvalidIds]\n * @api private\n */\n\nfunction _filterInvalidIds(ids, foreignSchemaType, skipInvalidIds) {\n  ids = ids.filter(v => !(v instanceof SkipPopulateValue));\n  if (!skipInvalidIds) {\n    return ids;\n  }\n  return ids.filter(id => {\n    try {\n      foreignSchemaType.cast(id);\n      return true;\n    } catch (err) {\n      return false;\n    }\n  });\n}\n\n/**\n * Format `mod.match` given that it may be an array that we need to $or if\n * the client has multiple docs with match functions\n * @param {Array|Any} match\n * @api private\n */\n\nfunction _formatMatch(match) {\n  if (Array.isArray(match)) {\n    if (match.length > 1) {\n      return { $or: [].concat(match.map(m => Object.assign({}, m))) };\n    }\n    return Object.assign({}, match[0]);\n  }\n  return Object.assign({}, match);\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbW9uZ29vc2UvbGliL2hlbHBlcnMvcG9wdWxhdGUvY3JlYXRlUG9wdWxhdGVRdWVyeUZpbHRlci5qcyIsIm1hcHBpbmdzIjoiQUFBYTs7QUFFYiwwQkFBMEIsbUJBQU8sQ0FBQyxvR0FBcUI7QUFDdkQsb0JBQW9CLG1CQUFPLENBQUMsMEZBQXFCO0FBQ2pELFFBQVEsVUFBVSxFQUFFLG1CQUFPLENBQUMsb0ZBQWtCO0FBQzlDLHNCQUFzQixtQkFBTyxDQUFDLGdHQUF3Qjs7QUFFdEQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDLFVBQVU7QUFDaEQsTUFBTTtBQUNOO0FBQ0E7QUFDQSxVQUFVO0FBQ1YsOEJBQThCLGFBQWEsVUFBVTtBQUNyRDs7QUFFQTtBQUNBLG9CQUFvQiw2QkFBNkI7QUFDakQ7QUFDQTtBQUNBLDhFQUE4RSxVQUFVO0FBQ3hGO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQSxzQkFBc0IsZ0JBQWdCLElBQUksVUFBVTtBQUNwRDtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsa0JBQWtCLFlBQVk7QUFDakQsUUFBUTtBQUNSO0FBQ0E7QUFDQSxZQUFZO0FBQ1osZ0NBQWdDLGFBQWEsVUFBVTtBQUN2RDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE9BQU87QUFDbEIsV0FBVyxZQUFZO0FBQ3ZCLFdBQVcsU0FBUztBQUNwQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsV0FBVztBQUN0QjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsOENBQThDO0FBQzdEO0FBQ0EsMkJBQTJCO0FBQzNCO0FBQ0EseUJBQXlCO0FBQ3pCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vYXBwMS8uL25vZGVfbW9kdWxlcy9tb25nb29zZS9saWIvaGVscGVycy9wb3B1bGF0ZS9jcmVhdGVQb3B1bGF0ZVF1ZXJ5RmlsdGVyLmpzPzk5YWMiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG5jb25zdCBTa2lwUG9wdWxhdGVWYWx1ZSA9IHJlcXVpcmUoJy4vc2tpcFBvcHVsYXRlVmFsdWUnKTtcbmNvbnN0IHBhcmVudFBhdGhzID0gcmVxdWlyZSgnLi4vcGF0aC9wYXJlbnRQYXRocycpO1xuY29uc3QgeyB0cnVzdGVkIH0gPSByZXF1aXJlKCcuLi9xdWVyeS90cnVzdGVkJyk7XG5jb25zdCBoYXNEb2xsYXJLZXlzID0gcmVxdWlyZSgnLi4vcXVlcnkvaGFzRG9sbGFyS2V5cycpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGNyZWF0ZVBvcHVsYXRlUXVlcnlGaWx0ZXIoaWRzLCBfbWF0Y2gsIF9mb3JlaWduRmllbGQsIG1vZGVsLCBza2lwSW52YWxpZElkcykge1xuICBjb25zdCBtYXRjaCA9IF9mb3JtYXRNYXRjaChfbWF0Y2gpO1xuXG4gIGlmIChfZm9yZWlnbkZpZWxkLnNpemUgPT09IDEpIHtcbiAgICBjb25zdCBmb3JlaWduRmllbGQgPSBBcnJheS5mcm9tKF9mb3JlaWduRmllbGQpWzBdO1xuICAgIGNvbnN0IGZvcmVpZ25TY2hlbWFUeXBlID0gbW9kZWwuc2NoZW1hLnBhdGgoZm9yZWlnbkZpZWxkKTtcbiAgICBpZiAoZm9yZWlnbkZpZWxkICE9PSAnX2lkJyB8fCAhbWF0Y2hbJ19pZCddKSB7XG4gICAgICBpZHMgPSBfZmlsdGVySW52YWxpZElkcyhpZHMsIGZvcmVpZ25TY2hlbWFUeXBlLCBza2lwSW52YWxpZElkcyk7XG4gICAgICBtYXRjaFtmb3JlaWduRmllbGRdID0gdHJ1c3RlZCh7ICRpbjogaWRzIH0pO1xuICAgIH0gZWxzZSBpZiAoZm9yZWlnbkZpZWxkID09PSAnX2lkJyAmJiBtYXRjaFsnX2lkJ10pIHtcbiAgICAgIGNvbnN0IHVzZXJTcGVjaWZpZWRNYXRjaCA9IGhhc0RvbGxhcktleXMobWF0Y2hbZm9yZWlnbkZpZWxkXSkgP1xuICAgICAgICBtYXRjaFtmb3JlaWduRmllbGRdIDpcbiAgICAgICAgeyAkZXE6IG1hdGNoW2ZvcmVpZ25GaWVsZF0gfTtcbiAgICAgIG1hdGNoW2ZvcmVpZ25GaWVsZF0gPSB7IC4uLnRydXN0ZWQoeyAkaW46IGlkcyB9KSwgLi4udXNlclNwZWNpZmllZE1hdGNoIH07XG4gICAgfVxuXG4gICAgY29uc3QgX3BhcmVudFBhdGhzID0gcGFyZW50UGF0aHMoZm9yZWlnbkZpZWxkKTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IF9wYXJlbnRQYXRocy5sZW5ndGggLSAxOyArK2kpIHtcbiAgICAgIGNvbnN0IGN1ciA9IF9wYXJlbnRQYXRoc1tpXTtcbiAgICAgIGlmIChtYXRjaFtjdXJdICE9IG51bGwgJiYgbWF0Y2hbY3VyXS4kZWxlbU1hdGNoICE9IG51bGwpIHtcbiAgICAgICAgbWF0Y2hbY3VyXS4kZWxlbU1hdGNoW2ZvcmVpZ25GaWVsZC5zbGljZShjdXIubGVuZ3RoICsgMSldID0gdHJ1c3RlZCh7ICRpbjogaWRzIH0pO1xuICAgICAgICBkZWxldGUgbWF0Y2hbZm9yZWlnbkZpZWxkXTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGNvbnN0ICRvciA9IFtdO1xuICAgIGlmIChBcnJheS5pc0FycmF5KG1hdGNoLiRvcikpIHtcbiAgICAgIG1hdGNoLiRhbmQgPSBbeyAkb3I6IG1hdGNoLiRvciB9LCB7ICRvcjogJG9yIH1dO1xuICAgICAgZGVsZXRlIG1hdGNoLiRvcjtcbiAgICB9IGVsc2Uge1xuICAgICAgbWF0Y2guJG9yID0gJG9yO1xuICAgIH1cbiAgICBmb3IgKGNvbnN0IGZvcmVpZ25GaWVsZCBvZiBfZm9yZWlnbkZpZWxkKSB7XG4gICAgICBpZiAoZm9yZWlnbkZpZWxkICE9PSAnX2lkJyB8fCAhbWF0Y2hbJ19pZCddKSB7XG4gICAgICAgIGNvbnN0IGZvcmVpZ25TY2hlbWFUeXBlID0gbW9kZWwuc2NoZW1hLnBhdGgoZm9yZWlnbkZpZWxkKTtcbiAgICAgICAgaWRzID0gX2ZpbHRlckludmFsaWRJZHMoaWRzLCBmb3JlaWduU2NoZW1hVHlwZSwgc2tpcEludmFsaWRJZHMpO1xuICAgICAgICAkb3IucHVzaCh7IFtmb3JlaWduRmllbGRdOiB7ICRpbjogaWRzIH0gfSk7XG4gICAgICB9IGVsc2UgaWYgKGZvcmVpZ25GaWVsZCA9PT0gJ19pZCcgJiYgbWF0Y2hbJ19pZCddKSB7XG4gICAgICAgIGNvbnN0IHVzZXJTcGVjaWZpZWRNYXRjaCA9IGhhc0RvbGxhcktleXMobWF0Y2hbZm9yZWlnbkZpZWxkXSkgP1xuICAgICAgICAgIG1hdGNoW2ZvcmVpZ25GaWVsZF0gOlxuICAgICAgICAgIHsgJGVxOiBtYXRjaFtmb3JlaWduRmllbGRdIH07XG4gICAgICAgIG1hdGNoW2ZvcmVpZ25GaWVsZF0gPSB7IC4uLnRydXN0ZWQoeyAkaW46IGlkcyB9KSwgLi4udXNlclNwZWNpZmllZE1hdGNoIH07XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG1hdGNoO1xufTtcblxuLyoqXG4gKiBPcHRpb25hbGx5IGZpbHRlciBvdXQgaW52YWxpZCBpZHMgdGhhdCBkb24ndCBjb25mb3JtIHRvIGZvcmVpZ24gZmllbGQncyBzY2hlbWFcbiAqIHRvIGF2b2lkIGNhc3QgZXJyb3JzIChnaC03NzA2KVxuICogQHBhcmFtIHtBcnJheX0gaWRzXG4gKiBAcGFyYW0ge1NjaGVtYVR5cGV9IGZvcmVpZ25TY2hlbWFUeXBlXG4gKiBAcGFyYW0ge0Jvb2xlYW59IFtza2lwSW52YWxpZElkc11cbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmZ1bmN0aW9uIF9maWx0ZXJJbnZhbGlkSWRzKGlkcywgZm9yZWlnblNjaGVtYVR5cGUsIHNraXBJbnZhbGlkSWRzKSB7XG4gIGlkcyA9IGlkcy5maWx0ZXIodiA9PiAhKHYgaW5zdGFuY2VvZiBTa2lwUG9wdWxhdGVWYWx1ZSkpO1xuICBpZiAoIXNraXBJbnZhbGlkSWRzKSB7XG4gICAgcmV0dXJuIGlkcztcbiAgfVxuICByZXR1cm4gaWRzLmZpbHRlcihpZCA9PiB7XG4gICAgdHJ5IHtcbiAgICAgIGZvcmVpZ25TY2hlbWFUeXBlLmNhc3QoaWQpO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9KTtcbn1cblxuLyoqXG4gKiBGb3JtYXQgYG1vZC5tYXRjaGAgZ2l2ZW4gdGhhdCBpdCBtYXkgYmUgYW4gYXJyYXkgdGhhdCB3ZSBuZWVkIHRvICRvciBpZlxuICogdGhlIGNsaWVudCBoYXMgbXVsdGlwbGUgZG9jcyB3aXRoIG1hdGNoIGZ1bmN0aW9uc1xuICogQHBhcmFtIHtBcnJheXxBbnl9IG1hdGNoXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5mdW5jdGlvbiBfZm9ybWF0TWF0Y2gobWF0Y2gpIHtcbiAgaWYgKEFycmF5LmlzQXJyYXkobWF0Y2gpKSB7XG4gICAgaWYgKG1hdGNoLmxlbmd0aCA+IDEpIHtcbiAgICAgIHJldHVybiB7ICRvcjogW10uY29uY2F0KG1hdGNoLm1hcChtID0+IE9iamVjdC5hc3NpZ24oe30sIG0pKSkgfTtcbiAgICB9XG4gICAgcmV0dXJuIE9iamVjdC5hc3NpZ24oe30sIG1hdGNoWzBdKTtcbiAgfVxuICByZXR1cm4gT2JqZWN0LmFzc2lnbih7fSwgbWF0Y2gpO1xufVxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/mongoose/lib/helpers/populate/createPopulateQueryFilter.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/mongoose/lib/helpers/populate/getModelsMapForPopulate.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/mongoose/lib/helpers/populate/getModelsMapForPopulate.js ***!
  \*******************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\n\nconst MongooseError = __webpack_require__(/*! ../../error/index */ \"(ssr)/./node_modules/mongoose/lib/error/index.js\");\nconst SkipPopulateValue = __webpack_require__(/*! ./skipPopulateValue */ \"(ssr)/./node_modules/mongoose/lib/helpers/populate/skipPopulateValue.js\");\nconst clone = __webpack_require__(/*! ../clone */ \"(ssr)/./node_modules/mongoose/lib/helpers/clone.js\");\nconst get = __webpack_require__(/*! ../get */ \"(ssr)/./node_modules/mongoose/lib/helpers/get.js\");\nconst getDiscriminatorByValue = __webpack_require__(/*! ../discriminator/getDiscriminatorByValue */ \"(ssr)/./node_modules/mongoose/lib/helpers/discriminator/getDiscriminatorByValue.js\");\nconst getConstructorName = __webpack_require__(/*! ../getConstructorName */ \"(ssr)/./node_modules/mongoose/lib/helpers/getConstructorName.js\");\nconst getSchemaTypes = __webpack_require__(/*! ./getSchemaTypes */ \"(ssr)/./node_modules/mongoose/lib/helpers/populate/getSchemaTypes.js\");\nconst getVirtual = __webpack_require__(/*! ./getVirtual */ \"(ssr)/./node_modules/mongoose/lib/helpers/populate/getVirtual.js\");\nconst lookupLocalFields = __webpack_require__(/*! ./lookupLocalFields */ \"(ssr)/./node_modules/mongoose/lib/helpers/populate/lookupLocalFields.js\");\nconst mpath = __webpack_require__(/*! mpath */ \"(ssr)/./node_modules/mpath/index.js\");\nconst modelNamesFromRefPath = __webpack_require__(/*! ./modelNamesFromRefPath */ \"(ssr)/./node_modules/mongoose/lib/helpers/populate/modelNamesFromRefPath.js\");\nconst utils = __webpack_require__(/*! ../../utils */ \"(ssr)/./node_modules/mongoose/lib/utils.js\");\n\nconst modelSymbol = (__webpack_require__(/*! ../symbols */ \"(ssr)/./node_modules/mongoose/lib/helpers/symbols.js\").modelSymbol);\nconst populateModelSymbol = (__webpack_require__(/*! ../symbols */ \"(ssr)/./node_modules/mongoose/lib/helpers/symbols.js\").populateModelSymbol);\nconst schemaMixedSymbol = (__webpack_require__(/*! ../../schema/symbols */ \"(ssr)/./node_modules/mongoose/lib/schema/symbols.js\").schemaMixedSymbol);\nconst StrictPopulate = __webpack_require__(/*! ../../error/strictPopulate */ \"(ssr)/./node_modules/mongoose/lib/error/strictPopulate.js\");\n\nmodule.exports = function getModelsMapForPopulate(model, docs, options) {\n  let doc;\n  const len = docs.length;\n  const map = [];\n  const modelNameFromQuery = options.model && options.model.modelName || options.model;\n  let schema;\n  let refPath;\n  let modelNames;\n  const available = {};\n\n  const modelSchema = model.schema;\n\n  // Populating a nested path should always be a no-op re: #9073.\n  // People shouldn't do this, but apparently they do.\n  if (options._localModel != null && options._localModel.schema.nested[options.path]) {\n    return [];\n  }\n\n  const _virtualRes = getVirtual(model.schema, options.path);\n  const virtual = _virtualRes == null ? null : _virtualRes.virtual;\n  if (virtual != null) {\n    return _virtualPopulate(model, docs, options, _virtualRes);\n  }\n\n  let allSchemaTypes = getSchemaTypes(model, modelSchema, null, options.path);\n  allSchemaTypes = Array.isArray(allSchemaTypes) ? allSchemaTypes : [allSchemaTypes].filter(v => v != null);\n\n  const isStrictPopulateDisabled = options.strictPopulate === false || options.options?.strictPopulate === false;\n  if (!isStrictPopulateDisabled && allSchemaTypes.length === 0 && options._localModel != null) {\n    return new StrictPopulate(options._fullPath || options.path);\n  }\n\n  for (let i = 0; i < len; i++) {\n    doc = docs[i];\n    let justOne = null;\n\n    const docSchema = doc != null && doc.$__ != null ? doc.$__schema : modelSchema;\n    schema = getSchemaTypes(model, docSchema, doc, options.path);\n\n    // Special case: populating a path that's a DocumentArray unless\n    // there's an explicit `ref` or `refPath` re: gh-8946\n    if (schema != null &&\n        schema.$isMongooseDocumentArray &&\n        schema.options.ref == null &&\n        schema.options.refPath == null) {\n      continue;\n    }\n    const isUnderneathDocArray = schema && schema.$parentSchemaDocArray;\n    if (isUnderneathDocArray && get(options, 'options.sort') != null) {\n      return new MongooseError('Cannot populate with `sort` on path ' + options.path +\n        ' because it is a subproperty of a document array');\n    }\n\n    modelNames = null;\n    let isRefPath = false;\n    let normalizedRefPath = null;\n    let schemaOptions = null;\n    let modelNamesInOrder = null;\n\n    if (schema != null && schema.instance === 'Embedded') {\n      if (schema.options.ref) {\n        const data = {\n          localField: options.path + '._id',\n          foreignField: '_id',\n          justOne: true\n        };\n        const res = _getModelNames(doc, schema, modelNameFromQuery, model);\n\n        const unpopulatedValue = mpath.get(options.path, doc);\n        const id = mpath.get('_id', unpopulatedValue);\n        addModelNamesToMap(model, map, available, res.modelNames, options, data, id, doc, schemaOptions, unpopulatedValue);\n      }\n      // No-op if no `ref` set. See gh-11538\n      continue;\n    }\n\n    if (Array.isArray(schema)) {\n      const schemasArray = schema;\n      for (const _schema of schemasArray) {\n        let _modelNames;\n        let res;\n        try {\n          res = _getModelNames(doc, _schema, modelNameFromQuery, model);\n          _modelNames = res.modelNames;\n          isRefPath = isRefPath || res.isRefPath;\n          normalizedRefPath = normalizedRefPath || res.refPath;\n          justOne = res.justOne;\n        } catch (error) {\n          return error;\n        }\n\n        if (isRefPath && !res.isRefPath) {\n          continue;\n        }\n        if (!_modelNames) {\n          continue;\n        }\n        modelNames = modelNames || [];\n        for (const modelName of _modelNames) {\n          if (modelNames.indexOf(modelName) === -1) {\n            modelNames.push(modelName);\n          }\n        }\n      }\n    } else {\n      try {\n        const res = _getModelNames(doc, schema, modelNameFromQuery, model);\n        modelNames = res.modelNames;\n        isRefPath = res.isRefPath;\n        normalizedRefPath = normalizedRefPath || res.refPath;\n        justOne = res.justOne;\n        schemaOptions = get(schema, 'options.populate', null);\n        // Dedupe, because `refPath` can return duplicates of the same model name,\n        // and that causes perf issues.\n        if (isRefPath) {\n          modelNamesInOrder = modelNames;\n          modelNames = Array.from(new Set(modelNames));\n        }\n      } catch (error) {\n        return error;\n      }\n\n      if (!modelNames) {\n        continue;\n      }\n    }\n\n    const data = {};\n    const localField = options.path;\n    const foreignField = '_id';\n\n    // `justOne = null` means we don't know from the schema whether the end\n    // result should be an array or a single doc. This can result from\n    // populating a POJO using `Model.populate()`\n    if ('justOne' in options && options.justOne !== void 0) {\n      justOne = options.justOne;\n    } else if (schema && !schema[schemaMixedSymbol]) {\n      // Skip Mixed types because we explicitly don't do casting on those.\n      if (options.path.endsWith('.' + schema.path) || options.path === schema.path) {\n        justOne = Array.isArray(schema) ?\n          schema.every(schema => !schema.$isMongooseArray) :\n          !schema.$isMongooseArray;\n      }\n    }\n\n    if (!modelNames) {\n      continue;\n    }\n\n    data.isVirtual = false;\n    data.justOne = justOne;\n    data.localField = localField;\n    data.foreignField = foreignField;\n\n    // Get local fields\n    const ret = _getLocalFieldValues(doc, localField, model, options, null, schema);\n\n    const id = String(utils.getValue(foreignField, doc));\n    options._docs[id] = Array.isArray(ret) ? ret.slice() : ret;\n\n    let match = get(options, 'match', null);\n\n    const hasMatchFunction = typeof match === 'function';\n    if (hasMatchFunction) {\n      match = match.call(doc, doc);\n    }\n    data.match = match;\n    data.hasMatchFunction = hasMatchFunction;\n    data.isRefPath = isRefPath;\n    data.modelNamesInOrder = modelNamesInOrder;\n\n    if (isRefPath) {\n      const embeddedDiscriminatorModelNames = _findRefPathForDiscriminators(doc,\n        modelSchema, data, options, normalizedRefPath, ret);\n\n      modelNames = embeddedDiscriminatorModelNames || modelNames;\n    }\n\n    try {\n      addModelNamesToMap(model, map, available, modelNames, options, data, ret, doc, schemaOptions);\n    } catch (err) {\n      return err;\n    }\n  }\n  return map;\n\n  function _getModelNames(doc, schema, modelNameFromQuery, model) {\n    let modelNames;\n    let isRefPath = false;\n    let justOne = null;\n\n    const originalSchema = schema;\n    if (schema && schema.instance === 'Array') {\n      schema = schema.caster;\n    }\n    if (schema && schema.$isSchemaMap) {\n      schema = schema.$__schemaType;\n    }\n\n    const ref = schema && schema.options && schema.options.ref;\n    refPath = schema && schema.options && schema.options.refPath;\n    if (schema != null &&\n        schema[schemaMixedSymbol] &&\n        !ref &&\n        !refPath &&\n        !modelNameFromQuery) {\n      return { modelNames: null };\n    }\n\n    if (modelNameFromQuery) {\n      modelNames = [modelNameFromQuery]; // query options\n    } else if (refPath != null) {\n      if (typeof refPath === 'function') {\n        const subdocPath = options.path.slice(0, options.path.length - schema.path.length - 1);\n        const vals = mpath.get(subdocPath, doc, lookupLocalFields);\n        const subdocsBeingPopulated = Array.isArray(vals) ?\n          utils.array.flatten(vals) :\n          (vals ? [vals] : []);\n\n        modelNames = new Set();\n        for (const subdoc of subdocsBeingPopulated) {\n          refPath = refPath.call(subdoc, subdoc, options.path);\n          modelNamesFromRefPath(refPath, doc, options.path, modelSchema, options._queryProjection).\n            forEach(name => modelNames.add(name));\n        }\n        modelNames = Array.from(modelNames);\n      } else {\n        modelNames = modelNamesFromRefPath(refPath, doc, options.path, modelSchema, options._queryProjection);\n      }\n\n      isRefPath = true;\n    } else {\n      let ref;\n      let refPath;\n      let schemaForCurrentDoc;\n      let discriminatorValue;\n      let modelForCurrentDoc = model;\n      const discriminatorKey = model.schema.options.discriminatorKey;\n\n      if (!schema && discriminatorKey && (discriminatorValue = utils.getValue(discriminatorKey, doc))) {\n        // `modelNameForFind` is the discriminator value, so we might need\n        // find the discriminated model name\n        const discriminatorModel = getDiscriminatorByValue(model.discriminators, discriminatorValue) || model;\n        if (discriminatorModel != null) {\n          modelForCurrentDoc = discriminatorModel;\n        } else {\n          try {\n            modelForCurrentDoc = _getModelFromConn(model.db, discriminatorValue);\n          } catch (error) {\n            return error;\n          }\n        }\n\n        schemaForCurrentDoc = modelForCurrentDoc.schema._getSchema(options.path);\n\n        if (schemaForCurrentDoc && schemaForCurrentDoc.caster) {\n          schemaForCurrentDoc = schemaForCurrentDoc.caster;\n        }\n      } else {\n        schemaForCurrentDoc = schema;\n      }\n\n      if (originalSchema && originalSchema.path.endsWith('.$*')) {\n        justOne = !originalSchema.$isMongooseArray && !originalSchema._arrayPath;\n      } else if (schemaForCurrentDoc != null) {\n        justOne = !schemaForCurrentDoc.$isMongooseArray && !schemaForCurrentDoc._arrayPath;\n      }\n\n      if ((ref = get(schemaForCurrentDoc, 'options.ref')) != null) {\n        if (schemaForCurrentDoc != null &&\n            typeof ref === 'function' &&\n            options.path.endsWith('.' + schemaForCurrentDoc.path)) {\n          // Ensure correct context for ref functions: subdoc, not top-level doc. See gh-8469\n          modelNames = new Set();\n\n          const subdocPath = options.path.slice(0, options.path.length - schemaForCurrentDoc.path.length - 1);\n          const vals = mpath.get(subdocPath, doc, lookupLocalFields);\n          const subdocsBeingPopulated = Array.isArray(vals) ?\n            utils.array.flatten(vals) :\n            (vals ? [vals] : []);\n          for (const subdoc of subdocsBeingPopulated) {\n            modelNames.add(handleRefFunction(ref, subdoc));\n          }\n\n          if (subdocsBeingPopulated.length === 0) {\n            modelNames = [handleRefFunction(ref, doc)];\n          } else {\n            modelNames = Array.from(modelNames);\n          }\n        } else {\n          ref = handleRefFunction(ref, doc);\n          modelNames = [ref];\n        }\n      } else if ((schemaForCurrentDoc = get(schema, 'options.refPath')) != null) {\n        isRefPath = true;\n        if (typeof refPath === 'function') {\n          const subdocPath = options.path.slice(0, options.path.length - schemaForCurrentDoc.path.length - 1);\n          const vals = mpath.get(subdocPath, doc, lookupLocalFields);\n          const subdocsBeingPopulated = Array.isArray(vals) ?\n            utils.array.flatten(vals) :\n            (vals ? [vals] : []);\n\n          modelNames = new Set();\n          for (const subdoc of subdocsBeingPopulated) {\n            refPath = refPath.call(subdoc, subdoc, options.path);\n            modelNamesFromRefPath(refPath, doc, options.path, modelSchema, options._queryProjection).\n              forEach(name => modelNames.add(name));\n          }\n          modelNames = Array.from(modelNames);\n        } else {\n          modelNames = modelNamesFromRefPath(refPath, doc, options.path, modelSchema, options._queryProjection);\n        }\n      }\n    }\n\n    if (!modelNames) {\n      // `Model.populate()` on a POJO with no known local model. Default to using the `Model`\n      if (options._localModel == null) {\n        modelNames = [model.modelName];\n      } else {\n        return { modelNames: modelNames, justOne: justOne, isRefPath: isRefPath, refPath: refPath };\n      }\n    }\n\n    if (!Array.isArray(modelNames)) {\n      modelNames = [modelNames];\n    }\n\n    return { modelNames: modelNames, justOne: justOne, isRefPath: isRefPath, refPath: refPath };\n  }\n};\n\n/*!\n * ignore\n */\n\nfunction _virtualPopulate(model, docs, options, _virtualRes) {\n  const map = [];\n  const available = {};\n  const virtual = _virtualRes.virtual;\n\n  for (const doc of docs) {\n    let modelNames = null;\n    const data = {};\n\n    // localField and foreignField\n    let localField;\n    const virtualPrefix = _virtualRes.nestedSchemaPath ?\n      _virtualRes.nestedSchemaPath + '.' : '';\n    if (typeof options.localField === 'string') {\n      localField = options.localField;\n    } else if (typeof virtual.options.localField === 'function') {\n      localField = virtualPrefix + virtual.options.localField.call(doc, doc);\n    } else if (Array.isArray(virtual.options.localField)) {\n      localField = virtual.options.localField.map(field => virtualPrefix + field);\n    } else {\n      localField = virtualPrefix + virtual.options.localField;\n    }\n    data.count = virtual.options.count;\n\n    if (virtual.options.skip != null && !options.hasOwnProperty('skip')) {\n      options.skip = virtual.options.skip;\n    }\n    if (virtual.options.limit != null && !options.hasOwnProperty('limit')) {\n      options.limit = virtual.options.limit;\n    }\n    if (virtual.options.perDocumentLimit != null && !options.hasOwnProperty('perDocumentLimit')) {\n      options.perDocumentLimit = virtual.options.perDocumentLimit;\n    }\n    let foreignField = virtual.options.foreignField;\n\n    if (!localField || !foreignField) {\n      return new MongooseError(`Cannot populate virtual \\`${options.path}\\` on model \\`${model.modelName}\\`, because options \\`localField\\` and / or \\`foreignField\\` are missing`);\n    }\n\n    if (typeof localField === 'function') {\n      localField = localField.call(doc, doc);\n    }\n    if (typeof foreignField === 'function') {\n      foreignField = foreignField.call(doc, doc);\n    }\n\n    data.isRefPath = false;\n\n    // `justOne = null` means we don't know from the schema whether the end\n    // result should be an array or a single doc. This can result from\n    // populating a POJO using `Model.populate()`\n    let justOne = null;\n    if ('justOne' in options && options.justOne !== void 0) {\n      justOne = options.justOne;\n    }\n\n    if (virtual.options.refPath) {\n      modelNames =\n        modelNamesFromRefPath(virtual.options.refPath, doc, options.path);\n      justOne = !!virtual.options.justOne;\n      data.isRefPath = true;\n    } else if (virtual.options.ref) {\n      let normalizedRef;\n      if (typeof virtual.options.ref === 'function' && !virtual.options.ref[modelSymbol]) {\n        normalizedRef = virtual.options.ref.call(doc, doc);\n      } else {\n        normalizedRef = virtual.options.ref;\n      }\n      justOne = !!virtual.options.justOne;\n      // When referencing nested arrays, the ref should be an Array\n      // of modelNames.\n      if (Array.isArray(normalizedRef)) {\n        modelNames = normalizedRef;\n      } else {\n        modelNames = [normalizedRef];\n      }\n    }\n\n    data.isVirtual = true;\n    data.virtual = virtual;\n    data.justOne = justOne;\n\n    // `match`\n    const baseMatch = get(data, 'virtual.options.match', null) ||\n      get(data, 'virtual.options.options.match', null);\n    let match = get(options, 'match', null) || baseMatch;\n\n    let hasMatchFunction = typeof match === 'function';\n    if (hasMatchFunction) {\n      match = match.call(doc, doc, data.virtual);\n    }\n\n    if (Array.isArray(localField) && Array.isArray(foreignField) && localField.length === foreignField.length) {\n      match = Object.assign({}, match);\n      for (let i = 1; i < localField.length; ++i) {\n        match[foreignField[i]] = convertTo_id(mpath.get(localField[i], doc, lookupLocalFields), model.schema);\n        hasMatchFunction = true;\n      }\n\n      localField = localField[0];\n      foreignField = foreignField[0];\n    }\n    data.localField = localField;\n    data.foreignField = foreignField;\n    data.match = match;\n    data.hasMatchFunction = hasMatchFunction;\n\n    // Get local fields\n    const ret = _getLocalFieldValues(doc, localField, model, options, virtual);\n\n    try {\n      addModelNamesToMap(model, map, available, modelNames, options, data, ret, doc);\n    } catch (err) {\n      return err;\n    }\n  }\n\n  return map;\n}\n\n/*!\n * ignore\n */\n\nfunction addModelNamesToMap(model, map, available, modelNames, options, data, ret, doc, schemaOptions, unpopulatedValue) {\n  // `PopulateOptions#connection`: if the model is passed as a string, the\n  // connection matters because different connections have different models.\n  const connection = options.connection != null ? options.connection : model.db;\n\n  unpopulatedValue = unpopulatedValue === void 0 ? ret : unpopulatedValue;\n  if (Array.isArray(unpopulatedValue)) {\n    unpopulatedValue = utils.cloneArrays(unpopulatedValue);\n  }\n\n  if (modelNames == null) {\n    return;\n  }\n\n  let k = modelNames.length;\n  while (k--) {\n    const modelName = modelNames[k];\n    if (modelName == null) {\n      continue;\n    }\n\n    let Model;\n    if (options.model && options.model[modelSymbol]) {\n      Model = options.model;\n    } else if (modelName[modelSymbol]) {\n      Model = modelName;\n    } else {\n      try {\n        Model = _getModelFromConn(connection, modelName);\n      } catch (err) {\n        if (ret !== void 0) {\n          throw err;\n        }\n        Model = null;\n      }\n    }\n\n    let ids = ret;\n    const flat = Array.isArray(ret) ? utils.array.flatten(ret) : [];\n\n    const modelNamesForRefPath = data.modelNamesInOrder ? data.modelNamesInOrder : modelNames;\n    if (data.isRefPath && Array.isArray(ret) && flat.length === modelNamesForRefPath.length) {\n      ids = flat.filter((val, i) => modelNamesForRefPath[i] === modelName);\n    }\n\n    const perDocumentLimit = options.perDocumentLimit == null ?\n      get(options, 'options.perDocumentLimit', null) :\n      options.perDocumentLimit;\n\n    if (!available[modelName] || perDocumentLimit != null) {\n      const currentOptions = {\n        model: Model\n      };\n      if (data.isVirtual && get(data.virtual, 'options.options')) {\n        currentOptions.options = clone(data.virtual.options.options);\n      } else if (schemaOptions != null) {\n        currentOptions.options = Object.assign({}, schemaOptions);\n      }\n      utils.merge(currentOptions, options);\n\n      // Used internally for checking what model was used to populate this\n      // path.\n      options[populateModelSymbol] = Model;\n      currentOptions[populateModelSymbol] = Model;\n      available[modelName] = {\n        model: Model,\n        options: currentOptions,\n        match: data.hasMatchFunction ? [data.match] : data.match,\n        docs: [doc],\n        ids: [ids],\n        allIds: [ret],\n        unpopulatedValues: [unpopulatedValue],\n        localField: new Set([data.localField]),\n        foreignField: new Set([data.foreignField]),\n        justOne: data.justOne,\n        isVirtual: data.isVirtual,\n        virtual: data.virtual,\n        count: data.count,\n        [populateModelSymbol]: Model\n      };\n      map.push(available[modelName]);\n    } else {\n      available[modelName].localField.add(data.localField);\n      available[modelName].foreignField.add(data.foreignField);\n      available[modelName].docs.push(doc);\n      available[modelName].ids.push(ids);\n      available[modelName].allIds.push(ret);\n      available[modelName].unpopulatedValues.push(unpopulatedValue);\n      if (data.hasMatchFunction) {\n        available[modelName].match.push(data.match);\n      }\n    }\n  }\n}\n\nfunction _getModelFromConn(conn, modelName) {\n  /* If this connection has a parent from `useDb()`, bubble up to parent's models */\n  if (conn.models[modelName] == null && conn._parent != null) {\n    return _getModelFromConn(conn._parent, modelName);\n  }\n\n  return conn.model(modelName);\n}\n\n/*!\n * ignore\n */\n\nfunction handleRefFunction(ref, doc) {\n  if (typeof ref === 'function' && !ref[modelSymbol]) {\n    return ref.call(doc, doc);\n  }\n  return ref;\n}\n\n/*!\n * ignore\n */\n\nfunction _getLocalFieldValues(doc, localField, model, options, virtual, schema) {\n  // Get Local fields\n  const localFieldPathType = model.schema._getPathType(localField);\n  const localFieldPath = localFieldPathType === 'real' ?\n    model.schema.path(localField) :\n    localFieldPathType.schema;\n  const localFieldGetters = localFieldPath && localFieldPath.getters ?\n    localFieldPath.getters : [];\n\n  localField = localFieldPath != null && localFieldPath.instance === 'Embedded' ? localField + '._id' : localField;\n\n  const _populateOptions = get(options, 'options', {});\n\n  const getters = 'getters' in _populateOptions ?\n    _populateOptions.getters :\n    get(virtual, 'options.getters', false);\n  if (localFieldGetters.length !== 0 && getters) {\n    const hydratedDoc = (doc.$__ != null) ? doc : model.hydrate(doc);\n    const localFieldValue = utils.getValue(localField, doc);\n    if (Array.isArray(localFieldValue)) {\n      const localFieldHydratedValue = utils.getValue(localField.split('.').slice(0, -1), hydratedDoc);\n      return localFieldValue.map((localFieldArrVal, localFieldArrIndex) =>\n        localFieldPath.applyGetters(localFieldArrVal, localFieldHydratedValue[localFieldArrIndex]));\n    } else {\n      return localFieldPath.applyGetters(localFieldValue, hydratedDoc);\n    }\n  } else {\n    return convertTo_id(mpath.get(localField, doc, lookupLocalFields), schema);\n  }\n}\n\n/**\n * Retrieve the _id of `val` if a Document or Array of Documents.\n *\n * @param {Array|Document|Any} val\n * @param {Schema} schema\n * @return {Array|Document|Any}\n * @api private\n */\n\nfunction convertTo_id(val, schema) {\n  if (val != null && val.$__ != null) {\n    return val._id;\n  }\n  if (val != null && val._id != null && (schema == null || !schema.$isSchemaMap)) {\n    return val._id;\n  }\n\n  if (Array.isArray(val)) {\n    const rawVal = val.__array != null ? val.__array : val;\n    for (let i = 0; i < rawVal.length; ++i) {\n      if (rawVal[i] != null && rawVal[i].$__ != null) {\n        rawVal[i] = rawVal[i]._id;\n      }\n    }\n    if (utils.isMongooseArray(val) && val.$schema()) {\n      return val.$schema()._castForPopulate(val, val.$parent());\n    }\n\n    return [].concat(val);\n  }\n\n  // `populate('map')` may be an object if populating on a doc that hasn't\n  // been hydrated yet\n  if (getConstructorName(val) === 'Object' &&\n      // The intent here is we should only flatten the object if we expect\n      // to get a Map in the end. Avoid doing this for mixed types.\n      (schema == null || schema[schemaMixedSymbol] == null)) {\n    const ret = [];\n    for (const key of Object.keys(val)) {\n      ret.push(val[key]);\n    }\n    return ret;\n  }\n  // If doc has already been hydrated, e.g. `doc.populate('map')`\n  // then `val` will already be a map\n  if (val instanceof Map) {\n    return Array.from(val.values());\n  }\n\n  return val;\n}\n\n/*!\n * ignore\n */\n\nfunction _findRefPathForDiscriminators(doc, modelSchema, data, options, normalizedRefPath, ret) {\n  // Re: gh-8452. Embedded discriminators may not have `refPath`, so clear\n  // out embedded discriminator docs that don't have a `refPath` on the\n  // populated path.\n  if (!data.isRefPath || normalizedRefPath == null) {\n    return;\n  }\n\n  const pieces = normalizedRefPath.split('.');\n  let cur = '';\n  let modelNames = void 0;\n  for (let i = 0; i < pieces.length; ++i) {\n    const piece = pieces[i];\n    cur = cur + (cur.length === 0 ? '' : '.') + piece;\n    const schematype = modelSchema.path(cur);\n    if (schematype != null &&\n        schematype.$isMongooseArray &&\n        schematype.caster.discriminators != null &&\n        Object.keys(schematype.caster.discriminators).length !== 0) {\n      const subdocs = utils.getValue(cur, doc);\n      const remnant = options.path.substring(cur.length + 1);\n      const discriminatorKey = schematype.caster.schema.options.discriminatorKey;\n      modelNames = [];\n      for (const subdoc of subdocs) {\n        const discriminatorName = utils.getValue(discriminatorKey, subdoc);\n        const discriminator = schematype.caster.discriminators[discriminatorName];\n        const discriminatorSchema = discriminator && discriminator.schema;\n        if (discriminatorSchema == null) {\n          continue;\n        }\n        const _path = discriminatorSchema.path(remnant);\n        if (_path == null || _path.options.refPath == null) {\n          const docValue = utils.getValue(data.localField.substring(cur.length + 1), subdoc);\n          ret.forEach((v, i) => {\n            if (v === docValue) {\n              ret[i] = SkipPopulateValue(v);\n            }\n          });\n          continue;\n        }\n        const modelName = utils.getValue(pieces.slice(i + 1).join('.'), subdoc);\n        modelNames.push(modelName);\n      }\n    }\n  }\n\n  return modelNames;\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbW9uZ29vc2UvbGliL2hlbHBlcnMvcG9wdWxhdGUvZ2V0TW9kZWxzTWFwRm9yUG9wdWxhdGUuanMiLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWIsc0JBQXNCLG1CQUFPLENBQUMsMkVBQW1CO0FBQ2pELDBCQUEwQixtQkFBTyxDQUFDLG9HQUFxQjtBQUN2RCxjQUFjLG1CQUFPLENBQUMsb0VBQVU7QUFDaEMsWUFBWSxtQkFBTyxDQUFDLGdFQUFRO0FBQzVCLGdDQUFnQyxtQkFBTyxDQUFDLG9JQUEwQztBQUNsRiwyQkFBMkIsbUJBQU8sQ0FBQyw4RkFBdUI7QUFDMUQsdUJBQXVCLG1CQUFPLENBQUMsOEZBQWtCO0FBQ2pELG1CQUFtQixtQkFBTyxDQUFDLHNGQUFjO0FBQ3pDLDBCQUEwQixtQkFBTyxDQUFDLG9HQUFxQjtBQUN2RCxjQUFjLG1CQUFPLENBQUMsa0RBQU87QUFDN0IsOEJBQThCLG1CQUFPLENBQUMsNEdBQXlCO0FBQy9ELGNBQWMsbUJBQU8sQ0FBQywrREFBYTs7QUFFbkMsb0JBQW9CLDJHQUFpQztBQUNyRCw0QkFBNEIsbUhBQXlDO0FBQ3JFLDBCQUEwQiwwSEFBaUQ7QUFDM0UsdUJBQXVCLG1CQUFPLENBQUMsNkZBQTRCOztBQUUzRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsa0JBQWtCLFNBQVM7QUFDM0I7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjs7QUFFQTtBQUNBLHlDQUF5QztBQUN6QyxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7O0FBRUE7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUixpQkFBaUI7QUFDakI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsYUFBYTtBQUNiO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQSxNQUFNO0FBQ047QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsNERBQTRELGFBQWEsZ0JBQWdCLGdCQUFnQjtBQUN6Rzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDhCQUE4QjtBQUM5QixzQkFBc0IsdUJBQXVCO0FBQzdDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUixpREFBaUQ7QUFDakQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBLHFEQUFxRDs7QUFFckQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxvQkFBb0I7QUFDL0IsV0FBVyxRQUFRO0FBQ25CLFlBQVk7QUFDWjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxvQkFBb0IsbUJBQW1CO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsbUJBQW1CO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9hcHAxLy4vbm9kZV9tb2R1bGVzL21vbmdvb3NlL2xpYi9oZWxwZXJzL3BvcHVsYXRlL2dldE1vZGVsc01hcEZvclBvcHVsYXRlLmpzPzUzNmEiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG5jb25zdCBNb25nb29zZUVycm9yID0gcmVxdWlyZSgnLi4vLi4vZXJyb3IvaW5kZXgnKTtcbmNvbnN0IFNraXBQb3B1bGF0ZVZhbHVlID0gcmVxdWlyZSgnLi9za2lwUG9wdWxhdGVWYWx1ZScpO1xuY29uc3QgY2xvbmUgPSByZXF1aXJlKCcuLi9jbG9uZScpO1xuY29uc3QgZ2V0ID0gcmVxdWlyZSgnLi4vZ2V0Jyk7XG5jb25zdCBnZXREaXNjcmltaW5hdG9yQnlWYWx1ZSA9IHJlcXVpcmUoJy4uL2Rpc2NyaW1pbmF0b3IvZ2V0RGlzY3JpbWluYXRvckJ5VmFsdWUnKTtcbmNvbnN0IGdldENvbnN0cnVjdG9yTmFtZSA9IHJlcXVpcmUoJy4uL2dldENvbnN0cnVjdG9yTmFtZScpO1xuY29uc3QgZ2V0U2NoZW1hVHlwZXMgPSByZXF1aXJlKCcuL2dldFNjaGVtYVR5cGVzJyk7XG5jb25zdCBnZXRWaXJ0dWFsID0gcmVxdWlyZSgnLi9nZXRWaXJ0dWFsJyk7XG5jb25zdCBsb29rdXBMb2NhbEZpZWxkcyA9IHJlcXVpcmUoJy4vbG9va3VwTG9jYWxGaWVsZHMnKTtcbmNvbnN0IG1wYXRoID0gcmVxdWlyZSgnbXBhdGgnKTtcbmNvbnN0IG1vZGVsTmFtZXNGcm9tUmVmUGF0aCA9IHJlcXVpcmUoJy4vbW9kZWxOYW1lc0Zyb21SZWZQYXRoJyk7XG5jb25zdCB1dGlscyA9IHJlcXVpcmUoJy4uLy4uL3V0aWxzJyk7XG5cbmNvbnN0IG1vZGVsU3ltYm9sID0gcmVxdWlyZSgnLi4vc3ltYm9scycpLm1vZGVsU3ltYm9sO1xuY29uc3QgcG9wdWxhdGVNb2RlbFN5bWJvbCA9IHJlcXVpcmUoJy4uL3N5bWJvbHMnKS5wb3B1bGF0ZU1vZGVsU3ltYm9sO1xuY29uc3Qgc2NoZW1hTWl4ZWRTeW1ib2wgPSByZXF1aXJlKCcuLi8uLi9zY2hlbWEvc3ltYm9scycpLnNjaGVtYU1peGVkU3ltYm9sO1xuY29uc3QgU3RyaWN0UG9wdWxhdGUgPSByZXF1aXJlKCcuLi8uLi9lcnJvci9zdHJpY3RQb3B1bGF0ZScpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGdldE1vZGVsc01hcEZvclBvcHVsYXRlKG1vZGVsLCBkb2NzLCBvcHRpb25zKSB7XG4gIGxldCBkb2M7XG4gIGNvbnN0IGxlbiA9IGRvY3MubGVuZ3RoO1xuICBjb25zdCBtYXAgPSBbXTtcbiAgY29uc3QgbW9kZWxOYW1lRnJvbVF1ZXJ5ID0gb3B0aW9ucy5tb2RlbCAmJiBvcHRpb25zLm1vZGVsLm1vZGVsTmFtZSB8fCBvcHRpb25zLm1vZGVsO1xuICBsZXQgc2NoZW1hO1xuICBsZXQgcmVmUGF0aDtcbiAgbGV0IG1vZGVsTmFtZXM7XG4gIGNvbnN0IGF2YWlsYWJsZSA9IHt9O1xuXG4gIGNvbnN0IG1vZGVsU2NoZW1hID0gbW9kZWwuc2NoZW1hO1xuXG4gIC8vIFBvcHVsYXRpbmcgYSBuZXN0ZWQgcGF0aCBzaG91bGQgYWx3YXlzIGJlIGEgbm8tb3AgcmU6ICM5MDczLlxuICAvLyBQZW9wbGUgc2hvdWxkbid0IGRvIHRoaXMsIGJ1dCBhcHBhcmVudGx5IHRoZXkgZG8uXG4gIGlmIChvcHRpb25zLl9sb2NhbE1vZGVsICE9IG51bGwgJiYgb3B0aW9ucy5fbG9jYWxNb2RlbC5zY2hlbWEubmVzdGVkW29wdGlvbnMucGF0aF0pIHtcbiAgICByZXR1cm4gW107XG4gIH1cblxuICBjb25zdCBfdmlydHVhbFJlcyA9IGdldFZpcnR1YWwobW9kZWwuc2NoZW1hLCBvcHRpb25zLnBhdGgpO1xuICBjb25zdCB2aXJ0dWFsID0gX3ZpcnR1YWxSZXMgPT0gbnVsbCA/IG51bGwgOiBfdmlydHVhbFJlcy52aXJ0dWFsO1xuICBpZiAodmlydHVhbCAhPSBudWxsKSB7XG4gICAgcmV0dXJuIF92aXJ0dWFsUG9wdWxhdGUobW9kZWwsIGRvY3MsIG9wdGlvbnMsIF92aXJ0dWFsUmVzKTtcbiAgfVxuXG4gIGxldCBhbGxTY2hlbWFUeXBlcyA9IGdldFNjaGVtYVR5cGVzKG1vZGVsLCBtb2RlbFNjaGVtYSwgbnVsbCwgb3B0aW9ucy5wYXRoKTtcbiAgYWxsU2NoZW1hVHlwZXMgPSBBcnJheS5pc0FycmF5KGFsbFNjaGVtYVR5cGVzKSA/IGFsbFNjaGVtYVR5cGVzIDogW2FsbFNjaGVtYVR5cGVzXS5maWx0ZXIodiA9PiB2ICE9IG51bGwpO1xuXG4gIGNvbnN0IGlzU3RyaWN0UG9wdWxhdGVEaXNhYmxlZCA9IG9wdGlvbnMuc3RyaWN0UG9wdWxhdGUgPT09IGZhbHNlIHx8IG9wdGlvbnMub3B0aW9ucz8uc3RyaWN0UG9wdWxhdGUgPT09IGZhbHNlO1xuICBpZiAoIWlzU3RyaWN0UG9wdWxhdGVEaXNhYmxlZCAmJiBhbGxTY2hlbWFUeXBlcy5sZW5ndGggPT09IDAgJiYgb3B0aW9ucy5fbG9jYWxNb2RlbCAhPSBudWxsKSB7XG4gICAgcmV0dXJuIG5ldyBTdHJpY3RQb3B1bGF0ZShvcHRpb25zLl9mdWxsUGF0aCB8fCBvcHRpb25zLnBhdGgpO1xuICB9XG5cbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgIGRvYyA9IGRvY3NbaV07XG4gICAgbGV0IGp1c3RPbmUgPSBudWxsO1xuXG4gICAgY29uc3QgZG9jU2NoZW1hID0gZG9jICE9IG51bGwgJiYgZG9jLiRfXyAhPSBudWxsID8gZG9jLiRfX3NjaGVtYSA6IG1vZGVsU2NoZW1hO1xuICAgIHNjaGVtYSA9IGdldFNjaGVtYVR5cGVzKG1vZGVsLCBkb2NTY2hlbWEsIGRvYywgb3B0aW9ucy5wYXRoKTtcblxuICAgIC8vIFNwZWNpYWwgY2FzZTogcG9wdWxhdGluZyBhIHBhdGggdGhhdCdzIGEgRG9jdW1lbnRBcnJheSB1bmxlc3NcbiAgICAvLyB0aGVyZSdzIGFuIGV4cGxpY2l0IGByZWZgIG9yIGByZWZQYXRoYCByZTogZ2gtODk0NlxuICAgIGlmIChzY2hlbWEgIT0gbnVsbCAmJlxuICAgICAgICBzY2hlbWEuJGlzTW9uZ29vc2VEb2N1bWVudEFycmF5ICYmXG4gICAgICAgIHNjaGVtYS5vcHRpb25zLnJlZiA9PSBudWxsICYmXG4gICAgICAgIHNjaGVtYS5vcHRpb25zLnJlZlBhdGggPT0gbnVsbCkge1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIGNvbnN0IGlzVW5kZXJuZWF0aERvY0FycmF5ID0gc2NoZW1hICYmIHNjaGVtYS4kcGFyZW50U2NoZW1hRG9jQXJyYXk7XG4gICAgaWYgKGlzVW5kZXJuZWF0aERvY0FycmF5ICYmIGdldChvcHRpb25zLCAnb3B0aW9ucy5zb3J0JykgIT0gbnVsbCkge1xuICAgICAgcmV0dXJuIG5ldyBNb25nb29zZUVycm9yKCdDYW5ub3QgcG9wdWxhdGUgd2l0aCBgc29ydGAgb24gcGF0aCAnICsgb3B0aW9ucy5wYXRoICtcbiAgICAgICAgJyBiZWNhdXNlIGl0IGlzIGEgc3VicHJvcGVydHkgb2YgYSBkb2N1bWVudCBhcnJheScpO1xuICAgIH1cblxuICAgIG1vZGVsTmFtZXMgPSBudWxsO1xuICAgIGxldCBpc1JlZlBhdGggPSBmYWxzZTtcbiAgICBsZXQgbm9ybWFsaXplZFJlZlBhdGggPSBudWxsO1xuICAgIGxldCBzY2hlbWFPcHRpb25zID0gbnVsbDtcbiAgICBsZXQgbW9kZWxOYW1lc0luT3JkZXIgPSBudWxsO1xuXG4gICAgaWYgKHNjaGVtYSAhPSBudWxsICYmIHNjaGVtYS5pbnN0YW5jZSA9PT0gJ0VtYmVkZGVkJykge1xuICAgICAgaWYgKHNjaGVtYS5vcHRpb25zLnJlZikge1xuICAgICAgICBjb25zdCBkYXRhID0ge1xuICAgICAgICAgIGxvY2FsRmllbGQ6IG9wdGlvbnMucGF0aCArICcuX2lkJyxcbiAgICAgICAgICBmb3JlaWduRmllbGQ6ICdfaWQnLFxuICAgICAgICAgIGp1c3RPbmU6IHRydWVcbiAgICAgICAgfTtcbiAgICAgICAgY29uc3QgcmVzID0gX2dldE1vZGVsTmFtZXMoZG9jLCBzY2hlbWEsIG1vZGVsTmFtZUZyb21RdWVyeSwgbW9kZWwpO1xuXG4gICAgICAgIGNvbnN0IHVucG9wdWxhdGVkVmFsdWUgPSBtcGF0aC5nZXQob3B0aW9ucy5wYXRoLCBkb2MpO1xuICAgICAgICBjb25zdCBpZCA9IG1wYXRoLmdldCgnX2lkJywgdW5wb3B1bGF0ZWRWYWx1ZSk7XG4gICAgICAgIGFkZE1vZGVsTmFtZXNUb01hcChtb2RlbCwgbWFwLCBhdmFpbGFibGUsIHJlcy5tb2RlbE5hbWVzLCBvcHRpb25zLCBkYXRhLCBpZCwgZG9jLCBzY2hlbWFPcHRpb25zLCB1bnBvcHVsYXRlZFZhbHVlKTtcbiAgICAgIH1cbiAgICAgIC8vIE5vLW9wIGlmIG5vIGByZWZgIHNldC4gU2VlIGdoLTExNTM4XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICBpZiAoQXJyYXkuaXNBcnJheShzY2hlbWEpKSB7XG4gICAgICBjb25zdCBzY2hlbWFzQXJyYXkgPSBzY2hlbWE7XG4gICAgICBmb3IgKGNvbnN0IF9zY2hlbWEgb2Ygc2NoZW1hc0FycmF5KSB7XG4gICAgICAgIGxldCBfbW9kZWxOYW1lcztcbiAgICAgICAgbGV0IHJlcztcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICByZXMgPSBfZ2V0TW9kZWxOYW1lcyhkb2MsIF9zY2hlbWEsIG1vZGVsTmFtZUZyb21RdWVyeSwgbW9kZWwpO1xuICAgICAgICAgIF9tb2RlbE5hbWVzID0gcmVzLm1vZGVsTmFtZXM7XG4gICAgICAgICAgaXNSZWZQYXRoID0gaXNSZWZQYXRoIHx8IHJlcy5pc1JlZlBhdGg7XG4gICAgICAgICAgbm9ybWFsaXplZFJlZlBhdGggPSBub3JtYWxpemVkUmVmUGF0aCB8fCByZXMucmVmUGF0aDtcbiAgICAgICAgICBqdXN0T25lID0gcmVzLmp1c3RPbmU7XG4gICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgcmV0dXJuIGVycm9yO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGlzUmVmUGF0aCAmJiAhcmVzLmlzUmVmUGF0aCkge1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIGlmICghX21vZGVsTmFtZXMpIHtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBtb2RlbE5hbWVzID0gbW9kZWxOYW1lcyB8fCBbXTtcbiAgICAgICAgZm9yIChjb25zdCBtb2RlbE5hbWUgb2YgX21vZGVsTmFtZXMpIHtcbiAgICAgICAgICBpZiAobW9kZWxOYW1lcy5pbmRleE9mKG1vZGVsTmFtZSkgPT09IC0xKSB7XG4gICAgICAgICAgICBtb2RlbE5hbWVzLnB1c2gobW9kZWxOYW1lKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgdHJ5IHtcbiAgICAgICAgY29uc3QgcmVzID0gX2dldE1vZGVsTmFtZXMoZG9jLCBzY2hlbWEsIG1vZGVsTmFtZUZyb21RdWVyeSwgbW9kZWwpO1xuICAgICAgICBtb2RlbE5hbWVzID0gcmVzLm1vZGVsTmFtZXM7XG4gICAgICAgIGlzUmVmUGF0aCA9IHJlcy5pc1JlZlBhdGg7XG4gICAgICAgIG5vcm1hbGl6ZWRSZWZQYXRoID0gbm9ybWFsaXplZFJlZlBhdGggfHwgcmVzLnJlZlBhdGg7XG4gICAgICAgIGp1c3RPbmUgPSByZXMuanVzdE9uZTtcbiAgICAgICAgc2NoZW1hT3B0aW9ucyA9IGdldChzY2hlbWEsICdvcHRpb25zLnBvcHVsYXRlJywgbnVsbCk7XG4gICAgICAgIC8vIERlZHVwZSwgYmVjYXVzZSBgcmVmUGF0aGAgY2FuIHJldHVybiBkdXBsaWNhdGVzIG9mIHRoZSBzYW1lIG1vZGVsIG5hbWUsXG4gICAgICAgIC8vIGFuZCB0aGF0IGNhdXNlcyBwZXJmIGlzc3Vlcy5cbiAgICAgICAgaWYgKGlzUmVmUGF0aCkge1xuICAgICAgICAgIG1vZGVsTmFtZXNJbk9yZGVyID0gbW9kZWxOYW1lcztcbiAgICAgICAgICBtb2RlbE5hbWVzID0gQXJyYXkuZnJvbShuZXcgU2V0KG1vZGVsTmFtZXMpKTtcbiAgICAgICAgfVxuICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgcmV0dXJuIGVycm9yO1xuICAgICAgfVxuXG4gICAgICBpZiAoIW1vZGVsTmFtZXMpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgfVxuXG4gICAgY29uc3QgZGF0YSA9IHt9O1xuICAgIGNvbnN0IGxvY2FsRmllbGQgPSBvcHRpb25zLnBhdGg7XG4gICAgY29uc3QgZm9yZWlnbkZpZWxkID0gJ19pZCc7XG5cbiAgICAvLyBganVzdE9uZSA9IG51bGxgIG1lYW5zIHdlIGRvbid0IGtub3cgZnJvbSB0aGUgc2NoZW1hIHdoZXRoZXIgdGhlIGVuZFxuICAgIC8vIHJlc3VsdCBzaG91bGQgYmUgYW4gYXJyYXkgb3IgYSBzaW5nbGUgZG9jLiBUaGlzIGNhbiByZXN1bHQgZnJvbVxuICAgIC8vIHBvcHVsYXRpbmcgYSBQT0pPIHVzaW5nIGBNb2RlbC5wb3B1bGF0ZSgpYFxuICAgIGlmICgnanVzdE9uZScgaW4gb3B0aW9ucyAmJiBvcHRpb25zLmp1c3RPbmUgIT09IHZvaWQgMCkge1xuICAgICAganVzdE9uZSA9IG9wdGlvbnMuanVzdE9uZTtcbiAgICB9IGVsc2UgaWYgKHNjaGVtYSAmJiAhc2NoZW1hW3NjaGVtYU1peGVkU3ltYm9sXSkge1xuICAgICAgLy8gU2tpcCBNaXhlZCB0eXBlcyBiZWNhdXNlIHdlIGV4cGxpY2l0bHkgZG9uJ3QgZG8gY2FzdGluZyBvbiB0aG9zZS5cbiAgICAgIGlmIChvcHRpb25zLnBhdGguZW5kc1dpdGgoJy4nICsgc2NoZW1hLnBhdGgpIHx8IG9wdGlvbnMucGF0aCA9PT0gc2NoZW1hLnBhdGgpIHtcbiAgICAgICAganVzdE9uZSA9IEFycmF5LmlzQXJyYXkoc2NoZW1hKSA/XG4gICAgICAgICAgc2NoZW1hLmV2ZXJ5KHNjaGVtYSA9PiAhc2NoZW1hLiRpc01vbmdvb3NlQXJyYXkpIDpcbiAgICAgICAgICAhc2NoZW1hLiRpc01vbmdvb3NlQXJyYXk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKCFtb2RlbE5hbWVzKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICBkYXRhLmlzVmlydHVhbCA9IGZhbHNlO1xuICAgIGRhdGEuanVzdE9uZSA9IGp1c3RPbmU7XG4gICAgZGF0YS5sb2NhbEZpZWxkID0gbG9jYWxGaWVsZDtcbiAgICBkYXRhLmZvcmVpZ25GaWVsZCA9IGZvcmVpZ25GaWVsZDtcblxuICAgIC8vIEdldCBsb2NhbCBmaWVsZHNcbiAgICBjb25zdCByZXQgPSBfZ2V0TG9jYWxGaWVsZFZhbHVlcyhkb2MsIGxvY2FsRmllbGQsIG1vZGVsLCBvcHRpb25zLCBudWxsLCBzY2hlbWEpO1xuXG4gICAgY29uc3QgaWQgPSBTdHJpbmcodXRpbHMuZ2V0VmFsdWUoZm9yZWlnbkZpZWxkLCBkb2MpKTtcbiAgICBvcHRpb25zLl9kb2NzW2lkXSA9IEFycmF5LmlzQXJyYXkocmV0KSA/IHJldC5zbGljZSgpIDogcmV0O1xuXG4gICAgbGV0IG1hdGNoID0gZ2V0KG9wdGlvbnMsICdtYXRjaCcsIG51bGwpO1xuXG4gICAgY29uc3QgaGFzTWF0Y2hGdW5jdGlvbiA9IHR5cGVvZiBtYXRjaCA9PT0gJ2Z1bmN0aW9uJztcbiAgICBpZiAoaGFzTWF0Y2hGdW5jdGlvbikge1xuICAgICAgbWF0Y2ggPSBtYXRjaC5jYWxsKGRvYywgZG9jKTtcbiAgICB9XG4gICAgZGF0YS5tYXRjaCA9IG1hdGNoO1xuICAgIGRhdGEuaGFzTWF0Y2hGdW5jdGlvbiA9IGhhc01hdGNoRnVuY3Rpb247XG4gICAgZGF0YS5pc1JlZlBhdGggPSBpc1JlZlBhdGg7XG4gICAgZGF0YS5tb2RlbE5hbWVzSW5PcmRlciA9IG1vZGVsTmFtZXNJbk9yZGVyO1xuXG4gICAgaWYgKGlzUmVmUGF0aCkge1xuICAgICAgY29uc3QgZW1iZWRkZWREaXNjcmltaW5hdG9yTW9kZWxOYW1lcyA9IF9maW5kUmVmUGF0aEZvckRpc2NyaW1pbmF0b3JzKGRvYyxcbiAgICAgICAgbW9kZWxTY2hlbWEsIGRhdGEsIG9wdGlvbnMsIG5vcm1hbGl6ZWRSZWZQYXRoLCByZXQpO1xuXG4gICAgICBtb2RlbE5hbWVzID0gZW1iZWRkZWREaXNjcmltaW5hdG9yTW9kZWxOYW1lcyB8fCBtb2RlbE5hbWVzO1xuICAgIH1cblxuICAgIHRyeSB7XG4gICAgICBhZGRNb2RlbE5hbWVzVG9NYXAobW9kZWwsIG1hcCwgYXZhaWxhYmxlLCBtb2RlbE5hbWVzLCBvcHRpb25zLCBkYXRhLCByZXQsIGRvYywgc2NoZW1hT3B0aW9ucyk7XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICByZXR1cm4gZXJyO1xuICAgIH1cbiAgfVxuICByZXR1cm4gbWFwO1xuXG4gIGZ1bmN0aW9uIF9nZXRNb2RlbE5hbWVzKGRvYywgc2NoZW1hLCBtb2RlbE5hbWVGcm9tUXVlcnksIG1vZGVsKSB7XG4gICAgbGV0IG1vZGVsTmFtZXM7XG4gICAgbGV0IGlzUmVmUGF0aCA9IGZhbHNlO1xuICAgIGxldCBqdXN0T25lID0gbnVsbDtcblxuICAgIGNvbnN0IG9yaWdpbmFsU2NoZW1hID0gc2NoZW1hO1xuICAgIGlmIChzY2hlbWEgJiYgc2NoZW1hLmluc3RhbmNlID09PSAnQXJyYXknKSB7XG4gICAgICBzY2hlbWEgPSBzY2hlbWEuY2FzdGVyO1xuICAgIH1cbiAgICBpZiAoc2NoZW1hICYmIHNjaGVtYS4kaXNTY2hlbWFNYXApIHtcbiAgICAgIHNjaGVtYSA9IHNjaGVtYS4kX19zY2hlbWFUeXBlO1xuICAgIH1cblxuICAgIGNvbnN0IHJlZiA9IHNjaGVtYSAmJiBzY2hlbWEub3B0aW9ucyAmJiBzY2hlbWEub3B0aW9ucy5yZWY7XG4gICAgcmVmUGF0aCA9IHNjaGVtYSAmJiBzY2hlbWEub3B0aW9ucyAmJiBzY2hlbWEub3B0aW9ucy5yZWZQYXRoO1xuICAgIGlmIChzY2hlbWEgIT0gbnVsbCAmJlxuICAgICAgICBzY2hlbWFbc2NoZW1hTWl4ZWRTeW1ib2xdICYmXG4gICAgICAgICFyZWYgJiZcbiAgICAgICAgIXJlZlBhdGggJiZcbiAgICAgICAgIW1vZGVsTmFtZUZyb21RdWVyeSkge1xuICAgICAgcmV0dXJuIHsgbW9kZWxOYW1lczogbnVsbCB9O1xuICAgIH1cblxuICAgIGlmIChtb2RlbE5hbWVGcm9tUXVlcnkpIHtcbiAgICAgIG1vZGVsTmFtZXMgPSBbbW9kZWxOYW1lRnJvbVF1ZXJ5XTsgLy8gcXVlcnkgb3B0aW9uc1xuICAgIH0gZWxzZSBpZiAocmVmUGF0aCAhPSBudWxsKSB7XG4gICAgICBpZiAodHlwZW9mIHJlZlBhdGggPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgY29uc3Qgc3ViZG9jUGF0aCA9IG9wdGlvbnMucGF0aC5zbGljZSgwLCBvcHRpb25zLnBhdGgubGVuZ3RoIC0gc2NoZW1hLnBhdGgubGVuZ3RoIC0gMSk7XG4gICAgICAgIGNvbnN0IHZhbHMgPSBtcGF0aC5nZXQoc3ViZG9jUGF0aCwgZG9jLCBsb29rdXBMb2NhbEZpZWxkcyk7XG4gICAgICAgIGNvbnN0IHN1YmRvY3NCZWluZ1BvcHVsYXRlZCA9IEFycmF5LmlzQXJyYXkodmFscykgP1xuICAgICAgICAgIHV0aWxzLmFycmF5LmZsYXR0ZW4odmFscykgOlxuICAgICAgICAgICh2YWxzID8gW3ZhbHNdIDogW10pO1xuXG4gICAgICAgIG1vZGVsTmFtZXMgPSBuZXcgU2V0KCk7XG4gICAgICAgIGZvciAoY29uc3Qgc3ViZG9jIG9mIHN1YmRvY3NCZWluZ1BvcHVsYXRlZCkge1xuICAgICAgICAgIHJlZlBhdGggPSByZWZQYXRoLmNhbGwoc3ViZG9jLCBzdWJkb2MsIG9wdGlvbnMucGF0aCk7XG4gICAgICAgICAgbW9kZWxOYW1lc0Zyb21SZWZQYXRoKHJlZlBhdGgsIGRvYywgb3B0aW9ucy5wYXRoLCBtb2RlbFNjaGVtYSwgb3B0aW9ucy5fcXVlcnlQcm9qZWN0aW9uKS5cbiAgICAgICAgICAgIGZvckVhY2gobmFtZSA9PiBtb2RlbE5hbWVzLmFkZChuYW1lKSk7XG4gICAgICAgIH1cbiAgICAgICAgbW9kZWxOYW1lcyA9IEFycmF5LmZyb20obW9kZWxOYW1lcyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBtb2RlbE5hbWVzID0gbW9kZWxOYW1lc0Zyb21SZWZQYXRoKHJlZlBhdGgsIGRvYywgb3B0aW9ucy5wYXRoLCBtb2RlbFNjaGVtYSwgb3B0aW9ucy5fcXVlcnlQcm9qZWN0aW9uKTtcbiAgICAgIH1cblxuICAgICAgaXNSZWZQYXRoID0gdHJ1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgbGV0IHJlZjtcbiAgICAgIGxldCByZWZQYXRoO1xuICAgICAgbGV0IHNjaGVtYUZvckN1cnJlbnREb2M7XG4gICAgICBsZXQgZGlzY3JpbWluYXRvclZhbHVlO1xuICAgICAgbGV0IG1vZGVsRm9yQ3VycmVudERvYyA9IG1vZGVsO1xuICAgICAgY29uc3QgZGlzY3JpbWluYXRvcktleSA9IG1vZGVsLnNjaGVtYS5vcHRpb25zLmRpc2NyaW1pbmF0b3JLZXk7XG5cbiAgICAgIGlmICghc2NoZW1hICYmIGRpc2NyaW1pbmF0b3JLZXkgJiYgKGRpc2NyaW1pbmF0b3JWYWx1ZSA9IHV0aWxzLmdldFZhbHVlKGRpc2NyaW1pbmF0b3JLZXksIGRvYykpKSB7XG4gICAgICAgIC8vIGBtb2RlbE5hbWVGb3JGaW5kYCBpcyB0aGUgZGlzY3JpbWluYXRvciB2YWx1ZSwgc28gd2UgbWlnaHQgbmVlZFxuICAgICAgICAvLyBmaW5kIHRoZSBkaXNjcmltaW5hdGVkIG1vZGVsIG5hbWVcbiAgICAgICAgY29uc3QgZGlzY3JpbWluYXRvck1vZGVsID0gZ2V0RGlzY3JpbWluYXRvckJ5VmFsdWUobW9kZWwuZGlzY3JpbWluYXRvcnMsIGRpc2NyaW1pbmF0b3JWYWx1ZSkgfHwgbW9kZWw7XG4gICAgICAgIGlmIChkaXNjcmltaW5hdG9yTW9kZWwgIT0gbnVsbCkge1xuICAgICAgICAgIG1vZGVsRm9yQ3VycmVudERvYyA9IGRpc2NyaW1pbmF0b3JNb2RlbDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgbW9kZWxGb3JDdXJyZW50RG9jID0gX2dldE1vZGVsRnJvbUNvbm4obW9kZWwuZGIsIGRpc2NyaW1pbmF0b3JWYWx1ZSk7XG4gICAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIHJldHVybiBlcnJvcjtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBzY2hlbWFGb3JDdXJyZW50RG9jID0gbW9kZWxGb3JDdXJyZW50RG9jLnNjaGVtYS5fZ2V0U2NoZW1hKG9wdGlvbnMucGF0aCk7XG5cbiAgICAgICAgaWYgKHNjaGVtYUZvckN1cnJlbnREb2MgJiYgc2NoZW1hRm9yQ3VycmVudERvYy5jYXN0ZXIpIHtcbiAgICAgICAgICBzY2hlbWFGb3JDdXJyZW50RG9jID0gc2NoZW1hRm9yQ3VycmVudERvYy5jYXN0ZXI7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHNjaGVtYUZvckN1cnJlbnREb2MgPSBzY2hlbWE7XG4gICAgICB9XG5cbiAgICAgIGlmIChvcmlnaW5hbFNjaGVtYSAmJiBvcmlnaW5hbFNjaGVtYS5wYXRoLmVuZHNXaXRoKCcuJConKSkge1xuICAgICAgICBqdXN0T25lID0gIW9yaWdpbmFsU2NoZW1hLiRpc01vbmdvb3NlQXJyYXkgJiYgIW9yaWdpbmFsU2NoZW1hLl9hcnJheVBhdGg7XG4gICAgICB9IGVsc2UgaWYgKHNjaGVtYUZvckN1cnJlbnREb2MgIT0gbnVsbCkge1xuICAgICAgICBqdXN0T25lID0gIXNjaGVtYUZvckN1cnJlbnREb2MuJGlzTW9uZ29vc2VBcnJheSAmJiAhc2NoZW1hRm9yQ3VycmVudERvYy5fYXJyYXlQYXRoO1xuICAgICAgfVxuXG4gICAgICBpZiAoKHJlZiA9IGdldChzY2hlbWFGb3JDdXJyZW50RG9jLCAnb3B0aW9ucy5yZWYnKSkgIT0gbnVsbCkge1xuICAgICAgICBpZiAoc2NoZW1hRm9yQ3VycmVudERvYyAhPSBudWxsICYmXG4gICAgICAgICAgICB0eXBlb2YgcmVmID09PSAnZnVuY3Rpb24nICYmXG4gICAgICAgICAgICBvcHRpb25zLnBhdGguZW5kc1dpdGgoJy4nICsgc2NoZW1hRm9yQ3VycmVudERvYy5wYXRoKSkge1xuICAgICAgICAgIC8vIEVuc3VyZSBjb3JyZWN0IGNvbnRleHQgZm9yIHJlZiBmdW5jdGlvbnM6IHN1YmRvYywgbm90IHRvcC1sZXZlbCBkb2MuIFNlZSBnaC04NDY5XG4gICAgICAgICAgbW9kZWxOYW1lcyA9IG5ldyBTZXQoKTtcblxuICAgICAgICAgIGNvbnN0IHN1YmRvY1BhdGggPSBvcHRpb25zLnBhdGguc2xpY2UoMCwgb3B0aW9ucy5wYXRoLmxlbmd0aCAtIHNjaGVtYUZvckN1cnJlbnREb2MucGF0aC5sZW5ndGggLSAxKTtcbiAgICAgICAgICBjb25zdCB2YWxzID0gbXBhdGguZ2V0KHN1YmRvY1BhdGgsIGRvYywgbG9va3VwTG9jYWxGaWVsZHMpO1xuICAgICAgICAgIGNvbnN0IHN1YmRvY3NCZWluZ1BvcHVsYXRlZCA9IEFycmF5LmlzQXJyYXkodmFscykgP1xuICAgICAgICAgICAgdXRpbHMuYXJyYXkuZmxhdHRlbih2YWxzKSA6XG4gICAgICAgICAgICAodmFscyA/IFt2YWxzXSA6IFtdKTtcbiAgICAgICAgICBmb3IgKGNvbnN0IHN1YmRvYyBvZiBzdWJkb2NzQmVpbmdQb3B1bGF0ZWQpIHtcbiAgICAgICAgICAgIG1vZGVsTmFtZXMuYWRkKGhhbmRsZVJlZkZ1bmN0aW9uKHJlZiwgc3ViZG9jKSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKHN1YmRvY3NCZWluZ1BvcHVsYXRlZC5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIG1vZGVsTmFtZXMgPSBbaGFuZGxlUmVmRnVuY3Rpb24ocmVmLCBkb2MpXTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbW9kZWxOYW1lcyA9IEFycmF5LmZyb20obW9kZWxOYW1lcyk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJlZiA9IGhhbmRsZVJlZkZ1bmN0aW9uKHJlZiwgZG9jKTtcbiAgICAgICAgICBtb2RlbE5hbWVzID0gW3JlZl07XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoKHNjaGVtYUZvckN1cnJlbnREb2MgPSBnZXQoc2NoZW1hLCAnb3B0aW9ucy5yZWZQYXRoJykpICE9IG51bGwpIHtcbiAgICAgICAgaXNSZWZQYXRoID0gdHJ1ZTtcbiAgICAgICAgaWYgKHR5cGVvZiByZWZQYXRoID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgY29uc3Qgc3ViZG9jUGF0aCA9IG9wdGlvbnMucGF0aC5zbGljZSgwLCBvcHRpb25zLnBhdGgubGVuZ3RoIC0gc2NoZW1hRm9yQ3VycmVudERvYy5wYXRoLmxlbmd0aCAtIDEpO1xuICAgICAgICAgIGNvbnN0IHZhbHMgPSBtcGF0aC5nZXQoc3ViZG9jUGF0aCwgZG9jLCBsb29rdXBMb2NhbEZpZWxkcyk7XG4gICAgICAgICAgY29uc3Qgc3ViZG9jc0JlaW5nUG9wdWxhdGVkID0gQXJyYXkuaXNBcnJheSh2YWxzKSA/XG4gICAgICAgICAgICB1dGlscy5hcnJheS5mbGF0dGVuKHZhbHMpIDpcbiAgICAgICAgICAgICh2YWxzID8gW3ZhbHNdIDogW10pO1xuXG4gICAgICAgICAgbW9kZWxOYW1lcyA9IG5ldyBTZXQoKTtcbiAgICAgICAgICBmb3IgKGNvbnN0IHN1YmRvYyBvZiBzdWJkb2NzQmVpbmdQb3B1bGF0ZWQpIHtcbiAgICAgICAgICAgIHJlZlBhdGggPSByZWZQYXRoLmNhbGwoc3ViZG9jLCBzdWJkb2MsIG9wdGlvbnMucGF0aCk7XG4gICAgICAgICAgICBtb2RlbE5hbWVzRnJvbVJlZlBhdGgocmVmUGF0aCwgZG9jLCBvcHRpb25zLnBhdGgsIG1vZGVsU2NoZW1hLCBvcHRpb25zLl9xdWVyeVByb2plY3Rpb24pLlxuICAgICAgICAgICAgICBmb3JFYWNoKG5hbWUgPT4gbW9kZWxOYW1lcy5hZGQobmFtZSkpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBtb2RlbE5hbWVzID0gQXJyYXkuZnJvbShtb2RlbE5hbWVzKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBtb2RlbE5hbWVzID0gbW9kZWxOYW1lc0Zyb21SZWZQYXRoKHJlZlBhdGgsIGRvYywgb3B0aW9ucy5wYXRoLCBtb2RlbFNjaGVtYSwgb3B0aW9ucy5fcXVlcnlQcm9qZWN0aW9uKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGlmICghbW9kZWxOYW1lcykge1xuICAgICAgLy8gYE1vZGVsLnBvcHVsYXRlKClgIG9uIGEgUE9KTyB3aXRoIG5vIGtub3duIGxvY2FsIG1vZGVsLiBEZWZhdWx0IHRvIHVzaW5nIHRoZSBgTW9kZWxgXG4gICAgICBpZiAob3B0aW9ucy5fbG9jYWxNb2RlbCA9PSBudWxsKSB7XG4gICAgICAgIG1vZGVsTmFtZXMgPSBbbW9kZWwubW9kZWxOYW1lXTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiB7IG1vZGVsTmFtZXM6IG1vZGVsTmFtZXMsIGp1c3RPbmU6IGp1c3RPbmUsIGlzUmVmUGF0aDogaXNSZWZQYXRoLCByZWZQYXRoOiByZWZQYXRoIH07XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKCFBcnJheS5pc0FycmF5KG1vZGVsTmFtZXMpKSB7XG4gICAgICBtb2RlbE5hbWVzID0gW21vZGVsTmFtZXNdO1xuICAgIH1cblxuICAgIHJldHVybiB7IG1vZGVsTmFtZXM6IG1vZGVsTmFtZXMsIGp1c3RPbmU6IGp1c3RPbmUsIGlzUmVmUGF0aDogaXNSZWZQYXRoLCByZWZQYXRoOiByZWZQYXRoIH07XG4gIH1cbn07XG5cbi8qIVxuICogaWdub3JlXG4gKi9cblxuZnVuY3Rpb24gX3ZpcnR1YWxQb3B1bGF0ZShtb2RlbCwgZG9jcywgb3B0aW9ucywgX3ZpcnR1YWxSZXMpIHtcbiAgY29uc3QgbWFwID0gW107XG4gIGNvbnN0IGF2YWlsYWJsZSA9IHt9O1xuICBjb25zdCB2aXJ0dWFsID0gX3ZpcnR1YWxSZXMudmlydHVhbDtcblxuICBmb3IgKGNvbnN0IGRvYyBvZiBkb2NzKSB7XG4gICAgbGV0IG1vZGVsTmFtZXMgPSBudWxsO1xuICAgIGNvbnN0IGRhdGEgPSB7fTtcblxuICAgIC8vIGxvY2FsRmllbGQgYW5kIGZvcmVpZ25GaWVsZFxuICAgIGxldCBsb2NhbEZpZWxkO1xuICAgIGNvbnN0IHZpcnR1YWxQcmVmaXggPSBfdmlydHVhbFJlcy5uZXN0ZWRTY2hlbWFQYXRoID9cbiAgICAgIF92aXJ0dWFsUmVzLm5lc3RlZFNjaGVtYVBhdGggKyAnLicgOiAnJztcbiAgICBpZiAodHlwZW9mIG9wdGlvbnMubG9jYWxGaWVsZCA9PT0gJ3N0cmluZycpIHtcbiAgICAgIGxvY2FsRmllbGQgPSBvcHRpb25zLmxvY2FsRmllbGQ7XG4gICAgfSBlbHNlIGlmICh0eXBlb2YgdmlydHVhbC5vcHRpb25zLmxvY2FsRmllbGQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIGxvY2FsRmllbGQgPSB2aXJ0dWFsUHJlZml4ICsgdmlydHVhbC5vcHRpb25zLmxvY2FsRmllbGQuY2FsbChkb2MsIGRvYyk7XG4gICAgfSBlbHNlIGlmIChBcnJheS5pc0FycmF5KHZpcnR1YWwub3B0aW9ucy5sb2NhbEZpZWxkKSkge1xuICAgICAgbG9jYWxGaWVsZCA9IHZpcnR1YWwub3B0aW9ucy5sb2NhbEZpZWxkLm1hcChmaWVsZCA9PiB2aXJ0dWFsUHJlZml4ICsgZmllbGQpO1xuICAgIH0gZWxzZSB7XG4gICAgICBsb2NhbEZpZWxkID0gdmlydHVhbFByZWZpeCArIHZpcnR1YWwub3B0aW9ucy5sb2NhbEZpZWxkO1xuICAgIH1cbiAgICBkYXRhLmNvdW50ID0gdmlydHVhbC5vcHRpb25zLmNvdW50O1xuXG4gICAgaWYgKHZpcnR1YWwub3B0aW9ucy5za2lwICE9IG51bGwgJiYgIW9wdGlvbnMuaGFzT3duUHJvcGVydHkoJ3NraXAnKSkge1xuICAgICAgb3B0aW9ucy5za2lwID0gdmlydHVhbC5vcHRpb25zLnNraXA7XG4gICAgfVxuICAgIGlmICh2aXJ0dWFsLm9wdGlvbnMubGltaXQgIT0gbnVsbCAmJiAhb3B0aW9ucy5oYXNPd25Qcm9wZXJ0eSgnbGltaXQnKSkge1xuICAgICAgb3B0aW9ucy5saW1pdCA9IHZpcnR1YWwub3B0aW9ucy5saW1pdDtcbiAgICB9XG4gICAgaWYgKHZpcnR1YWwub3B0aW9ucy5wZXJEb2N1bWVudExpbWl0ICE9IG51bGwgJiYgIW9wdGlvbnMuaGFzT3duUHJvcGVydHkoJ3BlckRvY3VtZW50TGltaXQnKSkge1xuICAgICAgb3B0aW9ucy5wZXJEb2N1bWVudExpbWl0ID0gdmlydHVhbC5vcHRpb25zLnBlckRvY3VtZW50TGltaXQ7XG4gICAgfVxuICAgIGxldCBmb3JlaWduRmllbGQgPSB2aXJ0dWFsLm9wdGlvbnMuZm9yZWlnbkZpZWxkO1xuXG4gICAgaWYgKCFsb2NhbEZpZWxkIHx8ICFmb3JlaWduRmllbGQpIHtcbiAgICAgIHJldHVybiBuZXcgTW9uZ29vc2VFcnJvcihgQ2Fubm90IHBvcHVsYXRlIHZpcnR1YWwgXFxgJHtvcHRpb25zLnBhdGh9XFxgIG9uIG1vZGVsIFxcYCR7bW9kZWwubW9kZWxOYW1lfVxcYCwgYmVjYXVzZSBvcHRpb25zIFxcYGxvY2FsRmllbGRcXGAgYW5kIC8gb3IgXFxgZm9yZWlnbkZpZWxkXFxgIGFyZSBtaXNzaW5nYCk7XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiBsb2NhbEZpZWxkID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBsb2NhbEZpZWxkID0gbG9jYWxGaWVsZC5jYWxsKGRvYywgZG9jKTtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBmb3JlaWduRmllbGQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIGZvcmVpZ25GaWVsZCA9IGZvcmVpZ25GaWVsZC5jYWxsKGRvYywgZG9jKTtcbiAgICB9XG5cbiAgICBkYXRhLmlzUmVmUGF0aCA9IGZhbHNlO1xuXG4gICAgLy8gYGp1c3RPbmUgPSBudWxsYCBtZWFucyB3ZSBkb24ndCBrbm93IGZyb20gdGhlIHNjaGVtYSB3aGV0aGVyIHRoZSBlbmRcbiAgICAvLyByZXN1bHQgc2hvdWxkIGJlIGFuIGFycmF5IG9yIGEgc2luZ2xlIGRvYy4gVGhpcyBjYW4gcmVzdWx0IGZyb21cbiAgICAvLyBwb3B1bGF0aW5nIGEgUE9KTyB1c2luZyBgTW9kZWwucG9wdWxhdGUoKWBcbiAgICBsZXQganVzdE9uZSA9IG51bGw7XG4gICAgaWYgKCdqdXN0T25lJyBpbiBvcHRpb25zICYmIG9wdGlvbnMuanVzdE9uZSAhPT0gdm9pZCAwKSB7XG4gICAgICBqdXN0T25lID0gb3B0aW9ucy5qdXN0T25lO1xuICAgIH1cblxuICAgIGlmICh2aXJ0dWFsLm9wdGlvbnMucmVmUGF0aCkge1xuICAgICAgbW9kZWxOYW1lcyA9XG4gICAgICAgIG1vZGVsTmFtZXNGcm9tUmVmUGF0aCh2aXJ0dWFsLm9wdGlvbnMucmVmUGF0aCwgZG9jLCBvcHRpb25zLnBhdGgpO1xuICAgICAganVzdE9uZSA9ICEhdmlydHVhbC5vcHRpb25zLmp1c3RPbmU7XG4gICAgICBkYXRhLmlzUmVmUGF0aCA9IHRydWU7XG4gICAgfSBlbHNlIGlmICh2aXJ0dWFsLm9wdGlvbnMucmVmKSB7XG4gICAgICBsZXQgbm9ybWFsaXplZFJlZjtcbiAgICAgIGlmICh0eXBlb2YgdmlydHVhbC5vcHRpb25zLnJlZiA9PT0gJ2Z1bmN0aW9uJyAmJiAhdmlydHVhbC5vcHRpb25zLnJlZlttb2RlbFN5bWJvbF0pIHtcbiAgICAgICAgbm9ybWFsaXplZFJlZiA9IHZpcnR1YWwub3B0aW9ucy5yZWYuY2FsbChkb2MsIGRvYyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBub3JtYWxpemVkUmVmID0gdmlydHVhbC5vcHRpb25zLnJlZjtcbiAgICAgIH1cbiAgICAgIGp1c3RPbmUgPSAhIXZpcnR1YWwub3B0aW9ucy5qdXN0T25lO1xuICAgICAgLy8gV2hlbiByZWZlcmVuY2luZyBuZXN0ZWQgYXJyYXlzLCB0aGUgcmVmIHNob3VsZCBiZSBhbiBBcnJheVxuICAgICAgLy8gb2YgbW9kZWxOYW1lcy5cbiAgICAgIGlmIChBcnJheS5pc0FycmF5KG5vcm1hbGl6ZWRSZWYpKSB7XG4gICAgICAgIG1vZGVsTmFtZXMgPSBub3JtYWxpemVkUmVmO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbW9kZWxOYW1lcyA9IFtub3JtYWxpemVkUmVmXTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBkYXRhLmlzVmlydHVhbCA9IHRydWU7XG4gICAgZGF0YS52aXJ0dWFsID0gdmlydHVhbDtcbiAgICBkYXRhLmp1c3RPbmUgPSBqdXN0T25lO1xuXG4gICAgLy8gYG1hdGNoYFxuICAgIGNvbnN0IGJhc2VNYXRjaCA9IGdldChkYXRhLCAndmlydHVhbC5vcHRpb25zLm1hdGNoJywgbnVsbCkgfHxcbiAgICAgIGdldChkYXRhLCAndmlydHVhbC5vcHRpb25zLm9wdGlvbnMubWF0Y2gnLCBudWxsKTtcbiAgICBsZXQgbWF0Y2ggPSBnZXQob3B0aW9ucywgJ21hdGNoJywgbnVsbCkgfHwgYmFzZU1hdGNoO1xuXG4gICAgbGV0IGhhc01hdGNoRnVuY3Rpb24gPSB0eXBlb2YgbWF0Y2ggPT09ICdmdW5jdGlvbic7XG4gICAgaWYgKGhhc01hdGNoRnVuY3Rpb24pIHtcbiAgICAgIG1hdGNoID0gbWF0Y2guY2FsbChkb2MsIGRvYywgZGF0YS52aXJ0dWFsKTtcbiAgICB9XG5cbiAgICBpZiAoQXJyYXkuaXNBcnJheShsb2NhbEZpZWxkKSAmJiBBcnJheS5pc0FycmF5KGZvcmVpZ25GaWVsZCkgJiYgbG9jYWxGaWVsZC5sZW5ndGggPT09IGZvcmVpZ25GaWVsZC5sZW5ndGgpIHtcbiAgICAgIG1hdGNoID0gT2JqZWN0LmFzc2lnbih7fSwgbWF0Y2gpO1xuICAgICAgZm9yIChsZXQgaSA9IDE7IGkgPCBsb2NhbEZpZWxkLmxlbmd0aDsgKytpKSB7XG4gICAgICAgIG1hdGNoW2ZvcmVpZ25GaWVsZFtpXV0gPSBjb252ZXJ0VG9faWQobXBhdGguZ2V0KGxvY2FsRmllbGRbaV0sIGRvYywgbG9va3VwTG9jYWxGaWVsZHMpLCBtb2RlbC5zY2hlbWEpO1xuICAgICAgICBoYXNNYXRjaEZ1bmN0aW9uID0gdHJ1ZTtcbiAgICAgIH1cblxuICAgICAgbG9jYWxGaWVsZCA9IGxvY2FsRmllbGRbMF07XG4gICAgICBmb3JlaWduRmllbGQgPSBmb3JlaWduRmllbGRbMF07XG4gICAgfVxuICAgIGRhdGEubG9jYWxGaWVsZCA9IGxvY2FsRmllbGQ7XG4gICAgZGF0YS5mb3JlaWduRmllbGQgPSBmb3JlaWduRmllbGQ7XG4gICAgZGF0YS5tYXRjaCA9IG1hdGNoO1xuICAgIGRhdGEuaGFzTWF0Y2hGdW5jdGlvbiA9IGhhc01hdGNoRnVuY3Rpb247XG5cbiAgICAvLyBHZXQgbG9jYWwgZmllbGRzXG4gICAgY29uc3QgcmV0ID0gX2dldExvY2FsRmllbGRWYWx1ZXMoZG9jLCBsb2NhbEZpZWxkLCBtb2RlbCwgb3B0aW9ucywgdmlydHVhbCk7XG5cbiAgICB0cnkge1xuICAgICAgYWRkTW9kZWxOYW1lc1RvTWFwKG1vZGVsLCBtYXAsIGF2YWlsYWJsZSwgbW9kZWxOYW1lcywgb3B0aW9ucywgZGF0YSwgcmV0LCBkb2MpO1xuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgcmV0dXJuIGVycjtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gbWFwO1xufVxuXG4vKiFcbiAqIGlnbm9yZVxuICovXG5cbmZ1bmN0aW9uIGFkZE1vZGVsTmFtZXNUb01hcChtb2RlbCwgbWFwLCBhdmFpbGFibGUsIG1vZGVsTmFtZXMsIG9wdGlvbnMsIGRhdGEsIHJldCwgZG9jLCBzY2hlbWFPcHRpb25zLCB1bnBvcHVsYXRlZFZhbHVlKSB7XG4gIC8vIGBQb3B1bGF0ZU9wdGlvbnMjY29ubmVjdGlvbmA6IGlmIHRoZSBtb2RlbCBpcyBwYXNzZWQgYXMgYSBzdHJpbmcsIHRoZVxuICAvLyBjb25uZWN0aW9uIG1hdHRlcnMgYmVjYXVzZSBkaWZmZXJlbnQgY29ubmVjdGlvbnMgaGF2ZSBkaWZmZXJlbnQgbW9kZWxzLlxuICBjb25zdCBjb25uZWN0aW9uID0gb3B0aW9ucy5jb25uZWN0aW9uICE9IG51bGwgPyBvcHRpb25zLmNvbm5lY3Rpb24gOiBtb2RlbC5kYjtcblxuICB1bnBvcHVsYXRlZFZhbHVlID0gdW5wb3B1bGF0ZWRWYWx1ZSA9PT0gdm9pZCAwID8gcmV0IDogdW5wb3B1bGF0ZWRWYWx1ZTtcbiAgaWYgKEFycmF5LmlzQXJyYXkodW5wb3B1bGF0ZWRWYWx1ZSkpIHtcbiAgICB1bnBvcHVsYXRlZFZhbHVlID0gdXRpbHMuY2xvbmVBcnJheXModW5wb3B1bGF0ZWRWYWx1ZSk7XG4gIH1cblxuICBpZiAobW9kZWxOYW1lcyA9PSBudWxsKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgbGV0IGsgPSBtb2RlbE5hbWVzLmxlbmd0aDtcbiAgd2hpbGUgKGstLSkge1xuICAgIGNvbnN0IG1vZGVsTmFtZSA9IG1vZGVsTmFtZXNba107XG4gICAgaWYgKG1vZGVsTmFtZSA9PSBudWxsKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICBsZXQgTW9kZWw7XG4gICAgaWYgKG9wdGlvbnMubW9kZWwgJiYgb3B0aW9ucy5tb2RlbFttb2RlbFN5bWJvbF0pIHtcbiAgICAgIE1vZGVsID0gb3B0aW9ucy5tb2RlbDtcbiAgICB9IGVsc2UgaWYgKG1vZGVsTmFtZVttb2RlbFN5bWJvbF0pIHtcbiAgICAgIE1vZGVsID0gbW9kZWxOYW1lO1xuICAgIH0gZWxzZSB7XG4gICAgICB0cnkge1xuICAgICAgICBNb2RlbCA9IF9nZXRNb2RlbEZyb21Db25uKGNvbm5lY3Rpb24sIG1vZGVsTmFtZSk7XG4gICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgaWYgKHJldCAhPT0gdm9pZCAwKSB7XG4gICAgICAgICAgdGhyb3cgZXJyO1xuICAgICAgICB9XG4gICAgICAgIE1vZGVsID0gbnVsbDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBsZXQgaWRzID0gcmV0O1xuICAgIGNvbnN0IGZsYXQgPSBBcnJheS5pc0FycmF5KHJldCkgPyB1dGlscy5hcnJheS5mbGF0dGVuKHJldCkgOiBbXTtcblxuICAgIGNvbnN0IG1vZGVsTmFtZXNGb3JSZWZQYXRoID0gZGF0YS5tb2RlbE5hbWVzSW5PcmRlciA/IGRhdGEubW9kZWxOYW1lc0luT3JkZXIgOiBtb2RlbE5hbWVzO1xuICAgIGlmIChkYXRhLmlzUmVmUGF0aCAmJiBBcnJheS5pc0FycmF5KHJldCkgJiYgZmxhdC5sZW5ndGggPT09IG1vZGVsTmFtZXNGb3JSZWZQYXRoLmxlbmd0aCkge1xuICAgICAgaWRzID0gZmxhdC5maWx0ZXIoKHZhbCwgaSkgPT4gbW9kZWxOYW1lc0ZvclJlZlBhdGhbaV0gPT09IG1vZGVsTmFtZSk7XG4gICAgfVxuXG4gICAgY29uc3QgcGVyRG9jdW1lbnRMaW1pdCA9IG9wdGlvbnMucGVyRG9jdW1lbnRMaW1pdCA9PSBudWxsID9cbiAgICAgIGdldChvcHRpb25zLCAnb3B0aW9ucy5wZXJEb2N1bWVudExpbWl0JywgbnVsbCkgOlxuICAgICAgb3B0aW9ucy5wZXJEb2N1bWVudExpbWl0O1xuXG4gICAgaWYgKCFhdmFpbGFibGVbbW9kZWxOYW1lXSB8fCBwZXJEb2N1bWVudExpbWl0ICE9IG51bGwpIHtcbiAgICAgIGNvbnN0IGN1cnJlbnRPcHRpb25zID0ge1xuICAgICAgICBtb2RlbDogTW9kZWxcbiAgICAgIH07XG4gICAgICBpZiAoZGF0YS5pc1ZpcnR1YWwgJiYgZ2V0KGRhdGEudmlydHVhbCwgJ29wdGlvbnMub3B0aW9ucycpKSB7XG4gICAgICAgIGN1cnJlbnRPcHRpb25zLm9wdGlvbnMgPSBjbG9uZShkYXRhLnZpcnR1YWwub3B0aW9ucy5vcHRpb25zKTtcbiAgICAgIH0gZWxzZSBpZiAoc2NoZW1hT3B0aW9ucyAhPSBudWxsKSB7XG4gICAgICAgIGN1cnJlbnRPcHRpb25zLm9wdGlvbnMgPSBPYmplY3QuYXNzaWduKHt9LCBzY2hlbWFPcHRpb25zKTtcbiAgICAgIH1cbiAgICAgIHV0aWxzLm1lcmdlKGN1cnJlbnRPcHRpb25zLCBvcHRpb25zKTtcblxuICAgICAgLy8gVXNlZCBpbnRlcm5hbGx5IGZvciBjaGVja2luZyB3aGF0IG1vZGVsIHdhcyB1c2VkIHRvIHBvcHVsYXRlIHRoaXNcbiAgICAgIC8vIHBhdGguXG4gICAgICBvcHRpb25zW3BvcHVsYXRlTW9kZWxTeW1ib2xdID0gTW9kZWw7XG4gICAgICBjdXJyZW50T3B0aW9uc1twb3B1bGF0ZU1vZGVsU3ltYm9sXSA9IE1vZGVsO1xuICAgICAgYXZhaWxhYmxlW21vZGVsTmFtZV0gPSB7XG4gICAgICAgIG1vZGVsOiBNb2RlbCxcbiAgICAgICAgb3B0aW9uczogY3VycmVudE9wdGlvbnMsXG4gICAgICAgIG1hdGNoOiBkYXRhLmhhc01hdGNoRnVuY3Rpb24gPyBbZGF0YS5tYXRjaF0gOiBkYXRhLm1hdGNoLFxuICAgICAgICBkb2NzOiBbZG9jXSxcbiAgICAgICAgaWRzOiBbaWRzXSxcbiAgICAgICAgYWxsSWRzOiBbcmV0XSxcbiAgICAgICAgdW5wb3B1bGF0ZWRWYWx1ZXM6IFt1bnBvcHVsYXRlZFZhbHVlXSxcbiAgICAgICAgbG9jYWxGaWVsZDogbmV3IFNldChbZGF0YS5sb2NhbEZpZWxkXSksXG4gICAgICAgIGZvcmVpZ25GaWVsZDogbmV3IFNldChbZGF0YS5mb3JlaWduRmllbGRdKSxcbiAgICAgICAganVzdE9uZTogZGF0YS5qdXN0T25lLFxuICAgICAgICBpc1ZpcnR1YWw6IGRhdGEuaXNWaXJ0dWFsLFxuICAgICAgICB2aXJ0dWFsOiBkYXRhLnZpcnR1YWwsXG4gICAgICAgIGNvdW50OiBkYXRhLmNvdW50LFxuICAgICAgICBbcG9wdWxhdGVNb2RlbFN5bWJvbF06IE1vZGVsXG4gICAgICB9O1xuICAgICAgbWFwLnB1c2goYXZhaWxhYmxlW21vZGVsTmFtZV0pO1xuICAgIH0gZWxzZSB7XG4gICAgICBhdmFpbGFibGVbbW9kZWxOYW1lXS5sb2NhbEZpZWxkLmFkZChkYXRhLmxvY2FsRmllbGQpO1xuICAgICAgYXZhaWxhYmxlW21vZGVsTmFtZV0uZm9yZWlnbkZpZWxkLmFkZChkYXRhLmZvcmVpZ25GaWVsZCk7XG4gICAgICBhdmFpbGFibGVbbW9kZWxOYW1lXS5kb2NzLnB1c2goZG9jKTtcbiAgICAgIGF2YWlsYWJsZVttb2RlbE5hbWVdLmlkcy5wdXNoKGlkcyk7XG4gICAgICBhdmFpbGFibGVbbW9kZWxOYW1lXS5hbGxJZHMucHVzaChyZXQpO1xuICAgICAgYXZhaWxhYmxlW21vZGVsTmFtZV0udW5wb3B1bGF0ZWRWYWx1ZXMucHVzaCh1bnBvcHVsYXRlZFZhbHVlKTtcbiAgICAgIGlmIChkYXRhLmhhc01hdGNoRnVuY3Rpb24pIHtcbiAgICAgICAgYXZhaWxhYmxlW21vZGVsTmFtZV0ubWF0Y2gucHVzaChkYXRhLm1hdGNoKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gX2dldE1vZGVsRnJvbUNvbm4oY29ubiwgbW9kZWxOYW1lKSB7XG4gIC8qIElmIHRoaXMgY29ubmVjdGlvbiBoYXMgYSBwYXJlbnQgZnJvbSBgdXNlRGIoKWAsIGJ1YmJsZSB1cCB0byBwYXJlbnQncyBtb2RlbHMgKi9cbiAgaWYgKGNvbm4ubW9kZWxzW21vZGVsTmFtZV0gPT0gbnVsbCAmJiBjb25uLl9wYXJlbnQgIT0gbnVsbCkge1xuICAgIHJldHVybiBfZ2V0TW9kZWxGcm9tQ29ubihjb25uLl9wYXJlbnQsIG1vZGVsTmFtZSk7XG4gIH1cblxuICByZXR1cm4gY29ubi5tb2RlbChtb2RlbE5hbWUpO1xufVxuXG4vKiFcbiAqIGlnbm9yZVxuICovXG5cbmZ1bmN0aW9uIGhhbmRsZVJlZkZ1bmN0aW9uKHJlZiwgZG9jKSB7XG4gIGlmICh0eXBlb2YgcmVmID09PSAnZnVuY3Rpb24nICYmICFyZWZbbW9kZWxTeW1ib2xdKSB7XG4gICAgcmV0dXJuIHJlZi5jYWxsKGRvYywgZG9jKTtcbiAgfVxuICByZXR1cm4gcmVmO1xufVxuXG4vKiFcbiAqIGlnbm9yZVxuICovXG5cbmZ1bmN0aW9uIF9nZXRMb2NhbEZpZWxkVmFsdWVzKGRvYywgbG9jYWxGaWVsZCwgbW9kZWwsIG9wdGlvbnMsIHZpcnR1YWwsIHNjaGVtYSkge1xuICAvLyBHZXQgTG9jYWwgZmllbGRzXG4gIGNvbnN0IGxvY2FsRmllbGRQYXRoVHlwZSA9IG1vZGVsLnNjaGVtYS5fZ2V0UGF0aFR5cGUobG9jYWxGaWVsZCk7XG4gIGNvbnN0IGxvY2FsRmllbGRQYXRoID0gbG9jYWxGaWVsZFBhdGhUeXBlID09PSAncmVhbCcgP1xuICAgIG1vZGVsLnNjaGVtYS5wYXRoKGxvY2FsRmllbGQpIDpcbiAgICBsb2NhbEZpZWxkUGF0aFR5cGUuc2NoZW1hO1xuICBjb25zdCBsb2NhbEZpZWxkR2V0dGVycyA9IGxvY2FsRmllbGRQYXRoICYmIGxvY2FsRmllbGRQYXRoLmdldHRlcnMgP1xuICAgIGxvY2FsRmllbGRQYXRoLmdldHRlcnMgOiBbXTtcblxuICBsb2NhbEZpZWxkID0gbG9jYWxGaWVsZFBhdGggIT0gbnVsbCAmJiBsb2NhbEZpZWxkUGF0aC5pbnN0YW5jZSA9PT0gJ0VtYmVkZGVkJyA/IGxvY2FsRmllbGQgKyAnLl9pZCcgOiBsb2NhbEZpZWxkO1xuXG4gIGNvbnN0IF9wb3B1bGF0ZU9wdGlvbnMgPSBnZXQob3B0aW9ucywgJ29wdGlvbnMnLCB7fSk7XG5cbiAgY29uc3QgZ2V0dGVycyA9ICdnZXR0ZXJzJyBpbiBfcG9wdWxhdGVPcHRpb25zID9cbiAgICBfcG9wdWxhdGVPcHRpb25zLmdldHRlcnMgOlxuICAgIGdldCh2aXJ0dWFsLCAnb3B0aW9ucy5nZXR0ZXJzJywgZmFsc2UpO1xuICBpZiAobG9jYWxGaWVsZEdldHRlcnMubGVuZ3RoICE9PSAwICYmIGdldHRlcnMpIHtcbiAgICBjb25zdCBoeWRyYXRlZERvYyA9IChkb2MuJF9fICE9IG51bGwpID8gZG9jIDogbW9kZWwuaHlkcmF0ZShkb2MpO1xuICAgIGNvbnN0IGxvY2FsRmllbGRWYWx1ZSA9IHV0aWxzLmdldFZhbHVlKGxvY2FsRmllbGQsIGRvYyk7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkobG9jYWxGaWVsZFZhbHVlKSkge1xuICAgICAgY29uc3QgbG9jYWxGaWVsZEh5ZHJhdGVkVmFsdWUgPSB1dGlscy5nZXRWYWx1ZShsb2NhbEZpZWxkLnNwbGl0KCcuJykuc2xpY2UoMCwgLTEpLCBoeWRyYXRlZERvYyk7XG4gICAgICByZXR1cm4gbG9jYWxGaWVsZFZhbHVlLm1hcCgobG9jYWxGaWVsZEFyclZhbCwgbG9jYWxGaWVsZEFyckluZGV4KSA9PlxuICAgICAgICBsb2NhbEZpZWxkUGF0aC5hcHBseUdldHRlcnMobG9jYWxGaWVsZEFyclZhbCwgbG9jYWxGaWVsZEh5ZHJhdGVkVmFsdWVbbG9jYWxGaWVsZEFyckluZGV4XSkpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gbG9jYWxGaWVsZFBhdGguYXBwbHlHZXR0ZXJzKGxvY2FsRmllbGRWYWx1ZSwgaHlkcmF0ZWREb2MpO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gY29udmVydFRvX2lkKG1wYXRoLmdldChsb2NhbEZpZWxkLCBkb2MsIGxvb2t1cExvY2FsRmllbGRzKSwgc2NoZW1hKTtcbiAgfVxufVxuXG4vKipcbiAqIFJldHJpZXZlIHRoZSBfaWQgb2YgYHZhbGAgaWYgYSBEb2N1bWVudCBvciBBcnJheSBvZiBEb2N1bWVudHMuXG4gKlxuICogQHBhcmFtIHtBcnJheXxEb2N1bWVudHxBbnl9IHZhbFxuICogQHBhcmFtIHtTY2hlbWF9IHNjaGVtYVxuICogQHJldHVybiB7QXJyYXl8RG9jdW1lbnR8QW55fVxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZnVuY3Rpb24gY29udmVydFRvX2lkKHZhbCwgc2NoZW1hKSB7XG4gIGlmICh2YWwgIT0gbnVsbCAmJiB2YWwuJF9fICE9IG51bGwpIHtcbiAgICByZXR1cm4gdmFsLl9pZDtcbiAgfVxuICBpZiAodmFsICE9IG51bGwgJiYgdmFsLl9pZCAhPSBudWxsICYmIChzY2hlbWEgPT0gbnVsbCB8fCAhc2NoZW1hLiRpc1NjaGVtYU1hcCkpIHtcbiAgICByZXR1cm4gdmFsLl9pZDtcbiAgfVxuXG4gIGlmIChBcnJheS5pc0FycmF5KHZhbCkpIHtcbiAgICBjb25zdCByYXdWYWwgPSB2YWwuX19hcnJheSAhPSBudWxsID8gdmFsLl9fYXJyYXkgOiB2YWw7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCByYXdWYWwubGVuZ3RoOyArK2kpIHtcbiAgICAgIGlmIChyYXdWYWxbaV0gIT0gbnVsbCAmJiByYXdWYWxbaV0uJF9fICE9IG51bGwpIHtcbiAgICAgICAgcmF3VmFsW2ldID0gcmF3VmFsW2ldLl9pZDtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKHV0aWxzLmlzTW9uZ29vc2VBcnJheSh2YWwpICYmIHZhbC4kc2NoZW1hKCkpIHtcbiAgICAgIHJldHVybiB2YWwuJHNjaGVtYSgpLl9jYXN0Rm9yUG9wdWxhdGUodmFsLCB2YWwuJHBhcmVudCgpKTtcbiAgICB9XG5cbiAgICByZXR1cm4gW10uY29uY2F0KHZhbCk7XG4gIH1cblxuICAvLyBgcG9wdWxhdGUoJ21hcCcpYCBtYXkgYmUgYW4gb2JqZWN0IGlmIHBvcHVsYXRpbmcgb24gYSBkb2MgdGhhdCBoYXNuJ3RcbiAgLy8gYmVlbiBoeWRyYXRlZCB5ZXRcbiAgaWYgKGdldENvbnN0cnVjdG9yTmFtZSh2YWwpID09PSAnT2JqZWN0JyAmJlxuICAgICAgLy8gVGhlIGludGVudCBoZXJlIGlzIHdlIHNob3VsZCBvbmx5IGZsYXR0ZW4gdGhlIG9iamVjdCBpZiB3ZSBleHBlY3RcbiAgICAgIC8vIHRvIGdldCBhIE1hcCBpbiB0aGUgZW5kLiBBdm9pZCBkb2luZyB0aGlzIGZvciBtaXhlZCB0eXBlcy5cbiAgICAgIChzY2hlbWEgPT0gbnVsbCB8fCBzY2hlbWFbc2NoZW1hTWl4ZWRTeW1ib2xdID09IG51bGwpKSB7XG4gICAgY29uc3QgcmV0ID0gW107XG4gICAgZm9yIChjb25zdCBrZXkgb2YgT2JqZWN0LmtleXModmFsKSkge1xuICAgICAgcmV0LnB1c2godmFsW2tleV0pO1xuICAgIH1cbiAgICByZXR1cm4gcmV0O1xuICB9XG4gIC8vIElmIGRvYyBoYXMgYWxyZWFkeSBiZWVuIGh5ZHJhdGVkLCBlLmcuIGBkb2MucG9wdWxhdGUoJ21hcCcpYFxuICAvLyB0aGVuIGB2YWxgIHdpbGwgYWxyZWFkeSBiZSBhIG1hcFxuICBpZiAodmFsIGluc3RhbmNlb2YgTWFwKSB7XG4gICAgcmV0dXJuIEFycmF5LmZyb20odmFsLnZhbHVlcygpKTtcbiAgfVxuXG4gIHJldHVybiB2YWw7XG59XG5cbi8qIVxuICogaWdub3JlXG4gKi9cblxuZnVuY3Rpb24gX2ZpbmRSZWZQYXRoRm9yRGlzY3JpbWluYXRvcnMoZG9jLCBtb2RlbFNjaGVtYSwgZGF0YSwgb3B0aW9ucywgbm9ybWFsaXplZFJlZlBhdGgsIHJldCkge1xuICAvLyBSZTogZ2gtODQ1Mi4gRW1iZWRkZWQgZGlzY3JpbWluYXRvcnMgbWF5IG5vdCBoYXZlIGByZWZQYXRoYCwgc28gY2xlYXJcbiAgLy8gb3V0IGVtYmVkZGVkIGRpc2NyaW1pbmF0b3IgZG9jcyB0aGF0IGRvbid0IGhhdmUgYSBgcmVmUGF0aGAgb24gdGhlXG4gIC8vIHBvcHVsYXRlZCBwYXRoLlxuICBpZiAoIWRhdGEuaXNSZWZQYXRoIHx8IG5vcm1hbGl6ZWRSZWZQYXRoID09IG51bGwpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICBjb25zdCBwaWVjZXMgPSBub3JtYWxpemVkUmVmUGF0aC5zcGxpdCgnLicpO1xuICBsZXQgY3VyID0gJyc7XG4gIGxldCBtb2RlbE5hbWVzID0gdm9pZCAwO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IHBpZWNlcy5sZW5ndGg7ICsraSkge1xuICAgIGNvbnN0IHBpZWNlID0gcGllY2VzW2ldO1xuICAgIGN1ciA9IGN1ciArIChjdXIubGVuZ3RoID09PSAwID8gJycgOiAnLicpICsgcGllY2U7XG4gICAgY29uc3Qgc2NoZW1hdHlwZSA9IG1vZGVsU2NoZW1hLnBhdGgoY3VyKTtcbiAgICBpZiAoc2NoZW1hdHlwZSAhPSBudWxsICYmXG4gICAgICAgIHNjaGVtYXR5cGUuJGlzTW9uZ29vc2VBcnJheSAmJlxuICAgICAgICBzY2hlbWF0eXBlLmNhc3Rlci5kaXNjcmltaW5hdG9ycyAhPSBudWxsICYmXG4gICAgICAgIE9iamVjdC5rZXlzKHNjaGVtYXR5cGUuY2FzdGVyLmRpc2NyaW1pbmF0b3JzKS5sZW5ndGggIT09IDApIHtcbiAgICAgIGNvbnN0IHN1YmRvY3MgPSB1dGlscy5nZXRWYWx1ZShjdXIsIGRvYyk7XG4gICAgICBjb25zdCByZW1uYW50ID0gb3B0aW9ucy5wYXRoLnN1YnN0cmluZyhjdXIubGVuZ3RoICsgMSk7XG4gICAgICBjb25zdCBkaXNjcmltaW5hdG9yS2V5ID0gc2NoZW1hdHlwZS5jYXN0ZXIuc2NoZW1hLm9wdGlvbnMuZGlzY3JpbWluYXRvcktleTtcbiAgICAgIG1vZGVsTmFtZXMgPSBbXTtcbiAgICAgIGZvciAoY29uc3Qgc3ViZG9jIG9mIHN1YmRvY3MpIHtcbiAgICAgICAgY29uc3QgZGlzY3JpbWluYXRvck5hbWUgPSB1dGlscy5nZXRWYWx1ZShkaXNjcmltaW5hdG9yS2V5LCBzdWJkb2MpO1xuICAgICAgICBjb25zdCBkaXNjcmltaW5hdG9yID0gc2NoZW1hdHlwZS5jYXN0ZXIuZGlzY3JpbWluYXRvcnNbZGlzY3JpbWluYXRvck5hbWVdO1xuICAgICAgICBjb25zdCBkaXNjcmltaW5hdG9yU2NoZW1hID0gZGlzY3JpbWluYXRvciAmJiBkaXNjcmltaW5hdG9yLnNjaGVtYTtcbiAgICAgICAgaWYgKGRpc2NyaW1pbmF0b3JTY2hlbWEgPT0gbnVsbCkge1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IF9wYXRoID0gZGlzY3JpbWluYXRvclNjaGVtYS5wYXRoKHJlbW5hbnQpO1xuICAgICAgICBpZiAoX3BhdGggPT0gbnVsbCB8fCBfcGF0aC5vcHRpb25zLnJlZlBhdGggPT0gbnVsbCkge1xuICAgICAgICAgIGNvbnN0IGRvY1ZhbHVlID0gdXRpbHMuZ2V0VmFsdWUoZGF0YS5sb2NhbEZpZWxkLnN1YnN0cmluZyhjdXIubGVuZ3RoICsgMSksIHN1YmRvYyk7XG4gICAgICAgICAgcmV0LmZvckVhY2goKHYsIGkpID0+IHtcbiAgICAgICAgICAgIGlmICh2ID09PSBkb2NWYWx1ZSkge1xuICAgICAgICAgICAgICByZXRbaV0gPSBTa2lwUG9wdWxhdGVWYWx1ZSh2KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBtb2RlbE5hbWUgPSB1dGlscy5nZXRWYWx1ZShwaWVjZXMuc2xpY2UoaSArIDEpLmpvaW4oJy4nKSwgc3ViZG9jKTtcbiAgICAgICAgbW9kZWxOYW1lcy5wdXNoKG1vZGVsTmFtZSk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG1vZGVsTmFtZXM7XG59XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/mongoose/lib/helpers/populate/getModelsMapForPopulate.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/mongoose/lib/helpers/populate/getSchemaTypes.js":
/*!**********************************************************************!*\
  !*** ./node_modules/mongoose/lib/helpers/populate/getSchemaTypes.js ***!
  \**********************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\n\n/*!\n * ignore\n */\n\nconst Mixed = __webpack_require__(/*! ../../schema/mixed */ \"(ssr)/./node_modules/mongoose/lib/schema/mixed.js\");\nconst get = __webpack_require__(/*! ../get */ \"(ssr)/./node_modules/mongoose/lib/helpers/get.js\");\nconst getDiscriminatorByValue = __webpack_require__(/*! ../discriminator/getDiscriminatorByValue */ \"(ssr)/./node_modules/mongoose/lib/helpers/discriminator/getDiscriminatorByValue.js\");\nconst leanPopulateMap = __webpack_require__(/*! ./leanPopulateMap */ \"(ssr)/./node_modules/mongoose/lib/helpers/populate/leanPopulateMap.js\");\nconst mpath = __webpack_require__(/*! mpath */ \"(ssr)/./node_modules/mpath/index.js\");\n\nconst populateModelSymbol = (__webpack_require__(/*! ../symbols */ \"(ssr)/./node_modules/mongoose/lib/helpers/symbols.js\").populateModelSymbol);\n\n/**\n * Given a model and its schema, find all possible schema types for `path`,\n * including searching through discriminators. If `doc` is specified, will\n * use the doc's values for discriminator keys when searching, otherwise\n * will search all discriminators.\n *\n * @param {Model} model\n * @param {Schema} schema\n * @param {Object} doc POJO\n * @param {string} path\n * @api private\n */\n\nmodule.exports = function getSchemaTypes(model, schema, doc, path) {\n  const pathschema = schema.path(path);\n  const topLevelDoc = doc;\n  if (pathschema) {\n    return pathschema;\n  }\n\n  const discriminatorKey = schema.discriminatorMapping &&\n    schema.discriminatorMapping.key;\n  if (discriminatorKey && model != null) {\n    if (doc != null && doc[discriminatorKey] != null) {\n      const discriminator = getDiscriminatorByValue(model.discriminators, doc[discriminatorKey]);\n      schema = discriminator ? discriminator.schema : schema;\n    } else if (model.discriminators != null) {\n      return Object.keys(model.discriminators).reduce((arr, name) => {\n        const disc = model.discriminators[name];\n        return arr.concat(getSchemaTypes(disc, disc.schema, null, path));\n      }, []);\n    }\n  }\n\n  function search(parts, schema, subdoc, nestedPath) {\n    let p = parts.length + 1;\n    let foundschema;\n    let trypath;\n\n    while (p--) {\n      trypath = parts.slice(0, p).join('.');\n      foundschema = schema.path(trypath);\n      if (foundschema == null) {\n        continue;\n      }\n\n      if (foundschema.caster) {\n        // array of Mixed?\n        if (foundschema.caster instanceof Mixed) {\n          return foundschema.caster;\n        }\n\n        let schemas = null;\n        if (foundschema.schema != null && foundschema.schema.discriminators != null) {\n          const discriminators = foundschema.schema.discriminators;\n          const discriminatorKeyPath = trypath + '.' +\n            foundschema.schema.options.discriminatorKey;\n          const keys = subdoc ? mpath.get(discriminatorKeyPath, subdoc) || [] : [];\n          schemas = Object.keys(discriminators).\n            reduce(function(cur, discriminator) {\n              const tiedValue = discriminators[discriminator].discriminatorMapping.value;\n              if (doc == null || keys.indexOf(discriminator) !== -1 || keys.indexOf(tiedValue) !== -1) {\n                cur.push(discriminators[discriminator]);\n              }\n              return cur;\n            }, []);\n        }\n\n        // Now that we found the array, we need to check if there\n        // are remaining document paths to look up for casting.\n        // Also we need to handle array.$.path since schema.path\n        // doesn't work for that.\n        // If there is no foundschema.schema we are dealing with\n        // a path like array.$\n        if (p !== parts.length && foundschema.schema) {\n          let ret;\n          if (parts[p] === '$') {\n            if (p + 1 === parts.length) {\n              // comments.$\n              return foundschema;\n            }\n            // comments.$.comments.$.title\n            ret = search(\n              parts.slice(p + 1),\n              schema,\n              subdoc ? mpath.get(trypath, subdoc) : null,\n              nestedPath.concat(parts.slice(0, p))\n            );\n            if (ret) {\n              ret.$parentSchemaDocArray = ret.$parentSchemaDocArray ||\n                (foundschema.schema.$isSingleNested ? null : foundschema);\n            }\n            return ret;\n          }\n\n          if (schemas != null && schemas.length > 0) {\n            ret = [];\n            for (const schema of schemas) {\n              const _ret = search(\n                parts.slice(p),\n                schema,\n                subdoc ? mpath.get(trypath, subdoc) : null,\n                nestedPath.concat(parts.slice(0, p))\n              );\n              if (_ret != null) {\n                _ret.$parentSchemaDocArray = _ret.$parentSchemaDocArray ||\n                  (foundschema.schema.$isSingleNested ? null : foundschema);\n                if (_ret.$parentSchemaDocArray) {\n                  ret.$parentSchemaDocArray = _ret.$parentSchemaDocArray;\n                }\n                ret.push(_ret);\n              }\n            }\n            return ret;\n          } else {\n            ret = search(\n              parts.slice(p),\n              foundschema.schema,\n              subdoc ? mpath.get(trypath, subdoc) : null,\n              nestedPath.concat(parts.slice(0, p))\n            );\n\n            if (ret) {\n              ret.$parentSchemaDocArray = ret.$parentSchemaDocArray ||\n                (foundschema.schema.$isSingleNested ? null : foundschema);\n            }\n            return ret;\n          }\n        } else if (p !== parts.length &&\n            foundschema.$isMongooseArray &&\n            foundschema.casterConstructor.$isMongooseArray) {\n          // Nested arrays. Drill down to the bottom of the nested array.\n          let type = foundschema;\n          while (type.$isMongooseArray && !type.$isMongooseDocumentArray) {\n            type = type.casterConstructor;\n          }\n\n          const ret = search(\n            parts.slice(p),\n            type.schema,\n            null,\n            nestedPath.concat(parts.slice(0, p))\n          );\n          if (ret != null) {\n            return ret;\n          }\n\n          if (type.schema.discriminators) {\n            const discriminatorPaths = [];\n            for (const discriminatorName of Object.keys(type.schema.discriminators)) {\n              const _schema = type.schema.discriminators[discriminatorName] || type.schema;\n              const ret = search(parts.slice(p), _schema, null, nestedPath.concat(parts.slice(0, p)));\n              if (ret != null) {\n                discriminatorPaths.push(ret);\n              }\n            }\n            if (discriminatorPaths.length > 0) {\n              return discriminatorPaths;\n            }\n          }\n        }\n      } else if (foundschema.$isSchemaMap && foundschema.$__schemaType instanceof Mixed) {\n        return foundschema.$__schemaType;\n      }\n\n      const fullPath = nestedPath.concat([trypath]).join('.');\n      if (topLevelDoc != null && topLevelDoc.$__ && topLevelDoc.$populated(fullPath) && p < parts.length) {\n        const model = doc.$__.populated[fullPath].options[populateModelSymbol];\n        if (model != null) {\n          const ret = search(\n            parts.slice(p),\n            model.schema,\n            subdoc ? mpath.get(trypath, subdoc) : null,\n            nestedPath.concat(parts.slice(0, p))\n          );\n\n          return ret;\n        }\n      }\n\n      const _val = get(topLevelDoc, trypath);\n      if (_val != null) {\n        const model = Array.isArray(_val) && _val.length > 0 ?\n          leanPopulateMap.get(_val[0]) :\n          leanPopulateMap.get(_val);\n        // Populated using lean, `leanPopulateMap` value is the foreign model\n        const schema = model != null ? model.schema : null;\n        if (schema != null) {\n          const ret = search(\n            parts.slice(p),\n            schema,\n            subdoc ? mpath.get(trypath, subdoc) : null,\n            nestedPath.concat(parts.slice(0, p))\n          );\n\n          if (ret != null) {\n            ret.$parentSchemaDocArray = ret.$parentSchemaDocArray ||\n              (schema.$isSingleNested ? null : schema);\n            return ret;\n          }\n        }\n      }\n      return foundschema;\n    }\n  }\n  // look for arrays\n  const parts = path.split('.');\n  for (let i = 0; i < parts.length; ++i) {\n    if (parts[i] === '$') {\n      // Re: gh-5628, because `schema.path()` doesn't take $ into account.\n      parts[i] = '0';\n    }\n  }\n  return search(parts, schema, doc, []);\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbW9uZ29vc2UvbGliL2hlbHBlcnMvcG9wdWxhdGUvZ2V0U2NoZW1hVHlwZXMuanMiLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWI7QUFDQTtBQUNBOztBQUVBLGNBQWMsbUJBQU8sQ0FBQyw2RUFBb0I7QUFDMUMsWUFBWSxtQkFBTyxDQUFDLGdFQUFRO0FBQzVCLGdDQUFnQyxtQkFBTyxDQUFDLG9JQUEwQztBQUNsRix3QkFBd0IsbUJBQU8sQ0FBQyxnR0FBbUI7QUFDbkQsY0FBYyxtQkFBTyxDQUFDLGtEQUFPOztBQUU3Qiw0QkFBNEIsbUhBQXlDOztBQUVyRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE9BQU87QUFDbEIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixrQkFBa0I7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9hcHAxLy4vbm9kZV9tb2R1bGVzL21vbmdvb3NlL2xpYi9oZWxwZXJzL3BvcHVsYXRlL2dldFNjaGVtYVR5cGVzLmpzP2E1ZDciXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG4vKiFcbiAqIGlnbm9yZVxuICovXG5cbmNvbnN0IE1peGVkID0gcmVxdWlyZSgnLi4vLi4vc2NoZW1hL21peGVkJyk7XG5jb25zdCBnZXQgPSByZXF1aXJlKCcuLi9nZXQnKTtcbmNvbnN0IGdldERpc2NyaW1pbmF0b3JCeVZhbHVlID0gcmVxdWlyZSgnLi4vZGlzY3JpbWluYXRvci9nZXREaXNjcmltaW5hdG9yQnlWYWx1ZScpO1xuY29uc3QgbGVhblBvcHVsYXRlTWFwID0gcmVxdWlyZSgnLi9sZWFuUG9wdWxhdGVNYXAnKTtcbmNvbnN0IG1wYXRoID0gcmVxdWlyZSgnbXBhdGgnKTtcblxuY29uc3QgcG9wdWxhdGVNb2RlbFN5bWJvbCA9IHJlcXVpcmUoJy4uL3N5bWJvbHMnKS5wb3B1bGF0ZU1vZGVsU3ltYm9sO1xuXG4vKipcbiAqIEdpdmVuIGEgbW9kZWwgYW5kIGl0cyBzY2hlbWEsIGZpbmQgYWxsIHBvc3NpYmxlIHNjaGVtYSB0eXBlcyBmb3IgYHBhdGhgLFxuICogaW5jbHVkaW5nIHNlYXJjaGluZyB0aHJvdWdoIGRpc2NyaW1pbmF0b3JzLiBJZiBgZG9jYCBpcyBzcGVjaWZpZWQsIHdpbGxcbiAqIHVzZSB0aGUgZG9jJ3MgdmFsdWVzIGZvciBkaXNjcmltaW5hdG9yIGtleXMgd2hlbiBzZWFyY2hpbmcsIG90aGVyd2lzZVxuICogd2lsbCBzZWFyY2ggYWxsIGRpc2NyaW1pbmF0b3JzLlxuICpcbiAqIEBwYXJhbSB7TW9kZWx9IG1vZGVsXG4gKiBAcGFyYW0ge1NjaGVtYX0gc2NoZW1hXG4gKiBAcGFyYW0ge09iamVjdH0gZG9jIFBPSk9cbiAqIEBwYXJhbSB7c3RyaW5nfSBwYXRoXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGdldFNjaGVtYVR5cGVzKG1vZGVsLCBzY2hlbWEsIGRvYywgcGF0aCkge1xuICBjb25zdCBwYXRoc2NoZW1hID0gc2NoZW1hLnBhdGgocGF0aCk7XG4gIGNvbnN0IHRvcExldmVsRG9jID0gZG9jO1xuICBpZiAocGF0aHNjaGVtYSkge1xuICAgIHJldHVybiBwYXRoc2NoZW1hO1xuICB9XG5cbiAgY29uc3QgZGlzY3JpbWluYXRvcktleSA9IHNjaGVtYS5kaXNjcmltaW5hdG9yTWFwcGluZyAmJlxuICAgIHNjaGVtYS5kaXNjcmltaW5hdG9yTWFwcGluZy5rZXk7XG4gIGlmIChkaXNjcmltaW5hdG9yS2V5ICYmIG1vZGVsICE9IG51bGwpIHtcbiAgICBpZiAoZG9jICE9IG51bGwgJiYgZG9jW2Rpc2NyaW1pbmF0b3JLZXldICE9IG51bGwpIHtcbiAgICAgIGNvbnN0IGRpc2NyaW1pbmF0b3IgPSBnZXREaXNjcmltaW5hdG9yQnlWYWx1ZShtb2RlbC5kaXNjcmltaW5hdG9ycywgZG9jW2Rpc2NyaW1pbmF0b3JLZXldKTtcbiAgICAgIHNjaGVtYSA9IGRpc2NyaW1pbmF0b3IgPyBkaXNjcmltaW5hdG9yLnNjaGVtYSA6IHNjaGVtYTtcbiAgICB9IGVsc2UgaWYgKG1vZGVsLmRpc2NyaW1pbmF0b3JzICE9IG51bGwpIHtcbiAgICAgIHJldHVybiBPYmplY3Qua2V5cyhtb2RlbC5kaXNjcmltaW5hdG9ycykucmVkdWNlKChhcnIsIG5hbWUpID0+IHtcbiAgICAgICAgY29uc3QgZGlzYyA9IG1vZGVsLmRpc2NyaW1pbmF0b3JzW25hbWVdO1xuICAgICAgICByZXR1cm4gYXJyLmNvbmNhdChnZXRTY2hlbWFUeXBlcyhkaXNjLCBkaXNjLnNjaGVtYSwgbnVsbCwgcGF0aCkpO1xuICAgICAgfSwgW10pO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHNlYXJjaChwYXJ0cywgc2NoZW1hLCBzdWJkb2MsIG5lc3RlZFBhdGgpIHtcbiAgICBsZXQgcCA9IHBhcnRzLmxlbmd0aCArIDE7XG4gICAgbGV0IGZvdW5kc2NoZW1hO1xuICAgIGxldCB0cnlwYXRoO1xuXG4gICAgd2hpbGUgKHAtLSkge1xuICAgICAgdHJ5cGF0aCA9IHBhcnRzLnNsaWNlKDAsIHApLmpvaW4oJy4nKTtcbiAgICAgIGZvdW5kc2NoZW1hID0gc2NoZW1hLnBhdGgodHJ5cGF0aCk7XG4gICAgICBpZiAoZm91bmRzY2hlbWEgPT0gbnVsbCkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgaWYgKGZvdW5kc2NoZW1hLmNhc3Rlcikge1xuICAgICAgICAvLyBhcnJheSBvZiBNaXhlZD9cbiAgICAgICAgaWYgKGZvdW5kc2NoZW1hLmNhc3RlciBpbnN0YW5jZW9mIE1peGVkKSB7XG4gICAgICAgICAgcmV0dXJuIGZvdW5kc2NoZW1hLmNhc3RlcjtcbiAgICAgICAgfVxuXG4gICAgICAgIGxldCBzY2hlbWFzID0gbnVsbDtcbiAgICAgICAgaWYgKGZvdW5kc2NoZW1hLnNjaGVtYSAhPSBudWxsICYmIGZvdW5kc2NoZW1hLnNjaGVtYS5kaXNjcmltaW5hdG9ycyAhPSBudWxsKSB7XG4gICAgICAgICAgY29uc3QgZGlzY3JpbWluYXRvcnMgPSBmb3VuZHNjaGVtYS5zY2hlbWEuZGlzY3JpbWluYXRvcnM7XG4gICAgICAgICAgY29uc3QgZGlzY3JpbWluYXRvcktleVBhdGggPSB0cnlwYXRoICsgJy4nICtcbiAgICAgICAgICAgIGZvdW5kc2NoZW1hLnNjaGVtYS5vcHRpb25zLmRpc2NyaW1pbmF0b3JLZXk7XG4gICAgICAgICAgY29uc3Qga2V5cyA9IHN1YmRvYyA/IG1wYXRoLmdldChkaXNjcmltaW5hdG9yS2V5UGF0aCwgc3ViZG9jKSB8fCBbXSA6IFtdO1xuICAgICAgICAgIHNjaGVtYXMgPSBPYmplY3Qua2V5cyhkaXNjcmltaW5hdG9ycykuXG4gICAgICAgICAgICByZWR1Y2UoZnVuY3Rpb24oY3VyLCBkaXNjcmltaW5hdG9yKSB7XG4gICAgICAgICAgICAgIGNvbnN0IHRpZWRWYWx1ZSA9IGRpc2NyaW1pbmF0b3JzW2Rpc2NyaW1pbmF0b3JdLmRpc2NyaW1pbmF0b3JNYXBwaW5nLnZhbHVlO1xuICAgICAgICAgICAgICBpZiAoZG9jID09IG51bGwgfHwga2V5cy5pbmRleE9mKGRpc2NyaW1pbmF0b3IpICE9PSAtMSB8fCBrZXlzLmluZGV4T2YodGllZFZhbHVlKSAhPT0gLTEpIHtcbiAgICAgICAgICAgICAgICBjdXIucHVzaChkaXNjcmltaW5hdG9yc1tkaXNjcmltaW5hdG9yXSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgcmV0dXJuIGN1cjtcbiAgICAgICAgICAgIH0sIFtdKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIE5vdyB0aGF0IHdlIGZvdW5kIHRoZSBhcnJheSwgd2UgbmVlZCB0byBjaGVjayBpZiB0aGVyZVxuICAgICAgICAvLyBhcmUgcmVtYWluaW5nIGRvY3VtZW50IHBhdGhzIHRvIGxvb2sgdXAgZm9yIGNhc3RpbmcuXG4gICAgICAgIC8vIEFsc28gd2UgbmVlZCB0byBoYW5kbGUgYXJyYXkuJC5wYXRoIHNpbmNlIHNjaGVtYS5wYXRoXG4gICAgICAgIC8vIGRvZXNuJ3Qgd29yayBmb3IgdGhhdC5cbiAgICAgICAgLy8gSWYgdGhlcmUgaXMgbm8gZm91bmRzY2hlbWEuc2NoZW1hIHdlIGFyZSBkZWFsaW5nIHdpdGhcbiAgICAgICAgLy8gYSBwYXRoIGxpa2UgYXJyYXkuJFxuICAgICAgICBpZiAocCAhPT0gcGFydHMubGVuZ3RoICYmIGZvdW5kc2NoZW1hLnNjaGVtYSkge1xuICAgICAgICAgIGxldCByZXQ7XG4gICAgICAgICAgaWYgKHBhcnRzW3BdID09PSAnJCcpIHtcbiAgICAgICAgICAgIGlmIChwICsgMSA9PT0gcGFydHMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgIC8vIGNvbW1lbnRzLiRcbiAgICAgICAgICAgICAgcmV0dXJuIGZvdW5kc2NoZW1hO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gY29tbWVudHMuJC5jb21tZW50cy4kLnRpdGxlXG4gICAgICAgICAgICByZXQgPSBzZWFyY2goXG4gICAgICAgICAgICAgIHBhcnRzLnNsaWNlKHAgKyAxKSxcbiAgICAgICAgICAgICAgc2NoZW1hLFxuICAgICAgICAgICAgICBzdWJkb2MgPyBtcGF0aC5nZXQodHJ5cGF0aCwgc3ViZG9jKSA6IG51bGwsXG4gICAgICAgICAgICAgIG5lc3RlZFBhdGguY29uY2F0KHBhcnRzLnNsaWNlKDAsIHApKVxuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIGlmIChyZXQpIHtcbiAgICAgICAgICAgICAgcmV0LiRwYXJlbnRTY2hlbWFEb2NBcnJheSA9IHJldC4kcGFyZW50U2NoZW1hRG9jQXJyYXkgfHxcbiAgICAgICAgICAgICAgICAoZm91bmRzY2hlbWEuc2NoZW1hLiRpc1NpbmdsZU5lc3RlZCA/IG51bGwgOiBmb3VuZHNjaGVtYSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcmV0O1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChzY2hlbWFzICE9IG51bGwgJiYgc2NoZW1hcy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICByZXQgPSBbXTtcbiAgICAgICAgICAgIGZvciAoY29uc3Qgc2NoZW1hIG9mIHNjaGVtYXMpIHtcbiAgICAgICAgICAgICAgY29uc3QgX3JldCA9IHNlYXJjaChcbiAgICAgICAgICAgICAgICBwYXJ0cy5zbGljZShwKSxcbiAgICAgICAgICAgICAgICBzY2hlbWEsXG4gICAgICAgICAgICAgICAgc3ViZG9jID8gbXBhdGguZ2V0KHRyeXBhdGgsIHN1YmRvYykgOiBudWxsLFxuICAgICAgICAgICAgICAgIG5lc3RlZFBhdGguY29uY2F0KHBhcnRzLnNsaWNlKDAsIHApKVxuICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICBpZiAoX3JldCAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgX3JldC4kcGFyZW50U2NoZW1hRG9jQXJyYXkgPSBfcmV0LiRwYXJlbnRTY2hlbWFEb2NBcnJheSB8fFxuICAgICAgICAgICAgICAgICAgKGZvdW5kc2NoZW1hLnNjaGVtYS4kaXNTaW5nbGVOZXN0ZWQgPyBudWxsIDogZm91bmRzY2hlbWEpO1xuICAgICAgICAgICAgICAgIGlmIChfcmV0LiRwYXJlbnRTY2hlbWFEb2NBcnJheSkge1xuICAgICAgICAgICAgICAgICAgcmV0LiRwYXJlbnRTY2hlbWFEb2NBcnJheSA9IF9yZXQuJHBhcmVudFNjaGVtYURvY0FycmF5O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXQucHVzaChfcmV0KTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHJldDtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0ID0gc2VhcmNoKFxuICAgICAgICAgICAgICBwYXJ0cy5zbGljZShwKSxcbiAgICAgICAgICAgICAgZm91bmRzY2hlbWEuc2NoZW1hLFxuICAgICAgICAgICAgICBzdWJkb2MgPyBtcGF0aC5nZXQodHJ5cGF0aCwgc3ViZG9jKSA6IG51bGwsXG4gICAgICAgICAgICAgIG5lc3RlZFBhdGguY29uY2F0KHBhcnRzLnNsaWNlKDAsIHApKVxuICAgICAgICAgICAgKTtcblxuICAgICAgICAgICAgaWYgKHJldCkge1xuICAgICAgICAgICAgICByZXQuJHBhcmVudFNjaGVtYURvY0FycmF5ID0gcmV0LiRwYXJlbnRTY2hlbWFEb2NBcnJheSB8fFxuICAgICAgICAgICAgICAgIChmb3VuZHNjaGVtYS5zY2hlbWEuJGlzU2luZ2xlTmVzdGVkID8gbnVsbCA6IGZvdW5kc2NoZW1hKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiByZXQ7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKHAgIT09IHBhcnRzLmxlbmd0aCAmJlxuICAgICAgICAgICAgZm91bmRzY2hlbWEuJGlzTW9uZ29vc2VBcnJheSAmJlxuICAgICAgICAgICAgZm91bmRzY2hlbWEuY2FzdGVyQ29uc3RydWN0b3IuJGlzTW9uZ29vc2VBcnJheSkge1xuICAgICAgICAgIC8vIE5lc3RlZCBhcnJheXMuIERyaWxsIGRvd24gdG8gdGhlIGJvdHRvbSBvZiB0aGUgbmVzdGVkIGFycmF5LlxuICAgICAgICAgIGxldCB0eXBlID0gZm91bmRzY2hlbWE7XG4gICAgICAgICAgd2hpbGUgKHR5cGUuJGlzTW9uZ29vc2VBcnJheSAmJiAhdHlwZS4kaXNNb25nb29zZURvY3VtZW50QXJyYXkpIHtcbiAgICAgICAgICAgIHR5cGUgPSB0eXBlLmNhc3RlckNvbnN0cnVjdG9yO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGNvbnN0IHJldCA9IHNlYXJjaChcbiAgICAgICAgICAgIHBhcnRzLnNsaWNlKHApLFxuICAgICAgICAgICAgdHlwZS5zY2hlbWEsXG4gICAgICAgICAgICBudWxsLFxuICAgICAgICAgICAgbmVzdGVkUGF0aC5jb25jYXQocGFydHMuc2xpY2UoMCwgcCkpXG4gICAgICAgICAgKTtcbiAgICAgICAgICBpZiAocmV0ICE9IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiByZXQ7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKHR5cGUuc2NoZW1hLmRpc2NyaW1pbmF0b3JzKSB7XG4gICAgICAgICAgICBjb25zdCBkaXNjcmltaW5hdG9yUGF0aHMgPSBbXTtcbiAgICAgICAgICAgIGZvciAoY29uc3QgZGlzY3JpbWluYXRvck5hbWUgb2YgT2JqZWN0LmtleXModHlwZS5zY2hlbWEuZGlzY3JpbWluYXRvcnMpKSB7XG4gICAgICAgICAgICAgIGNvbnN0IF9zY2hlbWEgPSB0eXBlLnNjaGVtYS5kaXNjcmltaW5hdG9yc1tkaXNjcmltaW5hdG9yTmFtZV0gfHwgdHlwZS5zY2hlbWE7XG4gICAgICAgICAgICAgIGNvbnN0IHJldCA9IHNlYXJjaChwYXJ0cy5zbGljZShwKSwgX3NjaGVtYSwgbnVsbCwgbmVzdGVkUGF0aC5jb25jYXQocGFydHMuc2xpY2UoMCwgcCkpKTtcbiAgICAgICAgICAgICAgaWYgKHJldCAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgZGlzY3JpbWluYXRvclBhdGhzLnB1c2gocmV0KTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGRpc2NyaW1pbmF0b3JQYXRocy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgIHJldHVybiBkaXNjcmltaW5hdG9yUGF0aHM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKGZvdW5kc2NoZW1hLiRpc1NjaGVtYU1hcCAmJiBmb3VuZHNjaGVtYS4kX19zY2hlbWFUeXBlIGluc3RhbmNlb2YgTWl4ZWQpIHtcbiAgICAgICAgcmV0dXJuIGZvdW5kc2NoZW1hLiRfX3NjaGVtYVR5cGU7XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IGZ1bGxQYXRoID0gbmVzdGVkUGF0aC5jb25jYXQoW3RyeXBhdGhdKS5qb2luKCcuJyk7XG4gICAgICBpZiAodG9wTGV2ZWxEb2MgIT0gbnVsbCAmJiB0b3BMZXZlbERvYy4kX18gJiYgdG9wTGV2ZWxEb2MuJHBvcHVsYXRlZChmdWxsUGF0aCkgJiYgcCA8IHBhcnRzLmxlbmd0aCkge1xuICAgICAgICBjb25zdCBtb2RlbCA9IGRvYy4kX18ucG9wdWxhdGVkW2Z1bGxQYXRoXS5vcHRpb25zW3BvcHVsYXRlTW9kZWxTeW1ib2xdO1xuICAgICAgICBpZiAobW9kZWwgIT0gbnVsbCkge1xuICAgICAgICAgIGNvbnN0IHJldCA9IHNlYXJjaChcbiAgICAgICAgICAgIHBhcnRzLnNsaWNlKHApLFxuICAgICAgICAgICAgbW9kZWwuc2NoZW1hLFxuICAgICAgICAgICAgc3ViZG9jID8gbXBhdGguZ2V0KHRyeXBhdGgsIHN1YmRvYykgOiBudWxsLFxuICAgICAgICAgICAgbmVzdGVkUGF0aC5jb25jYXQocGFydHMuc2xpY2UoMCwgcCkpXG4gICAgICAgICAgKTtcblxuICAgICAgICAgIHJldHVybiByZXQ7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgY29uc3QgX3ZhbCA9IGdldCh0b3BMZXZlbERvYywgdHJ5cGF0aCk7XG4gICAgICBpZiAoX3ZhbCAhPSBudWxsKSB7XG4gICAgICAgIGNvbnN0IG1vZGVsID0gQXJyYXkuaXNBcnJheShfdmFsKSAmJiBfdmFsLmxlbmd0aCA+IDAgP1xuICAgICAgICAgIGxlYW5Qb3B1bGF0ZU1hcC5nZXQoX3ZhbFswXSkgOlxuICAgICAgICAgIGxlYW5Qb3B1bGF0ZU1hcC5nZXQoX3ZhbCk7XG4gICAgICAgIC8vIFBvcHVsYXRlZCB1c2luZyBsZWFuLCBgbGVhblBvcHVsYXRlTWFwYCB2YWx1ZSBpcyB0aGUgZm9yZWlnbiBtb2RlbFxuICAgICAgICBjb25zdCBzY2hlbWEgPSBtb2RlbCAhPSBudWxsID8gbW9kZWwuc2NoZW1hIDogbnVsbDtcbiAgICAgICAgaWYgKHNjaGVtYSAhPSBudWxsKSB7XG4gICAgICAgICAgY29uc3QgcmV0ID0gc2VhcmNoKFxuICAgICAgICAgICAgcGFydHMuc2xpY2UocCksXG4gICAgICAgICAgICBzY2hlbWEsXG4gICAgICAgICAgICBzdWJkb2MgPyBtcGF0aC5nZXQodHJ5cGF0aCwgc3ViZG9jKSA6IG51bGwsXG4gICAgICAgICAgICBuZXN0ZWRQYXRoLmNvbmNhdChwYXJ0cy5zbGljZSgwLCBwKSlcbiAgICAgICAgICApO1xuXG4gICAgICAgICAgaWYgKHJldCAhPSBudWxsKSB7XG4gICAgICAgICAgICByZXQuJHBhcmVudFNjaGVtYURvY0FycmF5ID0gcmV0LiRwYXJlbnRTY2hlbWFEb2NBcnJheSB8fFxuICAgICAgICAgICAgICAoc2NoZW1hLiRpc1NpbmdsZU5lc3RlZCA/IG51bGwgOiBzY2hlbWEpO1xuICAgICAgICAgICAgcmV0dXJuIHJldDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBmb3VuZHNjaGVtYTtcbiAgICB9XG4gIH1cbiAgLy8gbG9vayBmb3IgYXJyYXlzXG4gIGNvbnN0IHBhcnRzID0gcGF0aC5zcGxpdCgnLicpO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IHBhcnRzLmxlbmd0aDsgKytpKSB7XG4gICAgaWYgKHBhcnRzW2ldID09PSAnJCcpIHtcbiAgICAgIC8vIFJlOiBnaC01NjI4LCBiZWNhdXNlIGBzY2hlbWEucGF0aCgpYCBkb2Vzbid0IHRha2UgJCBpbnRvIGFjY291bnQuXG4gICAgICBwYXJ0c1tpXSA9ICcwJztcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHNlYXJjaChwYXJ0cywgc2NoZW1hLCBkb2MsIFtdKTtcbn07XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/mongoose/lib/helpers/populate/getSchemaTypes.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/mongoose/lib/helpers/populate/getVirtual.js":
/*!******************************************************************!*\
  !*** ./node_modules/mongoose/lib/helpers/populate/getVirtual.js ***!
  \******************************************************************/
/***/ ((module) => {

eval("\n\nmodule.exports = getVirtual;\n\n/*!\n * ignore\n */\n\nfunction getVirtual(schema, name) {\n  if (schema.virtuals[name]) {\n    return { virtual: schema.virtuals[name], path: void 0 };\n  }\n\n  const parts = name.split('.');\n  let cur = '';\n  let nestedSchemaPath = '';\n  for (let i = 0; i < parts.length; ++i) {\n    cur += (cur.length > 0 ? '.' : '') + parts[i];\n    if (schema.virtuals[cur]) {\n      if (i === parts.length - 1) {\n        return { virtual: schema.virtuals[cur], path: nestedSchemaPath };\n      }\n      continue;\n    }\n\n    if (schema.nested[cur]) {\n      continue;\n    }\n\n    if (schema.paths[cur] && schema.paths[cur].schema) {\n      schema = schema.paths[cur].schema;\n      const rest = parts.slice(i + 1).join('.');\n\n      if (schema.virtuals[rest]) {\n        if (i === parts.length - 2) {\n          return {\n            virtual: schema.virtuals[rest],\n            nestedSchemaPath: [nestedSchemaPath, cur].filter(v => !!v).join('.')\n          };\n        }\n        continue;\n      }\n\n      if (i + 1 < parts.length && schema.discriminators) {\n        for (const key of Object.keys(schema.discriminators)) {\n          const res = getVirtual(schema.discriminators[key], rest);\n          if (res != null) {\n            const _path = [nestedSchemaPath, cur, res.nestedSchemaPath].\n              filter(v => !!v).join('.');\n            return {\n              virtual: res.virtual,\n              nestedSchemaPath: _path\n            };\n          }\n        }\n      }\n\n      nestedSchemaPath += (nestedSchemaPath.length > 0 ? '.' : '') + cur;\n      cur = '';\n      continue;\n    }\n\n    if (schema.discriminators) {\n      for (const discriminatorKey of Object.keys(schema.discriminators)) {\n        const virtualFromDiscriminator = getVirtual(schema.discriminators[discriminatorKey], name);\n        if (virtualFromDiscriminator) return virtualFromDiscriminator;\n      }\n    }\n\n    return null;\n  }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbW9uZ29vc2UvbGliL2hlbHBlcnMvcG9wdWxhdGUvZ2V0VmlydHVhbC5qcyIsIm1hcHBpbmdzIjoiQUFBYTs7QUFFYjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGFBQWE7QUFDYjs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0Isa0JBQWtCO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL2FwcDEvLi9ub2RlX21vZHVsZXMvbW9uZ29vc2UvbGliL2hlbHBlcnMvcG9wdWxhdGUvZ2V0VmlydHVhbC5qcz82ZDZjIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxubW9kdWxlLmV4cG9ydHMgPSBnZXRWaXJ0dWFsO1xuXG4vKiFcbiAqIGlnbm9yZVxuICovXG5cbmZ1bmN0aW9uIGdldFZpcnR1YWwoc2NoZW1hLCBuYW1lKSB7XG4gIGlmIChzY2hlbWEudmlydHVhbHNbbmFtZV0pIHtcbiAgICByZXR1cm4geyB2aXJ0dWFsOiBzY2hlbWEudmlydHVhbHNbbmFtZV0sIHBhdGg6IHZvaWQgMCB9O1xuICB9XG5cbiAgY29uc3QgcGFydHMgPSBuYW1lLnNwbGl0KCcuJyk7XG4gIGxldCBjdXIgPSAnJztcbiAgbGV0IG5lc3RlZFNjaGVtYVBhdGggPSAnJztcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBwYXJ0cy5sZW5ndGg7ICsraSkge1xuICAgIGN1ciArPSAoY3VyLmxlbmd0aCA+IDAgPyAnLicgOiAnJykgKyBwYXJ0c1tpXTtcbiAgICBpZiAoc2NoZW1hLnZpcnR1YWxzW2N1cl0pIHtcbiAgICAgIGlmIChpID09PSBwYXJ0cy5sZW5ndGggLSAxKSB7XG4gICAgICAgIHJldHVybiB7IHZpcnR1YWw6IHNjaGVtYS52aXJ0dWFsc1tjdXJdLCBwYXRoOiBuZXN0ZWRTY2hlbWFQYXRoIH07XG4gICAgICB9XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICBpZiAoc2NoZW1hLm5lc3RlZFtjdXJdKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICBpZiAoc2NoZW1hLnBhdGhzW2N1cl0gJiYgc2NoZW1hLnBhdGhzW2N1cl0uc2NoZW1hKSB7XG4gICAgICBzY2hlbWEgPSBzY2hlbWEucGF0aHNbY3VyXS5zY2hlbWE7XG4gICAgICBjb25zdCByZXN0ID0gcGFydHMuc2xpY2UoaSArIDEpLmpvaW4oJy4nKTtcblxuICAgICAgaWYgKHNjaGVtYS52aXJ0dWFsc1tyZXN0XSkge1xuICAgICAgICBpZiAoaSA9PT0gcGFydHMubGVuZ3RoIC0gMikge1xuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB2aXJ0dWFsOiBzY2hlbWEudmlydHVhbHNbcmVzdF0sXG4gICAgICAgICAgICBuZXN0ZWRTY2hlbWFQYXRoOiBbbmVzdGVkU2NoZW1hUGF0aCwgY3VyXS5maWx0ZXIodiA9PiAhIXYpLmpvaW4oJy4nKVxuICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIGlmIChpICsgMSA8IHBhcnRzLmxlbmd0aCAmJiBzY2hlbWEuZGlzY3JpbWluYXRvcnMpIHtcbiAgICAgICAgZm9yIChjb25zdCBrZXkgb2YgT2JqZWN0LmtleXMoc2NoZW1hLmRpc2NyaW1pbmF0b3JzKSkge1xuICAgICAgICAgIGNvbnN0IHJlcyA9IGdldFZpcnR1YWwoc2NoZW1hLmRpc2NyaW1pbmF0b3JzW2tleV0sIHJlc3QpO1xuICAgICAgICAgIGlmIChyZXMgIT0gbnVsbCkge1xuICAgICAgICAgICAgY29uc3QgX3BhdGggPSBbbmVzdGVkU2NoZW1hUGF0aCwgY3VyLCByZXMubmVzdGVkU2NoZW1hUGF0aF0uXG4gICAgICAgICAgICAgIGZpbHRlcih2ID0+ICEhdikuam9pbignLicpO1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgdmlydHVhbDogcmVzLnZpcnR1YWwsXG4gICAgICAgICAgICAgIG5lc3RlZFNjaGVtYVBhdGg6IF9wYXRoXG4gICAgICAgICAgICB9O1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBuZXN0ZWRTY2hlbWFQYXRoICs9IChuZXN0ZWRTY2hlbWFQYXRoLmxlbmd0aCA+IDAgPyAnLicgOiAnJykgKyBjdXI7XG4gICAgICBjdXIgPSAnJztcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIGlmIChzY2hlbWEuZGlzY3JpbWluYXRvcnMpIHtcbiAgICAgIGZvciAoY29uc3QgZGlzY3JpbWluYXRvcktleSBvZiBPYmplY3Qua2V5cyhzY2hlbWEuZGlzY3JpbWluYXRvcnMpKSB7XG4gICAgICAgIGNvbnN0IHZpcnR1YWxGcm9tRGlzY3JpbWluYXRvciA9IGdldFZpcnR1YWwoc2NoZW1hLmRpc2NyaW1pbmF0b3JzW2Rpc2NyaW1pbmF0b3JLZXldLCBuYW1lKTtcbiAgICAgICAgaWYgKHZpcnR1YWxGcm9tRGlzY3JpbWluYXRvcikgcmV0dXJuIHZpcnR1YWxGcm9tRGlzY3JpbWluYXRvcjtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gbnVsbDtcbiAgfVxufVxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/mongoose/lib/helpers/populate/getVirtual.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/mongoose/lib/helpers/populate/leanPopulateMap.js":
/*!***********************************************************************!*\
  !*** ./node_modules/mongoose/lib/helpers/populate/leanPopulateMap.js ***!
  \***********************************************************************/
/***/ ((module) => {

eval("\n\n/*!\n * ignore\n */\n\nmodule.exports = new WeakMap();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbW9uZ29vc2UvbGliL2hlbHBlcnMvcG9wdWxhdGUvbGVhblBvcHVsYXRlTWFwLmpzIiwibWFwcGluZ3MiOiJBQUFhOztBQUViO0FBQ0E7QUFDQTs7QUFFQSIsInNvdXJjZXMiOlsid2VicGFjazovL2FwcDEvLi9ub2RlX21vZHVsZXMvbW9uZ29vc2UvbGliL2hlbHBlcnMvcG9wdWxhdGUvbGVhblBvcHVsYXRlTWFwLmpzP2Q1ZGIiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG4vKiFcbiAqIGlnbm9yZVxuICovXG5cbm1vZHVsZS5leHBvcnRzID0gbmV3IFdlYWtNYXAoKTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/mongoose/lib/helpers/populate/leanPopulateMap.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/mongoose/lib/helpers/populate/lookupLocalFields.js":
/*!*************************************************************************!*\
  !*** ./node_modules/mongoose/lib/helpers/populate/lookupLocalFields.js ***!
  \*************************************************************************/
/***/ ((module) => {

eval("\n\nmodule.exports = function lookupLocalFields(cur, path, val) {\n  if (cur == null) {\n    return cur;\n  }\n\n  if (cur._doc != null) {\n    cur = cur._doc;\n  }\n\n  if (arguments.length >= 3) {\n    if (typeof cur !== 'object') {\n      return void 0;\n    }\n    if (val === void 0) {\n      return void 0;\n    }\n    if (cur instanceof Map) {\n      cur.set(path, val);\n    } else {\n      cur[path] = val;\n    }\n    return val;\n  }\n\n\n  // Support populating paths under maps using `map.$*.subpath`\n  if (path === '$*') {\n    return cur instanceof Map ?\n      Array.from(cur.values()) :\n      Object.keys(cur).map(key => cur[key]);\n  }\n\n  if (cur instanceof Map) {\n    return cur.get(path);\n  }\n\n  return cur[path];\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbW9uZ29vc2UvbGliL2hlbHBlcnMvcG9wdWxhdGUvbG9va3VwTG9jYWxGaWVsZHMuanMiLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vYXBwMS8uL25vZGVfbW9kdWxlcy9tb25nb29zZS9saWIvaGVscGVycy9wb3B1bGF0ZS9sb29rdXBMb2NhbEZpZWxkcy5qcz9mOGMxIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBsb29rdXBMb2NhbEZpZWxkcyhjdXIsIHBhdGgsIHZhbCkge1xuICBpZiAoY3VyID09IG51bGwpIHtcbiAgICByZXR1cm4gY3VyO1xuICB9XG5cbiAgaWYgKGN1ci5fZG9jICE9IG51bGwpIHtcbiAgICBjdXIgPSBjdXIuX2RvYztcbiAgfVxuXG4gIGlmIChhcmd1bWVudHMubGVuZ3RoID49IDMpIHtcbiAgICBpZiAodHlwZW9mIGN1ciAhPT0gJ29iamVjdCcpIHtcbiAgICAgIHJldHVybiB2b2lkIDA7XG4gICAgfVxuICAgIGlmICh2YWwgPT09IHZvaWQgMCkge1xuICAgICAgcmV0dXJuIHZvaWQgMDtcbiAgICB9XG4gICAgaWYgKGN1ciBpbnN0YW5jZW9mIE1hcCkge1xuICAgICAgY3VyLnNldChwYXRoLCB2YWwpO1xuICAgIH0gZWxzZSB7XG4gICAgICBjdXJbcGF0aF0gPSB2YWw7XG4gICAgfVxuICAgIHJldHVybiB2YWw7XG4gIH1cblxuXG4gIC8vIFN1cHBvcnQgcG9wdWxhdGluZyBwYXRocyB1bmRlciBtYXBzIHVzaW5nIGBtYXAuJCouc3VicGF0aGBcbiAgaWYgKHBhdGggPT09ICckKicpIHtcbiAgICByZXR1cm4gY3VyIGluc3RhbmNlb2YgTWFwID9cbiAgICAgIEFycmF5LmZyb20oY3VyLnZhbHVlcygpKSA6XG4gICAgICBPYmplY3Qua2V5cyhjdXIpLm1hcChrZXkgPT4gY3VyW2tleV0pO1xuICB9XG5cbiAgaWYgKGN1ciBpbnN0YW5jZW9mIE1hcCkge1xuICAgIHJldHVybiBjdXIuZ2V0KHBhdGgpO1xuICB9XG5cbiAgcmV0dXJuIGN1cltwYXRoXTtcbn07XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/mongoose/lib/helpers/populate/lookupLocalFields.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/mongoose/lib/helpers/populate/markArraySubdocsPopulated.js":
/*!*********************************************************************************!*\
  !*** ./node_modules/mongoose/lib/helpers/populate/markArraySubdocsPopulated.js ***!
  \*********************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\n\nconst utils = __webpack_require__(/*! ../../utils */ \"(ssr)/./node_modules/mongoose/lib/utils.js\");\n\n/**\n * If populating a path within a document array, make sure each\n * subdoc within the array knows its subpaths are populated.\n *\n * #### Example:\n *\n *     const doc = await Article.findOne().populate('comments.author');\n *     doc.comments[0].populated('author'); // Should be set\n *\n * @param {Document} doc\n * @param {Object} [populated]\n * @api private\n */\n\nmodule.exports = function markArraySubdocsPopulated(doc, populated) {\n  if (doc._id == null || populated == null || populated.length === 0) {\n    return;\n  }\n\n  const id = String(doc._id);\n  for (const item of populated) {\n    if (item.isVirtual) {\n      continue;\n    }\n    const path = item.path;\n    const pieces = path.split('.');\n    for (let i = 0; i < pieces.length - 1; ++i) {\n      const subpath = pieces.slice(0, i + 1).join('.');\n      const rest = pieces.slice(i + 1).join('.');\n      const val = doc.get(subpath);\n      if (val == null) {\n        continue;\n      }\n\n      if (utils.isMongooseDocumentArray(val)) {\n        for (let j = 0; j < val.length; ++j) {\n          if (val[j]) {\n            val[j].populated(rest, item._docs[id] == null ? void 0 : item._docs[id][j], item);\n          }\n        }\n        break;\n      }\n    }\n  }\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbW9uZ29vc2UvbGliL2hlbHBlcnMvcG9wdWxhdGUvbWFya0FycmF5U3ViZG9jc1BvcHVsYXRlZC5qcyIsIm1hcHBpbmdzIjoiQUFBYTs7QUFFYixjQUFjLG1CQUFPLENBQUMsK0RBQWE7O0FBRW5DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNENBQTRDO0FBQzVDO0FBQ0EsV0FBVyxVQUFVO0FBQ3JCLFdBQVcsUUFBUTtBQUNuQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLHVCQUF1QjtBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSx3QkFBd0IsZ0JBQWdCO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL2FwcDEvLi9ub2RlX21vZHVsZXMvbW9uZ29vc2UvbGliL2hlbHBlcnMvcG9wdWxhdGUvbWFya0FycmF5U3ViZG9jc1BvcHVsYXRlZC5qcz85NmVmIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxuY29uc3QgdXRpbHMgPSByZXF1aXJlKCcuLi8uLi91dGlscycpO1xuXG4vKipcbiAqIElmIHBvcHVsYXRpbmcgYSBwYXRoIHdpdGhpbiBhIGRvY3VtZW50IGFycmF5LCBtYWtlIHN1cmUgZWFjaFxuICogc3ViZG9jIHdpdGhpbiB0aGUgYXJyYXkga25vd3MgaXRzIHN1YnBhdGhzIGFyZSBwb3B1bGF0ZWQuXG4gKlxuICogIyMjIyBFeGFtcGxlOlxuICpcbiAqICAgICBjb25zdCBkb2MgPSBhd2FpdCBBcnRpY2xlLmZpbmRPbmUoKS5wb3B1bGF0ZSgnY29tbWVudHMuYXV0aG9yJyk7XG4gKiAgICAgZG9jLmNvbW1lbnRzWzBdLnBvcHVsYXRlZCgnYXV0aG9yJyk7IC8vIFNob3VsZCBiZSBzZXRcbiAqXG4gKiBAcGFyYW0ge0RvY3VtZW50fSBkb2NcbiAqIEBwYXJhbSB7T2JqZWN0fSBbcG9wdWxhdGVkXVxuICogQGFwaSBwcml2YXRlXG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBtYXJrQXJyYXlTdWJkb2NzUG9wdWxhdGVkKGRvYywgcG9wdWxhdGVkKSB7XG4gIGlmIChkb2MuX2lkID09IG51bGwgfHwgcG9wdWxhdGVkID09IG51bGwgfHwgcG9wdWxhdGVkLmxlbmd0aCA9PT0gMCkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIGNvbnN0IGlkID0gU3RyaW5nKGRvYy5faWQpO1xuICBmb3IgKGNvbnN0IGl0ZW0gb2YgcG9wdWxhdGVkKSB7XG4gICAgaWYgKGl0ZW0uaXNWaXJ0dWFsKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgY29uc3QgcGF0aCA9IGl0ZW0ucGF0aDtcbiAgICBjb25zdCBwaWVjZXMgPSBwYXRoLnNwbGl0KCcuJyk7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBwaWVjZXMubGVuZ3RoIC0gMTsgKytpKSB7XG4gICAgICBjb25zdCBzdWJwYXRoID0gcGllY2VzLnNsaWNlKDAsIGkgKyAxKS5qb2luKCcuJyk7XG4gICAgICBjb25zdCByZXN0ID0gcGllY2VzLnNsaWNlKGkgKyAxKS5qb2luKCcuJyk7XG4gICAgICBjb25zdCB2YWwgPSBkb2MuZ2V0KHN1YnBhdGgpO1xuICAgICAgaWYgKHZhbCA9PSBudWxsKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuXG4gICAgICBpZiAodXRpbHMuaXNNb25nb29zZURvY3VtZW50QXJyYXkodmFsKSkge1xuICAgICAgICBmb3IgKGxldCBqID0gMDsgaiA8IHZhbC5sZW5ndGg7ICsraikge1xuICAgICAgICAgIGlmICh2YWxbal0pIHtcbiAgICAgICAgICAgIHZhbFtqXS5wb3B1bGF0ZWQocmVzdCwgaXRlbS5fZG9jc1tpZF0gPT0gbnVsbCA/IHZvaWQgMCA6IGl0ZW0uX2RvY3NbaWRdW2pdLCBpdGVtKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICB9XG59O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/mongoose/lib/helpers/populate/markArraySubdocsPopulated.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/mongoose/lib/helpers/populate/modelNamesFromRefPath.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/mongoose/lib/helpers/populate/modelNamesFromRefPath.js ***!
  \*****************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\n\nconst MongooseError = __webpack_require__(/*! ../../error/mongooseError */ \"(ssr)/./node_modules/mongoose/lib/error/mongooseError.js\");\nconst isPathExcluded = __webpack_require__(/*! ../projection/isPathExcluded */ \"(ssr)/./node_modules/mongoose/lib/helpers/projection/isPathExcluded.js\");\nconst lookupLocalFields = __webpack_require__(/*! ./lookupLocalFields */ \"(ssr)/./node_modules/mongoose/lib/helpers/populate/lookupLocalFields.js\");\nconst mpath = __webpack_require__(/*! mpath */ \"(ssr)/./node_modules/mpath/index.js\");\nconst util = __webpack_require__(/*! util */ \"util\");\nconst utils = __webpack_require__(/*! ../../utils */ \"(ssr)/./node_modules/mongoose/lib/utils.js\");\n\nconst hasNumericPropRE = /(\\.\\d+$|\\.\\d+\\.)/g;\n\nmodule.exports = function modelNamesFromRefPath(refPath, doc, populatedPath, modelSchema, queryProjection) {\n  if (refPath == null) {\n    return [];\n  }\n\n  if (typeof refPath === 'string' && queryProjection != null && isPathExcluded(queryProjection, refPath)) {\n    throw new MongooseError('refPath `' + refPath + '` must not be excluded in projection, got ' +\n      util.inspect(queryProjection));\n  }\n\n  // If populated path has numerics, the end `refPath` should too. For example,\n  // if populating `a.0.b` instead of `a.b` and `b` has `refPath = a.c`, we\n  // should return `a.0.c` for the refPath.\n\n  if (hasNumericPropRE.test(populatedPath)) {\n    const chunks = populatedPath.split(hasNumericPropRE);\n\n    if (chunks[chunks.length - 1] === '') {\n      throw new Error('Can\\'t populate individual element in an array');\n    }\n\n    let _refPath = '';\n    let _remaining = refPath;\n    // 2nd, 4th, etc. will be numeric props. For example: `[ 'a', '.0.', 'b' ]`\n    for (let i = 0; i < chunks.length; i += 2) {\n      const chunk = chunks[i];\n      if (_remaining.startsWith(chunk + '.')) {\n        _refPath += _remaining.substring(0, chunk.length) + chunks[i + 1];\n        _remaining = _remaining.substring(chunk.length + 1);\n      } else if (i === chunks.length - 1) {\n        _refPath += _remaining;\n        _remaining = '';\n        break;\n      } else {\n        throw new Error('Could not normalize ref path, chunk ' + chunk + ' not in populated path');\n      }\n    }\n\n    const refValue = mpath.get(_refPath, doc, lookupLocalFields);\n    let modelNames = Array.isArray(refValue) ? refValue : [refValue];\n    modelNames = utils.array.flatten(modelNames);\n    return modelNames;\n  }\n\n  const refValue = mpath.get(refPath, doc, lookupLocalFields);\n\n  let modelNames;\n  if (modelSchema != null && modelSchema.virtuals.hasOwnProperty(refPath)) {\n    modelNames = [modelSchema.virtuals[refPath].applyGetters(void 0, doc)];\n  } else {\n    modelNames = Array.isArray(refValue) ? refValue : [refValue];\n  }\n\n  modelNames = utils.array.flatten(modelNames);\n\n  return modelNames;\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbW9uZ29vc2UvbGliL2hlbHBlcnMvcG9wdWxhdGUvbW9kZWxOYW1lc0Zyb21SZWZQYXRoLmpzIiwibWFwcGluZ3MiOiJBQUFhOztBQUViLHNCQUFzQixtQkFBTyxDQUFDLDJGQUEyQjtBQUN6RCx1QkFBdUIsbUJBQU8sQ0FBQyw0R0FBOEI7QUFDN0QsMEJBQTBCLG1CQUFPLENBQUMsb0dBQXFCO0FBQ3ZELGNBQWMsbUJBQU8sQ0FBQyxrREFBTztBQUM3QixhQUFhLG1CQUFPLENBQUMsa0JBQU07QUFDM0IsY0FBYyxtQkFBTyxDQUFDLCtEQUFhOztBQUVuQzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLG1CQUFtQjtBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL2FwcDEvLi9ub2RlX21vZHVsZXMvbW9uZ29vc2UvbGliL2hlbHBlcnMvcG9wdWxhdGUvbW9kZWxOYW1lc0Zyb21SZWZQYXRoLmpzPzFmMWIiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG5jb25zdCBNb25nb29zZUVycm9yID0gcmVxdWlyZSgnLi4vLi4vZXJyb3IvbW9uZ29vc2VFcnJvcicpO1xuY29uc3QgaXNQYXRoRXhjbHVkZWQgPSByZXF1aXJlKCcuLi9wcm9qZWN0aW9uL2lzUGF0aEV4Y2x1ZGVkJyk7XG5jb25zdCBsb29rdXBMb2NhbEZpZWxkcyA9IHJlcXVpcmUoJy4vbG9va3VwTG9jYWxGaWVsZHMnKTtcbmNvbnN0IG1wYXRoID0gcmVxdWlyZSgnbXBhdGgnKTtcbmNvbnN0IHV0aWwgPSByZXF1aXJlKCd1dGlsJyk7XG5jb25zdCB1dGlscyA9IHJlcXVpcmUoJy4uLy4uL3V0aWxzJyk7XG5cbmNvbnN0IGhhc051bWVyaWNQcm9wUkUgPSAvKFxcLlxcZCskfFxcLlxcZCtcXC4pL2c7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gbW9kZWxOYW1lc0Zyb21SZWZQYXRoKHJlZlBhdGgsIGRvYywgcG9wdWxhdGVkUGF0aCwgbW9kZWxTY2hlbWEsIHF1ZXJ5UHJvamVjdGlvbikge1xuICBpZiAocmVmUGF0aCA9PSBudWxsKSB7XG4gICAgcmV0dXJuIFtdO1xuICB9XG5cbiAgaWYgKHR5cGVvZiByZWZQYXRoID09PSAnc3RyaW5nJyAmJiBxdWVyeVByb2plY3Rpb24gIT0gbnVsbCAmJiBpc1BhdGhFeGNsdWRlZChxdWVyeVByb2plY3Rpb24sIHJlZlBhdGgpKSB7XG4gICAgdGhyb3cgbmV3IE1vbmdvb3NlRXJyb3IoJ3JlZlBhdGggYCcgKyByZWZQYXRoICsgJ2AgbXVzdCBub3QgYmUgZXhjbHVkZWQgaW4gcHJvamVjdGlvbiwgZ290ICcgK1xuICAgICAgdXRpbC5pbnNwZWN0KHF1ZXJ5UHJvamVjdGlvbikpO1xuICB9XG5cbiAgLy8gSWYgcG9wdWxhdGVkIHBhdGggaGFzIG51bWVyaWNzLCB0aGUgZW5kIGByZWZQYXRoYCBzaG91bGQgdG9vLiBGb3IgZXhhbXBsZSxcbiAgLy8gaWYgcG9wdWxhdGluZyBgYS4wLmJgIGluc3RlYWQgb2YgYGEuYmAgYW5kIGBiYCBoYXMgYHJlZlBhdGggPSBhLmNgLCB3ZVxuICAvLyBzaG91bGQgcmV0dXJuIGBhLjAuY2AgZm9yIHRoZSByZWZQYXRoLlxuXG4gIGlmIChoYXNOdW1lcmljUHJvcFJFLnRlc3QocG9wdWxhdGVkUGF0aCkpIHtcbiAgICBjb25zdCBjaHVua3MgPSBwb3B1bGF0ZWRQYXRoLnNwbGl0KGhhc051bWVyaWNQcm9wUkUpO1xuXG4gICAgaWYgKGNodW5rc1tjaHVua3MubGVuZ3RoIC0gMV0gPT09ICcnKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0NhblxcJ3QgcG9wdWxhdGUgaW5kaXZpZHVhbCBlbGVtZW50IGluIGFuIGFycmF5Jyk7XG4gICAgfVxuXG4gICAgbGV0IF9yZWZQYXRoID0gJyc7XG4gICAgbGV0IF9yZW1haW5pbmcgPSByZWZQYXRoO1xuICAgIC8vIDJuZCwgNHRoLCBldGMuIHdpbGwgYmUgbnVtZXJpYyBwcm9wcy4gRm9yIGV4YW1wbGU6IGBbICdhJywgJy4wLicsICdiJyBdYFxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY2h1bmtzLmxlbmd0aDsgaSArPSAyKSB7XG4gICAgICBjb25zdCBjaHVuayA9IGNodW5rc1tpXTtcbiAgICAgIGlmIChfcmVtYWluaW5nLnN0YXJ0c1dpdGgoY2h1bmsgKyAnLicpKSB7XG4gICAgICAgIF9yZWZQYXRoICs9IF9yZW1haW5pbmcuc3Vic3RyaW5nKDAsIGNodW5rLmxlbmd0aCkgKyBjaHVua3NbaSArIDFdO1xuICAgICAgICBfcmVtYWluaW5nID0gX3JlbWFpbmluZy5zdWJzdHJpbmcoY2h1bmsubGVuZ3RoICsgMSk7XG4gICAgICB9IGVsc2UgaWYgKGkgPT09IGNodW5rcy5sZW5ndGggLSAxKSB7XG4gICAgICAgIF9yZWZQYXRoICs9IF9yZW1haW5pbmc7XG4gICAgICAgIF9yZW1haW5pbmcgPSAnJztcbiAgICAgICAgYnJlYWs7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0NvdWxkIG5vdCBub3JtYWxpemUgcmVmIHBhdGgsIGNodW5rICcgKyBjaHVuayArICcgbm90IGluIHBvcHVsYXRlZCBwYXRoJyk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgY29uc3QgcmVmVmFsdWUgPSBtcGF0aC5nZXQoX3JlZlBhdGgsIGRvYywgbG9va3VwTG9jYWxGaWVsZHMpO1xuICAgIGxldCBtb2RlbE5hbWVzID0gQXJyYXkuaXNBcnJheShyZWZWYWx1ZSkgPyByZWZWYWx1ZSA6IFtyZWZWYWx1ZV07XG4gICAgbW9kZWxOYW1lcyA9IHV0aWxzLmFycmF5LmZsYXR0ZW4obW9kZWxOYW1lcyk7XG4gICAgcmV0dXJuIG1vZGVsTmFtZXM7XG4gIH1cblxuICBjb25zdCByZWZWYWx1ZSA9IG1wYXRoLmdldChyZWZQYXRoLCBkb2MsIGxvb2t1cExvY2FsRmllbGRzKTtcblxuICBsZXQgbW9kZWxOYW1lcztcbiAgaWYgKG1vZGVsU2NoZW1hICE9IG51bGwgJiYgbW9kZWxTY2hlbWEudmlydHVhbHMuaGFzT3duUHJvcGVydHkocmVmUGF0aCkpIHtcbiAgICBtb2RlbE5hbWVzID0gW21vZGVsU2NoZW1hLnZpcnR1YWxzW3JlZlBhdGhdLmFwcGx5R2V0dGVycyh2b2lkIDAsIGRvYyldO1xuICB9IGVsc2Uge1xuICAgIG1vZGVsTmFtZXMgPSBBcnJheS5pc0FycmF5KHJlZlZhbHVlKSA/IHJlZlZhbHVlIDogW3JlZlZhbHVlXTtcbiAgfVxuXG4gIG1vZGVsTmFtZXMgPSB1dGlscy5hcnJheS5mbGF0dGVuKG1vZGVsTmFtZXMpO1xuXG4gIHJldHVybiBtb2RlbE5hbWVzO1xufTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/mongoose/lib/helpers/populate/modelNamesFromRefPath.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/mongoose/lib/helpers/populate/removeDeselectedForeignField.js":
/*!************************************************************************************!*\
  !*** ./node_modules/mongoose/lib/helpers/populate/removeDeselectedForeignField.js ***!
  \************************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\n\nconst get = __webpack_require__(/*! ../get */ \"(ssr)/./node_modules/mongoose/lib/helpers/get.js\");\nconst mpath = __webpack_require__(/*! mpath */ \"(ssr)/./node_modules/mpath/index.js\");\nconst parseProjection = __webpack_require__(/*! ../projection/parseProjection */ \"(ssr)/./node_modules/mongoose/lib/helpers/projection/parseProjection.js\");\n\n/*!\n * ignore\n */\n\nmodule.exports = function removeDeselectedForeignField(foreignFields, options, docs) {\n  const projection = parseProjection(get(options, 'select', null), true) ||\n    parseProjection(get(options, 'options.select', null), true);\n\n  if (projection == null) {\n    return;\n  }\n  for (const foreignField of foreignFields) {\n    if (!projection.hasOwnProperty('-' + foreignField)) {\n      continue;\n    }\n\n    for (const val of docs) {\n      if (val.$__ != null) {\n        mpath.unset(foreignField, val._doc);\n      } else {\n        mpath.unset(foreignField, val);\n      }\n    }\n  }\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbW9uZ29vc2UvbGliL2hlbHBlcnMvcG9wdWxhdGUvcmVtb3ZlRGVzZWxlY3RlZEZvcmVpZ25GaWVsZC5qcyIsIm1hcHBpbmdzIjoiQUFBYTs7QUFFYixZQUFZLG1CQUFPLENBQUMsZ0VBQVE7QUFDNUIsY0FBYyxtQkFBTyxDQUFDLGtEQUFPO0FBQzdCLHdCQUF3QixtQkFBTyxDQUFDLDhHQUErQjs7QUFFL0Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL2FwcDEvLi9ub2RlX21vZHVsZXMvbW9uZ29vc2UvbGliL2hlbHBlcnMvcG9wdWxhdGUvcmVtb3ZlRGVzZWxlY3RlZEZvcmVpZ25GaWVsZC5qcz9mNWE3Il0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxuY29uc3QgZ2V0ID0gcmVxdWlyZSgnLi4vZ2V0Jyk7XG5jb25zdCBtcGF0aCA9IHJlcXVpcmUoJ21wYXRoJyk7XG5jb25zdCBwYXJzZVByb2plY3Rpb24gPSByZXF1aXJlKCcuLi9wcm9qZWN0aW9uL3BhcnNlUHJvamVjdGlvbicpO1xuXG4vKiFcbiAqIGlnbm9yZVxuICovXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gcmVtb3ZlRGVzZWxlY3RlZEZvcmVpZ25GaWVsZChmb3JlaWduRmllbGRzLCBvcHRpb25zLCBkb2NzKSB7XG4gIGNvbnN0IHByb2plY3Rpb24gPSBwYXJzZVByb2plY3Rpb24oZ2V0KG9wdGlvbnMsICdzZWxlY3QnLCBudWxsKSwgdHJ1ZSkgfHxcbiAgICBwYXJzZVByb2plY3Rpb24oZ2V0KG9wdGlvbnMsICdvcHRpb25zLnNlbGVjdCcsIG51bGwpLCB0cnVlKTtcblxuICBpZiAocHJvamVjdGlvbiA9PSBudWxsKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGZvciAoY29uc3QgZm9yZWlnbkZpZWxkIG9mIGZvcmVpZ25GaWVsZHMpIHtcbiAgICBpZiAoIXByb2plY3Rpb24uaGFzT3duUHJvcGVydHkoJy0nICsgZm9yZWlnbkZpZWxkKSkge1xuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgZm9yIChjb25zdCB2YWwgb2YgZG9jcykge1xuICAgICAgaWYgKHZhbC4kX18gIT0gbnVsbCkge1xuICAgICAgICBtcGF0aC51bnNldChmb3JlaWduRmllbGQsIHZhbC5fZG9jKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG1wYXRoLnVuc2V0KGZvcmVpZ25GaWVsZCwgdmFsKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn07XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/mongoose/lib/helpers/populate/removeDeselectedForeignField.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/mongoose/lib/helpers/populate/skipPopulateValue.js":
/*!*************************************************************************!*\
  !*** ./node_modules/mongoose/lib/helpers/populate/skipPopulateValue.js ***!
  \*************************************************************************/
/***/ ((module) => {

eval("\n\nmodule.exports = function SkipPopulateValue(val) {\n  if (!(this instanceof SkipPopulateValue)) {\n    return new SkipPopulateValue(val);\n  }\n\n  this.val = val;\n  return this;\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbW9uZ29vc2UvbGliL2hlbHBlcnMvcG9wdWxhdGUvc2tpcFBvcHVsYXRlVmFsdWUuanMiLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vYXBwMS8uL25vZGVfbW9kdWxlcy9tb25nb29zZS9saWIvaGVscGVycy9wb3B1bGF0ZS9za2lwUG9wdWxhdGVWYWx1ZS5qcz8wZDQwIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBTa2lwUG9wdWxhdGVWYWx1ZSh2YWwpIHtcbiAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIFNraXBQb3B1bGF0ZVZhbHVlKSkge1xuICAgIHJldHVybiBuZXcgU2tpcFBvcHVsYXRlVmFsdWUodmFsKTtcbiAgfVxuXG4gIHRoaXMudmFsID0gdmFsO1xuICByZXR1cm4gdGhpcztcbn07XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/mongoose/lib/helpers/populate/skipPopulateValue.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/mongoose/lib/helpers/populate/validateRef.js":
/*!*******************************************************************!*\
  !*** ./node_modules/mongoose/lib/helpers/populate/validateRef.js ***!
  \*******************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\n\nconst MongooseError = __webpack_require__(/*! ../../error/mongooseError */ \"(ssr)/./node_modules/mongoose/lib/error/mongooseError.js\");\nconst util = __webpack_require__(/*! util */ \"util\");\n\nmodule.exports = validateRef;\n\nfunction validateRef(ref, path) {\n  if (typeof ref === 'string') {\n    return;\n  }\n\n  if (typeof ref === 'function') {\n    return;\n  }\n\n  throw new MongooseError('Invalid ref at path \"' + path + '\". Got ' +\n    util.inspect(ref, { depth: 0 }));\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbW9uZ29vc2UvbGliL2hlbHBlcnMvcG9wdWxhdGUvdmFsaWRhdGVSZWYuanMiLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWIsc0JBQXNCLG1CQUFPLENBQUMsMkZBQTJCO0FBQ3pELGFBQWEsbUJBQU8sQ0FBQyxrQkFBTTs7QUFFM0I7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0Esd0JBQXdCLFVBQVU7QUFDbEMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9hcHAxLy4vbm9kZV9tb2R1bGVzL21vbmdvb3NlL2xpYi9oZWxwZXJzL3BvcHVsYXRlL3ZhbGlkYXRlUmVmLmpzPzE4MDYiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG5jb25zdCBNb25nb29zZUVycm9yID0gcmVxdWlyZSgnLi4vLi4vZXJyb3IvbW9uZ29vc2VFcnJvcicpO1xuY29uc3QgdXRpbCA9IHJlcXVpcmUoJ3V0aWwnKTtcblxubW9kdWxlLmV4cG9ydHMgPSB2YWxpZGF0ZVJlZjtcblxuZnVuY3Rpb24gdmFsaWRhdGVSZWYocmVmLCBwYXRoKSB7XG4gIGlmICh0eXBlb2YgcmVmID09PSAnc3RyaW5nJykge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIGlmICh0eXBlb2YgcmVmID09PSAnZnVuY3Rpb24nKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgdGhyb3cgbmV3IE1vbmdvb3NlRXJyb3IoJ0ludmFsaWQgcmVmIGF0IHBhdGggXCInICsgcGF0aCArICdcIi4gR290ICcgK1xuICAgIHV0aWwuaW5zcGVjdChyZWYsIHsgZGVwdGg6IDAgfSkpO1xufVxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/mongoose/lib/helpers/populate/validateRef.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/mongoose/lib/helpers/printJestWarning.js":
/*!***************************************************************!*\
  !*** ./node_modules/mongoose/lib/helpers/printJestWarning.js ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

eval("\n\nconst utils = __webpack_require__(/*! ../utils */ \"(ssr)/./node_modules/mongoose/lib/utils.js\");\n\nif (typeof jest !== 'undefined' && !process.env.SUPPRESS_JEST_WARNINGS) {\n  if (typeof window !== 'undefined') {\n    utils.warn('Mongoose: looks like you\\'re trying to test a Mongoose app ' +\n      'with Jest\\'s default jsdom test environment. Please make sure you read ' +\n      'Mongoose\\'s docs on configuring Jest to test Node.js apps: ' +\n      'https://mongoosejs.com/docs/jest.html. Set the SUPPRESS_JEST_WARNINGS to true ' +\n      'to hide this warning.');\n  }\n\n  if (setTimeout.clock != null && typeof setTimeout.clock.Date === 'function') {\n    utils.warn('Mongoose: looks like you\\'re trying to test a Mongoose app ' +\n      'with Jest\\'s mock timers enabled. Please make sure you read ' +\n      'Mongoose\\'s docs on configuring Jest to test Node.js apps: ' +\n      'https://mongoosejs.com/docs/jest.html. Set the SUPPRESS_JEST_WARNINGS to true ' +\n      'to hide this warning.');\n  }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbW9uZ29vc2UvbGliL2hlbHBlcnMvcHJpbnRKZXN0V2FybmluZy5qcyIsIm1hcHBpbmdzIjoiQUFBYTs7QUFFYixjQUFjLG1CQUFPLENBQUMsNERBQVU7O0FBRWhDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL2FwcDEvLi9ub2RlX21vZHVsZXMvbW9uZ29vc2UvbGliL2hlbHBlcnMvcHJpbnRKZXN0V2FybmluZy5qcz8zNDY3Il0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxuY29uc3QgdXRpbHMgPSByZXF1aXJlKCcuLi91dGlscycpO1xuXG5pZiAodHlwZW9mIGplc3QgIT09ICd1bmRlZmluZWQnICYmICFwcm9jZXNzLmVudi5TVVBQUkVTU19KRVNUX1dBUk5JTkdTKSB7XG4gIGlmICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJykge1xuICAgIHV0aWxzLndhcm4oJ01vbmdvb3NlOiBsb29rcyBsaWtlIHlvdVxcJ3JlIHRyeWluZyB0byB0ZXN0IGEgTW9uZ29vc2UgYXBwICcgK1xuICAgICAgJ3dpdGggSmVzdFxcJ3MgZGVmYXVsdCBqc2RvbSB0ZXN0IGVudmlyb25tZW50LiBQbGVhc2UgbWFrZSBzdXJlIHlvdSByZWFkICcgK1xuICAgICAgJ01vbmdvb3NlXFwncyBkb2NzIG9uIGNvbmZpZ3VyaW5nIEplc3QgdG8gdGVzdCBOb2RlLmpzIGFwcHM6ICcgK1xuICAgICAgJ2h0dHBzOi8vbW9uZ29vc2Vqcy5jb20vZG9jcy9qZXN0Lmh0bWwuIFNldCB0aGUgU1VQUFJFU1NfSkVTVF9XQVJOSU5HUyB0byB0cnVlICcgK1xuICAgICAgJ3RvIGhpZGUgdGhpcyB3YXJuaW5nLicpO1xuICB9XG5cbiAgaWYgKHNldFRpbWVvdXQuY2xvY2sgIT0gbnVsbCAmJiB0eXBlb2Ygc2V0VGltZW91dC5jbG9jay5EYXRlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgdXRpbHMud2FybignTW9uZ29vc2U6IGxvb2tzIGxpa2UgeW91XFwncmUgdHJ5aW5nIHRvIHRlc3QgYSBNb25nb29zZSBhcHAgJyArXG4gICAgICAnd2l0aCBKZXN0XFwncyBtb2NrIHRpbWVycyBlbmFibGVkLiBQbGVhc2UgbWFrZSBzdXJlIHlvdSByZWFkICcgK1xuICAgICAgJ01vbmdvb3NlXFwncyBkb2NzIG9uIGNvbmZpZ3VyaW5nIEplc3QgdG8gdGVzdCBOb2RlLmpzIGFwcHM6ICcgK1xuICAgICAgJ2h0dHBzOi8vbW9uZ29vc2Vqcy5jb20vZG9jcy9qZXN0Lmh0bWwuIFNldCB0aGUgU1VQUFJFU1NfSkVTVF9XQVJOSU5HUyB0byB0cnVlICcgK1xuICAgICAgJ3RvIGhpZGUgdGhpcyB3YXJuaW5nLicpO1xuICB9XG59XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/mongoose/lib/helpers/printJestWarning.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/mongoose/lib/helpers/processConnectionOptions.js":
/*!***********************************************************************!*\
  !*** ./node_modules/mongoose/lib/helpers/processConnectionOptions.js ***!
  \***********************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\n\nconst clone = __webpack_require__(/*! ./clone */ \"(ssr)/./node_modules/mongoose/lib/helpers/clone.js\");\nconst MongooseError = __webpack_require__(/*! ../error/index */ \"(ssr)/./node_modules/mongoose/lib/error/index.js\");\n\nfunction processConnectionOptions(uri, options) {\n  const opts = options ? options : {};\n  const readPreference = opts.readPreference\n    ? opts.readPreference\n    : getUriReadPreference(uri);\n\n  const clonedOpts = clone(opts);\n  const resolvedOpts = (readPreference && readPreference !== 'primary' && readPreference !== 'primaryPreferred')\n    ? resolveOptsConflicts(readPreference, clonedOpts)\n    : clonedOpts;\n\n  return resolvedOpts;\n}\n\nfunction resolveOptsConflicts(pref, opts) {\n  // don't silently override user-provided indexing options\n  if (setsIndexOptions(opts) && setsSecondaryRead(pref)) {\n    throwReadPreferenceError();\n  }\n\n  // if user has not explicitly set any auto-indexing options,\n  // we can silently default them all to false\n  else {\n    return defaultIndexOptsToFalse(opts);\n  }\n}\n\nfunction setsIndexOptions(opts) {\n  const configIdx = opts.config && opts.config.autoIndex;\n  const { autoCreate, autoIndex } = opts;\n  return !!(configIdx || autoCreate || autoIndex);\n}\n\nfunction setsSecondaryRead(prefString) {\n  return !!(prefString === 'secondary' || prefString === 'secondaryPreferred');\n}\n\nfunction getUriReadPreference(connectionString) {\n  const exp = /(?:&|\\?)readPreference=(\\w+)(?:&|$)/;\n  const match = exp.exec(connectionString);\n  return match ? match[1] : null;\n}\n\nfunction defaultIndexOptsToFalse(opts) {\n  opts.config = { autoIndex: false };\n  opts.autoCreate = false;\n  opts.autoIndex = false;\n  return opts;\n}\n\nfunction throwReadPreferenceError() {\n  throw new MongooseError(\n    'MongoDB prohibits index creation on connections that read from ' +\n            'non-primary replicas.  Connections that set \"readPreference\" to \"secondary\" or ' +\n            '\"secondaryPreferred\" may not opt-in to the following connection options: ' +\n            'autoCreate, autoIndex'\n  );\n}\n\nmodule.exports = processConnectionOptions;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbW9uZ29vc2UvbGliL2hlbHBlcnMvcHJvY2Vzc0Nvbm5lY3Rpb25PcHRpb25zLmpzIiwibWFwcGluZ3MiOiJBQUFhOztBQUViLGNBQWMsbUJBQU8sQ0FBQyxtRUFBUztBQUMvQixzQkFBc0IsbUJBQU8sQ0FBQyx3RUFBZ0I7O0FBRTlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsVUFBVSx3QkFBd0I7QUFDbEM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vYXBwMS8uL25vZGVfbW9kdWxlcy9tb25nb29zZS9saWIvaGVscGVycy9wcm9jZXNzQ29ubmVjdGlvbk9wdGlvbnMuanM/NmExMyJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbmNvbnN0IGNsb25lID0gcmVxdWlyZSgnLi9jbG9uZScpO1xuY29uc3QgTW9uZ29vc2VFcnJvciA9IHJlcXVpcmUoJy4uL2Vycm9yL2luZGV4Jyk7XG5cbmZ1bmN0aW9uIHByb2Nlc3NDb25uZWN0aW9uT3B0aW9ucyh1cmksIG9wdGlvbnMpIHtcbiAgY29uc3Qgb3B0cyA9IG9wdGlvbnMgPyBvcHRpb25zIDoge307XG4gIGNvbnN0IHJlYWRQcmVmZXJlbmNlID0gb3B0cy5yZWFkUHJlZmVyZW5jZVxuICAgID8gb3B0cy5yZWFkUHJlZmVyZW5jZVxuICAgIDogZ2V0VXJpUmVhZFByZWZlcmVuY2UodXJpKTtcblxuICBjb25zdCBjbG9uZWRPcHRzID0gY2xvbmUob3B0cyk7XG4gIGNvbnN0IHJlc29sdmVkT3B0cyA9IChyZWFkUHJlZmVyZW5jZSAmJiByZWFkUHJlZmVyZW5jZSAhPT0gJ3ByaW1hcnknICYmIHJlYWRQcmVmZXJlbmNlICE9PSAncHJpbWFyeVByZWZlcnJlZCcpXG4gICAgPyByZXNvbHZlT3B0c0NvbmZsaWN0cyhyZWFkUHJlZmVyZW5jZSwgY2xvbmVkT3B0cylcbiAgICA6IGNsb25lZE9wdHM7XG5cbiAgcmV0dXJuIHJlc29sdmVkT3B0cztcbn1cblxuZnVuY3Rpb24gcmVzb2x2ZU9wdHNDb25mbGljdHMocHJlZiwgb3B0cykge1xuICAvLyBkb24ndCBzaWxlbnRseSBvdmVycmlkZSB1c2VyLXByb3ZpZGVkIGluZGV4aW5nIG9wdGlvbnNcbiAgaWYgKHNldHNJbmRleE9wdGlvbnMob3B0cykgJiYgc2V0c1NlY29uZGFyeVJlYWQocHJlZikpIHtcbiAgICB0aHJvd1JlYWRQcmVmZXJlbmNlRXJyb3IoKTtcbiAgfVxuXG4gIC8vIGlmIHVzZXIgaGFzIG5vdCBleHBsaWNpdGx5IHNldCBhbnkgYXV0by1pbmRleGluZyBvcHRpb25zLFxuICAvLyB3ZSBjYW4gc2lsZW50bHkgZGVmYXVsdCB0aGVtIGFsbCB0byBmYWxzZVxuICBlbHNlIHtcbiAgICByZXR1cm4gZGVmYXVsdEluZGV4T3B0c1RvRmFsc2Uob3B0cyk7XG4gIH1cbn1cblxuZnVuY3Rpb24gc2V0c0luZGV4T3B0aW9ucyhvcHRzKSB7XG4gIGNvbnN0IGNvbmZpZ0lkeCA9IG9wdHMuY29uZmlnICYmIG9wdHMuY29uZmlnLmF1dG9JbmRleDtcbiAgY29uc3QgeyBhdXRvQ3JlYXRlLCBhdXRvSW5kZXggfSA9IG9wdHM7XG4gIHJldHVybiAhIShjb25maWdJZHggfHwgYXV0b0NyZWF0ZSB8fCBhdXRvSW5kZXgpO1xufVxuXG5mdW5jdGlvbiBzZXRzU2Vjb25kYXJ5UmVhZChwcmVmU3RyaW5nKSB7XG4gIHJldHVybiAhIShwcmVmU3RyaW5nID09PSAnc2Vjb25kYXJ5JyB8fCBwcmVmU3RyaW5nID09PSAnc2Vjb25kYXJ5UHJlZmVycmVkJyk7XG59XG5cbmZ1bmN0aW9uIGdldFVyaVJlYWRQcmVmZXJlbmNlKGNvbm5lY3Rpb25TdHJpbmcpIHtcbiAgY29uc3QgZXhwID0gLyg/OiZ8XFw/KXJlYWRQcmVmZXJlbmNlPShcXHcrKSg/OiZ8JCkvO1xuICBjb25zdCBtYXRjaCA9IGV4cC5leGVjKGNvbm5lY3Rpb25TdHJpbmcpO1xuICByZXR1cm4gbWF0Y2ggPyBtYXRjaFsxXSA6IG51bGw7XG59XG5cbmZ1bmN0aW9uIGRlZmF1bHRJbmRleE9wdHNUb0ZhbHNlKG9wdHMpIHtcbiAgb3B0cy5jb25maWcgPSB7IGF1dG9JbmRleDogZmFsc2UgfTtcbiAgb3B0cy5hdXRvQ3JlYXRlID0gZmFsc2U7XG4gIG9wdHMuYXV0b0luZGV4ID0gZmFsc2U7XG4gIHJldHVybiBvcHRzO1xufVxuXG5mdW5jdGlvbiB0aHJvd1JlYWRQcmVmZXJlbmNlRXJyb3IoKSB7XG4gIHRocm93IG5ldyBNb25nb29zZUVycm9yKFxuICAgICdNb25nb0RCIHByb2hpYml0cyBpbmRleCBjcmVhdGlvbiBvbiBjb25uZWN0aW9ucyB0aGF0IHJlYWQgZnJvbSAnICtcbiAgICAgICAgICAgICdub24tcHJpbWFyeSByZXBsaWNhcy4gIENvbm5lY3Rpb25zIHRoYXQgc2V0IFwicmVhZFByZWZlcmVuY2VcIiB0byBcInNlY29uZGFyeVwiIG9yICcgK1xuICAgICAgICAgICAgJ1wic2Vjb25kYXJ5UHJlZmVycmVkXCIgbWF5IG5vdCBvcHQtaW4gdG8gdGhlIGZvbGxvd2luZyBjb25uZWN0aW9uIG9wdGlvbnM6ICcgK1xuICAgICAgICAgICAgJ2F1dG9DcmVhdGUsIGF1dG9JbmRleCdcbiAgKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBwcm9jZXNzQ29ubmVjdGlvbk9wdGlvbnM7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/mongoose/lib/helpers/processConnectionOptions.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/mongoose/lib/helpers/projection/applyProjection.js":
/*!*************************************************************************!*\
  !*** ./node_modules/mongoose/lib/helpers/projection/applyProjection.js ***!
  \*************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\n\nconst hasIncludedChildren = __webpack_require__(/*! ./hasIncludedChildren */ \"(ssr)/./node_modules/mongoose/lib/helpers/projection/hasIncludedChildren.js\");\nconst isExclusive = __webpack_require__(/*! ./isExclusive */ \"(ssr)/./node_modules/mongoose/lib/helpers/projection/isExclusive.js\");\nconst isInclusive = __webpack_require__(/*! ./isInclusive */ \"(ssr)/./node_modules/mongoose/lib/helpers/projection/isInclusive.js\");\nconst isPOJO = (__webpack_require__(/*! ../../utils */ \"(ssr)/./node_modules/mongoose/lib/utils.js\").isPOJO);\n\nmodule.exports = function applyProjection(doc, projection, _hasIncludedChildren) {\n  if (projection == null) {\n    return doc;\n  }\n  if (doc == null) {\n    return doc;\n  }\n\n  let exclude = null;\n  if (isInclusive(projection)) {\n    exclude = false;\n  } else if (isExclusive(projection)) {\n    exclude = true;\n  }\n\n  if (exclude == null) {\n    return doc;\n  } else if (exclude) {\n    _hasIncludedChildren = _hasIncludedChildren || hasIncludedChildren(projection);\n    return applyExclusiveProjection(doc, projection, _hasIncludedChildren);\n  } else {\n    _hasIncludedChildren = _hasIncludedChildren || hasIncludedChildren(projection);\n    return applyInclusiveProjection(doc, projection, _hasIncludedChildren);\n  }\n};\n\nfunction applyExclusiveProjection(doc, projection, hasIncludedChildren, projectionLimb, prefix) {\n  if (doc == null || typeof doc !== 'object') {\n    return doc;\n  }\n  const ret = { ...doc };\n  projectionLimb = prefix ? (projectionLimb || {}) : projection;\n\n  for (const key of Object.keys(ret)) {\n    const fullPath = prefix ? prefix + '.' + key : key;\n    if (projection.hasOwnProperty(fullPath) || projectionLimb.hasOwnProperty(key)) {\n      if (isPOJO(projection[fullPath]) || isPOJO(projectionLimb[key])) {\n        ret[key] = applyExclusiveProjection(ret[key], projection, hasIncludedChildren, projectionLimb[key], fullPath);\n      } else {\n        delete ret[key];\n      }\n    } else if (hasIncludedChildren[fullPath]) {\n      ret[key] = applyExclusiveProjection(ret[key], projection, hasIncludedChildren, projectionLimb[key], fullPath);\n    }\n  }\n  return ret;\n}\n\nfunction applyInclusiveProjection(doc, projection, hasIncludedChildren, projectionLimb, prefix) {\n  if (doc == null || typeof doc !== 'object') {\n    return doc;\n  }\n  const ret = { ...doc };\n  projectionLimb = prefix ? (projectionLimb || {}) : projection;\n\n  for (const key of Object.keys(ret)) {\n    const fullPath = prefix ? prefix + '.' + key : key;\n    if (projection.hasOwnProperty(fullPath) || projectionLimb.hasOwnProperty(key)) {\n      if (isPOJO(projection[fullPath]) || isPOJO(projectionLimb[key])) {\n        ret[key] = applyInclusiveProjection(ret[key], projection, hasIncludedChildren, projectionLimb[key], fullPath);\n      }\n      continue;\n    } else if (hasIncludedChildren[fullPath]) {\n      ret[key] = applyInclusiveProjection(ret[key], projection, hasIncludedChildren, projectionLimb[key], fullPath);\n    } else {\n      delete ret[key];\n    }\n  }\n  return ret;\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbW9uZ29vc2UvbGliL2hlbHBlcnMvcHJvamVjdGlvbi9hcHBseVByb2plY3Rpb24uanMiLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWIsNEJBQTRCLG1CQUFPLENBQUMsMEdBQXVCO0FBQzNELG9CQUFvQixtQkFBTyxDQUFDLDBGQUFlO0FBQzNDLG9CQUFvQixtQkFBTyxDQUFDLDBGQUFlO0FBQzNDLGVBQWUsNkZBQTZCOztBQUU1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEIsaURBQWlEOztBQUVqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQixpREFBaUQ7O0FBRWpEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9hcHAxLy4vbm9kZV9tb2R1bGVzL21vbmdvb3NlL2xpYi9oZWxwZXJzL3Byb2plY3Rpb24vYXBwbHlQcm9qZWN0aW9uLmpzPzlhY2YiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG5jb25zdCBoYXNJbmNsdWRlZENoaWxkcmVuID0gcmVxdWlyZSgnLi9oYXNJbmNsdWRlZENoaWxkcmVuJyk7XG5jb25zdCBpc0V4Y2x1c2l2ZSA9IHJlcXVpcmUoJy4vaXNFeGNsdXNpdmUnKTtcbmNvbnN0IGlzSW5jbHVzaXZlID0gcmVxdWlyZSgnLi9pc0luY2x1c2l2ZScpO1xuY29uc3QgaXNQT0pPID0gcmVxdWlyZSgnLi4vLi4vdXRpbHMnKS5pc1BPSk87XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gYXBwbHlQcm9qZWN0aW9uKGRvYywgcHJvamVjdGlvbiwgX2hhc0luY2x1ZGVkQ2hpbGRyZW4pIHtcbiAgaWYgKHByb2plY3Rpb24gPT0gbnVsbCkge1xuICAgIHJldHVybiBkb2M7XG4gIH1cbiAgaWYgKGRvYyA9PSBudWxsKSB7XG4gICAgcmV0dXJuIGRvYztcbiAgfVxuXG4gIGxldCBleGNsdWRlID0gbnVsbDtcbiAgaWYgKGlzSW5jbHVzaXZlKHByb2plY3Rpb24pKSB7XG4gICAgZXhjbHVkZSA9IGZhbHNlO1xuICB9IGVsc2UgaWYgKGlzRXhjbHVzaXZlKHByb2plY3Rpb24pKSB7XG4gICAgZXhjbHVkZSA9IHRydWU7XG4gIH1cblxuICBpZiAoZXhjbHVkZSA9PSBudWxsKSB7XG4gICAgcmV0dXJuIGRvYztcbiAgfSBlbHNlIGlmIChleGNsdWRlKSB7XG4gICAgX2hhc0luY2x1ZGVkQ2hpbGRyZW4gPSBfaGFzSW5jbHVkZWRDaGlsZHJlbiB8fCBoYXNJbmNsdWRlZENoaWxkcmVuKHByb2plY3Rpb24pO1xuICAgIHJldHVybiBhcHBseUV4Y2x1c2l2ZVByb2plY3Rpb24oZG9jLCBwcm9qZWN0aW9uLCBfaGFzSW5jbHVkZWRDaGlsZHJlbik7XG4gIH0gZWxzZSB7XG4gICAgX2hhc0luY2x1ZGVkQ2hpbGRyZW4gPSBfaGFzSW5jbHVkZWRDaGlsZHJlbiB8fCBoYXNJbmNsdWRlZENoaWxkcmVuKHByb2plY3Rpb24pO1xuICAgIHJldHVybiBhcHBseUluY2x1c2l2ZVByb2plY3Rpb24oZG9jLCBwcm9qZWN0aW9uLCBfaGFzSW5jbHVkZWRDaGlsZHJlbik7XG4gIH1cbn07XG5cbmZ1bmN0aW9uIGFwcGx5RXhjbHVzaXZlUHJvamVjdGlvbihkb2MsIHByb2plY3Rpb24sIGhhc0luY2x1ZGVkQ2hpbGRyZW4sIHByb2plY3Rpb25MaW1iLCBwcmVmaXgpIHtcbiAgaWYgKGRvYyA9PSBudWxsIHx8IHR5cGVvZiBkb2MgIT09ICdvYmplY3QnKSB7XG4gICAgcmV0dXJuIGRvYztcbiAgfVxuICBjb25zdCByZXQgPSB7IC4uLmRvYyB9O1xuICBwcm9qZWN0aW9uTGltYiA9IHByZWZpeCA/IChwcm9qZWN0aW9uTGltYiB8fCB7fSkgOiBwcm9qZWN0aW9uO1xuXG4gIGZvciAoY29uc3Qga2V5IG9mIE9iamVjdC5rZXlzKHJldCkpIHtcbiAgICBjb25zdCBmdWxsUGF0aCA9IHByZWZpeCA/IHByZWZpeCArICcuJyArIGtleSA6IGtleTtcbiAgICBpZiAocHJvamVjdGlvbi5oYXNPd25Qcm9wZXJ0eShmdWxsUGF0aCkgfHwgcHJvamVjdGlvbkxpbWIuaGFzT3duUHJvcGVydHkoa2V5KSkge1xuICAgICAgaWYgKGlzUE9KTyhwcm9qZWN0aW9uW2Z1bGxQYXRoXSkgfHwgaXNQT0pPKHByb2plY3Rpb25MaW1iW2tleV0pKSB7XG4gICAgICAgIHJldFtrZXldID0gYXBwbHlFeGNsdXNpdmVQcm9qZWN0aW9uKHJldFtrZXldLCBwcm9qZWN0aW9uLCBoYXNJbmNsdWRlZENoaWxkcmVuLCBwcm9qZWN0aW9uTGltYltrZXldLCBmdWxsUGF0aCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBkZWxldGUgcmV0W2tleV07XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChoYXNJbmNsdWRlZENoaWxkcmVuW2Z1bGxQYXRoXSkge1xuICAgICAgcmV0W2tleV0gPSBhcHBseUV4Y2x1c2l2ZVByb2plY3Rpb24ocmV0W2tleV0sIHByb2plY3Rpb24sIGhhc0luY2x1ZGVkQ2hpbGRyZW4sIHByb2plY3Rpb25MaW1iW2tleV0sIGZ1bGxQYXRoKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJldDtcbn1cblxuZnVuY3Rpb24gYXBwbHlJbmNsdXNpdmVQcm9qZWN0aW9uKGRvYywgcHJvamVjdGlvbiwgaGFzSW5jbHVkZWRDaGlsZHJlbiwgcHJvamVjdGlvbkxpbWIsIHByZWZpeCkge1xuICBpZiAoZG9jID09IG51bGwgfHwgdHlwZW9mIGRvYyAhPT0gJ29iamVjdCcpIHtcbiAgICByZXR1cm4gZG9jO1xuICB9XG4gIGNvbnN0IHJldCA9IHsgLi4uZG9jIH07XG4gIHByb2plY3Rpb25MaW1iID0gcHJlZml4ID8gKHByb2plY3Rpb25MaW1iIHx8IHt9KSA6IHByb2plY3Rpb247XG5cbiAgZm9yIChjb25zdCBrZXkgb2YgT2JqZWN0LmtleXMocmV0KSkge1xuICAgIGNvbnN0IGZ1bGxQYXRoID0gcHJlZml4ID8gcHJlZml4ICsgJy4nICsga2V5IDoga2V5O1xuICAgIGlmIChwcm9qZWN0aW9uLmhhc093blByb3BlcnR5KGZ1bGxQYXRoKSB8fCBwcm9qZWN0aW9uTGltYi5oYXNPd25Qcm9wZXJ0eShrZXkpKSB7XG4gICAgICBpZiAoaXNQT0pPKHByb2plY3Rpb25bZnVsbFBhdGhdKSB8fCBpc1BPSk8ocHJvamVjdGlvbkxpbWJba2V5XSkpIHtcbiAgICAgICAgcmV0W2tleV0gPSBhcHBseUluY2x1c2l2ZVByb2plY3Rpb24ocmV0W2tleV0sIHByb2plY3Rpb24sIGhhc0luY2x1ZGVkQ2hpbGRyZW4sIHByb2plY3Rpb25MaW1iW2tleV0sIGZ1bGxQYXRoKTtcbiAgICAgIH1cbiAgICAgIGNvbnRpbnVlO1xuICAgIH0gZWxzZSBpZiAoaGFzSW5jbHVkZWRDaGlsZHJlbltmdWxsUGF0aF0pIHtcbiAgICAgIHJldFtrZXldID0gYXBwbHlJbmNsdXNpdmVQcm9qZWN0aW9uKHJldFtrZXldLCBwcm9qZWN0aW9uLCBoYXNJbmNsdWRlZENoaWxkcmVuLCBwcm9qZWN0aW9uTGltYltrZXldLCBmdWxsUGF0aCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGRlbGV0ZSByZXRba2V5XTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJldDtcbn1cbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/mongoose/lib/helpers/projection/applyProjection.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/mongoose/lib/helpers/projection/hasIncludedChildren.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/mongoose/lib/helpers/projection/hasIncludedChildren.js ***!
  \*****************************************************************************/
/***/ ((module) => {

eval("\n\n/**\n * Creates an object that precomputes whether a given path has child fields in\n * the projection.\n *\n * #### Example:\n *\n *     const res = hasIncludedChildren({ 'a.b.c': 0 });\n *     res.a; // 1\n *     res['a.b']; // 1\n *     res['a.b.c']; // 1\n *     res['a.c']; // undefined\n *\n * @param {Object} fields\n * @api private\n */\n\nmodule.exports = function hasIncludedChildren(fields) {\n  const hasIncludedChildren = {};\n  const keys = Object.keys(fields);\n\n  for (const key of keys) {\n    if (key.indexOf('.') === -1) {\n      hasIncludedChildren[key] = 1;\n      continue;\n    }\n    const parts = key.split('.');\n    let c = parts[0];\n\n    for (let i = 0; i < parts.length; ++i) {\n      hasIncludedChildren[c] = 1;\n      if (i + 1 < parts.length) {\n        c = c + '.' + parts[i + 1];\n      }\n    }\n  }\n\n  return hasIncludedChildren;\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbW9uZ29vc2UvbGliL2hlbHBlcnMvcHJvamVjdGlvbi9oYXNJbmNsdWRlZENoaWxkcmVuLmpzIiwibWFwcGluZ3MiOiJBQUFhOztBQUViO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlDQUF5QyxZQUFZO0FBQ3JELGNBQWM7QUFDZCxtQkFBbUI7QUFDbkIscUJBQXFCO0FBQ3JCLG1CQUFtQjtBQUNuQjtBQUNBLFdBQVcsUUFBUTtBQUNuQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxvQkFBb0Isa0JBQWtCO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vYXBwMS8uL25vZGVfbW9kdWxlcy9tb25nb29zZS9saWIvaGVscGVycy9wcm9qZWN0aW9uL2hhc0luY2x1ZGVkQ2hpbGRyZW4uanM/ZTVlZCJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbi8qKlxuICogQ3JlYXRlcyBhbiBvYmplY3QgdGhhdCBwcmVjb21wdXRlcyB3aGV0aGVyIGEgZ2l2ZW4gcGF0aCBoYXMgY2hpbGQgZmllbGRzIGluXG4gKiB0aGUgcHJvamVjdGlvbi5cbiAqXG4gKiAjIyMjIEV4YW1wbGU6XG4gKlxuICogICAgIGNvbnN0IHJlcyA9IGhhc0luY2x1ZGVkQ2hpbGRyZW4oeyAnYS5iLmMnOiAwIH0pO1xuICogICAgIHJlcy5hOyAvLyAxXG4gKiAgICAgcmVzWydhLmInXTsgLy8gMVxuICogICAgIHJlc1snYS5iLmMnXTsgLy8gMVxuICogICAgIHJlc1snYS5jJ107IC8vIHVuZGVmaW5lZFxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBmaWVsZHNcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gaGFzSW5jbHVkZWRDaGlsZHJlbihmaWVsZHMpIHtcbiAgY29uc3QgaGFzSW5jbHVkZWRDaGlsZHJlbiA9IHt9O1xuICBjb25zdCBrZXlzID0gT2JqZWN0LmtleXMoZmllbGRzKTtcblxuICBmb3IgKGNvbnN0IGtleSBvZiBrZXlzKSB7XG4gICAgaWYgKGtleS5pbmRleE9mKCcuJykgPT09IC0xKSB7XG4gICAgICBoYXNJbmNsdWRlZENoaWxkcmVuW2tleV0gPSAxO1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIGNvbnN0IHBhcnRzID0ga2V5LnNwbGl0KCcuJyk7XG4gICAgbGV0IGMgPSBwYXJ0c1swXTtcblxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcGFydHMubGVuZ3RoOyArK2kpIHtcbiAgICAgIGhhc0luY2x1ZGVkQ2hpbGRyZW5bY10gPSAxO1xuICAgICAgaWYgKGkgKyAxIDwgcGFydHMubGVuZ3RoKSB7XG4gICAgICAgIGMgPSBjICsgJy4nICsgcGFydHNbaSArIDFdO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBoYXNJbmNsdWRlZENoaWxkcmVuO1xufTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/mongoose/lib/helpers/projection/hasIncludedChildren.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/mongoose/lib/helpers/projection/isDefiningProjection.js":
/*!******************************************************************************!*\
  !*** ./node_modules/mongoose/lib/helpers/projection/isDefiningProjection.js ***!
  \******************************************************************************/
/***/ ((module) => {

eval("\n\n/*!\n * ignore\n */\n\nmodule.exports = function isDefiningProjection(val) {\n  if (val == null) {\n    // `undefined` or `null` become exclusive projections\n    return true;\n  }\n  if (typeof val === 'object') {\n    // Only cases where a value does **not** define whether the whole projection\n    // is inclusive or exclusive are `$meta` and `$slice`.\n    return !('$meta' in val) && !('$slice' in val);\n  }\n  return true;\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbW9uZ29vc2UvbGliL2hlbHBlcnMvcHJvamVjdGlvbi9pc0RlZmluaW5nUHJvamVjdGlvbi5qcyIsIm1hcHBpbmdzIjoiQUFBYTs7QUFFYjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vYXBwMS8uL25vZGVfbW9kdWxlcy9tb25nb29zZS9saWIvaGVscGVycy9wcm9qZWN0aW9uL2lzRGVmaW5pbmdQcm9qZWN0aW9uLmpzPzhjOGQiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG4vKiFcbiAqIGlnbm9yZVxuICovXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gaXNEZWZpbmluZ1Byb2plY3Rpb24odmFsKSB7XG4gIGlmICh2YWwgPT0gbnVsbCkge1xuICAgIC8vIGB1bmRlZmluZWRgIG9yIGBudWxsYCBiZWNvbWUgZXhjbHVzaXZlIHByb2plY3Rpb25zXG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgaWYgKHR5cGVvZiB2YWwgPT09ICdvYmplY3QnKSB7XG4gICAgLy8gT25seSBjYXNlcyB3aGVyZSBhIHZhbHVlIGRvZXMgKipub3QqKiBkZWZpbmUgd2hldGhlciB0aGUgd2hvbGUgcHJvamVjdGlvblxuICAgIC8vIGlzIGluY2x1c2l2ZSBvciBleGNsdXNpdmUgYXJlIGAkbWV0YWAgYW5kIGAkc2xpY2VgLlxuICAgIHJldHVybiAhKCckbWV0YScgaW4gdmFsKSAmJiAhKCckc2xpY2UnIGluIHZhbCk7XG4gIH1cbiAgcmV0dXJuIHRydWU7XG59O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/mongoose/lib/helpers/projection/isDefiningProjection.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/mongoose/lib/helpers/projection/isExclusive.js":
/*!*********************************************************************!*\
  !*** ./node_modules/mongoose/lib/helpers/projection/isExclusive.js ***!
  \*********************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\n\nconst isDefiningProjection = __webpack_require__(/*! ./isDefiningProjection */ \"(ssr)/./node_modules/mongoose/lib/helpers/projection/isDefiningProjection.js\");\n\n/*!\n * ignore\n */\n\nmodule.exports = function isExclusive(projection) {\n  if (projection == null) {\n    return null;\n  }\n\n  const keys = Object.keys(projection);\n  let ki = keys.length;\n  let exclude = null;\n\n  if (ki === 1 && keys[0] === '_id') {\n    exclude = !projection._id;\n  } else {\n    while (ki--) {\n      // Does this projection explicitly define inclusion/exclusion?\n      // Explicitly avoid `$meta` and `$slice`\n      const key = keys[ki];\n      if (key !== '_id' && isDefiningProjection(projection[key])) {\n        exclude = (projection[key] != null && typeof projection[key] === 'object') ?\n          isExclusive(projection[key]) :\n          !projection[key];\n        break;\n      }\n    }\n  }\n\n  return exclude;\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbW9uZ29vc2UvbGliL2hlbHBlcnMvcHJvamVjdGlvbi9pc0V4Y2x1c2l2ZS5qcyIsIm1hcHBpbmdzIjoiQUFBYTs7QUFFYiw2QkFBNkIsbUJBQU8sQ0FBQyw0R0FBd0I7O0FBRTdEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL2FwcDEvLi9ub2RlX21vZHVsZXMvbW9uZ29vc2UvbGliL2hlbHBlcnMvcHJvamVjdGlvbi9pc0V4Y2x1c2l2ZS5qcz9iZjgwIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxuY29uc3QgaXNEZWZpbmluZ1Byb2plY3Rpb24gPSByZXF1aXJlKCcuL2lzRGVmaW5pbmdQcm9qZWN0aW9uJyk7XG5cbi8qIVxuICogaWdub3JlXG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBpc0V4Y2x1c2l2ZShwcm9qZWN0aW9uKSB7XG4gIGlmIChwcm9qZWN0aW9uID09IG51bGwpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIGNvbnN0IGtleXMgPSBPYmplY3Qua2V5cyhwcm9qZWN0aW9uKTtcbiAgbGV0IGtpID0ga2V5cy5sZW5ndGg7XG4gIGxldCBleGNsdWRlID0gbnVsbDtcblxuICBpZiAoa2kgPT09IDEgJiYga2V5c1swXSA9PT0gJ19pZCcpIHtcbiAgICBleGNsdWRlID0gIXByb2plY3Rpb24uX2lkO1xuICB9IGVsc2Uge1xuICAgIHdoaWxlIChraS0tKSB7XG4gICAgICAvLyBEb2VzIHRoaXMgcHJvamVjdGlvbiBleHBsaWNpdGx5IGRlZmluZSBpbmNsdXNpb24vZXhjbHVzaW9uP1xuICAgICAgLy8gRXhwbGljaXRseSBhdm9pZCBgJG1ldGFgIGFuZCBgJHNsaWNlYFxuICAgICAgY29uc3Qga2V5ID0ga2V5c1traV07XG4gICAgICBpZiAoa2V5ICE9PSAnX2lkJyAmJiBpc0RlZmluaW5nUHJvamVjdGlvbihwcm9qZWN0aW9uW2tleV0pKSB7XG4gICAgICAgIGV4Y2x1ZGUgPSAocHJvamVjdGlvbltrZXldICE9IG51bGwgJiYgdHlwZW9mIHByb2plY3Rpb25ba2V5XSA9PT0gJ29iamVjdCcpID9cbiAgICAgICAgICBpc0V4Y2x1c2l2ZShwcm9qZWN0aW9uW2tleV0pIDpcbiAgICAgICAgICAhcHJvamVjdGlvbltrZXldO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gZXhjbHVkZTtcbn07XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/mongoose/lib/helpers/projection/isExclusive.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/mongoose/lib/helpers/projection/isInclusive.js":
/*!*********************************************************************!*\
  !*** ./node_modules/mongoose/lib/helpers/projection/isInclusive.js ***!
  \*********************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\n\nconst isDefiningProjection = __webpack_require__(/*! ./isDefiningProjection */ \"(ssr)/./node_modules/mongoose/lib/helpers/projection/isDefiningProjection.js\");\n\n/*!\n * ignore\n */\n\nmodule.exports = function isInclusive(projection) {\n  if (projection == null) {\n    return false;\n  }\n\n  const props = Object.keys(projection);\n  const numProps = props.length;\n  if (numProps === 0) {\n    return false;\n  }\n\n  for (let i = 0; i < numProps; ++i) {\n    const prop = props[i];\n    // Plus paths can't define the projection (see gh-7050)\n    if (prop.startsWith('+')) {\n      continue;\n    }\n    // If field is truthy (1, true, etc.) and not an object, then this\n    // projection must be inclusive. If object, assume its $meta, $slice, etc.\n    if (isDefiningProjection(projection[prop]) && !!projection[prop]) {\n      if (projection[prop] != null && typeof projection[prop] === 'object') {\n        return isInclusive(projection[prop]);\n      } else {\n        return !!projection[prop];\n      }\n    }\n  }\n\n  return false;\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbW9uZ29vc2UvbGliL2hlbHBlcnMvcHJvamVjdGlvbi9pc0luY2x1c2l2ZS5qcyIsIm1hcHBpbmdzIjoiQUFBYTs7QUFFYiw2QkFBNkIsbUJBQU8sQ0FBQyw0R0FBd0I7O0FBRTdEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGtCQUFrQixjQUFjO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9hcHAxLy4vbm9kZV9tb2R1bGVzL21vbmdvb3NlL2xpYi9oZWxwZXJzL3Byb2plY3Rpb24vaXNJbmNsdXNpdmUuanM/OTlhYiJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbmNvbnN0IGlzRGVmaW5pbmdQcm9qZWN0aW9uID0gcmVxdWlyZSgnLi9pc0RlZmluaW5nUHJvamVjdGlvbicpO1xuXG4vKiFcbiAqIGlnbm9yZVxuICovXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gaXNJbmNsdXNpdmUocHJvamVjdGlvbikge1xuICBpZiAocHJvamVjdGlvbiA9PSBudWxsKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgY29uc3QgcHJvcHMgPSBPYmplY3Qua2V5cyhwcm9qZWN0aW9uKTtcbiAgY29uc3QgbnVtUHJvcHMgPSBwcm9wcy5sZW5ndGg7XG4gIGlmIChudW1Qcm9wcyA9PT0gMCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgbnVtUHJvcHM7ICsraSkge1xuICAgIGNvbnN0IHByb3AgPSBwcm9wc1tpXTtcbiAgICAvLyBQbHVzIHBhdGhzIGNhbid0IGRlZmluZSB0aGUgcHJvamVjdGlvbiAoc2VlIGdoLTcwNTApXG4gICAgaWYgKHByb3Auc3RhcnRzV2l0aCgnKycpKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgLy8gSWYgZmllbGQgaXMgdHJ1dGh5ICgxLCB0cnVlLCBldGMuKSBhbmQgbm90IGFuIG9iamVjdCwgdGhlbiB0aGlzXG4gICAgLy8gcHJvamVjdGlvbiBtdXN0IGJlIGluY2x1c2l2ZS4gSWYgb2JqZWN0LCBhc3N1bWUgaXRzICRtZXRhLCAkc2xpY2UsIGV0Yy5cbiAgICBpZiAoaXNEZWZpbmluZ1Byb2plY3Rpb24ocHJvamVjdGlvbltwcm9wXSkgJiYgISFwcm9qZWN0aW9uW3Byb3BdKSB7XG4gICAgICBpZiAocHJvamVjdGlvbltwcm9wXSAhPSBudWxsICYmIHR5cGVvZiBwcm9qZWN0aW9uW3Byb3BdID09PSAnb2JqZWN0Jykge1xuICAgICAgICByZXR1cm4gaXNJbmNsdXNpdmUocHJvamVjdGlvbltwcm9wXSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gISFwcm9qZWN0aW9uW3Byb3BdO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBmYWxzZTtcbn07XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/mongoose/lib/helpers/projection/isInclusive.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/mongoose/lib/helpers/projection/isPathExcluded.js":
/*!************************************************************************!*\
  !*** ./node_modules/mongoose/lib/helpers/projection/isPathExcluded.js ***!
  \************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\n\nconst isDefiningProjection = __webpack_require__(/*! ./isDefiningProjection */ \"(ssr)/./node_modules/mongoose/lib/helpers/projection/isDefiningProjection.js\");\n\n/**\n * Determines if `path` is excluded by `projection`\n *\n * @param {Object} projection\n * @param {String} path\n * @return {Boolean}\n * @api private\n */\n\nmodule.exports = function isPathExcluded(projection, path) {\n  if (projection == null) {\n    return false;\n  }\n\n  if (path === '_id') {\n    return projection._id === 0;\n  }\n\n  const paths = Object.keys(projection);\n  let type = null;\n\n  for (const _path of paths) {\n    if (isDefiningProjection(projection[_path])) {\n      type = projection[path] === 1 ? 'inclusive' : 'exclusive';\n      break;\n    }\n  }\n\n  if (type === 'inclusive') {\n    return projection[path] !== 1;\n  }\n  if (type === 'exclusive') {\n    return projection[path] === 0;\n  }\n  return false;\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbW9uZ29vc2UvbGliL2hlbHBlcnMvcHJvamVjdGlvbi9pc1BhdGhFeGNsdWRlZC5qcyIsIm1hcHBpbmdzIjoiQUFBYTs7QUFFYiw2QkFBNkIsbUJBQU8sQ0FBQyw0R0FBd0I7O0FBRTdEO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsWUFBWTtBQUNaO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9hcHAxLy4vbm9kZV9tb2R1bGVzL21vbmdvb3NlL2xpYi9oZWxwZXJzL3Byb2plY3Rpb24vaXNQYXRoRXhjbHVkZWQuanM/MTVhZSJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbmNvbnN0IGlzRGVmaW5pbmdQcm9qZWN0aW9uID0gcmVxdWlyZSgnLi9pc0RlZmluaW5nUHJvamVjdGlvbicpO1xuXG4vKipcbiAqIERldGVybWluZXMgaWYgYHBhdGhgIGlzIGV4Y2x1ZGVkIGJ5IGBwcm9qZWN0aW9uYFxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBwcm9qZWN0aW9uXG4gKiBAcGFyYW0ge1N0cmluZ30gcGF0aFxuICogQHJldHVybiB7Qm9vbGVhbn1cbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gaXNQYXRoRXhjbHVkZWQocHJvamVjdGlvbiwgcGF0aCkge1xuICBpZiAocHJvamVjdGlvbiA9PSBudWxsKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgaWYgKHBhdGggPT09ICdfaWQnKSB7XG4gICAgcmV0dXJuIHByb2plY3Rpb24uX2lkID09PSAwO1xuICB9XG5cbiAgY29uc3QgcGF0aHMgPSBPYmplY3Qua2V5cyhwcm9qZWN0aW9uKTtcbiAgbGV0IHR5cGUgPSBudWxsO1xuXG4gIGZvciAoY29uc3QgX3BhdGggb2YgcGF0aHMpIHtcbiAgICBpZiAoaXNEZWZpbmluZ1Byb2plY3Rpb24ocHJvamVjdGlvbltfcGF0aF0pKSB7XG4gICAgICB0eXBlID0gcHJvamVjdGlvbltwYXRoXSA9PT0gMSA/ICdpbmNsdXNpdmUnIDogJ2V4Y2x1c2l2ZSc7XG4gICAgICBicmVhaztcbiAgICB9XG4gIH1cblxuICBpZiAodHlwZSA9PT0gJ2luY2x1c2l2ZScpIHtcbiAgICByZXR1cm4gcHJvamVjdGlvbltwYXRoXSAhPT0gMTtcbiAgfVxuICBpZiAodHlwZSA9PT0gJ2V4Y2x1c2l2ZScpIHtcbiAgICByZXR1cm4gcHJvamVjdGlvbltwYXRoXSA9PT0gMDtcbiAgfVxuICByZXR1cm4gZmFsc2U7XG59O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/mongoose/lib/helpers/projection/isPathExcluded.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/mongoose/lib/helpers/projection/isPathSelectedInclusive.js":
/*!*********************************************************************************!*\
  !*** ./node_modules/mongoose/lib/helpers/projection/isPathSelectedInclusive.js ***!
  \*********************************************************************************/
/***/ ((module) => {

eval("\n\n/*!\n * ignore\n */\n\nmodule.exports = function isPathSelectedInclusive(fields, path) {\n  const chunks = path.split('.');\n  let cur = '';\n  let j;\n  let keys;\n  let numKeys;\n  for (let i = 0; i < chunks.length; ++i) {\n    cur += cur.length ? '.' : '' + chunks[i];\n    if (fields[cur]) {\n      keys = Object.keys(fields);\n      numKeys = keys.length;\n      for (j = 0; j < numKeys; ++j) {\n        if (keys[i].indexOf(cur + '.') === 0 && keys[i].indexOf(path) !== 0) {\n          continue;\n        }\n      }\n      return true;\n    }\n  }\n\n  return false;\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbW9uZ29vc2UvbGliL2hlbHBlcnMvcHJvamVjdGlvbi9pc1BhdGhTZWxlY3RlZEluY2x1c2l2ZS5qcyIsIm1hcHBpbmdzIjoiQUFBYTs7QUFFYjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLG1CQUFtQjtBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixhQUFhO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9hcHAxLy4vbm9kZV9tb2R1bGVzL21vbmdvb3NlL2xpYi9oZWxwZXJzL3Byb2plY3Rpb24vaXNQYXRoU2VsZWN0ZWRJbmNsdXNpdmUuanM/N2FjMSJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbi8qIVxuICogaWdub3JlXG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBpc1BhdGhTZWxlY3RlZEluY2x1c2l2ZShmaWVsZHMsIHBhdGgpIHtcbiAgY29uc3QgY2h1bmtzID0gcGF0aC5zcGxpdCgnLicpO1xuICBsZXQgY3VyID0gJyc7XG4gIGxldCBqO1xuICBsZXQga2V5cztcbiAgbGV0IG51bUtleXM7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgY2h1bmtzLmxlbmd0aDsgKytpKSB7XG4gICAgY3VyICs9IGN1ci5sZW5ndGggPyAnLicgOiAnJyArIGNodW5rc1tpXTtcbiAgICBpZiAoZmllbGRzW2N1cl0pIHtcbiAgICAgIGtleXMgPSBPYmplY3Qua2V5cyhmaWVsZHMpO1xuICAgICAgbnVtS2V5cyA9IGtleXMubGVuZ3RoO1xuICAgICAgZm9yIChqID0gMDsgaiA8IG51bUtleXM7ICsraikge1xuICAgICAgICBpZiAoa2V5c1tpXS5pbmRleE9mKGN1ciArICcuJykgPT09IDAgJiYga2V5c1tpXS5pbmRleE9mKHBhdGgpICE9PSAwKSB7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBmYWxzZTtcbn07XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/mongoose/lib/helpers/projection/isPathSelectedInclusive.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/mongoose/lib/helpers/projection/isSubpath.js":
/*!*******************************************************************!*\
  !*** ./node_modules/mongoose/lib/helpers/projection/isSubpath.js ***!
  \*******************************************************************/
/***/ ((module) => {

eval("\n\n/**\n * Determines if `path2` is a subpath of or equal to `path1`\n *\n * @param {string} path1\n * @param {string} path2\n * @return {Boolean}\n * @api private\n */\n\nmodule.exports = function isSubpath(path1, path2) {\n  return path1 === path2 || path2.startsWith(path1 + '.');\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbW9uZ29vc2UvbGliL2hlbHBlcnMvcHJvamVjdGlvbi9pc1N1YnBhdGguanMiLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWI7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixZQUFZO0FBQ1o7QUFDQTs7QUFFQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9hcHAxLy4vbm9kZV9tb2R1bGVzL21vbmdvb3NlL2xpYi9oZWxwZXJzL3Byb2plY3Rpb24vaXNTdWJwYXRoLmpzPzEwZDgiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG4vKipcbiAqIERldGVybWluZXMgaWYgYHBhdGgyYCBpcyBhIHN1YnBhdGggb2Ygb3IgZXF1YWwgdG8gYHBhdGgxYFxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBwYXRoMVxuICogQHBhcmFtIHtzdHJpbmd9IHBhdGgyXG4gKiBAcmV0dXJuIHtCb29sZWFufVxuICogQGFwaSBwcml2YXRlXG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBpc1N1YnBhdGgocGF0aDEsIHBhdGgyKSB7XG4gIHJldHVybiBwYXRoMSA9PT0gcGF0aDIgfHwgcGF0aDIuc3RhcnRzV2l0aChwYXRoMSArICcuJyk7XG59O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/mongoose/lib/helpers/projection/isSubpath.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/mongoose/lib/helpers/projection/parseProjection.js":
/*!*************************************************************************!*\
  !*** ./node_modules/mongoose/lib/helpers/projection/parseProjection.js ***!
  \*************************************************************************/
/***/ ((module) => {

eval("\n\n/**\n * Convert a string or array into a projection object, retaining all\n * `-` and `+` paths.\n */\n\nmodule.exports = function parseProjection(v, retainMinusPaths) {\n  const type = typeof v;\n\n  if (type === 'string') {\n    v = v.split(/\\s+/);\n  }\n  if (!Array.isArray(v) && Object.prototype.toString.call(v) !== '[object Arguments]') {\n    return v;\n  }\n\n  const len = v.length;\n  const ret = {};\n  for (let i = 0; i < len; ++i) {\n    let field = v[i];\n    if (!field) {\n      continue;\n    }\n    const include = '-' == field[0] ? 0 : 1;\n    if (!retainMinusPaths && include === 0) {\n      field = field.substring(1);\n    }\n    ret[field] = include;\n  }\n\n  return ret;\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbW9uZ29vc2UvbGliL2hlbHBlcnMvcHJvamVjdGlvbi9wYXJzZVByb2plY3Rpb24uanMiLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGtCQUFrQixTQUFTO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9hcHAxLy4vbm9kZV9tb2R1bGVzL21vbmdvb3NlL2xpYi9oZWxwZXJzL3Byb2plY3Rpb24vcGFyc2VQcm9qZWN0aW9uLmpzPzUwYzMiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG4vKipcbiAqIENvbnZlcnQgYSBzdHJpbmcgb3IgYXJyYXkgaW50byBhIHByb2plY3Rpb24gb2JqZWN0LCByZXRhaW5pbmcgYWxsXG4gKiBgLWAgYW5kIGArYCBwYXRocy5cbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIHBhcnNlUHJvamVjdGlvbih2LCByZXRhaW5NaW51c1BhdGhzKSB7XG4gIGNvbnN0IHR5cGUgPSB0eXBlb2YgdjtcblxuICBpZiAodHlwZSA9PT0gJ3N0cmluZycpIHtcbiAgICB2ID0gdi5zcGxpdCgvXFxzKy8pO1xuICB9XG4gIGlmICghQXJyYXkuaXNBcnJheSh2KSAmJiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwodikgIT09ICdbb2JqZWN0IEFyZ3VtZW50c10nKSB7XG4gICAgcmV0dXJuIHY7XG4gIH1cblxuICBjb25zdCBsZW4gPSB2Lmxlbmd0aDtcbiAgY29uc3QgcmV0ID0ge307XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgbGVuOyArK2kpIHtcbiAgICBsZXQgZmllbGQgPSB2W2ldO1xuICAgIGlmICghZmllbGQpIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICBjb25zdCBpbmNsdWRlID0gJy0nID09IGZpZWxkWzBdID8gMCA6IDE7XG4gICAgaWYgKCFyZXRhaW5NaW51c1BhdGhzICYmIGluY2x1ZGUgPT09IDApIHtcbiAgICAgIGZpZWxkID0gZmllbGQuc3Vic3RyaW5nKDEpO1xuICAgIH1cbiAgICByZXRbZmllbGRdID0gaW5jbHVkZTtcbiAgfVxuXG4gIHJldHVybiByZXQ7XG59O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/mongoose/lib/helpers/projection/parseProjection.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/mongoose/lib/helpers/promiseOrCallback.js":
/*!****************************************************************!*\
  !*** ./node_modules/mongoose/lib/helpers/promiseOrCallback.js ***!
  \****************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\n\nconst immediate = __webpack_require__(/*! ./immediate */ \"(ssr)/./node_modules/mongoose/lib/helpers/immediate.js\");\n\nconst emittedSymbol = Symbol('mongoose#emitted');\n\nmodule.exports = function promiseOrCallback(callback, fn, ee, Promise) {\n  if (typeof callback === 'function') {\n    try {\n      return fn(function(error) {\n        if (error != null) {\n          if (ee != null && ee.listeners != null && ee.listeners('error').length > 0 && !error[emittedSymbol]) {\n            error[emittedSymbol] = true;\n            ee.emit('error', error);\n          }\n          try {\n            callback(error);\n          } catch (error) {\n            return immediate(() => {\n              throw error;\n            });\n          }\n          return;\n        }\n        callback.apply(this, arguments);\n      });\n    } catch (error) {\n      if (ee != null && ee.listeners != null && ee.listeners('error').length > 0 && !error[emittedSymbol]) {\n        error[emittedSymbol] = true;\n        ee.emit('error', error);\n      }\n\n      return callback(error);\n    }\n  }\n\n  Promise = Promise || global.Promise;\n\n  return new Promise((resolve, reject) => {\n    fn(function(error, res) {\n      if (error != null) {\n        if (ee != null && ee.listeners != null && ee.listeners('error').length > 0 && !error[emittedSymbol]) {\n          error[emittedSymbol] = true;\n          ee.emit('error', error);\n        }\n        return reject(error);\n      }\n      if (arguments.length > 2) {\n        return resolve(Array.prototype.slice.call(arguments, 1));\n      }\n      resolve(res);\n    });\n  });\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbW9uZ29vc2UvbGliL2hlbHBlcnMvcHJvbWlzZU9yQ2FsbGJhY2suanMiLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWIsa0JBQWtCLG1CQUFPLENBQUMsMkVBQWE7O0FBRXZDOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLEdBQUc7QUFDSCIsInNvdXJjZXMiOlsid2VicGFjazovL2FwcDEvLi9ub2RlX21vZHVsZXMvbW9uZ29vc2UvbGliL2hlbHBlcnMvcHJvbWlzZU9yQ2FsbGJhY2suanM/ODI3MyJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbmNvbnN0IGltbWVkaWF0ZSA9IHJlcXVpcmUoJy4vaW1tZWRpYXRlJyk7XG5cbmNvbnN0IGVtaXR0ZWRTeW1ib2wgPSBTeW1ib2woJ21vbmdvb3NlI2VtaXR0ZWQnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBwcm9taXNlT3JDYWxsYmFjayhjYWxsYmFjaywgZm4sIGVlLCBQcm9taXNlKSB7XG4gIGlmICh0eXBlb2YgY2FsbGJhY2sgPT09ICdmdW5jdGlvbicpIHtcbiAgICB0cnkge1xuICAgICAgcmV0dXJuIGZuKGZ1bmN0aW9uKGVycm9yKSB7XG4gICAgICAgIGlmIChlcnJvciAhPSBudWxsKSB7XG4gICAgICAgICAgaWYgKGVlICE9IG51bGwgJiYgZWUubGlzdGVuZXJzICE9IG51bGwgJiYgZWUubGlzdGVuZXJzKCdlcnJvcicpLmxlbmd0aCA+IDAgJiYgIWVycm9yW2VtaXR0ZWRTeW1ib2xdKSB7XG4gICAgICAgICAgICBlcnJvcltlbWl0dGVkU3ltYm9sXSA9IHRydWU7XG4gICAgICAgICAgICBlZS5lbWl0KCdlcnJvcicsIGVycm9yKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNhbGxiYWNrKGVycm9yKTtcbiAgICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgcmV0dXJuIGltbWVkaWF0ZSgoKSA9PiB7XG4gICAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjYWxsYmFjay5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgfSk7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGlmIChlZSAhPSBudWxsICYmIGVlLmxpc3RlbmVycyAhPSBudWxsICYmIGVlLmxpc3RlbmVycygnZXJyb3InKS5sZW5ndGggPiAwICYmICFlcnJvcltlbWl0dGVkU3ltYm9sXSkge1xuICAgICAgICBlcnJvcltlbWl0dGVkU3ltYm9sXSA9IHRydWU7XG4gICAgICAgIGVlLmVtaXQoJ2Vycm9yJywgZXJyb3IpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gY2FsbGJhY2soZXJyb3IpO1xuICAgIH1cbiAgfVxuXG4gIFByb21pc2UgPSBQcm9taXNlIHx8IGdsb2JhbC5Qcm9taXNlO1xuXG4gIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgZm4oZnVuY3Rpb24oZXJyb3IsIHJlcykge1xuICAgICAgaWYgKGVycm9yICE9IG51bGwpIHtcbiAgICAgICAgaWYgKGVlICE9IG51bGwgJiYgZWUubGlzdGVuZXJzICE9IG51bGwgJiYgZWUubGlzdGVuZXJzKCdlcnJvcicpLmxlbmd0aCA+IDAgJiYgIWVycm9yW2VtaXR0ZWRTeW1ib2xdKSB7XG4gICAgICAgICAgZXJyb3JbZW1pdHRlZFN5bWJvbF0gPSB0cnVlO1xuICAgICAgICAgIGVlLmVtaXQoJ2Vycm9yJywgZXJyb3IpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZWplY3QoZXJyb3IpO1xuICAgICAgfVxuICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPiAyKSB7XG4gICAgICAgIHJldHVybiByZXNvbHZlKEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMSkpO1xuICAgICAgfVxuICAgICAgcmVzb2x2ZShyZXMpO1xuICAgIH0pO1xuICB9KTtcbn07XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/mongoose/lib/helpers/promiseOrCallback.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/mongoose/lib/helpers/query/applyGlobalOption.js":
/*!**********************************************************************!*\
  !*** ./node_modules/mongoose/lib/helpers/query/applyGlobalOption.js ***!
  \**********************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\n\nconst utils = __webpack_require__(/*! ../../utils */ \"(ssr)/./node_modules/mongoose/lib/utils.js\");\n\nfunction applyGlobalMaxTimeMS(options, model) {\n  applyGlobalOption(options, model, 'maxTimeMS');\n}\n\nfunction applyGlobalDiskUse(options, model) {\n  applyGlobalOption(options, model, 'allowDiskUse');\n}\n\nmodule.exports = {\n  applyGlobalMaxTimeMS,\n  applyGlobalDiskUse\n};\n\n\nfunction applyGlobalOption(options, model, optionName) {\n  if (utils.hasUserDefinedProperty(options, optionName)) {\n    return;\n  }\n\n  if (utils.hasUserDefinedProperty(model.db.options, optionName)) {\n    options[optionName] = model.db.options[optionName];\n  } else if (utils.hasUserDefinedProperty(model.base.options, optionName)) {\n    options[optionName] = model.base.options[optionName];\n  }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbW9uZ29vc2UvbGliL2hlbHBlcnMvcXVlcnkvYXBwbHlHbG9iYWxPcHRpb24uanMiLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWIsY0FBYyxtQkFBTyxDQUFDLCtEQUFhOztBQUVuQztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL2FwcDEvLi9ub2RlX21vZHVsZXMvbW9uZ29vc2UvbGliL2hlbHBlcnMvcXVlcnkvYXBwbHlHbG9iYWxPcHRpb24uanM/Yzk0YSJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbmNvbnN0IHV0aWxzID0gcmVxdWlyZSgnLi4vLi4vdXRpbHMnKTtcblxuZnVuY3Rpb24gYXBwbHlHbG9iYWxNYXhUaW1lTVMob3B0aW9ucywgbW9kZWwpIHtcbiAgYXBwbHlHbG9iYWxPcHRpb24ob3B0aW9ucywgbW9kZWwsICdtYXhUaW1lTVMnKTtcbn1cblxuZnVuY3Rpb24gYXBwbHlHbG9iYWxEaXNrVXNlKG9wdGlvbnMsIG1vZGVsKSB7XG4gIGFwcGx5R2xvYmFsT3B0aW9uKG9wdGlvbnMsIG1vZGVsLCAnYWxsb3dEaXNrVXNlJyk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBhcHBseUdsb2JhbE1heFRpbWVNUyxcbiAgYXBwbHlHbG9iYWxEaXNrVXNlXG59O1xuXG5cbmZ1bmN0aW9uIGFwcGx5R2xvYmFsT3B0aW9uKG9wdGlvbnMsIG1vZGVsLCBvcHRpb25OYW1lKSB7XG4gIGlmICh1dGlscy5oYXNVc2VyRGVmaW5lZFByb3BlcnR5KG9wdGlvbnMsIG9wdGlvbk5hbWUpKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgaWYgKHV0aWxzLmhhc1VzZXJEZWZpbmVkUHJvcGVydHkobW9kZWwuZGIub3B0aW9ucywgb3B0aW9uTmFtZSkpIHtcbiAgICBvcHRpb25zW29wdGlvbk5hbWVdID0gbW9kZWwuZGIub3B0aW9uc1tvcHRpb25OYW1lXTtcbiAgfSBlbHNlIGlmICh1dGlscy5oYXNVc2VyRGVmaW5lZFByb3BlcnR5KG1vZGVsLmJhc2Uub3B0aW9ucywgb3B0aW9uTmFtZSkpIHtcbiAgICBvcHRpb25zW29wdGlvbk5hbWVdID0gbW9kZWwuYmFzZS5vcHRpb25zW29wdGlvbk5hbWVdO1xuICB9XG59XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/mongoose/lib/helpers/query/applyGlobalOption.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/mongoose/lib/helpers/query/applyQueryMiddleware.js":
/*!*************************************************************************!*\
  !*** ./node_modules/mongoose/lib/helpers/query/applyQueryMiddleware.js ***!
  \*************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\n\n/*!\n * ignore\n */\n\nmodule.exports = applyQueryMiddleware;\n\nconst validOps = __webpack_require__(/*! ./validOps */ \"(ssr)/./node_modules/mongoose/lib/helpers/query/validOps.js\");\n\n/*!\n * ignore\n */\n\napplyQueryMiddleware.middlewareFunctions = validOps.concat([\n  'validate'\n]);\n\n/**\n * Apply query middleware\n *\n * @param {Query} Query constructor\n * @param {Model} model\n * @api private\n */\n\nfunction applyQueryMiddleware(Query, model) {\n  const queryMiddleware = model.schema.s.hooks.filter(hook => {\n    const contexts = _getContexts(hook);\n    if (hook.name === 'validate') {\n      return !!contexts.query;\n    }\n    if (hook.name === 'deleteOne' || hook.name === 'updateOne') {\n      return !!contexts.query || Object.keys(contexts).length === 0;\n    }\n    if (hook.query != null || hook.document != null) {\n      return !!hook.query;\n    }\n    return true;\n  });\n\n  Query.prototype._queryMiddleware = queryMiddleware;\n}\n\nfunction _getContexts(hook) {\n  const ret = {};\n  if (hook.hasOwnProperty('query')) {\n    ret.query = hook.query;\n  }\n  if (hook.hasOwnProperty('document')) {\n    ret.document = hook.document;\n  }\n  return ret;\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbW9uZ29vc2UvbGliL2hlbHBlcnMvcXVlcnkvYXBwbHlRdWVyeU1pZGRsZXdhcmUuanMiLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWI7QUFDQTtBQUNBOztBQUVBOztBQUVBLGlCQUFpQixtQkFBTyxDQUFDLCtFQUFZOztBQUVyQztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQixXQUFXLE9BQU87QUFDbEI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL2FwcDEvLi9ub2RlX21vZHVsZXMvbW9uZ29vc2UvbGliL2hlbHBlcnMvcXVlcnkvYXBwbHlRdWVyeU1pZGRsZXdhcmUuanM/OTZjMCJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbi8qIVxuICogaWdub3JlXG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSBhcHBseVF1ZXJ5TWlkZGxld2FyZTtcblxuY29uc3QgdmFsaWRPcHMgPSByZXF1aXJlKCcuL3ZhbGlkT3BzJyk7XG5cbi8qIVxuICogaWdub3JlXG4gKi9cblxuYXBwbHlRdWVyeU1pZGRsZXdhcmUubWlkZGxld2FyZUZ1bmN0aW9ucyA9IHZhbGlkT3BzLmNvbmNhdChbXG4gICd2YWxpZGF0ZSdcbl0pO1xuXG4vKipcbiAqIEFwcGx5IHF1ZXJ5IG1pZGRsZXdhcmVcbiAqXG4gKiBAcGFyYW0ge1F1ZXJ5fSBRdWVyeSBjb25zdHJ1Y3RvclxuICogQHBhcmFtIHtNb2RlbH0gbW9kZWxcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmZ1bmN0aW9uIGFwcGx5UXVlcnlNaWRkbGV3YXJlKFF1ZXJ5LCBtb2RlbCkge1xuICBjb25zdCBxdWVyeU1pZGRsZXdhcmUgPSBtb2RlbC5zY2hlbWEucy5ob29rcy5maWx0ZXIoaG9vayA9PiB7XG4gICAgY29uc3QgY29udGV4dHMgPSBfZ2V0Q29udGV4dHMoaG9vayk7XG4gICAgaWYgKGhvb2submFtZSA9PT0gJ3ZhbGlkYXRlJykge1xuICAgICAgcmV0dXJuICEhY29udGV4dHMucXVlcnk7XG4gICAgfVxuICAgIGlmIChob29rLm5hbWUgPT09ICdkZWxldGVPbmUnIHx8IGhvb2submFtZSA9PT0gJ3VwZGF0ZU9uZScpIHtcbiAgICAgIHJldHVybiAhIWNvbnRleHRzLnF1ZXJ5IHx8IE9iamVjdC5rZXlzKGNvbnRleHRzKS5sZW5ndGggPT09IDA7XG4gICAgfVxuICAgIGlmIChob29rLnF1ZXJ5ICE9IG51bGwgfHwgaG9vay5kb2N1bWVudCAhPSBudWxsKSB7XG4gICAgICByZXR1cm4gISFob29rLnF1ZXJ5O1xuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfSk7XG5cbiAgUXVlcnkucHJvdG90eXBlLl9xdWVyeU1pZGRsZXdhcmUgPSBxdWVyeU1pZGRsZXdhcmU7XG59XG5cbmZ1bmN0aW9uIF9nZXRDb250ZXh0cyhob29rKSB7XG4gIGNvbnN0IHJldCA9IHt9O1xuICBpZiAoaG9vay5oYXNPd25Qcm9wZXJ0eSgncXVlcnknKSkge1xuICAgIHJldC5xdWVyeSA9IGhvb2sucXVlcnk7XG4gIH1cbiAgaWYgKGhvb2suaGFzT3duUHJvcGVydHkoJ2RvY3VtZW50JykpIHtcbiAgICByZXQuZG9jdW1lbnQgPSBob29rLmRvY3VtZW50O1xuICB9XG4gIHJldHVybiByZXQ7XG59XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/mongoose/lib/helpers/query/applyQueryMiddleware.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/mongoose/lib/helpers/query/cast$expr.js":
/*!**************************************************************!*\
  !*** ./node_modules/mongoose/lib/helpers/query/cast$expr.js ***!
  \**************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\n\nconst CastError = __webpack_require__(/*! ../../error/cast */ \"(ssr)/./node_modules/mongoose/lib/error/cast.js\");\nconst StrictModeError = __webpack_require__(/*! ../../error/strict */ \"(ssr)/./node_modules/mongoose/lib/error/strict.js\");\nconst castNumber = __webpack_require__(/*! ../../cast/number */ \"(ssr)/./node_modules/mongoose/lib/cast/number.js\");\n\nconst booleanComparison = new Set(['$and', '$or']);\nconst comparisonOperator = new Set(['$cmp', '$eq', '$lt', '$lte', '$gt', '$gte']);\nconst arithmeticOperatorArray = new Set([\n  // avoid casting '$add' or '$subtract', because expressions can be either number or date,\n  // and we don't have a good way of inferring which arguments should be numbers and which should\n  // be dates.\n  '$multiply',\n  '$divide',\n  '$log',\n  '$mod',\n  '$trunc',\n  '$avg',\n  '$max',\n  '$min',\n  '$stdDevPop',\n  '$stdDevSamp',\n  '$sum'\n]);\nconst arithmeticOperatorNumber = new Set([\n  '$abs',\n  '$exp',\n  '$ceil',\n  '$floor',\n  '$ln',\n  '$log10',\n  '$sqrt',\n  '$sin',\n  '$cos',\n  '$tan',\n  '$asin',\n  '$acos',\n  '$atan',\n  '$atan2',\n  '$asinh',\n  '$acosh',\n  '$atanh',\n  '$sinh',\n  '$cosh',\n  '$tanh',\n  '$degreesToRadians',\n  '$radiansToDegrees'\n]);\nconst arrayElementOperators = new Set([\n  '$arrayElemAt',\n  '$first',\n  '$last'\n]);\nconst dateOperators = new Set([\n  '$year',\n  '$month',\n  '$week',\n  '$dayOfMonth',\n  '$dayOfYear',\n  '$hour',\n  '$minute',\n  '$second',\n  '$isoDayOfWeek',\n  '$isoWeekYear',\n  '$isoWeek',\n  '$millisecond'\n]);\nconst expressionOperator = new Set(['$not']);\n\nmodule.exports = function cast$expr(val, schema, strictQuery) {\n  if (typeof val !== 'object' || val === null) {\n    throw new Error('`$expr` must be an object');\n  }\n\n  return _castExpression(val, schema, strictQuery);\n};\n\nfunction _castExpression(val, schema, strictQuery) {\n  // Preserve the value if it represents a path or if it's null\n  if (isPath(val) || val === null) {\n    return val;\n  }\n\n  if (val.$cond != null) {\n    if (Array.isArray(val.$cond)) {\n      val.$cond = val.$cond.map(expr => _castExpression(expr, schema, strictQuery));\n    } else {\n      val.$cond.if = _castExpression(val.$cond.if, schema, strictQuery);\n      val.$cond.then = _castExpression(val.$cond.then, schema, strictQuery);\n      val.$cond.else = _castExpression(val.$cond.else, schema, strictQuery);\n    }\n  } else if (val.$ifNull != null) {\n    val.$ifNull.map(v => _castExpression(v, schema, strictQuery));\n  } else if (val.$switch != null) {\n    val.branches.map(v => _castExpression(v, schema, strictQuery));\n    val.default = _castExpression(val.default, schema, strictQuery);\n  }\n\n  const keys = Object.keys(val);\n  for (const key of keys) {\n    if (booleanComparison.has(key)) {\n      val[key] = val[key].map(v => _castExpression(v, schema, strictQuery));\n    } else if (comparisonOperator.has(key)) {\n      val[key] = castComparison(val[key], schema, strictQuery);\n    } else if (arithmeticOperatorArray.has(key)) {\n      val[key] = castArithmetic(val[key], schema, strictQuery);\n    } else if (arithmeticOperatorNumber.has(key)) {\n      val[key] = castNumberOperator(val[key], schema, strictQuery);\n    } else if (expressionOperator.has(key)) {\n      val[key] = _castExpression(val[key], schema, strictQuery);\n    }\n  }\n\n  if (val.$in) {\n    val.$in = castIn(val.$in, schema, strictQuery);\n  }\n  if (val.$size) {\n    val.$size = castNumberOperator(val.$size, schema, strictQuery);\n  }\n  if (val.$round) {\n    const $round = val.$round;\n    if (!Array.isArray($round) || $round.length < 1 || $round.length > 2) {\n      throw new CastError('Array', $round, '$round');\n    }\n    val.$round = $round.map(v => castNumberOperator(v, schema, strictQuery));\n  }\n\n  _omitUndefined(val);\n\n  return val;\n}\n\nfunction _omitUndefined(val) {\n  const keys = Object.keys(val);\n  for (let i = 0, len = keys.length; i < len; ++i) {\n    (val[keys[i]] === void 0) && delete val[keys[i]];\n  }\n}\n\n// { $op: <number> }\nfunction castNumberOperator(val) {\n  if (!isLiteral(val)) {\n    return val;\n  }\n\n  try {\n    return castNumber(val);\n  } catch (err) {\n    throw new CastError('Number', val);\n  }\n}\n\nfunction castIn(val, schema, strictQuery) {\n  const path = val[1];\n  if (!isPath(path)) {\n    return val;\n  }\n  const search = val[0];\n\n  const schematype = schema.path(path.slice(1));\n  if (schematype === null) {\n    if (strictQuery === false) {\n      return val;\n    } else if (strictQuery === 'throw') {\n      throw new StrictModeError('$in');\n    }\n\n    return void 0;\n  }\n\n  if (!schematype.$isMongooseArray) {\n    throw new Error('Path must be an array for $in');\n  }\n\n  return [\n    schematype.$isMongooseDocumentArray ? schematype.$embeddedSchemaType.cast(search) : schematype.caster.cast(search),\n    path\n  ];\n}\n\n// { $op: [<number>, <number>] }\nfunction castArithmetic(val) {\n  if (!Array.isArray(val)) {\n    if (!isLiteral(val)) {\n      return val;\n    }\n    try {\n      return castNumber(val);\n    } catch (err) {\n      throw new CastError('Number', val);\n    }\n  }\n\n  return val.map(v => {\n    if (!isLiteral(v)) {\n      return v;\n    }\n    try {\n      return castNumber(v);\n    } catch (err) {\n      throw new CastError('Number', v);\n    }\n  });\n}\n\n// { $op: [expression, expression] }\nfunction castComparison(val, schema, strictQuery) {\n  if (!Array.isArray(val) || val.length !== 2) {\n    throw new Error('Comparison operator must be an array of length 2');\n  }\n\n  val[0] = _castExpression(val[0], schema, strictQuery);\n  const lhs = val[0];\n\n  if (isLiteral(val[1])) {\n    let path = null;\n    let schematype = null;\n    let caster = null;\n    if (isPath(lhs)) {\n      path = lhs.slice(1);\n      schematype = schema.path(path);\n    } else if (typeof lhs === 'object' && lhs != null) {\n      for (const key of Object.keys(lhs)) {\n        if (dateOperators.has(key) && isPath(lhs[key])) {\n          path = lhs[key].slice(1) + '.' + key;\n          caster = castNumber;\n        } else if (arrayElementOperators.has(key) && isPath(lhs[key])) {\n          path = lhs[key].slice(1) + '.' + key;\n          schematype = schema.path(lhs[key].slice(1));\n          if (schematype != null) {\n            if (schematype.$isMongooseDocumentArray) {\n              schematype = schematype.$embeddedSchemaType;\n            } else if (schematype.$isMongooseArray) {\n              schematype = schematype.caster;\n            }\n          }\n        }\n      }\n    }\n\n    const is$literal = typeof val[1] === 'object' && val[1] != null && val[1].$literal != null;\n    if (schematype != null) {\n      if (is$literal) {\n        val[1] = { $literal: schematype.cast(val[1].$literal) };\n      } else {\n        val[1] = schematype.cast(val[1]);\n      }\n    } else if (caster != null) {\n      if (is$literal) {\n        try {\n          val[1] = { $literal: caster(val[1].$literal) };\n        } catch (err) {\n          throw new CastError(caster.name.replace(/^cast/, ''), val[1], path + '.$literal');\n        }\n      } else {\n        try {\n          val[1] = caster(val[1]);\n        } catch (err) {\n          throw new CastError(caster.name.replace(/^cast/, ''), val[1], path);\n        }\n      }\n    } else if (path != null && strictQuery === true) {\n      return void 0;\n    } else if (path != null && strictQuery === 'throw') {\n      throw new StrictModeError(path);\n    }\n  } else {\n    val[1] = _castExpression(val[1]);\n  }\n\n  return val;\n}\n\nfunction isPath(val) {\n  return typeof val === 'string' && val[0] === '$';\n}\n\nfunction isLiteral(val) {\n  if (typeof val === 'string' && val[0] === '$') {\n    return false;\n  }\n  if (typeof val === 'object' && val !== null && Object.keys(val).find(key => key[0] === '$')) {\n    // The `$literal` expression can make an object a literal\n    // https://www.mongodb.com/docs/manual/reference/operator/aggregation/literal/#mongodb-expression-exp.-literal\n    return val.$literal != null;\n  }\n  return true;\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbW9uZ29vc2UvbGliL2hlbHBlcnMvcXVlcnkvY2FzdCRleHByLmpzIiwibWFwcGluZ3MiOiJBQUFhOztBQUViLGtCQUFrQixtQkFBTyxDQUFDLHlFQUFrQjtBQUM1Qyx3QkFBd0IsbUJBQU8sQ0FBQyw2RUFBb0I7QUFDcEQsbUJBQW1CLG1CQUFPLENBQUMsMkVBQW1COztBQUU5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxxQ0FBcUMsU0FBUztBQUM5QztBQUNBO0FBQ0E7O0FBRUEsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUI7QUFDbkIsUUFBUTtBQUNSO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLHFCQUFxQjtBQUNyQixVQUFVO0FBQ1Y7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL2FwcDEvLi9ub2RlX21vZHVsZXMvbW9uZ29vc2UvbGliL2hlbHBlcnMvcXVlcnkvY2FzdCRleHByLmpzPzRmYjMiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG5jb25zdCBDYXN0RXJyb3IgPSByZXF1aXJlKCcuLi8uLi9lcnJvci9jYXN0Jyk7XG5jb25zdCBTdHJpY3RNb2RlRXJyb3IgPSByZXF1aXJlKCcuLi8uLi9lcnJvci9zdHJpY3QnKTtcbmNvbnN0IGNhc3ROdW1iZXIgPSByZXF1aXJlKCcuLi8uLi9jYXN0L251bWJlcicpO1xuXG5jb25zdCBib29sZWFuQ29tcGFyaXNvbiA9IG5ldyBTZXQoWyckYW5kJywgJyRvciddKTtcbmNvbnN0IGNvbXBhcmlzb25PcGVyYXRvciA9IG5ldyBTZXQoWyckY21wJywgJyRlcScsICckbHQnLCAnJGx0ZScsICckZ3QnLCAnJGd0ZSddKTtcbmNvbnN0IGFyaXRobWV0aWNPcGVyYXRvckFycmF5ID0gbmV3IFNldChbXG4gIC8vIGF2b2lkIGNhc3RpbmcgJyRhZGQnIG9yICckc3VidHJhY3QnLCBiZWNhdXNlIGV4cHJlc3Npb25zIGNhbiBiZSBlaXRoZXIgbnVtYmVyIG9yIGRhdGUsXG4gIC8vIGFuZCB3ZSBkb24ndCBoYXZlIGEgZ29vZCB3YXkgb2YgaW5mZXJyaW5nIHdoaWNoIGFyZ3VtZW50cyBzaG91bGQgYmUgbnVtYmVycyBhbmQgd2hpY2ggc2hvdWxkXG4gIC8vIGJlIGRhdGVzLlxuICAnJG11bHRpcGx5JyxcbiAgJyRkaXZpZGUnLFxuICAnJGxvZycsXG4gICckbW9kJyxcbiAgJyR0cnVuYycsXG4gICckYXZnJyxcbiAgJyRtYXgnLFxuICAnJG1pbicsXG4gICckc3RkRGV2UG9wJyxcbiAgJyRzdGREZXZTYW1wJyxcbiAgJyRzdW0nXG5dKTtcbmNvbnN0IGFyaXRobWV0aWNPcGVyYXRvck51bWJlciA9IG5ldyBTZXQoW1xuICAnJGFicycsXG4gICckZXhwJyxcbiAgJyRjZWlsJyxcbiAgJyRmbG9vcicsXG4gICckbG4nLFxuICAnJGxvZzEwJyxcbiAgJyRzcXJ0JyxcbiAgJyRzaW4nLFxuICAnJGNvcycsXG4gICckdGFuJyxcbiAgJyRhc2luJyxcbiAgJyRhY29zJyxcbiAgJyRhdGFuJyxcbiAgJyRhdGFuMicsXG4gICckYXNpbmgnLFxuICAnJGFjb3NoJyxcbiAgJyRhdGFuaCcsXG4gICckc2luaCcsXG4gICckY29zaCcsXG4gICckdGFuaCcsXG4gICckZGVncmVlc1RvUmFkaWFucycsXG4gICckcmFkaWFuc1RvRGVncmVlcydcbl0pO1xuY29uc3QgYXJyYXlFbGVtZW50T3BlcmF0b3JzID0gbmV3IFNldChbXG4gICckYXJyYXlFbGVtQXQnLFxuICAnJGZpcnN0JyxcbiAgJyRsYXN0J1xuXSk7XG5jb25zdCBkYXRlT3BlcmF0b3JzID0gbmV3IFNldChbXG4gICckeWVhcicsXG4gICckbW9udGgnLFxuICAnJHdlZWsnLFxuICAnJGRheU9mTW9udGgnLFxuICAnJGRheU9mWWVhcicsXG4gICckaG91cicsXG4gICckbWludXRlJyxcbiAgJyRzZWNvbmQnLFxuICAnJGlzb0RheU9mV2VlaycsXG4gICckaXNvV2Vla1llYXInLFxuICAnJGlzb1dlZWsnLFxuICAnJG1pbGxpc2Vjb25kJ1xuXSk7XG5jb25zdCBleHByZXNzaW9uT3BlcmF0b3IgPSBuZXcgU2V0KFsnJG5vdCddKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBjYXN0JGV4cHIodmFsLCBzY2hlbWEsIHN0cmljdFF1ZXJ5KSB7XG4gIGlmICh0eXBlb2YgdmFsICE9PSAnb2JqZWN0JyB8fCB2YWwgPT09IG51bGwpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ2AkZXhwcmAgbXVzdCBiZSBhbiBvYmplY3QnKTtcbiAgfVxuXG4gIHJldHVybiBfY2FzdEV4cHJlc3Npb24odmFsLCBzY2hlbWEsIHN0cmljdFF1ZXJ5KTtcbn07XG5cbmZ1bmN0aW9uIF9jYXN0RXhwcmVzc2lvbih2YWwsIHNjaGVtYSwgc3RyaWN0UXVlcnkpIHtcbiAgLy8gUHJlc2VydmUgdGhlIHZhbHVlIGlmIGl0IHJlcHJlc2VudHMgYSBwYXRoIG9yIGlmIGl0J3MgbnVsbFxuICBpZiAoaXNQYXRoKHZhbCkgfHwgdmFsID09PSBudWxsKSB7XG4gICAgcmV0dXJuIHZhbDtcbiAgfVxuXG4gIGlmICh2YWwuJGNvbmQgIT0gbnVsbCkge1xuICAgIGlmIChBcnJheS5pc0FycmF5KHZhbC4kY29uZCkpIHtcbiAgICAgIHZhbC4kY29uZCA9IHZhbC4kY29uZC5tYXAoZXhwciA9PiBfY2FzdEV4cHJlc3Npb24oZXhwciwgc2NoZW1hLCBzdHJpY3RRdWVyeSkpO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YWwuJGNvbmQuaWYgPSBfY2FzdEV4cHJlc3Npb24odmFsLiRjb25kLmlmLCBzY2hlbWEsIHN0cmljdFF1ZXJ5KTtcbiAgICAgIHZhbC4kY29uZC50aGVuID0gX2Nhc3RFeHByZXNzaW9uKHZhbC4kY29uZC50aGVuLCBzY2hlbWEsIHN0cmljdFF1ZXJ5KTtcbiAgICAgIHZhbC4kY29uZC5lbHNlID0gX2Nhc3RFeHByZXNzaW9uKHZhbC4kY29uZC5lbHNlLCBzY2hlbWEsIHN0cmljdFF1ZXJ5KTtcbiAgICB9XG4gIH0gZWxzZSBpZiAodmFsLiRpZk51bGwgIT0gbnVsbCkge1xuICAgIHZhbC4kaWZOdWxsLm1hcCh2ID0+IF9jYXN0RXhwcmVzc2lvbih2LCBzY2hlbWEsIHN0cmljdFF1ZXJ5KSk7XG4gIH0gZWxzZSBpZiAodmFsLiRzd2l0Y2ggIT0gbnVsbCkge1xuICAgIHZhbC5icmFuY2hlcy5tYXAodiA9PiBfY2FzdEV4cHJlc3Npb24odiwgc2NoZW1hLCBzdHJpY3RRdWVyeSkpO1xuICAgIHZhbC5kZWZhdWx0ID0gX2Nhc3RFeHByZXNzaW9uKHZhbC5kZWZhdWx0LCBzY2hlbWEsIHN0cmljdFF1ZXJ5KTtcbiAgfVxuXG4gIGNvbnN0IGtleXMgPSBPYmplY3Qua2V5cyh2YWwpO1xuICBmb3IgKGNvbnN0IGtleSBvZiBrZXlzKSB7XG4gICAgaWYgKGJvb2xlYW5Db21wYXJpc29uLmhhcyhrZXkpKSB7XG4gICAgICB2YWxba2V5XSA9IHZhbFtrZXldLm1hcCh2ID0+IF9jYXN0RXhwcmVzc2lvbih2LCBzY2hlbWEsIHN0cmljdFF1ZXJ5KSk7XG4gICAgfSBlbHNlIGlmIChjb21wYXJpc29uT3BlcmF0b3IuaGFzKGtleSkpIHtcbiAgICAgIHZhbFtrZXldID0gY2FzdENvbXBhcmlzb24odmFsW2tleV0sIHNjaGVtYSwgc3RyaWN0UXVlcnkpO1xuICAgIH0gZWxzZSBpZiAoYXJpdGhtZXRpY09wZXJhdG9yQXJyYXkuaGFzKGtleSkpIHtcbiAgICAgIHZhbFtrZXldID0gY2FzdEFyaXRobWV0aWModmFsW2tleV0sIHNjaGVtYSwgc3RyaWN0UXVlcnkpO1xuICAgIH0gZWxzZSBpZiAoYXJpdGhtZXRpY09wZXJhdG9yTnVtYmVyLmhhcyhrZXkpKSB7XG4gICAgICB2YWxba2V5XSA9IGNhc3ROdW1iZXJPcGVyYXRvcih2YWxba2V5XSwgc2NoZW1hLCBzdHJpY3RRdWVyeSk7XG4gICAgfSBlbHNlIGlmIChleHByZXNzaW9uT3BlcmF0b3IuaGFzKGtleSkpIHtcbiAgICAgIHZhbFtrZXldID0gX2Nhc3RFeHByZXNzaW9uKHZhbFtrZXldLCBzY2hlbWEsIHN0cmljdFF1ZXJ5KTtcbiAgICB9XG4gIH1cblxuICBpZiAodmFsLiRpbikge1xuICAgIHZhbC4kaW4gPSBjYXN0SW4odmFsLiRpbiwgc2NoZW1hLCBzdHJpY3RRdWVyeSk7XG4gIH1cbiAgaWYgKHZhbC4kc2l6ZSkge1xuICAgIHZhbC4kc2l6ZSA9IGNhc3ROdW1iZXJPcGVyYXRvcih2YWwuJHNpemUsIHNjaGVtYSwgc3RyaWN0UXVlcnkpO1xuICB9XG4gIGlmICh2YWwuJHJvdW5kKSB7XG4gICAgY29uc3QgJHJvdW5kID0gdmFsLiRyb3VuZDtcbiAgICBpZiAoIUFycmF5LmlzQXJyYXkoJHJvdW5kKSB8fCAkcm91bmQubGVuZ3RoIDwgMSB8fCAkcm91bmQubGVuZ3RoID4gMikge1xuICAgICAgdGhyb3cgbmV3IENhc3RFcnJvcignQXJyYXknLCAkcm91bmQsICckcm91bmQnKTtcbiAgICB9XG4gICAgdmFsLiRyb3VuZCA9ICRyb3VuZC5tYXAodiA9PiBjYXN0TnVtYmVyT3BlcmF0b3Iodiwgc2NoZW1hLCBzdHJpY3RRdWVyeSkpO1xuICB9XG5cbiAgX29taXRVbmRlZmluZWQodmFsKTtcblxuICByZXR1cm4gdmFsO1xufVxuXG5mdW5jdGlvbiBfb21pdFVuZGVmaW5lZCh2YWwpIHtcbiAgY29uc3Qga2V5cyA9IE9iamVjdC5rZXlzKHZhbCk7XG4gIGZvciAobGV0IGkgPSAwLCBsZW4gPSBrZXlzLmxlbmd0aDsgaSA8IGxlbjsgKytpKSB7XG4gICAgKHZhbFtrZXlzW2ldXSA9PT0gdm9pZCAwKSAmJiBkZWxldGUgdmFsW2tleXNbaV1dO1xuICB9XG59XG5cbi8vIHsgJG9wOiA8bnVtYmVyPiB9XG5mdW5jdGlvbiBjYXN0TnVtYmVyT3BlcmF0b3IodmFsKSB7XG4gIGlmICghaXNMaXRlcmFsKHZhbCkpIHtcbiAgICByZXR1cm4gdmFsO1xuICB9XG5cbiAgdHJ5IHtcbiAgICByZXR1cm4gY2FzdE51bWJlcih2YWwpO1xuICB9IGNhdGNoIChlcnIpIHtcbiAgICB0aHJvdyBuZXcgQ2FzdEVycm9yKCdOdW1iZXInLCB2YWwpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGNhc3RJbih2YWwsIHNjaGVtYSwgc3RyaWN0UXVlcnkpIHtcbiAgY29uc3QgcGF0aCA9IHZhbFsxXTtcbiAgaWYgKCFpc1BhdGgocGF0aCkpIHtcbiAgICByZXR1cm4gdmFsO1xuICB9XG4gIGNvbnN0IHNlYXJjaCA9IHZhbFswXTtcblxuICBjb25zdCBzY2hlbWF0eXBlID0gc2NoZW1hLnBhdGgocGF0aC5zbGljZSgxKSk7XG4gIGlmIChzY2hlbWF0eXBlID09PSBudWxsKSB7XG4gICAgaWYgKHN0cmljdFF1ZXJ5ID09PSBmYWxzZSkge1xuICAgICAgcmV0dXJuIHZhbDtcbiAgICB9IGVsc2UgaWYgKHN0cmljdFF1ZXJ5ID09PSAndGhyb3cnKSB7XG4gICAgICB0aHJvdyBuZXcgU3RyaWN0TW9kZUVycm9yKCckaW4nKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdm9pZCAwO1xuICB9XG5cbiAgaWYgKCFzY2hlbWF0eXBlLiRpc01vbmdvb3NlQXJyYXkpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1BhdGggbXVzdCBiZSBhbiBhcnJheSBmb3IgJGluJyk7XG4gIH1cblxuICByZXR1cm4gW1xuICAgIHNjaGVtYXR5cGUuJGlzTW9uZ29vc2VEb2N1bWVudEFycmF5ID8gc2NoZW1hdHlwZS4kZW1iZWRkZWRTY2hlbWFUeXBlLmNhc3Qoc2VhcmNoKSA6IHNjaGVtYXR5cGUuY2FzdGVyLmNhc3Qoc2VhcmNoKSxcbiAgICBwYXRoXG4gIF07XG59XG5cbi8vIHsgJG9wOiBbPG51bWJlcj4sIDxudW1iZXI+XSB9XG5mdW5jdGlvbiBjYXN0QXJpdGhtZXRpYyh2YWwpIHtcbiAgaWYgKCFBcnJheS5pc0FycmF5KHZhbCkpIHtcbiAgICBpZiAoIWlzTGl0ZXJhbCh2YWwpKSB7XG4gICAgICByZXR1cm4gdmFsO1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgcmV0dXJuIGNhc3ROdW1iZXIodmFsKTtcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIHRocm93IG5ldyBDYXN0RXJyb3IoJ051bWJlcicsIHZhbCk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHZhbC5tYXAodiA9PiB7XG4gICAgaWYgKCFpc0xpdGVyYWwodikpIHtcbiAgICAgIHJldHVybiB2O1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgcmV0dXJuIGNhc3ROdW1iZXIodik7XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICB0aHJvdyBuZXcgQ2FzdEVycm9yKCdOdW1iZXInLCB2KTtcbiAgICB9XG4gIH0pO1xufVxuXG4vLyB7ICRvcDogW2V4cHJlc3Npb24sIGV4cHJlc3Npb25dIH1cbmZ1bmN0aW9uIGNhc3RDb21wYXJpc29uKHZhbCwgc2NoZW1hLCBzdHJpY3RRdWVyeSkge1xuICBpZiAoIUFycmF5LmlzQXJyYXkodmFsKSB8fCB2YWwubGVuZ3RoICE9PSAyKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdDb21wYXJpc29uIG9wZXJhdG9yIG11c3QgYmUgYW4gYXJyYXkgb2YgbGVuZ3RoIDInKTtcbiAgfVxuXG4gIHZhbFswXSA9IF9jYXN0RXhwcmVzc2lvbih2YWxbMF0sIHNjaGVtYSwgc3RyaWN0UXVlcnkpO1xuICBjb25zdCBsaHMgPSB2YWxbMF07XG5cbiAgaWYgKGlzTGl0ZXJhbCh2YWxbMV0pKSB7XG4gICAgbGV0IHBhdGggPSBudWxsO1xuICAgIGxldCBzY2hlbWF0eXBlID0gbnVsbDtcbiAgICBsZXQgY2FzdGVyID0gbnVsbDtcbiAgICBpZiAoaXNQYXRoKGxocykpIHtcbiAgICAgIHBhdGggPSBsaHMuc2xpY2UoMSk7XG4gICAgICBzY2hlbWF0eXBlID0gc2NoZW1hLnBhdGgocGF0aCk7XG4gICAgfSBlbHNlIGlmICh0eXBlb2YgbGhzID09PSAnb2JqZWN0JyAmJiBsaHMgIT0gbnVsbCkge1xuICAgICAgZm9yIChjb25zdCBrZXkgb2YgT2JqZWN0LmtleXMobGhzKSkge1xuICAgICAgICBpZiAoZGF0ZU9wZXJhdG9ycy5oYXMoa2V5KSAmJiBpc1BhdGgobGhzW2tleV0pKSB7XG4gICAgICAgICAgcGF0aCA9IGxoc1trZXldLnNsaWNlKDEpICsgJy4nICsga2V5O1xuICAgICAgICAgIGNhc3RlciA9IGNhc3ROdW1iZXI7XG4gICAgICAgIH0gZWxzZSBpZiAoYXJyYXlFbGVtZW50T3BlcmF0b3JzLmhhcyhrZXkpICYmIGlzUGF0aChsaHNba2V5XSkpIHtcbiAgICAgICAgICBwYXRoID0gbGhzW2tleV0uc2xpY2UoMSkgKyAnLicgKyBrZXk7XG4gICAgICAgICAgc2NoZW1hdHlwZSA9IHNjaGVtYS5wYXRoKGxoc1trZXldLnNsaWNlKDEpKTtcbiAgICAgICAgICBpZiAoc2NoZW1hdHlwZSAhPSBudWxsKSB7XG4gICAgICAgICAgICBpZiAoc2NoZW1hdHlwZS4kaXNNb25nb29zZURvY3VtZW50QXJyYXkpIHtcbiAgICAgICAgICAgICAgc2NoZW1hdHlwZSA9IHNjaGVtYXR5cGUuJGVtYmVkZGVkU2NoZW1hVHlwZTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoc2NoZW1hdHlwZS4kaXNNb25nb29zZUFycmF5KSB7XG4gICAgICAgICAgICAgIHNjaGVtYXR5cGUgPSBzY2hlbWF0eXBlLmNhc3RlcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBjb25zdCBpcyRsaXRlcmFsID0gdHlwZW9mIHZhbFsxXSA9PT0gJ29iamVjdCcgJiYgdmFsWzFdICE9IG51bGwgJiYgdmFsWzFdLiRsaXRlcmFsICE9IG51bGw7XG4gICAgaWYgKHNjaGVtYXR5cGUgIT0gbnVsbCkge1xuICAgICAgaWYgKGlzJGxpdGVyYWwpIHtcbiAgICAgICAgdmFsWzFdID0geyAkbGl0ZXJhbDogc2NoZW1hdHlwZS5jYXN0KHZhbFsxXS4kbGl0ZXJhbCkgfTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhbFsxXSA9IHNjaGVtYXR5cGUuY2FzdCh2YWxbMV0pO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoY2FzdGVyICE9IG51bGwpIHtcbiAgICAgIGlmIChpcyRsaXRlcmFsKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgdmFsWzFdID0geyAkbGl0ZXJhbDogY2FzdGVyKHZhbFsxXS4kbGl0ZXJhbCkgfTtcbiAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IENhc3RFcnJvcihjYXN0ZXIubmFtZS5yZXBsYWNlKC9eY2FzdC8sICcnKSwgdmFsWzFdLCBwYXRoICsgJy4kbGl0ZXJhbCcpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIHZhbFsxXSA9IGNhc3Rlcih2YWxbMV0pO1xuICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgQ2FzdEVycm9yKGNhc3Rlci5uYW1lLnJlcGxhY2UoL15jYXN0LywgJycpLCB2YWxbMV0sIHBhdGgpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChwYXRoICE9IG51bGwgJiYgc3RyaWN0UXVlcnkgPT09IHRydWUpIHtcbiAgICAgIHJldHVybiB2b2lkIDA7XG4gICAgfSBlbHNlIGlmIChwYXRoICE9IG51bGwgJiYgc3RyaWN0UXVlcnkgPT09ICd0aHJvdycpIHtcbiAgICAgIHRocm93IG5ldyBTdHJpY3RNb2RlRXJyb3IocGF0aCk7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHZhbFsxXSA9IF9jYXN0RXhwcmVzc2lvbih2YWxbMV0pO1xuICB9XG5cbiAgcmV0dXJuIHZhbDtcbn1cblxuZnVuY3Rpb24gaXNQYXRoKHZhbCkge1xuICByZXR1cm4gdHlwZW9mIHZhbCA9PT0gJ3N0cmluZycgJiYgdmFsWzBdID09PSAnJCc7XG59XG5cbmZ1bmN0aW9uIGlzTGl0ZXJhbCh2YWwpIHtcbiAgaWYgKHR5cGVvZiB2YWwgPT09ICdzdHJpbmcnICYmIHZhbFswXSA9PT0gJyQnKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGlmICh0eXBlb2YgdmFsID09PSAnb2JqZWN0JyAmJiB2YWwgIT09IG51bGwgJiYgT2JqZWN0LmtleXModmFsKS5maW5kKGtleSA9PiBrZXlbMF0gPT09ICckJykpIHtcbiAgICAvLyBUaGUgYCRsaXRlcmFsYCBleHByZXNzaW9uIGNhbiBtYWtlIGFuIG9iamVjdCBhIGxpdGVyYWxcbiAgICAvLyBodHRwczovL3d3dy5tb25nb2RiLmNvbS9kb2NzL21hbnVhbC9yZWZlcmVuY2Uvb3BlcmF0b3IvYWdncmVnYXRpb24vbGl0ZXJhbC8jbW9uZ29kYi1leHByZXNzaW9uLWV4cC4tbGl0ZXJhbFxuICAgIHJldHVybiB2YWwuJGxpdGVyYWwgIT0gbnVsbDtcbiAgfVxuICByZXR1cm4gdHJ1ZTtcbn1cbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/mongoose/lib/helpers/query/cast$expr.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/mongoose/lib/helpers/query/castFilterPath.js":
/*!*******************************************************************!*\
  !*** ./node_modules/mongoose/lib/helpers/query/castFilterPath.js ***!
  \*******************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\n\nconst isOperator = __webpack_require__(/*! ./isOperator */ \"(ssr)/./node_modules/mongoose/lib/helpers/query/isOperator.js\");\n\nmodule.exports = function castFilterPath(query, schematype, val) {\n  const ctx = query;\n  const any$conditionals = Object.keys(val).some(isOperator);\n\n  if (!any$conditionals) {\n    return schematype.castForQuery(\n      null,\n      val,\n      ctx\n    );\n  }\n\n  const ks = Object.keys(val);\n\n  let k = ks.length;\n\n  while (k--) {\n    const $cond = ks[k];\n    const nested = val[$cond];\n\n    if ($cond === '$not') {\n      if (nested && schematype && !schematype.caster) {\n        const _keys = Object.keys(nested);\n        if (_keys.length && isOperator(_keys[0])) {\n          for (const key of Object.keys(nested)) {\n            nested[key] = schematype.castForQuery(\n              key,\n              nested[key],\n              ctx\n            );\n          }\n        } else {\n          val[$cond] = schematype.castForQuery(\n            $cond,\n            nested,\n            ctx\n          );\n        }\n        continue;\n      }\n    } else {\n      val[$cond] = schematype.castForQuery(\n        $cond,\n        nested,\n        ctx\n      );\n    }\n  }\n\n  return val;\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbW9uZ29vc2UvbGliL2hlbHBlcnMvcXVlcnkvY2FzdEZpbHRlclBhdGguanMiLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWIsbUJBQW1CLG1CQUFPLENBQUMsbUZBQWM7O0FBRXpDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9hcHAxLy4vbm9kZV9tb2R1bGVzL21vbmdvb3NlL2xpYi9oZWxwZXJzL3F1ZXJ5L2Nhc3RGaWx0ZXJQYXRoLmpzPzE4MGIiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG5jb25zdCBpc09wZXJhdG9yID0gcmVxdWlyZSgnLi9pc09wZXJhdG9yJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gY2FzdEZpbHRlclBhdGgocXVlcnksIHNjaGVtYXR5cGUsIHZhbCkge1xuICBjb25zdCBjdHggPSBxdWVyeTtcbiAgY29uc3QgYW55JGNvbmRpdGlvbmFscyA9IE9iamVjdC5rZXlzKHZhbCkuc29tZShpc09wZXJhdG9yKTtcblxuICBpZiAoIWFueSRjb25kaXRpb25hbHMpIHtcbiAgICByZXR1cm4gc2NoZW1hdHlwZS5jYXN0Rm9yUXVlcnkoXG4gICAgICBudWxsLFxuICAgICAgdmFsLFxuICAgICAgY3R4XG4gICAgKTtcbiAgfVxuXG4gIGNvbnN0IGtzID0gT2JqZWN0LmtleXModmFsKTtcblxuICBsZXQgayA9IGtzLmxlbmd0aDtcblxuICB3aGlsZSAoay0tKSB7XG4gICAgY29uc3QgJGNvbmQgPSBrc1trXTtcbiAgICBjb25zdCBuZXN0ZWQgPSB2YWxbJGNvbmRdO1xuXG4gICAgaWYgKCRjb25kID09PSAnJG5vdCcpIHtcbiAgICAgIGlmIChuZXN0ZWQgJiYgc2NoZW1hdHlwZSAmJiAhc2NoZW1hdHlwZS5jYXN0ZXIpIHtcbiAgICAgICAgY29uc3QgX2tleXMgPSBPYmplY3Qua2V5cyhuZXN0ZWQpO1xuICAgICAgICBpZiAoX2tleXMubGVuZ3RoICYmIGlzT3BlcmF0b3IoX2tleXNbMF0pKSB7XG4gICAgICAgICAgZm9yIChjb25zdCBrZXkgb2YgT2JqZWN0LmtleXMobmVzdGVkKSkge1xuICAgICAgICAgICAgbmVzdGVkW2tleV0gPSBzY2hlbWF0eXBlLmNhc3RGb3JRdWVyeShcbiAgICAgICAgICAgICAga2V5LFxuICAgICAgICAgICAgICBuZXN0ZWRba2V5XSxcbiAgICAgICAgICAgICAgY3R4XG4gICAgICAgICAgICApO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB2YWxbJGNvbmRdID0gc2NoZW1hdHlwZS5jYXN0Rm9yUXVlcnkoXG4gICAgICAgICAgICAkY29uZCxcbiAgICAgICAgICAgIG5lc3RlZCxcbiAgICAgICAgICAgIGN0eFxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhbFskY29uZF0gPSBzY2hlbWF0eXBlLmNhc3RGb3JRdWVyeShcbiAgICAgICAgJGNvbmQsXG4gICAgICAgIG5lc3RlZCxcbiAgICAgICAgY3R4XG4gICAgICApO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiB2YWw7XG59O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/mongoose/lib/helpers/query/castFilterPath.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/mongoose/lib/helpers/query/castUpdate.js":
/*!***************************************************************!*\
  !*** ./node_modules/mongoose/lib/helpers/query/castUpdate.js ***!
  \***************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\n\nconst CastError = __webpack_require__(/*! ../../error/cast */ \"(ssr)/./node_modules/mongoose/lib/error/cast.js\");\nconst MongooseError = __webpack_require__(/*! ../../error/mongooseError */ \"(ssr)/./node_modules/mongoose/lib/error/mongooseError.js\");\nconst StrictModeError = __webpack_require__(/*! ../../error/strict */ \"(ssr)/./node_modules/mongoose/lib/error/strict.js\");\nconst ValidationError = __webpack_require__(/*! ../../error/validation */ \"(ssr)/./node_modules/mongoose/lib/error/validation.js\");\nconst castNumber = __webpack_require__(/*! ../../cast/number */ \"(ssr)/./node_modules/mongoose/lib/cast/number.js\");\nconst cast = __webpack_require__(/*! ../../cast */ \"(ssr)/./node_modules/mongoose/lib/cast.js\");\nconst getConstructorName = __webpack_require__(/*! ../getConstructorName */ \"(ssr)/./node_modules/mongoose/lib/helpers/getConstructorName.js\");\nconst getEmbeddedDiscriminatorPath = __webpack_require__(/*! ./getEmbeddedDiscriminatorPath */ \"(ssr)/./node_modules/mongoose/lib/helpers/query/getEmbeddedDiscriminatorPath.js\");\nconst handleImmutable = __webpack_require__(/*! ./handleImmutable */ \"(ssr)/./node_modules/mongoose/lib/helpers/query/handleImmutable.js\");\nconst moveImmutableProperties = __webpack_require__(/*! ../update/moveImmutableProperties */ \"(ssr)/./node_modules/mongoose/lib/helpers/update/moveImmutableProperties.js\");\nconst schemaMixedSymbol = (__webpack_require__(/*! ../../schema/symbols */ \"(ssr)/./node_modules/mongoose/lib/schema/symbols.js\").schemaMixedSymbol);\nconst setDottedPath = __webpack_require__(/*! ../path/setDottedPath */ \"(ssr)/./node_modules/mongoose/lib/helpers/path/setDottedPath.js\");\nconst utils = __webpack_require__(/*! ../../utils */ \"(ssr)/./node_modules/mongoose/lib/utils.js\");\n\nconst mongodbUpdateOperators = new Set([\n  '$currentDate',\n  '$inc',\n  '$min',\n  '$max',\n  '$mul',\n  '$rename',\n  '$set',\n  '$setOnInsert',\n  '$unset',\n  '$addToSet',\n  '$pop',\n  '$pull',\n  '$push',\n  '$pullAll',\n  '$bit'\n]);\n\n/**\n * Casts an update op based on the given schema\n *\n * @param {Schema} schema\n * @param {Object} obj\n * @param {Object} [options]\n * @param {Boolean|String} [options.strict] defaults to true\n * @param {Query} context passed to setters\n * @return {Boolean} true iff the update is non-empty\n * @api private\n */\nmodule.exports = function castUpdate(schema, obj, options, context, filter) {\n  if (obj == null) {\n    return undefined;\n  }\n  options = options || {};\n  // Update pipeline\n  if (Array.isArray(obj)) {\n    const len = obj.length;\n    for (let i = 0; i < len; ++i) {\n      const ops = Object.keys(obj[i]);\n      for (const op of ops) {\n        obj[i][op] = castPipelineOperator(op, obj[i][op]);\n      }\n    }\n    return obj;\n  }\n\n  if (options.upsert) {\n    moveImmutableProperties(schema, obj, context);\n  }\n\n  const ops = Object.keys(obj);\n  let i = ops.length;\n  const ret = {};\n  let val;\n  let hasDollarKey = false;\n\n  filter = filter || {};\n  while (i--) {\n    const op = ops[i];\n    if (!mongodbUpdateOperators.has(op)) {\n      // fix up $set sugar\n      if (!ret.$set) {\n        if (obj.$set) {\n          ret.$set = obj.$set;\n        } else {\n          ret.$set = {};\n        }\n      }\n      ret.$set[op] = obj[op];\n      ops.splice(i, 1);\n      if (!~ops.indexOf('$set')) ops.push('$set');\n    } else if (op === '$set') {\n      if (!ret.$set) {\n        ret[op] = obj[op];\n      }\n    } else {\n      ret[op] = obj[op];\n    }\n  }\n  // cast each value\n  i = ops.length;\n  while (i--) {\n    const op = ops[i];\n    val = ret[op];\n    hasDollarKey = hasDollarKey || op.startsWith('$');\n\n    if (val &&\n        typeof val === 'object' &&\n        !Buffer.isBuffer(val) &&\n        mongodbUpdateOperators.has(op)) {\n      walkUpdatePath(schema, val, op, options, context, filter);\n    } else {\n      const msg = 'Invalid atomic update value for ' + op + '. '\n          + 'Expected an object, received ' + typeof val;\n      throw new Error(msg);\n    }\n\n    if (op.startsWith('$') && utils.isEmptyObject(val)) {\n      delete ret[op];\n    }\n  }\n\n  if (Object.keys(ret).length === 0 &&\n      options.upsert &&\n      Object.keys(filter).length > 0) {\n    // Trick the driver into allowing empty upserts to work around\n    // https://github.com/mongodb/node-mongodb-native/pull/2490\n    // Shallow clone to avoid passing defaults in re: gh-13962\n    return { $setOnInsert: { ...filter } };\n  }\n  return ret;\n};\n\n/*!\n * ignore\n */\n\nfunction castPipelineOperator(op, val) {\n  if (op === '$unset') {\n    if (typeof val !== 'string' && (!Array.isArray(val) || val.find(v => typeof v !== 'string'))) {\n      throw new MongooseError('Invalid $unset in pipeline, must be ' +\n        ' a string or an array of strings');\n    }\n    return val;\n  }\n  if (op === '$project') {\n    if (val == null || typeof val !== 'object') {\n      throw new MongooseError('Invalid $project in pipeline, must be an object');\n    }\n    return val;\n  }\n  if (op === '$addFields' || op === '$set') {\n    if (val == null || typeof val !== 'object') {\n      throw new MongooseError('Invalid ' + op + ' in pipeline, must be an object');\n    }\n    return val;\n  } else if (op === '$replaceRoot' || op === '$replaceWith') {\n    if (val == null || typeof val !== 'object') {\n      throw new MongooseError('Invalid ' + op + ' in pipeline, must be an object');\n    }\n    return val;\n  }\n\n  throw new MongooseError('Invalid update pipeline operator: \"' + op + '\"');\n}\n\n/**\n * Walk each path of obj and cast its values\n * according to its schema.\n *\n * @param {Schema} schema\n * @param {Object} obj part of a query\n * @param {String} op the atomic operator ($pull, $set, etc)\n * @param {Object} [options]\n * @param {Boolean|String} [options.strict]\n * @param {Query} context\n * @param {Object} filter\n * @param {String} pref path prefix (internal only)\n * @return {Bool} true if this path has keys to update\n * @api private\n */\n\nfunction walkUpdatePath(schema, obj, op, options, context, filter, pref) {\n  const strict = options.strict;\n  const prefix = pref ? pref + '.' : '';\n  const keys = Object.keys(obj);\n  let i = keys.length;\n  let hasKeys = false;\n  let schematype;\n  let key;\n  let val;\n\n  let aggregatedError = null;\n\n  const strictMode = strict != null ? strict : schema.options.strict;\n\n  while (i--) {\n    key = keys[i];\n    val = obj[key];\n\n    // `$pull` is special because we need to cast the RHS as a query, not as\n    // an update.\n    if (op === '$pull') {\n      schematype = schema._getSchema(prefix + key);\n      if (schematype != null && schematype.schema != null) {\n        obj[key] = cast(schematype.schema, obj[key], options, context);\n        hasKeys = true;\n        continue;\n      }\n    }\n\n    const discriminatorKey = (prefix ? prefix + key : key);\n    if (\n      schema.discriminatorMapping != null &&\n      discriminatorKey === schema.options.discriminatorKey &&\n      schema.discriminatorMapping.value !== obj[key] &&\n      !options.overwriteDiscriminatorKey\n    ) {\n      if (strictMode === 'throw') {\n        const err = new Error('Can\\'t modify discriminator key \"' + discriminatorKey + '\" on discriminator model');\n        aggregatedError = _appendError(err, context, discriminatorKey, aggregatedError);\n        continue;\n      } else if (strictMode) {\n        delete obj[key];\n        continue;\n      }\n    }\n\n    if (getConstructorName(val) === 'Object') {\n      // watch for embedded doc schemas\n      schematype = schema._getSchema(prefix + key);\n\n      if (schematype == null) {\n        const _res = getEmbeddedDiscriminatorPath(schema, obj, filter, prefix + key, options);\n        if (_res.schematype != null) {\n          schematype = _res.schematype;\n        }\n      }\n\n      if (op !== '$setOnInsert' &&\n          handleImmutable(schematype, strict, obj, key, prefix + key, context)) {\n        continue;\n      }\n\n      if (schematype && schematype.caster && op in castOps) {\n        // embedded doc schema\n        if ('$each' in val) {\n          hasKeys = true;\n          try {\n            obj[key] = {\n              $each: castUpdateVal(schematype, val.$each, op, key, context, prefix + key)\n            };\n          } catch (error) {\n            aggregatedError = _appendError(error, context, key, aggregatedError);\n          }\n\n          if (val.$slice != null) {\n            obj[key].$slice = val.$slice | 0;\n          }\n\n          if (val.$sort) {\n            obj[key].$sort = val.$sort;\n          }\n\n          if (val.$position != null) {\n            obj[key].$position = castNumber(val.$position);\n          }\n        } else {\n          if (schematype != null && schematype.$isSingleNested) {\n            const _strict = strict == null ? schematype.schema.options.strict : strict;\n            try {\n              obj[key] = schematype.castForQuery(null, val, context, { strict: _strict });\n            } catch (error) {\n              aggregatedError = _appendError(error, context, key, aggregatedError);\n            }\n          } else {\n            try {\n              obj[key] = castUpdateVal(schematype, val, op, key, context, prefix + key);\n            } catch (error) {\n              aggregatedError = _appendError(error, context, key, aggregatedError);\n            }\n          }\n\n          if (obj[key] === void 0) {\n            delete obj[key];\n            continue;\n          }\n\n          hasKeys = true;\n        }\n      } else if ((op === '$currentDate') || (op in castOps && schematype)) {\n        // $currentDate can take an object\n        try {\n          obj[key] = castUpdateVal(schematype, val, op, key, context, prefix + key);\n        } catch (error) {\n          aggregatedError = _appendError(error, context, key, aggregatedError);\n        }\n\n        if (obj[key] === void 0) {\n          delete obj[key];\n          continue;\n        }\n\n        hasKeys = true;\n      } else {\n        const pathToCheck = (prefix + key);\n        const v = schema._getPathType(pathToCheck);\n        let _strict = strict;\n        if (v && v.schema && _strict == null) {\n          _strict = v.schema.options.strict;\n        }\n\n        if (v.pathType === 'undefined') {\n          if (_strict === 'throw') {\n            throw new StrictModeError(pathToCheck);\n          } else if (_strict) {\n            delete obj[key];\n            continue;\n          }\n        }\n\n        // gh-2314\n        // we should be able to set a schema-less field\n        // to an empty object literal\n        hasKeys |= walkUpdatePath(schema, val, op, options, context, filter, prefix + key) ||\n          (utils.isObject(val) && Object.keys(val).length === 0);\n      }\n    } else {\n      const checkPath = (key === '$each' || key === '$or' || key === '$and' || key === '$in') ?\n        pref : prefix + key;\n      schematype = schema._getSchema(checkPath);\n\n      // You can use `$setOnInsert` with immutable keys\n      if (op !== '$setOnInsert' &&\n          handleImmutable(schematype, strict, obj, key, prefix + key, context)) {\n        continue;\n      }\n\n      let pathDetails = schema._getPathType(checkPath);\n\n      // If no schema type, check for embedded discriminators because the\n      // filter or update may imply an embedded discriminator type. See #8378\n      if (schematype == null) {\n        const _res = getEmbeddedDiscriminatorPath(schema, obj, filter, checkPath, options);\n        if (_res.schematype != null) {\n          schematype = _res.schematype;\n          pathDetails = _res.type;\n        }\n      }\n\n      let isStrict = strict;\n      if (pathDetails && pathDetails.schema && strict == null) {\n        isStrict = pathDetails.schema.options.strict;\n      }\n\n      const skip = isStrict &&\n        !schematype &&\n        !/real|nested/.test(pathDetails.pathType);\n\n      if (skip) {\n        // Even if strict is `throw`, avoid throwing an error because of\n        // virtuals because of #6731\n        if (isStrict === 'throw' && schema.virtuals[checkPath] == null) {\n          throw new StrictModeError(prefix + key);\n        } else {\n          delete obj[key];\n        }\n      } else {\n        // gh-1845 temporary fix: ignore $rename. See gh-3027 for tracking\n        // improving this.\n        if (op === '$rename') {\n          hasKeys = true;\n          continue;\n        }\n\n        try {\n          if (prefix.length === 0 || key.indexOf('.') === -1) {\n            obj[key] = castUpdateVal(schematype, val, op, key, context, prefix + key);\n          } else if (isStrict !== false || schematype != null) {\n            // Setting a nested dotted path that's in the schema. We don't allow paths with '.' in\n            // a schema, so replace the dotted path with a nested object to avoid ending up with\n            // dotted properties in the updated object. See (gh-10200)\n            setDottedPath(obj, key, castUpdateVal(schematype, val, op, key, context, prefix + key));\n            delete obj[key];\n          }\n        } catch (error) {\n          aggregatedError = _appendError(error, context, key, aggregatedError);\n        }\n\n        if (Array.isArray(obj[key]) && (op === '$addToSet' || op === '$push') && key !== '$each') {\n          if (schematype &&\n              schematype.caster &&\n              !schematype.caster.$isMongooseArray &&\n              !schematype.caster[schemaMixedSymbol]) {\n            obj[key] = { $each: obj[key] };\n          }\n        }\n\n        if (obj[key] === void 0) {\n          delete obj[key];\n          continue;\n        }\n\n        hasKeys = true;\n      }\n    }\n  }\n\n  if (aggregatedError != null) {\n    throw aggregatedError;\n  }\n\n  return hasKeys;\n}\n\n/*!\n * ignore\n */\n\nfunction _appendError(error, query, key, aggregatedError) {\n  if (typeof query !== 'object' || !query.options.multipleCastError) {\n    throw error;\n  }\n  aggregatedError = aggregatedError || new ValidationError();\n  aggregatedError.addError(key, error);\n  return aggregatedError;\n}\n\n/**\n * These operators should be cast to numbers instead\n * of their path schema type.\n * @api private\n */\n\nconst numberOps = {\n  $pop: 1,\n  $inc: 1\n};\n\n/**\n * These ops require no casting because the RHS doesn't do anything.\n * @api private\n */\n\nconst noCastOps = {\n  $unset: 1\n};\n\n/**\n * These operators require casting docs\n * to real Documents for Update operations.\n * @api private\n */\n\nconst castOps = {\n  $push: 1,\n  $addToSet: 1,\n  $set: 1,\n  $setOnInsert: 1\n};\n\n/*!\n * ignore\n */\n\nconst overwriteOps = {\n  $set: 1,\n  $setOnInsert: 1\n};\n\n/**\n * Casts `val` according to `schema` and atomic `op`.\n *\n * @param {SchemaType} schema\n * @param {Object} val\n * @param {String} op the atomic operator ($pull, $set, etc)\n * @param {String} $conditional\n * @param {Query} context\n * @param {String} path\n * @api private\n */\n\nfunction castUpdateVal(schema, val, op, $conditional, context, path) {\n  if (!schema) {\n    // non-existing schema path\n    if (op in numberOps) {\n      try {\n        return castNumber(val);\n      } catch (err) {\n        throw new CastError('number', val, path);\n      }\n    }\n    return val;\n  }\n\n  // console.log('CastUpdateVal', path, op, val, schema);\n\n  const cond = schema.caster && op in castOps &&\n      (utils.isObject(val) || Array.isArray(val));\n  if (cond && !overwriteOps[op]) {\n    // Cast values for ops that add data to MongoDB.\n    // Ensures embedded documents get ObjectIds etc.\n    let schemaArrayDepth = 0;\n    let cur = schema;\n    while (cur.$isMongooseArray) {\n      ++schemaArrayDepth;\n      cur = cur.caster;\n    }\n    let arrayDepth = 0;\n    let _val = val;\n    while (Array.isArray(_val)) {\n      ++arrayDepth;\n      _val = _val[0];\n    }\n\n    const additionalNesting = schemaArrayDepth - arrayDepth;\n    while (arrayDepth < schemaArrayDepth) {\n      val = [val];\n      ++arrayDepth;\n    }\n\n    let tmp = schema.applySetters(Array.isArray(val) ? val : [val], context);\n\n    for (let i = 0; i < additionalNesting; ++i) {\n      tmp = tmp[0];\n    }\n    return tmp;\n  }\n\n  if (op in noCastOps) {\n    return val;\n  }\n  if (op in numberOps) {\n    // Null and undefined not allowed for $pop, $inc\n    if (val == null) {\n      throw new CastError('number', val, schema.path);\n    }\n    if (op === '$inc') {\n      // Support `$inc` with long, int32, etc. (gh-4283)\n      return schema.castForQuery(\n        null,\n        val,\n        context\n      );\n    }\n    try {\n      return castNumber(val);\n    } catch (error) {\n      throw new CastError('number', val, schema.path);\n    }\n  }\n  if (op === '$currentDate') {\n    if (typeof val === 'object') {\n      return { $type: val.$type };\n    }\n    return Boolean(val);\n  }\n\n  if (mongodbUpdateOperators.has($conditional)) {\n    return schema.castForQuery(\n      $conditional,\n      val,\n      context\n    );\n  }\n\n  if (overwriteOps[op]) {\n    const skipQueryCastForUpdate = val != null && schema.$isMongooseArray && schema.$fullPath != null && !schema.$fullPath.match(/\\d+$/);\n    const applySetters = schema[schemaMixedSymbol] != null;\n    if (skipQueryCastForUpdate || applySetters) {\n      return schema.applySetters(val, context);\n    }\n    return schema.castForQuery(\n      null,\n      val,\n      context\n    );\n  }\n\n  return schema.castForQuery(null, val, context);\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbW9uZ29vc2UvbGliL2hlbHBlcnMvcXVlcnkvY2FzdFVwZGF0ZS5qcyIsIm1hcHBpbmdzIjoiQUFBYTs7QUFFYixrQkFBa0IsbUJBQU8sQ0FBQyx5RUFBa0I7QUFDNUMsc0JBQXNCLG1CQUFPLENBQUMsMkZBQTJCO0FBQ3pELHdCQUF3QixtQkFBTyxDQUFDLDZFQUFvQjtBQUNwRCx3QkFBd0IsbUJBQU8sQ0FBQyxxRkFBd0I7QUFDeEQsbUJBQW1CLG1CQUFPLENBQUMsMkVBQW1CO0FBQzlDLGFBQWEsbUJBQU8sQ0FBQyw2REFBWTtBQUNqQywyQkFBMkIsbUJBQU8sQ0FBQyw4RkFBdUI7QUFDMUQscUNBQXFDLG1CQUFPLENBQUMsdUhBQWdDO0FBQzdFLHdCQUF3QixtQkFBTyxDQUFDLDZGQUFtQjtBQUNuRCxnQ0FBZ0MsbUJBQU8sQ0FBQyxzSEFBbUM7QUFDM0UsMEJBQTBCLDBIQUFpRDtBQUMzRSxzQkFBc0IsbUJBQU8sQ0FBQyw4RkFBdUI7QUFDckQsY0FBYyxtQkFBTyxDQUFDLCtEQUFhOztBQUVuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsZ0JBQWdCO0FBQzNCLFdBQVcsT0FBTztBQUNsQixZQUFZLFNBQVM7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsU0FBUztBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxnQkFBZ0I7QUFDN0I7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsV0FBVyxnQkFBZ0I7QUFDM0IsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsWUFBWSxNQUFNO0FBQ2xCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBLHVFQUF1RSxpQkFBaUI7QUFDeEYsY0FBYztBQUNkO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxZQUFZO0FBQ3ZCLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsT0FBTztBQUNsQixXQUFXLFFBQVE7QUFDbkI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsb0JBQW9CLHVCQUF1QjtBQUMzQztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9hcHAxLy4vbm9kZV9tb2R1bGVzL21vbmdvb3NlL2xpYi9oZWxwZXJzL3F1ZXJ5L2Nhc3RVcGRhdGUuanM/ZThhMCJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbmNvbnN0IENhc3RFcnJvciA9IHJlcXVpcmUoJy4uLy4uL2Vycm9yL2Nhc3QnKTtcbmNvbnN0IE1vbmdvb3NlRXJyb3IgPSByZXF1aXJlKCcuLi8uLi9lcnJvci9tb25nb29zZUVycm9yJyk7XG5jb25zdCBTdHJpY3RNb2RlRXJyb3IgPSByZXF1aXJlKCcuLi8uLi9lcnJvci9zdHJpY3QnKTtcbmNvbnN0IFZhbGlkYXRpb25FcnJvciA9IHJlcXVpcmUoJy4uLy4uL2Vycm9yL3ZhbGlkYXRpb24nKTtcbmNvbnN0IGNhc3ROdW1iZXIgPSByZXF1aXJlKCcuLi8uLi9jYXN0L251bWJlcicpO1xuY29uc3QgY2FzdCA9IHJlcXVpcmUoJy4uLy4uL2Nhc3QnKTtcbmNvbnN0IGdldENvbnN0cnVjdG9yTmFtZSA9IHJlcXVpcmUoJy4uL2dldENvbnN0cnVjdG9yTmFtZScpO1xuY29uc3QgZ2V0RW1iZWRkZWREaXNjcmltaW5hdG9yUGF0aCA9IHJlcXVpcmUoJy4vZ2V0RW1iZWRkZWREaXNjcmltaW5hdG9yUGF0aCcpO1xuY29uc3QgaGFuZGxlSW1tdXRhYmxlID0gcmVxdWlyZSgnLi9oYW5kbGVJbW11dGFibGUnKTtcbmNvbnN0IG1vdmVJbW11dGFibGVQcm9wZXJ0aWVzID0gcmVxdWlyZSgnLi4vdXBkYXRlL21vdmVJbW11dGFibGVQcm9wZXJ0aWVzJyk7XG5jb25zdCBzY2hlbWFNaXhlZFN5bWJvbCA9IHJlcXVpcmUoJy4uLy4uL3NjaGVtYS9zeW1ib2xzJykuc2NoZW1hTWl4ZWRTeW1ib2w7XG5jb25zdCBzZXREb3R0ZWRQYXRoID0gcmVxdWlyZSgnLi4vcGF0aC9zZXREb3R0ZWRQYXRoJyk7XG5jb25zdCB1dGlscyA9IHJlcXVpcmUoJy4uLy4uL3V0aWxzJyk7XG5cbmNvbnN0IG1vbmdvZGJVcGRhdGVPcGVyYXRvcnMgPSBuZXcgU2V0KFtcbiAgJyRjdXJyZW50RGF0ZScsXG4gICckaW5jJyxcbiAgJyRtaW4nLFxuICAnJG1heCcsXG4gICckbXVsJyxcbiAgJyRyZW5hbWUnLFxuICAnJHNldCcsXG4gICckc2V0T25JbnNlcnQnLFxuICAnJHVuc2V0JyxcbiAgJyRhZGRUb1NldCcsXG4gICckcG9wJyxcbiAgJyRwdWxsJyxcbiAgJyRwdXNoJyxcbiAgJyRwdWxsQWxsJyxcbiAgJyRiaXQnXG5dKTtcblxuLyoqXG4gKiBDYXN0cyBhbiB1cGRhdGUgb3AgYmFzZWQgb24gdGhlIGdpdmVuIHNjaGVtYVxuICpcbiAqIEBwYXJhbSB7U2NoZW1hfSBzY2hlbWFcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmpcbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc11cbiAqIEBwYXJhbSB7Qm9vbGVhbnxTdHJpbmd9IFtvcHRpb25zLnN0cmljdF0gZGVmYXVsdHMgdG8gdHJ1ZVxuICogQHBhcmFtIHtRdWVyeX0gY29udGV4dCBwYXNzZWQgdG8gc2V0dGVyc1xuICogQHJldHVybiB7Qm9vbGVhbn0gdHJ1ZSBpZmYgdGhlIHVwZGF0ZSBpcyBub24tZW1wdHlcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGNhc3RVcGRhdGUoc2NoZW1hLCBvYmosIG9wdGlvbnMsIGNvbnRleHQsIGZpbHRlcikge1xuICBpZiAob2JqID09IG51bGwpIHtcbiAgICByZXR1cm4gdW5kZWZpbmVkO1xuICB9XG4gIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICAvLyBVcGRhdGUgcGlwZWxpbmVcbiAgaWYgKEFycmF5LmlzQXJyYXkob2JqKSkge1xuICAgIGNvbnN0IGxlbiA9IG9iai5sZW5ndGg7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZW47ICsraSkge1xuICAgICAgY29uc3Qgb3BzID0gT2JqZWN0LmtleXMob2JqW2ldKTtcbiAgICAgIGZvciAoY29uc3Qgb3Agb2Ygb3BzKSB7XG4gICAgICAgIG9ialtpXVtvcF0gPSBjYXN0UGlwZWxpbmVPcGVyYXRvcihvcCwgb2JqW2ldW29wXSk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBvYmo7XG4gIH1cblxuICBpZiAob3B0aW9ucy51cHNlcnQpIHtcbiAgICBtb3ZlSW1tdXRhYmxlUHJvcGVydGllcyhzY2hlbWEsIG9iaiwgY29udGV4dCk7XG4gIH1cblxuICBjb25zdCBvcHMgPSBPYmplY3Qua2V5cyhvYmopO1xuICBsZXQgaSA9IG9wcy5sZW5ndGg7XG4gIGNvbnN0IHJldCA9IHt9O1xuICBsZXQgdmFsO1xuICBsZXQgaGFzRG9sbGFyS2V5ID0gZmFsc2U7XG5cbiAgZmlsdGVyID0gZmlsdGVyIHx8IHt9O1xuICB3aGlsZSAoaS0tKSB7XG4gICAgY29uc3Qgb3AgPSBvcHNbaV07XG4gICAgaWYgKCFtb25nb2RiVXBkYXRlT3BlcmF0b3JzLmhhcyhvcCkpIHtcbiAgICAgIC8vIGZpeCB1cCAkc2V0IHN1Z2FyXG4gICAgICBpZiAoIXJldC4kc2V0KSB7XG4gICAgICAgIGlmIChvYmouJHNldCkge1xuICAgICAgICAgIHJldC4kc2V0ID0gb2JqLiRzZXQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0LiRzZXQgPSB7fTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0LiRzZXRbb3BdID0gb2JqW29wXTtcbiAgICAgIG9wcy5zcGxpY2UoaSwgMSk7XG4gICAgICBpZiAoIX5vcHMuaW5kZXhPZignJHNldCcpKSBvcHMucHVzaCgnJHNldCcpO1xuICAgIH0gZWxzZSBpZiAob3AgPT09ICckc2V0Jykge1xuICAgICAgaWYgKCFyZXQuJHNldCkge1xuICAgICAgICByZXRbb3BdID0gb2JqW29wXTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgcmV0W29wXSA9IG9ialtvcF07XG4gICAgfVxuICB9XG4gIC8vIGNhc3QgZWFjaCB2YWx1ZVxuICBpID0gb3BzLmxlbmd0aDtcbiAgd2hpbGUgKGktLSkge1xuICAgIGNvbnN0IG9wID0gb3BzW2ldO1xuICAgIHZhbCA9IHJldFtvcF07XG4gICAgaGFzRG9sbGFyS2V5ID0gaGFzRG9sbGFyS2V5IHx8IG9wLnN0YXJ0c1dpdGgoJyQnKTtcblxuICAgIGlmICh2YWwgJiZcbiAgICAgICAgdHlwZW9mIHZhbCA9PT0gJ29iamVjdCcgJiZcbiAgICAgICAgIUJ1ZmZlci5pc0J1ZmZlcih2YWwpICYmXG4gICAgICAgIG1vbmdvZGJVcGRhdGVPcGVyYXRvcnMuaGFzKG9wKSkge1xuICAgICAgd2Fsa1VwZGF0ZVBhdGgoc2NoZW1hLCB2YWwsIG9wLCBvcHRpb25zLCBjb250ZXh0LCBmaWx0ZXIpO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCBtc2cgPSAnSW52YWxpZCBhdG9taWMgdXBkYXRlIHZhbHVlIGZvciAnICsgb3AgKyAnLiAnXG4gICAgICAgICAgKyAnRXhwZWN0ZWQgYW4gb2JqZWN0LCByZWNlaXZlZCAnICsgdHlwZW9mIHZhbDtcbiAgICAgIHRocm93IG5ldyBFcnJvcihtc2cpO1xuICAgIH1cblxuICAgIGlmIChvcC5zdGFydHNXaXRoKCckJykgJiYgdXRpbHMuaXNFbXB0eU9iamVjdCh2YWwpKSB7XG4gICAgICBkZWxldGUgcmV0W29wXTtcbiAgICB9XG4gIH1cblxuICBpZiAoT2JqZWN0LmtleXMocmV0KS5sZW5ndGggPT09IDAgJiZcbiAgICAgIG9wdGlvbnMudXBzZXJ0ICYmXG4gICAgICBPYmplY3Qua2V5cyhmaWx0ZXIpLmxlbmd0aCA+IDApIHtcbiAgICAvLyBUcmljayB0aGUgZHJpdmVyIGludG8gYWxsb3dpbmcgZW1wdHkgdXBzZXJ0cyB0byB3b3JrIGFyb3VuZFxuICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9tb25nb2RiL25vZGUtbW9uZ29kYi1uYXRpdmUvcHVsbC8yNDkwXG4gICAgLy8gU2hhbGxvdyBjbG9uZSB0byBhdm9pZCBwYXNzaW5nIGRlZmF1bHRzIGluIHJlOiBnaC0xMzk2MlxuICAgIHJldHVybiB7ICRzZXRPbkluc2VydDogeyAuLi5maWx0ZXIgfSB9O1xuICB9XG4gIHJldHVybiByZXQ7XG59O1xuXG4vKiFcbiAqIGlnbm9yZVxuICovXG5cbmZ1bmN0aW9uIGNhc3RQaXBlbGluZU9wZXJhdG9yKG9wLCB2YWwpIHtcbiAgaWYgKG9wID09PSAnJHVuc2V0Jykge1xuICAgIGlmICh0eXBlb2YgdmFsICE9PSAnc3RyaW5nJyAmJiAoIUFycmF5LmlzQXJyYXkodmFsKSB8fCB2YWwuZmluZCh2ID0+IHR5cGVvZiB2ICE9PSAnc3RyaW5nJykpKSB7XG4gICAgICB0aHJvdyBuZXcgTW9uZ29vc2VFcnJvcignSW52YWxpZCAkdW5zZXQgaW4gcGlwZWxpbmUsIG11c3QgYmUgJyArXG4gICAgICAgICcgYSBzdHJpbmcgb3IgYW4gYXJyYXkgb2Ygc3RyaW5ncycpO1xuICAgIH1cbiAgICByZXR1cm4gdmFsO1xuICB9XG4gIGlmIChvcCA9PT0gJyRwcm9qZWN0Jykge1xuICAgIGlmICh2YWwgPT0gbnVsbCB8fCB0eXBlb2YgdmFsICE9PSAnb2JqZWN0Jykge1xuICAgICAgdGhyb3cgbmV3IE1vbmdvb3NlRXJyb3IoJ0ludmFsaWQgJHByb2plY3QgaW4gcGlwZWxpbmUsIG11c3QgYmUgYW4gb2JqZWN0Jyk7XG4gICAgfVxuICAgIHJldHVybiB2YWw7XG4gIH1cbiAgaWYgKG9wID09PSAnJGFkZEZpZWxkcycgfHwgb3AgPT09ICckc2V0Jykge1xuICAgIGlmICh2YWwgPT0gbnVsbCB8fCB0eXBlb2YgdmFsICE9PSAnb2JqZWN0Jykge1xuICAgICAgdGhyb3cgbmV3IE1vbmdvb3NlRXJyb3IoJ0ludmFsaWQgJyArIG9wICsgJyBpbiBwaXBlbGluZSwgbXVzdCBiZSBhbiBvYmplY3QnKTtcbiAgICB9XG4gICAgcmV0dXJuIHZhbDtcbiAgfSBlbHNlIGlmIChvcCA9PT0gJyRyZXBsYWNlUm9vdCcgfHwgb3AgPT09ICckcmVwbGFjZVdpdGgnKSB7XG4gICAgaWYgKHZhbCA9PSBudWxsIHx8IHR5cGVvZiB2YWwgIT09ICdvYmplY3QnKSB7XG4gICAgICB0aHJvdyBuZXcgTW9uZ29vc2VFcnJvcignSW52YWxpZCAnICsgb3AgKyAnIGluIHBpcGVsaW5lLCBtdXN0IGJlIGFuIG9iamVjdCcpO1xuICAgIH1cbiAgICByZXR1cm4gdmFsO1xuICB9XG5cbiAgdGhyb3cgbmV3IE1vbmdvb3NlRXJyb3IoJ0ludmFsaWQgdXBkYXRlIHBpcGVsaW5lIG9wZXJhdG9yOiBcIicgKyBvcCArICdcIicpO1xufVxuXG4vKipcbiAqIFdhbGsgZWFjaCBwYXRoIG9mIG9iaiBhbmQgY2FzdCBpdHMgdmFsdWVzXG4gKiBhY2NvcmRpbmcgdG8gaXRzIHNjaGVtYS5cbiAqXG4gKiBAcGFyYW0ge1NjaGVtYX0gc2NoZW1hXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqIHBhcnQgb2YgYSBxdWVyeVxuICogQHBhcmFtIHtTdHJpbmd9IG9wIHRoZSBhdG9taWMgb3BlcmF0b3IgKCRwdWxsLCAkc2V0LCBldGMpXG4gKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdXG4gKiBAcGFyYW0ge0Jvb2xlYW58U3RyaW5nfSBbb3B0aW9ucy5zdHJpY3RdXG4gKiBAcGFyYW0ge1F1ZXJ5fSBjb250ZXh0XG4gKiBAcGFyYW0ge09iamVjdH0gZmlsdGVyXG4gKiBAcGFyYW0ge1N0cmluZ30gcHJlZiBwYXRoIHByZWZpeCAoaW50ZXJuYWwgb25seSlcbiAqIEByZXR1cm4ge0Jvb2x9IHRydWUgaWYgdGhpcyBwYXRoIGhhcyBrZXlzIHRvIHVwZGF0ZVxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZnVuY3Rpb24gd2Fsa1VwZGF0ZVBhdGgoc2NoZW1hLCBvYmosIG9wLCBvcHRpb25zLCBjb250ZXh0LCBmaWx0ZXIsIHByZWYpIHtcbiAgY29uc3Qgc3RyaWN0ID0gb3B0aW9ucy5zdHJpY3Q7XG4gIGNvbnN0IHByZWZpeCA9IHByZWYgPyBwcmVmICsgJy4nIDogJyc7XG4gIGNvbnN0IGtleXMgPSBPYmplY3Qua2V5cyhvYmopO1xuICBsZXQgaSA9IGtleXMubGVuZ3RoO1xuICBsZXQgaGFzS2V5cyA9IGZhbHNlO1xuICBsZXQgc2NoZW1hdHlwZTtcbiAgbGV0IGtleTtcbiAgbGV0IHZhbDtcblxuICBsZXQgYWdncmVnYXRlZEVycm9yID0gbnVsbDtcblxuICBjb25zdCBzdHJpY3RNb2RlID0gc3RyaWN0ICE9IG51bGwgPyBzdHJpY3QgOiBzY2hlbWEub3B0aW9ucy5zdHJpY3Q7XG5cbiAgd2hpbGUgKGktLSkge1xuICAgIGtleSA9IGtleXNbaV07XG4gICAgdmFsID0gb2JqW2tleV07XG5cbiAgICAvLyBgJHB1bGxgIGlzIHNwZWNpYWwgYmVjYXVzZSB3ZSBuZWVkIHRvIGNhc3QgdGhlIFJIUyBhcyBhIHF1ZXJ5LCBub3QgYXNcbiAgICAvLyBhbiB1cGRhdGUuXG4gICAgaWYgKG9wID09PSAnJHB1bGwnKSB7XG4gICAgICBzY2hlbWF0eXBlID0gc2NoZW1hLl9nZXRTY2hlbWEocHJlZml4ICsga2V5KTtcbiAgICAgIGlmIChzY2hlbWF0eXBlICE9IG51bGwgJiYgc2NoZW1hdHlwZS5zY2hlbWEgIT0gbnVsbCkge1xuICAgICAgICBvYmpba2V5XSA9IGNhc3Qoc2NoZW1hdHlwZS5zY2hlbWEsIG9ialtrZXldLCBvcHRpb25zLCBjb250ZXh0KTtcbiAgICAgICAgaGFzS2V5cyA9IHRydWU7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgIH1cblxuICAgIGNvbnN0IGRpc2NyaW1pbmF0b3JLZXkgPSAocHJlZml4ID8gcHJlZml4ICsga2V5IDoga2V5KTtcbiAgICBpZiAoXG4gICAgICBzY2hlbWEuZGlzY3JpbWluYXRvck1hcHBpbmcgIT0gbnVsbCAmJlxuICAgICAgZGlzY3JpbWluYXRvcktleSA9PT0gc2NoZW1hLm9wdGlvbnMuZGlzY3JpbWluYXRvcktleSAmJlxuICAgICAgc2NoZW1hLmRpc2NyaW1pbmF0b3JNYXBwaW5nLnZhbHVlICE9PSBvYmpba2V5XSAmJlxuICAgICAgIW9wdGlvbnMub3ZlcndyaXRlRGlzY3JpbWluYXRvcktleVxuICAgICkge1xuICAgICAgaWYgKHN0cmljdE1vZGUgPT09ICd0aHJvdycpIHtcbiAgICAgICAgY29uc3QgZXJyID0gbmV3IEVycm9yKCdDYW5cXCd0IG1vZGlmeSBkaXNjcmltaW5hdG9yIGtleSBcIicgKyBkaXNjcmltaW5hdG9yS2V5ICsgJ1wiIG9uIGRpc2NyaW1pbmF0b3IgbW9kZWwnKTtcbiAgICAgICAgYWdncmVnYXRlZEVycm9yID0gX2FwcGVuZEVycm9yKGVyciwgY29udGV4dCwgZGlzY3JpbWluYXRvcktleSwgYWdncmVnYXRlZEVycm9yKTtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9IGVsc2UgaWYgKHN0cmljdE1vZGUpIHtcbiAgICAgICAgZGVsZXRlIG9ialtrZXldO1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoZ2V0Q29uc3RydWN0b3JOYW1lKHZhbCkgPT09ICdPYmplY3QnKSB7XG4gICAgICAvLyB3YXRjaCBmb3IgZW1iZWRkZWQgZG9jIHNjaGVtYXNcbiAgICAgIHNjaGVtYXR5cGUgPSBzY2hlbWEuX2dldFNjaGVtYShwcmVmaXggKyBrZXkpO1xuXG4gICAgICBpZiAoc2NoZW1hdHlwZSA9PSBudWxsKSB7XG4gICAgICAgIGNvbnN0IF9yZXMgPSBnZXRFbWJlZGRlZERpc2NyaW1pbmF0b3JQYXRoKHNjaGVtYSwgb2JqLCBmaWx0ZXIsIHByZWZpeCArIGtleSwgb3B0aW9ucyk7XG4gICAgICAgIGlmIChfcmVzLnNjaGVtYXR5cGUgIT0gbnVsbCkge1xuICAgICAgICAgIHNjaGVtYXR5cGUgPSBfcmVzLnNjaGVtYXR5cGU7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKG9wICE9PSAnJHNldE9uSW5zZXJ0JyAmJlxuICAgICAgICAgIGhhbmRsZUltbXV0YWJsZShzY2hlbWF0eXBlLCBzdHJpY3QsIG9iaiwga2V5LCBwcmVmaXggKyBrZXksIGNvbnRleHQpKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuXG4gICAgICBpZiAoc2NoZW1hdHlwZSAmJiBzY2hlbWF0eXBlLmNhc3RlciAmJiBvcCBpbiBjYXN0T3BzKSB7XG4gICAgICAgIC8vIGVtYmVkZGVkIGRvYyBzY2hlbWFcbiAgICAgICAgaWYgKCckZWFjaCcgaW4gdmFsKSB7XG4gICAgICAgICAgaGFzS2V5cyA9IHRydWU7XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIG9ialtrZXldID0ge1xuICAgICAgICAgICAgICAkZWFjaDogY2FzdFVwZGF0ZVZhbChzY2hlbWF0eXBlLCB2YWwuJGVhY2gsIG9wLCBrZXksIGNvbnRleHQsIHByZWZpeCArIGtleSlcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIGFnZ3JlZ2F0ZWRFcnJvciA9IF9hcHBlbmRFcnJvcihlcnJvciwgY29udGV4dCwga2V5LCBhZ2dyZWdhdGVkRXJyb3IpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmICh2YWwuJHNsaWNlICE9IG51bGwpIHtcbiAgICAgICAgICAgIG9ialtrZXldLiRzbGljZSA9IHZhbC4kc2xpY2UgfCAwO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmICh2YWwuJHNvcnQpIHtcbiAgICAgICAgICAgIG9ialtrZXldLiRzb3J0ID0gdmFsLiRzb3J0O1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmICh2YWwuJHBvc2l0aW9uICE9IG51bGwpIHtcbiAgICAgICAgICAgIG9ialtrZXldLiRwb3NpdGlvbiA9IGNhc3ROdW1iZXIodmFsLiRwb3NpdGlvbik7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGlmIChzY2hlbWF0eXBlICE9IG51bGwgJiYgc2NoZW1hdHlwZS4kaXNTaW5nbGVOZXN0ZWQpIHtcbiAgICAgICAgICAgIGNvbnN0IF9zdHJpY3QgPSBzdHJpY3QgPT0gbnVsbCA/IHNjaGVtYXR5cGUuc2NoZW1hLm9wdGlvbnMuc3RyaWN0IDogc3RyaWN0O1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgb2JqW2tleV0gPSBzY2hlbWF0eXBlLmNhc3RGb3JRdWVyeShudWxsLCB2YWwsIGNvbnRleHQsIHsgc3RyaWN0OiBfc3RyaWN0IH0pO1xuICAgICAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgYWdncmVnYXRlZEVycm9yID0gX2FwcGVuZEVycm9yKGVycm9yLCBjb250ZXh0LCBrZXksIGFnZ3JlZ2F0ZWRFcnJvcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgIG9ialtrZXldID0gY2FzdFVwZGF0ZVZhbChzY2hlbWF0eXBlLCB2YWwsIG9wLCBrZXksIGNvbnRleHQsIHByZWZpeCArIGtleSk7XG4gICAgICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgICBhZ2dyZWdhdGVkRXJyb3IgPSBfYXBwZW5kRXJyb3IoZXJyb3IsIGNvbnRleHQsIGtleSwgYWdncmVnYXRlZEVycm9yKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAob2JqW2tleV0gPT09IHZvaWQgMCkge1xuICAgICAgICAgICAgZGVsZXRlIG9ialtrZXldO1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaGFzS2V5cyA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoKG9wID09PSAnJGN1cnJlbnREYXRlJykgfHwgKG9wIGluIGNhc3RPcHMgJiYgc2NoZW1hdHlwZSkpIHtcbiAgICAgICAgLy8gJGN1cnJlbnREYXRlIGNhbiB0YWtlIGFuIG9iamVjdFxuICAgICAgICB0cnkge1xuICAgICAgICAgIG9ialtrZXldID0gY2FzdFVwZGF0ZVZhbChzY2hlbWF0eXBlLCB2YWwsIG9wLCBrZXksIGNvbnRleHQsIHByZWZpeCArIGtleSk7XG4gICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgYWdncmVnYXRlZEVycm9yID0gX2FwcGVuZEVycm9yKGVycm9yLCBjb250ZXh0LCBrZXksIGFnZ3JlZ2F0ZWRFcnJvcik7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAob2JqW2tleV0gPT09IHZvaWQgMCkge1xuICAgICAgICAgIGRlbGV0ZSBvYmpba2V5XTtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGhhc0tleXMgPSB0cnVlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc3QgcGF0aFRvQ2hlY2sgPSAocHJlZml4ICsga2V5KTtcbiAgICAgICAgY29uc3QgdiA9IHNjaGVtYS5fZ2V0UGF0aFR5cGUocGF0aFRvQ2hlY2spO1xuICAgICAgICBsZXQgX3N0cmljdCA9IHN0cmljdDtcbiAgICAgICAgaWYgKHYgJiYgdi5zY2hlbWEgJiYgX3N0cmljdCA9PSBudWxsKSB7XG4gICAgICAgICAgX3N0cmljdCA9IHYuc2NoZW1hLm9wdGlvbnMuc3RyaWN0O1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHYucGF0aFR5cGUgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgaWYgKF9zdHJpY3QgPT09ICd0aHJvdycpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBTdHJpY3RNb2RlRXJyb3IocGF0aFRvQ2hlY2spO1xuICAgICAgICAgIH0gZWxzZSBpZiAoX3N0cmljdCkge1xuICAgICAgICAgICAgZGVsZXRlIG9ialtrZXldO1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gZ2gtMjMxNFxuICAgICAgICAvLyB3ZSBzaG91bGQgYmUgYWJsZSB0byBzZXQgYSBzY2hlbWEtbGVzcyBmaWVsZFxuICAgICAgICAvLyB0byBhbiBlbXB0eSBvYmplY3QgbGl0ZXJhbFxuICAgICAgICBoYXNLZXlzIHw9IHdhbGtVcGRhdGVQYXRoKHNjaGVtYSwgdmFsLCBvcCwgb3B0aW9ucywgY29udGV4dCwgZmlsdGVyLCBwcmVmaXggKyBrZXkpIHx8XG4gICAgICAgICAgKHV0aWxzLmlzT2JqZWN0KHZhbCkgJiYgT2JqZWN0LmtleXModmFsKS5sZW5ndGggPT09IDApO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCBjaGVja1BhdGggPSAoa2V5ID09PSAnJGVhY2gnIHx8IGtleSA9PT0gJyRvcicgfHwga2V5ID09PSAnJGFuZCcgfHwga2V5ID09PSAnJGluJykgP1xuICAgICAgICBwcmVmIDogcHJlZml4ICsga2V5O1xuICAgICAgc2NoZW1hdHlwZSA9IHNjaGVtYS5fZ2V0U2NoZW1hKGNoZWNrUGF0aCk7XG5cbiAgICAgIC8vIFlvdSBjYW4gdXNlIGAkc2V0T25JbnNlcnRgIHdpdGggaW1tdXRhYmxlIGtleXNcbiAgICAgIGlmIChvcCAhPT0gJyRzZXRPbkluc2VydCcgJiZcbiAgICAgICAgICBoYW5kbGVJbW11dGFibGUoc2NoZW1hdHlwZSwgc3RyaWN0LCBvYmosIGtleSwgcHJlZml4ICsga2V5LCBjb250ZXh0KSkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgbGV0IHBhdGhEZXRhaWxzID0gc2NoZW1hLl9nZXRQYXRoVHlwZShjaGVja1BhdGgpO1xuXG4gICAgICAvLyBJZiBubyBzY2hlbWEgdHlwZSwgY2hlY2sgZm9yIGVtYmVkZGVkIGRpc2NyaW1pbmF0b3JzIGJlY2F1c2UgdGhlXG4gICAgICAvLyBmaWx0ZXIgb3IgdXBkYXRlIG1heSBpbXBseSBhbiBlbWJlZGRlZCBkaXNjcmltaW5hdG9yIHR5cGUuIFNlZSAjODM3OFxuICAgICAgaWYgKHNjaGVtYXR5cGUgPT0gbnVsbCkge1xuICAgICAgICBjb25zdCBfcmVzID0gZ2V0RW1iZWRkZWREaXNjcmltaW5hdG9yUGF0aChzY2hlbWEsIG9iaiwgZmlsdGVyLCBjaGVja1BhdGgsIG9wdGlvbnMpO1xuICAgICAgICBpZiAoX3Jlcy5zY2hlbWF0eXBlICE9IG51bGwpIHtcbiAgICAgICAgICBzY2hlbWF0eXBlID0gX3Jlcy5zY2hlbWF0eXBlO1xuICAgICAgICAgIHBhdGhEZXRhaWxzID0gX3Jlcy50eXBlO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGxldCBpc1N0cmljdCA9IHN0cmljdDtcbiAgICAgIGlmIChwYXRoRGV0YWlscyAmJiBwYXRoRGV0YWlscy5zY2hlbWEgJiYgc3RyaWN0ID09IG51bGwpIHtcbiAgICAgICAgaXNTdHJpY3QgPSBwYXRoRGV0YWlscy5zY2hlbWEub3B0aW9ucy5zdHJpY3Q7XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IHNraXAgPSBpc1N0cmljdCAmJlxuICAgICAgICAhc2NoZW1hdHlwZSAmJlxuICAgICAgICAhL3JlYWx8bmVzdGVkLy50ZXN0KHBhdGhEZXRhaWxzLnBhdGhUeXBlKTtcblxuICAgICAgaWYgKHNraXApIHtcbiAgICAgICAgLy8gRXZlbiBpZiBzdHJpY3QgaXMgYHRocm93YCwgYXZvaWQgdGhyb3dpbmcgYW4gZXJyb3IgYmVjYXVzZSBvZlxuICAgICAgICAvLyB2aXJ0dWFscyBiZWNhdXNlIG9mICM2NzMxXG4gICAgICAgIGlmIChpc1N0cmljdCA9PT0gJ3Rocm93JyAmJiBzY2hlbWEudmlydHVhbHNbY2hlY2tQYXRoXSA9PSBudWxsKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IFN0cmljdE1vZGVFcnJvcihwcmVmaXggKyBrZXkpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGRlbGV0ZSBvYmpba2V5XTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gZ2gtMTg0NSB0ZW1wb3JhcnkgZml4OiBpZ25vcmUgJHJlbmFtZS4gU2VlIGdoLTMwMjcgZm9yIHRyYWNraW5nXG4gICAgICAgIC8vIGltcHJvdmluZyB0aGlzLlxuICAgICAgICBpZiAob3AgPT09ICckcmVuYW1lJykge1xuICAgICAgICAgIGhhc0tleXMgPSB0cnVlO1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBpZiAocHJlZml4Lmxlbmd0aCA9PT0gMCB8fCBrZXkuaW5kZXhPZignLicpID09PSAtMSkge1xuICAgICAgICAgICAgb2JqW2tleV0gPSBjYXN0VXBkYXRlVmFsKHNjaGVtYXR5cGUsIHZhbCwgb3AsIGtleSwgY29udGV4dCwgcHJlZml4ICsga2V5KTtcbiAgICAgICAgICB9IGVsc2UgaWYgKGlzU3RyaWN0ICE9PSBmYWxzZSB8fCBzY2hlbWF0eXBlICE9IG51bGwpIHtcbiAgICAgICAgICAgIC8vIFNldHRpbmcgYSBuZXN0ZWQgZG90dGVkIHBhdGggdGhhdCdzIGluIHRoZSBzY2hlbWEuIFdlIGRvbid0IGFsbG93IHBhdGhzIHdpdGggJy4nIGluXG4gICAgICAgICAgICAvLyBhIHNjaGVtYSwgc28gcmVwbGFjZSB0aGUgZG90dGVkIHBhdGggd2l0aCBhIG5lc3RlZCBvYmplY3QgdG8gYXZvaWQgZW5kaW5nIHVwIHdpdGhcbiAgICAgICAgICAgIC8vIGRvdHRlZCBwcm9wZXJ0aWVzIGluIHRoZSB1cGRhdGVkIG9iamVjdC4gU2VlIChnaC0xMDIwMClcbiAgICAgICAgICAgIHNldERvdHRlZFBhdGgob2JqLCBrZXksIGNhc3RVcGRhdGVWYWwoc2NoZW1hdHlwZSwgdmFsLCBvcCwga2V5LCBjb250ZXh0LCBwcmVmaXggKyBrZXkpKTtcbiAgICAgICAgICAgIGRlbGV0ZSBvYmpba2V5XTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgYWdncmVnYXRlZEVycm9yID0gX2FwcGVuZEVycm9yKGVycm9yLCBjb250ZXh0LCBrZXksIGFnZ3JlZ2F0ZWRFcnJvcik7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShvYmpba2V5XSkgJiYgKG9wID09PSAnJGFkZFRvU2V0JyB8fCBvcCA9PT0gJyRwdXNoJykgJiYga2V5ICE9PSAnJGVhY2gnKSB7XG4gICAgICAgICAgaWYgKHNjaGVtYXR5cGUgJiZcbiAgICAgICAgICAgICAgc2NoZW1hdHlwZS5jYXN0ZXIgJiZcbiAgICAgICAgICAgICAgIXNjaGVtYXR5cGUuY2FzdGVyLiRpc01vbmdvb3NlQXJyYXkgJiZcbiAgICAgICAgICAgICAgIXNjaGVtYXR5cGUuY2FzdGVyW3NjaGVtYU1peGVkU3ltYm9sXSkge1xuICAgICAgICAgICAgb2JqW2tleV0gPSB7ICRlYWNoOiBvYmpba2V5XSB9O1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChvYmpba2V5XSA9PT0gdm9pZCAwKSB7XG4gICAgICAgICAgZGVsZXRlIG9ialtrZXldO1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgaGFzS2V5cyA9IHRydWU7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgaWYgKGFnZ3JlZ2F0ZWRFcnJvciAhPSBudWxsKSB7XG4gICAgdGhyb3cgYWdncmVnYXRlZEVycm9yO1xuICB9XG5cbiAgcmV0dXJuIGhhc0tleXM7XG59XG5cbi8qIVxuICogaWdub3JlXG4gKi9cblxuZnVuY3Rpb24gX2FwcGVuZEVycm9yKGVycm9yLCBxdWVyeSwga2V5LCBhZ2dyZWdhdGVkRXJyb3IpIHtcbiAgaWYgKHR5cGVvZiBxdWVyeSAhPT0gJ29iamVjdCcgfHwgIXF1ZXJ5Lm9wdGlvbnMubXVsdGlwbGVDYXN0RXJyb3IpIHtcbiAgICB0aHJvdyBlcnJvcjtcbiAgfVxuICBhZ2dyZWdhdGVkRXJyb3IgPSBhZ2dyZWdhdGVkRXJyb3IgfHwgbmV3IFZhbGlkYXRpb25FcnJvcigpO1xuICBhZ2dyZWdhdGVkRXJyb3IuYWRkRXJyb3Ioa2V5LCBlcnJvcik7XG4gIHJldHVybiBhZ2dyZWdhdGVkRXJyb3I7XG59XG5cbi8qKlxuICogVGhlc2Ugb3BlcmF0b3JzIHNob3VsZCBiZSBjYXN0IHRvIG51bWJlcnMgaW5zdGVhZFxuICogb2YgdGhlaXIgcGF0aCBzY2hlbWEgdHlwZS5cbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmNvbnN0IG51bWJlck9wcyA9IHtcbiAgJHBvcDogMSxcbiAgJGluYzogMVxufTtcblxuLyoqXG4gKiBUaGVzZSBvcHMgcmVxdWlyZSBubyBjYXN0aW5nIGJlY2F1c2UgdGhlIFJIUyBkb2Vzbid0IGRvIGFueXRoaW5nLlxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuY29uc3Qgbm9DYXN0T3BzID0ge1xuICAkdW5zZXQ6IDFcbn07XG5cbi8qKlxuICogVGhlc2Ugb3BlcmF0b3JzIHJlcXVpcmUgY2FzdGluZyBkb2NzXG4gKiB0byByZWFsIERvY3VtZW50cyBmb3IgVXBkYXRlIG9wZXJhdGlvbnMuXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5jb25zdCBjYXN0T3BzID0ge1xuICAkcHVzaDogMSxcbiAgJGFkZFRvU2V0OiAxLFxuICAkc2V0OiAxLFxuICAkc2V0T25JbnNlcnQ6IDFcbn07XG5cbi8qIVxuICogaWdub3JlXG4gKi9cblxuY29uc3Qgb3ZlcndyaXRlT3BzID0ge1xuICAkc2V0OiAxLFxuICAkc2V0T25JbnNlcnQ6IDFcbn07XG5cbi8qKlxuICogQ2FzdHMgYHZhbGAgYWNjb3JkaW5nIHRvIGBzY2hlbWFgIGFuZCBhdG9taWMgYG9wYC5cbiAqXG4gKiBAcGFyYW0ge1NjaGVtYVR5cGV9IHNjaGVtYVxuICogQHBhcmFtIHtPYmplY3R9IHZhbFxuICogQHBhcmFtIHtTdHJpbmd9IG9wIHRoZSBhdG9taWMgb3BlcmF0b3IgKCRwdWxsLCAkc2V0LCBldGMpXG4gKiBAcGFyYW0ge1N0cmluZ30gJGNvbmRpdGlvbmFsXG4gKiBAcGFyYW0ge1F1ZXJ5fSBjb250ZXh0XG4gKiBAcGFyYW0ge1N0cmluZ30gcGF0aFxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZnVuY3Rpb24gY2FzdFVwZGF0ZVZhbChzY2hlbWEsIHZhbCwgb3AsICRjb25kaXRpb25hbCwgY29udGV4dCwgcGF0aCkge1xuICBpZiAoIXNjaGVtYSkge1xuICAgIC8vIG5vbi1leGlzdGluZyBzY2hlbWEgcGF0aFxuICAgIGlmIChvcCBpbiBudW1iZXJPcHMpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIHJldHVybiBjYXN0TnVtYmVyKHZhbCk7XG4gICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgdGhyb3cgbmV3IENhc3RFcnJvcignbnVtYmVyJywgdmFsLCBwYXRoKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHZhbDtcbiAgfVxuXG4gIC8vIGNvbnNvbGUubG9nKCdDYXN0VXBkYXRlVmFsJywgcGF0aCwgb3AsIHZhbCwgc2NoZW1hKTtcblxuICBjb25zdCBjb25kID0gc2NoZW1hLmNhc3RlciAmJiBvcCBpbiBjYXN0T3BzICYmXG4gICAgICAodXRpbHMuaXNPYmplY3QodmFsKSB8fCBBcnJheS5pc0FycmF5KHZhbCkpO1xuICBpZiAoY29uZCAmJiAhb3ZlcndyaXRlT3BzW29wXSkge1xuICAgIC8vIENhc3QgdmFsdWVzIGZvciBvcHMgdGhhdCBhZGQgZGF0YSB0byBNb25nb0RCLlxuICAgIC8vIEVuc3VyZXMgZW1iZWRkZWQgZG9jdW1lbnRzIGdldCBPYmplY3RJZHMgZXRjLlxuICAgIGxldCBzY2hlbWFBcnJheURlcHRoID0gMDtcbiAgICBsZXQgY3VyID0gc2NoZW1hO1xuICAgIHdoaWxlIChjdXIuJGlzTW9uZ29vc2VBcnJheSkge1xuICAgICAgKytzY2hlbWFBcnJheURlcHRoO1xuICAgICAgY3VyID0gY3VyLmNhc3RlcjtcbiAgICB9XG4gICAgbGV0IGFycmF5RGVwdGggPSAwO1xuICAgIGxldCBfdmFsID0gdmFsO1xuICAgIHdoaWxlIChBcnJheS5pc0FycmF5KF92YWwpKSB7XG4gICAgICArK2FycmF5RGVwdGg7XG4gICAgICBfdmFsID0gX3ZhbFswXTtcbiAgICB9XG5cbiAgICBjb25zdCBhZGRpdGlvbmFsTmVzdGluZyA9IHNjaGVtYUFycmF5RGVwdGggLSBhcnJheURlcHRoO1xuICAgIHdoaWxlIChhcnJheURlcHRoIDwgc2NoZW1hQXJyYXlEZXB0aCkge1xuICAgICAgdmFsID0gW3ZhbF07XG4gICAgICArK2FycmF5RGVwdGg7XG4gICAgfVxuXG4gICAgbGV0IHRtcCA9IHNjaGVtYS5hcHBseVNldHRlcnMoQXJyYXkuaXNBcnJheSh2YWwpID8gdmFsIDogW3ZhbF0sIGNvbnRleHQpO1xuXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBhZGRpdGlvbmFsTmVzdGluZzsgKytpKSB7XG4gICAgICB0bXAgPSB0bXBbMF07XG4gICAgfVxuICAgIHJldHVybiB0bXA7XG4gIH1cblxuICBpZiAob3AgaW4gbm9DYXN0T3BzKSB7XG4gICAgcmV0dXJuIHZhbDtcbiAgfVxuICBpZiAob3AgaW4gbnVtYmVyT3BzKSB7XG4gICAgLy8gTnVsbCBhbmQgdW5kZWZpbmVkIG5vdCBhbGxvd2VkIGZvciAkcG9wLCAkaW5jXG4gICAgaWYgKHZhbCA9PSBudWxsKSB7XG4gICAgICB0aHJvdyBuZXcgQ2FzdEVycm9yKCdudW1iZXInLCB2YWwsIHNjaGVtYS5wYXRoKTtcbiAgICB9XG4gICAgaWYgKG9wID09PSAnJGluYycpIHtcbiAgICAgIC8vIFN1cHBvcnQgYCRpbmNgIHdpdGggbG9uZywgaW50MzIsIGV0Yy4gKGdoLTQyODMpXG4gICAgICByZXR1cm4gc2NoZW1hLmNhc3RGb3JRdWVyeShcbiAgICAgICAgbnVsbCxcbiAgICAgICAgdmFsLFxuICAgICAgICBjb250ZXh0XG4gICAgICApO1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgcmV0dXJuIGNhc3ROdW1iZXIodmFsKTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgdGhyb3cgbmV3IENhc3RFcnJvcignbnVtYmVyJywgdmFsLCBzY2hlbWEucGF0aCk7XG4gICAgfVxuICB9XG4gIGlmIChvcCA9PT0gJyRjdXJyZW50RGF0ZScpIHtcbiAgICBpZiAodHlwZW9mIHZhbCA9PT0gJ29iamVjdCcpIHtcbiAgICAgIHJldHVybiB7ICR0eXBlOiB2YWwuJHR5cGUgfTtcbiAgICB9XG4gICAgcmV0dXJuIEJvb2xlYW4odmFsKTtcbiAgfVxuXG4gIGlmIChtb25nb2RiVXBkYXRlT3BlcmF0b3JzLmhhcygkY29uZGl0aW9uYWwpKSB7XG4gICAgcmV0dXJuIHNjaGVtYS5jYXN0Rm9yUXVlcnkoXG4gICAgICAkY29uZGl0aW9uYWwsXG4gICAgICB2YWwsXG4gICAgICBjb250ZXh0XG4gICAgKTtcbiAgfVxuXG4gIGlmIChvdmVyd3JpdGVPcHNbb3BdKSB7XG4gICAgY29uc3Qgc2tpcFF1ZXJ5Q2FzdEZvclVwZGF0ZSA9IHZhbCAhPSBudWxsICYmIHNjaGVtYS4kaXNNb25nb29zZUFycmF5ICYmIHNjaGVtYS4kZnVsbFBhdGggIT0gbnVsbCAmJiAhc2NoZW1hLiRmdWxsUGF0aC5tYXRjaCgvXFxkKyQvKTtcbiAgICBjb25zdCBhcHBseVNldHRlcnMgPSBzY2hlbWFbc2NoZW1hTWl4ZWRTeW1ib2xdICE9IG51bGw7XG4gICAgaWYgKHNraXBRdWVyeUNhc3RGb3JVcGRhdGUgfHwgYXBwbHlTZXR0ZXJzKSB7XG4gICAgICByZXR1cm4gc2NoZW1hLmFwcGx5U2V0dGVycyh2YWwsIGNvbnRleHQpO1xuICAgIH1cbiAgICByZXR1cm4gc2NoZW1hLmNhc3RGb3JRdWVyeShcbiAgICAgIG51bGwsXG4gICAgICB2YWwsXG4gICAgICBjb250ZXh0XG4gICAgKTtcbiAgfVxuXG4gIHJldHVybiBzY2hlbWEuY2FzdEZvclF1ZXJ5KG51bGwsIHZhbCwgY29udGV4dCk7XG59XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/mongoose/lib/helpers/query/castUpdate.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/mongoose/lib/helpers/query/completeMany.js":
/*!*****************************************************************!*\
  !*** ./node_modules/mongoose/lib/helpers/query/completeMany.js ***!
  \*****************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\n\nconst helpers = __webpack_require__(/*! ../../queryHelpers */ \"(ssr)/./node_modules/mongoose/lib/queryHelpers.js\");\n\nmodule.exports = completeMany;\n\n/**\n * Given a model and an array of docs, hydrates all the docs to be instances\n * of the model. Used to initialize docs returned from the db from `find()`\n *\n * @param {Model} model\n * @param {Array} docs\n * @param {Object} fields the projection used, including `select` from schemas\n * @param {Object} userProvidedFields the user-specified projection\n * @param {Object} [opts]\n * @param {Array} [opts.populated]\n * @param {ClientSession} [opts.session]\n * @param {Function} callback\n * @api private\n */\n\nasync function completeMany(model, docs, fields, userProvidedFields, opts) {\n  return Promise.all(docs.map(doc => new Promise((resolve, reject) => {\n    const rawDoc = doc;\n    doc = helpers.createModel(model, doc, fields, userProvidedFields);\n    if (opts.session != null) {\n      doc.$session(opts.session);\n    }\n    doc.$init(rawDoc, opts, (err) => {\n      if (err != null) {\n        return reject(err);\n      }\n      resolve(doc);\n    });\n  })));\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbW9uZ29vc2UvbGliL2hlbHBlcnMvcXVlcnkvY29tcGxldGVNYW55LmpzIiwibWFwcGluZ3MiOiJBQUFhOztBQUViLGdCQUFnQixtQkFBTyxDQUFDLDZFQUFvQjs7QUFFNUM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE9BQU87QUFDbEIsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsT0FBTztBQUNsQixXQUFXLGVBQWU7QUFDMUIsV0FBVyxVQUFVO0FBQ3JCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLEdBQUc7QUFDSCIsInNvdXJjZXMiOlsid2VicGFjazovL2FwcDEvLi9ub2RlX21vZHVsZXMvbW9uZ29vc2UvbGliL2hlbHBlcnMvcXVlcnkvY29tcGxldGVNYW55LmpzPzY3Y2EiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG5jb25zdCBoZWxwZXJzID0gcmVxdWlyZSgnLi4vLi4vcXVlcnlIZWxwZXJzJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gY29tcGxldGVNYW55O1xuXG4vKipcbiAqIEdpdmVuIGEgbW9kZWwgYW5kIGFuIGFycmF5IG9mIGRvY3MsIGh5ZHJhdGVzIGFsbCB0aGUgZG9jcyB0byBiZSBpbnN0YW5jZXNcbiAqIG9mIHRoZSBtb2RlbC4gVXNlZCB0byBpbml0aWFsaXplIGRvY3MgcmV0dXJuZWQgZnJvbSB0aGUgZGIgZnJvbSBgZmluZCgpYFxuICpcbiAqIEBwYXJhbSB7TW9kZWx9IG1vZGVsXG4gKiBAcGFyYW0ge0FycmF5fSBkb2NzXG4gKiBAcGFyYW0ge09iamVjdH0gZmllbGRzIHRoZSBwcm9qZWN0aW9uIHVzZWQsIGluY2x1ZGluZyBgc2VsZWN0YCBmcm9tIHNjaGVtYXNcbiAqIEBwYXJhbSB7T2JqZWN0fSB1c2VyUHJvdmlkZWRGaWVsZHMgdGhlIHVzZXItc3BlY2lmaWVkIHByb2plY3Rpb25cbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0c11cbiAqIEBwYXJhbSB7QXJyYXl9IFtvcHRzLnBvcHVsYXRlZF1cbiAqIEBwYXJhbSB7Q2xpZW50U2Vzc2lvbn0gW29wdHMuc2Vzc2lvbl1cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5hc3luYyBmdW5jdGlvbiBjb21wbGV0ZU1hbnkobW9kZWwsIGRvY3MsIGZpZWxkcywgdXNlclByb3ZpZGVkRmllbGRzLCBvcHRzKSB7XG4gIHJldHVybiBQcm9taXNlLmFsbChkb2NzLm1hcChkb2MgPT4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgIGNvbnN0IHJhd0RvYyA9IGRvYztcbiAgICBkb2MgPSBoZWxwZXJzLmNyZWF0ZU1vZGVsKG1vZGVsLCBkb2MsIGZpZWxkcywgdXNlclByb3ZpZGVkRmllbGRzKTtcbiAgICBpZiAob3B0cy5zZXNzaW9uICE9IG51bGwpIHtcbiAgICAgIGRvYy4kc2Vzc2lvbihvcHRzLnNlc3Npb24pO1xuICAgIH1cbiAgICBkb2MuJGluaXQocmF3RG9jLCBvcHRzLCAoZXJyKSA9PiB7XG4gICAgICBpZiAoZXJyICE9IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIHJlamVjdChlcnIpO1xuICAgICAgfVxuICAgICAgcmVzb2x2ZShkb2MpO1xuICAgIH0pO1xuICB9KSkpO1xufVxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/mongoose/lib/helpers/query/completeMany.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/mongoose/lib/helpers/query/getEmbeddedDiscriminatorPath.js":
/*!*********************************************************************************!*\
  !*** ./node_modules/mongoose/lib/helpers/query/getEmbeddedDiscriminatorPath.js ***!
  \*********************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\n\nconst cleanPositionalOperators = __webpack_require__(/*! ../schema/cleanPositionalOperators */ \"(ssr)/./node_modules/mongoose/lib/helpers/schema/cleanPositionalOperators.js\");\nconst get = __webpack_require__(/*! ../get */ \"(ssr)/./node_modules/mongoose/lib/helpers/get.js\");\nconst getDiscriminatorByValue = __webpack_require__(/*! ../discriminator/getDiscriminatorByValue */ \"(ssr)/./node_modules/mongoose/lib/helpers/discriminator/getDiscriminatorByValue.js\");\nconst updatedPathsByArrayFilter = __webpack_require__(/*! ../update/updatedPathsByArrayFilter */ \"(ssr)/./node_modules/mongoose/lib/helpers/update/updatedPathsByArrayFilter.js\");\n\n/**\n * Like `schema.path()`, except with a document, because impossible to\n * determine path type without knowing the embedded discriminator key.\n * @param {Schema} schema\n * @param {Object} [update]\n * @param {Object} [filter]\n * @param {String} path\n * @param {Object} [options]\n * @api private\n */\n\nmodule.exports = function getEmbeddedDiscriminatorPath(schema, update, filter, path, options) {\n  const parts = path.split('.');\n  let schematype = null;\n  let type = 'adhocOrUndefined';\n\n  filter = filter || {};\n  update = update || {};\n  const arrayFilters = options != null && Array.isArray(options.arrayFilters) ?\n    options.arrayFilters : [];\n  const updatedPathsByFilter = updatedPathsByArrayFilter(update);\n\n  for (let i = 0; i < parts.length; ++i) {\n    const subpath = cleanPositionalOperators(parts.slice(0, i + 1).join('.'));\n    schematype = schema.path(subpath);\n    if (schematype == null) {\n      continue;\n    }\n\n    type = schema.pathType(subpath);\n    if ((schematype.$isSingleNested || schematype.$isMongooseDocumentArrayElement) &&\n        schematype.schema.discriminators != null) {\n      const key = get(schematype, 'schema.options.discriminatorKey');\n      const discriminatorValuePath = subpath + '.' + key;\n      const discriminatorFilterPath =\n        discriminatorValuePath.replace(/\\.\\d+\\./, '.');\n      let discriminatorKey = null;\n\n      if (discriminatorValuePath in filter) {\n        discriminatorKey = filter[discriminatorValuePath];\n      }\n      if (discriminatorFilterPath in filter) {\n        discriminatorKey = filter[discriminatorFilterPath];\n      }\n\n      const wrapperPath = subpath.replace(/\\.\\d+$/, '');\n      if (schematype.$isMongooseDocumentArrayElement &&\n          get(filter[wrapperPath], '$elemMatch.' + key) != null) {\n        discriminatorKey = filter[wrapperPath].$elemMatch[key];\n      }\n\n      if (discriminatorValuePath in update) {\n        discriminatorKey = update[discriminatorValuePath];\n      }\n\n      for (const filterKey of Object.keys(updatedPathsByFilter)) {\n        const schemaKey = updatedPathsByFilter[filterKey] + '.' + key;\n        const arrayFilterKey = filterKey + '.' + key;\n        if (schemaKey === discriminatorFilterPath) {\n          const filter = arrayFilters.find(filter => filter.hasOwnProperty(arrayFilterKey));\n          if (filter != null) {\n            discriminatorKey = filter[arrayFilterKey];\n          }\n        }\n      }\n\n      if (discriminatorKey == null) {\n        continue;\n      }\n\n      const discriminator = getDiscriminatorByValue(schematype.caster.discriminators, discriminatorKey);\n      const discriminatorSchema = discriminator && discriminator.schema;\n      if (discriminatorSchema == null) {\n        continue;\n      }\n\n      const rest = parts.slice(i + 1).join('.');\n      schematype = discriminatorSchema.path(rest);\n      if (schematype != null) {\n        type = discriminatorSchema._getPathType(rest);\n        break;\n      }\n    }\n  }\n\n  return { type: type, schematype: schematype };\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbW9uZ29vc2UvbGliL2hlbHBlcnMvcXVlcnkvZ2V0RW1iZWRkZWREaXNjcmltaW5hdG9yUGF0aC5qcyIsIm1hcHBpbmdzIjoiQUFBYTs7QUFFYixpQ0FBaUMsbUJBQU8sQ0FBQyx3SEFBb0M7QUFDN0UsWUFBWSxtQkFBTyxDQUFDLGdFQUFRO0FBQzVCLGdDQUFnQyxtQkFBTyxDQUFDLG9JQUEwQztBQUNsRixrQ0FBa0MsbUJBQU8sQ0FBQywwSEFBcUM7O0FBRS9FO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGtCQUFrQixrQkFBa0I7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLFdBQVc7QUFDWCIsInNvdXJjZXMiOlsid2VicGFjazovL2FwcDEvLi9ub2RlX21vZHVsZXMvbW9uZ29vc2UvbGliL2hlbHBlcnMvcXVlcnkvZ2V0RW1iZWRkZWREaXNjcmltaW5hdG9yUGF0aC5qcz82ZTU1Il0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxuY29uc3QgY2xlYW5Qb3NpdGlvbmFsT3BlcmF0b3JzID0gcmVxdWlyZSgnLi4vc2NoZW1hL2NsZWFuUG9zaXRpb25hbE9wZXJhdG9ycycpO1xuY29uc3QgZ2V0ID0gcmVxdWlyZSgnLi4vZ2V0Jyk7XG5jb25zdCBnZXREaXNjcmltaW5hdG9yQnlWYWx1ZSA9IHJlcXVpcmUoJy4uL2Rpc2NyaW1pbmF0b3IvZ2V0RGlzY3JpbWluYXRvckJ5VmFsdWUnKTtcbmNvbnN0IHVwZGF0ZWRQYXRoc0J5QXJyYXlGaWx0ZXIgPSByZXF1aXJlKCcuLi91cGRhdGUvdXBkYXRlZFBhdGhzQnlBcnJheUZpbHRlcicpO1xuXG4vKipcbiAqIExpa2UgYHNjaGVtYS5wYXRoKClgLCBleGNlcHQgd2l0aCBhIGRvY3VtZW50LCBiZWNhdXNlIGltcG9zc2libGUgdG9cbiAqIGRldGVybWluZSBwYXRoIHR5cGUgd2l0aG91dCBrbm93aW5nIHRoZSBlbWJlZGRlZCBkaXNjcmltaW5hdG9yIGtleS5cbiAqIEBwYXJhbSB7U2NoZW1hfSBzY2hlbWFcbiAqIEBwYXJhbSB7T2JqZWN0fSBbdXBkYXRlXVxuICogQHBhcmFtIHtPYmplY3R9IFtmaWx0ZXJdXG4gKiBAcGFyYW0ge1N0cmluZ30gcGF0aFxuICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXVxuICogQGFwaSBwcml2YXRlXG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBnZXRFbWJlZGRlZERpc2NyaW1pbmF0b3JQYXRoKHNjaGVtYSwgdXBkYXRlLCBmaWx0ZXIsIHBhdGgsIG9wdGlvbnMpIHtcbiAgY29uc3QgcGFydHMgPSBwYXRoLnNwbGl0KCcuJyk7XG4gIGxldCBzY2hlbWF0eXBlID0gbnVsbDtcbiAgbGV0IHR5cGUgPSAnYWRob2NPclVuZGVmaW5lZCc7XG5cbiAgZmlsdGVyID0gZmlsdGVyIHx8IHt9O1xuICB1cGRhdGUgPSB1cGRhdGUgfHwge307XG4gIGNvbnN0IGFycmF5RmlsdGVycyA9IG9wdGlvbnMgIT0gbnVsbCAmJiBBcnJheS5pc0FycmF5KG9wdGlvbnMuYXJyYXlGaWx0ZXJzKSA/XG4gICAgb3B0aW9ucy5hcnJheUZpbHRlcnMgOiBbXTtcbiAgY29uc3QgdXBkYXRlZFBhdGhzQnlGaWx0ZXIgPSB1cGRhdGVkUGF0aHNCeUFycmF5RmlsdGVyKHVwZGF0ZSk7XG5cbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBwYXJ0cy5sZW5ndGg7ICsraSkge1xuICAgIGNvbnN0IHN1YnBhdGggPSBjbGVhblBvc2l0aW9uYWxPcGVyYXRvcnMocGFydHMuc2xpY2UoMCwgaSArIDEpLmpvaW4oJy4nKSk7XG4gICAgc2NoZW1hdHlwZSA9IHNjaGVtYS5wYXRoKHN1YnBhdGgpO1xuICAgIGlmIChzY2hlbWF0eXBlID09IG51bGwpIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIHR5cGUgPSBzY2hlbWEucGF0aFR5cGUoc3VicGF0aCk7XG4gICAgaWYgKChzY2hlbWF0eXBlLiRpc1NpbmdsZU5lc3RlZCB8fCBzY2hlbWF0eXBlLiRpc01vbmdvb3NlRG9jdW1lbnRBcnJheUVsZW1lbnQpICYmXG4gICAgICAgIHNjaGVtYXR5cGUuc2NoZW1hLmRpc2NyaW1pbmF0b3JzICE9IG51bGwpIHtcbiAgICAgIGNvbnN0IGtleSA9IGdldChzY2hlbWF0eXBlLCAnc2NoZW1hLm9wdGlvbnMuZGlzY3JpbWluYXRvcktleScpO1xuICAgICAgY29uc3QgZGlzY3JpbWluYXRvclZhbHVlUGF0aCA9IHN1YnBhdGggKyAnLicgKyBrZXk7XG4gICAgICBjb25zdCBkaXNjcmltaW5hdG9yRmlsdGVyUGF0aCA9XG4gICAgICAgIGRpc2NyaW1pbmF0b3JWYWx1ZVBhdGgucmVwbGFjZSgvXFwuXFxkK1xcLi8sICcuJyk7XG4gICAgICBsZXQgZGlzY3JpbWluYXRvcktleSA9IG51bGw7XG5cbiAgICAgIGlmIChkaXNjcmltaW5hdG9yVmFsdWVQYXRoIGluIGZpbHRlcikge1xuICAgICAgICBkaXNjcmltaW5hdG9yS2V5ID0gZmlsdGVyW2Rpc2NyaW1pbmF0b3JWYWx1ZVBhdGhdO1xuICAgICAgfVxuICAgICAgaWYgKGRpc2NyaW1pbmF0b3JGaWx0ZXJQYXRoIGluIGZpbHRlcikge1xuICAgICAgICBkaXNjcmltaW5hdG9yS2V5ID0gZmlsdGVyW2Rpc2NyaW1pbmF0b3JGaWx0ZXJQYXRoXTtcbiAgICAgIH1cblxuICAgICAgY29uc3Qgd3JhcHBlclBhdGggPSBzdWJwYXRoLnJlcGxhY2UoL1xcLlxcZCskLywgJycpO1xuICAgICAgaWYgKHNjaGVtYXR5cGUuJGlzTW9uZ29vc2VEb2N1bWVudEFycmF5RWxlbWVudCAmJlxuICAgICAgICAgIGdldChmaWx0ZXJbd3JhcHBlclBhdGhdLCAnJGVsZW1NYXRjaC4nICsga2V5KSAhPSBudWxsKSB7XG4gICAgICAgIGRpc2NyaW1pbmF0b3JLZXkgPSBmaWx0ZXJbd3JhcHBlclBhdGhdLiRlbGVtTWF0Y2hba2V5XTtcbiAgICAgIH1cblxuICAgICAgaWYgKGRpc2NyaW1pbmF0b3JWYWx1ZVBhdGggaW4gdXBkYXRlKSB7XG4gICAgICAgIGRpc2NyaW1pbmF0b3JLZXkgPSB1cGRhdGVbZGlzY3JpbWluYXRvclZhbHVlUGF0aF07XG4gICAgICB9XG5cbiAgICAgIGZvciAoY29uc3QgZmlsdGVyS2V5IG9mIE9iamVjdC5rZXlzKHVwZGF0ZWRQYXRoc0J5RmlsdGVyKSkge1xuICAgICAgICBjb25zdCBzY2hlbWFLZXkgPSB1cGRhdGVkUGF0aHNCeUZpbHRlcltmaWx0ZXJLZXldICsgJy4nICsga2V5O1xuICAgICAgICBjb25zdCBhcnJheUZpbHRlcktleSA9IGZpbHRlcktleSArICcuJyArIGtleTtcbiAgICAgICAgaWYgKHNjaGVtYUtleSA9PT0gZGlzY3JpbWluYXRvckZpbHRlclBhdGgpIHtcbiAgICAgICAgICBjb25zdCBmaWx0ZXIgPSBhcnJheUZpbHRlcnMuZmluZChmaWx0ZXIgPT4gZmlsdGVyLmhhc093blByb3BlcnR5KGFycmF5RmlsdGVyS2V5KSk7XG4gICAgICAgICAgaWYgKGZpbHRlciAhPSBudWxsKSB7XG4gICAgICAgICAgICBkaXNjcmltaW5hdG9yS2V5ID0gZmlsdGVyW2FycmF5RmlsdGVyS2V5XTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKGRpc2NyaW1pbmF0b3JLZXkgPT0gbnVsbCkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgY29uc3QgZGlzY3JpbWluYXRvciA9IGdldERpc2NyaW1pbmF0b3JCeVZhbHVlKHNjaGVtYXR5cGUuY2FzdGVyLmRpc2NyaW1pbmF0b3JzLCBkaXNjcmltaW5hdG9yS2V5KTtcbiAgICAgIGNvbnN0IGRpc2NyaW1pbmF0b3JTY2hlbWEgPSBkaXNjcmltaW5hdG9yICYmIGRpc2NyaW1pbmF0b3Iuc2NoZW1hO1xuICAgICAgaWYgKGRpc2NyaW1pbmF0b3JTY2hlbWEgPT0gbnVsbCkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgY29uc3QgcmVzdCA9IHBhcnRzLnNsaWNlKGkgKyAxKS5qb2luKCcuJyk7XG4gICAgICBzY2hlbWF0eXBlID0gZGlzY3JpbWluYXRvclNjaGVtYS5wYXRoKHJlc3QpO1xuICAgICAgaWYgKHNjaGVtYXR5cGUgIT0gbnVsbCkge1xuICAgICAgICB0eXBlID0gZGlzY3JpbWluYXRvclNjaGVtYS5fZ2V0UGF0aFR5cGUocmVzdCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiB7IHR5cGU6IHR5cGUsIHNjaGVtYXR5cGU6IHNjaGVtYXR5cGUgfTtcbn07XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/mongoose/lib/helpers/query/getEmbeddedDiscriminatorPath.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/mongoose/lib/helpers/query/handleImmutable.js":
/*!********************************************************************!*\
  !*** ./node_modules/mongoose/lib/helpers/query/handleImmutable.js ***!
  \********************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\n\nconst StrictModeError = __webpack_require__(/*! ../../error/strict */ \"(ssr)/./node_modules/mongoose/lib/error/strict.js\");\n\nmodule.exports = function handleImmutable(schematype, strict, obj, key, fullPath, ctx) {\n  if (schematype == null || !schematype.options || !schematype.options.immutable) {\n    return false;\n  }\n  let immutable = schematype.options.immutable;\n\n  if (typeof immutable === 'function') {\n    immutable = immutable.call(ctx, ctx);\n  }\n  if (!immutable) {\n    return false;\n  }\n\n  if (strict === false) {\n    return false;\n  }\n  if (strict === 'throw') {\n    throw new StrictModeError(null,\n      `Field ${fullPath} is immutable and strict = 'throw'`);\n  }\n\n  delete obj[key];\n  return true;\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbW9uZ29vc2UvbGliL2hlbHBlcnMvcXVlcnkvaGFuZGxlSW1tdXRhYmxlLmpzIiwibWFwcGluZ3MiOiJBQUFhOztBQUViLHdCQUF3QixtQkFBTyxDQUFDLDZFQUFvQjs7QUFFcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsVUFBVTtBQUN6Qjs7QUFFQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9hcHAxLy4vbm9kZV9tb2R1bGVzL21vbmdvb3NlL2xpYi9oZWxwZXJzL3F1ZXJ5L2hhbmRsZUltbXV0YWJsZS5qcz9iNzgzIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxuY29uc3QgU3RyaWN0TW9kZUVycm9yID0gcmVxdWlyZSgnLi4vLi4vZXJyb3Ivc3RyaWN0Jyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gaGFuZGxlSW1tdXRhYmxlKHNjaGVtYXR5cGUsIHN0cmljdCwgb2JqLCBrZXksIGZ1bGxQYXRoLCBjdHgpIHtcbiAgaWYgKHNjaGVtYXR5cGUgPT0gbnVsbCB8fCAhc2NoZW1hdHlwZS5vcHRpb25zIHx8ICFzY2hlbWF0eXBlLm9wdGlvbnMuaW1tdXRhYmxlKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGxldCBpbW11dGFibGUgPSBzY2hlbWF0eXBlLm9wdGlvbnMuaW1tdXRhYmxlO1xuXG4gIGlmICh0eXBlb2YgaW1tdXRhYmxlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgaW1tdXRhYmxlID0gaW1tdXRhYmxlLmNhbGwoY3R4LCBjdHgpO1xuICB9XG4gIGlmICghaW1tdXRhYmxlKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgaWYgKHN0cmljdCA9PT0gZmFsc2UpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgaWYgKHN0cmljdCA9PT0gJ3Rocm93Jykge1xuICAgIHRocm93IG5ldyBTdHJpY3RNb2RlRXJyb3IobnVsbCxcbiAgICAgIGBGaWVsZCAke2Z1bGxQYXRofSBpcyBpbW11dGFibGUgYW5kIHN0cmljdCA9ICd0aHJvdydgKTtcbiAgfVxuXG4gIGRlbGV0ZSBvYmpba2V5XTtcbiAgcmV0dXJuIHRydWU7XG59O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/mongoose/lib/helpers/query/handleImmutable.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/mongoose/lib/helpers/query/handleReadPreferenceAliases.js":
/*!********************************************************************************!*\
  !*** ./node_modules/mongoose/lib/helpers/query/handleReadPreferenceAliases.js ***!
  \********************************************************************************/
/***/ ((module) => {

eval("\n\nmodule.exports = function handleReadPreferenceAliases(pref) {\n  switch (pref) {\n    case 'p':\n      pref = 'primary';\n      break;\n    case 'pp':\n      pref = 'primaryPreferred';\n      break;\n    case 's':\n      pref = 'secondary';\n      break;\n    case 'sp':\n      pref = 'secondaryPreferred';\n      break;\n    case 'n':\n      pref = 'nearest';\n      break;\n  }\n\n  return pref;\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbW9uZ29vc2UvbGliL2hlbHBlcnMvcXVlcnkvaGFuZGxlUmVhZFByZWZlcmVuY2VBbGlhc2VzLmpzIiwibWFwcGluZ3MiOiJBQUFhOztBQUViO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vYXBwMS8uL25vZGVfbW9kdWxlcy9tb25nb29zZS9saWIvaGVscGVycy9xdWVyeS9oYW5kbGVSZWFkUHJlZmVyZW5jZUFsaWFzZXMuanM/ZjViMCJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gaGFuZGxlUmVhZFByZWZlcmVuY2VBbGlhc2VzKHByZWYpIHtcbiAgc3dpdGNoIChwcmVmKSB7XG4gICAgY2FzZSAncCc6XG4gICAgICBwcmVmID0gJ3ByaW1hcnknO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAncHAnOlxuICAgICAgcHJlZiA9ICdwcmltYXJ5UHJlZmVycmVkJztcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgJ3MnOlxuICAgICAgcHJlZiA9ICdzZWNvbmRhcnknO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAnc3AnOlxuICAgICAgcHJlZiA9ICdzZWNvbmRhcnlQcmVmZXJyZWQnO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAnbic6XG4gICAgICBwcmVmID0gJ25lYXJlc3QnO1xuICAgICAgYnJlYWs7XG4gIH1cblxuICByZXR1cm4gcHJlZjtcbn07XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/mongoose/lib/helpers/query/handleReadPreferenceAliases.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/mongoose/lib/helpers/query/hasDollarKeys.js":
/*!******************************************************************!*\
  !*** ./node_modules/mongoose/lib/helpers/query/hasDollarKeys.js ***!
  \******************************************************************/
/***/ ((module) => {

eval("\n\n/*!\n * ignore\n */\n\nmodule.exports = function hasDollarKeys(obj) {\n\n  if (typeof obj !== 'object' || obj === null) {\n    return false;\n  }\n\n  const keys = Object.keys(obj);\n  const len = keys.length;\n\n  for (let i = 0; i < len; ++i) {\n    if (keys[i][0] === '$') {\n      return true;\n    }\n  }\n\n  return false;\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbW9uZ29vc2UvbGliL2hlbHBlcnMvcXVlcnkvaGFzRG9sbGFyS2V5cy5qcyIsIm1hcHBpbmdzIjoiQUFBYTs7QUFFYjtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsa0JBQWtCLFNBQVM7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL2FwcDEvLi9ub2RlX21vZHVsZXMvbW9uZ29vc2UvbGliL2hlbHBlcnMvcXVlcnkvaGFzRG9sbGFyS2V5cy5qcz8wYmVjIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxuLyohXG4gKiBpZ25vcmVcbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGhhc0RvbGxhcktleXMob2JqKSB7XG5cbiAgaWYgKHR5cGVvZiBvYmogIT09ICdvYmplY3QnIHx8IG9iaiA9PT0gbnVsbCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIGNvbnN0IGtleXMgPSBPYmplY3Qua2V5cyhvYmopO1xuICBjb25zdCBsZW4gPSBrZXlzLmxlbmd0aDtcblxuICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbjsgKytpKSB7XG4gICAgaWYgKGtleXNbaV1bMF0gPT09ICckJykge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGZhbHNlO1xufTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/mongoose/lib/helpers/query/hasDollarKeys.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/mongoose/lib/helpers/query/isOperator.js":
/*!***************************************************************!*\
  !*** ./node_modules/mongoose/lib/helpers/query/isOperator.js ***!
  \***************************************************************/
/***/ ((module) => {

eval("\n\nconst specialKeys = new Set([\n  '$ref',\n  '$id',\n  '$db'\n]);\n\nmodule.exports = function isOperator(path) {\n  return (\n    path[0] === '$' &&\n    !specialKeys.has(path)\n  );\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbW9uZ29vc2UvbGliL2hlbHBlcnMvcXVlcnkvaXNPcGVyYXRvci5qcyIsIm1hcHBpbmdzIjoiQUFBYTs7QUFFYjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL2FwcDEvLi9ub2RlX21vZHVsZXMvbW9uZ29vc2UvbGliL2hlbHBlcnMvcXVlcnkvaXNPcGVyYXRvci5qcz9hNDIyIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxuY29uc3Qgc3BlY2lhbEtleXMgPSBuZXcgU2V0KFtcbiAgJyRyZWYnLFxuICAnJGlkJyxcbiAgJyRkYidcbl0pO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGlzT3BlcmF0b3IocGF0aCkge1xuICByZXR1cm4gKFxuICAgIHBhdGhbMF0gPT09ICckJyAmJlxuICAgICFzcGVjaWFsS2V5cy5oYXMocGF0aClcbiAgKTtcbn07XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/mongoose/lib/helpers/query/isOperator.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/mongoose/lib/helpers/query/sanitizeFilter.js":
/*!*******************************************************************!*\
  !*** ./node_modules/mongoose/lib/helpers/query/sanitizeFilter.js ***!
  \*******************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\n\nconst hasDollarKeys = __webpack_require__(/*! ./hasDollarKeys */ \"(ssr)/./node_modules/mongoose/lib/helpers/query/hasDollarKeys.js\");\nconst { trustedSymbol } = __webpack_require__(/*! ./trusted */ \"(ssr)/./node_modules/mongoose/lib/helpers/query/trusted.js\");\n\nmodule.exports = function sanitizeFilter(filter) {\n  if (filter == null || typeof filter !== 'object') {\n    return filter;\n  }\n  if (Array.isArray(filter)) {\n    for (const subfilter of filter) {\n      sanitizeFilter(subfilter);\n    }\n    return filter;\n  }\n\n  const filterKeys = Object.keys(filter);\n  for (const key of filterKeys) {\n    const value = filter[key];\n    if (value != null && value[trustedSymbol]) {\n      continue;\n    }\n    if (key === '$and' || key === '$or') {\n      sanitizeFilter(value);\n      continue;\n    }\n\n    if (hasDollarKeys(value)) {\n      const keys = Object.keys(value);\n      if (keys.length === 1 && keys[0] === '$eq') {\n        continue;\n      }\n      filter[key] = { $eq: filter[key] };\n    }\n  }\n\n  return filter;\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbW9uZ29vc2UvbGliL2hlbHBlcnMvcXVlcnkvc2FuaXRpemVGaWx0ZXIuanMiLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWIsc0JBQXNCLG1CQUFPLENBQUMseUZBQWlCO0FBQy9DLFFBQVEsZ0JBQWdCLEVBQUUsbUJBQU8sQ0FBQyw2RUFBVzs7QUFFN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQjtBQUN0QjtBQUNBOztBQUVBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9hcHAxLy4vbm9kZV9tb2R1bGVzL21vbmdvb3NlL2xpYi9oZWxwZXJzL3F1ZXJ5L3Nhbml0aXplRmlsdGVyLmpzPzhmODYiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG5jb25zdCBoYXNEb2xsYXJLZXlzID0gcmVxdWlyZSgnLi9oYXNEb2xsYXJLZXlzJyk7XG5jb25zdCB7IHRydXN0ZWRTeW1ib2wgfSA9IHJlcXVpcmUoJy4vdHJ1c3RlZCcpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIHNhbml0aXplRmlsdGVyKGZpbHRlcikge1xuICBpZiAoZmlsdGVyID09IG51bGwgfHwgdHlwZW9mIGZpbHRlciAhPT0gJ29iamVjdCcpIHtcbiAgICByZXR1cm4gZmlsdGVyO1xuICB9XG4gIGlmIChBcnJheS5pc0FycmF5KGZpbHRlcikpIHtcbiAgICBmb3IgKGNvbnN0IHN1YmZpbHRlciBvZiBmaWx0ZXIpIHtcbiAgICAgIHNhbml0aXplRmlsdGVyKHN1YmZpbHRlcik7XG4gICAgfVxuICAgIHJldHVybiBmaWx0ZXI7XG4gIH1cblxuICBjb25zdCBmaWx0ZXJLZXlzID0gT2JqZWN0LmtleXMoZmlsdGVyKTtcbiAgZm9yIChjb25zdCBrZXkgb2YgZmlsdGVyS2V5cykge1xuICAgIGNvbnN0IHZhbHVlID0gZmlsdGVyW2tleV07XG4gICAgaWYgKHZhbHVlICE9IG51bGwgJiYgdmFsdWVbdHJ1c3RlZFN5bWJvbF0pIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICBpZiAoa2V5ID09PSAnJGFuZCcgfHwga2V5ID09PSAnJG9yJykge1xuICAgICAgc2FuaXRpemVGaWx0ZXIodmFsdWUpO1xuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgaWYgKGhhc0RvbGxhcktleXModmFsdWUpKSB7XG4gICAgICBjb25zdCBrZXlzID0gT2JqZWN0LmtleXModmFsdWUpO1xuICAgICAgaWYgKGtleXMubGVuZ3RoID09PSAxICYmIGtleXNbMF0gPT09ICckZXEnKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgZmlsdGVyW2tleV0gPSB7ICRlcTogZmlsdGVyW2tleV0gfTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZmlsdGVyO1xufTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/mongoose/lib/helpers/query/sanitizeFilter.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/mongoose/lib/helpers/query/sanitizeProjection.js":
/*!***********************************************************************!*\
  !*** ./node_modules/mongoose/lib/helpers/query/sanitizeProjection.js ***!
  \***********************************************************************/
/***/ ((module) => {

eval("\n\nmodule.exports = function sanitizeProjection(projection) {\n  if (projection == null) {\n    return;\n  }\n\n  const keys = Object.keys(projection);\n  for (let i = 0; i < keys.length; ++i) {\n    if (typeof projection[keys[i]] === 'string') {\n      projection[keys[i]] = 1;\n    }\n  }\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbW9uZ29vc2UvbGliL2hlbHBlcnMvcXVlcnkvc2FuaXRpemVQcm9qZWN0aW9uLmpzIiwibWFwcGluZ3MiOiJBQUFhOztBQUViO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0Esa0JBQWtCLGlCQUFpQjtBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vYXBwMS8uL25vZGVfbW9kdWxlcy9tb25nb29zZS9saWIvaGVscGVycy9xdWVyeS9zYW5pdGl6ZVByb2plY3Rpb24uanM/MDM1ZCJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gc2FuaXRpemVQcm9qZWN0aW9uKHByb2plY3Rpb24pIHtcbiAgaWYgKHByb2plY3Rpb24gPT0gbnVsbCkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIGNvbnN0IGtleXMgPSBPYmplY3Qua2V5cyhwcm9qZWN0aW9uKTtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBrZXlzLmxlbmd0aDsgKytpKSB7XG4gICAgaWYgKHR5cGVvZiBwcm9qZWN0aW9uW2tleXNbaV1dID09PSAnc3RyaW5nJykge1xuICAgICAgcHJvamVjdGlvbltrZXlzW2ldXSA9IDE7XG4gICAgfVxuICB9XG59O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/mongoose/lib/helpers/query/sanitizeProjection.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/mongoose/lib/helpers/query/selectPopulatedFields.js":
/*!**************************************************************************!*\
  !*** ./node_modules/mongoose/lib/helpers/query/selectPopulatedFields.js ***!
  \**************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\n\nconst isExclusive = __webpack_require__(/*! ../projection/isExclusive */ \"(ssr)/./node_modules/mongoose/lib/helpers/projection/isExclusive.js\");\nconst isInclusive = __webpack_require__(/*! ../projection/isInclusive */ \"(ssr)/./node_modules/mongoose/lib/helpers/projection/isInclusive.js\");\n\n/*!\n * ignore\n */\n\nmodule.exports = function selectPopulatedFields(fields, userProvidedFields, populateOptions) {\n  if (populateOptions == null) {\n    return;\n  }\n\n  const paths = Object.keys(populateOptions);\n  userProvidedFields = userProvidedFields || {};\n  if (isInclusive(fields)) {\n    for (const path of paths) {\n      if (!isPathInFields(userProvidedFields, path)) {\n        fields[path] = 1;\n      } else if (userProvidedFields[path] === 0) {\n        delete fields[path];\n      }\n\n      const refPath = populateOptions[path]?.refPath;\n      if (typeof refPath === 'string') {\n        if (!isPathInFields(userProvidedFields, refPath)) {\n          fields[refPath] = 1;\n        } else if (userProvidedFields[refPath] === 0) {\n          delete fields[refPath];\n        }\n      }\n    }\n  } else if (isExclusive(fields)) {\n    for (const path of paths) {\n      if (userProvidedFields[path] == null) {\n        delete fields[path];\n      }\n      const refPath = populateOptions[path]?.refPath;\n      if (typeof refPath === 'string' && userProvidedFields[refPath] == null) {\n        delete fields[refPath];\n      }\n    }\n  }\n};\n\n/*!\n * ignore\n */\n\nfunction isPathInFields(userProvidedFields, path) {\n  const pieces = path.split('.');\n  const len = pieces.length;\n  let cur = pieces[0];\n  for (let i = 1; i < len; ++i) {\n    if (userProvidedFields[cur] != null || userProvidedFields[cur + '.$'] != null) {\n      return true;\n    }\n    cur += '.' + pieces[i];\n  }\n  return userProvidedFields[cur] != null || userProvidedFields[cur + '.$'] != null;\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbW9uZ29vc2UvbGliL2hlbHBlcnMvcXVlcnkvc2VsZWN0UG9wdWxhdGVkRmllbGRzLmpzIiwibWFwcGluZ3MiOiJBQUFhOztBQUViLG9CQUFvQixtQkFBTyxDQUFDLHNHQUEyQjtBQUN2RCxvQkFBb0IsbUJBQU8sQ0FBQyxzR0FBMkI7O0FBRXZEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixTQUFTO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vYXBwMS8uL25vZGVfbW9kdWxlcy9tb25nb29zZS9saWIvaGVscGVycy9xdWVyeS9zZWxlY3RQb3B1bGF0ZWRGaWVsZHMuanM/N2YzZiJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbmNvbnN0IGlzRXhjbHVzaXZlID0gcmVxdWlyZSgnLi4vcHJvamVjdGlvbi9pc0V4Y2x1c2l2ZScpO1xuY29uc3QgaXNJbmNsdXNpdmUgPSByZXF1aXJlKCcuLi9wcm9qZWN0aW9uL2lzSW5jbHVzaXZlJyk7XG5cbi8qIVxuICogaWdub3JlXG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBzZWxlY3RQb3B1bGF0ZWRGaWVsZHMoZmllbGRzLCB1c2VyUHJvdmlkZWRGaWVsZHMsIHBvcHVsYXRlT3B0aW9ucykge1xuICBpZiAocG9wdWxhdGVPcHRpb25zID09IG51bGwpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICBjb25zdCBwYXRocyA9IE9iamVjdC5rZXlzKHBvcHVsYXRlT3B0aW9ucyk7XG4gIHVzZXJQcm92aWRlZEZpZWxkcyA9IHVzZXJQcm92aWRlZEZpZWxkcyB8fCB7fTtcbiAgaWYgKGlzSW5jbHVzaXZlKGZpZWxkcykpIHtcbiAgICBmb3IgKGNvbnN0IHBhdGggb2YgcGF0aHMpIHtcbiAgICAgIGlmICghaXNQYXRoSW5GaWVsZHModXNlclByb3ZpZGVkRmllbGRzLCBwYXRoKSkge1xuICAgICAgICBmaWVsZHNbcGF0aF0gPSAxO1xuICAgICAgfSBlbHNlIGlmICh1c2VyUHJvdmlkZWRGaWVsZHNbcGF0aF0gPT09IDApIHtcbiAgICAgICAgZGVsZXRlIGZpZWxkc1twYXRoXTtcbiAgICAgIH1cblxuICAgICAgY29uc3QgcmVmUGF0aCA9IHBvcHVsYXRlT3B0aW9uc1twYXRoXT8ucmVmUGF0aDtcbiAgICAgIGlmICh0eXBlb2YgcmVmUGF0aCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgaWYgKCFpc1BhdGhJbkZpZWxkcyh1c2VyUHJvdmlkZWRGaWVsZHMsIHJlZlBhdGgpKSB7XG4gICAgICAgICAgZmllbGRzW3JlZlBhdGhdID0gMTtcbiAgICAgICAgfSBlbHNlIGlmICh1c2VyUHJvdmlkZWRGaWVsZHNbcmVmUGF0aF0gPT09IDApIHtcbiAgICAgICAgICBkZWxldGUgZmllbGRzW3JlZlBhdGhdO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9IGVsc2UgaWYgKGlzRXhjbHVzaXZlKGZpZWxkcykpIHtcbiAgICBmb3IgKGNvbnN0IHBhdGggb2YgcGF0aHMpIHtcbiAgICAgIGlmICh1c2VyUHJvdmlkZWRGaWVsZHNbcGF0aF0gPT0gbnVsbCkge1xuICAgICAgICBkZWxldGUgZmllbGRzW3BhdGhdO1xuICAgICAgfVxuICAgICAgY29uc3QgcmVmUGF0aCA9IHBvcHVsYXRlT3B0aW9uc1twYXRoXT8ucmVmUGF0aDtcbiAgICAgIGlmICh0eXBlb2YgcmVmUGF0aCA9PT0gJ3N0cmluZycgJiYgdXNlclByb3ZpZGVkRmllbGRzW3JlZlBhdGhdID09IG51bGwpIHtcbiAgICAgICAgZGVsZXRlIGZpZWxkc1tyZWZQYXRoXTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn07XG5cbi8qIVxuICogaWdub3JlXG4gKi9cblxuZnVuY3Rpb24gaXNQYXRoSW5GaWVsZHModXNlclByb3ZpZGVkRmllbGRzLCBwYXRoKSB7XG4gIGNvbnN0IHBpZWNlcyA9IHBhdGguc3BsaXQoJy4nKTtcbiAgY29uc3QgbGVuID0gcGllY2VzLmxlbmd0aDtcbiAgbGV0IGN1ciA9IHBpZWNlc1swXTtcbiAgZm9yIChsZXQgaSA9IDE7IGkgPCBsZW47ICsraSkge1xuICAgIGlmICh1c2VyUHJvdmlkZWRGaWVsZHNbY3VyXSAhPSBudWxsIHx8IHVzZXJQcm92aWRlZEZpZWxkc1tjdXIgKyAnLiQnXSAhPSBudWxsKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgY3VyICs9ICcuJyArIHBpZWNlc1tpXTtcbiAgfVxuICByZXR1cm4gdXNlclByb3ZpZGVkRmllbGRzW2N1cl0gIT0gbnVsbCB8fCB1c2VyUHJvdmlkZWRGaWVsZHNbY3VyICsgJy4kJ10gIT0gbnVsbDtcbn1cbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/mongoose/lib/helpers/query/selectPopulatedFields.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/mongoose/lib/helpers/query/trusted.js":
/*!************************************************************!*\
  !*** ./node_modules/mongoose/lib/helpers/query/trusted.js ***!
  \************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\n\nconst trustedSymbol = Symbol('mongoose#trustedSymbol');\n\nexports.trustedSymbol = trustedSymbol;\n\nexports.trusted = function trusted(obj) {\n  if (obj == null || typeof obj !== 'object') {\n    return obj;\n  }\n  obj[trustedSymbol] = true;\n  return obj;\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbW9uZ29vc2UvbGliL2hlbHBlcnMvcXVlcnkvdHJ1c3RlZC5qcyIsIm1hcHBpbmdzIjoiQUFBYTs7QUFFYjs7QUFFQSxxQkFBcUI7O0FBRXJCLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9hcHAxLy4vbm9kZV9tb2R1bGVzL21vbmdvb3NlL2xpYi9oZWxwZXJzL3F1ZXJ5L3RydXN0ZWQuanM/NDZhYyJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbmNvbnN0IHRydXN0ZWRTeW1ib2wgPSBTeW1ib2woJ21vbmdvb3NlI3RydXN0ZWRTeW1ib2wnKTtcblxuZXhwb3J0cy50cnVzdGVkU3ltYm9sID0gdHJ1c3RlZFN5bWJvbDtcblxuZXhwb3J0cy50cnVzdGVkID0gZnVuY3Rpb24gdHJ1c3RlZChvYmopIHtcbiAgaWYgKG9iaiA9PSBudWxsIHx8IHR5cGVvZiBvYmogIT09ICdvYmplY3QnKSB7XG4gICAgcmV0dXJuIG9iajtcbiAgfVxuICBvYmpbdHJ1c3RlZFN5bWJvbF0gPSB0cnVlO1xuICByZXR1cm4gb2JqO1xufTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/mongoose/lib/helpers/query/trusted.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/mongoose/lib/helpers/query/validOps.js":
/*!*************************************************************!*\
  !*** ./node_modules/mongoose/lib/helpers/query/validOps.js ***!
  \*************************************************************/
/***/ ((module) => {

eval("\n\nmodule.exports = Object.freeze([\n  // Read\n  'countDocuments',\n  'distinct',\n  'estimatedDocumentCount',\n  'find',\n  'findOne',\n  // Update\n  'findOneAndReplace',\n  'findOneAndUpdate',\n  'replaceOne',\n  'updateMany',\n  'updateOne',\n  // Delete\n  'deleteMany',\n  'deleteOne',\n  'findOneAndDelete'\n]);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbW9uZ29vc2UvbGliL2hlbHBlcnMvcXVlcnkvdmFsaWRPcHMuanMiLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vYXBwMS8uL25vZGVfbW9kdWxlcy9tb25nb29zZS9saWIvaGVscGVycy9xdWVyeS92YWxpZE9wcy5qcz8wNTJiIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxubW9kdWxlLmV4cG9ydHMgPSBPYmplY3QuZnJlZXplKFtcbiAgLy8gUmVhZFxuICAnY291bnREb2N1bWVudHMnLFxuICAnZGlzdGluY3QnLFxuICAnZXN0aW1hdGVkRG9jdW1lbnRDb3VudCcsXG4gICdmaW5kJyxcbiAgJ2ZpbmRPbmUnLFxuICAvLyBVcGRhdGVcbiAgJ2ZpbmRPbmVBbmRSZXBsYWNlJyxcbiAgJ2ZpbmRPbmVBbmRVcGRhdGUnLFxuICAncmVwbGFjZU9uZScsXG4gICd1cGRhdGVNYW55JyxcbiAgJ3VwZGF0ZU9uZScsXG4gIC8vIERlbGV0ZVxuICAnZGVsZXRlTWFueScsXG4gICdkZWxldGVPbmUnLFxuICAnZmluZE9uZUFuZERlbGV0ZSdcbl0pO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/mongoose/lib/helpers/query/validOps.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/mongoose/lib/helpers/schema/addAutoId.js":
/*!***************************************************************!*\
  !*** ./node_modules/mongoose/lib/helpers/schema/addAutoId.js ***!
  \***************************************************************/
/***/ ((module) => {

eval("\n\nmodule.exports = function addAutoId(schema) {\n  const _obj = { _id: { auto: true } };\n  _obj._id[schema.options.typeKey] = 'ObjectId';\n  schema.add(_obj);\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbW9uZ29vc2UvbGliL2hlbHBlcnMvc2NoZW1hL2FkZEF1dG9JZC5qcyIsIm1hcHBpbmdzIjoiQUFBYTs7QUFFYjtBQUNBLGlCQUFpQixPQUFPO0FBQ3hCO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL2FwcDEvLi9ub2RlX21vZHVsZXMvbW9uZ29vc2UvbGliL2hlbHBlcnMvc2NoZW1hL2FkZEF1dG9JZC5qcz81NDljIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBhZGRBdXRvSWQoc2NoZW1hKSB7XG4gIGNvbnN0IF9vYmogPSB7IF9pZDogeyBhdXRvOiB0cnVlIH0gfTtcbiAgX29iai5faWRbc2NoZW1hLm9wdGlvbnMudHlwZUtleV0gPSAnT2JqZWN0SWQnO1xuICBzY2hlbWEuYWRkKF9vYmopO1xufTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/mongoose/lib/helpers/schema/addAutoId.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/mongoose/lib/helpers/schema/applyBuiltinPlugins.js":
/*!*************************************************************************!*\
  !*** ./node_modules/mongoose/lib/helpers/schema/applyBuiltinPlugins.js ***!
  \*************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\n\nconst builtinPlugins = __webpack_require__(/*! ../../plugins */ \"(ssr)/./node_modules/mongoose/lib/plugins/index.js\");\n\nmodule.exports = function applyBuiltinPlugins(schema) {\n  for (const plugin of Object.values(builtinPlugins)) {\n    plugin(schema, { deduplicate: true });\n  }\n  schema.plugins = Object.values(builtinPlugins).\n    map(fn => ({ fn, opts: { deduplicate: true } })).\n    concat(schema.plugins);\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbW9uZ29vc2UvbGliL2hlbHBlcnMvc2NoZW1hL2FwcGx5QnVpbHRpblBsdWdpbnMuanMiLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWIsdUJBQXVCLG1CQUFPLENBQUMseUVBQWU7O0FBRTlDO0FBQ0E7QUFDQSxxQkFBcUIsbUJBQW1CO0FBQ3hDO0FBQ0E7QUFDQSxpQkFBaUIsWUFBWSxxQkFBcUI7QUFDbEQ7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL2FwcDEvLi9ub2RlX21vZHVsZXMvbW9uZ29vc2UvbGliL2hlbHBlcnMvc2NoZW1hL2FwcGx5QnVpbHRpblBsdWdpbnMuanM/MTRjZCJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbmNvbnN0IGJ1aWx0aW5QbHVnaW5zID0gcmVxdWlyZSgnLi4vLi4vcGx1Z2lucycpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGFwcGx5QnVpbHRpblBsdWdpbnMoc2NoZW1hKSB7XG4gIGZvciAoY29uc3QgcGx1Z2luIG9mIE9iamVjdC52YWx1ZXMoYnVpbHRpblBsdWdpbnMpKSB7XG4gICAgcGx1Z2luKHNjaGVtYSwgeyBkZWR1cGxpY2F0ZTogdHJ1ZSB9KTtcbiAgfVxuICBzY2hlbWEucGx1Z2lucyA9IE9iamVjdC52YWx1ZXMoYnVpbHRpblBsdWdpbnMpLlxuICAgIG1hcChmbiA9PiAoeyBmbiwgb3B0czogeyBkZWR1cGxpY2F0ZTogdHJ1ZSB9IH0pKS5cbiAgICBjb25jYXQoc2NoZW1hLnBsdWdpbnMpO1xufTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/mongoose/lib/helpers/schema/applyBuiltinPlugins.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/mongoose/lib/helpers/schema/applyPlugins.js":
/*!******************************************************************!*\
  !*** ./node_modules/mongoose/lib/helpers/schema/applyPlugins.js ***!
  \******************************************************************/
/***/ ((module) => {

eval("\n\nmodule.exports = function applyPlugins(schema, plugins, options, cacheKey) {\n  if (schema[cacheKey]) {\n    return;\n  }\n  schema[cacheKey] = true;\n\n  if (!options || !options.skipTopLevel) {\n    let pluginTags = null;\n    for (const plugin of plugins) {\n      const tags = plugin[1] == null ? null : plugin[1].tags;\n      if (!Array.isArray(tags)) {\n        schema.plugin(plugin[0], plugin[1]);\n        continue;\n      }\n\n      pluginTags = pluginTags || new Set(schema.options.pluginTags || []);\n      if (!tags.find(tag => pluginTags.has(tag))) {\n        continue;\n      }\n      schema.plugin(plugin[0], plugin[1]);\n    }\n  }\n\n  options = Object.assign({}, options);\n  delete options.skipTopLevel;\n\n  if (options.applyPluginsToChildSchemas !== false) {\n    for (const path of Object.keys(schema.paths)) {\n      const type = schema.paths[path];\n      if (type.schema != null) {\n        applyPlugins(type.schema, plugins, options, cacheKey);\n\n        // Recompile schema because plugins may have changed it, see gh-7572\n        type.caster.prototype.$__setSchema(type.schema);\n      }\n    }\n  }\n\n  const discriminators = schema.discriminators;\n  if (discriminators == null) {\n    return;\n  }\n\n  const applyPluginsToDiscriminators = options.applyPluginsToDiscriminators;\n\n  const keys = Object.keys(discriminators);\n  for (const discriminatorKey of keys) {\n    const discriminatorSchema = discriminators[discriminatorKey];\n\n    applyPlugins(discriminatorSchema, plugins,\n      { skipTopLevel: !applyPluginsToDiscriminators }, cacheKey);\n  }\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbW9uZ29vc2UvbGliL2hlbHBlcnMvc2NoZW1hL2FwcGx5UGx1Z2lucy5qcyIsIm1hcHBpbmdzIjoiQUFBYTs7QUFFYjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsNEJBQTRCO0FBQzVCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxRQUFRLDZDQUE2QztBQUNyRDtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vYXBwMS8uL25vZGVfbW9kdWxlcy9tb25nb29zZS9saWIvaGVscGVycy9zY2hlbWEvYXBwbHlQbHVnaW5zLmpzP2VkODkiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGFwcGx5UGx1Z2lucyhzY2hlbWEsIHBsdWdpbnMsIG9wdGlvbnMsIGNhY2hlS2V5KSB7XG4gIGlmIChzY2hlbWFbY2FjaGVLZXldKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIHNjaGVtYVtjYWNoZUtleV0gPSB0cnVlO1xuXG4gIGlmICghb3B0aW9ucyB8fCAhb3B0aW9ucy5za2lwVG9wTGV2ZWwpIHtcbiAgICBsZXQgcGx1Z2luVGFncyA9IG51bGw7XG4gICAgZm9yIChjb25zdCBwbHVnaW4gb2YgcGx1Z2lucykge1xuICAgICAgY29uc3QgdGFncyA9IHBsdWdpblsxXSA9PSBudWxsID8gbnVsbCA6IHBsdWdpblsxXS50YWdzO1xuICAgICAgaWYgKCFBcnJheS5pc0FycmF5KHRhZ3MpKSB7XG4gICAgICAgIHNjaGVtYS5wbHVnaW4ocGx1Z2luWzBdLCBwbHVnaW5bMV0pO1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgcGx1Z2luVGFncyA9IHBsdWdpblRhZ3MgfHwgbmV3IFNldChzY2hlbWEub3B0aW9ucy5wbHVnaW5UYWdzIHx8IFtdKTtcbiAgICAgIGlmICghdGFncy5maW5kKHRhZyA9PiBwbHVnaW5UYWdzLmhhcyh0YWcpKSkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIHNjaGVtYS5wbHVnaW4ocGx1Z2luWzBdLCBwbHVnaW5bMV0pO1xuICAgIH1cbiAgfVxuXG4gIG9wdGlvbnMgPSBPYmplY3QuYXNzaWduKHt9LCBvcHRpb25zKTtcbiAgZGVsZXRlIG9wdGlvbnMuc2tpcFRvcExldmVsO1xuXG4gIGlmIChvcHRpb25zLmFwcGx5UGx1Z2luc1RvQ2hpbGRTY2hlbWFzICE9PSBmYWxzZSkge1xuICAgIGZvciAoY29uc3QgcGF0aCBvZiBPYmplY3Qua2V5cyhzY2hlbWEucGF0aHMpKSB7XG4gICAgICBjb25zdCB0eXBlID0gc2NoZW1hLnBhdGhzW3BhdGhdO1xuICAgICAgaWYgKHR5cGUuc2NoZW1hICE9IG51bGwpIHtcbiAgICAgICAgYXBwbHlQbHVnaW5zKHR5cGUuc2NoZW1hLCBwbHVnaW5zLCBvcHRpb25zLCBjYWNoZUtleSk7XG5cbiAgICAgICAgLy8gUmVjb21waWxlIHNjaGVtYSBiZWNhdXNlIHBsdWdpbnMgbWF5IGhhdmUgY2hhbmdlZCBpdCwgc2VlIGdoLTc1NzJcbiAgICAgICAgdHlwZS5jYXN0ZXIucHJvdG90eXBlLiRfX3NldFNjaGVtYSh0eXBlLnNjaGVtYSk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgY29uc3QgZGlzY3JpbWluYXRvcnMgPSBzY2hlbWEuZGlzY3JpbWluYXRvcnM7XG4gIGlmIChkaXNjcmltaW5hdG9ycyA9PSBudWxsKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgY29uc3QgYXBwbHlQbHVnaW5zVG9EaXNjcmltaW5hdG9ycyA9IG9wdGlvbnMuYXBwbHlQbHVnaW5zVG9EaXNjcmltaW5hdG9ycztcblxuICBjb25zdCBrZXlzID0gT2JqZWN0LmtleXMoZGlzY3JpbWluYXRvcnMpO1xuICBmb3IgKGNvbnN0IGRpc2NyaW1pbmF0b3JLZXkgb2Yga2V5cykge1xuICAgIGNvbnN0IGRpc2NyaW1pbmF0b3JTY2hlbWEgPSBkaXNjcmltaW5hdG9yc1tkaXNjcmltaW5hdG9yS2V5XTtcblxuICAgIGFwcGx5UGx1Z2lucyhkaXNjcmltaW5hdG9yU2NoZW1hLCBwbHVnaW5zLFxuICAgICAgeyBza2lwVG9wTGV2ZWw6ICFhcHBseVBsdWdpbnNUb0Rpc2NyaW1pbmF0b3JzIH0sIGNhY2hlS2V5KTtcbiAgfVxufTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/mongoose/lib/helpers/schema/applyPlugins.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/mongoose/lib/helpers/schema/applyWriteConcern.js":
/*!***********************************************************************!*\
  !*** ./node_modules/mongoose/lib/helpers/schema/applyWriteConcern.js ***!
  \***********************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\n\nconst get = __webpack_require__(/*! ../get */ \"(ssr)/./node_modules/mongoose/lib/helpers/get.js\");\n\nmodule.exports = function applyWriteConcern(schema, options) {\n  if (options.writeConcern != null) {\n    return;\n  }\n  const writeConcern = get(schema, 'options.writeConcern', {});\n  if (Object.keys(writeConcern).length != 0) {\n    options.writeConcern = {};\n    if (!('w' in options) && writeConcern.w != null) {\n      options.writeConcern.w = writeConcern.w;\n    }\n    if (!('j' in options) && writeConcern.j != null) {\n      options.writeConcern.j = writeConcern.j;\n    }\n    if (!('wtimeout' in options) && writeConcern.wtimeout != null) {\n      options.writeConcern.wtimeout = writeConcern.wtimeout;\n    }\n  }\n  else {\n    if (!('w' in options) && writeConcern.w != null) {\n      options.w = writeConcern.w;\n    }\n    if (!('j' in options) && writeConcern.j != null) {\n      options.j = writeConcern.j;\n    }\n    if (!('wtimeout' in options) && writeConcern.wtimeout != null) {\n      options.wtimeout = writeConcern.wtimeout;\n    }\n  }\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbW9uZ29vc2UvbGliL2hlbHBlcnMvc2NoZW1hL2FwcGx5V3JpdGVDb25jZXJuLmpzIiwibWFwcGluZ3MiOiJBQUFhOztBQUViLFlBQVksbUJBQU8sQ0FBQyxnRUFBUTs7QUFFNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2REFBNkQ7QUFDN0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vYXBwMS8uL25vZGVfbW9kdWxlcy9tb25nb29zZS9saWIvaGVscGVycy9zY2hlbWEvYXBwbHlXcml0ZUNvbmNlcm4uanM/NTdmNyJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbmNvbnN0IGdldCA9IHJlcXVpcmUoJy4uL2dldCcpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGFwcGx5V3JpdGVDb25jZXJuKHNjaGVtYSwgb3B0aW9ucykge1xuICBpZiAob3B0aW9ucy53cml0ZUNvbmNlcm4gIT0gbnVsbCkge1xuICAgIHJldHVybjtcbiAgfVxuICBjb25zdCB3cml0ZUNvbmNlcm4gPSBnZXQoc2NoZW1hLCAnb3B0aW9ucy53cml0ZUNvbmNlcm4nLCB7fSk7XG4gIGlmIChPYmplY3Qua2V5cyh3cml0ZUNvbmNlcm4pLmxlbmd0aCAhPSAwKSB7XG4gICAgb3B0aW9ucy53cml0ZUNvbmNlcm4gPSB7fTtcbiAgICBpZiAoISgndycgaW4gb3B0aW9ucykgJiYgd3JpdGVDb25jZXJuLncgIT0gbnVsbCkge1xuICAgICAgb3B0aW9ucy53cml0ZUNvbmNlcm4udyA9IHdyaXRlQ29uY2Vybi53O1xuICAgIH1cbiAgICBpZiAoISgnaicgaW4gb3B0aW9ucykgJiYgd3JpdGVDb25jZXJuLmogIT0gbnVsbCkge1xuICAgICAgb3B0aW9ucy53cml0ZUNvbmNlcm4uaiA9IHdyaXRlQ29uY2Vybi5qO1xuICAgIH1cbiAgICBpZiAoISgnd3RpbWVvdXQnIGluIG9wdGlvbnMpICYmIHdyaXRlQ29uY2Vybi53dGltZW91dCAhPSBudWxsKSB7XG4gICAgICBvcHRpb25zLndyaXRlQ29uY2Vybi53dGltZW91dCA9IHdyaXRlQ29uY2Vybi53dGltZW91dDtcbiAgICB9XG4gIH1cbiAgZWxzZSB7XG4gICAgaWYgKCEoJ3cnIGluIG9wdGlvbnMpICYmIHdyaXRlQ29uY2Vybi53ICE9IG51bGwpIHtcbiAgICAgIG9wdGlvbnMudyA9IHdyaXRlQ29uY2Vybi53O1xuICAgIH1cbiAgICBpZiAoISgnaicgaW4gb3B0aW9ucykgJiYgd3JpdGVDb25jZXJuLmogIT0gbnVsbCkge1xuICAgICAgb3B0aW9ucy5qID0gd3JpdGVDb25jZXJuLmo7XG4gICAgfVxuICAgIGlmICghKCd3dGltZW91dCcgaW4gb3B0aW9ucykgJiYgd3JpdGVDb25jZXJuLnd0aW1lb3V0ICE9IG51bGwpIHtcbiAgICAgIG9wdGlvbnMud3RpbWVvdXQgPSB3cml0ZUNvbmNlcm4ud3RpbWVvdXQ7XG4gICAgfVxuICB9XG59O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/mongoose/lib/helpers/schema/applyWriteConcern.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/mongoose/lib/helpers/schema/cleanPositionalOperators.js":
/*!******************************************************************************!*\
  !*** ./node_modules/mongoose/lib/helpers/schema/cleanPositionalOperators.js ***!
  \******************************************************************************/
/***/ ((module) => {

eval("\n\n/**\n * For consistency's sake, we replace positional operator `$` and array filters\n * `$[]` and `$[foo]` with `0` when looking up schema paths.\n */\n\nmodule.exports = function cleanPositionalOperators(path) {\n  return path.\n    replace(/\\.\\$(\\[[^\\]]*\\])?(?=\\.)/g, '.0').\n    replace(/\\.\\$(\\[[^\\]]*\\])?$/g, '.0');\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbW9uZ29vc2UvbGliL2hlbHBlcnMvc2NoZW1hL2NsZWFuUG9zaXRpb25hbE9wZXJhdG9ycy5qcyIsIm1hcHBpbmdzIjoiQUFBYTs7QUFFYjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vYXBwMS8uL25vZGVfbW9kdWxlcy9tb25nb29zZS9saWIvaGVscGVycy9zY2hlbWEvY2xlYW5Qb3NpdGlvbmFsT3BlcmF0b3JzLmpzPzZjZDIiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG4vKipcbiAqIEZvciBjb25zaXN0ZW5jeSdzIHNha2UsIHdlIHJlcGxhY2UgcG9zaXRpb25hbCBvcGVyYXRvciBgJGAgYW5kIGFycmF5IGZpbHRlcnNcbiAqIGAkW11gIGFuZCBgJFtmb29dYCB3aXRoIGAwYCB3aGVuIGxvb2tpbmcgdXAgc2NoZW1hIHBhdGhzLlxuICovXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gY2xlYW5Qb3NpdGlvbmFsT3BlcmF0b3JzKHBhdGgpIHtcbiAgcmV0dXJuIHBhdGguXG4gICAgcmVwbGFjZSgvXFwuXFwkKFxcW1teXFxdXSpcXF0pPyg/PVxcLikvZywgJy4wJykuXG4gICAgcmVwbGFjZSgvXFwuXFwkKFxcW1teXFxdXSpcXF0pPyQvZywgJy4wJyk7XG59O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/mongoose/lib/helpers/schema/cleanPositionalOperators.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/mongoose/lib/helpers/schema/getIndexes.js":
/*!****************************************************************!*\
  !*** ./node_modules/mongoose/lib/helpers/schema/getIndexes.js ***!
  \****************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\n\nconst get = __webpack_require__(/*! ../get */ \"(ssr)/./node_modules/mongoose/lib/helpers/get.js\");\nconst helperIsObject = __webpack_require__(/*! ../isObject */ \"(ssr)/./node_modules/mongoose/lib/helpers/isObject.js\");\nconst decorateDiscriminatorIndexOptions = __webpack_require__(/*! ../indexes/decorateDiscriminatorIndexOptions */ \"(ssr)/./node_modules/mongoose/lib/helpers/indexes/decorateDiscriminatorIndexOptions.js\");\n\n/**\n * Gather all indexes defined in the schema, including single nested,\n * document arrays, and embedded discriminators.\n * @param {Schema} schema\n * @api private\n */\n\nmodule.exports = function getIndexes(schema) {\n  let indexes = [];\n  const schemaStack = new WeakMap();\n  const indexTypes = schema.constructor.indexTypes;\n  const indexByName = new Map();\n\n  collectIndexes(schema);\n  return indexes;\n\n  function collectIndexes(schema, prefix, baseSchema) {\n    // Ignore infinitely nested schemas, if we've already seen this schema\n    // along this path there must be a cycle\n    if (schemaStack.has(schema)) {\n      return;\n    }\n    schemaStack.set(schema, true);\n\n    prefix = prefix || '';\n    const keys = Object.keys(schema.paths);\n\n    for (const key of keys) {\n      const path = schema.paths[key];\n      if (baseSchema != null && baseSchema.paths[key]) {\n        // If looking at an embedded discriminator schema, don't look at paths\n        // that the\n        continue;\n      }\n\n      if (path.$isMongooseDocumentArray || path.$isSingleNested) {\n        if (get(path, 'options.excludeIndexes') !== true &&\n            get(path, 'schemaOptions.excludeIndexes') !== true &&\n            get(path, 'schema.options.excludeIndexes') !== true) {\n          collectIndexes(path.schema, prefix + key + '.');\n        }\n\n        if (path.schema.discriminators != null) {\n          const discriminators = path.schema.discriminators;\n          const discriminatorKeys = Object.keys(discriminators);\n          for (const discriminatorKey of discriminatorKeys) {\n            collectIndexes(discriminators[discriminatorKey],\n              prefix + key + '.', path.schema);\n          }\n        }\n\n        // Retained to minimize risk of backwards breaking changes due to\n        // gh-6113\n        if (path.$isMongooseDocumentArray) {\n          continue;\n        }\n      }\n\n      const index = path._index || (path.caster && path.caster._index);\n\n      if (index !== false && index !== null && index !== undefined) {\n        const field = {};\n        const isObject = helperIsObject(index);\n        const options = isObject ? index : {};\n        const type = typeof index === 'string' ? index :\n          isObject ? index.type :\n            false;\n\n        if (type && indexTypes.indexOf(type) !== -1) {\n          field[prefix + key] = type;\n        } else if (options.text) {\n          field[prefix + key] = 'text';\n          delete options.text;\n        } else {\n          let isDescendingIndex = false;\n          if (index === 'descending' || index === 'desc') {\n            isDescendingIndex = true;\n          } else if (index === 'ascending' || index === 'asc') {\n            isDescendingIndex = false;\n          } else {\n            isDescendingIndex = Number(index) === -1;\n          }\n\n          field[prefix + key] = isDescendingIndex ? -1 : 1;\n        }\n\n        delete options.type;\n        if (!('background' in options)) {\n          options.background = true;\n        }\n        if (schema.options.autoIndex != null) {\n          options._autoIndex = schema.options.autoIndex;\n        }\n\n        const indexName = options && options.name;\n\n        if (typeof indexName === 'string') {\n          if (indexByName.has(indexName)) {\n            Object.assign(indexByName.get(indexName), field);\n          } else {\n            indexes.push([field, options]);\n            indexByName.set(indexName, field);\n          }\n        } else {\n          indexes.push([field, options]);\n          indexByName.set(indexName, field);\n        }\n      }\n    }\n\n    schemaStack.delete(schema);\n\n    if (prefix) {\n      fixSubIndexPaths(schema, prefix);\n    } else {\n      schema._indexes.forEach(function(index) {\n        const options = index[1];\n        if (!('background' in options)) {\n          options.background = true;\n        }\n        decorateDiscriminatorIndexOptions(schema, options);\n      });\n      indexes = indexes.concat(schema._indexes);\n    }\n  }\n\n  /**\n   * Checks for indexes added to subdocs using Schema.index().\n   * These indexes need their paths prefixed properly.\n   *\n   * schema._indexes = [ [indexObj, options], [indexObj, options] ..]\n   * @param {Schema} schema\n   * @param {String} prefix\n   * @api private\n   */\n\n  function fixSubIndexPaths(schema, prefix) {\n    const subindexes = schema._indexes;\n    const len = subindexes.length;\n    for (let i = 0; i < len; ++i) {\n      const indexObj = subindexes[i][0];\n      const indexOptions = subindexes[i][1];\n      const keys = Object.keys(indexObj);\n      const klen = keys.length;\n      const newindex = {};\n\n      // use forward iteration, order matters\n      for (let j = 0; j < klen; ++j) {\n        const key = keys[j];\n        newindex[prefix + key] = indexObj[key];\n      }\n\n      const newIndexOptions = Object.assign({}, indexOptions);\n      if (indexOptions != null && indexOptions.partialFilterExpression != null) {\n        newIndexOptions.partialFilterExpression = {};\n        const partialFilterExpression = indexOptions.partialFilterExpression;\n        for (const key of Object.keys(partialFilterExpression)) {\n          newIndexOptions.partialFilterExpression[prefix + key] =\n            partialFilterExpression[key];\n        }\n      }\n\n      indexes.push([newindex, newIndexOptions]);\n    }\n  }\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbW9uZ29vc2UvbGliL2hlbHBlcnMvc2NoZW1hL2dldEluZGV4ZXMuanMiLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWIsWUFBWSxtQkFBTyxDQUFDLGdFQUFRO0FBQzVCLHVCQUF1QixtQkFBTyxDQUFDLDBFQUFhO0FBQzVDLDBDQUEwQyxtQkFBTyxDQUFDLDRJQUE4Qzs7QUFFaEc7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQSxZQUFZO0FBQ1o7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsUUFBUTtBQUNyQixhQUFhLFFBQVE7QUFDckI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsU0FBUztBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0Esc0JBQXNCLFVBQVU7QUFDaEM7QUFDQTtBQUNBOztBQUVBLDhDQUE4QztBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vYXBwMS8uL25vZGVfbW9kdWxlcy9tb25nb29zZS9saWIvaGVscGVycy9zY2hlbWEvZ2V0SW5kZXhlcy5qcz8wNjdjIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxuY29uc3QgZ2V0ID0gcmVxdWlyZSgnLi4vZ2V0Jyk7XG5jb25zdCBoZWxwZXJJc09iamVjdCA9IHJlcXVpcmUoJy4uL2lzT2JqZWN0Jyk7XG5jb25zdCBkZWNvcmF0ZURpc2NyaW1pbmF0b3JJbmRleE9wdGlvbnMgPSByZXF1aXJlKCcuLi9pbmRleGVzL2RlY29yYXRlRGlzY3JpbWluYXRvckluZGV4T3B0aW9ucycpO1xuXG4vKipcbiAqIEdhdGhlciBhbGwgaW5kZXhlcyBkZWZpbmVkIGluIHRoZSBzY2hlbWEsIGluY2x1ZGluZyBzaW5nbGUgbmVzdGVkLFxuICogZG9jdW1lbnQgYXJyYXlzLCBhbmQgZW1iZWRkZWQgZGlzY3JpbWluYXRvcnMuXG4gKiBAcGFyYW0ge1NjaGVtYX0gc2NoZW1hXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGdldEluZGV4ZXMoc2NoZW1hKSB7XG4gIGxldCBpbmRleGVzID0gW107XG4gIGNvbnN0IHNjaGVtYVN0YWNrID0gbmV3IFdlYWtNYXAoKTtcbiAgY29uc3QgaW5kZXhUeXBlcyA9IHNjaGVtYS5jb25zdHJ1Y3Rvci5pbmRleFR5cGVzO1xuICBjb25zdCBpbmRleEJ5TmFtZSA9IG5ldyBNYXAoKTtcblxuICBjb2xsZWN0SW5kZXhlcyhzY2hlbWEpO1xuICByZXR1cm4gaW5kZXhlcztcblxuICBmdW5jdGlvbiBjb2xsZWN0SW5kZXhlcyhzY2hlbWEsIHByZWZpeCwgYmFzZVNjaGVtYSkge1xuICAgIC8vIElnbm9yZSBpbmZpbml0ZWx5IG5lc3RlZCBzY2hlbWFzLCBpZiB3ZSd2ZSBhbHJlYWR5IHNlZW4gdGhpcyBzY2hlbWFcbiAgICAvLyBhbG9uZyB0aGlzIHBhdGggdGhlcmUgbXVzdCBiZSBhIGN5Y2xlXG4gICAgaWYgKHNjaGVtYVN0YWNrLmhhcyhzY2hlbWEpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHNjaGVtYVN0YWNrLnNldChzY2hlbWEsIHRydWUpO1xuXG4gICAgcHJlZml4ID0gcHJlZml4IHx8ICcnO1xuICAgIGNvbnN0IGtleXMgPSBPYmplY3Qua2V5cyhzY2hlbWEucGF0aHMpO1xuXG4gICAgZm9yIChjb25zdCBrZXkgb2Yga2V5cykge1xuICAgICAgY29uc3QgcGF0aCA9IHNjaGVtYS5wYXRoc1trZXldO1xuICAgICAgaWYgKGJhc2VTY2hlbWEgIT0gbnVsbCAmJiBiYXNlU2NoZW1hLnBhdGhzW2tleV0pIHtcbiAgICAgICAgLy8gSWYgbG9va2luZyBhdCBhbiBlbWJlZGRlZCBkaXNjcmltaW5hdG9yIHNjaGVtYSwgZG9uJ3QgbG9vayBhdCBwYXRoc1xuICAgICAgICAvLyB0aGF0IHRoZVxuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgaWYgKHBhdGguJGlzTW9uZ29vc2VEb2N1bWVudEFycmF5IHx8IHBhdGguJGlzU2luZ2xlTmVzdGVkKSB7XG4gICAgICAgIGlmIChnZXQocGF0aCwgJ29wdGlvbnMuZXhjbHVkZUluZGV4ZXMnKSAhPT0gdHJ1ZSAmJlxuICAgICAgICAgICAgZ2V0KHBhdGgsICdzY2hlbWFPcHRpb25zLmV4Y2x1ZGVJbmRleGVzJykgIT09IHRydWUgJiZcbiAgICAgICAgICAgIGdldChwYXRoLCAnc2NoZW1hLm9wdGlvbnMuZXhjbHVkZUluZGV4ZXMnKSAhPT0gdHJ1ZSkge1xuICAgICAgICAgIGNvbGxlY3RJbmRleGVzKHBhdGguc2NoZW1hLCBwcmVmaXggKyBrZXkgKyAnLicpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHBhdGguc2NoZW1hLmRpc2NyaW1pbmF0b3JzICE9IG51bGwpIHtcbiAgICAgICAgICBjb25zdCBkaXNjcmltaW5hdG9ycyA9IHBhdGguc2NoZW1hLmRpc2NyaW1pbmF0b3JzO1xuICAgICAgICAgIGNvbnN0IGRpc2NyaW1pbmF0b3JLZXlzID0gT2JqZWN0LmtleXMoZGlzY3JpbWluYXRvcnMpO1xuICAgICAgICAgIGZvciAoY29uc3QgZGlzY3JpbWluYXRvcktleSBvZiBkaXNjcmltaW5hdG9yS2V5cykge1xuICAgICAgICAgICAgY29sbGVjdEluZGV4ZXMoZGlzY3JpbWluYXRvcnNbZGlzY3JpbWluYXRvcktleV0sXG4gICAgICAgICAgICAgIHByZWZpeCArIGtleSArICcuJywgcGF0aC5zY2hlbWEpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFJldGFpbmVkIHRvIG1pbmltaXplIHJpc2sgb2YgYmFja3dhcmRzIGJyZWFraW5nIGNoYW5nZXMgZHVlIHRvXG4gICAgICAgIC8vIGdoLTYxMTNcbiAgICAgICAgaWYgKHBhdGguJGlzTW9uZ29vc2VEb2N1bWVudEFycmF5KSB7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgY29uc3QgaW5kZXggPSBwYXRoLl9pbmRleCB8fCAocGF0aC5jYXN0ZXIgJiYgcGF0aC5jYXN0ZXIuX2luZGV4KTtcblxuICAgICAgaWYgKGluZGV4ICE9PSBmYWxzZSAmJiBpbmRleCAhPT0gbnVsbCAmJiBpbmRleCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGNvbnN0IGZpZWxkID0ge307XG4gICAgICAgIGNvbnN0IGlzT2JqZWN0ID0gaGVscGVySXNPYmplY3QoaW5kZXgpO1xuICAgICAgICBjb25zdCBvcHRpb25zID0gaXNPYmplY3QgPyBpbmRleCA6IHt9O1xuICAgICAgICBjb25zdCB0eXBlID0gdHlwZW9mIGluZGV4ID09PSAnc3RyaW5nJyA/IGluZGV4IDpcbiAgICAgICAgICBpc09iamVjdCA/IGluZGV4LnR5cGUgOlxuICAgICAgICAgICAgZmFsc2U7XG5cbiAgICAgICAgaWYgKHR5cGUgJiYgaW5kZXhUeXBlcy5pbmRleE9mKHR5cGUpICE9PSAtMSkge1xuICAgICAgICAgIGZpZWxkW3ByZWZpeCArIGtleV0gPSB0eXBlO1xuICAgICAgICB9IGVsc2UgaWYgKG9wdGlvbnMudGV4dCkge1xuICAgICAgICAgIGZpZWxkW3ByZWZpeCArIGtleV0gPSAndGV4dCc7XG4gICAgICAgICAgZGVsZXRlIG9wdGlvbnMudGV4dDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBsZXQgaXNEZXNjZW5kaW5nSW5kZXggPSBmYWxzZTtcbiAgICAgICAgICBpZiAoaW5kZXggPT09ICdkZXNjZW5kaW5nJyB8fCBpbmRleCA9PT0gJ2Rlc2MnKSB7XG4gICAgICAgICAgICBpc0Rlc2NlbmRpbmdJbmRleCA9IHRydWU7XG4gICAgICAgICAgfSBlbHNlIGlmIChpbmRleCA9PT0gJ2FzY2VuZGluZycgfHwgaW5kZXggPT09ICdhc2MnKSB7XG4gICAgICAgICAgICBpc0Rlc2NlbmRpbmdJbmRleCA9IGZhbHNlO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpc0Rlc2NlbmRpbmdJbmRleCA9IE51bWJlcihpbmRleCkgPT09IC0xO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGZpZWxkW3ByZWZpeCArIGtleV0gPSBpc0Rlc2NlbmRpbmdJbmRleCA/IC0xIDogMTtcbiAgICAgICAgfVxuXG4gICAgICAgIGRlbGV0ZSBvcHRpb25zLnR5cGU7XG4gICAgICAgIGlmICghKCdiYWNrZ3JvdW5kJyBpbiBvcHRpb25zKSkge1xuICAgICAgICAgIG9wdGlvbnMuYmFja2dyb3VuZCA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHNjaGVtYS5vcHRpb25zLmF1dG9JbmRleCAhPSBudWxsKSB7XG4gICAgICAgICAgb3B0aW9ucy5fYXV0b0luZGV4ID0gc2NoZW1hLm9wdGlvbnMuYXV0b0luZGV4O1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgaW5kZXhOYW1lID0gb3B0aW9ucyAmJiBvcHRpb25zLm5hbWU7XG5cbiAgICAgICAgaWYgKHR5cGVvZiBpbmRleE5hbWUgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgaWYgKGluZGV4QnlOYW1lLmhhcyhpbmRleE5hbWUpKSB7XG4gICAgICAgICAgICBPYmplY3QuYXNzaWduKGluZGV4QnlOYW1lLmdldChpbmRleE5hbWUpLCBmaWVsZCk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGluZGV4ZXMucHVzaChbZmllbGQsIG9wdGlvbnNdKTtcbiAgICAgICAgICAgIGluZGV4QnlOYW1lLnNldChpbmRleE5hbWUsIGZpZWxkKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaW5kZXhlcy5wdXNoKFtmaWVsZCwgb3B0aW9uc10pO1xuICAgICAgICAgIGluZGV4QnlOYW1lLnNldChpbmRleE5hbWUsIGZpZWxkKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHNjaGVtYVN0YWNrLmRlbGV0ZShzY2hlbWEpO1xuXG4gICAgaWYgKHByZWZpeCkge1xuICAgICAgZml4U3ViSW5kZXhQYXRocyhzY2hlbWEsIHByZWZpeCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHNjaGVtYS5faW5kZXhlcy5mb3JFYWNoKGZ1bmN0aW9uKGluZGV4KSB7XG4gICAgICAgIGNvbnN0IG9wdGlvbnMgPSBpbmRleFsxXTtcbiAgICAgICAgaWYgKCEoJ2JhY2tncm91bmQnIGluIG9wdGlvbnMpKSB7XG4gICAgICAgICAgb3B0aW9ucy5iYWNrZ3JvdW5kID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBkZWNvcmF0ZURpc2NyaW1pbmF0b3JJbmRleE9wdGlvbnMoc2NoZW1hLCBvcHRpb25zKTtcbiAgICAgIH0pO1xuICAgICAgaW5kZXhlcyA9IGluZGV4ZXMuY29uY2F0KHNjaGVtYS5faW5kZXhlcyk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIENoZWNrcyBmb3IgaW5kZXhlcyBhZGRlZCB0byBzdWJkb2NzIHVzaW5nIFNjaGVtYS5pbmRleCgpLlxuICAgKiBUaGVzZSBpbmRleGVzIG5lZWQgdGhlaXIgcGF0aHMgcHJlZml4ZWQgcHJvcGVybHkuXG4gICAqXG4gICAqIHNjaGVtYS5faW5kZXhlcyA9IFsgW2luZGV4T2JqLCBvcHRpb25zXSwgW2luZGV4T2JqLCBvcHRpb25zXSAuLl1cbiAgICogQHBhcmFtIHtTY2hlbWF9IHNjaGVtYVxuICAgKiBAcGFyYW0ge1N0cmluZ30gcHJlZml4XG4gICAqIEBhcGkgcHJpdmF0ZVxuICAgKi9cblxuICBmdW5jdGlvbiBmaXhTdWJJbmRleFBhdGhzKHNjaGVtYSwgcHJlZml4KSB7XG4gICAgY29uc3Qgc3ViaW5kZXhlcyA9IHNjaGVtYS5faW5kZXhlcztcbiAgICBjb25zdCBsZW4gPSBzdWJpbmRleGVzLmxlbmd0aDtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbjsgKytpKSB7XG4gICAgICBjb25zdCBpbmRleE9iaiA9IHN1YmluZGV4ZXNbaV1bMF07XG4gICAgICBjb25zdCBpbmRleE9wdGlvbnMgPSBzdWJpbmRleGVzW2ldWzFdO1xuICAgICAgY29uc3Qga2V5cyA9IE9iamVjdC5rZXlzKGluZGV4T2JqKTtcbiAgICAgIGNvbnN0IGtsZW4gPSBrZXlzLmxlbmd0aDtcbiAgICAgIGNvbnN0IG5ld2luZGV4ID0ge307XG5cbiAgICAgIC8vIHVzZSBmb3J3YXJkIGl0ZXJhdGlvbiwgb3JkZXIgbWF0dGVyc1xuICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCBrbGVuOyArK2opIHtcbiAgICAgICAgY29uc3Qga2V5ID0ga2V5c1tqXTtcbiAgICAgICAgbmV3aW5kZXhbcHJlZml4ICsga2V5XSA9IGluZGV4T2JqW2tleV07XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IG5ld0luZGV4T3B0aW9ucyA9IE9iamVjdC5hc3NpZ24oe30sIGluZGV4T3B0aW9ucyk7XG4gICAgICBpZiAoaW5kZXhPcHRpb25zICE9IG51bGwgJiYgaW5kZXhPcHRpb25zLnBhcnRpYWxGaWx0ZXJFeHByZXNzaW9uICE9IG51bGwpIHtcbiAgICAgICAgbmV3SW5kZXhPcHRpb25zLnBhcnRpYWxGaWx0ZXJFeHByZXNzaW9uID0ge307XG4gICAgICAgIGNvbnN0IHBhcnRpYWxGaWx0ZXJFeHByZXNzaW9uID0gaW5kZXhPcHRpb25zLnBhcnRpYWxGaWx0ZXJFeHByZXNzaW9uO1xuICAgICAgICBmb3IgKGNvbnN0IGtleSBvZiBPYmplY3Qua2V5cyhwYXJ0aWFsRmlsdGVyRXhwcmVzc2lvbikpIHtcbiAgICAgICAgICBuZXdJbmRleE9wdGlvbnMucGFydGlhbEZpbHRlckV4cHJlc3Npb25bcHJlZml4ICsga2V5XSA9XG4gICAgICAgICAgICBwYXJ0aWFsRmlsdGVyRXhwcmVzc2lvbltrZXldO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGluZGV4ZXMucHVzaChbbmV3aW5kZXgsIG5ld0luZGV4T3B0aW9uc10pO1xuICAgIH1cbiAgfVxufTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/mongoose/lib/helpers/schema/getIndexes.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/mongoose/lib/helpers/schema/getKeysInSchemaOrder.js":
/*!**************************************************************************!*\
  !*** ./node_modules/mongoose/lib/helpers/schema/getKeysInSchemaOrder.js ***!
  \**************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\n\nconst get = __webpack_require__(/*! ../get */ \"(ssr)/./node_modules/mongoose/lib/helpers/get.js\");\n\nmodule.exports = function getKeysInSchemaOrder(schema, val, path) {\n  const schemaKeys = path != null ? Object.keys(get(schema.tree, path, {})) : Object.keys(schema.tree);\n  const valKeys = new Set(Object.keys(val));\n\n  let keys;\n  if (valKeys.size > 1) {\n    keys = new Set();\n    for (const key of schemaKeys) {\n      if (valKeys.has(key)) {\n        keys.add(key);\n      }\n    }\n    for (const key of valKeys) {\n      if (!keys.has(key)) {\n        keys.add(key);\n      }\n    }\n    keys = Array.from(keys);\n  } else {\n    keys = Array.from(valKeys);\n  }\n\n  return keys;\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbW9uZ29vc2UvbGliL2hlbHBlcnMvc2NoZW1hL2dldEtleXNJblNjaGVtYU9yZGVyLmpzIiwibWFwcGluZ3MiOiJBQUFhOztBQUViLFlBQVksbUJBQU8sQ0FBQyxnRUFBUTs7QUFFNUI7QUFDQSx5RUFBeUU7QUFDekU7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBOztBQUVBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9hcHAxLy4vbm9kZV9tb2R1bGVzL21vbmdvb3NlL2xpYi9oZWxwZXJzL3NjaGVtYS9nZXRLZXlzSW5TY2hlbWFPcmRlci5qcz85NzM3Il0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxuY29uc3QgZ2V0ID0gcmVxdWlyZSgnLi4vZ2V0Jyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gZ2V0S2V5c0luU2NoZW1hT3JkZXIoc2NoZW1hLCB2YWwsIHBhdGgpIHtcbiAgY29uc3Qgc2NoZW1hS2V5cyA9IHBhdGggIT0gbnVsbCA/IE9iamVjdC5rZXlzKGdldChzY2hlbWEudHJlZSwgcGF0aCwge30pKSA6IE9iamVjdC5rZXlzKHNjaGVtYS50cmVlKTtcbiAgY29uc3QgdmFsS2V5cyA9IG5ldyBTZXQoT2JqZWN0LmtleXModmFsKSk7XG5cbiAgbGV0IGtleXM7XG4gIGlmICh2YWxLZXlzLnNpemUgPiAxKSB7XG4gICAga2V5cyA9IG5ldyBTZXQoKTtcbiAgICBmb3IgKGNvbnN0IGtleSBvZiBzY2hlbWFLZXlzKSB7XG4gICAgICBpZiAodmFsS2V5cy5oYXMoa2V5KSkge1xuICAgICAgICBrZXlzLmFkZChrZXkpO1xuICAgICAgfVxuICAgIH1cbiAgICBmb3IgKGNvbnN0IGtleSBvZiB2YWxLZXlzKSB7XG4gICAgICBpZiAoIWtleXMuaGFzKGtleSkpIHtcbiAgICAgICAga2V5cy5hZGQoa2V5KTtcbiAgICAgIH1cbiAgICB9XG4gICAga2V5cyA9IEFycmF5LmZyb20oa2V5cyk7XG4gIH0gZWxzZSB7XG4gICAga2V5cyA9IEFycmF5LmZyb20odmFsS2V5cyk7XG4gIH1cblxuICByZXR1cm4ga2V5cztcbn07XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/mongoose/lib/helpers/schema/getKeysInSchemaOrder.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/mongoose/lib/helpers/schema/getPath.js":
/*!*************************************************************!*\
  !*** ./node_modules/mongoose/lib/helpers/schema/getPath.js ***!
  \*************************************************************/
/***/ ((module) => {

eval("\n\nconst numberRE = /^\\d+$/;\n\n/**\n * Behaves like `Schema#path()`, except for it also digs into arrays without\n * needing to put `.0.`, so `getPath(schema, 'docArr.elProp')` works.\n * @api private\n */\n\nmodule.exports = function getPath(schema, path) {\n  let schematype = schema.path(path);\n  if (schematype != null) {\n    return schematype;\n  }\n  const pieces = path.split('.');\n  let cur = '';\n  let isArray = false;\n\n  for (const piece of pieces) {\n    if (isArray && numberRE.test(piece)) {\n      continue;\n    }\n    cur = cur.length === 0 ? piece : cur + '.' + piece;\n\n    schematype = schema.path(cur);\n    if (schematype != null && schematype.schema) {\n      schema = schematype.schema;\n      cur = '';\n      if (!isArray && schematype.$isMongooseDocumentArray) {\n        isArray = true;\n      }\n    }\n  }\n\n  return schematype;\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbW9uZ29vc2UvbGliL2hlbHBlcnMvc2NoZW1hL2dldFBhdGguanMiLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9hcHAxLy4vbm9kZV9tb2R1bGVzL21vbmdvb3NlL2xpYi9oZWxwZXJzL3NjaGVtYS9nZXRQYXRoLmpzP2RiMTkiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG5jb25zdCBudW1iZXJSRSA9IC9eXFxkKyQvO1xuXG4vKipcbiAqIEJlaGF2ZXMgbGlrZSBgU2NoZW1hI3BhdGgoKWAsIGV4Y2VwdCBmb3IgaXQgYWxzbyBkaWdzIGludG8gYXJyYXlzIHdpdGhvdXRcbiAqIG5lZWRpbmcgdG8gcHV0IGAuMC5gLCBzbyBgZ2V0UGF0aChzY2hlbWEsICdkb2NBcnIuZWxQcm9wJylgIHdvcmtzLlxuICogQGFwaSBwcml2YXRlXG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBnZXRQYXRoKHNjaGVtYSwgcGF0aCkge1xuICBsZXQgc2NoZW1hdHlwZSA9IHNjaGVtYS5wYXRoKHBhdGgpO1xuICBpZiAoc2NoZW1hdHlwZSAhPSBudWxsKSB7XG4gICAgcmV0dXJuIHNjaGVtYXR5cGU7XG4gIH1cbiAgY29uc3QgcGllY2VzID0gcGF0aC5zcGxpdCgnLicpO1xuICBsZXQgY3VyID0gJyc7XG4gIGxldCBpc0FycmF5ID0gZmFsc2U7XG5cbiAgZm9yIChjb25zdCBwaWVjZSBvZiBwaWVjZXMpIHtcbiAgICBpZiAoaXNBcnJheSAmJiBudW1iZXJSRS50ZXN0KHBpZWNlKSkge1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIGN1ciA9IGN1ci5sZW5ndGggPT09IDAgPyBwaWVjZSA6IGN1ciArICcuJyArIHBpZWNlO1xuXG4gICAgc2NoZW1hdHlwZSA9IHNjaGVtYS5wYXRoKGN1cik7XG4gICAgaWYgKHNjaGVtYXR5cGUgIT0gbnVsbCAmJiBzY2hlbWF0eXBlLnNjaGVtYSkge1xuICAgICAgc2NoZW1hID0gc2NoZW1hdHlwZS5zY2hlbWE7XG4gICAgICBjdXIgPSAnJztcbiAgICAgIGlmICghaXNBcnJheSAmJiBzY2hlbWF0eXBlLiRpc01vbmdvb3NlRG9jdW1lbnRBcnJheSkge1xuICAgICAgICBpc0FycmF5ID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gc2NoZW1hdHlwZTtcbn07XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/mongoose/lib/helpers/schema/getPath.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/mongoose/lib/helpers/schema/getSubdocumentStrictValue.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/mongoose/lib/helpers/schema/getSubdocumentStrictValue.js ***!
  \*******************************************************************************/
/***/ ((module) => {

eval("\n\n/**\n * Find the `strict` mode setting for the deepest subdocument along a given path\n * to ensure we have the correct default value for `strict`. When setting values\n * underneath a subdocument, we should use the subdocument's `strict` setting by\n * default, not the top-level document's.\n *\n * @param {Schema} schema\n * @param {String[]} parts\n * @returns {boolean | 'throw' | undefined}\n */\n\nmodule.exports = function getSubdocumentStrictValue(schema, parts) {\n  if (parts.length === 1) {\n    return undefined;\n  }\n  let cur = parts[0];\n  let strict = undefined;\n  for (let i = 0; i < parts.length - 1; ++i) {\n    const curSchemaType = schema.path(cur);\n    if (curSchemaType && curSchemaType.schema) {\n      strict = curSchemaType.schema.options.strict;\n      schema = curSchemaType.schema;\n      cur = curSchemaType.$isMongooseDocumentArray && !isNaN(parts[i + 1]) ? '' : parts[i + 1];\n    } else {\n      cur += cur.length ? ('.' + parts[i + 1]) : parts[i + 1];\n    }\n  }\n\n  return strict;\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbW9uZ29vc2UvbGliL2hlbHBlcnMvc2NoZW1hL2dldFN1YmRvY3VtZW50U3RyaWN0VmFsdWUuanMiLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFdBQVcsVUFBVTtBQUNyQixhQUFhO0FBQ2I7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLHNCQUFzQjtBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTs7QUFFQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vYXBwMS8uL25vZGVfbW9kdWxlcy9tb25nb29zZS9saWIvaGVscGVycy9zY2hlbWEvZ2V0U3ViZG9jdW1lbnRTdHJpY3RWYWx1ZS5qcz80ZDhmIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxuLyoqXG4gKiBGaW5kIHRoZSBgc3RyaWN0YCBtb2RlIHNldHRpbmcgZm9yIHRoZSBkZWVwZXN0IHN1YmRvY3VtZW50IGFsb25nIGEgZ2l2ZW4gcGF0aFxuICogdG8gZW5zdXJlIHdlIGhhdmUgdGhlIGNvcnJlY3QgZGVmYXVsdCB2YWx1ZSBmb3IgYHN0cmljdGAuIFdoZW4gc2V0dGluZyB2YWx1ZXNcbiAqIHVuZGVybmVhdGggYSBzdWJkb2N1bWVudCwgd2Ugc2hvdWxkIHVzZSB0aGUgc3ViZG9jdW1lbnQncyBgc3RyaWN0YCBzZXR0aW5nIGJ5XG4gKiBkZWZhdWx0LCBub3QgdGhlIHRvcC1sZXZlbCBkb2N1bWVudCdzLlxuICpcbiAqIEBwYXJhbSB7U2NoZW1hfSBzY2hlbWFcbiAqIEBwYXJhbSB7U3RyaW5nW119IHBhcnRzXG4gKiBAcmV0dXJucyB7Ym9vbGVhbiB8ICd0aHJvdycgfCB1bmRlZmluZWR9XG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBnZXRTdWJkb2N1bWVudFN0cmljdFZhbHVlKHNjaGVtYSwgcGFydHMpIHtcbiAgaWYgKHBhcnRzLmxlbmd0aCA9PT0gMSkge1xuICAgIHJldHVybiB1bmRlZmluZWQ7XG4gIH1cbiAgbGV0IGN1ciA9IHBhcnRzWzBdO1xuICBsZXQgc3RyaWN0ID0gdW5kZWZpbmVkO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IHBhcnRzLmxlbmd0aCAtIDE7ICsraSkge1xuICAgIGNvbnN0IGN1clNjaGVtYVR5cGUgPSBzY2hlbWEucGF0aChjdXIpO1xuICAgIGlmIChjdXJTY2hlbWFUeXBlICYmIGN1clNjaGVtYVR5cGUuc2NoZW1hKSB7XG4gICAgICBzdHJpY3QgPSBjdXJTY2hlbWFUeXBlLnNjaGVtYS5vcHRpb25zLnN0cmljdDtcbiAgICAgIHNjaGVtYSA9IGN1clNjaGVtYVR5cGUuc2NoZW1hO1xuICAgICAgY3VyID0gY3VyU2NoZW1hVHlwZS4kaXNNb25nb29zZURvY3VtZW50QXJyYXkgJiYgIWlzTmFOKHBhcnRzW2kgKyAxXSkgPyAnJyA6IHBhcnRzW2kgKyAxXTtcbiAgICB9IGVsc2Uge1xuICAgICAgY3VyICs9IGN1ci5sZW5ndGggPyAoJy4nICsgcGFydHNbaSArIDFdKSA6IHBhcnRzW2kgKyAxXTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gc3RyaWN0O1xufTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/mongoose/lib/helpers/schema/getSubdocumentStrictValue.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/mongoose/lib/helpers/schema/handleIdOption.js":
/*!********************************************************************!*\
  !*** ./node_modules/mongoose/lib/helpers/schema/handleIdOption.js ***!
  \********************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\n\nconst addAutoId = __webpack_require__(/*! ./addAutoId */ \"(ssr)/./node_modules/mongoose/lib/helpers/schema/addAutoId.js\");\n\nmodule.exports = function handleIdOption(schema, options) {\n  if (options == null || options._id == null) {\n    return schema;\n  }\n\n  schema = schema.clone();\n  if (!options._id) {\n    schema.remove('_id');\n    schema.options._id = false;\n  } else if (!schema.paths['_id']) {\n    addAutoId(schema);\n    schema.options._id = true;\n  }\n\n  return schema;\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbW9uZ29vc2UvbGliL2hlbHBlcnMvc2NoZW1hL2hhbmRsZUlkT3B0aW9uLmpzIiwibWFwcGluZ3MiOiJBQUFhOztBQUViLGtCQUFrQixtQkFBTyxDQUFDLGtGQUFhOztBQUV2QztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7O0FBRUE7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL2FwcDEvLi9ub2RlX21vZHVsZXMvbW9uZ29vc2UvbGliL2hlbHBlcnMvc2NoZW1hL2hhbmRsZUlkT3B0aW9uLmpzPzg5YjgiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG5jb25zdCBhZGRBdXRvSWQgPSByZXF1aXJlKCcuL2FkZEF1dG9JZCcpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGhhbmRsZUlkT3B0aW9uKHNjaGVtYSwgb3B0aW9ucykge1xuICBpZiAob3B0aW9ucyA9PSBudWxsIHx8IG9wdGlvbnMuX2lkID09IG51bGwpIHtcbiAgICByZXR1cm4gc2NoZW1hO1xuICB9XG5cbiAgc2NoZW1hID0gc2NoZW1hLmNsb25lKCk7XG4gIGlmICghb3B0aW9ucy5faWQpIHtcbiAgICBzY2hlbWEucmVtb3ZlKCdfaWQnKTtcbiAgICBzY2hlbWEub3B0aW9ucy5faWQgPSBmYWxzZTtcbiAgfSBlbHNlIGlmICghc2NoZW1hLnBhdGhzWydfaWQnXSkge1xuICAgIGFkZEF1dG9JZChzY2hlbWEpO1xuICAgIHNjaGVtYS5vcHRpb25zLl9pZCA9IHRydWU7XG4gIH1cblxuICByZXR1cm4gc2NoZW1hO1xufTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/mongoose/lib/helpers/schema/handleIdOption.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/mongoose/lib/helpers/schema/handleTimestampOption.js":
/*!***************************************************************************!*\
  !*** ./node_modules/mongoose/lib/helpers/schema/handleTimestampOption.js ***!
  \***************************************************************************/
/***/ ((module) => {

eval("\n\nmodule.exports = handleTimestampOption;\n\n/*!\n * ignore\n */\n\nfunction handleTimestampOption(arg, prop) {\n  if (arg == null) {\n    return null;\n  }\n\n  if (typeof arg === 'boolean') {\n    return prop;\n  }\n  if (typeof arg[prop] === 'boolean') {\n    return arg[prop] ? prop : null;\n  }\n  if (!(prop in arg)) {\n    return prop;\n  }\n  return arg[prop];\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbW9uZ29vc2UvbGliL2hlbHBlcnMvc2NoZW1hL2hhbmRsZVRpbWVzdGFtcE9wdGlvbi5qcyIsIm1hcHBpbmdzIjoiQUFBYTs7QUFFYjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL2FwcDEvLi9ub2RlX21vZHVsZXMvbW9uZ29vc2UvbGliL2hlbHBlcnMvc2NoZW1hL2hhbmRsZVRpbWVzdGFtcE9wdGlvbi5qcz9iYjAyIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxubW9kdWxlLmV4cG9ydHMgPSBoYW5kbGVUaW1lc3RhbXBPcHRpb247XG5cbi8qIVxuICogaWdub3JlXG4gKi9cblxuZnVuY3Rpb24gaGFuZGxlVGltZXN0YW1wT3B0aW9uKGFyZywgcHJvcCkge1xuICBpZiAoYXJnID09IG51bGwpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIGlmICh0eXBlb2YgYXJnID09PSAnYm9vbGVhbicpIHtcbiAgICByZXR1cm4gcHJvcDtcbiAgfVxuICBpZiAodHlwZW9mIGFyZ1twcm9wXSA9PT0gJ2Jvb2xlYW4nKSB7XG4gICAgcmV0dXJuIGFyZ1twcm9wXSA/IHByb3AgOiBudWxsO1xuICB9XG4gIGlmICghKHByb3AgaW4gYXJnKSkge1xuICAgIHJldHVybiBwcm9wO1xuICB9XG4gIHJldHVybiBhcmdbcHJvcF07XG59XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/mongoose/lib/helpers/schema/handleTimestampOption.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/mongoose/lib/helpers/schema/idGetter.js":
/*!**************************************************************!*\
  !*** ./node_modules/mongoose/lib/helpers/schema/idGetter.js ***!
  \**************************************************************/
/***/ ((module) => {

eval("\n\n/*!\n * ignore\n */\n\nmodule.exports = function addIdGetter(schema) {\n  // ensure the documents receive an id getter unless disabled\n  const autoIdGetter = !schema.paths['id'] &&\n    schema.paths['_id'] &&\n    schema.options.id;\n  if (!autoIdGetter) {\n    return schema;\n  }\n  if (schema.aliases && schema.aliases.id) {\n    return schema;\n  }\n  schema.virtual('id').get(idGetter);\n\n  return schema;\n};\n\n/**\n * Returns this documents _id cast to a string.\n * @api private\n */\n\nfunction idGetter() {\n  if (this._id != null) {\n    return String(this._id);\n  }\n\n  return null;\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbW9uZ29vc2UvbGliL2hlbHBlcnMvc2NoZW1hL2lkR2V0dGVyLmpzIiwibWFwcGluZ3MiOiJBQUFhOztBQUViO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vYXBwMS8uL25vZGVfbW9kdWxlcy9tb25nb29zZS9saWIvaGVscGVycy9zY2hlbWEvaWRHZXR0ZXIuanM/MzgwYyJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbi8qIVxuICogaWdub3JlXG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBhZGRJZEdldHRlcihzY2hlbWEpIHtcbiAgLy8gZW5zdXJlIHRoZSBkb2N1bWVudHMgcmVjZWl2ZSBhbiBpZCBnZXR0ZXIgdW5sZXNzIGRpc2FibGVkXG4gIGNvbnN0IGF1dG9JZEdldHRlciA9ICFzY2hlbWEucGF0aHNbJ2lkJ10gJiZcbiAgICBzY2hlbWEucGF0aHNbJ19pZCddICYmXG4gICAgc2NoZW1hLm9wdGlvbnMuaWQ7XG4gIGlmICghYXV0b0lkR2V0dGVyKSB7XG4gICAgcmV0dXJuIHNjaGVtYTtcbiAgfVxuICBpZiAoc2NoZW1hLmFsaWFzZXMgJiYgc2NoZW1hLmFsaWFzZXMuaWQpIHtcbiAgICByZXR1cm4gc2NoZW1hO1xuICB9XG4gIHNjaGVtYS52aXJ0dWFsKCdpZCcpLmdldChpZEdldHRlcik7XG5cbiAgcmV0dXJuIHNjaGVtYTtcbn07XG5cbi8qKlxuICogUmV0dXJucyB0aGlzIGRvY3VtZW50cyBfaWQgY2FzdCB0byBhIHN0cmluZy5cbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmZ1bmN0aW9uIGlkR2V0dGVyKCkge1xuICBpZiAodGhpcy5faWQgIT0gbnVsbCkge1xuICAgIHJldHVybiBTdHJpbmcodGhpcy5faWQpO1xuICB9XG5cbiAgcmV0dXJuIG51bGw7XG59XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/mongoose/lib/helpers/schema/idGetter.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/mongoose/lib/helpers/schema/merge.js":
/*!***********************************************************!*\
  !*** ./node_modules/mongoose/lib/helpers/schema/merge.js ***!
  \***********************************************************/
/***/ ((module) => {

eval("\n\nmodule.exports = function merge(s1, s2, skipConflictingPaths) {\n  const paths = Object.keys(s2.tree);\n  const pathsToAdd = {};\n  for (const key of paths) {\n    if (skipConflictingPaths && (s1.paths[key] || s1.nested[key] || s1.singleNestedPaths[key])) {\n      continue;\n    }\n    pathsToAdd[key] = s2.tree[key];\n  }\n  s1.options._isMerging = true;\n  s1.add(pathsToAdd, null);\n  delete s1.options._isMerging;\n\n  s1.callQueue = s1.callQueue.concat(s2.callQueue);\n  s1.method(s2.methods);\n  s1.static(s2.statics);\n\n  for (const [option, value] of Object.entries(s2._userProvidedOptions)) {\n    if (!(option in s1._userProvidedOptions)) {\n      s1.set(option, value);\n    }\n  }\n\n  for (const query in s2.query) {\n    s1.query[query] = s2.query[query];\n  }\n\n  for (const virtual in s2.virtuals) {\n    s1.virtuals[virtual] = s2.virtuals[virtual].clone();\n  }\n\n  s1._indexes = s1._indexes.concat(s2._indexes || []);\n  s1.s.hooks.merge(s2.s.hooks, false);\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbW9uZ29vc2UvbGliL2hlbHBlcnMvc2NoZW1hL21lcmdlLmpzIiwibWFwcGluZ3MiOiJBQUFhOztBQUViO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL2FwcDEvLi9ub2RlX21vZHVsZXMvbW9uZ29vc2UvbGliL2hlbHBlcnMvc2NoZW1hL21lcmdlLmpzPzUwOWYiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIG1lcmdlKHMxLCBzMiwgc2tpcENvbmZsaWN0aW5nUGF0aHMpIHtcbiAgY29uc3QgcGF0aHMgPSBPYmplY3Qua2V5cyhzMi50cmVlKTtcbiAgY29uc3QgcGF0aHNUb0FkZCA9IHt9O1xuICBmb3IgKGNvbnN0IGtleSBvZiBwYXRocykge1xuICAgIGlmIChza2lwQ29uZmxpY3RpbmdQYXRocyAmJiAoczEucGF0aHNba2V5XSB8fCBzMS5uZXN0ZWRba2V5XSB8fCBzMS5zaW5nbGVOZXN0ZWRQYXRoc1trZXldKSkge1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIHBhdGhzVG9BZGRba2V5XSA9IHMyLnRyZWVba2V5XTtcbiAgfVxuICBzMS5vcHRpb25zLl9pc01lcmdpbmcgPSB0cnVlO1xuICBzMS5hZGQocGF0aHNUb0FkZCwgbnVsbCk7XG4gIGRlbGV0ZSBzMS5vcHRpb25zLl9pc01lcmdpbmc7XG5cbiAgczEuY2FsbFF1ZXVlID0gczEuY2FsbFF1ZXVlLmNvbmNhdChzMi5jYWxsUXVldWUpO1xuICBzMS5tZXRob2QoczIubWV0aG9kcyk7XG4gIHMxLnN0YXRpYyhzMi5zdGF0aWNzKTtcblxuICBmb3IgKGNvbnN0IFtvcHRpb24sIHZhbHVlXSBvZiBPYmplY3QuZW50cmllcyhzMi5fdXNlclByb3ZpZGVkT3B0aW9ucykpIHtcbiAgICBpZiAoIShvcHRpb24gaW4gczEuX3VzZXJQcm92aWRlZE9wdGlvbnMpKSB7XG4gICAgICBzMS5zZXQob3B0aW9uLCB2YWx1ZSk7XG4gICAgfVxuICB9XG5cbiAgZm9yIChjb25zdCBxdWVyeSBpbiBzMi5xdWVyeSkge1xuICAgIHMxLnF1ZXJ5W3F1ZXJ5XSA9IHMyLnF1ZXJ5W3F1ZXJ5XTtcbiAgfVxuXG4gIGZvciAoY29uc3QgdmlydHVhbCBpbiBzMi52aXJ0dWFscykge1xuICAgIHMxLnZpcnR1YWxzW3ZpcnR1YWxdID0gczIudmlydHVhbHNbdmlydHVhbF0uY2xvbmUoKTtcbiAgfVxuXG4gIHMxLl9pbmRleGVzID0gczEuX2luZGV4ZXMuY29uY2F0KHMyLl9pbmRleGVzIHx8IFtdKTtcbiAgczEucy5ob29rcy5tZXJnZShzMi5zLmhvb2tzLCBmYWxzZSk7XG59O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/mongoose/lib/helpers/schema/merge.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/mongoose/lib/helpers/schematype/handleImmutable.js":
/*!*************************************************************************!*\
  !*** ./node_modules/mongoose/lib/helpers/schematype/handleImmutable.js ***!
  \*************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\n\nconst StrictModeError = __webpack_require__(/*! ../../error/strict */ \"(ssr)/./node_modules/mongoose/lib/error/strict.js\");\n\n/*!\n * ignore\n */\n\nmodule.exports = function(schematype) {\n  if (schematype.$immutable) {\n    schematype.$immutableSetter = createImmutableSetter(schematype.path,\n      schematype.options.immutable);\n    schematype.set(schematype.$immutableSetter);\n  } else if (schematype.$immutableSetter) {\n    schematype.setters = schematype.setters.\n      filter(fn => fn !== schematype.$immutableSetter);\n    delete schematype.$immutableSetter;\n  }\n};\n\nfunction createImmutableSetter(path, immutable) {\n  return function immutableSetter(v, _priorVal, _doc, options) {\n    if (this == null || this.$__ == null) {\n      return v;\n    }\n    if (this.isNew) {\n      return v;\n    }\n    if (options && options.overwriteImmutable) {\n      return v;\n    }\n\n    const _immutable = typeof immutable === 'function' ?\n      immutable.call(this, this) :\n      immutable;\n    if (!_immutable) {\n      return v;\n    }\n\n    const _value = this.$__.priorDoc != null ?\n      this.$__.priorDoc.$__getValue(path) :\n      this.$__getValue(path);\n    if (this.$__.strictMode === 'throw' && v !== _value) {\n      throw new StrictModeError(path, 'Path `' + path + '` is immutable ' +\n        'and strict mode is set to throw.', true);\n    }\n\n    return _value;\n  };\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbW9uZ29vc2UvbGliL2hlbHBlcnMvc2NoZW1hdHlwZS9oYW5kbGVJbW11dGFibGUuanMiLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWIsd0JBQXdCLG1CQUFPLENBQUMsNkVBQW9COztBQUVwRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL2FwcDEvLi9ub2RlX21vZHVsZXMvbW9uZ29vc2UvbGliL2hlbHBlcnMvc2NoZW1hdHlwZS9oYW5kbGVJbW11dGFibGUuanM/MTBhNyJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbmNvbnN0IFN0cmljdE1vZGVFcnJvciA9IHJlcXVpcmUoJy4uLy4uL2Vycm9yL3N0cmljdCcpO1xuXG4vKiFcbiAqIGlnbm9yZVxuICovXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oc2NoZW1hdHlwZSkge1xuICBpZiAoc2NoZW1hdHlwZS4kaW1tdXRhYmxlKSB7XG4gICAgc2NoZW1hdHlwZS4kaW1tdXRhYmxlU2V0dGVyID0gY3JlYXRlSW1tdXRhYmxlU2V0dGVyKHNjaGVtYXR5cGUucGF0aCxcbiAgICAgIHNjaGVtYXR5cGUub3B0aW9ucy5pbW11dGFibGUpO1xuICAgIHNjaGVtYXR5cGUuc2V0KHNjaGVtYXR5cGUuJGltbXV0YWJsZVNldHRlcik7XG4gIH0gZWxzZSBpZiAoc2NoZW1hdHlwZS4kaW1tdXRhYmxlU2V0dGVyKSB7XG4gICAgc2NoZW1hdHlwZS5zZXR0ZXJzID0gc2NoZW1hdHlwZS5zZXR0ZXJzLlxuICAgICAgZmlsdGVyKGZuID0+IGZuICE9PSBzY2hlbWF0eXBlLiRpbW11dGFibGVTZXR0ZXIpO1xuICAgIGRlbGV0ZSBzY2hlbWF0eXBlLiRpbW11dGFibGVTZXR0ZXI7XG4gIH1cbn07XG5cbmZ1bmN0aW9uIGNyZWF0ZUltbXV0YWJsZVNldHRlcihwYXRoLCBpbW11dGFibGUpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIGltbXV0YWJsZVNldHRlcih2LCBfcHJpb3JWYWwsIF9kb2MsIG9wdGlvbnMpIHtcbiAgICBpZiAodGhpcyA9PSBudWxsIHx8IHRoaXMuJF9fID09IG51bGwpIHtcbiAgICAgIHJldHVybiB2O1xuICAgIH1cbiAgICBpZiAodGhpcy5pc05ldykge1xuICAgICAgcmV0dXJuIHY7XG4gICAgfVxuICAgIGlmIChvcHRpb25zICYmIG9wdGlvbnMub3ZlcndyaXRlSW1tdXRhYmxlKSB7XG4gICAgICByZXR1cm4gdjtcbiAgICB9XG5cbiAgICBjb25zdCBfaW1tdXRhYmxlID0gdHlwZW9mIGltbXV0YWJsZSA9PT0gJ2Z1bmN0aW9uJyA/XG4gICAgICBpbW11dGFibGUuY2FsbCh0aGlzLCB0aGlzKSA6XG4gICAgICBpbW11dGFibGU7XG4gICAgaWYgKCFfaW1tdXRhYmxlKSB7XG4gICAgICByZXR1cm4gdjtcbiAgICB9XG5cbiAgICBjb25zdCBfdmFsdWUgPSB0aGlzLiRfXy5wcmlvckRvYyAhPSBudWxsID9cbiAgICAgIHRoaXMuJF9fLnByaW9yRG9jLiRfX2dldFZhbHVlKHBhdGgpIDpcbiAgICAgIHRoaXMuJF9fZ2V0VmFsdWUocGF0aCk7XG4gICAgaWYgKHRoaXMuJF9fLnN0cmljdE1vZGUgPT09ICd0aHJvdycgJiYgdiAhPT0gX3ZhbHVlKSB7XG4gICAgICB0aHJvdyBuZXcgU3RyaWN0TW9kZUVycm9yKHBhdGgsICdQYXRoIGAnICsgcGF0aCArICdgIGlzIGltbXV0YWJsZSAnICtcbiAgICAgICAgJ2FuZCBzdHJpY3QgbW9kZSBpcyBzZXQgdG8gdGhyb3cuJywgdHJ1ZSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIF92YWx1ZTtcbiAgfTtcbn1cbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/mongoose/lib/helpers/schematype/handleImmutable.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/mongoose/lib/helpers/setDefaultsOnInsert.js":
/*!******************************************************************!*\
  !*** ./node_modules/mongoose/lib/helpers/setDefaultsOnInsert.js ***!
  \******************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\nconst modifiedPaths = (__webpack_require__(/*! ./common */ \"(ssr)/./node_modules/mongoose/lib/helpers/common.js\").modifiedPaths);\nconst get = __webpack_require__(/*! ./get */ \"(ssr)/./node_modules/mongoose/lib/helpers/get.js\");\n\n/**\n * Applies defaults to update and findOneAndUpdate operations.\n *\n * @param {Object} filter\n * @param {Schema} schema\n * @param {Object} castedDoc\n * @param {Object} options\n * @method setDefaultsOnInsert\n * @api private\n */\n\nmodule.exports = function(filter, schema, castedDoc, options) {\n  options = options || {};\n\n  const shouldSetDefaultsOnInsert =\n    options.setDefaultsOnInsert != null ?\n      options.setDefaultsOnInsert :\n      schema.base.options.setDefaultsOnInsert;\n\n  if (!options.upsert || shouldSetDefaultsOnInsert === false) {\n    return castedDoc;\n  }\n\n  const keys = Object.keys(castedDoc || {});\n  const updatedKeys = {};\n  const updatedValues = {};\n  const numKeys = keys.length;\n  const modified = {};\n\n  let hasDollarUpdate = false;\n\n  for (let i = 0; i < numKeys; ++i) {\n    if (keys[i].startsWith('$')) {\n      modifiedPaths(castedDoc[keys[i]], '', modified);\n      hasDollarUpdate = true;\n    }\n  }\n\n  if (!hasDollarUpdate) {\n    modifiedPaths(castedDoc, '', modified);\n  }\n\n  const paths = Object.keys(filter);\n  const numPaths = paths.length;\n  for (let i = 0; i < numPaths; ++i) {\n    const path = paths[i];\n    const condition = filter[path];\n    if (condition && typeof condition === 'object') {\n      const conditionKeys = Object.keys(condition);\n      const numConditionKeys = conditionKeys.length;\n      let hasDollarKey = false;\n      for (let j = 0; j < numConditionKeys; ++j) {\n        if (conditionKeys[j].startsWith('$')) {\n          hasDollarKey = true;\n          break;\n        }\n      }\n      if (hasDollarKey) {\n        continue;\n      }\n    }\n    updatedKeys[path] = true;\n    modified[path] = true;\n  }\n\n  if (options && options.overwrite && !hasDollarUpdate) {\n    // Defaults will be set later, since we're overwriting we'll cast\n    // the whole update to a document\n    return castedDoc;\n  }\n\n  schema.eachPath(function(path, schemaType) {\n    // Skip single nested paths if underneath a map\n    if (schemaType.path === '_id' && schemaType.options.auto) {\n      return;\n    }\n    const def = schemaType.getDefault(null, true);\n    if (isModified(modified, path)) {\n      return;\n    }\n    if (typeof def === 'undefined') {\n      return;\n    }\n    if (schemaType.splitPath().includes('$*')) {\n      // Skip defaults underneath maps. We should never do `$setOnInsert` on a path with `$*`\n      return;\n    }\n\n    castedDoc = castedDoc || {};\n    castedDoc.$setOnInsert = castedDoc.$setOnInsert || {};\n    if (get(castedDoc, path) == null) {\n      castedDoc.$setOnInsert[path] = def;\n    }\n    updatedValues[path] = def;\n  });\n\n  return castedDoc;\n};\n\nfunction isModified(modified, path) {\n  if (modified[path]) {\n    return true;\n  }\n\n  // Is any parent path of `path` modified?\n  const sp = path.split('.');\n  let cur = sp[0];\n  for (let i = 1; i < sp.length; ++i) {\n    if (modified[cur]) {\n      return true;\n    }\n    cur += '.' + sp[i];\n  }\n\n  // Is any child of `path` modified?\n  const modifiedKeys = Object.keys(modified);\n  if (modifiedKeys.length) {\n    const parentPath = path + '.';\n\n    for (const modifiedPath of modifiedKeys) {\n      if (modifiedPath.slice(0, path.length + 1) === parentPath) {\n        return true;\n      }\n    }\n  }\n\n  return false;\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbW9uZ29vc2UvbGliL2hlbHBlcnMvc2V0RGVmYXVsdHNPbkluc2VydC5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLHNCQUFzQiwwR0FBaUM7QUFDdkQsWUFBWSxtQkFBTyxDQUFDLCtEQUFPOztBQUUzQjtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLDBDQUEwQztBQUMxQztBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxrQkFBa0IsYUFBYTtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esa0JBQWtCLGNBQWM7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLHNCQUFzQjtBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLGVBQWU7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL2FwcDEvLi9ub2RlX21vZHVsZXMvbW9uZ29vc2UvbGliL2hlbHBlcnMvc2V0RGVmYXVsdHNPbkluc2VydC5qcz9kMjljIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcbmNvbnN0IG1vZGlmaWVkUGF0aHMgPSByZXF1aXJlKCcuL2NvbW1vbicpLm1vZGlmaWVkUGF0aHM7XG5jb25zdCBnZXQgPSByZXF1aXJlKCcuL2dldCcpO1xuXG4vKipcbiAqIEFwcGxpZXMgZGVmYXVsdHMgdG8gdXBkYXRlIGFuZCBmaW5kT25lQW5kVXBkYXRlIG9wZXJhdGlvbnMuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IGZpbHRlclxuICogQHBhcmFtIHtTY2hlbWF9IHNjaGVtYVxuICogQHBhcmFtIHtPYmplY3R9IGNhc3RlZERvY1xuICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcbiAqIEBtZXRob2Qgc2V0RGVmYXVsdHNPbkluc2VydFxuICogQGFwaSBwcml2YXRlXG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihmaWx0ZXIsIHNjaGVtYSwgY2FzdGVkRG9jLCBvcHRpb25zKSB7XG4gIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuXG4gIGNvbnN0IHNob3VsZFNldERlZmF1bHRzT25JbnNlcnQgPVxuICAgIG9wdGlvbnMuc2V0RGVmYXVsdHNPbkluc2VydCAhPSBudWxsID9cbiAgICAgIG9wdGlvbnMuc2V0RGVmYXVsdHNPbkluc2VydCA6XG4gICAgICBzY2hlbWEuYmFzZS5vcHRpb25zLnNldERlZmF1bHRzT25JbnNlcnQ7XG5cbiAgaWYgKCFvcHRpb25zLnVwc2VydCB8fCBzaG91bGRTZXREZWZhdWx0c09uSW5zZXJ0ID09PSBmYWxzZSkge1xuICAgIHJldHVybiBjYXN0ZWREb2M7XG4gIH1cblxuICBjb25zdCBrZXlzID0gT2JqZWN0LmtleXMoY2FzdGVkRG9jIHx8IHt9KTtcbiAgY29uc3QgdXBkYXRlZEtleXMgPSB7fTtcbiAgY29uc3QgdXBkYXRlZFZhbHVlcyA9IHt9O1xuICBjb25zdCBudW1LZXlzID0ga2V5cy5sZW5ndGg7XG4gIGNvbnN0IG1vZGlmaWVkID0ge307XG5cbiAgbGV0IGhhc0RvbGxhclVwZGF0ZSA9IGZhbHNlO1xuXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgbnVtS2V5czsgKytpKSB7XG4gICAgaWYgKGtleXNbaV0uc3RhcnRzV2l0aCgnJCcpKSB7XG4gICAgICBtb2RpZmllZFBhdGhzKGNhc3RlZERvY1trZXlzW2ldXSwgJycsIG1vZGlmaWVkKTtcbiAgICAgIGhhc0RvbGxhclVwZGF0ZSA9IHRydWU7XG4gICAgfVxuICB9XG5cbiAgaWYgKCFoYXNEb2xsYXJVcGRhdGUpIHtcbiAgICBtb2RpZmllZFBhdGhzKGNhc3RlZERvYywgJycsIG1vZGlmaWVkKTtcbiAgfVxuXG4gIGNvbnN0IHBhdGhzID0gT2JqZWN0LmtleXMoZmlsdGVyKTtcbiAgY29uc3QgbnVtUGF0aHMgPSBwYXRocy5sZW5ndGg7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgbnVtUGF0aHM7ICsraSkge1xuICAgIGNvbnN0IHBhdGggPSBwYXRoc1tpXTtcbiAgICBjb25zdCBjb25kaXRpb24gPSBmaWx0ZXJbcGF0aF07XG4gICAgaWYgKGNvbmRpdGlvbiAmJiB0eXBlb2YgY29uZGl0aW9uID09PSAnb2JqZWN0Jykge1xuICAgICAgY29uc3QgY29uZGl0aW9uS2V5cyA9IE9iamVjdC5rZXlzKGNvbmRpdGlvbik7XG4gICAgICBjb25zdCBudW1Db25kaXRpb25LZXlzID0gY29uZGl0aW9uS2V5cy5sZW5ndGg7XG4gICAgICBsZXQgaGFzRG9sbGFyS2V5ID0gZmFsc2U7XG4gICAgICBmb3IgKGxldCBqID0gMDsgaiA8IG51bUNvbmRpdGlvbktleXM7ICsraikge1xuICAgICAgICBpZiAoY29uZGl0aW9uS2V5c1tqXS5zdGFydHNXaXRoKCckJykpIHtcbiAgICAgICAgICBoYXNEb2xsYXJLZXkgPSB0cnVlO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoaGFzRG9sbGFyS2V5KSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgIH1cbiAgICB1cGRhdGVkS2V5c1twYXRoXSA9IHRydWU7XG4gICAgbW9kaWZpZWRbcGF0aF0gPSB0cnVlO1xuICB9XG5cbiAgaWYgKG9wdGlvbnMgJiYgb3B0aW9ucy5vdmVyd3JpdGUgJiYgIWhhc0RvbGxhclVwZGF0ZSkge1xuICAgIC8vIERlZmF1bHRzIHdpbGwgYmUgc2V0IGxhdGVyLCBzaW5jZSB3ZSdyZSBvdmVyd3JpdGluZyB3ZSdsbCBjYXN0XG4gICAgLy8gdGhlIHdob2xlIHVwZGF0ZSB0byBhIGRvY3VtZW50XG4gICAgcmV0dXJuIGNhc3RlZERvYztcbiAgfVxuXG4gIHNjaGVtYS5lYWNoUGF0aChmdW5jdGlvbihwYXRoLCBzY2hlbWFUeXBlKSB7XG4gICAgLy8gU2tpcCBzaW5nbGUgbmVzdGVkIHBhdGhzIGlmIHVuZGVybmVhdGggYSBtYXBcbiAgICBpZiAoc2NoZW1hVHlwZS5wYXRoID09PSAnX2lkJyAmJiBzY2hlbWFUeXBlLm9wdGlvbnMuYXV0bykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBkZWYgPSBzY2hlbWFUeXBlLmdldERlZmF1bHQobnVsbCwgdHJ1ZSk7XG4gICAgaWYgKGlzTW9kaWZpZWQobW9kaWZpZWQsIHBhdGgpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmICh0eXBlb2YgZGVmID09PSAndW5kZWZpbmVkJykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoc2NoZW1hVHlwZS5zcGxpdFBhdGgoKS5pbmNsdWRlcygnJConKSkge1xuICAgICAgLy8gU2tpcCBkZWZhdWx0cyB1bmRlcm5lYXRoIG1hcHMuIFdlIHNob3VsZCBuZXZlciBkbyBgJHNldE9uSW5zZXJ0YCBvbiBhIHBhdGggd2l0aCBgJCpgXG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgY2FzdGVkRG9jID0gY2FzdGVkRG9jIHx8IHt9O1xuICAgIGNhc3RlZERvYy4kc2V0T25JbnNlcnQgPSBjYXN0ZWREb2MuJHNldE9uSW5zZXJ0IHx8IHt9O1xuICAgIGlmIChnZXQoY2FzdGVkRG9jLCBwYXRoKSA9PSBudWxsKSB7XG4gICAgICBjYXN0ZWREb2MuJHNldE9uSW5zZXJ0W3BhdGhdID0gZGVmO1xuICAgIH1cbiAgICB1cGRhdGVkVmFsdWVzW3BhdGhdID0gZGVmO1xuICB9KTtcblxuICByZXR1cm4gY2FzdGVkRG9jO1xufTtcblxuZnVuY3Rpb24gaXNNb2RpZmllZChtb2RpZmllZCwgcGF0aCkge1xuICBpZiAobW9kaWZpZWRbcGF0aF0pIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIC8vIElzIGFueSBwYXJlbnQgcGF0aCBvZiBgcGF0aGAgbW9kaWZpZWQ/XG4gIGNvbnN0IHNwID0gcGF0aC5zcGxpdCgnLicpO1xuICBsZXQgY3VyID0gc3BbMF07XG4gIGZvciAobGV0IGkgPSAxOyBpIDwgc3AubGVuZ3RoOyArK2kpIHtcbiAgICBpZiAobW9kaWZpZWRbY3VyXSkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGN1ciArPSAnLicgKyBzcFtpXTtcbiAgfVxuXG4gIC8vIElzIGFueSBjaGlsZCBvZiBgcGF0aGAgbW9kaWZpZWQ/XG4gIGNvbnN0IG1vZGlmaWVkS2V5cyA9IE9iamVjdC5rZXlzKG1vZGlmaWVkKTtcbiAgaWYgKG1vZGlmaWVkS2V5cy5sZW5ndGgpIHtcbiAgICBjb25zdCBwYXJlbnRQYXRoID0gcGF0aCArICcuJztcblxuICAgIGZvciAoY29uc3QgbW9kaWZpZWRQYXRoIG9mIG1vZGlmaWVkS2V5cykge1xuICAgICAgaWYgKG1vZGlmaWVkUGF0aC5zbGljZSgwLCBwYXRoLmxlbmd0aCArIDEpID09PSBwYXJlbnRQYXRoKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBmYWxzZTtcbn1cbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/mongoose/lib/helpers/setDefaultsOnInsert.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/mongoose/lib/helpers/specialProperties.js":
/*!****************************************************************!*\
  !*** ./node_modules/mongoose/lib/helpers/specialProperties.js ***!
  \****************************************************************/
/***/ ((module) => {

eval("\n\nmodule.exports = new Set(['__proto__', 'constructor', 'prototype']);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbW9uZ29vc2UvbGliL2hlbHBlcnMvc3BlY2lhbFByb3BlcnRpZXMuanMiLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9hcHAxLy4vbm9kZV9tb2R1bGVzL21vbmdvb3NlL2xpYi9oZWxwZXJzL3NwZWNpYWxQcm9wZXJ0aWVzLmpzP2JiZGQiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG5tb2R1bGUuZXhwb3J0cyA9IG5ldyBTZXQoWydfX3Byb3RvX18nLCAnY29uc3RydWN0b3InLCAncHJvdG90eXBlJ10pO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/mongoose/lib/helpers/specialProperties.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/mongoose/lib/helpers/symbols.js":
/*!******************************************************!*\
  !*** ./node_modules/mongoose/lib/helpers/symbols.js ***!
  \******************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\n\nexports.arrayAtomicsBackupSymbol = Symbol('mongoose#Array#atomicsBackup');\nexports.arrayAtomicsSymbol = Symbol('mongoose#Array#_atomics');\nexports.arrayParentSymbol = Symbol('mongoose#Array#_parent');\nexports.arrayPathSymbol = Symbol('mongoose#Array#_path');\nexports.arraySchemaSymbol = Symbol('mongoose#Array#_schema');\nexports.documentArrayParent = Symbol('mongoose#documentArrayParent');\nexports.documentIsSelected = Symbol('mongoose#Document#isSelected');\nexports.documentIsModified = Symbol('mongoose#Document#isModified');\nexports.documentModifiedPaths = Symbol('mongoose#Document#modifiedPaths');\nexports.documentSchemaSymbol = Symbol('mongoose#Document#schema');\nexports.getSymbol = Symbol('mongoose#Document#get');\nexports.modelSymbol = Symbol('mongoose#Model');\nexports.objectIdSymbol = Symbol('mongoose#ObjectId');\nexports.populateModelSymbol = Symbol('mongoose#PopulateOptions#Model');\nexports.schemaTypeSymbol = Symbol('mongoose#schemaType');\nexports.sessionNewDocuments = Symbol('mongoose#ClientSession#newDocuments');\nexports.scopeSymbol = Symbol('mongoose#Document#scope');\nexports.validatorErrorSymbol = Symbol('mongoose#validatorError');\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbW9uZ29vc2UvbGliL2hlbHBlcnMvc3ltYm9scy5qcyIsIm1hcHBpbmdzIjoiQUFBYTs7QUFFYixnQ0FBZ0M7QUFDaEMsMEJBQTBCO0FBQzFCLHlCQUF5QjtBQUN6Qix1QkFBdUI7QUFDdkIseUJBQXlCO0FBQ3pCLDJCQUEyQjtBQUMzQiwwQkFBMEI7QUFDMUIsMEJBQTBCO0FBQzFCLDZCQUE2QjtBQUM3Qiw0QkFBNEI7QUFDNUIsaUJBQWlCO0FBQ2pCLG1CQUFtQjtBQUNuQixzQkFBc0I7QUFDdEIsMkJBQTJCO0FBQzNCLHdCQUF3QjtBQUN4QiwyQkFBMkI7QUFDM0IsbUJBQW1CO0FBQ25CLDRCQUE0QiIsInNvdXJjZXMiOlsid2VicGFjazovL2FwcDEvLi9ub2RlX21vZHVsZXMvbW9uZ29vc2UvbGliL2hlbHBlcnMvc3ltYm9scy5qcz8wNWQzIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxuZXhwb3J0cy5hcnJheUF0b21pY3NCYWNrdXBTeW1ib2wgPSBTeW1ib2woJ21vbmdvb3NlI0FycmF5I2F0b21pY3NCYWNrdXAnKTtcbmV4cG9ydHMuYXJyYXlBdG9taWNzU3ltYm9sID0gU3ltYm9sKCdtb25nb29zZSNBcnJheSNfYXRvbWljcycpO1xuZXhwb3J0cy5hcnJheVBhcmVudFN5bWJvbCA9IFN5bWJvbCgnbW9uZ29vc2UjQXJyYXkjX3BhcmVudCcpO1xuZXhwb3J0cy5hcnJheVBhdGhTeW1ib2wgPSBTeW1ib2woJ21vbmdvb3NlI0FycmF5I19wYXRoJyk7XG5leHBvcnRzLmFycmF5U2NoZW1hU3ltYm9sID0gU3ltYm9sKCdtb25nb29zZSNBcnJheSNfc2NoZW1hJyk7XG5leHBvcnRzLmRvY3VtZW50QXJyYXlQYXJlbnQgPSBTeW1ib2woJ21vbmdvb3NlI2RvY3VtZW50QXJyYXlQYXJlbnQnKTtcbmV4cG9ydHMuZG9jdW1lbnRJc1NlbGVjdGVkID0gU3ltYm9sKCdtb25nb29zZSNEb2N1bWVudCNpc1NlbGVjdGVkJyk7XG5leHBvcnRzLmRvY3VtZW50SXNNb2RpZmllZCA9IFN5bWJvbCgnbW9uZ29vc2UjRG9jdW1lbnQjaXNNb2RpZmllZCcpO1xuZXhwb3J0cy5kb2N1bWVudE1vZGlmaWVkUGF0aHMgPSBTeW1ib2woJ21vbmdvb3NlI0RvY3VtZW50I21vZGlmaWVkUGF0aHMnKTtcbmV4cG9ydHMuZG9jdW1lbnRTY2hlbWFTeW1ib2wgPSBTeW1ib2woJ21vbmdvb3NlI0RvY3VtZW50I3NjaGVtYScpO1xuZXhwb3J0cy5nZXRTeW1ib2wgPSBTeW1ib2woJ21vbmdvb3NlI0RvY3VtZW50I2dldCcpO1xuZXhwb3J0cy5tb2RlbFN5bWJvbCA9IFN5bWJvbCgnbW9uZ29vc2UjTW9kZWwnKTtcbmV4cG9ydHMub2JqZWN0SWRTeW1ib2wgPSBTeW1ib2woJ21vbmdvb3NlI09iamVjdElkJyk7XG5leHBvcnRzLnBvcHVsYXRlTW9kZWxTeW1ib2wgPSBTeW1ib2woJ21vbmdvb3NlI1BvcHVsYXRlT3B0aW9ucyNNb2RlbCcpO1xuZXhwb3J0cy5zY2hlbWFUeXBlU3ltYm9sID0gU3ltYm9sKCdtb25nb29zZSNzY2hlbWFUeXBlJyk7XG5leHBvcnRzLnNlc3Npb25OZXdEb2N1bWVudHMgPSBTeW1ib2woJ21vbmdvb3NlI0NsaWVudFNlc3Npb24jbmV3RG9jdW1lbnRzJyk7XG5leHBvcnRzLnNjb3BlU3ltYm9sID0gU3ltYm9sKCdtb25nb29zZSNEb2N1bWVudCNzY29wZScpO1xuZXhwb3J0cy52YWxpZGF0b3JFcnJvclN5bWJvbCA9IFN5bWJvbCgnbW9uZ29vc2UjdmFsaWRhdG9yRXJyb3InKTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/mongoose/lib/helpers/symbols.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/mongoose/lib/helpers/timers.js":
/*!*****************************************************!*\
  !*** ./node_modules/mongoose/lib/helpers/timers.js ***!
  \*****************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\n\nexports.setTimeout = setTimeout;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbW9uZ29vc2UvbGliL2hlbHBlcnMvdGltZXJzLmpzIiwibWFwcGluZ3MiOiJBQUFhOztBQUViLGtCQUFrQiIsInNvdXJjZXMiOlsid2VicGFjazovL2FwcDEvLi9ub2RlX21vZHVsZXMvbW9uZ29vc2UvbGliL2hlbHBlcnMvdGltZXJzLmpzPzE2NjUiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG5leHBvcnRzLnNldFRpbWVvdXQgPSBzZXRUaW1lb3V0O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/mongoose/lib/helpers/timers.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/mongoose/lib/helpers/timestamps/setDocumentTimestamps.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/mongoose/lib/helpers/timestamps/setDocumentTimestamps.js ***!
  \*******************************************************************************/
/***/ ((module) => {

eval("\n\nmodule.exports = function setDocumentTimestamps(doc, timestampOption, currentTime, createdAt, updatedAt) {\n  const skipUpdatedAt = timestampOption != null && timestampOption.updatedAt === false;\n  const skipCreatedAt = timestampOption != null && timestampOption.createdAt === false;\n\n  const defaultTimestamp = currentTime != null ?\n    currentTime() :\n    doc.ownerDocument().constructor.base.now();\n\n  if (!skipCreatedAt &&\n      (doc.isNew || doc.$isSubdocument) &&\n      createdAt &&\n      !doc.$__getValue(createdAt) &&\n      doc.$__isSelected(createdAt)) {\n    doc.$set(createdAt, defaultTimestamp, undefined, { overwriteImmutable: true });\n  }\n\n  if (!skipUpdatedAt && updatedAt && (doc.isNew || doc.$isModified())) {\n    let ts = defaultTimestamp;\n    if (doc.isNew && createdAt != null) {\n      ts = doc.$__getValue(createdAt);\n    }\n    doc.$set(updatedAt, ts);\n  }\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbW9uZ29vc2UvbGliL2hlbHBlcnMvdGltZXN0YW1wcy9zZXREb2N1bWVudFRpbWVzdGFtcHMuanMiLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdURBQXVELDBCQUEwQjtBQUNqRjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vYXBwMS8uL25vZGVfbW9kdWxlcy9tb25nb29zZS9saWIvaGVscGVycy90aW1lc3RhbXBzL3NldERvY3VtZW50VGltZXN0YW1wcy5qcz9hNTlhIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBzZXREb2N1bWVudFRpbWVzdGFtcHMoZG9jLCB0aW1lc3RhbXBPcHRpb24sIGN1cnJlbnRUaW1lLCBjcmVhdGVkQXQsIHVwZGF0ZWRBdCkge1xuICBjb25zdCBza2lwVXBkYXRlZEF0ID0gdGltZXN0YW1wT3B0aW9uICE9IG51bGwgJiYgdGltZXN0YW1wT3B0aW9uLnVwZGF0ZWRBdCA9PT0gZmFsc2U7XG4gIGNvbnN0IHNraXBDcmVhdGVkQXQgPSB0aW1lc3RhbXBPcHRpb24gIT0gbnVsbCAmJiB0aW1lc3RhbXBPcHRpb24uY3JlYXRlZEF0ID09PSBmYWxzZTtcblxuICBjb25zdCBkZWZhdWx0VGltZXN0YW1wID0gY3VycmVudFRpbWUgIT0gbnVsbCA/XG4gICAgY3VycmVudFRpbWUoKSA6XG4gICAgZG9jLm93bmVyRG9jdW1lbnQoKS5jb25zdHJ1Y3Rvci5iYXNlLm5vdygpO1xuXG4gIGlmICghc2tpcENyZWF0ZWRBdCAmJlxuICAgICAgKGRvYy5pc05ldyB8fCBkb2MuJGlzU3ViZG9jdW1lbnQpICYmXG4gICAgICBjcmVhdGVkQXQgJiZcbiAgICAgICFkb2MuJF9fZ2V0VmFsdWUoY3JlYXRlZEF0KSAmJlxuICAgICAgZG9jLiRfX2lzU2VsZWN0ZWQoY3JlYXRlZEF0KSkge1xuICAgIGRvYy4kc2V0KGNyZWF0ZWRBdCwgZGVmYXVsdFRpbWVzdGFtcCwgdW5kZWZpbmVkLCB7IG92ZXJ3cml0ZUltbXV0YWJsZTogdHJ1ZSB9KTtcbiAgfVxuXG4gIGlmICghc2tpcFVwZGF0ZWRBdCAmJiB1cGRhdGVkQXQgJiYgKGRvYy5pc05ldyB8fCBkb2MuJGlzTW9kaWZpZWQoKSkpIHtcbiAgICBsZXQgdHMgPSBkZWZhdWx0VGltZXN0YW1wO1xuICAgIGlmIChkb2MuaXNOZXcgJiYgY3JlYXRlZEF0ICE9IG51bGwpIHtcbiAgICAgIHRzID0gZG9jLiRfX2dldFZhbHVlKGNyZWF0ZWRBdCk7XG4gICAgfVxuICAgIGRvYy4kc2V0KHVwZGF0ZWRBdCwgdHMpO1xuICB9XG59O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/mongoose/lib/helpers/timestamps/setDocumentTimestamps.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/mongoose/lib/helpers/timestamps/setupTimestamps.js":
/*!*************************************************************************!*\
  !*** ./node_modules/mongoose/lib/helpers/timestamps/setupTimestamps.js ***!
  \*************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\n\nconst applyTimestampsToChildren = __webpack_require__(/*! ../update/applyTimestampsToChildren */ \"(ssr)/./node_modules/mongoose/lib/helpers/update/applyTimestampsToChildren.js\");\nconst applyTimestampsToUpdate = __webpack_require__(/*! ../update/applyTimestampsToUpdate */ \"(ssr)/./node_modules/mongoose/lib/helpers/update/applyTimestampsToUpdate.js\");\nconst get = __webpack_require__(/*! ../get */ \"(ssr)/./node_modules/mongoose/lib/helpers/get.js\");\nconst handleTimestampOption = __webpack_require__(/*! ../schema/handleTimestampOption */ \"(ssr)/./node_modules/mongoose/lib/helpers/schema/handleTimestampOption.js\");\nconst setDocumentTimestamps = __webpack_require__(/*! ./setDocumentTimestamps */ \"(ssr)/./node_modules/mongoose/lib/helpers/timestamps/setDocumentTimestamps.js\");\nconst symbols = __webpack_require__(/*! ../../schema/symbols */ \"(ssr)/./node_modules/mongoose/lib/schema/symbols.js\");\n\nconst replaceOps = new Set([\n  'replaceOne',\n  'findOneAndReplace'\n]);\n\nmodule.exports = function setupTimestamps(schema, timestamps) {\n  const childHasTimestamp = schema.childSchemas.find(withTimestamp);\n  function withTimestamp(s) {\n    const ts = s.schema.options.timestamps;\n    return !!ts;\n  }\n  if (!timestamps && !childHasTimestamp) {\n    return;\n  }\n  const createdAt = handleTimestampOption(timestamps, 'createdAt');\n  const updatedAt = handleTimestampOption(timestamps, 'updatedAt');\n  const currentTime = timestamps != null && timestamps.hasOwnProperty('currentTime') ?\n    timestamps.currentTime :\n    null;\n  const schemaAdditions = {};\n\n  schema.$timestamps = { createdAt: createdAt, updatedAt: updatedAt };\n\n  if (createdAt && !schema.paths[createdAt]) {\n    const baseImmutableCreatedAt = schema.base != null ? schema.base.get('timestamps.createdAt.immutable') : null;\n    const immutable = baseImmutableCreatedAt != null ? baseImmutableCreatedAt : true;\n    schemaAdditions[createdAt] = { [schema.options.typeKey || 'type']: Date, immutable };\n  }\n\n  if (updatedAt && !schema.paths[updatedAt]) {\n    schemaAdditions[updatedAt] = Date;\n  }\n\n  schema.add(schemaAdditions);\n\n  schema.pre('save', function timestampsPreSave(next) {\n    const timestampOption = get(this, '$__.saveOptions.timestamps');\n    if (timestampOption === false) {\n      return next();\n    }\n\n    setDocumentTimestamps(this, timestampOption, currentTime, createdAt, updatedAt);\n\n    next();\n  });\n\n  schema.methods.initializeTimestamps = function() {\n    const ts = currentTime != null ?\n      currentTime() : this.constructor.base.now();\n\n\n    if (createdAt && !this.get(createdAt)) {\n      this.$set(createdAt, ts);\n    }\n    if (updatedAt && !this.get(updatedAt)) {\n      this.$set(updatedAt, ts);\n    }\n    if (this.$isSubdocument) {\n      return this;\n    }\n\n    const subdocs = this.$getAllSubdocs();\n    for (const subdoc of subdocs) {\n      if (subdoc.initializeTimestamps) {\n        subdoc.initializeTimestamps();\n      }\n    }\n\n    return this;\n  };\n\n  _setTimestampsOnUpdate[symbols.builtInMiddleware] = true;\n\n  const opts = { query: true, model: false };\n  schema.pre('findOneAndReplace', opts, _setTimestampsOnUpdate);\n  schema.pre('findOneAndUpdate', opts, _setTimestampsOnUpdate);\n  schema.pre('replaceOne', opts, _setTimestampsOnUpdate);\n  schema.pre('update', opts, _setTimestampsOnUpdate);\n  schema.pre('updateOne', opts, _setTimestampsOnUpdate);\n  schema.pre('updateMany', opts, _setTimestampsOnUpdate);\n\n  function _setTimestampsOnUpdate(next) {\n    const now = currentTime != null ?\n      currentTime() :\n      this.model.base.now();\n    // Replacing with null update should still trigger timestamps\n    if (replaceOps.has(this.op) && this.getUpdate() == null) {\n      this.setUpdate({});\n    }\n    applyTimestampsToUpdate(\n      now,\n      createdAt,\n      updatedAt,\n      this.getUpdate(),\n      this._mongooseOptions,\n      replaceOps.has(this.op)\n    );\n    applyTimestampsToChildren(now, this.getUpdate(), this.model.schema);\n    next();\n  }\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbW9uZ29vc2UvbGliL2hlbHBlcnMvdGltZXN0YW1wcy9zZXR1cFRpbWVzdGFtcHMuanMiLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWIsa0NBQWtDLG1CQUFPLENBQUMsMEhBQXFDO0FBQy9FLGdDQUFnQyxtQkFBTyxDQUFDLHNIQUFtQztBQUMzRSxZQUFZLG1CQUFPLENBQUMsZ0VBQVE7QUFDNUIsOEJBQThCLG1CQUFPLENBQUMsa0hBQWlDO0FBQ3ZFLDhCQUE4QixtQkFBTyxDQUFDLDhHQUF5QjtBQUMvRCxnQkFBZ0IsbUJBQU8sQ0FBQyxpRkFBc0I7O0FBRTlDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSx5QkFBeUI7O0FBRXpCO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQztBQUNuQzs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUEsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUI7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9hcHAxLy4vbm9kZV9tb2R1bGVzL21vbmdvb3NlL2xpYi9oZWxwZXJzL3RpbWVzdGFtcHMvc2V0dXBUaW1lc3RhbXBzLmpzP2YyODQiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG5jb25zdCBhcHBseVRpbWVzdGFtcHNUb0NoaWxkcmVuID0gcmVxdWlyZSgnLi4vdXBkYXRlL2FwcGx5VGltZXN0YW1wc1RvQ2hpbGRyZW4nKTtcbmNvbnN0IGFwcGx5VGltZXN0YW1wc1RvVXBkYXRlID0gcmVxdWlyZSgnLi4vdXBkYXRlL2FwcGx5VGltZXN0YW1wc1RvVXBkYXRlJyk7XG5jb25zdCBnZXQgPSByZXF1aXJlKCcuLi9nZXQnKTtcbmNvbnN0IGhhbmRsZVRpbWVzdGFtcE9wdGlvbiA9IHJlcXVpcmUoJy4uL3NjaGVtYS9oYW5kbGVUaW1lc3RhbXBPcHRpb24nKTtcbmNvbnN0IHNldERvY3VtZW50VGltZXN0YW1wcyA9IHJlcXVpcmUoJy4vc2V0RG9jdW1lbnRUaW1lc3RhbXBzJyk7XG5jb25zdCBzeW1ib2xzID0gcmVxdWlyZSgnLi4vLi4vc2NoZW1hL3N5bWJvbHMnKTtcblxuY29uc3QgcmVwbGFjZU9wcyA9IG5ldyBTZXQoW1xuICAncmVwbGFjZU9uZScsXG4gICdmaW5kT25lQW5kUmVwbGFjZSdcbl0pO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIHNldHVwVGltZXN0YW1wcyhzY2hlbWEsIHRpbWVzdGFtcHMpIHtcbiAgY29uc3QgY2hpbGRIYXNUaW1lc3RhbXAgPSBzY2hlbWEuY2hpbGRTY2hlbWFzLmZpbmQod2l0aFRpbWVzdGFtcCk7XG4gIGZ1bmN0aW9uIHdpdGhUaW1lc3RhbXAocykge1xuICAgIGNvbnN0IHRzID0gcy5zY2hlbWEub3B0aW9ucy50aW1lc3RhbXBzO1xuICAgIHJldHVybiAhIXRzO1xuICB9XG4gIGlmICghdGltZXN0YW1wcyAmJiAhY2hpbGRIYXNUaW1lc3RhbXApIHtcbiAgICByZXR1cm47XG4gIH1cbiAgY29uc3QgY3JlYXRlZEF0ID0gaGFuZGxlVGltZXN0YW1wT3B0aW9uKHRpbWVzdGFtcHMsICdjcmVhdGVkQXQnKTtcbiAgY29uc3QgdXBkYXRlZEF0ID0gaGFuZGxlVGltZXN0YW1wT3B0aW9uKHRpbWVzdGFtcHMsICd1cGRhdGVkQXQnKTtcbiAgY29uc3QgY3VycmVudFRpbWUgPSB0aW1lc3RhbXBzICE9IG51bGwgJiYgdGltZXN0YW1wcy5oYXNPd25Qcm9wZXJ0eSgnY3VycmVudFRpbWUnKSA/XG4gICAgdGltZXN0YW1wcy5jdXJyZW50VGltZSA6XG4gICAgbnVsbDtcbiAgY29uc3Qgc2NoZW1hQWRkaXRpb25zID0ge307XG5cbiAgc2NoZW1hLiR0aW1lc3RhbXBzID0geyBjcmVhdGVkQXQ6IGNyZWF0ZWRBdCwgdXBkYXRlZEF0OiB1cGRhdGVkQXQgfTtcblxuICBpZiAoY3JlYXRlZEF0ICYmICFzY2hlbWEucGF0aHNbY3JlYXRlZEF0XSkge1xuICAgIGNvbnN0IGJhc2VJbW11dGFibGVDcmVhdGVkQXQgPSBzY2hlbWEuYmFzZSAhPSBudWxsID8gc2NoZW1hLmJhc2UuZ2V0KCd0aW1lc3RhbXBzLmNyZWF0ZWRBdC5pbW11dGFibGUnKSA6IG51bGw7XG4gICAgY29uc3QgaW1tdXRhYmxlID0gYmFzZUltbXV0YWJsZUNyZWF0ZWRBdCAhPSBudWxsID8gYmFzZUltbXV0YWJsZUNyZWF0ZWRBdCA6IHRydWU7XG4gICAgc2NoZW1hQWRkaXRpb25zW2NyZWF0ZWRBdF0gPSB7IFtzY2hlbWEub3B0aW9ucy50eXBlS2V5IHx8ICd0eXBlJ106IERhdGUsIGltbXV0YWJsZSB9O1xuICB9XG5cbiAgaWYgKHVwZGF0ZWRBdCAmJiAhc2NoZW1hLnBhdGhzW3VwZGF0ZWRBdF0pIHtcbiAgICBzY2hlbWFBZGRpdGlvbnNbdXBkYXRlZEF0XSA9IERhdGU7XG4gIH1cblxuICBzY2hlbWEuYWRkKHNjaGVtYUFkZGl0aW9ucyk7XG5cbiAgc2NoZW1hLnByZSgnc2F2ZScsIGZ1bmN0aW9uIHRpbWVzdGFtcHNQcmVTYXZlKG5leHQpIHtcbiAgICBjb25zdCB0aW1lc3RhbXBPcHRpb24gPSBnZXQodGhpcywgJyRfXy5zYXZlT3B0aW9ucy50aW1lc3RhbXBzJyk7XG4gICAgaWYgKHRpbWVzdGFtcE9wdGlvbiA9PT0gZmFsc2UpIHtcbiAgICAgIHJldHVybiBuZXh0KCk7XG4gICAgfVxuXG4gICAgc2V0RG9jdW1lbnRUaW1lc3RhbXBzKHRoaXMsIHRpbWVzdGFtcE9wdGlvbiwgY3VycmVudFRpbWUsIGNyZWF0ZWRBdCwgdXBkYXRlZEF0KTtcblxuICAgIG5leHQoKTtcbiAgfSk7XG5cbiAgc2NoZW1hLm1ldGhvZHMuaW5pdGlhbGl6ZVRpbWVzdGFtcHMgPSBmdW5jdGlvbigpIHtcbiAgICBjb25zdCB0cyA9IGN1cnJlbnRUaW1lICE9IG51bGwgP1xuICAgICAgY3VycmVudFRpbWUoKSA6IHRoaXMuY29uc3RydWN0b3IuYmFzZS5ub3coKTtcblxuXG4gICAgaWYgKGNyZWF0ZWRBdCAmJiAhdGhpcy5nZXQoY3JlYXRlZEF0KSkge1xuICAgICAgdGhpcy4kc2V0KGNyZWF0ZWRBdCwgdHMpO1xuICAgIH1cbiAgICBpZiAodXBkYXRlZEF0ICYmICF0aGlzLmdldCh1cGRhdGVkQXQpKSB7XG4gICAgICB0aGlzLiRzZXQodXBkYXRlZEF0LCB0cyk7XG4gICAgfVxuICAgIGlmICh0aGlzLiRpc1N1YmRvY3VtZW50KSB7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICBjb25zdCBzdWJkb2NzID0gdGhpcy4kZ2V0QWxsU3ViZG9jcygpO1xuICAgIGZvciAoY29uc3Qgc3ViZG9jIG9mIHN1YmRvY3MpIHtcbiAgICAgIGlmIChzdWJkb2MuaW5pdGlhbGl6ZVRpbWVzdGFtcHMpIHtcbiAgICAgICAgc3ViZG9jLmluaXRpYWxpemVUaW1lc3RhbXBzKCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG5cbiAgX3NldFRpbWVzdGFtcHNPblVwZGF0ZVtzeW1ib2xzLmJ1aWx0SW5NaWRkbGV3YXJlXSA9IHRydWU7XG5cbiAgY29uc3Qgb3B0cyA9IHsgcXVlcnk6IHRydWUsIG1vZGVsOiBmYWxzZSB9O1xuICBzY2hlbWEucHJlKCdmaW5kT25lQW5kUmVwbGFjZScsIG9wdHMsIF9zZXRUaW1lc3RhbXBzT25VcGRhdGUpO1xuICBzY2hlbWEucHJlKCdmaW5kT25lQW5kVXBkYXRlJywgb3B0cywgX3NldFRpbWVzdGFtcHNPblVwZGF0ZSk7XG4gIHNjaGVtYS5wcmUoJ3JlcGxhY2VPbmUnLCBvcHRzLCBfc2V0VGltZXN0YW1wc09uVXBkYXRlKTtcbiAgc2NoZW1hLnByZSgndXBkYXRlJywgb3B0cywgX3NldFRpbWVzdGFtcHNPblVwZGF0ZSk7XG4gIHNjaGVtYS5wcmUoJ3VwZGF0ZU9uZScsIG9wdHMsIF9zZXRUaW1lc3RhbXBzT25VcGRhdGUpO1xuICBzY2hlbWEucHJlKCd1cGRhdGVNYW55Jywgb3B0cywgX3NldFRpbWVzdGFtcHNPblVwZGF0ZSk7XG5cbiAgZnVuY3Rpb24gX3NldFRpbWVzdGFtcHNPblVwZGF0ZShuZXh0KSB7XG4gICAgY29uc3Qgbm93ID0gY3VycmVudFRpbWUgIT0gbnVsbCA/XG4gICAgICBjdXJyZW50VGltZSgpIDpcbiAgICAgIHRoaXMubW9kZWwuYmFzZS5ub3coKTtcbiAgICAvLyBSZXBsYWNpbmcgd2l0aCBudWxsIHVwZGF0ZSBzaG91bGQgc3RpbGwgdHJpZ2dlciB0aW1lc3RhbXBzXG4gICAgaWYgKHJlcGxhY2VPcHMuaGFzKHRoaXMub3ApICYmIHRoaXMuZ2V0VXBkYXRlKCkgPT0gbnVsbCkge1xuICAgICAgdGhpcy5zZXRVcGRhdGUoe30pO1xuICAgIH1cbiAgICBhcHBseVRpbWVzdGFtcHNUb1VwZGF0ZShcbiAgICAgIG5vdyxcbiAgICAgIGNyZWF0ZWRBdCxcbiAgICAgIHVwZGF0ZWRBdCxcbiAgICAgIHRoaXMuZ2V0VXBkYXRlKCksXG4gICAgICB0aGlzLl9tb25nb29zZU9wdGlvbnMsXG4gICAgICByZXBsYWNlT3BzLmhhcyh0aGlzLm9wKVxuICAgICk7XG4gICAgYXBwbHlUaW1lc3RhbXBzVG9DaGlsZHJlbihub3csIHRoaXMuZ2V0VXBkYXRlKCksIHRoaXMubW9kZWwuc2NoZW1hKTtcbiAgICBuZXh0KCk7XG4gIH1cbn07XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/mongoose/lib/helpers/timestamps/setupTimestamps.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/mongoose/lib/helpers/topology/allServersUnknown.js":
/*!*************************************************************************!*\
  !*** ./node_modules/mongoose/lib/helpers/topology/allServersUnknown.js ***!
  \*************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\n\nconst getConstructorName = __webpack_require__(/*! ../getConstructorName */ \"(ssr)/./node_modules/mongoose/lib/helpers/getConstructorName.js\");\n\nmodule.exports = function allServersUnknown(topologyDescription) {\n  if (getConstructorName(topologyDescription) !== 'TopologyDescription') {\n    return false;\n  }\n\n  const servers = Array.from(topologyDescription.servers.values());\n  return servers.length > 0 && servers.every(server => server.type === 'Unknown');\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbW9uZ29vc2UvbGliL2hlbHBlcnMvdG9wb2xvZ3kvYWxsU2VydmVyc1Vua25vd24uanMiLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWIsMkJBQTJCLG1CQUFPLENBQUMsOEZBQXVCOztBQUUxRDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9hcHAxLy4vbm9kZV9tb2R1bGVzL21vbmdvb3NlL2xpYi9oZWxwZXJzL3RvcG9sb2d5L2FsbFNlcnZlcnNVbmtub3duLmpzP2NiYTgiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG5jb25zdCBnZXRDb25zdHJ1Y3Rvck5hbWUgPSByZXF1aXJlKCcuLi9nZXRDb25zdHJ1Y3Rvck5hbWUnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBhbGxTZXJ2ZXJzVW5rbm93bih0b3BvbG9neURlc2NyaXB0aW9uKSB7XG4gIGlmIChnZXRDb25zdHJ1Y3Rvck5hbWUodG9wb2xvZ3lEZXNjcmlwdGlvbikgIT09ICdUb3BvbG9neURlc2NyaXB0aW9uJykge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIGNvbnN0IHNlcnZlcnMgPSBBcnJheS5mcm9tKHRvcG9sb2d5RGVzY3JpcHRpb24uc2VydmVycy52YWx1ZXMoKSk7XG4gIHJldHVybiBzZXJ2ZXJzLmxlbmd0aCA+IDAgJiYgc2VydmVycy5ldmVyeShzZXJ2ZXIgPT4gc2VydmVyLnR5cGUgPT09ICdVbmtub3duJyk7XG59O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/mongoose/lib/helpers/topology/allServersUnknown.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/mongoose/lib/helpers/topology/isAtlas.js":
/*!***************************************************************!*\
  !*** ./node_modules/mongoose/lib/helpers/topology/isAtlas.js ***!
  \***************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\n\nconst getConstructorName = __webpack_require__(/*! ../getConstructorName */ \"(ssr)/./node_modules/mongoose/lib/helpers/getConstructorName.js\");\n\n/**\n * @typedef { import('mongodb').TopologyDescription } TopologyDescription\n */\n\n/**\n * Checks if topologyDescription contains servers connected to an atlas instance\n *\n * @param  {TopologyDescription} topologyDescription\n * @returns {boolean}\n */\nmodule.exports = function isAtlas(topologyDescription) {\n  if (getConstructorName(topologyDescription) !== 'TopologyDescription') {\n    return false;\n  }\n\n  if (topologyDescription.servers.size === 0) {\n    return false;\n  }\n\n  for (const server of topologyDescription.servers.values()) {\n    if (server.host.endsWith('.mongodb.net') === false || server.port !== 27017) {\n      return false;\n    }\n  }\n\n  return true;\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbW9uZ29vc2UvbGliL2hlbHBlcnMvdG9wb2xvZ3kvaXNBdGxhcy5qcyIsIm1hcHBpbmdzIjoiQUFBYTs7QUFFYiwyQkFBMkIsbUJBQU8sQ0FBQyw4RkFBdUI7O0FBRTFEO0FBQ0EsY0FBYyx3Q0FBd0M7QUFDdEQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsWUFBWSxxQkFBcUI7QUFDakMsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL2FwcDEvLi9ub2RlX21vZHVsZXMvbW9uZ29vc2UvbGliL2hlbHBlcnMvdG9wb2xvZ3kvaXNBdGxhcy5qcz80ZGM1Il0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxuY29uc3QgZ2V0Q29uc3RydWN0b3JOYW1lID0gcmVxdWlyZSgnLi4vZ2V0Q29uc3RydWN0b3JOYW1lJyk7XG5cbi8qKlxuICogQHR5cGVkZWYgeyBpbXBvcnQoJ21vbmdvZGInKS5Ub3BvbG9neURlc2NyaXB0aW9uIH0gVG9wb2xvZ3lEZXNjcmlwdGlvblxuICovXG5cbi8qKlxuICogQ2hlY2tzIGlmIHRvcG9sb2d5RGVzY3JpcHRpb24gY29udGFpbnMgc2VydmVycyBjb25uZWN0ZWQgdG8gYW4gYXRsYXMgaW5zdGFuY2VcbiAqXG4gKiBAcGFyYW0gIHtUb3BvbG9neURlc2NyaXB0aW9ufSB0b3BvbG9neURlc2NyaXB0aW9uXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBpc0F0bGFzKHRvcG9sb2d5RGVzY3JpcHRpb24pIHtcbiAgaWYgKGdldENvbnN0cnVjdG9yTmFtZSh0b3BvbG9neURlc2NyaXB0aW9uKSAhPT0gJ1RvcG9sb2d5RGVzY3JpcHRpb24nKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgaWYgKHRvcG9sb2d5RGVzY3JpcHRpb24uc2VydmVycy5zaXplID09PSAwKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgZm9yIChjb25zdCBzZXJ2ZXIgb2YgdG9wb2xvZ3lEZXNjcmlwdGlvbi5zZXJ2ZXJzLnZhbHVlcygpKSB7XG4gICAgaWYgKHNlcnZlci5ob3N0LmVuZHNXaXRoKCcubW9uZ29kYi5uZXQnKSA9PT0gZmFsc2UgfHwgc2VydmVyLnBvcnQgIT09IDI3MDE3KSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHRydWU7XG59O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/mongoose/lib/helpers/topology/isAtlas.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/mongoose/lib/helpers/topology/isSSLError.js":
/*!******************************************************************!*\
  !*** ./node_modules/mongoose/lib/helpers/topology/isSSLError.js ***!
  \******************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\n\nconst getConstructorName = __webpack_require__(/*! ../getConstructorName */ \"(ssr)/./node_modules/mongoose/lib/helpers/getConstructorName.js\");\n\nconst nonSSLMessage = 'Client network socket disconnected before secure TLS ' +\n  'connection was established';\n\nmodule.exports = function isSSLError(topologyDescription) {\n  if (getConstructorName(topologyDescription) !== 'TopologyDescription') {\n    return false;\n  }\n\n  const descriptions = Array.from(topologyDescription.servers.values());\n  return descriptions.length > 0 &&\n    descriptions.every(descr => descr.error && descr.error.message.indexOf(nonSSLMessage) !== -1);\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbW9uZ29vc2UvbGliL2hlbHBlcnMvdG9wb2xvZ3kvaXNTU0xFcnJvci5qcyIsIm1hcHBpbmdzIjoiQUFBYTs7QUFFYiwyQkFBMkIsbUJBQU8sQ0FBQyw4RkFBdUI7O0FBRTFEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9hcHAxLy4vbm9kZV9tb2R1bGVzL21vbmdvb3NlL2xpYi9oZWxwZXJzL3RvcG9sb2d5L2lzU1NMRXJyb3IuanM/M2UzOCJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbmNvbnN0IGdldENvbnN0cnVjdG9yTmFtZSA9IHJlcXVpcmUoJy4uL2dldENvbnN0cnVjdG9yTmFtZScpO1xuXG5jb25zdCBub25TU0xNZXNzYWdlID0gJ0NsaWVudCBuZXR3b3JrIHNvY2tldCBkaXNjb25uZWN0ZWQgYmVmb3JlIHNlY3VyZSBUTFMgJyArXG4gICdjb25uZWN0aW9uIHdhcyBlc3RhYmxpc2hlZCc7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gaXNTU0xFcnJvcih0b3BvbG9neURlc2NyaXB0aW9uKSB7XG4gIGlmIChnZXRDb25zdHJ1Y3Rvck5hbWUodG9wb2xvZ3lEZXNjcmlwdGlvbikgIT09ICdUb3BvbG9neURlc2NyaXB0aW9uJykge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIGNvbnN0IGRlc2NyaXB0aW9ucyA9IEFycmF5LmZyb20odG9wb2xvZ3lEZXNjcmlwdGlvbi5zZXJ2ZXJzLnZhbHVlcygpKTtcbiAgcmV0dXJuIGRlc2NyaXB0aW9ucy5sZW5ndGggPiAwICYmXG4gICAgZGVzY3JpcHRpb25zLmV2ZXJ5KGRlc2NyID0+IGRlc2NyLmVycm9yICYmIGRlc2NyLmVycm9yLm1lc3NhZ2UuaW5kZXhPZihub25TU0xNZXNzYWdlKSAhPT0gLTEpO1xufTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/mongoose/lib/helpers/topology/isSSLError.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/mongoose/lib/helpers/update/applyTimestampsToChildren.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/mongoose/lib/helpers/update/applyTimestampsToChildren.js ***!
  \*******************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\n\nconst cleanPositionalOperators = __webpack_require__(/*! ../schema/cleanPositionalOperators */ \"(ssr)/./node_modules/mongoose/lib/helpers/schema/cleanPositionalOperators.js\");\nconst handleTimestampOption = __webpack_require__(/*! ../schema/handleTimestampOption */ \"(ssr)/./node_modules/mongoose/lib/helpers/schema/handleTimestampOption.js\");\n\nmodule.exports = applyTimestampsToChildren;\n\n/*!\n * ignore\n */\n\nfunction applyTimestampsToChildren(now, update, schema) {\n  if (update == null) {\n    return;\n  }\n\n  const keys = Object.keys(update);\n  const hasDollarKey = keys.some(key => key[0] === '$');\n\n  if (hasDollarKey) {\n    if (update.$push) {\n      _applyTimestampToUpdateOperator(update.$push);\n    }\n    if (update.$addToSet) {\n      _applyTimestampToUpdateOperator(update.$addToSet);\n    }\n    if (update.$set != null) {\n      const keys = Object.keys(update.$set);\n      for (const key of keys) {\n        applyTimestampsToUpdateKey(schema, key, update.$set, now);\n      }\n    }\n    if (update.$setOnInsert != null) {\n      const keys = Object.keys(update.$setOnInsert);\n      for (const key of keys) {\n        applyTimestampsToUpdateKey(schema, key, update.$setOnInsert, now);\n      }\n    }\n  }\n\n  const updateKeys = Object.keys(update).filter(key => key[0] !== '$');\n  for (const key of updateKeys) {\n    applyTimestampsToUpdateKey(schema, key, update, now);\n  }\n\n  function _applyTimestampToUpdateOperator(op) {\n    for (const key of Object.keys(op)) {\n      const $path = schema.path(key.replace(/\\.\\$\\./i, '.').replace(/.\\$$/, ''));\n      if (op[key] &&\n          $path &&\n          $path.$isMongooseDocumentArray &&\n          $path.schema.options.timestamps) {\n        const timestamps = $path.schema.options.timestamps;\n        const createdAt = handleTimestampOption(timestamps, 'createdAt');\n        const updatedAt = handleTimestampOption(timestamps, 'updatedAt');\n        if (op[key].$each) {\n          op[key].$each.forEach(function(subdoc) {\n            if (updatedAt != null) {\n              subdoc[updatedAt] = now;\n            }\n            if (createdAt != null) {\n              subdoc[createdAt] = now;\n            }\n\n            applyTimestampsToChildren(now, subdoc, $path.schema);\n          });\n        } else {\n          if (updatedAt != null) {\n            op[key][updatedAt] = now;\n          }\n          if (createdAt != null) {\n            op[key][createdAt] = now;\n          }\n\n          applyTimestampsToChildren(now, op[key], $path.schema);\n        }\n      }\n    }\n  }\n}\n\nfunction applyTimestampsToDocumentArray(arr, schematype, now) {\n  const timestamps = schematype.schema.options.timestamps;\n\n  const len = arr.length;\n\n  if (!timestamps) {\n    for (let i = 0; i < len; ++i) {\n      applyTimestampsToChildren(now, arr[i], schematype.schema);\n    }\n    return;\n  }\n\n  const createdAt = handleTimestampOption(timestamps, 'createdAt');\n  const updatedAt = handleTimestampOption(timestamps, 'updatedAt');\n  for (let i = 0; i < len; ++i) {\n    if (updatedAt != null) {\n      arr[i][updatedAt] = now;\n    }\n    if (createdAt != null) {\n      arr[i][createdAt] = now;\n    }\n\n    applyTimestampsToChildren(now, arr[i], schematype.schema);\n  }\n}\n\nfunction applyTimestampsToSingleNested(subdoc, schematype, now) {\n  const timestamps = schematype.schema.options.timestamps;\n  if (!timestamps) {\n    applyTimestampsToChildren(now, subdoc, schematype.schema);\n    return;\n  }\n\n  const createdAt = handleTimestampOption(timestamps, 'createdAt');\n  const updatedAt = handleTimestampOption(timestamps, 'updatedAt');\n  if (updatedAt != null) {\n    subdoc[updatedAt] = now;\n  }\n  if (createdAt != null) {\n    subdoc[createdAt] = now;\n  }\n\n  applyTimestampsToChildren(now, subdoc, schematype.schema);\n}\n\nfunction applyTimestampsToUpdateKey(schema, key, update, now) {\n  // Replace positional operator `$` and array filters `$[]` and `$[.*]`\n  const keyToSearch = cleanPositionalOperators(key);\n  const path = schema.path(keyToSearch);\n  if (!path) {\n    return;\n  }\n\n  const parentSchemaTypes = [];\n  const pieces = keyToSearch.split('.');\n  for (let i = pieces.length - 1; i > 0; --i) {\n    const s = schema.path(pieces.slice(0, i).join('.'));\n    if (s != null &&\n      (s.$isMongooseDocumentArray || s.$isSingleNested)) {\n      parentSchemaTypes.push({ parentPath: key.split('.').slice(0, i).join('.'), parentSchemaType: s });\n    }\n  }\n\n  if (Array.isArray(update[key]) && path.$isMongooseDocumentArray) {\n    applyTimestampsToDocumentArray(update[key], path, now);\n  } else if (update[key] && path.$isSingleNested) {\n    applyTimestampsToSingleNested(update[key], path, now);\n  } else if (parentSchemaTypes.length > 0) {\n    for (const item of parentSchemaTypes) {\n      const parentPath = item.parentPath;\n      const parentSchemaType = item.parentSchemaType;\n      const timestamps = parentSchemaType.schema.options.timestamps;\n      const updatedAt = handleTimestampOption(timestamps, 'updatedAt');\n\n      if (!timestamps || updatedAt == null) {\n        continue;\n      }\n\n      if (parentSchemaType.$isSingleNested) {\n        // Single nested is easy\n        update[parentPath + '.' + updatedAt] = now;\n      } else if (parentSchemaType.$isMongooseDocumentArray) {\n        let childPath = key.substring(parentPath.length + 1);\n\n        if (/^\\d+$/.test(childPath)) {\n          update[parentPath + '.' + childPath][updatedAt] = now;\n          continue;\n        }\n\n        const firstDot = childPath.indexOf('.');\n        childPath = firstDot !== -1 ? childPath.substring(0, firstDot) : childPath;\n\n        update[parentPath + '.' + childPath + '.' + updatedAt] = now;\n      }\n    }\n  } else if (path.schema != null && path.schema != schema && update[key]) {\n    const timestamps = path.schema.options.timestamps;\n    const createdAt = handleTimestampOption(timestamps, 'createdAt');\n    const updatedAt = handleTimestampOption(timestamps, 'updatedAt');\n\n    if (!timestamps) {\n      return;\n    }\n\n    if (updatedAt != null) {\n      update[key][updatedAt] = now;\n    }\n    if (createdAt != null) {\n      update[key][createdAt] = now;\n    }\n  }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbW9uZ29vc2UvbGliL2hlbHBlcnMvdXBkYXRlL2FwcGx5VGltZXN0YW1wc1RvQ2hpbGRyZW4uanMiLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWIsaUNBQWlDLG1CQUFPLENBQUMsd0hBQW9DO0FBQzdFLDhCQUE4QixtQkFBTyxDQUFDLGtIQUFpQzs7QUFFdkU7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxXQUFXO0FBQ1gsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLG9CQUFvQixTQUFTO0FBQzdCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxrQkFBa0IsU0FBUztBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGtDQUFrQyxPQUFPO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBLCtCQUErQix1RUFBdUU7QUFDdEc7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9hcHAxLy4vbm9kZV9tb2R1bGVzL21vbmdvb3NlL2xpYi9oZWxwZXJzL3VwZGF0ZS9hcHBseVRpbWVzdGFtcHNUb0NoaWxkcmVuLmpzPzgwNWEiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG5jb25zdCBjbGVhblBvc2l0aW9uYWxPcGVyYXRvcnMgPSByZXF1aXJlKCcuLi9zY2hlbWEvY2xlYW5Qb3NpdGlvbmFsT3BlcmF0b3JzJyk7XG5jb25zdCBoYW5kbGVUaW1lc3RhbXBPcHRpb24gPSByZXF1aXJlKCcuLi9zY2hlbWEvaGFuZGxlVGltZXN0YW1wT3B0aW9uJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gYXBwbHlUaW1lc3RhbXBzVG9DaGlsZHJlbjtcblxuLyohXG4gKiBpZ25vcmVcbiAqL1xuXG5mdW5jdGlvbiBhcHBseVRpbWVzdGFtcHNUb0NoaWxkcmVuKG5vdywgdXBkYXRlLCBzY2hlbWEpIHtcbiAgaWYgKHVwZGF0ZSA9PSBudWxsKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgY29uc3Qga2V5cyA9IE9iamVjdC5rZXlzKHVwZGF0ZSk7XG4gIGNvbnN0IGhhc0RvbGxhcktleSA9IGtleXMuc29tZShrZXkgPT4ga2V5WzBdID09PSAnJCcpO1xuXG4gIGlmIChoYXNEb2xsYXJLZXkpIHtcbiAgICBpZiAodXBkYXRlLiRwdXNoKSB7XG4gICAgICBfYXBwbHlUaW1lc3RhbXBUb1VwZGF0ZU9wZXJhdG9yKHVwZGF0ZS4kcHVzaCk7XG4gICAgfVxuICAgIGlmICh1cGRhdGUuJGFkZFRvU2V0KSB7XG4gICAgICBfYXBwbHlUaW1lc3RhbXBUb1VwZGF0ZU9wZXJhdG9yKHVwZGF0ZS4kYWRkVG9TZXQpO1xuICAgIH1cbiAgICBpZiAodXBkYXRlLiRzZXQgIT0gbnVsbCkge1xuICAgICAgY29uc3Qga2V5cyA9IE9iamVjdC5rZXlzKHVwZGF0ZS4kc2V0KTtcbiAgICAgIGZvciAoY29uc3Qga2V5IG9mIGtleXMpIHtcbiAgICAgICAgYXBwbHlUaW1lc3RhbXBzVG9VcGRhdGVLZXkoc2NoZW1hLCBrZXksIHVwZGF0ZS4kc2V0LCBub3cpO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAodXBkYXRlLiRzZXRPbkluc2VydCAhPSBudWxsKSB7XG4gICAgICBjb25zdCBrZXlzID0gT2JqZWN0LmtleXModXBkYXRlLiRzZXRPbkluc2VydCk7XG4gICAgICBmb3IgKGNvbnN0IGtleSBvZiBrZXlzKSB7XG4gICAgICAgIGFwcGx5VGltZXN0YW1wc1RvVXBkYXRlS2V5KHNjaGVtYSwga2V5LCB1cGRhdGUuJHNldE9uSW5zZXJ0LCBub3cpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGNvbnN0IHVwZGF0ZUtleXMgPSBPYmplY3Qua2V5cyh1cGRhdGUpLmZpbHRlcihrZXkgPT4ga2V5WzBdICE9PSAnJCcpO1xuICBmb3IgKGNvbnN0IGtleSBvZiB1cGRhdGVLZXlzKSB7XG4gICAgYXBwbHlUaW1lc3RhbXBzVG9VcGRhdGVLZXkoc2NoZW1hLCBrZXksIHVwZGF0ZSwgbm93KTtcbiAgfVxuXG4gIGZ1bmN0aW9uIF9hcHBseVRpbWVzdGFtcFRvVXBkYXRlT3BlcmF0b3Iob3ApIHtcbiAgICBmb3IgKGNvbnN0IGtleSBvZiBPYmplY3Qua2V5cyhvcCkpIHtcbiAgICAgIGNvbnN0ICRwYXRoID0gc2NoZW1hLnBhdGgoa2V5LnJlcGxhY2UoL1xcLlxcJFxcLi9pLCAnLicpLnJlcGxhY2UoLy5cXCQkLywgJycpKTtcbiAgICAgIGlmIChvcFtrZXldICYmXG4gICAgICAgICAgJHBhdGggJiZcbiAgICAgICAgICAkcGF0aC4kaXNNb25nb29zZURvY3VtZW50QXJyYXkgJiZcbiAgICAgICAgICAkcGF0aC5zY2hlbWEub3B0aW9ucy50aW1lc3RhbXBzKSB7XG4gICAgICAgIGNvbnN0IHRpbWVzdGFtcHMgPSAkcGF0aC5zY2hlbWEub3B0aW9ucy50aW1lc3RhbXBzO1xuICAgICAgICBjb25zdCBjcmVhdGVkQXQgPSBoYW5kbGVUaW1lc3RhbXBPcHRpb24odGltZXN0YW1wcywgJ2NyZWF0ZWRBdCcpO1xuICAgICAgICBjb25zdCB1cGRhdGVkQXQgPSBoYW5kbGVUaW1lc3RhbXBPcHRpb24odGltZXN0YW1wcywgJ3VwZGF0ZWRBdCcpO1xuICAgICAgICBpZiAob3Bba2V5XS4kZWFjaCkge1xuICAgICAgICAgIG9wW2tleV0uJGVhY2guZm9yRWFjaChmdW5jdGlvbihzdWJkb2MpIHtcbiAgICAgICAgICAgIGlmICh1cGRhdGVkQXQgIT0gbnVsbCkge1xuICAgICAgICAgICAgICBzdWJkb2NbdXBkYXRlZEF0XSA9IG5vdztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChjcmVhdGVkQXQgIT0gbnVsbCkge1xuICAgICAgICAgICAgICBzdWJkb2NbY3JlYXRlZEF0XSA9IG5vdztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgYXBwbHlUaW1lc3RhbXBzVG9DaGlsZHJlbihub3csIHN1YmRvYywgJHBhdGguc2NoZW1hKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpZiAodXBkYXRlZEF0ICE9IG51bGwpIHtcbiAgICAgICAgICAgIG9wW2tleV1bdXBkYXRlZEF0XSA9IG5vdztcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGNyZWF0ZWRBdCAhPSBudWxsKSB7XG4gICAgICAgICAgICBvcFtrZXldW2NyZWF0ZWRBdF0gPSBub3c7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgYXBwbHlUaW1lc3RhbXBzVG9DaGlsZHJlbihub3csIG9wW2tleV0sICRwYXRoLnNjaGVtYSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gYXBwbHlUaW1lc3RhbXBzVG9Eb2N1bWVudEFycmF5KGFyciwgc2NoZW1hdHlwZSwgbm93KSB7XG4gIGNvbnN0IHRpbWVzdGFtcHMgPSBzY2hlbWF0eXBlLnNjaGVtYS5vcHRpb25zLnRpbWVzdGFtcHM7XG5cbiAgY29uc3QgbGVuID0gYXJyLmxlbmd0aDtcblxuICBpZiAoIXRpbWVzdGFtcHMpIHtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbjsgKytpKSB7XG4gICAgICBhcHBseVRpbWVzdGFtcHNUb0NoaWxkcmVuKG5vdywgYXJyW2ldLCBzY2hlbWF0eXBlLnNjaGVtYSk7XG4gICAgfVxuICAgIHJldHVybjtcbiAgfVxuXG4gIGNvbnN0IGNyZWF0ZWRBdCA9IGhhbmRsZVRpbWVzdGFtcE9wdGlvbih0aW1lc3RhbXBzLCAnY3JlYXRlZEF0Jyk7XG4gIGNvbnN0IHVwZGF0ZWRBdCA9IGhhbmRsZVRpbWVzdGFtcE9wdGlvbih0aW1lc3RhbXBzLCAndXBkYXRlZEF0Jyk7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgbGVuOyArK2kpIHtcbiAgICBpZiAodXBkYXRlZEF0ICE9IG51bGwpIHtcbiAgICAgIGFycltpXVt1cGRhdGVkQXRdID0gbm93O1xuICAgIH1cbiAgICBpZiAoY3JlYXRlZEF0ICE9IG51bGwpIHtcbiAgICAgIGFycltpXVtjcmVhdGVkQXRdID0gbm93O1xuICAgIH1cblxuICAgIGFwcGx5VGltZXN0YW1wc1RvQ2hpbGRyZW4obm93LCBhcnJbaV0sIHNjaGVtYXR5cGUuc2NoZW1hKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBhcHBseVRpbWVzdGFtcHNUb1NpbmdsZU5lc3RlZChzdWJkb2MsIHNjaGVtYXR5cGUsIG5vdykge1xuICBjb25zdCB0aW1lc3RhbXBzID0gc2NoZW1hdHlwZS5zY2hlbWEub3B0aW9ucy50aW1lc3RhbXBzO1xuICBpZiAoIXRpbWVzdGFtcHMpIHtcbiAgICBhcHBseVRpbWVzdGFtcHNUb0NoaWxkcmVuKG5vdywgc3ViZG9jLCBzY2hlbWF0eXBlLnNjaGVtYSk7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgY29uc3QgY3JlYXRlZEF0ID0gaGFuZGxlVGltZXN0YW1wT3B0aW9uKHRpbWVzdGFtcHMsICdjcmVhdGVkQXQnKTtcbiAgY29uc3QgdXBkYXRlZEF0ID0gaGFuZGxlVGltZXN0YW1wT3B0aW9uKHRpbWVzdGFtcHMsICd1cGRhdGVkQXQnKTtcbiAgaWYgKHVwZGF0ZWRBdCAhPSBudWxsKSB7XG4gICAgc3ViZG9jW3VwZGF0ZWRBdF0gPSBub3c7XG4gIH1cbiAgaWYgKGNyZWF0ZWRBdCAhPSBudWxsKSB7XG4gICAgc3ViZG9jW2NyZWF0ZWRBdF0gPSBub3c7XG4gIH1cblxuICBhcHBseVRpbWVzdGFtcHNUb0NoaWxkcmVuKG5vdywgc3ViZG9jLCBzY2hlbWF0eXBlLnNjaGVtYSk7XG59XG5cbmZ1bmN0aW9uIGFwcGx5VGltZXN0YW1wc1RvVXBkYXRlS2V5KHNjaGVtYSwga2V5LCB1cGRhdGUsIG5vdykge1xuICAvLyBSZXBsYWNlIHBvc2l0aW9uYWwgb3BlcmF0b3IgYCRgIGFuZCBhcnJheSBmaWx0ZXJzIGAkW11gIGFuZCBgJFsuKl1gXG4gIGNvbnN0IGtleVRvU2VhcmNoID0gY2xlYW5Qb3NpdGlvbmFsT3BlcmF0b3JzKGtleSk7XG4gIGNvbnN0IHBhdGggPSBzY2hlbWEucGF0aChrZXlUb1NlYXJjaCk7XG4gIGlmICghcGF0aCkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIGNvbnN0IHBhcmVudFNjaGVtYVR5cGVzID0gW107XG4gIGNvbnN0IHBpZWNlcyA9IGtleVRvU2VhcmNoLnNwbGl0KCcuJyk7XG4gIGZvciAobGV0IGkgPSBwaWVjZXMubGVuZ3RoIC0gMTsgaSA+IDA7IC0taSkge1xuICAgIGNvbnN0IHMgPSBzY2hlbWEucGF0aChwaWVjZXMuc2xpY2UoMCwgaSkuam9pbignLicpKTtcbiAgICBpZiAocyAhPSBudWxsICYmXG4gICAgICAocy4kaXNNb25nb29zZURvY3VtZW50QXJyYXkgfHwgcy4kaXNTaW5nbGVOZXN0ZWQpKSB7XG4gICAgICBwYXJlbnRTY2hlbWFUeXBlcy5wdXNoKHsgcGFyZW50UGF0aDoga2V5LnNwbGl0KCcuJykuc2xpY2UoMCwgaSkuam9pbignLicpLCBwYXJlbnRTY2hlbWFUeXBlOiBzIH0pO1xuICAgIH1cbiAgfVxuXG4gIGlmIChBcnJheS5pc0FycmF5KHVwZGF0ZVtrZXldKSAmJiBwYXRoLiRpc01vbmdvb3NlRG9jdW1lbnRBcnJheSkge1xuICAgIGFwcGx5VGltZXN0YW1wc1RvRG9jdW1lbnRBcnJheSh1cGRhdGVba2V5XSwgcGF0aCwgbm93KTtcbiAgfSBlbHNlIGlmICh1cGRhdGVba2V5XSAmJiBwYXRoLiRpc1NpbmdsZU5lc3RlZCkge1xuICAgIGFwcGx5VGltZXN0YW1wc1RvU2luZ2xlTmVzdGVkKHVwZGF0ZVtrZXldLCBwYXRoLCBub3cpO1xuICB9IGVsc2UgaWYgKHBhcmVudFNjaGVtYVR5cGVzLmxlbmd0aCA+IDApIHtcbiAgICBmb3IgKGNvbnN0IGl0ZW0gb2YgcGFyZW50U2NoZW1hVHlwZXMpIHtcbiAgICAgIGNvbnN0IHBhcmVudFBhdGggPSBpdGVtLnBhcmVudFBhdGg7XG4gICAgICBjb25zdCBwYXJlbnRTY2hlbWFUeXBlID0gaXRlbS5wYXJlbnRTY2hlbWFUeXBlO1xuICAgICAgY29uc3QgdGltZXN0YW1wcyA9IHBhcmVudFNjaGVtYVR5cGUuc2NoZW1hLm9wdGlvbnMudGltZXN0YW1wcztcbiAgICAgIGNvbnN0IHVwZGF0ZWRBdCA9IGhhbmRsZVRpbWVzdGFtcE9wdGlvbih0aW1lc3RhbXBzLCAndXBkYXRlZEF0Jyk7XG5cbiAgICAgIGlmICghdGltZXN0YW1wcyB8fCB1cGRhdGVkQXQgPT0gbnVsbCkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgaWYgKHBhcmVudFNjaGVtYVR5cGUuJGlzU2luZ2xlTmVzdGVkKSB7XG4gICAgICAgIC8vIFNpbmdsZSBuZXN0ZWQgaXMgZWFzeVxuICAgICAgICB1cGRhdGVbcGFyZW50UGF0aCArICcuJyArIHVwZGF0ZWRBdF0gPSBub3c7XG4gICAgICB9IGVsc2UgaWYgKHBhcmVudFNjaGVtYVR5cGUuJGlzTW9uZ29vc2VEb2N1bWVudEFycmF5KSB7XG4gICAgICAgIGxldCBjaGlsZFBhdGggPSBrZXkuc3Vic3RyaW5nKHBhcmVudFBhdGgubGVuZ3RoICsgMSk7XG5cbiAgICAgICAgaWYgKC9eXFxkKyQvLnRlc3QoY2hpbGRQYXRoKSkge1xuICAgICAgICAgIHVwZGF0ZVtwYXJlbnRQYXRoICsgJy4nICsgY2hpbGRQYXRoXVt1cGRhdGVkQXRdID0gbm93O1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgZmlyc3REb3QgPSBjaGlsZFBhdGguaW5kZXhPZignLicpO1xuICAgICAgICBjaGlsZFBhdGggPSBmaXJzdERvdCAhPT0gLTEgPyBjaGlsZFBhdGguc3Vic3RyaW5nKDAsIGZpcnN0RG90KSA6IGNoaWxkUGF0aDtcblxuICAgICAgICB1cGRhdGVbcGFyZW50UGF0aCArICcuJyArIGNoaWxkUGF0aCArICcuJyArIHVwZGF0ZWRBdF0gPSBub3c7XG4gICAgICB9XG4gICAgfVxuICB9IGVsc2UgaWYgKHBhdGguc2NoZW1hICE9IG51bGwgJiYgcGF0aC5zY2hlbWEgIT0gc2NoZW1hICYmIHVwZGF0ZVtrZXldKSB7XG4gICAgY29uc3QgdGltZXN0YW1wcyA9IHBhdGguc2NoZW1hLm9wdGlvbnMudGltZXN0YW1wcztcbiAgICBjb25zdCBjcmVhdGVkQXQgPSBoYW5kbGVUaW1lc3RhbXBPcHRpb24odGltZXN0YW1wcywgJ2NyZWF0ZWRBdCcpO1xuICAgIGNvbnN0IHVwZGF0ZWRBdCA9IGhhbmRsZVRpbWVzdGFtcE9wdGlvbih0aW1lc3RhbXBzLCAndXBkYXRlZEF0Jyk7XG5cbiAgICBpZiAoIXRpbWVzdGFtcHMpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAodXBkYXRlZEF0ICE9IG51bGwpIHtcbiAgICAgIHVwZGF0ZVtrZXldW3VwZGF0ZWRBdF0gPSBub3c7XG4gICAgfVxuICAgIGlmIChjcmVhdGVkQXQgIT0gbnVsbCkge1xuICAgICAgdXBkYXRlW2tleV1bY3JlYXRlZEF0XSA9IG5vdztcbiAgICB9XG4gIH1cbn1cbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/mongoose/lib/helpers/update/applyTimestampsToChildren.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/mongoose/lib/helpers/update/applyTimestampsToUpdate.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/mongoose/lib/helpers/update/applyTimestampsToUpdate.js ***!
  \*****************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\n\n/*!\n * ignore\n */\n\nconst get = __webpack_require__(/*! ../get */ \"(ssr)/./node_modules/mongoose/lib/helpers/get.js\");\n\nmodule.exports = applyTimestampsToUpdate;\n\n/*!\n * ignore\n */\n\nfunction applyTimestampsToUpdate(now, createdAt, updatedAt, currentUpdate, options, isReplace) {\n  const updates = currentUpdate;\n  let _updates = updates;\n  const timestamps = get(options, 'timestamps', true);\n\n  // Support skipping timestamps at the query level, see gh-6980\n  if (!timestamps || updates == null) {\n    return currentUpdate;\n  }\n\n  const skipCreatedAt = timestamps != null && timestamps.createdAt === false;\n  const skipUpdatedAt = timestamps != null && timestamps.updatedAt === false;\n\n  if (isReplace) {\n    if (currentUpdate && currentUpdate.$set) {\n      currentUpdate = currentUpdate.$set;\n      updates.$set = {};\n      _updates = updates.$set;\n    }\n    if (!skipUpdatedAt && updatedAt && !currentUpdate[updatedAt]) {\n      _updates[updatedAt] = now;\n    }\n    if (!skipCreatedAt && createdAt && !currentUpdate[createdAt]) {\n      _updates[createdAt] = now;\n    }\n    return updates;\n  }\n  currentUpdate = currentUpdate || {};\n\n  if (Array.isArray(updates)) {\n    // Update with aggregation pipeline\n    if (updatedAt == null) {\n      return updates;\n    }\n    updates.push({ $set: { [updatedAt]: now } });\n    return updates;\n  }\n  updates.$set = updates.$set || {};\n  if (!skipUpdatedAt && updatedAt &&\n      (!currentUpdate.$currentDate || !currentUpdate.$currentDate[updatedAt])) {\n    let timestampSet = false;\n    if (updatedAt.indexOf('.') !== -1) {\n      const pieces = updatedAt.split('.');\n      for (let i = 1; i < pieces.length; ++i) {\n        const remnant = pieces.slice(-i).join('.');\n        const start = pieces.slice(0, -i).join('.');\n        if (currentUpdate[start] != null) {\n          currentUpdate[start][remnant] = now;\n          timestampSet = true;\n          break;\n        } else if (currentUpdate.$set && currentUpdate.$set[start]) {\n          currentUpdate.$set[start][remnant] = now;\n          timestampSet = true;\n          break;\n        }\n      }\n    }\n\n    if (!timestampSet) {\n      updates.$set[updatedAt] = now;\n    }\n\n    if (updates.hasOwnProperty(updatedAt)) {\n      delete updates[updatedAt];\n    }\n  }\n\n  if (!skipCreatedAt && createdAt) {\n    if (currentUpdate[createdAt]) {\n      delete currentUpdate[createdAt];\n    }\n    if (currentUpdate.$set && currentUpdate.$set[createdAt]) {\n      delete currentUpdate.$set[createdAt];\n    }\n    let timestampSet = false;\n    if (createdAt.indexOf('.') !== -1) {\n      const pieces = createdAt.split('.');\n      for (let i = 1; i < pieces.length; ++i) {\n        const remnant = pieces.slice(-i).join('.');\n        const start = pieces.slice(0, -i).join('.');\n        if (currentUpdate[start] != null) {\n          currentUpdate[start][remnant] = now;\n          timestampSet = true;\n          break;\n        } else if (currentUpdate.$set && currentUpdate.$set[start]) {\n          currentUpdate.$set[start][remnant] = now;\n          timestampSet = true;\n          break;\n        }\n      }\n    }\n\n    if (!timestampSet) {\n      updates.$setOnInsert = updates.$setOnInsert || {};\n      updates.$setOnInsert[createdAt] = now;\n    }\n  }\n\n  if (Object.keys(updates.$set).length === 0) {\n    delete updates.$set;\n  }\n  return updates;\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbW9uZ29vc2UvbGliL2hlbHBlcnMvdXBkYXRlL2FwcGx5VGltZXN0YW1wc1RvVXBkYXRlLmpzIiwibWFwcGluZ3MiOiJBQUFhOztBQUViO0FBQ0E7QUFDQTs7QUFFQSxZQUFZLG1CQUFPLENBQUMsZ0VBQVE7O0FBRTVCOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLFFBQVEsb0JBQW9CO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsbUJBQW1CO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLG1CQUFtQjtBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL2FwcDEvLi9ub2RlX21vZHVsZXMvbW9uZ29vc2UvbGliL2hlbHBlcnMvdXBkYXRlL2FwcGx5VGltZXN0YW1wc1RvVXBkYXRlLmpzP2RmNWEiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG4vKiFcbiAqIGlnbm9yZVxuICovXG5cbmNvbnN0IGdldCA9IHJlcXVpcmUoJy4uL2dldCcpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGFwcGx5VGltZXN0YW1wc1RvVXBkYXRlO1xuXG4vKiFcbiAqIGlnbm9yZVxuICovXG5cbmZ1bmN0aW9uIGFwcGx5VGltZXN0YW1wc1RvVXBkYXRlKG5vdywgY3JlYXRlZEF0LCB1cGRhdGVkQXQsIGN1cnJlbnRVcGRhdGUsIG9wdGlvbnMsIGlzUmVwbGFjZSkge1xuICBjb25zdCB1cGRhdGVzID0gY3VycmVudFVwZGF0ZTtcbiAgbGV0IF91cGRhdGVzID0gdXBkYXRlcztcbiAgY29uc3QgdGltZXN0YW1wcyA9IGdldChvcHRpb25zLCAndGltZXN0YW1wcycsIHRydWUpO1xuXG4gIC8vIFN1cHBvcnQgc2tpcHBpbmcgdGltZXN0YW1wcyBhdCB0aGUgcXVlcnkgbGV2ZWwsIHNlZSBnaC02OTgwXG4gIGlmICghdGltZXN0YW1wcyB8fCB1cGRhdGVzID09IG51bGwpIHtcbiAgICByZXR1cm4gY3VycmVudFVwZGF0ZTtcbiAgfVxuXG4gIGNvbnN0IHNraXBDcmVhdGVkQXQgPSB0aW1lc3RhbXBzICE9IG51bGwgJiYgdGltZXN0YW1wcy5jcmVhdGVkQXQgPT09IGZhbHNlO1xuICBjb25zdCBza2lwVXBkYXRlZEF0ID0gdGltZXN0YW1wcyAhPSBudWxsICYmIHRpbWVzdGFtcHMudXBkYXRlZEF0ID09PSBmYWxzZTtcblxuICBpZiAoaXNSZXBsYWNlKSB7XG4gICAgaWYgKGN1cnJlbnRVcGRhdGUgJiYgY3VycmVudFVwZGF0ZS4kc2V0KSB7XG4gICAgICBjdXJyZW50VXBkYXRlID0gY3VycmVudFVwZGF0ZS4kc2V0O1xuICAgICAgdXBkYXRlcy4kc2V0ID0ge307XG4gICAgICBfdXBkYXRlcyA9IHVwZGF0ZXMuJHNldDtcbiAgICB9XG4gICAgaWYgKCFza2lwVXBkYXRlZEF0ICYmIHVwZGF0ZWRBdCAmJiAhY3VycmVudFVwZGF0ZVt1cGRhdGVkQXRdKSB7XG4gICAgICBfdXBkYXRlc1t1cGRhdGVkQXRdID0gbm93O1xuICAgIH1cbiAgICBpZiAoIXNraXBDcmVhdGVkQXQgJiYgY3JlYXRlZEF0ICYmICFjdXJyZW50VXBkYXRlW2NyZWF0ZWRBdF0pIHtcbiAgICAgIF91cGRhdGVzW2NyZWF0ZWRBdF0gPSBub3c7XG4gICAgfVxuICAgIHJldHVybiB1cGRhdGVzO1xuICB9XG4gIGN1cnJlbnRVcGRhdGUgPSBjdXJyZW50VXBkYXRlIHx8IHt9O1xuXG4gIGlmIChBcnJheS5pc0FycmF5KHVwZGF0ZXMpKSB7XG4gICAgLy8gVXBkYXRlIHdpdGggYWdncmVnYXRpb24gcGlwZWxpbmVcbiAgICBpZiAodXBkYXRlZEF0ID09IG51bGwpIHtcbiAgICAgIHJldHVybiB1cGRhdGVzO1xuICAgIH1cbiAgICB1cGRhdGVzLnB1c2goeyAkc2V0OiB7IFt1cGRhdGVkQXRdOiBub3cgfSB9KTtcbiAgICByZXR1cm4gdXBkYXRlcztcbiAgfVxuICB1cGRhdGVzLiRzZXQgPSB1cGRhdGVzLiRzZXQgfHwge307XG4gIGlmICghc2tpcFVwZGF0ZWRBdCAmJiB1cGRhdGVkQXQgJiZcbiAgICAgICghY3VycmVudFVwZGF0ZS4kY3VycmVudERhdGUgfHwgIWN1cnJlbnRVcGRhdGUuJGN1cnJlbnREYXRlW3VwZGF0ZWRBdF0pKSB7XG4gICAgbGV0IHRpbWVzdGFtcFNldCA9IGZhbHNlO1xuICAgIGlmICh1cGRhdGVkQXQuaW5kZXhPZignLicpICE9PSAtMSkge1xuICAgICAgY29uc3QgcGllY2VzID0gdXBkYXRlZEF0LnNwbGl0KCcuJyk7XG4gICAgICBmb3IgKGxldCBpID0gMTsgaSA8IHBpZWNlcy5sZW5ndGg7ICsraSkge1xuICAgICAgICBjb25zdCByZW1uYW50ID0gcGllY2VzLnNsaWNlKC1pKS5qb2luKCcuJyk7XG4gICAgICAgIGNvbnN0IHN0YXJ0ID0gcGllY2VzLnNsaWNlKDAsIC1pKS5qb2luKCcuJyk7XG4gICAgICAgIGlmIChjdXJyZW50VXBkYXRlW3N0YXJ0XSAhPSBudWxsKSB7XG4gICAgICAgICAgY3VycmVudFVwZGF0ZVtzdGFydF1bcmVtbmFudF0gPSBub3c7XG4gICAgICAgICAgdGltZXN0YW1wU2V0ID0gdHJ1ZTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfSBlbHNlIGlmIChjdXJyZW50VXBkYXRlLiRzZXQgJiYgY3VycmVudFVwZGF0ZS4kc2V0W3N0YXJ0XSkge1xuICAgICAgICAgIGN1cnJlbnRVcGRhdGUuJHNldFtzdGFydF1bcmVtbmFudF0gPSBub3c7XG4gICAgICAgICAgdGltZXN0YW1wU2V0ID0gdHJ1ZTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGlmICghdGltZXN0YW1wU2V0KSB7XG4gICAgICB1cGRhdGVzLiRzZXRbdXBkYXRlZEF0XSA9IG5vdztcbiAgICB9XG5cbiAgICBpZiAodXBkYXRlcy5oYXNPd25Qcm9wZXJ0eSh1cGRhdGVkQXQpKSB7XG4gICAgICBkZWxldGUgdXBkYXRlc1t1cGRhdGVkQXRdO1xuICAgIH1cbiAgfVxuXG4gIGlmICghc2tpcENyZWF0ZWRBdCAmJiBjcmVhdGVkQXQpIHtcbiAgICBpZiAoY3VycmVudFVwZGF0ZVtjcmVhdGVkQXRdKSB7XG4gICAgICBkZWxldGUgY3VycmVudFVwZGF0ZVtjcmVhdGVkQXRdO1xuICAgIH1cbiAgICBpZiAoY3VycmVudFVwZGF0ZS4kc2V0ICYmIGN1cnJlbnRVcGRhdGUuJHNldFtjcmVhdGVkQXRdKSB7XG4gICAgICBkZWxldGUgY3VycmVudFVwZGF0ZS4kc2V0W2NyZWF0ZWRBdF07XG4gICAgfVxuICAgIGxldCB0aW1lc3RhbXBTZXQgPSBmYWxzZTtcbiAgICBpZiAoY3JlYXRlZEF0LmluZGV4T2YoJy4nKSAhPT0gLTEpIHtcbiAgICAgIGNvbnN0IHBpZWNlcyA9IGNyZWF0ZWRBdC5zcGxpdCgnLicpO1xuICAgICAgZm9yIChsZXQgaSA9IDE7IGkgPCBwaWVjZXMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgY29uc3QgcmVtbmFudCA9IHBpZWNlcy5zbGljZSgtaSkuam9pbignLicpO1xuICAgICAgICBjb25zdCBzdGFydCA9IHBpZWNlcy5zbGljZSgwLCAtaSkuam9pbignLicpO1xuICAgICAgICBpZiAoY3VycmVudFVwZGF0ZVtzdGFydF0gIT0gbnVsbCkge1xuICAgICAgICAgIGN1cnJlbnRVcGRhdGVbc3RhcnRdW3JlbW5hbnRdID0gbm93O1xuICAgICAgICAgIHRpbWVzdGFtcFNldCA9IHRydWU7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH0gZWxzZSBpZiAoY3VycmVudFVwZGF0ZS4kc2V0ICYmIGN1cnJlbnRVcGRhdGUuJHNldFtzdGFydF0pIHtcbiAgICAgICAgICBjdXJyZW50VXBkYXRlLiRzZXRbc3RhcnRdW3JlbW5hbnRdID0gbm93O1xuICAgICAgICAgIHRpbWVzdGFtcFNldCA9IHRydWU7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoIXRpbWVzdGFtcFNldCkge1xuICAgICAgdXBkYXRlcy4kc2V0T25JbnNlcnQgPSB1cGRhdGVzLiRzZXRPbkluc2VydCB8fCB7fTtcbiAgICAgIHVwZGF0ZXMuJHNldE9uSW5zZXJ0W2NyZWF0ZWRBdF0gPSBub3c7XG4gICAgfVxuICB9XG5cbiAgaWYgKE9iamVjdC5rZXlzKHVwZGF0ZXMuJHNldCkubGVuZ3RoID09PSAwKSB7XG4gICAgZGVsZXRlIHVwZGF0ZXMuJHNldDtcbiAgfVxuICByZXR1cm4gdXBkYXRlcztcbn1cbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/mongoose/lib/helpers/update/applyTimestampsToUpdate.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/mongoose/lib/helpers/update/castArrayFilters.js":
/*!**********************************************************************!*\
  !*** ./node_modules/mongoose/lib/helpers/update/castArrayFilters.js ***!
  \**********************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\n\nconst castFilterPath = __webpack_require__(/*! ../query/castFilterPath */ \"(ssr)/./node_modules/mongoose/lib/helpers/query/castFilterPath.js\");\nconst cleanPositionalOperators = __webpack_require__(/*! ../schema/cleanPositionalOperators */ \"(ssr)/./node_modules/mongoose/lib/helpers/schema/cleanPositionalOperators.js\");\nconst getPath = __webpack_require__(/*! ../schema/getPath */ \"(ssr)/./node_modules/mongoose/lib/helpers/schema/getPath.js\");\nconst updatedPathsByArrayFilter = __webpack_require__(/*! ./updatedPathsByArrayFilter */ \"(ssr)/./node_modules/mongoose/lib/helpers/update/updatedPathsByArrayFilter.js\");\n\nmodule.exports = function castArrayFilters(query) {\n  const arrayFilters = query.options.arrayFilters;\n  const update = query.getUpdate();\n  const schema = query.schema;\n  const updatedPathsByFilter = updatedPathsByArrayFilter(update);\n\n  let strictQuery = schema.options.strict;\n  if (query._mongooseOptions.strict != null) {\n    strictQuery = query._mongooseOptions.strict;\n  }\n  if (query.model && query.model.base.options.strictQuery != null) {\n    strictQuery = query.model.base.options.strictQuery;\n  }\n  if (schema._userProvidedOptions.strictQuery != null) {\n    strictQuery = schema._userProvidedOptions.strictQuery;\n  }\n  if (query._mongooseOptions.strictQuery != null) {\n    strictQuery = query._mongooseOptions.strictQuery;\n  }\n\n  _castArrayFilters(arrayFilters, schema, strictQuery, updatedPathsByFilter, query);\n};\n\nfunction _castArrayFilters(arrayFilters, schema, strictQuery, updatedPathsByFilter, query) {\n  if (!Array.isArray(arrayFilters)) {\n    return;\n  }\n\n  for (const filter of arrayFilters) {\n    if (filter == null) {\n      throw new Error(`Got null array filter in ${arrayFilters}`);\n    }\n    const keys = Object.keys(filter).filter(key => filter[key] != null);\n    if (keys.length === 0) {\n      continue;\n    }\n\n    const firstKey = keys[0];\n    if (firstKey === '$and' || firstKey === '$or') {\n      for (const key of keys) {\n        _castArrayFilters(filter[key], schema, strictQuery, updatedPathsByFilter, query);\n      }\n      continue;\n    }\n    const dot = firstKey.indexOf('.');\n    const filterWildcardPath = dot === -1 ? firstKey : firstKey.substring(0, dot);\n    if (updatedPathsByFilter[filterWildcardPath] == null) {\n      continue;\n    }\n    const baseFilterPath = cleanPositionalOperators(\n      updatedPathsByFilter[filterWildcardPath]\n    );\n\n    const baseSchematype = getPath(schema, baseFilterPath);\n    let filterBaseSchema = baseSchematype != null ? baseSchematype.schema : null;\n    if (filterBaseSchema != null &&\n        filterBaseSchema.discriminators != null &&\n        filter[filterWildcardPath + '.' + filterBaseSchema.options.discriminatorKey]) {\n      filterBaseSchema = filterBaseSchema.discriminators[filter[filterWildcardPath + '.' + filterBaseSchema.options.discriminatorKey]] || filterBaseSchema;\n    }\n\n    for (const key of keys) {\n      if (updatedPathsByFilter[key] === null) {\n        continue;\n      }\n      if (Object.keys(updatedPathsByFilter).length === 0) {\n        continue;\n      }\n      const dot = key.indexOf('.');\n\n      let filterPathRelativeToBase = dot === -1 ? null : key.substring(dot);\n      let schematype;\n      if (filterPathRelativeToBase == null || filterBaseSchema == null) {\n        schematype = baseSchematype;\n      } else {\n        // If there are multiple array filters in the path being updated, make sure\n        // to replace them so we can get the schema path.\n        filterPathRelativeToBase = cleanPositionalOperators(filterPathRelativeToBase);\n        schematype = getPath(filterBaseSchema, filterPathRelativeToBase);\n      }\n\n      if (schematype == null) {\n        if (!strictQuery) {\n          return;\n        }\n        const filterPath = filterPathRelativeToBase == null ?\n          baseFilterPath + '.0' :\n          baseFilterPath + '.0' + filterPathRelativeToBase;\n        // For now, treat `strictQuery = true` and `strictQuery = 'throw'` as\n        // equivalent for casting array filters. `strictQuery = true` doesn't\n        // quite work in this context because we never want to silently strip out\n        // array filters, even if the path isn't in the schema.\n        throw new Error(`Could not find path \"${filterPath}\" in schema`);\n      }\n      if (typeof filter[key] === 'object') {\n        filter[key] = castFilterPath(query, schematype, filter[key]);\n      } else {\n        filter[key] = schematype.castForQuery(null, filter[key]);\n      }\n    }\n  }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbW9uZ29vc2UvbGliL2hlbHBlcnMvdXBkYXRlL2Nhc3RBcnJheUZpbHRlcnMuanMiLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWIsdUJBQXVCLG1CQUFPLENBQUMsa0dBQXlCO0FBQ3hELGlDQUFpQyxtQkFBTyxDQUFDLHdIQUFvQztBQUM3RSxnQkFBZ0IsbUJBQU8sQ0FBQyxzRkFBbUI7QUFDM0Msa0NBQWtDLG1CQUFPLENBQUMsa0hBQTZCOztBQUV2RTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGtEQUFrRCxhQUFhO0FBQy9EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0RBQWdELFdBQVc7QUFDM0Q7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9hcHAxLy4vbm9kZV9tb2R1bGVzL21vbmdvb3NlL2xpYi9oZWxwZXJzL3VwZGF0ZS9jYXN0QXJyYXlGaWx0ZXJzLmpzPzYzMDQiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG5jb25zdCBjYXN0RmlsdGVyUGF0aCA9IHJlcXVpcmUoJy4uL3F1ZXJ5L2Nhc3RGaWx0ZXJQYXRoJyk7XG5jb25zdCBjbGVhblBvc2l0aW9uYWxPcGVyYXRvcnMgPSByZXF1aXJlKCcuLi9zY2hlbWEvY2xlYW5Qb3NpdGlvbmFsT3BlcmF0b3JzJyk7XG5jb25zdCBnZXRQYXRoID0gcmVxdWlyZSgnLi4vc2NoZW1hL2dldFBhdGgnKTtcbmNvbnN0IHVwZGF0ZWRQYXRoc0J5QXJyYXlGaWx0ZXIgPSByZXF1aXJlKCcuL3VwZGF0ZWRQYXRoc0J5QXJyYXlGaWx0ZXInKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBjYXN0QXJyYXlGaWx0ZXJzKHF1ZXJ5KSB7XG4gIGNvbnN0IGFycmF5RmlsdGVycyA9IHF1ZXJ5Lm9wdGlvbnMuYXJyYXlGaWx0ZXJzO1xuICBjb25zdCB1cGRhdGUgPSBxdWVyeS5nZXRVcGRhdGUoKTtcbiAgY29uc3Qgc2NoZW1hID0gcXVlcnkuc2NoZW1hO1xuICBjb25zdCB1cGRhdGVkUGF0aHNCeUZpbHRlciA9IHVwZGF0ZWRQYXRoc0J5QXJyYXlGaWx0ZXIodXBkYXRlKTtcblxuICBsZXQgc3RyaWN0UXVlcnkgPSBzY2hlbWEub3B0aW9ucy5zdHJpY3Q7XG4gIGlmIChxdWVyeS5fbW9uZ29vc2VPcHRpb25zLnN0cmljdCAhPSBudWxsKSB7XG4gICAgc3RyaWN0UXVlcnkgPSBxdWVyeS5fbW9uZ29vc2VPcHRpb25zLnN0cmljdDtcbiAgfVxuICBpZiAocXVlcnkubW9kZWwgJiYgcXVlcnkubW9kZWwuYmFzZS5vcHRpb25zLnN0cmljdFF1ZXJ5ICE9IG51bGwpIHtcbiAgICBzdHJpY3RRdWVyeSA9IHF1ZXJ5Lm1vZGVsLmJhc2Uub3B0aW9ucy5zdHJpY3RRdWVyeTtcbiAgfVxuICBpZiAoc2NoZW1hLl91c2VyUHJvdmlkZWRPcHRpb25zLnN0cmljdFF1ZXJ5ICE9IG51bGwpIHtcbiAgICBzdHJpY3RRdWVyeSA9IHNjaGVtYS5fdXNlclByb3ZpZGVkT3B0aW9ucy5zdHJpY3RRdWVyeTtcbiAgfVxuICBpZiAocXVlcnkuX21vbmdvb3NlT3B0aW9ucy5zdHJpY3RRdWVyeSAhPSBudWxsKSB7XG4gICAgc3RyaWN0UXVlcnkgPSBxdWVyeS5fbW9uZ29vc2VPcHRpb25zLnN0cmljdFF1ZXJ5O1xuICB9XG5cbiAgX2Nhc3RBcnJheUZpbHRlcnMoYXJyYXlGaWx0ZXJzLCBzY2hlbWEsIHN0cmljdFF1ZXJ5LCB1cGRhdGVkUGF0aHNCeUZpbHRlciwgcXVlcnkpO1xufTtcblxuZnVuY3Rpb24gX2Nhc3RBcnJheUZpbHRlcnMoYXJyYXlGaWx0ZXJzLCBzY2hlbWEsIHN0cmljdFF1ZXJ5LCB1cGRhdGVkUGF0aHNCeUZpbHRlciwgcXVlcnkpIHtcbiAgaWYgKCFBcnJheS5pc0FycmF5KGFycmF5RmlsdGVycykpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICBmb3IgKGNvbnN0IGZpbHRlciBvZiBhcnJheUZpbHRlcnMpIHtcbiAgICBpZiAoZmlsdGVyID09IG51bGwpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgR290IG51bGwgYXJyYXkgZmlsdGVyIGluICR7YXJyYXlGaWx0ZXJzfWApO1xuICAgIH1cbiAgICBjb25zdCBrZXlzID0gT2JqZWN0LmtleXMoZmlsdGVyKS5maWx0ZXIoa2V5ID0+IGZpbHRlcltrZXldICE9IG51bGwpO1xuICAgIGlmIChrZXlzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgY29uc3QgZmlyc3RLZXkgPSBrZXlzWzBdO1xuICAgIGlmIChmaXJzdEtleSA9PT0gJyRhbmQnIHx8IGZpcnN0S2V5ID09PSAnJG9yJykge1xuICAgICAgZm9yIChjb25zdCBrZXkgb2Yga2V5cykge1xuICAgICAgICBfY2FzdEFycmF5RmlsdGVycyhmaWx0ZXJba2V5XSwgc2NoZW1hLCBzdHJpY3RRdWVyeSwgdXBkYXRlZFBhdGhzQnlGaWx0ZXIsIHF1ZXJ5KTtcbiAgICAgIH1cbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICBjb25zdCBkb3QgPSBmaXJzdEtleS5pbmRleE9mKCcuJyk7XG4gICAgY29uc3QgZmlsdGVyV2lsZGNhcmRQYXRoID0gZG90ID09PSAtMSA/IGZpcnN0S2V5IDogZmlyc3RLZXkuc3Vic3RyaW5nKDAsIGRvdCk7XG4gICAgaWYgKHVwZGF0ZWRQYXRoc0J5RmlsdGVyW2ZpbHRlcldpbGRjYXJkUGF0aF0gPT0gbnVsbCkge1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIGNvbnN0IGJhc2VGaWx0ZXJQYXRoID0gY2xlYW5Qb3NpdGlvbmFsT3BlcmF0b3JzKFxuICAgICAgdXBkYXRlZFBhdGhzQnlGaWx0ZXJbZmlsdGVyV2lsZGNhcmRQYXRoXVxuICAgICk7XG5cbiAgICBjb25zdCBiYXNlU2NoZW1hdHlwZSA9IGdldFBhdGgoc2NoZW1hLCBiYXNlRmlsdGVyUGF0aCk7XG4gICAgbGV0IGZpbHRlckJhc2VTY2hlbWEgPSBiYXNlU2NoZW1hdHlwZSAhPSBudWxsID8gYmFzZVNjaGVtYXR5cGUuc2NoZW1hIDogbnVsbDtcbiAgICBpZiAoZmlsdGVyQmFzZVNjaGVtYSAhPSBudWxsICYmXG4gICAgICAgIGZpbHRlckJhc2VTY2hlbWEuZGlzY3JpbWluYXRvcnMgIT0gbnVsbCAmJlxuICAgICAgICBmaWx0ZXJbZmlsdGVyV2lsZGNhcmRQYXRoICsgJy4nICsgZmlsdGVyQmFzZVNjaGVtYS5vcHRpb25zLmRpc2NyaW1pbmF0b3JLZXldKSB7XG4gICAgICBmaWx0ZXJCYXNlU2NoZW1hID0gZmlsdGVyQmFzZVNjaGVtYS5kaXNjcmltaW5hdG9yc1tmaWx0ZXJbZmlsdGVyV2lsZGNhcmRQYXRoICsgJy4nICsgZmlsdGVyQmFzZVNjaGVtYS5vcHRpb25zLmRpc2NyaW1pbmF0b3JLZXldXSB8fCBmaWx0ZXJCYXNlU2NoZW1hO1xuICAgIH1cblxuICAgIGZvciAoY29uc3Qga2V5IG9mIGtleXMpIHtcbiAgICAgIGlmICh1cGRhdGVkUGF0aHNCeUZpbHRlcltrZXldID09PSBudWxsKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgaWYgKE9iamVjdC5rZXlzKHVwZGF0ZWRQYXRoc0J5RmlsdGVyKS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBjb25zdCBkb3QgPSBrZXkuaW5kZXhPZignLicpO1xuXG4gICAgICBsZXQgZmlsdGVyUGF0aFJlbGF0aXZlVG9CYXNlID0gZG90ID09PSAtMSA/IG51bGwgOiBrZXkuc3Vic3RyaW5nKGRvdCk7XG4gICAgICBsZXQgc2NoZW1hdHlwZTtcbiAgICAgIGlmIChmaWx0ZXJQYXRoUmVsYXRpdmVUb0Jhc2UgPT0gbnVsbCB8fCBmaWx0ZXJCYXNlU2NoZW1hID09IG51bGwpIHtcbiAgICAgICAgc2NoZW1hdHlwZSA9IGJhc2VTY2hlbWF0eXBlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gSWYgdGhlcmUgYXJlIG11bHRpcGxlIGFycmF5IGZpbHRlcnMgaW4gdGhlIHBhdGggYmVpbmcgdXBkYXRlZCwgbWFrZSBzdXJlXG4gICAgICAgIC8vIHRvIHJlcGxhY2UgdGhlbSBzbyB3ZSBjYW4gZ2V0IHRoZSBzY2hlbWEgcGF0aC5cbiAgICAgICAgZmlsdGVyUGF0aFJlbGF0aXZlVG9CYXNlID0gY2xlYW5Qb3NpdGlvbmFsT3BlcmF0b3JzKGZpbHRlclBhdGhSZWxhdGl2ZVRvQmFzZSk7XG4gICAgICAgIHNjaGVtYXR5cGUgPSBnZXRQYXRoKGZpbHRlckJhc2VTY2hlbWEsIGZpbHRlclBhdGhSZWxhdGl2ZVRvQmFzZSk7XG4gICAgICB9XG5cbiAgICAgIGlmIChzY2hlbWF0eXBlID09IG51bGwpIHtcbiAgICAgICAgaWYgKCFzdHJpY3RRdWVyeSkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBmaWx0ZXJQYXRoID0gZmlsdGVyUGF0aFJlbGF0aXZlVG9CYXNlID09IG51bGwgP1xuICAgICAgICAgIGJhc2VGaWx0ZXJQYXRoICsgJy4wJyA6XG4gICAgICAgICAgYmFzZUZpbHRlclBhdGggKyAnLjAnICsgZmlsdGVyUGF0aFJlbGF0aXZlVG9CYXNlO1xuICAgICAgICAvLyBGb3Igbm93LCB0cmVhdCBgc3RyaWN0UXVlcnkgPSB0cnVlYCBhbmQgYHN0cmljdFF1ZXJ5ID0gJ3Rocm93J2AgYXNcbiAgICAgICAgLy8gZXF1aXZhbGVudCBmb3IgY2FzdGluZyBhcnJheSBmaWx0ZXJzLiBgc3RyaWN0UXVlcnkgPSB0cnVlYCBkb2Vzbid0XG4gICAgICAgIC8vIHF1aXRlIHdvcmsgaW4gdGhpcyBjb250ZXh0IGJlY2F1c2Ugd2UgbmV2ZXIgd2FudCB0byBzaWxlbnRseSBzdHJpcCBvdXRcbiAgICAgICAgLy8gYXJyYXkgZmlsdGVycywgZXZlbiBpZiB0aGUgcGF0aCBpc24ndCBpbiB0aGUgc2NoZW1hLlxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYENvdWxkIG5vdCBmaW5kIHBhdGggXCIke2ZpbHRlclBhdGh9XCIgaW4gc2NoZW1hYCk7XG4gICAgICB9XG4gICAgICBpZiAodHlwZW9mIGZpbHRlcltrZXldID09PSAnb2JqZWN0Jykge1xuICAgICAgICBmaWx0ZXJba2V5XSA9IGNhc3RGaWx0ZXJQYXRoKHF1ZXJ5LCBzY2hlbWF0eXBlLCBmaWx0ZXJba2V5XSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBmaWx0ZXJba2V5XSA9IHNjaGVtYXR5cGUuY2FzdEZvclF1ZXJ5KG51bGwsIGZpbHRlcltrZXldKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/mongoose/lib/helpers/update/castArrayFilters.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/mongoose/lib/helpers/update/decorateUpdateWithVersionKey.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/mongoose/lib/helpers/update/decorateUpdateWithVersionKey.js ***!
  \**********************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\n\nconst modifiedPaths = __webpack_require__(/*! ./modifiedPaths */ \"(ssr)/./node_modules/mongoose/lib/helpers/update/modifiedPaths.js\");\n\n/**\n * Decorate the update with a version key, if necessary\n * @api private\n */\n\nmodule.exports = function decorateUpdateWithVersionKey(update, options, versionKey) {\n  if (!versionKey || !(options && options.upsert || false)) {\n    return;\n  }\n\n  const updatedPaths = modifiedPaths(update);\n  if (!updatedPaths[versionKey]) {\n    if (options.overwrite) {\n      update[versionKey] = 0;\n    } else {\n      if (!update.$setOnInsert) {\n        update.$setOnInsert = {};\n      }\n      update.$setOnInsert[versionKey] = 0;\n    }\n  }\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbW9uZ29vc2UvbGliL2hlbHBlcnMvdXBkYXRlL2RlY29yYXRlVXBkYXRlV2l0aFZlcnNpb25LZXkuanMiLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWIsc0JBQXNCLG1CQUFPLENBQUMsMEZBQWlCOztBQUUvQztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL2FwcDEvLi9ub2RlX21vZHVsZXMvbW9uZ29vc2UvbGliL2hlbHBlcnMvdXBkYXRlL2RlY29yYXRlVXBkYXRlV2l0aFZlcnNpb25LZXkuanM/MTg0NCJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbmNvbnN0IG1vZGlmaWVkUGF0aHMgPSByZXF1aXJlKCcuL21vZGlmaWVkUGF0aHMnKTtcblxuLyoqXG4gKiBEZWNvcmF0ZSB0aGUgdXBkYXRlIHdpdGggYSB2ZXJzaW9uIGtleSwgaWYgbmVjZXNzYXJ5XG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGRlY29yYXRlVXBkYXRlV2l0aFZlcnNpb25LZXkodXBkYXRlLCBvcHRpb25zLCB2ZXJzaW9uS2V5KSB7XG4gIGlmICghdmVyc2lvbktleSB8fCAhKG9wdGlvbnMgJiYgb3B0aW9ucy51cHNlcnQgfHwgZmFsc2UpKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgY29uc3QgdXBkYXRlZFBhdGhzID0gbW9kaWZpZWRQYXRocyh1cGRhdGUpO1xuICBpZiAoIXVwZGF0ZWRQYXRoc1t2ZXJzaW9uS2V5XSkge1xuICAgIGlmIChvcHRpb25zLm92ZXJ3cml0ZSkge1xuICAgICAgdXBkYXRlW3ZlcnNpb25LZXldID0gMDtcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKCF1cGRhdGUuJHNldE9uSW5zZXJ0KSB7XG4gICAgICAgIHVwZGF0ZS4kc2V0T25JbnNlcnQgPSB7fTtcbiAgICAgIH1cbiAgICAgIHVwZGF0ZS4kc2V0T25JbnNlcnRbdmVyc2lvbktleV0gPSAwO1xuICAgIH1cbiAgfVxufTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/mongoose/lib/helpers/update/decorateUpdateWithVersionKey.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/mongoose/lib/helpers/update/modifiedPaths.js":
/*!*******************************************************************!*\
  !*** ./node_modules/mongoose/lib/helpers/update/modifiedPaths.js ***!
  \*******************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\n\nconst _modifiedPaths = (__webpack_require__(/*! ../common */ \"(ssr)/./node_modules/mongoose/lib/helpers/common.js\").modifiedPaths);\n\n/**\n * Given an update document with potential update operators (`$set`, etc.)\n * returns an object whose keys are the directly modified paths.\n *\n * If there are any top-level keys that don't start with `$`, we assume those\n * will get wrapped in a `$set`. The Mongoose Query is responsible for wrapping\n * top-level keys in `$set`.\n *\n * @param {Object} update\n * @return {Object} modified\n */\n\nmodule.exports = function modifiedPaths(update) {\n  const keys = Object.keys(update);\n  const res = {};\n\n  const withoutDollarKeys = {};\n  for (const key of keys) {\n    if (key.startsWith('$')) {\n      _modifiedPaths(update[key], '', res);\n      continue;\n    }\n    withoutDollarKeys[key] = update[key];\n  }\n\n  _modifiedPaths(withoutDollarKeys, '', res);\n\n  return res;\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbW9uZ29vc2UvbGliL2hlbHBlcnMvdXBkYXRlL21vZGlmaWVkUGF0aHMuanMiLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWIsdUJBQXVCLDJHQUFrQzs7QUFFekQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixZQUFZLFFBQVE7QUFDcEI7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL2FwcDEvLi9ub2RlX21vZHVsZXMvbW9uZ29vc2UvbGliL2hlbHBlcnMvdXBkYXRlL21vZGlmaWVkUGF0aHMuanM/NTQwMSJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbmNvbnN0IF9tb2RpZmllZFBhdGhzID0gcmVxdWlyZSgnLi4vY29tbW9uJykubW9kaWZpZWRQYXRocztcblxuLyoqXG4gKiBHaXZlbiBhbiB1cGRhdGUgZG9jdW1lbnQgd2l0aCBwb3RlbnRpYWwgdXBkYXRlIG9wZXJhdG9ycyAoYCRzZXRgLCBldGMuKVxuICogcmV0dXJucyBhbiBvYmplY3Qgd2hvc2Uga2V5cyBhcmUgdGhlIGRpcmVjdGx5IG1vZGlmaWVkIHBhdGhzLlxuICpcbiAqIElmIHRoZXJlIGFyZSBhbnkgdG9wLWxldmVsIGtleXMgdGhhdCBkb24ndCBzdGFydCB3aXRoIGAkYCwgd2UgYXNzdW1lIHRob3NlXG4gKiB3aWxsIGdldCB3cmFwcGVkIGluIGEgYCRzZXRgLiBUaGUgTW9uZ29vc2UgUXVlcnkgaXMgcmVzcG9uc2libGUgZm9yIHdyYXBwaW5nXG4gKiB0b3AtbGV2ZWwga2V5cyBpbiBgJHNldGAuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IHVwZGF0ZVxuICogQHJldHVybiB7T2JqZWN0fSBtb2RpZmllZFxuICovXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gbW9kaWZpZWRQYXRocyh1cGRhdGUpIHtcbiAgY29uc3Qga2V5cyA9IE9iamVjdC5rZXlzKHVwZGF0ZSk7XG4gIGNvbnN0IHJlcyA9IHt9O1xuXG4gIGNvbnN0IHdpdGhvdXREb2xsYXJLZXlzID0ge307XG4gIGZvciAoY29uc3Qga2V5IG9mIGtleXMpIHtcbiAgICBpZiAoa2V5LnN0YXJ0c1dpdGgoJyQnKSkge1xuICAgICAgX21vZGlmaWVkUGF0aHModXBkYXRlW2tleV0sICcnLCByZXMpO1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIHdpdGhvdXREb2xsYXJLZXlzW2tleV0gPSB1cGRhdGVba2V5XTtcbiAgfVxuXG4gIF9tb2RpZmllZFBhdGhzKHdpdGhvdXREb2xsYXJLZXlzLCAnJywgcmVzKTtcblxuICByZXR1cm4gcmVzO1xufTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/mongoose/lib/helpers/update/modifiedPaths.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/mongoose/lib/helpers/update/moveImmutableProperties.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/mongoose/lib/helpers/update/moveImmutableProperties.js ***!
  \*****************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\n\nconst get = __webpack_require__(/*! ../get */ \"(ssr)/./node_modules/mongoose/lib/helpers/get.js\");\n\n/**\n * Given an update, move all $set on immutable properties to $setOnInsert.\n * This should only be called for upserts, because $setOnInsert bypasses the\n * strictness check for immutable properties.\n */\n\nmodule.exports = function moveImmutableProperties(schema, update, ctx) {\n  if (update == null) {\n    return;\n  }\n\n  const keys = Object.keys(update);\n  for (const key of keys) {\n    const isDollarKey = key.startsWith('$');\n\n    if (key === '$set') {\n      const updatedPaths = Object.keys(update[key]);\n      for (const path of updatedPaths) {\n        _walkUpdatePath(schema, update[key], path, update, ctx);\n      }\n    } else if (!isDollarKey) {\n      _walkUpdatePath(schema, update, key, update, ctx);\n    }\n\n  }\n};\n\nfunction _walkUpdatePath(schema, op, path, update, ctx) {\n  const schematype = schema.path(path);\n  if (schematype == null) {\n    return;\n  }\n\n  let immutable = get(schematype, 'options.immutable', null);\n  if (immutable == null) {\n    return;\n  }\n  if (typeof immutable === 'function') {\n    immutable = immutable.call(ctx, ctx);\n  }\n\n  if (!immutable) {\n    return;\n  }\n\n  update.$setOnInsert = update.$setOnInsert || {};\n  update.$setOnInsert[path] = op[path];\n  delete op[path];\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbW9uZ29vc2UvbGliL2hlbHBlcnMvdXBkYXRlL21vdmVJbW11dGFibGVQcm9wZXJ0aWVzLmpzIiwibWFwcGluZ3MiOiJBQUFhOztBQUViLFlBQVksbUJBQU8sQ0FBQyxnRUFBUTs7QUFFNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9hcHAxLy4vbm9kZV9tb2R1bGVzL21vbmdvb3NlL2xpYi9oZWxwZXJzL3VwZGF0ZS9tb3ZlSW1tdXRhYmxlUHJvcGVydGllcy5qcz9iYzBjIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxuY29uc3QgZ2V0ID0gcmVxdWlyZSgnLi4vZ2V0Jyk7XG5cbi8qKlxuICogR2l2ZW4gYW4gdXBkYXRlLCBtb3ZlIGFsbCAkc2V0IG9uIGltbXV0YWJsZSBwcm9wZXJ0aWVzIHRvICRzZXRPbkluc2VydC5cbiAqIFRoaXMgc2hvdWxkIG9ubHkgYmUgY2FsbGVkIGZvciB1cHNlcnRzLCBiZWNhdXNlICRzZXRPbkluc2VydCBieXBhc3NlcyB0aGVcbiAqIHN0cmljdG5lc3MgY2hlY2sgZm9yIGltbXV0YWJsZSBwcm9wZXJ0aWVzLlxuICovXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gbW92ZUltbXV0YWJsZVByb3BlcnRpZXMoc2NoZW1hLCB1cGRhdGUsIGN0eCkge1xuICBpZiAodXBkYXRlID09IG51bGwpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICBjb25zdCBrZXlzID0gT2JqZWN0LmtleXModXBkYXRlKTtcbiAgZm9yIChjb25zdCBrZXkgb2Yga2V5cykge1xuICAgIGNvbnN0IGlzRG9sbGFyS2V5ID0ga2V5LnN0YXJ0c1dpdGgoJyQnKTtcblxuICAgIGlmIChrZXkgPT09ICckc2V0Jykge1xuICAgICAgY29uc3QgdXBkYXRlZFBhdGhzID0gT2JqZWN0LmtleXModXBkYXRlW2tleV0pO1xuICAgICAgZm9yIChjb25zdCBwYXRoIG9mIHVwZGF0ZWRQYXRocykge1xuICAgICAgICBfd2Fsa1VwZGF0ZVBhdGgoc2NoZW1hLCB1cGRhdGVba2V5XSwgcGF0aCwgdXBkYXRlLCBjdHgpO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoIWlzRG9sbGFyS2V5KSB7XG4gICAgICBfd2Fsa1VwZGF0ZVBhdGgoc2NoZW1hLCB1cGRhdGUsIGtleSwgdXBkYXRlLCBjdHgpO1xuICAgIH1cblxuICB9XG59O1xuXG5mdW5jdGlvbiBfd2Fsa1VwZGF0ZVBhdGgoc2NoZW1hLCBvcCwgcGF0aCwgdXBkYXRlLCBjdHgpIHtcbiAgY29uc3Qgc2NoZW1hdHlwZSA9IHNjaGVtYS5wYXRoKHBhdGgpO1xuICBpZiAoc2NoZW1hdHlwZSA9PSBudWxsKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgbGV0IGltbXV0YWJsZSA9IGdldChzY2hlbWF0eXBlLCAnb3B0aW9ucy5pbW11dGFibGUnLCBudWxsKTtcbiAgaWYgKGltbXV0YWJsZSA9PSBudWxsKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGlmICh0eXBlb2YgaW1tdXRhYmxlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgaW1tdXRhYmxlID0gaW1tdXRhYmxlLmNhbGwoY3R4LCBjdHgpO1xuICB9XG5cbiAgaWYgKCFpbW11dGFibGUpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICB1cGRhdGUuJHNldE9uSW5zZXJ0ID0gdXBkYXRlLiRzZXRPbkluc2VydCB8fCB7fTtcbiAgdXBkYXRlLiRzZXRPbkluc2VydFtwYXRoXSA9IG9wW3BhdGhdO1xuICBkZWxldGUgb3BbcGF0aF07XG59XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/mongoose/lib/helpers/update/moveImmutableProperties.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/mongoose/lib/helpers/update/removeUnusedArrayFilters.js":
/*!******************************************************************************!*\
  !*** ./node_modules/mongoose/lib/helpers/update/removeUnusedArrayFilters.js ***!
  \******************************************************************************/
/***/ ((module) => {

eval("\n\n/**\n * MongoDB throws an error if there's unused array filters. That is, if `options.arrayFilters` defines\n * a filter, but none of the `update` keys use it. This should be enough to filter out all unused array\n * filters.\n */\n\nmodule.exports = function removeUnusedArrayFilters(update, arrayFilters) {\n  const updateKeys = Object.keys(update).\n    map(key => Object.keys(update[key])).\n    reduce((cur, arr) => cur.concat(arr), []);\n  return arrayFilters.filter(obj => {\n    return _checkSingleFilterKey(obj, updateKeys);\n  });\n};\n\nfunction _checkSingleFilterKey(arrayFilter, updateKeys) {\n  const firstKey = Object.keys(arrayFilter)[0];\n\n  if (firstKey === '$and' || firstKey === '$or') {\n    if (!Array.isArray(arrayFilter[firstKey])) {\n      return false;\n    }\n    return arrayFilter[firstKey].find(filter => _checkSingleFilterKey(filter, updateKeys)) != null;\n  }\n\n  const firstDot = firstKey.indexOf('.');\n  const arrayFilterKey = firstDot === -1 ? firstKey : firstKey.slice(0, firstDot);\n\n  return updateKeys.find(key => key.includes('$[' + arrayFilterKey + ']')) != null;\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbW9uZ29vc2UvbGliL2hlbHBlcnMvdXBkYXRlL3JlbW92ZVVudXNlZEFycmF5RmlsdGVycy5qcyIsIm1hcHBpbmdzIjoiQUFBYTs7QUFFYjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9hcHAxLy4vbm9kZV9tb2R1bGVzL21vbmdvb3NlL2xpYi9oZWxwZXJzL3VwZGF0ZS9yZW1vdmVVbnVzZWRBcnJheUZpbHRlcnMuanM/N2UyZSJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbi8qKlxuICogTW9uZ29EQiB0aHJvd3MgYW4gZXJyb3IgaWYgdGhlcmUncyB1bnVzZWQgYXJyYXkgZmlsdGVycy4gVGhhdCBpcywgaWYgYG9wdGlvbnMuYXJyYXlGaWx0ZXJzYCBkZWZpbmVzXG4gKiBhIGZpbHRlciwgYnV0IG5vbmUgb2YgdGhlIGB1cGRhdGVgIGtleXMgdXNlIGl0LiBUaGlzIHNob3VsZCBiZSBlbm91Z2ggdG8gZmlsdGVyIG91dCBhbGwgdW51c2VkIGFycmF5XG4gKiBmaWx0ZXJzLlxuICovXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gcmVtb3ZlVW51c2VkQXJyYXlGaWx0ZXJzKHVwZGF0ZSwgYXJyYXlGaWx0ZXJzKSB7XG4gIGNvbnN0IHVwZGF0ZUtleXMgPSBPYmplY3Qua2V5cyh1cGRhdGUpLlxuICAgIG1hcChrZXkgPT4gT2JqZWN0LmtleXModXBkYXRlW2tleV0pKS5cbiAgICByZWR1Y2UoKGN1ciwgYXJyKSA9PiBjdXIuY29uY2F0KGFyciksIFtdKTtcbiAgcmV0dXJuIGFycmF5RmlsdGVycy5maWx0ZXIob2JqID0+IHtcbiAgICByZXR1cm4gX2NoZWNrU2luZ2xlRmlsdGVyS2V5KG9iaiwgdXBkYXRlS2V5cyk7XG4gIH0pO1xufTtcblxuZnVuY3Rpb24gX2NoZWNrU2luZ2xlRmlsdGVyS2V5KGFycmF5RmlsdGVyLCB1cGRhdGVLZXlzKSB7XG4gIGNvbnN0IGZpcnN0S2V5ID0gT2JqZWN0LmtleXMoYXJyYXlGaWx0ZXIpWzBdO1xuXG4gIGlmIChmaXJzdEtleSA9PT0gJyRhbmQnIHx8IGZpcnN0S2V5ID09PSAnJG9yJykge1xuICAgIGlmICghQXJyYXkuaXNBcnJheShhcnJheUZpbHRlcltmaXJzdEtleV0pKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHJldHVybiBhcnJheUZpbHRlcltmaXJzdEtleV0uZmluZChmaWx0ZXIgPT4gX2NoZWNrU2luZ2xlRmlsdGVyS2V5KGZpbHRlciwgdXBkYXRlS2V5cykpICE9IG51bGw7XG4gIH1cblxuICBjb25zdCBmaXJzdERvdCA9IGZpcnN0S2V5LmluZGV4T2YoJy4nKTtcbiAgY29uc3QgYXJyYXlGaWx0ZXJLZXkgPSBmaXJzdERvdCA9PT0gLTEgPyBmaXJzdEtleSA6IGZpcnN0S2V5LnNsaWNlKDAsIGZpcnN0RG90KTtcblxuICByZXR1cm4gdXBkYXRlS2V5cy5maW5kKGtleSA9PiBrZXkuaW5jbHVkZXMoJyRbJyArIGFycmF5RmlsdGVyS2V5ICsgJ10nKSkgIT0gbnVsbDtcbn1cbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/mongoose/lib/helpers/update/removeUnusedArrayFilters.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/mongoose/lib/helpers/update/updatedPathsByArrayFilter.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/mongoose/lib/helpers/update/updatedPathsByArrayFilter.js ***!
  \*******************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\n\nconst modifiedPaths = __webpack_require__(/*! ./modifiedPaths */ \"(ssr)/./node_modules/mongoose/lib/helpers/update/modifiedPaths.js\");\n\nmodule.exports = function updatedPathsByArrayFilter(update) {\n  if (update == null) {\n    return {};\n  }\n  const updatedPaths = modifiedPaths(update);\n\n  return Object.keys(updatedPaths).reduce((cur, path) => {\n    const matches = path.match(/\\$\\[[^\\]]+\\]/g);\n    if (matches == null) {\n      return cur;\n    }\n    for (const match of matches) {\n      const firstMatch = path.indexOf(match);\n      if (firstMatch !== path.lastIndexOf(match)) {\n        throw new Error(`Path '${path}' contains the same array filter multiple times`);\n      }\n      cur[match.substring(2, match.length - 1)] = path.\n        substring(0, firstMatch - 1).\n        replace(/\\$\\[[^\\]]+\\]/g, '0');\n    }\n    return cur;\n  }, {});\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbW9uZ29vc2UvbGliL2hlbHBlcnMvdXBkYXRlL3VwZGF0ZWRQYXRoc0J5QXJyYXlGaWx0ZXIuanMiLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWIsc0JBQXNCLG1CQUFPLENBQUMsMEZBQWlCOztBQUUvQztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUMsS0FBSztBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHLElBQUk7QUFDUCIsInNvdXJjZXMiOlsid2VicGFjazovL2FwcDEvLi9ub2RlX21vZHVsZXMvbW9uZ29vc2UvbGliL2hlbHBlcnMvdXBkYXRlL3VwZGF0ZWRQYXRoc0J5QXJyYXlGaWx0ZXIuanM/MjcyZCJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbmNvbnN0IG1vZGlmaWVkUGF0aHMgPSByZXF1aXJlKCcuL21vZGlmaWVkUGF0aHMnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiB1cGRhdGVkUGF0aHNCeUFycmF5RmlsdGVyKHVwZGF0ZSkge1xuICBpZiAodXBkYXRlID09IG51bGwpIHtcbiAgICByZXR1cm4ge307XG4gIH1cbiAgY29uc3QgdXBkYXRlZFBhdGhzID0gbW9kaWZpZWRQYXRocyh1cGRhdGUpO1xuXG4gIHJldHVybiBPYmplY3Qua2V5cyh1cGRhdGVkUGF0aHMpLnJlZHVjZSgoY3VyLCBwYXRoKSA9PiB7XG4gICAgY29uc3QgbWF0Y2hlcyA9IHBhdGgubWF0Y2goL1xcJFxcW1teXFxdXStcXF0vZyk7XG4gICAgaWYgKG1hdGNoZXMgPT0gbnVsbCkge1xuICAgICAgcmV0dXJuIGN1cjtcbiAgICB9XG4gICAgZm9yIChjb25zdCBtYXRjaCBvZiBtYXRjaGVzKSB7XG4gICAgICBjb25zdCBmaXJzdE1hdGNoID0gcGF0aC5pbmRleE9mKG1hdGNoKTtcbiAgICAgIGlmIChmaXJzdE1hdGNoICE9PSBwYXRoLmxhc3RJbmRleE9mKG1hdGNoKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFBhdGggJyR7cGF0aH0nIGNvbnRhaW5zIHRoZSBzYW1lIGFycmF5IGZpbHRlciBtdWx0aXBsZSB0aW1lc2ApO1xuICAgICAgfVxuICAgICAgY3VyW21hdGNoLnN1YnN0cmluZygyLCBtYXRjaC5sZW5ndGggLSAxKV0gPSBwYXRoLlxuICAgICAgICBzdWJzdHJpbmcoMCwgZmlyc3RNYXRjaCAtIDEpLlxuICAgICAgICByZXBsYWNlKC9cXCRcXFtbXlxcXV0rXFxdL2csICcwJyk7XG4gICAgfVxuICAgIHJldHVybiBjdXI7XG4gIH0sIHt9KTtcbn07XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/mongoose/lib/helpers/update/updatedPathsByArrayFilter.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/mongoose/lib/helpers/updateValidators.js":
/*!***************************************************************!*\
  !*** ./node_modules/mongoose/lib/helpers/updateValidators.js ***!
  \***************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\n\n/*!\n * Module dependencies.\n */\n\nconst ValidationError = __webpack_require__(/*! ../error/validation */ \"(ssr)/./node_modules/mongoose/lib/error/validation.js\");\nconst cleanPositionalOperators = __webpack_require__(/*! ./schema/cleanPositionalOperators */ \"(ssr)/./node_modules/mongoose/lib/helpers/schema/cleanPositionalOperators.js\");\nconst flatten = (__webpack_require__(/*! ./common */ \"(ssr)/./node_modules/mongoose/lib/helpers/common.js\").flatten);\nconst modifiedPaths = (__webpack_require__(/*! ./common */ \"(ssr)/./node_modules/mongoose/lib/helpers/common.js\").modifiedPaths);\n\n/**\n * Applies validators and defaults to update and findOneAndUpdate operations,\n * specifically passing a null doc as `this` to validators and defaults\n *\n * @param {Query} query\n * @param {Schema} schema\n * @param {Object} castedDoc\n * @param {Object} options\n * @method runValidatorsOnUpdate\n * @api private\n */\n\nmodule.exports = function(query, schema, castedDoc, options, callback) {\n  const keys = Object.keys(castedDoc || {});\n  let updatedKeys = {};\n  let updatedValues = {};\n  const isPull = {};\n  const arrayAtomicUpdates = {};\n  const numKeys = keys.length;\n  let hasDollarUpdate = false;\n  const modified = {};\n  let currentUpdate;\n  let key;\n  let i;\n\n  for (i = 0; i < numKeys; ++i) {\n    if (keys[i].startsWith('$')) {\n      hasDollarUpdate = true;\n      if (keys[i] === '$push' || keys[i] === '$addToSet') {\n        const _keys = Object.keys(castedDoc[keys[i]]);\n        for (let ii = 0; ii < _keys.length; ++ii) {\n          currentUpdate = castedDoc[keys[i]][_keys[ii]];\n          if (currentUpdate && currentUpdate.$each) {\n            arrayAtomicUpdates[_keys[ii]] = (arrayAtomicUpdates[_keys[ii]] || []).\n              concat(currentUpdate.$each);\n          } else {\n            arrayAtomicUpdates[_keys[ii]] = (arrayAtomicUpdates[_keys[ii]] || []).\n              concat([currentUpdate]);\n          }\n        }\n        continue;\n      }\n      modifiedPaths(castedDoc[keys[i]], '', modified);\n      const flat = flatten(castedDoc[keys[i]], null, null, schema);\n      const paths = Object.keys(flat);\n      const numPaths = paths.length;\n      for (let j = 0; j < numPaths; ++j) {\n        const updatedPath = cleanPositionalOperators(paths[j]);\n        key = keys[i];\n        // With `$pull` we might flatten `$in`. Skip stuff nested under `$in`\n        // for the rest of the logic, it will get handled later.\n        if (updatedPath.includes('$')) {\n          continue;\n        }\n        if (key === '$set' || key === '$setOnInsert' ||\n            key === '$pull' || key === '$pullAll') {\n          updatedValues[updatedPath] = flat[paths[j]];\n          isPull[updatedPath] = key === '$pull' || key === '$pullAll';\n        } else if (key === '$unset') {\n          updatedValues[updatedPath] = undefined;\n        }\n        updatedKeys[updatedPath] = true;\n      }\n    }\n  }\n\n  if (!hasDollarUpdate) {\n    modifiedPaths(castedDoc, '', modified);\n    updatedValues = flatten(castedDoc, null, null, schema);\n    updatedKeys = Object.keys(updatedValues);\n  }\n\n  const updates = Object.keys(updatedValues);\n  const numUpdates = updates.length;\n  const validatorsToExecute = [];\n  const validationErrors = [];\n\n  const alreadyValidated = [];\n\n  const context = query;\n  function iter(i, v) {\n    const schemaPath = schema._getSchema(updates[i]);\n    if (schemaPath == null) {\n      return;\n    }\n    if (schemaPath.instance === 'Mixed' && schemaPath.path !== updates[i]) {\n      return;\n    }\n\n    if (v && Array.isArray(v.$in)) {\n      v.$in.forEach((v, i) => {\n        validatorsToExecute.push(function(callback) {\n          schemaPath.doValidate(\n            v,\n            function(err) {\n              if (err) {\n                err.path = updates[i] + '.$in.' + i;\n                validationErrors.push(err);\n              }\n              callback(null);\n            },\n            context,\n            { updateValidator: true });\n        });\n      });\n    } else {\n      if (isPull[updates[i]] &&\n          schemaPath.$isMongooseArray) {\n        return;\n      }\n\n      if (schemaPath.$isMongooseDocumentArrayElement && v != null && v.$__ != null) {\n        alreadyValidated.push(updates[i]);\n        validatorsToExecute.push(function(callback) {\n          schemaPath.doValidate(v, function(err) {\n            if (err) {\n              if (err.errors) {\n                for (const key of Object.keys(err.errors)) {\n                  const _err = err.errors[key];\n                  _err.path = updates[i] + '.' + key;\n                  validationErrors.push(_err);\n                }\n              } else {\n                err.path = updates[i];\n                validationErrors.push(err);\n              }\n            }\n\n            return callback(null);\n          }, context, { updateValidator: true });\n        });\n      } else {\n        validatorsToExecute.push(function(callback) {\n          for (const path of alreadyValidated) {\n            if (updates[i].startsWith(path + '.')) {\n              return callback(null);\n            }\n          }\n\n          schemaPath.doValidate(v, function(err) {\n            if (schemaPath.schema != null &&\n                schemaPath.schema.options.storeSubdocValidationError === false &&\n                err instanceof ValidationError) {\n              return callback(null);\n            }\n\n            if (err) {\n              err.path = updates[i];\n              validationErrors.push(err);\n            }\n            callback(null);\n          }, context, { updateValidator: true });\n        });\n      }\n    }\n  }\n  for (i = 0; i < numUpdates; ++i) {\n    iter(i, updatedValues[updates[i]]);\n  }\n\n  const arrayUpdates = Object.keys(arrayAtomicUpdates);\n  for (const arrayUpdate of arrayUpdates) {\n    let schemaPath = schema._getSchema(arrayUpdate);\n    if (schemaPath && schemaPath.$isMongooseDocumentArray) {\n      validatorsToExecute.push(function(callback) {\n        schemaPath.doValidate(\n          arrayAtomicUpdates[arrayUpdate],\n          getValidationCallback(arrayUpdate, validationErrors, callback),\n          options && options.context === 'query' ? query : null);\n      });\n    } else {\n      schemaPath = schema._getSchema(arrayUpdate + '.0');\n      for (const atomicUpdate of arrayAtomicUpdates[arrayUpdate]) {\n        validatorsToExecute.push(function(callback) {\n          schemaPath.doValidate(\n            atomicUpdate,\n            getValidationCallback(arrayUpdate, validationErrors, callback),\n            options && options.context === 'query' ? query : null,\n            { updateValidator: true });\n        });\n      }\n    }\n  }\n\n  if (callback != null) {\n    let numValidators = validatorsToExecute.length;\n    if (numValidators === 0) {\n      return _done(callback);\n    }\n    for (const validator of validatorsToExecute) {\n      validator(function() {\n        if (--numValidators <= 0) {\n          _done(callback);\n        }\n      });\n    }\n\n    return;\n  }\n\n  return function(callback) {\n    let numValidators = validatorsToExecute.length;\n    if (numValidators === 0) {\n      return _done(callback);\n    }\n    for (const validator of validatorsToExecute) {\n      validator(function() {\n        if (--numValidators <= 0) {\n          _done(callback);\n        }\n      });\n    }\n  };\n\n  function _done(callback) {\n    if (validationErrors.length) {\n      const err = new ValidationError(null);\n\n      for (const validationError of validationErrors) {\n        err.addError(validationError.path, validationError);\n      }\n\n      return callback(err);\n    }\n    callback(null);\n  }\n\n  function getValidationCallback(arrayUpdate, validationErrors, callback) {\n    return function(err) {\n      if (err) {\n        err.path = arrayUpdate;\n        validationErrors.push(err);\n      }\n      callback(null);\n    };\n  }\n};\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbW9uZ29vc2UvbGliL2hlbHBlcnMvdXBkYXRlVmFsaWRhdG9ycy5qcyIsIm1hcHBpbmdzIjoiQUFBYTs7QUFFYjtBQUNBO0FBQ0E7O0FBRUEsd0JBQXdCLG1CQUFPLENBQUMsa0ZBQXFCO0FBQ3JELGlDQUFpQyxtQkFBTyxDQUFDLHVIQUFtQztBQUM1RSxnQkFBZ0Isb0dBQTJCO0FBQzNDLHNCQUFzQiwwR0FBaUM7O0FBRXZEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDBDQUEwQztBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxjQUFjLGFBQWE7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsbUJBQW1CO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLGNBQWM7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBLGNBQWMsdUJBQXVCO0FBQ3JDLFNBQVM7QUFDVCxPQUFPO0FBQ1AsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxXQUFXLGFBQWEsdUJBQXVCO0FBQy9DLFNBQVM7QUFDVCxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxhQUFhLHVCQUF1QjtBQUMvQyxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsY0FBYyxnQkFBZ0I7QUFDOUI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyx1QkFBdUI7QUFDckMsU0FBUztBQUNUO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL2FwcDEvLi9ub2RlX21vZHVsZXMvbW9uZ29vc2UvbGliL2hlbHBlcnMvdXBkYXRlVmFsaWRhdG9ycy5qcz8xMTQ1Il0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxuLyohXG4gKiBNb2R1bGUgZGVwZW5kZW5jaWVzLlxuICovXG5cbmNvbnN0IFZhbGlkYXRpb25FcnJvciA9IHJlcXVpcmUoJy4uL2Vycm9yL3ZhbGlkYXRpb24nKTtcbmNvbnN0IGNsZWFuUG9zaXRpb25hbE9wZXJhdG9ycyA9IHJlcXVpcmUoJy4vc2NoZW1hL2NsZWFuUG9zaXRpb25hbE9wZXJhdG9ycycpO1xuY29uc3QgZmxhdHRlbiA9IHJlcXVpcmUoJy4vY29tbW9uJykuZmxhdHRlbjtcbmNvbnN0IG1vZGlmaWVkUGF0aHMgPSByZXF1aXJlKCcuL2NvbW1vbicpLm1vZGlmaWVkUGF0aHM7XG5cbi8qKlxuICogQXBwbGllcyB2YWxpZGF0b3JzIGFuZCBkZWZhdWx0cyB0byB1cGRhdGUgYW5kIGZpbmRPbmVBbmRVcGRhdGUgb3BlcmF0aW9ucyxcbiAqIHNwZWNpZmljYWxseSBwYXNzaW5nIGEgbnVsbCBkb2MgYXMgYHRoaXNgIHRvIHZhbGlkYXRvcnMgYW5kIGRlZmF1bHRzXG4gKlxuICogQHBhcmFtIHtRdWVyeX0gcXVlcnlcbiAqIEBwYXJhbSB7U2NoZW1hfSBzY2hlbWFcbiAqIEBwYXJhbSB7T2JqZWN0fSBjYXN0ZWREb2NcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zXG4gKiBAbWV0aG9kIHJ1blZhbGlkYXRvcnNPblVwZGF0ZVxuICogQGFwaSBwcml2YXRlXG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihxdWVyeSwgc2NoZW1hLCBjYXN0ZWREb2MsIG9wdGlvbnMsIGNhbGxiYWNrKSB7XG4gIGNvbnN0IGtleXMgPSBPYmplY3Qua2V5cyhjYXN0ZWREb2MgfHwge30pO1xuICBsZXQgdXBkYXRlZEtleXMgPSB7fTtcbiAgbGV0IHVwZGF0ZWRWYWx1ZXMgPSB7fTtcbiAgY29uc3QgaXNQdWxsID0ge307XG4gIGNvbnN0IGFycmF5QXRvbWljVXBkYXRlcyA9IHt9O1xuICBjb25zdCBudW1LZXlzID0ga2V5cy5sZW5ndGg7XG4gIGxldCBoYXNEb2xsYXJVcGRhdGUgPSBmYWxzZTtcbiAgY29uc3QgbW9kaWZpZWQgPSB7fTtcbiAgbGV0IGN1cnJlbnRVcGRhdGU7XG4gIGxldCBrZXk7XG4gIGxldCBpO1xuXG4gIGZvciAoaSA9IDA7IGkgPCBudW1LZXlzOyArK2kpIHtcbiAgICBpZiAoa2V5c1tpXS5zdGFydHNXaXRoKCckJykpIHtcbiAgICAgIGhhc0RvbGxhclVwZGF0ZSA9IHRydWU7XG4gICAgICBpZiAoa2V5c1tpXSA9PT0gJyRwdXNoJyB8fCBrZXlzW2ldID09PSAnJGFkZFRvU2V0Jykge1xuICAgICAgICBjb25zdCBfa2V5cyA9IE9iamVjdC5rZXlzKGNhc3RlZERvY1trZXlzW2ldXSk7XG4gICAgICAgIGZvciAobGV0IGlpID0gMDsgaWkgPCBfa2V5cy5sZW5ndGg7ICsraWkpIHtcbiAgICAgICAgICBjdXJyZW50VXBkYXRlID0gY2FzdGVkRG9jW2tleXNbaV1dW19rZXlzW2lpXV07XG4gICAgICAgICAgaWYgKGN1cnJlbnRVcGRhdGUgJiYgY3VycmVudFVwZGF0ZS4kZWFjaCkge1xuICAgICAgICAgICAgYXJyYXlBdG9taWNVcGRhdGVzW19rZXlzW2lpXV0gPSAoYXJyYXlBdG9taWNVcGRhdGVzW19rZXlzW2lpXV0gfHwgW10pLlxuICAgICAgICAgICAgICBjb25jYXQoY3VycmVudFVwZGF0ZS4kZWFjaCk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGFycmF5QXRvbWljVXBkYXRlc1tfa2V5c1tpaV1dID0gKGFycmF5QXRvbWljVXBkYXRlc1tfa2V5c1tpaV1dIHx8IFtdKS5cbiAgICAgICAgICAgICAgY29uY2F0KFtjdXJyZW50VXBkYXRlXSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgbW9kaWZpZWRQYXRocyhjYXN0ZWREb2Nba2V5c1tpXV0sICcnLCBtb2RpZmllZCk7XG4gICAgICBjb25zdCBmbGF0ID0gZmxhdHRlbihjYXN0ZWREb2Nba2V5c1tpXV0sIG51bGwsIG51bGwsIHNjaGVtYSk7XG4gICAgICBjb25zdCBwYXRocyA9IE9iamVjdC5rZXlzKGZsYXQpO1xuICAgICAgY29uc3QgbnVtUGF0aHMgPSBwYXRocy5sZW5ndGg7XG4gICAgICBmb3IgKGxldCBqID0gMDsgaiA8IG51bVBhdGhzOyArK2opIHtcbiAgICAgICAgY29uc3QgdXBkYXRlZFBhdGggPSBjbGVhblBvc2l0aW9uYWxPcGVyYXRvcnMocGF0aHNbal0pO1xuICAgICAgICBrZXkgPSBrZXlzW2ldO1xuICAgICAgICAvLyBXaXRoIGAkcHVsbGAgd2UgbWlnaHQgZmxhdHRlbiBgJGluYC4gU2tpcCBzdHVmZiBuZXN0ZWQgdW5kZXIgYCRpbmBcbiAgICAgICAgLy8gZm9yIHRoZSByZXN0IG9mIHRoZSBsb2dpYywgaXQgd2lsbCBnZXQgaGFuZGxlZCBsYXRlci5cbiAgICAgICAgaWYgKHVwZGF0ZWRQYXRoLmluY2x1ZGVzKCckJykpIHtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoa2V5ID09PSAnJHNldCcgfHwga2V5ID09PSAnJHNldE9uSW5zZXJ0JyB8fFxuICAgICAgICAgICAga2V5ID09PSAnJHB1bGwnIHx8IGtleSA9PT0gJyRwdWxsQWxsJykge1xuICAgICAgICAgIHVwZGF0ZWRWYWx1ZXNbdXBkYXRlZFBhdGhdID0gZmxhdFtwYXRoc1tqXV07XG4gICAgICAgICAgaXNQdWxsW3VwZGF0ZWRQYXRoXSA9IGtleSA9PT0gJyRwdWxsJyB8fCBrZXkgPT09ICckcHVsbEFsbCc7XG4gICAgICAgIH0gZWxzZSBpZiAoa2V5ID09PSAnJHVuc2V0Jykge1xuICAgICAgICAgIHVwZGF0ZWRWYWx1ZXNbdXBkYXRlZFBhdGhdID0gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICAgIHVwZGF0ZWRLZXlzW3VwZGF0ZWRQYXRoXSA9IHRydWU7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgaWYgKCFoYXNEb2xsYXJVcGRhdGUpIHtcbiAgICBtb2RpZmllZFBhdGhzKGNhc3RlZERvYywgJycsIG1vZGlmaWVkKTtcbiAgICB1cGRhdGVkVmFsdWVzID0gZmxhdHRlbihjYXN0ZWREb2MsIG51bGwsIG51bGwsIHNjaGVtYSk7XG4gICAgdXBkYXRlZEtleXMgPSBPYmplY3Qua2V5cyh1cGRhdGVkVmFsdWVzKTtcbiAgfVxuXG4gIGNvbnN0IHVwZGF0ZXMgPSBPYmplY3Qua2V5cyh1cGRhdGVkVmFsdWVzKTtcbiAgY29uc3QgbnVtVXBkYXRlcyA9IHVwZGF0ZXMubGVuZ3RoO1xuICBjb25zdCB2YWxpZGF0b3JzVG9FeGVjdXRlID0gW107XG4gIGNvbnN0IHZhbGlkYXRpb25FcnJvcnMgPSBbXTtcblxuICBjb25zdCBhbHJlYWR5VmFsaWRhdGVkID0gW107XG5cbiAgY29uc3QgY29udGV4dCA9IHF1ZXJ5O1xuICBmdW5jdGlvbiBpdGVyKGksIHYpIHtcbiAgICBjb25zdCBzY2hlbWFQYXRoID0gc2NoZW1hLl9nZXRTY2hlbWEodXBkYXRlc1tpXSk7XG4gICAgaWYgKHNjaGVtYVBhdGggPT0gbnVsbCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoc2NoZW1hUGF0aC5pbnN0YW5jZSA9PT0gJ01peGVkJyAmJiBzY2hlbWFQYXRoLnBhdGggIT09IHVwZGF0ZXNbaV0pIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAodiAmJiBBcnJheS5pc0FycmF5KHYuJGluKSkge1xuICAgICAgdi4kaW4uZm9yRWFjaCgodiwgaSkgPT4ge1xuICAgICAgICB2YWxpZGF0b3JzVG9FeGVjdXRlLnB1c2goZnVuY3Rpb24oY2FsbGJhY2spIHtcbiAgICAgICAgICBzY2hlbWFQYXRoLmRvVmFsaWRhdGUoXG4gICAgICAgICAgICB2LFxuICAgICAgICAgICAgZnVuY3Rpb24oZXJyKSB7XG4gICAgICAgICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICAgICAgICBlcnIucGF0aCA9IHVwZGF0ZXNbaV0gKyAnLiRpbi4nICsgaTtcbiAgICAgICAgICAgICAgICB2YWxpZGF0aW9uRXJyb3JzLnB1c2goZXJyKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBjYWxsYmFjayhudWxsKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBjb250ZXh0LFxuICAgICAgICAgICAgeyB1cGRhdGVWYWxpZGF0b3I6IHRydWUgfSk7XG4gICAgICAgIH0pO1xuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChpc1B1bGxbdXBkYXRlc1tpXV0gJiZcbiAgICAgICAgICBzY2hlbWFQYXRoLiRpc01vbmdvb3NlQXJyYXkpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBpZiAoc2NoZW1hUGF0aC4kaXNNb25nb29zZURvY3VtZW50QXJyYXlFbGVtZW50ICYmIHYgIT0gbnVsbCAmJiB2LiRfXyAhPSBudWxsKSB7XG4gICAgICAgIGFscmVhZHlWYWxpZGF0ZWQucHVzaCh1cGRhdGVzW2ldKTtcbiAgICAgICAgdmFsaWRhdG9yc1RvRXhlY3V0ZS5wdXNoKGZ1bmN0aW9uKGNhbGxiYWNrKSB7XG4gICAgICAgICAgc2NoZW1hUGF0aC5kb1ZhbGlkYXRlKHYsIGZ1bmN0aW9uKGVycikge1xuICAgICAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgICAgICBpZiAoZXJyLmVycm9ycykge1xuICAgICAgICAgICAgICAgIGZvciAoY29uc3Qga2V5IG9mIE9iamVjdC5rZXlzKGVyci5lcnJvcnMpKSB7XG4gICAgICAgICAgICAgICAgICBjb25zdCBfZXJyID0gZXJyLmVycm9yc1trZXldO1xuICAgICAgICAgICAgICAgICAgX2Vyci5wYXRoID0gdXBkYXRlc1tpXSArICcuJyArIGtleTtcbiAgICAgICAgICAgICAgICAgIHZhbGlkYXRpb25FcnJvcnMucHVzaChfZXJyKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgZXJyLnBhdGggPSB1cGRhdGVzW2ldO1xuICAgICAgICAgICAgICAgIHZhbGlkYXRpb25FcnJvcnMucHVzaChlcnIpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBjYWxsYmFjayhudWxsKTtcbiAgICAgICAgICB9LCBjb250ZXh0LCB7IHVwZGF0ZVZhbGlkYXRvcjogdHJ1ZSB9KTtcbiAgICAgICAgfSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YWxpZGF0b3JzVG9FeGVjdXRlLnB1c2goZnVuY3Rpb24oY2FsbGJhY2spIHtcbiAgICAgICAgICBmb3IgKGNvbnN0IHBhdGggb2YgYWxyZWFkeVZhbGlkYXRlZCkge1xuICAgICAgICAgICAgaWYgKHVwZGF0ZXNbaV0uc3RhcnRzV2l0aChwYXRoICsgJy4nKSkge1xuICAgICAgICAgICAgICByZXR1cm4gY2FsbGJhY2sobnVsbCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgc2NoZW1hUGF0aC5kb1ZhbGlkYXRlKHYsIGZ1bmN0aW9uKGVycikge1xuICAgICAgICAgICAgaWYgKHNjaGVtYVBhdGguc2NoZW1hICE9IG51bGwgJiZcbiAgICAgICAgICAgICAgICBzY2hlbWFQYXRoLnNjaGVtYS5vcHRpb25zLnN0b3JlU3ViZG9jVmFsaWRhdGlvbkVycm9yID09PSBmYWxzZSAmJlxuICAgICAgICAgICAgICAgIGVyciBpbnN0YW5jZW9mIFZhbGlkYXRpb25FcnJvcikge1xuICAgICAgICAgICAgICByZXR1cm4gY2FsbGJhY2sobnVsbCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICAgICAgZXJyLnBhdGggPSB1cGRhdGVzW2ldO1xuICAgICAgICAgICAgICB2YWxpZGF0aW9uRXJyb3JzLnB1c2goZXJyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhbGxiYWNrKG51bGwpO1xuICAgICAgICAgIH0sIGNvbnRleHQsIHsgdXBkYXRlVmFsaWRhdG9yOiB0cnVlIH0pO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgZm9yIChpID0gMDsgaSA8IG51bVVwZGF0ZXM7ICsraSkge1xuICAgIGl0ZXIoaSwgdXBkYXRlZFZhbHVlc1t1cGRhdGVzW2ldXSk7XG4gIH1cblxuICBjb25zdCBhcnJheVVwZGF0ZXMgPSBPYmplY3Qua2V5cyhhcnJheUF0b21pY1VwZGF0ZXMpO1xuICBmb3IgKGNvbnN0IGFycmF5VXBkYXRlIG9mIGFycmF5VXBkYXRlcykge1xuICAgIGxldCBzY2hlbWFQYXRoID0gc2NoZW1hLl9nZXRTY2hlbWEoYXJyYXlVcGRhdGUpO1xuICAgIGlmIChzY2hlbWFQYXRoICYmIHNjaGVtYVBhdGguJGlzTW9uZ29vc2VEb2N1bWVudEFycmF5KSB7XG4gICAgICB2YWxpZGF0b3JzVG9FeGVjdXRlLnB1c2goZnVuY3Rpb24oY2FsbGJhY2spIHtcbiAgICAgICAgc2NoZW1hUGF0aC5kb1ZhbGlkYXRlKFxuICAgICAgICAgIGFycmF5QXRvbWljVXBkYXRlc1thcnJheVVwZGF0ZV0sXG4gICAgICAgICAgZ2V0VmFsaWRhdGlvbkNhbGxiYWNrKGFycmF5VXBkYXRlLCB2YWxpZGF0aW9uRXJyb3JzLCBjYWxsYmFjayksXG4gICAgICAgICAgb3B0aW9ucyAmJiBvcHRpb25zLmNvbnRleHQgPT09ICdxdWVyeScgPyBxdWVyeSA6IG51bGwpO1xuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHNjaGVtYVBhdGggPSBzY2hlbWEuX2dldFNjaGVtYShhcnJheVVwZGF0ZSArICcuMCcpO1xuICAgICAgZm9yIChjb25zdCBhdG9taWNVcGRhdGUgb2YgYXJyYXlBdG9taWNVcGRhdGVzW2FycmF5VXBkYXRlXSkge1xuICAgICAgICB2YWxpZGF0b3JzVG9FeGVjdXRlLnB1c2goZnVuY3Rpb24oY2FsbGJhY2spIHtcbiAgICAgICAgICBzY2hlbWFQYXRoLmRvVmFsaWRhdGUoXG4gICAgICAgICAgICBhdG9taWNVcGRhdGUsXG4gICAgICAgICAgICBnZXRWYWxpZGF0aW9uQ2FsbGJhY2soYXJyYXlVcGRhdGUsIHZhbGlkYXRpb25FcnJvcnMsIGNhbGxiYWNrKSxcbiAgICAgICAgICAgIG9wdGlvbnMgJiYgb3B0aW9ucy5jb250ZXh0ID09PSAncXVlcnknID8gcXVlcnkgOiBudWxsLFxuICAgICAgICAgICAgeyB1cGRhdGVWYWxpZGF0b3I6IHRydWUgfSk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGlmIChjYWxsYmFjayAhPSBudWxsKSB7XG4gICAgbGV0IG51bVZhbGlkYXRvcnMgPSB2YWxpZGF0b3JzVG9FeGVjdXRlLmxlbmd0aDtcbiAgICBpZiAobnVtVmFsaWRhdG9ycyA9PT0gMCkge1xuICAgICAgcmV0dXJuIF9kb25lKGNhbGxiYWNrKTtcbiAgICB9XG4gICAgZm9yIChjb25zdCB2YWxpZGF0b3Igb2YgdmFsaWRhdG9yc1RvRXhlY3V0ZSkge1xuICAgICAgdmFsaWRhdG9yKGZ1bmN0aW9uKCkge1xuICAgICAgICBpZiAoLS1udW1WYWxpZGF0b3JzIDw9IDApIHtcbiAgICAgICAgICBfZG9uZShjYWxsYmFjayk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cblxuICAgIHJldHVybjtcbiAgfVxuXG4gIHJldHVybiBmdW5jdGlvbihjYWxsYmFjaykge1xuICAgIGxldCBudW1WYWxpZGF0b3JzID0gdmFsaWRhdG9yc1RvRXhlY3V0ZS5sZW5ndGg7XG4gICAgaWYgKG51bVZhbGlkYXRvcnMgPT09IDApIHtcbiAgICAgIHJldHVybiBfZG9uZShjYWxsYmFjayk7XG4gICAgfVxuICAgIGZvciAoY29uc3QgdmFsaWRhdG9yIG9mIHZhbGlkYXRvcnNUb0V4ZWN1dGUpIHtcbiAgICAgIHZhbGlkYXRvcihmdW5jdGlvbigpIHtcbiAgICAgICAgaWYgKC0tbnVtVmFsaWRhdG9ycyA8PSAwKSB7XG4gICAgICAgICAgX2RvbmUoY2FsbGJhY2spO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG4gIH07XG5cbiAgZnVuY3Rpb24gX2RvbmUoY2FsbGJhY2spIHtcbiAgICBpZiAodmFsaWRhdGlvbkVycm9ycy5sZW5ndGgpIHtcbiAgICAgIGNvbnN0IGVyciA9IG5ldyBWYWxpZGF0aW9uRXJyb3IobnVsbCk7XG5cbiAgICAgIGZvciAoY29uc3QgdmFsaWRhdGlvbkVycm9yIG9mIHZhbGlkYXRpb25FcnJvcnMpIHtcbiAgICAgICAgZXJyLmFkZEVycm9yKHZhbGlkYXRpb25FcnJvci5wYXRoLCB2YWxpZGF0aW9uRXJyb3IpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gY2FsbGJhY2soZXJyKTtcbiAgICB9XG4gICAgY2FsbGJhY2sobnVsbCk7XG4gIH1cblxuICBmdW5jdGlvbiBnZXRWYWxpZGF0aW9uQ2FsbGJhY2soYXJyYXlVcGRhdGUsIHZhbGlkYXRpb25FcnJvcnMsIGNhbGxiYWNrKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKGVycikge1xuICAgICAgaWYgKGVycikge1xuICAgICAgICBlcnIucGF0aCA9IGFycmF5VXBkYXRlO1xuICAgICAgICB2YWxpZGF0aW9uRXJyb3JzLnB1c2goZXJyKTtcbiAgICAgIH1cbiAgICAgIGNhbGxiYWNrKG51bGwpO1xuICAgIH07XG4gIH1cbn07XG5cbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/mongoose/lib/helpers/updateValidators.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/mongoose/lib/index.js":
/*!********************************************!*\
  !*** ./node_modules/mongoose/lib/index.js ***!
  \********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\n\n/*!\n * Module dependencies.\n */\n\n(__webpack_require__(/*! ./driver */ \"(ssr)/./node_modules/mongoose/lib/driver.js\").set)(__webpack_require__(/*! ./drivers/node-mongodb-native */ \"(ssr)/./node_modules/mongoose/lib/drivers/node-mongodb-native/index.js\"));\n\nconst mongoose = __webpack_require__(/*! ./mongoose */ \"(ssr)/./node_modules/mongoose/lib/mongoose.js\");\n\nmongoose.Mongoose.prototype.mongo = __webpack_require__(/*! mongodb */ \"(ssr)/./node_modules/mongodb/lib/index.js\");\n\nmodule.exports = mongoose;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbW9uZ29vc2UvbGliL2luZGV4LmpzIiwibWFwcGluZ3MiOiJBQUFhOztBQUViO0FBQ0E7QUFDQTs7QUFFQSx3RkFBdUIsQ0FBQyxtQkFBTyxDQUFDLDZHQUErQjs7QUFFL0QsaUJBQWlCLG1CQUFPLENBQUMsaUVBQVk7O0FBRXJDLG9DQUFvQyxtQkFBTyxDQUFDLDBEQUFTOztBQUVyRCIsInNvdXJjZXMiOlsid2VicGFjazovL2FwcDEvLi9ub2RlX21vZHVsZXMvbW9uZ29vc2UvbGliL2luZGV4LmpzPzM2M2QiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG4vKiFcbiAqIE1vZHVsZSBkZXBlbmRlbmNpZXMuXG4gKi9cblxucmVxdWlyZSgnLi9kcml2ZXInKS5zZXQocmVxdWlyZSgnLi9kcml2ZXJzL25vZGUtbW9uZ29kYi1uYXRpdmUnKSk7XG5cbmNvbnN0IG1vbmdvb3NlID0gcmVxdWlyZSgnLi9tb25nb29zZScpO1xuXG5tb25nb29zZS5Nb25nb29zZS5wcm90b3R5cGUubW9uZ28gPSByZXF1aXJlKCdtb25nb2RiJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gbW9uZ29vc2U7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/mongoose/lib/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/mongoose/lib/internal.js":
/*!***********************************************!*\
  !*** ./node_modules/mongoose/lib/internal.js ***!
  \***********************************************/
/***/ ((module, exports, __webpack_require__) => {

eval("/*!\n * Dependencies\n */\n\n\n\nconst StateMachine = __webpack_require__(/*! ./stateMachine */ \"(ssr)/./node_modules/mongoose/lib/stateMachine.js\");\nconst ActiveRoster = StateMachine.ctor('require', 'modify', 'init', 'default', 'ignore');\n\nmodule.exports = exports = InternalCache;\n\nfunction InternalCache() {\n  this.activePaths = new ActiveRoster();\n}\n\nInternalCache.prototype.strictMode = true;\n\nInternalCache.prototype.fullPath = undefined;\nInternalCache.prototype.selected = undefined;\nInternalCache.prototype.shardval = undefined;\nInternalCache.prototype.saveError = undefined;\nInternalCache.prototype.validationError = undefined;\nInternalCache.prototype.adhocPaths = undefined;\nInternalCache.prototype.removing = undefined;\nInternalCache.prototype.inserting = undefined;\nInternalCache.prototype.saving = undefined;\nInternalCache.prototype.version = undefined;\nInternalCache.prototype._id = undefined;\nInternalCache.prototype.ownerDocument = undefined;\nInternalCache.prototype.populate = undefined; // what we want to populate in this doc\nInternalCache.prototype.populated = undefined;// the _ids that have been populated\nInternalCache.prototype.primitiveAtomics = undefined;\n\n/**\n * If `false`, this document was not the result of population.\n * If `true`, this document is a populated doc underneath another doc\n * If an object, this document is a populated doc and the `value` property of the\n * object contains the original depopulated value.\n */\nInternalCache.prototype.wasPopulated = false;\n\nInternalCache.prototype.scope = undefined;\n\nInternalCache.prototype.session = null;\nInternalCache.prototype.pathsToScopes = null;\nInternalCache.prototype.cachedRequired = null;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbW9uZ29vc2UvbGliL2ludGVybmFsLmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTs7QUFFYTs7QUFFYixxQkFBcUIsbUJBQU8sQ0FBQyx5RUFBZ0I7QUFDN0M7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE4QztBQUM5Qyw4Q0FBOEM7QUFDOUM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vYXBwMS8uL25vZGVfbW9kdWxlcy9tb25nb29zZS9saWIvaW50ZXJuYWwuanM/MGIyMCJdLCJzb3VyY2VzQ29udGVudCI6WyIvKiFcbiAqIERlcGVuZGVuY2llc1xuICovXG5cbid1c2Ugc3RyaWN0JztcblxuY29uc3QgU3RhdGVNYWNoaW5lID0gcmVxdWlyZSgnLi9zdGF0ZU1hY2hpbmUnKTtcbmNvbnN0IEFjdGl2ZVJvc3RlciA9IFN0YXRlTWFjaGluZS5jdG9yKCdyZXF1aXJlJywgJ21vZGlmeScsICdpbml0JywgJ2RlZmF1bHQnLCAnaWdub3JlJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0cyA9IEludGVybmFsQ2FjaGU7XG5cbmZ1bmN0aW9uIEludGVybmFsQ2FjaGUoKSB7XG4gIHRoaXMuYWN0aXZlUGF0aHMgPSBuZXcgQWN0aXZlUm9zdGVyKCk7XG59XG5cbkludGVybmFsQ2FjaGUucHJvdG90eXBlLnN0cmljdE1vZGUgPSB0cnVlO1xuXG5JbnRlcm5hbENhY2hlLnByb3RvdHlwZS5mdWxsUGF0aCA9IHVuZGVmaW5lZDtcbkludGVybmFsQ2FjaGUucHJvdG90eXBlLnNlbGVjdGVkID0gdW5kZWZpbmVkO1xuSW50ZXJuYWxDYWNoZS5wcm90b3R5cGUuc2hhcmR2YWwgPSB1bmRlZmluZWQ7XG5JbnRlcm5hbENhY2hlLnByb3RvdHlwZS5zYXZlRXJyb3IgPSB1bmRlZmluZWQ7XG5JbnRlcm5hbENhY2hlLnByb3RvdHlwZS52YWxpZGF0aW9uRXJyb3IgPSB1bmRlZmluZWQ7XG5JbnRlcm5hbENhY2hlLnByb3RvdHlwZS5hZGhvY1BhdGhzID0gdW5kZWZpbmVkO1xuSW50ZXJuYWxDYWNoZS5wcm90b3R5cGUucmVtb3ZpbmcgPSB1bmRlZmluZWQ7XG5JbnRlcm5hbENhY2hlLnByb3RvdHlwZS5pbnNlcnRpbmcgPSB1bmRlZmluZWQ7XG5JbnRlcm5hbENhY2hlLnByb3RvdHlwZS5zYXZpbmcgPSB1bmRlZmluZWQ7XG5JbnRlcm5hbENhY2hlLnByb3RvdHlwZS52ZXJzaW9uID0gdW5kZWZpbmVkO1xuSW50ZXJuYWxDYWNoZS5wcm90b3R5cGUuX2lkID0gdW5kZWZpbmVkO1xuSW50ZXJuYWxDYWNoZS5wcm90b3R5cGUub3duZXJEb2N1bWVudCA9IHVuZGVmaW5lZDtcbkludGVybmFsQ2FjaGUucHJvdG90eXBlLnBvcHVsYXRlID0gdW5kZWZpbmVkOyAvLyB3aGF0IHdlIHdhbnQgdG8gcG9wdWxhdGUgaW4gdGhpcyBkb2NcbkludGVybmFsQ2FjaGUucHJvdG90eXBlLnBvcHVsYXRlZCA9IHVuZGVmaW5lZDsvLyB0aGUgX2lkcyB0aGF0IGhhdmUgYmVlbiBwb3B1bGF0ZWRcbkludGVybmFsQ2FjaGUucHJvdG90eXBlLnByaW1pdGl2ZUF0b21pY3MgPSB1bmRlZmluZWQ7XG5cbi8qKlxuICogSWYgYGZhbHNlYCwgdGhpcyBkb2N1bWVudCB3YXMgbm90IHRoZSByZXN1bHQgb2YgcG9wdWxhdGlvbi5cbiAqIElmIGB0cnVlYCwgdGhpcyBkb2N1bWVudCBpcyBhIHBvcHVsYXRlZCBkb2MgdW5kZXJuZWF0aCBhbm90aGVyIGRvY1xuICogSWYgYW4gb2JqZWN0LCB0aGlzIGRvY3VtZW50IGlzIGEgcG9wdWxhdGVkIGRvYyBhbmQgdGhlIGB2YWx1ZWAgcHJvcGVydHkgb2YgdGhlXG4gKiBvYmplY3QgY29udGFpbnMgdGhlIG9yaWdpbmFsIGRlcG9wdWxhdGVkIHZhbHVlLlxuICovXG5JbnRlcm5hbENhY2hlLnByb3RvdHlwZS53YXNQb3B1bGF0ZWQgPSBmYWxzZTtcblxuSW50ZXJuYWxDYWNoZS5wcm90b3R5cGUuc2NvcGUgPSB1bmRlZmluZWQ7XG5cbkludGVybmFsQ2FjaGUucHJvdG90eXBlLnNlc3Npb24gPSBudWxsO1xuSW50ZXJuYWxDYWNoZS5wcm90b3R5cGUucGF0aHNUb1Njb3BlcyA9IG51bGw7XG5JbnRlcm5hbENhY2hlLnByb3RvdHlwZS5jYWNoZWRSZXF1aXJlZCA9IG51bGw7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/mongoose/lib/internal.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/mongoose/lib/model.js":
/*!********************************************!*\
  !*** ./node_modules/mongoose/lib/model.js ***!
  \********************************************/
/***/ ((module, exports, __webpack_require__) => {

eval("\n\n/*!\n * Module dependencies.\n */\n\nconst Aggregate = __webpack_require__(/*! ./aggregate */ \"(ssr)/./node_modules/mongoose/lib/aggregate.js\");\nconst ChangeStream = __webpack_require__(/*! ./cursor/changeStream */ \"(ssr)/./node_modules/mongoose/lib/cursor/changeStream.js\");\nconst Document = __webpack_require__(/*! ./document */ \"(ssr)/./node_modules/mongoose/lib/document.js\");\nconst DocumentNotFoundError = __webpack_require__(/*! ./error/notFound */ \"(ssr)/./node_modules/mongoose/lib/error/notFound.js\");\nconst DivergentArrayError = __webpack_require__(/*! ./error/divergentArray */ \"(ssr)/./node_modules/mongoose/lib/error/divergentArray.js\");\nconst EventEmitter = (__webpack_require__(/*! events */ \"events\").EventEmitter);\nconst Kareem = __webpack_require__(/*! kareem */ \"(ssr)/./node_modules/kareem/index.js\");\nconst MongooseBuffer = __webpack_require__(/*! ./types/buffer */ \"(ssr)/./node_modules/mongoose/lib/types/buffer.js\");\nconst MongooseError = __webpack_require__(/*! ./error/index */ \"(ssr)/./node_modules/mongoose/lib/error/index.js\");\nconst OverwriteModelError = __webpack_require__(/*! ./error/overwriteModel */ \"(ssr)/./node_modules/mongoose/lib/error/overwriteModel.js\");\nconst Query = __webpack_require__(/*! ./query */ \"(ssr)/./node_modules/mongoose/lib/query.js\");\nconst SaveOptions = __webpack_require__(/*! ./options/saveOptions */ \"(ssr)/./node_modules/mongoose/lib/options/saveOptions.js\");\nconst Schema = __webpack_require__(/*! ./schema */ \"(ssr)/./node_modules/mongoose/lib/schema.js\");\nconst ValidationError = __webpack_require__(/*! ./error/validation */ \"(ssr)/./node_modules/mongoose/lib/error/validation.js\");\nconst VersionError = __webpack_require__(/*! ./error/version */ \"(ssr)/./node_modules/mongoose/lib/error/version.js\");\nconst ParallelSaveError = __webpack_require__(/*! ./error/parallelSave */ \"(ssr)/./node_modules/mongoose/lib/error/parallelSave.js\");\nconst applyDefaultsHelper = __webpack_require__(/*! ./helpers/document/applyDefaults */ \"(ssr)/./node_modules/mongoose/lib/helpers/document/applyDefaults.js\");\nconst applyDefaultsToPOJO = __webpack_require__(/*! ./helpers/model/applyDefaultsToPOJO */ \"(ssr)/./node_modules/mongoose/lib/helpers/model/applyDefaultsToPOJO.js\");\nconst applyQueryMiddleware = __webpack_require__(/*! ./helpers/query/applyQueryMiddleware */ \"(ssr)/./node_modules/mongoose/lib/helpers/query/applyQueryMiddleware.js\");\nconst applyHooks = __webpack_require__(/*! ./helpers/model/applyHooks */ \"(ssr)/./node_modules/mongoose/lib/helpers/model/applyHooks.js\");\nconst applyMethods = __webpack_require__(/*! ./helpers/model/applyMethods */ \"(ssr)/./node_modules/mongoose/lib/helpers/model/applyMethods.js\");\nconst applyProjection = __webpack_require__(/*! ./helpers/projection/applyProjection */ \"(ssr)/./node_modules/mongoose/lib/helpers/projection/applyProjection.js\");\nconst applySchemaCollation = __webpack_require__(/*! ./helpers/indexes/applySchemaCollation */ \"(ssr)/./node_modules/mongoose/lib/helpers/indexes/applySchemaCollation.js\");\nconst applyStaticHooks = __webpack_require__(/*! ./helpers/model/applyStaticHooks */ \"(ssr)/./node_modules/mongoose/lib/helpers/model/applyStaticHooks.js\");\nconst applyStatics = __webpack_require__(/*! ./helpers/model/applyStatics */ \"(ssr)/./node_modules/mongoose/lib/helpers/model/applyStatics.js\");\nconst applyWriteConcern = __webpack_require__(/*! ./helpers/schema/applyWriteConcern */ \"(ssr)/./node_modules/mongoose/lib/helpers/schema/applyWriteConcern.js\");\nconst assignVals = __webpack_require__(/*! ./helpers/populate/assignVals */ \"(ssr)/./node_modules/mongoose/lib/helpers/populate/assignVals.js\");\nconst castBulkWrite = __webpack_require__(/*! ./helpers/model/castBulkWrite */ \"(ssr)/./node_modules/mongoose/lib/helpers/model/castBulkWrite.js\");\nconst clone = __webpack_require__(/*! ./helpers/clone */ \"(ssr)/./node_modules/mongoose/lib/helpers/clone.js\");\nconst createPopulateQueryFilter = __webpack_require__(/*! ./helpers/populate/createPopulateQueryFilter */ \"(ssr)/./node_modules/mongoose/lib/helpers/populate/createPopulateQueryFilter.js\");\nconst decorateUpdateWithVersionKey = __webpack_require__(/*! ./helpers/update/decorateUpdateWithVersionKey */ \"(ssr)/./node_modules/mongoose/lib/helpers/update/decorateUpdateWithVersionKey.js\");\nconst getDefaultBulkwriteResult = __webpack_require__(/*! ./helpers/getDefaultBulkwriteResult */ \"(ssr)/./node_modules/mongoose/lib/helpers/getDefaultBulkwriteResult.js\");\nconst getSchemaDiscriminatorByValue = __webpack_require__(/*! ./helpers/discriminator/getSchemaDiscriminatorByValue */ \"(ssr)/./node_modules/mongoose/lib/helpers/discriminator/getSchemaDiscriminatorByValue.js\");\nconst discriminator = __webpack_require__(/*! ./helpers/model/discriminator */ \"(ssr)/./node_modules/mongoose/lib/helpers/model/discriminator.js\");\nconst firstKey = __webpack_require__(/*! ./helpers/firstKey */ \"(ssr)/./node_modules/mongoose/lib/helpers/firstKey.js\");\nconst each = __webpack_require__(/*! ./helpers/each */ \"(ssr)/./node_modules/mongoose/lib/helpers/each.js\");\nconst get = __webpack_require__(/*! ./helpers/get */ \"(ssr)/./node_modules/mongoose/lib/helpers/get.js\");\nconst getConstructorName = __webpack_require__(/*! ./helpers/getConstructorName */ \"(ssr)/./node_modules/mongoose/lib/helpers/getConstructorName.js\");\nconst getDiscriminatorByValue = __webpack_require__(/*! ./helpers/discriminator/getDiscriminatorByValue */ \"(ssr)/./node_modules/mongoose/lib/helpers/discriminator/getDiscriminatorByValue.js\");\nconst getModelsMapForPopulate = __webpack_require__(/*! ./helpers/populate/getModelsMapForPopulate */ \"(ssr)/./node_modules/mongoose/lib/helpers/populate/getModelsMapForPopulate.js\");\nconst immediate = __webpack_require__(/*! ./helpers/immediate */ \"(ssr)/./node_modules/mongoose/lib/helpers/immediate.js\");\nconst internalToObjectOptions = (__webpack_require__(/*! ./options */ \"(ssr)/./node_modules/mongoose/lib/options.js\").internalToObjectOptions);\nconst isDefaultIdIndex = __webpack_require__(/*! ./helpers/indexes/isDefaultIdIndex */ \"(ssr)/./node_modules/mongoose/lib/helpers/indexes/isDefaultIdIndex.js\");\nconst isIndexEqual = __webpack_require__(/*! ./helpers/indexes/isIndexEqual */ \"(ssr)/./node_modules/mongoose/lib/helpers/indexes/isIndexEqual.js\");\nconst {\n  getRelatedDBIndexes,\n  getRelatedSchemaIndexes\n} = __webpack_require__(/*! ./helpers/indexes/getRelatedIndexes */ \"(ssr)/./node_modules/mongoose/lib/helpers/indexes/getRelatedIndexes.js\");\nconst isPathExcluded = __webpack_require__(/*! ./helpers/projection/isPathExcluded */ \"(ssr)/./node_modules/mongoose/lib/helpers/projection/isPathExcluded.js\");\nconst decorateDiscriminatorIndexOptions = __webpack_require__(/*! ./helpers/indexes/decorateDiscriminatorIndexOptions */ \"(ssr)/./node_modules/mongoose/lib/helpers/indexes/decorateDiscriminatorIndexOptions.js\");\nconst isPathSelectedInclusive = __webpack_require__(/*! ./helpers/projection/isPathSelectedInclusive */ \"(ssr)/./node_modules/mongoose/lib/helpers/projection/isPathSelectedInclusive.js\");\nconst leanPopulateMap = __webpack_require__(/*! ./helpers/populate/leanPopulateMap */ \"(ssr)/./node_modules/mongoose/lib/helpers/populate/leanPopulateMap.js\");\nconst parallelLimit = __webpack_require__(/*! ./helpers/parallelLimit */ \"(ssr)/./node_modules/mongoose/lib/helpers/parallelLimit.js\");\nconst parentPaths = __webpack_require__(/*! ./helpers/path/parentPaths */ \"(ssr)/./node_modules/mongoose/lib/helpers/path/parentPaths.js\");\nconst prepareDiscriminatorPipeline = __webpack_require__(/*! ./helpers/aggregate/prepareDiscriminatorPipeline */ \"(ssr)/./node_modules/mongoose/lib/helpers/aggregate/prepareDiscriminatorPipeline.js\");\nconst pushNestedArrayPaths = __webpack_require__(/*! ./helpers/model/pushNestedArrayPaths */ \"(ssr)/./node_modules/mongoose/lib/helpers/model/pushNestedArrayPaths.js\");\nconst removeDeselectedForeignField = __webpack_require__(/*! ./helpers/populate/removeDeselectedForeignField */ \"(ssr)/./node_modules/mongoose/lib/helpers/populate/removeDeselectedForeignField.js\");\nconst setDottedPath = __webpack_require__(/*! ./helpers/path/setDottedPath */ \"(ssr)/./node_modules/mongoose/lib/helpers/path/setDottedPath.js\");\nconst STATES = __webpack_require__(/*! ./connectionState */ \"(ssr)/./node_modules/mongoose/lib/connectionState.js\");\nconst util = __webpack_require__(/*! util */ \"util\");\nconst utils = __webpack_require__(/*! ./utils */ \"(ssr)/./node_modules/mongoose/lib/utils.js\");\nconst MongooseBulkWriteError = __webpack_require__(/*! ./error/bulkWriteError */ \"(ssr)/./node_modules/mongoose/lib/error/bulkWriteError.js\");\nconst minimize = __webpack_require__(/*! ./helpers/minimize */ \"(ssr)/./node_modules/mongoose/lib/helpers/minimize.js\");\n\nconst VERSION_WHERE = 1;\nconst VERSION_INC = 2;\nconst VERSION_ALL = VERSION_WHERE | VERSION_INC;\n\nconst arrayAtomicsSymbol = (__webpack_require__(/*! ./helpers/symbols */ \"(ssr)/./node_modules/mongoose/lib/helpers/symbols.js\").arrayAtomicsSymbol);\nconst modelCollectionSymbol = Symbol('mongoose#Model#collection');\nconst modelDbSymbol = Symbol('mongoose#Model#db');\nconst modelSymbol = (__webpack_require__(/*! ./helpers/symbols */ \"(ssr)/./node_modules/mongoose/lib/helpers/symbols.js\").modelSymbol);\nconst subclassedSymbol = Symbol('mongoose#Model#subclassed');\n\nconst saveToObjectOptions = Object.assign({}, internalToObjectOptions, {\n  bson: true,\n  flattenObjectIds: false\n});\n\n/**\n * A Model is a class that's your primary tool for interacting with MongoDB.\n * An instance of a Model is called a [Document](https://mongoosejs.com/docs/api/document.html#Document).\n *\n * In Mongoose, the term \"Model\" refers to subclasses of the `mongoose.Model`\n * class. You should not use the `mongoose.Model` class directly. The\n * [`mongoose.model()`](https://mongoosejs.com/docs/api/mongoose.html#Mongoose.prototype.model()) and\n * [`connection.model()`](https://mongoosejs.com/docs/api/connection.html#Connection.prototype.model()) functions\n * create subclasses of `mongoose.Model` as shown below.\n *\n * #### Example:\n *\n *     // `UserModel` is a \"Model\", a subclass of `mongoose.Model`.\n *     const UserModel = mongoose.model('User', new Schema({ name: String }));\n *\n *     // You can use a Model to create new documents using `new`:\n *     const userDoc = new UserModel({ name: 'Foo' });\n *     await userDoc.save();\n *\n *     // You also use a model to create queries:\n *     const userFromDb = await UserModel.findOne({ name: 'Foo' });\n *\n * @param {Object} doc values for initial set\n * @param {Object} [fields] optional object containing the fields that were selected in the query which returned this document. You do **not** need to set this parameter to ensure Mongoose handles your [query projection](https://mongoosejs.com/docs/api/query.html#Query.prototype.select()).\n * @param {Boolean} [skipId=false] optional boolean. If true, mongoose doesn't add an `_id` field to the document.\n * @inherits Document https://mongoosejs.com/docs/api/document.html\n * @event `error`: If listening to this event, 'error' is emitted when a document was saved and an `error` occurred. If not listening, the event bubbles to the connection used to create this Model.\n * @event `index`: Emitted after `Model#ensureIndexes` completes. If an error occurred it is passed with the event.\n * @event `index-single-start`: Emitted when an individual index starts within `Model#ensureIndexes`. The fields and options being used to build the index are also passed with the event.\n * @event `index-single-done`: Emitted when an individual index finishes within `Model#ensureIndexes`. If an error occurred it is passed with the event. The fields, options, and index name are also passed.\n * @api public\n */\n\nfunction Model(doc, fields, skipId) {\n  if (fields instanceof Schema) {\n    throw new TypeError('2nd argument to `Model` must be a POJO or string, ' +\n      '**not** a schema. Make sure you\\'re calling `mongoose.model()`, not ' +\n      '`mongoose.Model()`.');\n  }\n  Document.call(this, doc, fields, skipId);\n}\n\n/**\n * Inherits from Document.\n *\n * All Model.prototype features are available on\n * top level (non-sub) documents.\n * @api private\n */\n\nObject.setPrototypeOf(Model.prototype, Document.prototype);\nModel.prototype.$isMongooseModelPrototype = true;\n\n/**\n * Connection the model uses.\n *\n * @api public\n * @property db\n * @memberOf Model\n * @instance\n */\n\nModel.prototype.db;\n\n/**\n * The collection instance this model uses.\n * A Mongoose collection is a thin wrapper around a [MongoDB Node.js driver collection]([MongoDB Node.js driver collection](https://mongodb.github.io/node-mongodb-native/Next/classes/Collection.html)).\n * Using `Model.collection` means you bypass Mongoose middleware, validation, and casting.\n *\n * This property is read-only. Modifying this property is a no-op.\n *\n * @api public\n * @property collection\n * @memberOf Model\n * @instance\n */\n\nModel.prototype.collection;\n\n/**\n * Internal collection the model uses.\n *\n * This property is read-only. Modifying this property is a no-op.\n *\n * @api private\n * @property collection\n * @memberOf Model\n * @instance\n */\n\n\nModel.prototype.$__collection;\n\n/**\n * The name of the model\n *\n * @api public\n * @property modelName\n * @memberOf Model\n * @instance\n */\n\nModel.prototype.modelName;\n\n/**\n * Additional properties to attach to the query when calling `save()` and\n * `isNew` is false.\n *\n * @api public\n * @property $where\n * @memberOf Model\n * @instance\n */\n\nModel.prototype.$where;\n\n/**\n * If this is a discriminator model, `baseModelName` is the name of\n * the base model.\n *\n * @api public\n * @property baseModelName\n * @memberOf Model\n * @instance\n */\n\nModel.prototype.baseModelName;\n\n/**\n * Event emitter that reports any errors that occurred. Useful for global error\n * handling.\n *\n * #### Example:\n *\n *     MyModel.events.on('error', err => console.log(err.message));\n *\n *     // Prints a 'CastError' because of the above handler\n *     await MyModel.findOne({ _id: 'Not a valid ObjectId' }).catch(noop);\n *\n * @api public\n * @property events\n * @fires error whenever any query or model function errors\n * @memberOf Model\n * @static\n */\n\nModel.events;\n\n/**\n * Compiled middleware for this model. Set in `applyHooks()`.\n *\n * @api private\n * @property _middleware\n * @memberOf Model\n * @static\n */\n\nModel._middleware;\n\n/*!\n * ignore\n */\n\nfunction _applyCustomWhere(doc, where) {\n  if (doc.$where == null) {\n    return;\n  }\n  for (const key of Object.keys(doc.$where)) {\n    where[key] = doc.$where[key];\n  }\n}\n\n/*!\n * ignore\n */\n\nModel.prototype.$__handleSave = function(options, callback) {\n  const saveOptions = {};\n\n  applyWriteConcern(this.$__schema, options);\n  if (typeof options.writeConcern !== 'undefined') {\n    saveOptions.writeConcern = {};\n    if ('w' in options.writeConcern) {\n      saveOptions.writeConcern.w = options.writeConcern.w;\n    }\n    if ('j' in options.writeConcern) {\n      saveOptions.writeConcern.j = options.writeConcern.j;\n    }\n    if ('wtimeout' in options.writeConcern) {\n      saveOptions.writeConcern.wtimeout = options.writeConcern.wtimeout;\n    }\n  } else {\n    if ('w' in options) {\n      saveOptions.w = options.w;\n    }\n    if ('j' in options) {\n      saveOptions.j = options.j;\n    }\n    if ('wtimeout' in options) {\n      saveOptions.wtimeout = options.wtimeout;\n    }\n  }\n  if ('checkKeys' in options) {\n    saveOptions.checkKeys = options.checkKeys;\n  }\n\n  const session = this.$session();\n  if (!saveOptions.hasOwnProperty('session') && session != null) {\n    saveOptions.session = session;\n  }\n\n  if (this.$isNew) {\n    // send entire doc\n    const obj = this.toObject(saveToObjectOptions);\n    if ((obj || {})._id === void 0) {\n      // documents must have an _id else mongoose won't know\n      // what to update later if more changes are made. the user\n      // wouldn't know what _id was generated by mongodb either\n      // nor would the ObjectId generated by mongodb necessarily\n      // match the schema definition.\n      immediate(function() {\n        callback(new MongooseError('document must have an _id before saving'));\n      });\n      return;\n    }\n\n    this.$__version(true, obj);\n    this[modelCollectionSymbol].insertOne(obj, saveOptions).then(\n      ret => callback(null, ret),\n      err => {\n        _setIsNew(this, true);\n\n        callback(err, null);\n      }\n    );\n\n    this.$__reset();\n    _setIsNew(this, false);\n    // Make it possible to retry the insert\n    this.$__.inserting = true;\n    return;\n  }\n\n  // Make sure we don't treat it as a new object on error,\n  // since it already exists\n  this.$__.inserting = false;\n  const delta = this.$__delta();\n  if (delta) {\n    if (delta instanceof MongooseError) {\n      callback(delta);\n      return;\n    }\n\n    const where = this.$__where(delta[0]);\n    if (where instanceof MongooseError) {\n      callback(where);\n      return;\n    }\n\n    _applyCustomWhere(this, where);\n\n    const update = delta[1];\n    if (this.$__schema.options.minimize) {\n      minimize(update);\n      // minimize might leave us with an empty object, which would\n      // lead to MongoDB throwing a \"Update document requires atomic operators\" error\n      if (Object.keys(update).length === 0) {\n        handleEmptyUpdate.call(this);\n        return;\n      }\n    }\n\n    this[modelCollectionSymbol].updateOne(where, update, saveOptions).then(\n      ret => {\n        ret.$where = where;\n        callback(null, ret);\n      },\n      err => {\n        this.$__undoReset();\n\n        callback(err);\n      }\n    );\n  } else {\n    handleEmptyUpdate.call(this);\n    return;\n  }\n\n  // store the modified paths before the document is reset\n  this.$__.modifiedPaths = this.modifiedPaths();\n  this.$__reset();\n\n  _setIsNew(this, false);\n\n  function handleEmptyUpdate() {\n    const optionsWithCustomValues = Object.assign({}, options, saveOptions);\n    const where = this.$__where();\n    const optimisticConcurrency = this.$__schema.options.optimisticConcurrency;\n    if (optimisticConcurrency && !Array.isArray(optimisticConcurrency)) {\n      const key = this.$__schema.options.versionKey;\n      const val = this.$__getValue(key);\n      if (val != null) {\n        where[key] = val;\n      }\n    }\n    this.constructor.collection.findOne(where, optionsWithCustomValues)\n      .then(documentExists => {\n        const matchedCount = !documentExists ? 0 : 1;\n        callback(null, { $where: where, matchedCount });\n      })\n      .catch(callback);\n  }\n};\n\n/*!\n * ignore\n */\n\nModel.prototype.$__save = function(options, callback) {\n  this.$__handleSave(options, (error, result) => {\n    if (error) {\n      const hooks = this.$__schema.s.hooks;\n      return hooks.execPost('save:error', this, [this], { error: error }, (error) => {\n        callback(error, this);\n      });\n    }\n    let numAffected = 0;\n    const writeConcern = options != null ?\n      options.writeConcern != null ?\n        options.writeConcern.w :\n        options.w :\n      0;\n    if (writeConcern !== 0) {\n      // Skip checking if write succeeded if writeConcern is set to\n      // unacknowledged writes, because otherwise `numAffected` will always be 0\n      if (result != null) {\n        if (Array.isArray(result)) {\n          numAffected = result.length;\n        } else if (result.matchedCount != null) {\n          numAffected = result.matchedCount;\n        } else {\n          numAffected = result;\n        }\n      }\n\n      const versionBump = this.$__.version;\n      // was this an update that required a version bump?\n      if (versionBump && !this.$__.inserting) {\n        const doIncrement = VERSION_INC === (VERSION_INC & this.$__.version);\n        this.$__.version = undefined;\n        const key = this.$__schema.options.versionKey;\n        const version = this.$__getValue(key) || 0;\n        if (numAffected <= 0) {\n          // the update failed. pass an error back\n          this.$__undoReset();\n          const err = this.$__.$versionError ||\n            new VersionError(this, version, this.$__.modifiedPaths);\n          return callback(err);\n        }\n\n        // increment version if was successful\n        if (doIncrement) {\n          this.$__setValue(key, version + 1);\n        }\n      }\n      if (result != null && numAffected <= 0) {\n        this.$__undoReset();\n        error = new DocumentNotFoundError(result.$where,\n          this.constructor.modelName, numAffected, result);\n        const hooks = this.$__schema.s.hooks;\n        return hooks.execPost('save:error', this, [this], { error: error }, (error) => {\n          callback(error, this);\n        });\n      }\n    }\n    this.$__.saving = undefined;\n    this.$__.savedState = {};\n    this.$emit('save', this, numAffected);\n    this.constructor.emit('save', this, numAffected);\n    callback(null, this);\n  });\n};\n\n/*!\n * ignore\n */\n\nfunction generateVersionError(doc, modifiedPaths) {\n  const key = doc.$__schema.options.versionKey;\n  if (!key) {\n    return null;\n  }\n  const version = doc.$__getValue(key) || 0;\n  return new VersionError(doc, version, modifiedPaths);\n}\n\n/**\n * Saves this document by inserting a new document into the database if [document.isNew](https://mongoosejs.com/docs/api/document.html#Document.prototype.isNew) is `true`,\n * or sends an [updateOne](https://mongoosejs.com/docs/api/document.html#Document.prototype.updateOne()) operation with just the modified paths if `isNew` is `false`.\n *\n * #### Example:\n *\n *     product.sold = Date.now();\n *     product = await product.save();\n *\n * If save is successful, the returned promise will fulfill with the document\n * saved.\n *\n * #### Example:\n *\n *     const newProduct = await product.save();\n *     newProduct === product; // true\n *\n * @param {Object} [options] options optional options\n * @param {Session} [options.session=null] the [session](https://www.mongodb.com/docs/manual/reference/server-sessions/) associated with this save operation. If not specified, defaults to the [document's associated session](https://mongoosejs.com/docs/api/document.html#Document.prototype.session()).\n * @param {Object} [options.safe] (DEPRECATED) overrides [schema's safe option](https://mongoosejs.com/docs/guide.html#safe). Use the `w` option instead.\n * @param {Boolean} [options.validateBeforeSave] set to false to save without validating.\n * @param {Boolean} [options.validateModifiedOnly=false] if `true`, Mongoose will only validate modified paths, as opposed to modified paths and `required` paths.\n * @param {Number|String} [options.w] set the [write concern](https://www.mongodb.com/docs/manual/reference/write-concern/#w-option). Overrides the [schema-level `writeConcern` option](https://mongoosejs.com/docs/guide.html#writeConcern)\n * @param {Boolean} [options.j] set to true for MongoDB to wait until this `save()` has been [journaled before resolving the returned promise](https://www.mongodb.com/docs/manual/reference/write-concern/#j-option). Overrides the [schema-level `writeConcern` option](https://mongoosejs.com/docs/guide.html#writeConcern)\n * @param {Number} [options.wtimeout] sets a [timeout for the write concern](https://www.mongodb.com/docs/manual/reference/write-concern/#wtimeout). Overrides the [schema-level `writeConcern` option](https://mongoosejs.com/docs/guide.html#writeConcern).\n * @param {Boolean} [options.checkKeys=true] the MongoDB driver prevents you from saving keys that start with '$' or contain '.' by default. Set this option to `false` to skip that check. See [restrictions on field names](https://docs.mongodb.com/manual/reference/limits/#mongodb-limit-Restrictions-on-Field-Names)\n * @param {Boolean} [options.timestamps=true] if `false` and [timestamps](https://mongoosejs.com/docs/guide.html#timestamps) are enabled, skip timestamps for this `save()`.\n * @throws {DocumentNotFoundError} if this [save updates an existing document](https://mongoosejs.com/docs/api/document.html#Document.prototype.isNew) but the document doesn't exist in the database. For example, you will get this error if the document is [deleted between when you retrieved the document and when you saved it](documents.html#updating).\n * @return {Promise}\n * @api public\n * @see middleware https://mongoosejs.com/docs/middleware.html\n */\n\nModel.prototype.save = async function save(options) {\n  if (typeof options === 'function' || typeof arguments[1] === 'function') {\n    throw new MongooseError('Model.prototype.save() no longer accepts a callback');\n  }\n\n  let parallelSave;\n  this.$op = 'save';\n\n  if (this.$__.saving) {\n    parallelSave = new ParallelSaveError(this);\n  } else {\n    this.$__.saving = new ParallelSaveError(this);\n  }\n\n  options = new SaveOptions(options);\n  if (options.hasOwnProperty('session')) {\n    this.$session(options.session);\n  }\n  if (this.$__.timestamps != null) {\n    options.timestamps = this.$__.timestamps;\n  }\n  this.$__.$versionError = generateVersionError(this, this.modifiedPaths());\n\n  if (parallelSave) {\n    this.$__handleReject(parallelSave);\n    throw parallelSave;\n  }\n\n  this.$__.saveOptions = options;\n\n  await new Promise((resolve, reject) => {\n    this.$__save(options, error => {\n      this.$__.saving = null;\n      this.$__.saveOptions = null;\n      this.$__.$versionError = null;\n      this.$op = null;\n      if (error != null) {\n        this.$__handleReject(error);\n        return reject(error);\n      }\n\n      resolve();\n    });\n  });\n\n  return this;\n};\n\nModel.prototype.$save = Model.prototype.save;\n\n/**\n * Determines whether versioning should be skipped for the given path\n *\n * @param {Document} self\n * @param {String} path\n * @return {Boolean} true if versioning should be skipped for the given path\n * @api private\n */\nfunction shouldSkipVersioning(self, path) {\n  const skipVersioning = self.$__schema.options.skipVersioning;\n  if (!skipVersioning) return false;\n\n  // Remove any array indexes from the path\n  path = path.replace(/\\.\\d+\\./, '.');\n\n  return skipVersioning[path];\n}\n\n/**\n * Apply the operation to the delta (update) clause as\n * well as track versioning for our where clause.\n *\n * @param {Document} self\n * @param {Object} where Unused\n * @param {Object} delta\n * @param {Object} data\n * @param {Mixed} val\n * @param {String} [op]\n * @api private\n */\n\nfunction operand(self, where, delta, data, val, op) {\n  // delta\n  op || (op = '$set');\n  if (!delta[op]) delta[op] = {};\n  delta[op][data.path] = val;\n  // disabled versioning?\n  if (self.$__schema.options.versionKey === false) return;\n\n  // path excluded from versioning?\n  if (shouldSkipVersioning(self, data.path)) return;\n\n  // already marked for versioning?\n  if (VERSION_ALL === (VERSION_ALL & self.$__.version)) return;\n\n  if (self.$__schema.options.optimisticConcurrency) {\n    return;\n  }\n\n  switch (op) {\n    case '$set':\n    case '$unset':\n    case '$pop':\n    case '$pull':\n    case '$pullAll':\n    case '$push':\n    case '$addToSet':\n    case '$inc':\n      break;\n    default:\n      // nothing to do\n      return;\n  }\n\n  // ensure updates sent with positional notation are\n  // editing the correct array element.\n  // only increment the version if an array position changes.\n  // modifying elements of an array is ok if position does not change.\n  if (op === '$push' || op === '$addToSet' || op === '$pullAll' || op === '$pull') {\n    if (/\\.\\d+\\.|\\.\\d+$/.test(data.path)) {\n      increment.call(self);\n    } else {\n      self.$__.version = VERSION_INC;\n    }\n  } else if (/^\\$p/.test(op)) {\n    // potentially changing array positions\n    increment.call(self);\n  } else if (Array.isArray(val)) {\n    // $set an array\n    increment.call(self);\n  } else if (/\\.\\d+\\.|\\.\\d+$/.test(data.path)) {\n    // now handling $set, $unset\n    // subpath of array\n    self.$__.version = VERSION_WHERE;\n  }\n}\n\n/**\n * Compiles an update and where clause for a `val` with _atomics.\n *\n * @param {Document} self\n * @param {Object} where\n * @param {Object} delta\n * @param {Object} data\n * @param {Array} value\n * @api private\n */\n\nfunction handleAtomics(self, where, delta, data, value) {\n  if (delta.$set && delta.$set[data.path]) {\n    // $set has precedence over other atomics\n    return;\n  }\n\n  if (typeof value.$__getAtomics === 'function') {\n    value.$__getAtomics().forEach(function(atomic) {\n      const op = atomic[0];\n      const val = atomic[1];\n      operand(self, where, delta, data, val, op);\n    });\n    return;\n  }\n\n  // legacy support for plugins\n\n  const atomics = value[arrayAtomicsSymbol];\n  const ops = Object.keys(atomics);\n  let i = ops.length;\n  let val;\n  let op;\n\n  if (i === 0) {\n    // $set\n\n    if (utils.isMongooseObject(value)) {\n      value = value.toObject({ depopulate: 1, _isNested: true });\n    } else if (value.valueOf) {\n      value = value.valueOf();\n    }\n\n    return operand(self, where, delta, data, value);\n  }\n\n  function iter(mem) {\n    return utils.isMongooseObject(mem)\n      ? mem.toObject({ depopulate: 1, _isNested: true })\n      : mem;\n  }\n\n  while (i--) {\n    op = ops[i];\n    val = atomics[op];\n\n    if (utils.isMongooseObject(val)) {\n      val = val.toObject({ depopulate: true, transform: false, _isNested: true });\n    } else if (Array.isArray(val)) {\n      val = val.map(iter);\n    } else if (val.valueOf) {\n      val = val.valueOf();\n    }\n\n    if (op === '$addToSet') {\n      val = { $each: val };\n    }\n\n    operand(self, where, delta, data, val, op);\n  }\n}\n\n/**\n * Produces a special query document of the modified properties used in updates.\n *\n * @api private\n * @method $__delta\n * @memberOf Model\n * @instance\n */\n\nModel.prototype.$__delta = function() {\n  const dirty = this.$__dirty();\n\n  const optimisticConcurrency = this.$__schema.options.optimisticConcurrency;\n  if (optimisticConcurrency) {\n    if (Array.isArray(optimisticConcurrency)) {\n      const optCon = new Set(optimisticConcurrency);\n      const modPaths = this.modifiedPaths();\n      if (modPaths.find(path => optCon.has(path))) {\n        this.$__.version = dirty.length ? VERSION_ALL : VERSION_WHERE;\n      }\n    } else {\n      this.$__.version = dirty.length ? VERSION_ALL : VERSION_WHERE;\n    }\n  }\n\n  if (!dirty.length && VERSION_ALL !== this.$__.version) {\n    return;\n  }\n  const where = {};\n  const delta = {};\n  const len = dirty.length;\n  const divergent = [];\n  let d = 0;\n\n  where._id = this._doc._id;\n  // If `_id` is an object, need to depopulate, but also need to be careful\n  // because `_id` can technically be null (see gh-6406)\n  if ((where && where._id && where._id.$__ || null) != null) {\n    where._id = where._id.toObject({ transform: false, depopulate: true });\n  }\n  for (; d < len; ++d) {\n    const data = dirty[d];\n    let value = data.value;\n    const match = checkDivergentArray(this, data.path, value);\n    if (match) {\n      divergent.push(match);\n      continue;\n    }\n\n    const pop = this.$populated(data.path, true);\n    if (!pop && this.$__.selected) {\n      // If any array was selected using an $elemMatch projection, we alter the path and where clause\n      // NOTE: MongoDB only supports projected $elemMatch on top level array.\n      const pathSplit = data.path.split('.');\n      const top = pathSplit[0];\n      if (this.$__.selected[top] && this.$__.selected[top].$elemMatch) {\n        // If the selected array entry was modified\n        if (pathSplit.length > 1 && pathSplit[1] == 0 && typeof where[top] === 'undefined') {\n          where[top] = this.$__.selected[top];\n          pathSplit[1] = '$';\n          data.path = pathSplit.join('.');\n        }\n        // if the selected array was modified in any other way throw an error\n        else {\n          divergent.push(data.path);\n          continue;\n        }\n      }\n    }\n\n    // If this path is set to default, and either this path or one of\n    // its parents is excluded, don't treat this path as dirty.\n    if (this.$isDefault(data.path) && this.$__.selected) {\n      if (data.path.indexOf('.') === -1 && isPathExcluded(this.$__.selected, data.path)) {\n        continue;\n      }\n\n      const pathsToCheck = parentPaths(data.path);\n      if (pathsToCheck.find(path => isPathExcluded(this.$__.isSelected, path))) {\n        continue;\n      }\n    }\n\n    if (divergent.length) continue;\n    if (value === undefined) {\n      operand(this, where, delta, data, 1, '$unset');\n    } else if (value === null) {\n      operand(this, where, delta, data, null);\n    } else if (utils.isMongooseArray(value) && value.$path() && value[arrayAtomicsSymbol]) {\n      // arrays and other custom types (support plugins etc)\n      handleAtomics(this, where, delta, data, value);\n    } else if (value[MongooseBuffer.pathSymbol] && Buffer.isBuffer(value)) {\n      // MongooseBuffer\n      value = value.toObject();\n      operand(this, where, delta, data, value);\n    } else {\n      if (this.$__.primitiveAtomics && this.$__.primitiveAtomics[data.path] != null) {\n        const val = this.$__.primitiveAtomics[data.path];\n        const op = firstKey(val);\n        operand(this, where, delta, data, val[op], op);\n      } else {\n        value = clone(value, {\n          depopulate: true,\n          transform: false,\n          virtuals: false,\n          getters: false,\n          omitUndefined: true,\n          _isNested: true\n        });\n        operand(this, where, delta, data, value);\n      }\n    }\n  }\n\n  if (divergent.length) {\n    return new DivergentArrayError(divergent);\n  }\n\n  if (this.$__.version) {\n    this.$__version(where, delta);\n  }\n\n  if (Object.keys(delta).length === 0) {\n    return [where, null];\n  }\n\n  return [where, delta];\n};\n\n/**\n * Determine if array was populated with some form of filter and is now\n * being updated in a manner which could overwrite data unintentionally.\n *\n * @see https://github.com/Automattic/mongoose/issues/1334\n * @param {Document} doc\n * @param {String} path\n * @param {Any} array\n * @return {String|undefined}\n * @api private\n */\n\nfunction checkDivergentArray(doc, path, array) {\n  // see if we populated this path\n  const pop = doc.$populated(path, true);\n\n  if (!pop && doc.$__.selected) {\n    // If any array was selected using an $elemMatch projection, we deny the update.\n    // NOTE: MongoDB only supports projected $elemMatch on top level array.\n    const top = path.split('.')[0];\n    if (doc.$__.selected[top + '.$']) {\n      return top;\n    }\n  }\n\n  if (!(pop && utils.isMongooseArray(array))) return;\n\n  // If the array was populated using options that prevented all\n  // documents from being returned (match, skip, limit) or they\n  // deselected the _id field, $pop and $set of the array are\n  // not safe operations. If _id was deselected, we do not know\n  // how to remove elements. $pop will pop off the _id from the end\n  // of the array in the db which is not guaranteed to be the\n  // same as the last element we have here. $set of the entire array\n  // would be similarly destructive as we never received all\n  // elements of the array and potentially would overwrite data.\n  const check = pop.options.match ||\n      pop.options.options && utils.object.hasOwnProperty(pop.options.options, 'limit') || // 0 is not permitted\n      pop.options.options && pop.options.options.skip || // 0 is permitted\n      pop.options.select && // deselected _id?\n      (pop.options.select._id === 0 ||\n      /\\s?-_id\\s?/.test(pop.options.select));\n\n  if (check) {\n    const atomics = array[arrayAtomicsSymbol];\n    if (Object.keys(atomics).length === 0 || atomics.$set || atomics.$pop) {\n      return path;\n    }\n  }\n}\n\n/**\n * Appends versioning to the where and update clauses.\n *\n * @api private\n * @method $__version\n * @memberOf Model\n * @instance\n */\n\nModel.prototype.$__version = function(where, delta) {\n  const key = this.$__schema.options.versionKey;\n  if (where === true) {\n    // this is an insert\n    if (key) {\n      setDottedPath(delta, key, 0);\n      this.$__setValue(key, 0);\n    }\n    return;\n  }\n\n  if (key === false) {\n    return;\n  }\n\n  // updates\n\n  // only apply versioning if our versionKey was selected. else\n  // there is no way to select the correct version. we could fail\n  // fast here and force them to include the versionKey but\n  // thats a bit intrusive. can we do this automatically?\n\n  if (!this.$__isSelected(key)) {\n    return;\n  }\n\n  // $push $addToSet don't need the where clause set\n  if (VERSION_WHERE === (VERSION_WHERE & this.$__.version)) {\n    const value = this.$__getValue(key);\n    if (value != null) where[key] = value;\n  }\n\n  if (VERSION_INC === (VERSION_INC & this.$__.version)) {\n    if (get(delta.$set, key, null) != null) {\n      // Version key is getting set, means we'll increment the doc's version\n      // after a successful save, so we should set the incremented version so\n      // future saves don't fail (gh-5779)\n      ++delta.$set[key];\n    } else {\n      delta.$inc = delta.$inc || {};\n      delta.$inc[key] = 1;\n    }\n  }\n};\n\n/*!\n * ignore\n */\n\nfunction increment() {\n  this.$__.version = VERSION_ALL;\n  return this;\n}\n\n/**\n * Signal that we desire an increment of this documents version.\n *\n * #### Example:\n *\n *     const doc = await Model.findById(id);\n *     doc.increment();\n *     await doc.save();\n *\n * @see versionKeys https://mongoosejs.com/docs/guide.html#versionKey\n * @memberOf Model\n * @method increment\n * @api public\n */\n\nModel.prototype.increment = increment;\n\n/**\n * Returns a query object\n *\n * @api private\n * @method $__where\n * @memberOf Model\n * @instance\n */\n\nModel.prototype.$__where = function _where(where) {\n  where || (where = {});\n\n  if (!where._id) {\n    where._id = this._doc._id;\n  }\n\n  if (this._doc._id === void 0) {\n    return new MongooseError('No _id found on document!');\n  }\n\n  return where;\n};\n\n/**\n * Delete this document from the db.\n *\n * #### Example:\n *\n *     await product.deleteOne();\n *     await Product.findById(product._id); // null\n *\n * @return {Query} Query\n * @api public\n */\n\nModel.prototype.deleteOne = function deleteOne(options) {\n  if (typeof options === 'function' ||\n      typeof arguments[1] === 'function') {\n    throw new MongooseError('Model.prototype.deleteOne() no longer accepts a callback');\n  }\n\n  if (!options) {\n    options = {};\n  }\n\n  if (options.hasOwnProperty('session')) {\n    this.$session(options.session);\n  }\n\n  const self = this;\n  const where = this.$__where();\n  if (where instanceof Error) {\n    throw where;\n  }\n  const query = self.constructor.deleteOne(where, options);\n\n  if (this.$session() != null) {\n    if (!('session' in query.options)) {\n      query.options.session = this.$session();\n    }\n  }\n\n  query.pre(function queryPreDeleteOne(cb) {\n    self.constructor._middleware.execPre('deleteOne', self, [self], cb);\n  });\n  query.pre(function callSubdocPreHooks(cb) {\n    each(self.$getAllSubdocs(), (subdoc, cb) => {\n      subdoc.constructor._middleware.execPre('deleteOne', subdoc, [subdoc], cb);\n    }, cb);\n  });\n  query.pre(function skipIfAlreadyDeleted(cb) {\n    if (self.$__.isDeleted) {\n      return cb(Kareem.skipWrappedFunction());\n    }\n    return cb();\n  });\n  query.post(function callSubdocPostHooks(cb) {\n    each(self.$getAllSubdocs(), (subdoc, cb) => {\n      subdoc.constructor._middleware.execPost('deleteOne', subdoc, [subdoc], {}, cb);\n    }, cb);\n  });\n  query.post(function queryPostDeleteOne(cb) {\n    self.constructor._middleware.execPost('deleteOne', self, [self], {}, cb);\n  });\n\n  return query;\n};\n\n/**\n * Returns the model instance used to create this document if no `name` specified.\n * If `name` specified, returns the model with the given `name`.\n *\n * #### Example:\n *\n *     const doc = new Tank({});\n *     doc.$model() === Tank; // true\n *     await doc.$model('User').findById(id);\n *\n * @param {String} [name] model name\n * @method $model\n * @api public\n * @return {Model}\n */\n\nModel.prototype.$model = function $model(name) {\n  if (arguments.length === 0) {\n    return this.constructor;\n  }\n  return this[modelDbSymbol].model(name);\n};\n\n/**\n * Returns the model instance used to create this document if no `name` specified.\n * If `name` specified, returns the model with the given `name`.\n *\n * #### Example:\n *\n *     const doc = new Tank({});\n *     doc.$model() === Tank; // true\n *     await doc.$model('User').findById(id);\n *\n * @param {String} [name] model name\n * @method model\n * @api public\n * @return {Model}\n */\n\nModel.prototype.model = Model.prototype.$model;\n\n/**\n * Returns a document with `_id` only if at least one document exists in the database that matches\n * the given `filter`, and `null` otherwise.\n *\n * Under the hood, `MyModel.exists({ answer: 42 })` is equivalent to\n * `MyModel.findOne({ answer: 42 }).select({ _id: 1 }).lean()`\n *\n * #### Example:\n *\n *     await Character.deleteMany({});\n *     await Character.create({ name: 'Jean-Luc Picard' });\n *\n *     await Character.exists({ name: /picard/i }); // { _id: ... }\n *     await Character.exists({ name: /riker/i }); // null\n *\n * This function triggers the following middleware.\n *\n * - `findOne()`\n *\n * @param {Object} filter\n * @param {Object} [options] optional see [`Query.prototype.setOptions()`](https://mongoosejs.com/docs/api/query.html#Query.prototype.setOptions())\n * @return {Query}\n */\n\nModel.exists = function exists(filter, options) {\n  _checkContext(this, 'exists');\n  if (typeof arguments[2] === 'function') {\n    throw new MongooseError('Model.exists() no longer accepts a callback');\n  }\n\n  const query = this.findOne(filter).\n    select({ _id: 1 }).\n    lean().\n    setOptions(options);\n\n  return query;\n};\n\n/**\n * Adds a discriminator type.\n *\n * #### Example:\n *\n *     function BaseSchema() {\n *       Schema.apply(this, arguments);\n *\n *       this.add({\n *         name: String,\n *         createdAt: Date\n *       });\n *     }\n *     util.inherits(BaseSchema, Schema);\n *\n *     const PersonSchema = new BaseSchema();\n *     const BossSchema = new BaseSchema({ department: String });\n *\n *     const Person = mongoose.model('Person', PersonSchema);\n *     const Boss = Person.discriminator('Boss', BossSchema);\n *     new Boss().__t; // \"Boss\". `__t` is the default `discriminatorKey`\n *\n *     const employeeSchema = new Schema({ boss: ObjectId });\n *     const Employee = Person.discriminator('Employee', employeeSchema, 'staff');\n *     new Employee().__t; // \"staff\" because of 3rd argument above\n *\n * @param {String} name discriminator model name\n * @param {Schema} schema discriminator model schema\n * @param {Object|String} [options] If string, same as `options.value`.\n * @param {String} [options.value] the string stored in the `discriminatorKey` property. If not specified, Mongoose uses the `name` parameter.\n * @param {Boolean} [options.clone=true] By default, `discriminator()` clones the given `schema`. Set to `false` to skip cloning.\n * @param {Boolean} [options.overwriteModels=false] by default, Mongoose does not allow you to define a discriminator with the same name as another discriminator. Set this to allow overwriting discriminators with the same name.\n * @param {Boolean} [options.mergeHooks=true] By default, Mongoose merges the base schema's hooks with the discriminator schema's hooks. Set this option to `false` to make Mongoose use the discriminator schema's hooks instead.\n * @param {Boolean} [options.mergePlugins=true] By default, Mongoose merges the base schema's plugins with the discriminator schema's plugins. Set this option to `false` to make Mongoose use the discriminator schema's plugins instead.\n * @return {Model} The newly created discriminator model\n * @api public\n */\n\nModel.discriminator = function(name, schema, options) {\n  let model;\n  if (typeof name === 'function') {\n    model = name;\n    name = utils.getFunctionName(model);\n    if (!(model.prototype instanceof Model)) {\n      throw new MongooseError('The provided class ' + name + ' must extend Model');\n    }\n  }\n\n  options = options || {};\n  const value = utils.isPOJO(options) ? options.value : options;\n  const clone = typeof options.clone === 'boolean' ? options.clone : true;\n  const mergePlugins = typeof options.mergePlugins === 'boolean' ? options.mergePlugins : true;\n\n  _checkContext(this, 'discriminator');\n\n  if (utils.isObject(schema) && !schema.instanceOfSchema) {\n    schema = new Schema(schema);\n  }\n  if (schema instanceof Schema && clone) {\n    schema = schema.clone();\n  }\n\n  schema = discriminator(this, name, schema, value, mergePlugins, options.mergeHooks);\n  if (this.db.models[name] && !schema.options.overwriteModels) {\n    throw new OverwriteModelError(name);\n  }\n\n  schema.$isRootDiscriminator = true;\n  schema.$globalPluginsApplied = true;\n\n  model = this.db.model(model || name, schema, this.$__collection.name);\n  this.discriminators[name] = model;\n  const d = this.discriminators[name];\n  Object.setPrototypeOf(d.prototype, this.prototype);\n  Object.defineProperty(d, 'baseModelName', {\n    value: this.modelName,\n    configurable: true,\n    writable: false\n  });\n\n  // apply methods and statics\n  applyMethods(d, schema);\n  applyStatics(d, schema);\n\n  if (this[subclassedSymbol] != null) {\n    for (const submodel of this[subclassedSymbol]) {\n      submodel.discriminators = submodel.discriminators || {};\n      submodel.discriminators[name] =\n        model.__subclass(model.db, schema, submodel.collection.name);\n    }\n  }\n\n  return d;\n};\n\n/**\n * Make sure `this` is a model\n * @api private\n */\n\nfunction _checkContext(ctx, fnName) {\n  // Check context, because it is easy to mistakenly type\n  // `new Model.discriminator()` and get an incomprehensible error\n  if (ctx == null || ctx === global) {\n    throw new MongooseError('`Model.' + fnName + '()` cannot run without a ' +\n      'model as `this`. Make sure you are calling `MyModel.' + fnName + '()` ' +\n      'where `MyModel` is a Mongoose model.');\n  } else if (ctx[modelSymbol] == null) {\n    throw new MongooseError('`Model.' + fnName + '()` cannot run without a ' +\n      'model as `this`. Make sure you are not calling ' +\n      '`new Model.' + fnName + '()`');\n  }\n}\n\n// Model (class) features\n\n/*!\n * Give the constructor the ability to emit events.\n */\n\nfor (const i in EventEmitter.prototype) {\n  Model[i] = EventEmitter.prototype[i];\n}\n\n/**\n * This function is responsible for building [indexes](https://www.mongodb.com/docs/manual/indexes/),\n * unless [`autoIndex`](https://mongoosejs.com/docs/guide.html#autoIndex) is turned off.\n *\n * Mongoose calls this function automatically when a model is created using\n * [`mongoose.model()`](https://mongoosejs.com/docs/api/mongoose.html#Mongoose.prototype.model()) or\n * [`connection.model()`](https://mongoosejs.com/docs/api/connection.html#Connection.prototype.model()), so you\n * don't need to call `init()` to trigger index builds.\n *\n * However, you _may_ need to call `init()`  to get back a promise that will resolve when your indexes are finished.\n * Calling `await Model.init()` is helpful if you need to wait for indexes to build before continuing.\n * For example, if you want to wait for unique indexes to build before continuing with a test case.\n *\n * #### Example:\n *\n *     const eventSchema = new Schema({ thing: { type: 'string', unique: true } })\n *     // This calls `Event.init()` implicitly, so you don't need to call\n *     // `Event.init()` on your own.\n *     const Event = mongoose.model('Event', eventSchema);\n *\n *     await Event.init();\n *     console.log('Indexes are done building!');\n *\n * @api public\n * @returns {Promise}\n */\n\nModel.init = function init() {\n  _checkContext(this, 'init');\n  if (typeof arguments[0] === 'function') {\n    throw new MongooseError('Model.init() no longer accepts a callback');\n  }\n\n  this.schema.emit('init', this);\n\n  if (this.$init != null) {\n    return this.$init;\n  }\n\n  const conn = this.db;\n  const _ensureIndexes = async() => {\n    const autoIndex = utils.getOption(\n      'autoIndex',\n      this.schema.options,\n      conn.config,\n      conn.base.options\n    );\n    if (!autoIndex) {\n      return;\n    }\n    return await this.ensureIndexes({ _automatic: true });\n  };\n  const _createCollection = async() => {\n    if ((conn.readyState === STATES.connecting || conn.readyState === STATES.disconnected) && conn._shouldBufferCommands()) {\n      await new Promise(resolve => {\n        conn._queue.push({ fn: resolve });\n      });\n    }\n    const autoCreate = utils.getOption(\n      'autoCreate',\n      this.schema.options,\n      conn.config,\n      conn.base.options\n    );\n    if (!autoCreate) {\n      return;\n    }\n    return await this.createCollection();\n  };\n\n  this.$init = _createCollection().then(() => _ensureIndexes());\n\n  const _catch = this.$init.catch;\n  const _this = this;\n  this.$init.catch = function() {\n    _this.$caught = true;\n    return _catch.apply(_this.$init, arguments);\n  };\n\n  return this.$init;\n};\n\n\n/**\n * Create the collection for this model. By default, if no indexes are specified,\n * mongoose will not create the collection for the model until any documents are\n * created. Use this method to create the collection explicitly.\n *\n * Note 1: You may need to call this before starting a transaction\n * See https://www.mongodb.com/docs/manual/core/transactions/#transactions-and-operations\n *\n * Note 2: You don't have to call this if your schema contains index or unique field.\n * In that case, just use `Model.init()`\n *\n * #### Example:\n *\n *     const userSchema = new Schema({ name: String })\n *     const User = mongoose.model('User', userSchema);\n *\n *     User.createCollection().then(function(collection) {\n *       console.log('Collection is created!');\n *     });\n *\n * @api public\n * @param {Object} [options] see [MongoDB driver docs](https://mongodb.github.io/node-mongodb-native/4.9/classes/Db.html#createCollection)\n * @returns {Promise}\n */\n\nModel.createCollection = async function createCollection(options) {\n  _checkContext(this, 'createCollection');\n  if (typeof arguments[0] === 'function' || typeof arguments[1] === 'function') {\n    throw new MongooseError('Model.createCollection() no longer accepts a callback');\n  }\n\n  const collectionOptions = this &&\n    this.schema &&\n    this.schema.options &&\n    this.schema.options.collectionOptions;\n  if (collectionOptions != null) {\n    options = Object.assign({}, collectionOptions, options);\n  }\n\n  const schemaCollation = this &&\n    this.schema &&\n    this.schema.options &&\n    this.schema.options.collation;\n  if (schemaCollation != null) {\n    options = Object.assign({ collation: schemaCollation }, options);\n  }\n  const capped = this &&\n    this.schema &&\n    this.schema.options &&\n    this.schema.options.capped;\n  if (capped != null) {\n    if (typeof capped === 'number') {\n      options = Object.assign({ capped: true, size: capped }, options);\n    } else if (typeof capped === 'object') {\n      options = Object.assign({ capped: true }, capped, options);\n    }\n  }\n  const timeseries = this &&\n    this.schema &&\n    this.schema.options &&\n    this.schema.options.timeseries;\n  if (timeseries != null) {\n    options = Object.assign({ timeseries }, options);\n    if (options.expireAfterSeconds != null) {\n      // do nothing\n    } else if (options.expires != null) {\n      utils.expires(options);\n    } else if (this.schema.options.expireAfterSeconds != null) {\n      options.expireAfterSeconds = this.schema.options.expireAfterSeconds;\n    } else if (this.schema.options.expires != null) {\n      options.expires = this.schema.options.expires;\n      utils.expires(options);\n    }\n  }\n\n  const clusteredIndex = this &&\n    this.schema &&\n    this.schema.options &&\n    this.schema.options.clusteredIndex;\n  if (clusteredIndex != null) {\n    options = Object.assign({ clusteredIndex: { ...clusteredIndex, unique: true } }, options);\n  }\n\n  try {\n    await this.db.createCollection(this.$__collection.collectionName, options);\n  } catch (err) {\n\n    if (err != null && (err.name !== 'MongoServerError' || err.code !== 48)) {\n      throw err;\n    }\n  }\n  return this.$__collection;\n};\n\n/**\n * Makes the indexes in MongoDB match the indexes defined in this model's\n * schema. This function will drop any indexes that are not defined in\n * the model's schema except the `_id` index, and build any indexes that\n * are in your schema but not in MongoDB.\n *\n * See the [introductory blog post](https://thecodebarbarian.com/whats-new-in-mongoose-5-2-syncindexes)\n * for more information.\n *\n * #### Example:\n *\n *     const schema = new Schema({ name: { type: String, unique: true } });\n *     const Customer = mongoose.model('Customer', schema);\n *     await Customer.collection.createIndex({ age: 1 }); // Index is not in schema\n *     // Will drop the 'age' index and create an index on `name`\n *     await Customer.syncIndexes();\n *\n * You should be careful about running `syncIndexes()` on production applications under heavy load,\n * because index builds are expensive operations, and unexpected index drops can lead to degraded\n * performance. Before running `syncIndexes()`, you can use the [`diffIndexes()` function](#Model.diffIndexes())\n * to check what indexes `syncIndexes()` will drop and create.\n *\n * #### Example:\n *\n *     const { toDrop, toCreate } = await Model.diffIndexes();\n *     toDrop; // Array of strings containing names of indexes that `syncIndexes()` will drop\n *     toCreate; // Array of strings containing names of indexes that `syncIndexes()` will create\n *\n * @param {Object} [options] options to pass to `ensureIndexes()`\n * @param {Boolean} [options.background=null] if specified, overrides each index's `background` property\n * @return {Promise}\n * @api public\n */\n\nModel.syncIndexes = async function syncIndexes(options) {\n  _checkContext(this, 'syncIndexes');\n  if (typeof arguments[0] === 'function' || typeof arguments[1] === 'function') {\n    throw new MongooseError('Model.syncIndexes() no longer accepts a callback');\n  }\n\n  const model = this;\n\n  try {\n    await model.createCollection();\n  } catch (err) {\n    if (err != null && (err.name !== 'MongoServerError' || err.code !== 48)) {\n      throw err;\n    }\n  }\n\n  const diffIndexesResult = await model.diffIndexes();\n  const dropped = await model.cleanIndexes({ ...options, toDrop: diffIndexesResult.toDrop });\n  await model.createIndexes({ ...options, toCreate: diffIndexesResult.toCreate });\n\n  return dropped;\n};\n\n/**\n * Does a dry-run of `Model.syncIndexes()`, returning the indexes that `syncIndexes()` would drop and create if you were to run `syncIndexes()`.\n *\n * #### Example:\n *\n *     const { toDrop, toCreate } = await Model.diffIndexes();\n *     toDrop; // Array of strings containing names of indexes that `syncIndexes()` will drop\n *     toCreate; // Array of strings containing names of indexes that `syncIndexes()` will create\n *\n * @param {Object} [options]\n * @return {Promise<Object>} contains the indexes that would be dropped in MongoDB and indexes that would be created in MongoDB as `{ toDrop: string[], toCreate: string[] }`.\n */\n\nModel.diffIndexes = async function diffIndexes() {\n  if (typeof arguments[0] === 'function' || typeof arguments[1] === 'function') {\n    throw new MongooseError('Model.syncIndexes() no longer accepts a callback');\n  }\n\n  const model = this;\n\n  let dbIndexes = await model.listIndexes().catch(err => {\n    if (err.codeName == 'NamespaceNotFound') {\n      return undefined;\n    }\n    throw err;\n  });\n  if (dbIndexes === undefined) {\n    dbIndexes = [];\n  }\n  dbIndexes = getRelatedDBIndexes(model, dbIndexes);\n\n  const schema = model.schema;\n  const schemaIndexes = getRelatedSchemaIndexes(model, schema.indexes());\n\n  const toDrop = getIndexesToDrop(schema, schemaIndexes, dbIndexes);\n  const toCreate = getIndexesToCreate(schema, schemaIndexes, dbIndexes, toDrop);\n\n  return { toDrop, toCreate };\n};\n\nfunction getIndexesToCreate(schema, schemaIndexes, dbIndexes, toDrop) {\n  const toCreate = [];\n\n  for (const [schemaIndexKeysObject, schemaIndexOptions] of schemaIndexes) {\n    let found = false;\n\n    const options = decorateDiscriminatorIndexOptions(schema, clone(schemaIndexOptions));\n\n    for (const index of dbIndexes) {\n      if (isDefaultIdIndex(index)) {\n        continue;\n      }\n      if (\n        isIndexEqual(schemaIndexKeysObject, options, index) &&\n        !toDrop.includes(index.name)\n      ) {\n        found = true;\n        break;\n      }\n    }\n\n    if (!found) {\n      toCreate.push(schemaIndexKeysObject);\n    }\n  }\n\n  return toCreate;\n}\n\nfunction getIndexesToDrop(schema, schemaIndexes, dbIndexes) {\n  const toDrop = [];\n\n  for (const dbIndex of dbIndexes) {\n    let found = false;\n    // Never try to drop `_id` index, MongoDB server doesn't allow it\n    if (isDefaultIdIndex(dbIndex)) {\n      continue;\n    }\n\n    for (const [schemaIndexKeysObject, schemaIndexOptions] of schemaIndexes) {\n      const options = decorateDiscriminatorIndexOptions(schema, clone(schemaIndexOptions));\n      applySchemaCollation(schemaIndexKeysObject, options, schema.options);\n\n      if (isIndexEqual(schemaIndexKeysObject, options, dbIndex)) {\n        found = true;\n        break;\n      }\n    }\n\n    if (!found) {\n      toDrop.push(dbIndex.name);\n    }\n  }\n\n  return toDrop;\n}\n/**\n * Deletes all indexes that aren't defined in this model's schema. Used by\n * `syncIndexes()`.\n *\n * The returned promise resolves to a list of the dropped indexes' names as an array\n *\n * @param {Function} [callback] optional callback\n * @return {Promise|undefined} Returns `undefined` if callback is specified, returns a promise if no callback.\n * @api public\n */\n\nModel.cleanIndexes = async function cleanIndexes(options) {\n  _checkContext(this, 'cleanIndexes');\n  if (typeof arguments[0] === 'function' || typeof arguments[1] === 'function') {\n    throw new MongooseError('Model.cleanIndexes() no longer accepts a callback');\n  }\n  const model = this;\n\n  const collection = model.$__collection;\n\n  if (Array.isArray(options && options.toDrop)) {\n    const res = await _dropIndexes(options.toDrop, collection);\n    return res;\n  }\n\n  const res = await model.diffIndexes();\n  return await _dropIndexes(res.toDrop, collection);\n};\n\nasync function _dropIndexes(toDrop, collection) {\n  if (toDrop.length === 0) {\n    return [];\n  }\n\n  await Promise.all(toDrop.map(indexName => collection.dropIndex(indexName)));\n  return toDrop;\n}\n\n/**\n * Lists the indexes currently defined in MongoDB. This may or may not be\n * the same as the indexes defined in your schema depending on whether you\n * use the [`autoIndex` option](https://mongoosejs.com/docs/guide.html#autoIndex) and if you\n * build indexes manually.\n *\n * @return {Promise}\n * @api public\n */\n\nModel.listIndexes = async function listIndexes() {\n  _checkContext(this, 'listIndexes');\n  if (typeof arguments[0] === 'function') {\n    throw new MongooseError('Model.listIndexes() no longer accepts a callback');\n  }\n\n  if (this.$__collection.buffer) {\n    await new Promise(resolve => {\n      this.$__collection.addQueue(resolve);\n    });\n  }\n\n  return this.$__collection.listIndexes().toArray();\n};\n\n/**\n * Sends `createIndex` commands to mongo for each index declared in the schema.\n * The `createIndex` commands are sent in series.\n *\n * #### Example:\n *\n *     Event.ensureIndexes(function (err) {\n *       if (err) return handleError(err);\n *     });\n *\n * After completion, an `index` event is emitted on this `Model` passing an error if one occurred.\n *\n * #### Example:\n *\n *     const eventSchema = new Schema({ thing: { type: 'string', unique: true } })\n *     const Event = mongoose.model('Event', eventSchema);\n *\n *     Event.on('index', function (err) {\n *       if (err) console.error(err); // error occurred during index creation\n *     })\n *\n * _NOTE: It is not recommended that you run this in production. Index creation may impact database performance depending on your load. Use with caution._\n *\n * @param {Object} [options] internal options\n * @return {Promise}\n * @api public\n */\n\nModel.ensureIndexes = async function ensureIndexes(options) {\n  _checkContext(this, 'ensureIndexes');\n  if (typeof arguments[0] === 'function' || typeof arguments[1] === 'function') {\n    throw new MongooseError('Model.ensureIndexes() no longer accepts a callback');\n  }\n\n  await new Promise((resolve, reject) => {\n    _ensureIndexes(this, options, (err) => {\n      if (err != null) {\n        return reject(err);\n      }\n      resolve();\n    });\n  });\n};\n\n/**\n * Similar to `ensureIndexes()`, except for it uses the [`createIndex`](https://mongodb.github.io/node-mongodb-native/4.9/classes/Db.html#createIndex)\n * function.\n *\n * @param {Object} [options] internal options\n * @return {Promise}\n * @api public\n */\n\nModel.createIndexes = async function createIndexes(options) {\n  _checkContext(this, 'createIndexes');\n\n  if (typeof arguments[0] === 'function' || typeof arguments[1] === 'function') {\n    throw new MongooseError('Model.createIndexes() no longer accepts a callback');\n  }\n\n  return this.ensureIndexes(options);\n};\n\n\n/*!\n * ignore\n */\n\nfunction _ensureIndexes(model, options, callback) {\n  const indexes = model.schema.indexes();\n  let indexError;\n\n  options = options || {};\n  const done = function(err) {\n    if (err && !model.$caught) {\n      model.emit('error', err);\n    }\n    model.emit('index', err || indexError);\n    callback && callback(err || indexError);\n  };\n\n  for (const index of indexes) {\n    if (isDefaultIdIndex(index)) {\n      utils.warn('mongoose: Cannot specify a custom index on `_id` for ' +\n        'model name \"' + model.modelName + '\", ' +\n        'MongoDB does not allow overwriting the default `_id` index. See ' +\n        'https://bit.ly/mongodb-id-index');\n    }\n  }\n\n  if (!indexes.length) {\n    immediate(function() {\n      done();\n    });\n    return;\n  }\n  // Indexes are created one-by-one to support how MongoDB < 2.4 deals\n  // with background indexes.\n\n  const indexSingleDone = function(err, fields, options, name) {\n    model.emit('index-single-done', err, fields, options, name);\n  };\n  const indexSingleStart = function(fields, options) {\n    model.emit('index-single-start', fields, options);\n  };\n\n  const baseSchema = model.schema._baseSchema;\n  const baseSchemaIndexes = baseSchema ? baseSchema.indexes() : [];\n\n  immediate(function() {\n    // If buffering is off, do this manually.\n    if (options._automatic && !model.collection.collection) {\n      model.collection.addQueue(create, []);\n    } else {\n      create();\n    }\n  });\n\n\n  function create() {\n    if (options._automatic) {\n      if (model.schema.options.autoIndex === false ||\n          (model.schema.options.autoIndex == null && model.db.config.autoIndex === false)) {\n        return done();\n      }\n    }\n\n    const index = indexes.shift();\n    if (!index) {\n      return done();\n    }\n    if (options._automatic && index[1]._autoIndex === false) {\n      return create();\n    }\n\n    if (baseSchemaIndexes.find(i => utils.deepEqual(i, index))) {\n      return create();\n    }\n\n    const indexFields = clone(index[0]);\n    const indexOptions = clone(index[1]);\n\n    delete indexOptions._autoIndex;\n    decorateDiscriminatorIndexOptions(model.schema, indexOptions);\n    applyWriteConcern(model.schema, indexOptions);\n    applySchemaCollation(indexFields, indexOptions, model.schema.options);\n\n    indexSingleStart(indexFields, options);\n\n    if ('background' in options) {\n      indexOptions.background = options.background;\n    }\n\n    if ('toCreate' in options) {\n      if (options.toCreate.length === 0) {\n        return done();\n      }\n    }\n\n    model.collection.createIndex(indexFields, indexOptions).then(\n      name => {\n        indexSingleDone(null, indexFields, indexOptions, name);\n        create();\n      },\n      err => {\n        if (!indexError) {\n          indexError = err;\n        }\n        if (!model.$caught) {\n          model.emit('error', err);\n        }\n\n        indexSingleDone(err, indexFields, indexOptions);\n        create();\n      }\n    );\n  }\n}\n\n/**\n * Schema the model uses.\n *\n * @property schema\n * @static\n * @api public\n * @memberOf Model\n */\n\nModel.schema;\n\n/**\n * Connection instance the model uses.\n *\n * @property db\n * @static\n * @api public\n * @memberOf Model\n */\n\nModel.db;\n\n/**\n * Collection the model uses.\n *\n * @property collection\n * @api public\n * @memberOf Model\n */\n\nModel.collection;\n\n/**\n * Internal collection the model uses.\n *\n * @property collection\n * @api private\n * @memberOf Model\n */\nModel.$__collection;\n\n/**\n * Base Mongoose instance the model uses.\n *\n * @property base\n * @api public\n * @memberOf Model\n */\n\nModel.base;\n\n/**\n * Registered discriminators for this model.\n *\n * @property discriminators\n * @api public\n * @memberOf Model\n */\n\nModel.discriminators;\n\n/**\n * Translate any aliases fields/conditions so the final query or document object is pure\n *\n * #### Example:\n *\n *     await Character.find(Character.translateAliases({\n *        '': 'Eddard Stark' // Alias for 'name'\n *     });\n *\n * By default, `translateAliases()` overwrites raw fields with aliased fields.\n * So if `n` is an alias for `name`, `{ n: 'alias', name: 'raw' }` will resolve to `{ name: 'alias' }`.\n * However, you can set the `errorOnDuplicates` option to throw an error if there are potentially conflicting paths.\n * The `translateAliases` option for queries uses `errorOnDuplicates`.\n *\n * #### Note:\n *\n * Only translate arguments of object type anything else is returned raw\n *\n * @param {Object} fields fields/conditions that may contain aliased keys\n * @param {Boolean} [errorOnDuplicates] if true, throw an error if there's both a key and an alias for that key in `fields`\n * @return {Object} the translated 'pure' fields/conditions\n */\nModel.translateAliases = function translateAliases(fields, errorOnDuplicates) {\n  _checkContext(this, 'translateAliases');\n\n  const translate = (key, value) => {\n    let alias;\n    const translated = [];\n    const fieldKeys = key.split('.');\n    let currentSchema = this.schema;\n    for (const i in fieldKeys) {\n      const name = fieldKeys[i];\n      if (currentSchema && currentSchema.aliases[name]) {\n        alias = currentSchema.aliases[name];\n        if (errorOnDuplicates && alias in fields) {\n          throw new MongooseError(`Provided object has both field \"${name}\" and its alias \"${alias}\"`);\n        }\n        // Alias found,\n        translated.push(alias);\n      } else {\n        alias = name;\n        // Alias not found, so treat as un-aliased key\n        translated.push(name);\n      }\n\n      // Check if aliased path is a schema\n      if (currentSchema && currentSchema.paths[alias]) {\n        currentSchema = currentSchema.paths[alias].schema;\n      }\n      else\n        currentSchema = null;\n    }\n\n    const translatedKey = translated.join('.');\n    if (fields instanceof Map)\n      fields.set(translatedKey, value);\n    else\n      fields[translatedKey] = value;\n\n    if (translatedKey !== key) {\n      // We'll be using the translated key instead\n      if (fields instanceof Map) {\n        // Delete from map\n        fields.delete(key);\n      } else {\n        // Delete from object\n        delete fields[key]; // We'll be using the translated key instead\n      }\n    }\n    return fields;\n  };\n\n  if (typeof fields === 'object') {\n    // Fields is an object (query conditions or document fields)\n    if (fields instanceof Map) {\n      // A Map was supplied\n      for (const field of new Map(fields)) {\n        fields = translate(field[0], field[1]);\n      }\n    } else {\n      // Infer a regular object was supplied\n      for (const key of Object.keys(fields)) {\n        fields = translate(key, fields[key]);\n        if (key[0] === '$') {\n          if (Array.isArray(fields[key])) {\n            for (const i in fields[key]) {\n              // Recursively translate nested queries\n              fields[key][i] = this.translateAliases(fields[key][i]);\n            }\n          } else {\n            this.translateAliases(fields[key]);\n          }\n        }\n      }\n    }\n\n    return fields;\n  } else {\n    // Don't know typeof fields\n    return fields;\n  }\n};\n\n/**\n * Deletes the first document that matches `conditions` from the collection.\n * It returns an object with the property `deletedCount` indicating how many documents were deleted.\n * Behaves like `remove()`, but deletes at most one document regardless of the\n * `single` option.\n *\n * #### Example:\n *\n *     await Character.deleteOne({ name: 'Eddard Stark' }); // returns {deletedCount: 1}\n *\n * #### Note:\n *\n * This function triggers `deleteOne` query hooks. Read the\n * [middleware docs](https://mongoosejs.com/docs/middleware.html#naming) to learn more.\n *\n * @param {Object} conditions\n * @param {Object} [options] optional see [`Query.prototype.setOptions()`](https://mongoosejs.com/docs/api/query.html#Query.prototype.setOptions())\n * @param {Boolean} [options.translateAliases=null] If set to `true`, translates any schema-defined aliases in `filter`, `projection`, `update`, and `distinct`. Throws an error if there are any conflicts where both alias and raw property are defined on the same object.\n * @return {Query}\n * @api public\n */\n\nModel.deleteOne = function deleteOne(conditions, options) {\n  _checkContext(this, 'deleteOne');\n\n  if (typeof arguments[0] === 'function' || typeof arguments[1] === 'function' || typeof arguments[2] === 'function') {\n    throw new MongooseError('Model.prototype.deleteOne() no longer accepts a callback');\n  }\n\n  const mq = new this.Query({}, {}, this, this.$__collection);\n  mq.setOptions(options);\n\n  return mq.deleteOne(conditions);\n};\n\n/**\n * Deletes all of the documents that match `conditions` from the collection.\n * It returns an object with the property `deletedCount` containing the number of documents deleted.\n * Behaves like `remove()`, but deletes all documents that match `conditions`\n * regardless of the `single` option.\n *\n * #### Example:\n *\n *     await Character.deleteMany({ name: /Stark/, age: { $gte: 18 } }); // returns {deletedCount: x} where x is the number of documents deleted.\n *\n * #### Note:\n *\n * This function triggers `deleteMany` query hooks. Read the\n * [middleware docs](https://mongoosejs.com/docs/middleware.html#naming) to learn more.\n *\n * @param {Object} conditions\n * @param {Object} [options] optional see [`Query.prototype.setOptions()`](https://mongoosejs.com/docs/api/query.html#Query.prototype.setOptions())\n * @param {Boolean} [options.translateAliases=null] If set to `true`, translates any schema-defined aliases in `filter`, `projection`, `update`, and `distinct`. Throws an error if there are any conflicts where both alias and raw property are defined on the same object.\n * @return {Query}\n * @api public\n */\n\nModel.deleteMany = function deleteMany(conditions, options) {\n  _checkContext(this, 'deleteMany');\n\n  if (typeof arguments[0] === 'function' || typeof arguments[1] === 'function' || typeof arguments[2] === 'function') {\n    throw new MongooseError('Model.deleteMany() no longer accepts a callback');\n  }\n\n  const mq = new this.Query({}, {}, this, this.$__collection);\n  mq.setOptions(options);\n\n  return mq.deleteMany(conditions);\n};\n\n/**\n * Finds documents.\n *\n * Mongoose casts the `filter` to match the model's schema before the command is sent.\n * See our [query casting tutorial](https://mongoosejs.com/docs/tutorials/query_casting.html) for\n * more information on how Mongoose casts `filter`.\n *\n * #### Example:\n *\n *     // find all documents\n *     await MyModel.find({});\n *\n *     // find all documents named john and at least 18\n *     await MyModel.find({ name: 'john', age: { $gte: 18 } }).exec();\n *\n *     // executes, name LIKE john and only selecting the \"name\" and \"friends\" fields\n *     await MyModel.find({ name: /john/i }, 'name friends').exec();\n *\n *     // passing options\n *     await MyModel.find({ name: /john/i }, null, { skip: 10 }).exec();\n *\n * @param {Object|ObjectId} filter\n * @param {Object|String|String[]} [projection] optional fields to return, see [`Query.prototype.select()`](https://mongoosejs.com/docs/api/query.html#Query.prototype.select())\n * @param {Object} [options] optional see [`Query.prototype.setOptions()`](https://mongoosejs.com/docs/api/query.html#Query.prototype.setOptions())\n * @param {Boolean} [options.translateAliases=null] If set to `true`, translates any schema-defined aliases in `filter`, `projection`, `update`, and `distinct`. Throws an error if there are any conflicts where both alias and raw property are defined on the same object.\n * @return {Query}\n * @see field selection https://mongoosejs.com/docs/api/query.html#Query.prototype.select()\n * @see query casting https://mongoosejs.com/docs/tutorials/query_casting.html\n * @api public\n */\n\nModel.find = function find(conditions, projection, options) {\n  _checkContext(this, 'find');\n  if (typeof arguments[0] === 'function' || typeof arguments[1] === 'function' || typeof arguments[2] === 'function' || typeof arguments[3] === 'function') {\n    throw new MongooseError('Model.find() no longer accepts a callback');\n  }\n\n  const mq = new this.Query({}, {}, this, this.$__collection);\n  mq.select(projection);\n  mq.setOptions(options);\n\n  return mq.find(conditions);\n};\n\n/**\n * Finds a single document by its _id field. `findById(id)` is almost*\n * equivalent to `findOne({ _id: id })`. If you want to query by a document's\n * `_id`, use `findById()` instead of `findOne()`.\n *\n * The `id` is cast based on the Schema before sending the command.\n *\n * This function triggers the following middleware.\n *\n * - `findOne()`\n *\n * \\* Except for how it treats `undefined`. If you use `findOne()`, you'll see\n * that `findOne(undefined)` and `findOne({ _id: undefined })` are equivalent\n * to `findOne({})` and return arbitrary documents. However, mongoose\n * translates `findById(undefined)` into `findOne({ _id: null })`.\n *\n * #### Example:\n *\n *     // Find the adventure with the given `id`, or `null` if not found\n *     await Adventure.findById(id).exec();\n *\n *     // select only the adventures name and length\n *     await Adventure.findById(id, 'name length').exec();\n *\n * @param {Any} id value of `_id` to query by\n * @param {Object|String|String[]} [projection] optional fields to return, see [`Query.prototype.select()`](https://mongoosejs.com/docs/api/query.html#Query.prototype.select())\n * @param {Object} [options] optional see [`Query.prototype.setOptions()`](https://mongoosejs.com/docs/api/query.html#Query.prototype.setOptions())\n * @return {Query}\n * @see field selection https://mongoosejs.com/docs/api/query.html#Query.prototype.select()\n * @see lean queries https://mongoosejs.com/docs/tutorials/lean.html\n * @see findById in Mongoose https://masteringjs.io/tutorials/mongoose/find-by-id\n * @api public\n */\n\nModel.findById = function findById(id, projection, options) {\n  _checkContext(this, 'findById');\n  if (typeof arguments[0] === 'function' || typeof arguments[1] === 'function' || typeof arguments[2] === 'function') {\n    throw new MongooseError('Model.findById() no longer accepts a callback');\n  }\n\n  if (typeof id === 'undefined') {\n    id = null;\n  }\n\n  return this.findOne({ _id: id }, projection, options);\n};\n\n/**\n * Finds one document.\n *\n * The `conditions` are cast to their respective SchemaTypes before the command is sent.\n *\n * *Note:* `conditions` is optional, and if `conditions` is null or undefined,\n * mongoose will send an empty `findOne` command to MongoDB, which will return\n * an arbitrary document. If you're querying by `_id`, use `findById()` instead.\n *\n * #### Example:\n *\n *     // Find one adventure whose `country` is 'Croatia', otherwise `null`\n *     await Adventure.findOne({ country: 'Croatia' }).exec();\n *\n *     // Model.findOne() no longer accepts a callback\n *\n *     // Select only the adventures name and length\n *     await Adventure.findOne({ country: 'Croatia' }, 'name length').exec();\n *\n * @param {Object} [conditions]\n * @param {Object|String|String[]} [projection] optional fields to return, see [`Query.prototype.select()`](https://mongoosejs.com/docs/api/query.html#Query.prototype.select())\n * @param {Object} [options] optional see [`Query.prototype.setOptions()`](https://mongoosejs.com/docs/api/query.html#Query.prototype.setOptions())\n * @param {Boolean} [options.translateAliases=null] If set to `true`, translates any schema-defined aliases in `filter`, `projection`, `update`, and `distinct`. Throws an error if there are any conflicts where both alias and raw property are defined on the same object.\n * @return {Query}\n * @see field selection https://mongoosejs.com/docs/api/query.html#Query.prototype.select()\n * @see lean queries https://mongoosejs.com/docs/tutorials/lean.html\n * @api public\n */\n\nModel.findOne = function findOne(conditions, projection, options) {\n  _checkContext(this, 'findOne');\n  if (typeof arguments[0] === 'function' || typeof arguments[1] === 'function' || typeof arguments[2] === 'function') {\n    throw new MongooseError('Model.findOne() no longer accepts a callback');\n  }\n\n  const mq = new this.Query({}, {}, this, this.$__collection);\n  mq.select(projection);\n  mq.setOptions(options);\n\n  return mq.findOne(conditions);\n};\n\n/**\n * Estimates the number of documents in the MongoDB collection. Faster than\n * using `countDocuments()` for large collections because\n * `estimatedDocumentCount()` uses collection metadata rather than scanning\n * the entire collection.\n *\n * #### Example:\n *\n *     const numAdventures = await Adventure.estimatedDocumentCount();\n *\n * @param {Object} [options]\n * @return {Query}\n * @api public\n */\n\nModel.estimatedDocumentCount = function estimatedDocumentCount(options) {\n  _checkContext(this, 'estimatedDocumentCount');\n\n  const mq = new this.Query({}, {}, this, this.$__collection);\n\n  return mq.estimatedDocumentCount(options);\n};\n\n/**\n * Counts number of documents matching `filter` in a database collection.\n *\n * #### Example:\n *\n *     Adventure.countDocuments({ type: 'jungle' }, function (err, count) {\n *       console.log('there are %d jungle adventures', count);\n *     });\n *\n * If you want to count all documents in a large collection,\n * use the [`estimatedDocumentCount()` function](https://mongoosejs.com/docs/api/model.html#Model.estimatedDocumentCount())\n * instead. If you call `countDocuments({})`, MongoDB will always execute\n * a full collection scan and **not** use any indexes.\n *\n * The `countDocuments()` function is similar to `count()`, but there are a\n * [few operators that `countDocuments()` does not support](https://mongodb.github.io/node-mongodb-native/4.9/classes/Collection.html#countDocuments).\n * Below are the operators that `count()` supports but `countDocuments()` does not,\n * and the suggested replacement:\n *\n * - `$where`: [`$expr`](https://www.mongodb.com/docs/manual/reference/operator/query/expr/)\n * - `$near`: [`$geoWithin`](https://www.mongodb.com/docs/manual/reference/operator/query/geoWithin/) with [`$center`](https://www.mongodb.com/docs/manual/reference/operator/query/center/#op._S_center)\n * - `$nearSphere`: [`$geoWithin`](https://www.mongodb.com/docs/manual/reference/operator/query/geoWithin/) with [`$centerSphere`](https://www.mongodb.com/docs/manual/reference/operator/query/centerSphere/#op._S_centerSphere)\n *\n * @param {Object} filter\n * @return {Query}\n * @api public\n */\n\nModel.countDocuments = function countDocuments(conditions, options) {\n  _checkContext(this, 'countDocuments');\n  if (typeof arguments[0] === 'function' || typeof arguments[1] === 'function' || typeof arguments[2] === 'function') {\n    throw new MongooseError('Model.countDocuments() no longer accepts a callback');\n  }\n\n  const mq = new this.Query({}, {}, this, this.$__collection);\n  if (options != null) {\n    mq.setOptions(options);\n  }\n\n  return mq.countDocuments(conditions);\n};\n\n\n/**\n * Creates a Query for a `distinct` operation.\n *\n * #### Example:\n *\n *     const query = Link.distinct('url');\n *     query.exec();\n *\n * @param {String} field\n * @param {Object} [conditions] optional\n * @return {Query}\n * @api public\n */\n\nModel.distinct = function distinct(field, conditions) {\n  _checkContext(this, 'distinct');\n  if (typeof arguments[0] === 'function' || typeof arguments[1] === 'function') {\n    throw new MongooseError('Model.distinct() no longer accepts a callback');\n  }\n\n  const mq = new this.Query({}, {}, this, this.$__collection);\n\n  return mq.distinct(field, conditions);\n};\n\n/**\n * Creates a Query, applies the passed conditions, and returns the Query.\n *\n * For example, instead of writing:\n *\n *     User.find({ age: { $gte: 21, $lte: 65 } });\n *\n * we can instead write:\n *\n *     User.where('age').gte(21).lte(65).exec();\n *\n * Since the Query class also supports `where` you can continue chaining\n *\n *     User\n *     .where('age').gte(21).lte(65)\n *     .where('name', /^b/i)\n *     ... etc\n *\n * @param {String} path\n * @param {Object} [val] optional value\n * @return {Query}\n * @api public\n */\n\nModel.where = function where(path, val) {\n  _checkContext(this, 'where');\n\n  void val; // eslint\n  const mq = new this.Query({}, {}, this, this.$__collection).find({});\n  return mq.where.apply(mq, arguments);\n};\n\n/**\n * Creates a `Query` and specifies a `$where` condition.\n *\n * Sometimes you need to query for things in mongodb using a JavaScript expression. You can do so via `find({ $where: javascript })`, or you can use the mongoose shortcut method $where via a Query chain or from your mongoose Model.\n *\n *     Blog.$where('this.username.indexOf(\"val\") !== -1').exec(function (err, docs) {});\n *\n * @param {String|Function} argument is a javascript string or anonymous function\n * @method $where\n * @memberOf Model\n * @return {Query}\n * @see Query.$where https://mongoosejs.com/docs/api/query.html#Query.prototype.$where\n * @api public\n */\n\nModel.$where = function $where() {\n  _checkContext(this, '$where');\n\n  const mq = new this.Query({}, {}, this, this.$__collection).find({});\n  return mq.$where.apply(mq, arguments);\n};\n\n/**\n * Issues a mongodb findOneAndUpdate command.\n *\n * Finds a matching document, updates it according to the `update` arg, passing any `options`, and returns the found document (if any) to the callback. The query executes if `callback` is passed else a Query object is returned.\n *\n * #### Example:\n *\n *     A.findOneAndUpdate(conditions, update, options)  // returns Query\n *     A.findOneAndUpdate(conditions, update)           // returns Query\n *     A.findOneAndUpdate()                             // returns Query\n *\n * #### Note:\n *\n * All top level update keys which are not `atomic` operation names are treated as set operations:\n *\n * #### Example:\n *\n *     const query = { name: 'borne' };\n *     Model.findOneAndUpdate(query, { name: 'jason bourne' }, options)\n *\n *     // is sent as\n *     Model.findOneAndUpdate(query, { $set: { name: 'jason bourne' }}, options)\n *\n * #### Note:\n *\n * `findOneAndX` and `findByIdAndX` functions support limited validation that\n * you can enable by setting the `runValidators` option.\n *\n * If you need full-fledged validation, use the traditional approach of first\n * retrieving the document.\n *\n *     const doc = await Model.findById(id);\n *     doc.name = 'jason bourne';\n *     await doc.save();\n *\n * @param {Object} [conditions]\n * @param {Object} [update]\n * @param {Object} [options] optional see [`Query.prototype.setOptions()`](https://mongoosejs.com/docs/api/query.html#Query.prototype.setOptions())\n * @param {String} [options.returnDocument='before'] Has two possible values, `'before'` and `'after'`. By default, it will return the document before the update was applied.\n * @param {Object} [options.lean] if truthy, mongoose will return the document as a plain JavaScript object rather than a mongoose document. See [`Query.lean()`](https://mongoosejs.com/docs/api/query.html#Query.prototype.lean()) and [the Mongoose lean tutorial](https://mongoosejs.com/docs/tutorials/lean.html).\n * @param {ClientSession} [options.session=null] The session associated with this query. See [transactions docs](https://mongoosejs.com/docs/transactions.html).\n * @param {Boolean|String} [options.strict] overwrites the schema's [strict mode option](https://mongoosejs.com/docs/guide.html#strict)\n * @param {Boolean} [options.timestamps=null] If set to `false` and [schema-level timestamps](https://mongoosejs.com/docs/guide.html#timestamps) are enabled, skip timestamps for this update. Note that this allows you to overwrite timestamps. Does nothing if schema-level timestamps are not set.\n * @param {Boolean} [options.upsert=false] if true, and no documents found, insert a new document\n * @param {Object|String|String[]} [options.projection=null] optional fields to return, see [`Query.prototype.select()`](https://mongoosejs.com/docs/api/query.html#Query.prototype.select())\n * @param {Boolean} [options.new=false] if true, return the modified document rather than the original\n * @param {Object|String} [options.fields] Field selection. Equivalent to `.select(fields).findOneAndUpdate()`\n * @param {Number} [options.maxTimeMS] puts a time limit on the query - requires mongodb >= 2.6.0\n * @param {Object|String} [options.sort] if multiple docs are found by the conditions, sets the sort order to choose which doc to update.\n * @param {Boolean} [options.runValidators] if true, runs [update validators](https://mongoosejs.com/docs/validation.html#update-validators) on this command. Update validators validate the update operation against the model's schema\n * @param {Boolean} [options.setDefaultsOnInsert=true] If `setDefaultsOnInsert` and `upsert` are true, mongoose will apply the [defaults](https://mongoosejs.com/docs/defaults.html) specified in the model's schema if a new document is created\n * @param {Boolean} [options.includeResultMetadata] if true, returns the [raw result from the MongoDB driver](https://mongodb.github.io/node-mongodb-native/4.9/interfaces/ModifyResult.html)\n * @param {Boolean} [options.translateAliases=null] If set to `true`, translates any schema-defined aliases in `filter`, `projection`, `update`, and `distinct`. Throws an error if there are any conflicts where both alias and raw property are defined on the same object.\n * @return {Query}\n * @see Tutorial https://mongoosejs.com/docs/tutorials/findoneandupdate.html\n * @see mongodb https://www.mongodb.com/docs/manual/reference/command/findAndModify/\n * @api public\n */\n\nModel.findOneAndUpdate = function(conditions, update, options) {\n  _checkContext(this, 'findOneAndUpdate');\n  if (typeof arguments[0] === 'function' || typeof arguments[1] === 'function' || typeof arguments[2] === 'function' || typeof arguments[3] === 'function') {\n    throw new MongooseError('Model.findOneAndUpdate() no longer accepts a callback');\n  }\n\n  if (arguments.length === 1) {\n    update = conditions;\n    conditions = null;\n    options = null;\n  }\n\n  let fields;\n  if (options) {\n    fields = options.fields || options.projection;\n  }\n\n  update = clone(update, {\n    depopulate: true,\n    _isNested: true\n  });\n\n  decorateUpdateWithVersionKey(update, options, this.schema.options.versionKey);\n\n  const mq = new this.Query({}, {}, this, this.$__collection);\n  mq.select(fields);\n\n  return mq.findOneAndUpdate(conditions, update, options);\n};\n\n/**\n * Issues a mongodb findOneAndUpdate command by a document's _id field.\n * `findByIdAndUpdate(id, ...)` is equivalent to `findOneAndUpdate({ _id: id }, ...)`.\n *\n * Finds a matching document, updates it according to the `update` arg,\n * passing any `options`, and returns the found document (if any).\n *\n * This function triggers the following middleware.\n *\n * - `findOneAndUpdate()`\n *\n * #### Example:\n *\n *     A.findByIdAndUpdate(id, update, options)  // returns Query\n *     A.findByIdAndUpdate(id, update)           // returns Query\n *     A.findByIdAndUpdate()                     // returns Query\n *\n * #### Note:\n *\n * All top level update keys which are not `atomic` operation names are treated as set operations:\n *\n * #### Example:\n *\n *     Model.findByIdAndUpdate(id, { name: 'jason bourne' }, options)\n *\n *     // is sent as\n *     Model.findByIdAndUpdate(id, { $set: { name: 'jason bourne' }}, options)\n *\n * #### Note:\n *\n * `findOneAndX` and `findByIdAndX` functions support limited validation. You can\n * enable validation by setting the `runValidators` option.\n *\n * If you need full-fledged validation, use the traditional approach of first\n * retrieving the document.\n *\n *     const doc = await Model.findById(id)\n *     doc.name = 'jason bourne';\n *     await doc.save();\n *\n * @param {Object|Number|String} id value of `_id` to query by\n * @param {Object} [update]\n * @param {Object} [options] optional see [`Query.prototype.setOptions()`](https://mongoosejs.com/docs/api/query.html#Query.prototype.setOptions())\n * @param {String} [options.returnDocument='before'] Has two possible values, `'before'` and `'after'`. By default, it will return the document before the update was applied.\n * @param {Object} [options.lean] if truthy, mongoose will return the document as a plain JavaScript object rather than a mongoose document. See [`Query.lean()`](https://mongoosejs.com/docs/api/query.html#Query.prototype.lean()) and [the Mongoose lean tutorial](https://mongoosejs.com/docs/tutorials/lean.html).\n * @param {ClientSession} [options.session=null] The session associated with this query. See [transactions docs](https://mongoosejs.com/docs/transactions.html).\n * @param {Boolean|String} [options.strict] overwrites the schema's [strict mode option](https://mongoosejs.com/docs/guide.html#strict)\n * @param {Boolean} [options.timestamps=null] If set to `false` and [schema-level timestamps](https://mongoosejs.com/docs/guide.html#timestamps) are enabled, skip timestamps for this update. Note that this allows you to overwrite timestamps. Does nothing if schema-level timestamps are not set.\n * @param {Object|String} [options.sort] if multiple docs are found by the conditions, sets the sort order to choose which doc to update.\n * @param {Boolean} [options.runValidators] if true, runs [update validators](https://mongoosejs.com/docs/validation.html#update-validators) on this command. Update validators validate the update operation against the model's schema\n * @param {Boolean} [options.setDefaultsOnInsert=true] If `setDefaultsOnInsert` and `upsert` are true, mongoose will apply the [defaults](https://mongoosejs.com/docs/defaults.html) specified in the model's schema if a new document is created\n * @param {Boolean} [options.includeResultMetadata] if true, returns the full [ModifyResult from the MongoDB driver](https://mongodb.github.io/node-mongodb-native/4.9/interfaces/ModifyResult.html) rather than just the document\n * @param {Boolean} [options.upsert=false] if true, and no documents found, insert a new document\n * @param {Boolean} [options.new=false] if true, return the modified document rather than the original\n * @param {Object|String} [options.select] sets the document fields to return.\n * @param {Boolean} [options.translateAliases=null] If set to `true`, translates any schema-defined aliases in `filter`, `projection`, `update`, and `distinct`. Throws an error if there are any conflicts where both alias and raw property are defined on the same object.\n * @return {Query}\n * @see Model.findOneAndUpdate https://mongoosejs.com/docs/api/model.html#Model.findOneAndUpdate()\n * @see mongodb https://www.mongodb.com/docs/manual/reference/command/findAndModify/\n * @api public\n */\n\nModel.findByIdAndUpdate = function(id, update, options) {\n  _checkContext(this, 'findByIdAndUpdate');\n  if (typeof arguments[0] === 'function' || typeof arguments[1] === 'function' || typeof arguments[2] === 'function' || typeof arguments[3] === 'function') {\n    throw new MongooseError('Model.findByIdAndUpdate() no longer accepts a callback');\n  }\n\n  // if a model is passed in instead of an id\n  if (id instanceof Document) {\n    id = id._id;\n  }\n\n  return this.findOneAndUpdate.call(this, { _id: id }, update, options);\n};\n\n/**\n * Issue a MongoDB `findOneAndDelete()` command.\n *\n * Finds a matching document, removes it, and returns the found document (if any).\n *\n * This function triggers the following middleware.\n *\n * - `findOneAndDelete()`\n *\n * #### Example:\n *\n *     A.findOneAndDelete(conditions, options)  // return Query\n *     A.findOneAndDelete(conditions) // returns Query\n *     A.findOneAndDelete()           // returns Query\n *\n * `findOneAndX` and `findByIdAndX` functions support limited validation. You can\n * enable validation by setting the `runValidators` option.\n *\n * If you need full-fledged validation, use the traditional approach of first\n * retrieving the document.\n *\n *     const doc = await Model.findById(id)\n *     doc.name = 'jason bourne';\n *     await doc.save();\n *\n * @param {Object} conditions\n * @param {Object} [options] optional see [`Query.prototype.setOptions()`](https://mongoosejs.com/docs/api/query.html#Query.prototype.setOptions())\n * @param {Boolean|String} [options.strict] overwrites the schema's [strict mode option](https://mongoosejs.com/docs/guide.html#strict)\n * @param {Object|String|String[]} [options.projection=null] optional fields to return, see [`Query.prototype.select()`](https://mongoosejs.com/docs/api/query.html#Query.prototype.select())\n * @param {ClientSession} [options.session=null] The session associated with this query. See [transactions docs](https://mongoosejs.com/docs/transactions.html).\n * @param {Boolean} [options.includeResultMetadata] if true, returns the full [ModifyResult from the MongoDB driver](https://mongodb.github.io/node-mongodb-native/4.9/interfaces/ModifyResult.html) rather than just the document\n * @param {Object|String} [options.sort] if multiple docs are found by the conditions, sets the sort order to choose which doc to update.\n * @param {Object|String} [options.select] sets the document fields to return.\n * @param {Number} [options.maxTimeMS] puts a time limit on the query - requires mongodb >= 2.6.0\n * @param {Boolean} [options.translateAliases=null] If set to `true`, translates any schema-defined aliases in `filter`, `projection`, `update`, and `distinct`. Throws an error if there are any conflicts where both alias and raw property are defined on the same object.\n * @return {Query}\n * @api public\n */\n\nModel.findOneAndDelete = function(conditions, options) {\n  _checkContext(this, 'findOneAndDelete');\n\n  if (typeof arguments[0] === 'function' || typeof arguments[1] === 'function' || typeof arguments[2] === 'function') {\n    throw new MongooseError('Model.findOneAndDelete() no longer accepts a callback');\n  }\n\n  let fields;\n  if (options) {\n    fields = options.select;\n    options.select = undefined;\n  }\n\n  const mq = new this.Query({}, {}, this, this.$__collection);\n  mq.select(fields);\n\n  return mq.findOneAndDelete(conditions, options);\n};\n\n/**\n * Issue a MongoDB `findOneAndDelete()` command by a document's _id field.\n * In other words, `findByIdAndDelete(id)` is a shorthand for\n * `findOneAndDelete({ _id: id })`.\n *\n * This function triggers the following middleware.\n *\n * - `findOneAndDelete()`\n *\n * @param {Object|Number|String} id value of `_id` to query by\n * @param {Object} [options] optional see [`Query.prototype.setOptions()`](https://mongoosejs.com/docs/api/query.html#Query.prototype.setOptions())\n * @param {Boolean|String} [options.strict] overwrites the schema's [strict mode option](https://mongoosejs.com/docs/guide.html#strict)\n * @param {Boolean} [options.translateAliases=null] If set to `true`, translates any schema-defined aliases in `filter`, `projection`, `update`, and `distinct`. Throws an error if there are any conflicts where both alias and raw property are defined on the same object.\n * @return {Query}\n * @see Model.findOneAndDelete https://mongoosejs.com/docs/api/model.html#Model.findOneAndDelete()\n * @see mongodb https://www.mongodb.com/docs/manual/reference/command/findAndModify/\n */\n\nModel.findByIdAndDelete = function(id, options) {\n  _checkContext(this, 'findByIdAndDelete');\n\n  if (typeof arguments[0] === 'function' || typeof arguments[1] === 'function' || typeof arguments[2] === 'function') {\n    throw new MongooseError('Model.findByIdAndDelete() no longer accepts a callback');\n  }\n\n  return this.findOneAndDelete({ _id: id }, options);\n};\n\n/**\n * Issue a MongoDB `findOneAndReplace()` command.\n *\n * Finds a matching document, replaces it with the provided doc, and returns the document.\n *\n * This function triggers the following query middleware.\n *\n * - `findOneAndReplace()`\n *\n * #### Example:\n *\n *     A.findOneAndReplace(filter, replacement, options)  // return Query\n *     A.findOneAndReplace(filter, replacement) // returns Query\n *     A.findOneAndReplace()                    // returns Query\n *\n * @param {Object} filter Replace the first document that matches this filter\n * @param {Object} [replacement] Replace with this document\n * @param {Object} [options] optional see [`Query.prototype.setOptions()`](https://mongoosejs.com/docs/api/query.html#Query.prototype.setOptions())\n * @param {String} [options.returnDocument='before'] Has two possible values, `'before'` and `'after'`. By default, it will return the document before the update was applied.\n * @param {Object} [options.lean] if truthy, mongoose will return the document as a plain JavaScript object rather than a mongoose document. See [`Query.lean()`](https://mongoosejs.com/docs/api/query.html#Query.prototype.lean()) and [the Mongoose lean tutorial](https://mongoosejs.com/docs/tutorials/lean.html).\n * @param {ClientSession} [options.session=null] The session associated with this query. See [transactions docs](https://mongoosejs.com/docs/transactions.html).\n * @param {Boolean|String} [options.strict] overwrites the schema's [strict mode option](https://mongoosejs.com/docs/guide.html#strict)\n * @param {Boolean} [options.timestamps=null] If set to `false` and [schema-level timestamps](https://mongoosejs.com/docs/guide.html#timestamps) are enabled, skip timestamps for this update. Note that this allows you to overwrite timestamps. Does nothing if schema-level timestamps are not set.\n * @param {Object|String|String[]} [options.projection=null] optional fields to return, see [`Query.prototype.select()`](https://mongoosejs.com/docs/api/query.html#Query.prototype.select())\n * @param {Object|String} [options.sort] if multiple docs are found by the conditions, sets the sort order to choose which doc to update.\n * @param {Boolean} [options.includeResultMetadata] if true, returns the full [ModifyResult from the MongoDB driver](https://mongodb.github.io/node-mongodb-native/4.9/interfaces/ModifyResult.html) rather than just the document\n * @param {Object|String} [options.select] sets the document fields to return.\n * @param {Number} [options.maxTimeMS] puts a time limit on the query - requires mongodb >= 2.6.0\n * @param {Boolean} [options.translateAliases=null] If set to `true`, translates any schema-defined aliases in `filter`, `projection`, `update`, and `distinct`. Throws an error if there are any conflicts where both alias and raw property are defined on the same object.\n * @return {Query}\n * @api public\n */\n\nModel.findOneAndReplace = function(filter, replacement, options) {\n  _checkContext(this, 'findOneAndReplace');\n\n  if (typeof arguments[0] === 'function' || typeof arguments[1] === 'function' || typeof arguments[2] === 'function' || typeof arguments[3] === 'function') {\n    throw new MongooseError('Model.findOneAndReplace() no longer accepts a callback');\n  }\n\n  let fields;\n  if (options) {\n    fields = options.select;\n    options.select = undefined;\n  }\n\n  const mq = new this.Query({}, {}, this, this.$__collection);\n  mq.select(fields);\n\n  return mq.findOneAndReplace(filter, replacement, options);\n};\n\n/**\n * Shortcut for saving one or more documents to the database.\n * `MyModel.create(docs)` does `new MyModel(doc).save()` for every doc in\n * docs.\n *\n * This function triggers the following middleware.\n *\n * - `save()`\n *\n * #### Example:\n *\n *     // Insert one new `Character` document\n *     await Character.create({ name: 'Jean-Luc Picard' });\n *\n *     // Insert multiple new `Character` documents\n *     await Character.create([{ name: 'Will Riker' }, { name: 'Geordi LaForge' }]);\n *\n *     // Create a new character within a transaction. Note that you **must**\n *     // pass an array as the first parameter to `create()` if you want to\n *     // specify options.\n *     await Character.create([{ name: 'Jean-Luc Picard' }], { session });\n *\n * @param {Array|Object} docs Documents to insert, as a spread or array\n * @param {Object} [options] Options passed down to `save()`. To specify `options`, `docs` **must** be an array, not a spread. See [Model.save](https://mongoosejs.com/docs/api/model.html#Model.prototype.save()) for available options.\n * @param {Boolean} [options.ordered] saves the docs in series rather than parallel.\n * @param {Boolean} [options.aggregateErrors] Aggregate Errors instead of throwing the first one that occurs. Default: false\n * @return {Promise}\n * @api public\n */\n\nModel.create = async function create(doc, options) {\n  if (typeof options === 'function' ||\n      typeof arguments[2] === 'function') {\n    throw new MongooseError('Model.create() no longer accepts a callback');\n  }\n\n  _checkContext(this, 'create');\n\n  let args;\n  const discriminatorKey = this.schema.options.discriminatorKey;\n\n  if (Array.isArray(doc)) {\n    args = doc;\n    options = options != null && typeof options === 'object' ? options : {};\n  } else {\n    const last = arguments[arguments.length - 1];\n    options = {};\n    const hasCallback = typeof last === 'function' ||\n      typeof options === 'function' ||\n      typeof arguments[2] === 'function';\n    if (hasCallback) {\n      throw new MongooseError('Model.create() no longer accepts a callback');\n    } else {\n      args = [...arguments];\n      // For backwards compatibility with 6.x, because of gh-5061 Mongoose 6.x and\n      // older would treat a falsy last arg as a callback. We don't want to throw\n      // an error here, because it would look strange if `Test.create({}, void 0)`\n      // threw a callback error. But we also don't want to create an unnecessary document.\n      if (args.length > 1 && !last) {\n        args.pop();\n      }\n    }\n\n    if (args.length === 2 &&\n        args[0] != null &&\n        args[1] != null &&\n        args[0].session == null &&\n        last &&\n        getConstructorName(last.session) === 'ClientSession' &&\n        !this.schema.path('session')) {\n      // Probably means the user is running into the common mistake of trying\n      // to use a spread to specify options, see gh-7535\n      utils.warn('WARNING: to pass a `session` to `Model.create()` in ' +\n        'Mongoose, you **must** pass an array as the first argument. See: ' +\n        'https://mongoosejs.com/docs/api/model.html#Model.create()');\n    }\n  }\n\n  if (args.length === 0) {\n    return Array.isArray(doc) ? [] : null;\n  }\n  let res = [];\n  const immediateError = typeof options.aggregateErrors === 'boolean' ? !options.aggregateErrors : true;\n\n  delete options.aggregateErrors; // dont pass on the option to \"$save\"\n\n  if (options.ordered) {\n    for (let i = 0; i < args.length; i++) {\n      try {\n        const doc = args[i];\n        const Model = this.discriminators && doc[discriminatorKey] != null ?\n          this.discriminators[doc[discriminatorKey]] || getDiscriminatorByValue(this.discriminators, doc[discriminatorKey]) :\n          this;\n        if (Model == null) {\n          throw new MongooseError(`Discriminator \"${doc[discriminatorKey]}\" not ` +\n          `found for model \"${this.modelName}\"`);\n        }\n        let toSave = doc;\n        if (!(toSave instanceof Model)) {\n          toSave = new Model(toSave);\n        }\n\n        await toSave.$save(options);\n        res.push(toSave);\n      } catch (err) {\n        if (!immediateError) {\n          res.push(err);\n        } else {\n          throw err;\n        }\n      }\n    }\n    return res;\n  } else if (!immediateError) {\n    res = await Promise.allSettled(args.map(async doc => {\n      const Model = this.discriminators && doc[discriminatorKey] != null ?\n        this.discriminators[doc[discriminatorKey]] || getDiscriminatorByValue(this.discriminators, doc[discriminatorKey]) :\n        this;\n      if (Model == null) {\n        throw new MongooseError(`Discriminator \"${doc[discriminatorKey]}\" not ` +\n            `found for model \"${this.modelName}\"`);\n      }\n      let toSave = doc;\n\n      if (!(toSave instanceof Model)) {\n        toSave = new Model(toSave);\n      }\n\n      await toSave.$save(options);\n\n      return toSave;\n    }));\n    res = res.map(result => result.status === 'fulfilled' ? result.value : result.reason);\n  } else {\n    let firstError = null;\n    res = await Promise.all(args.map(async doc => {\n      const Model = this.discriminators && doc[discriminatorKey] != null ?\n        this.discriminators[doc[discriminatorKey]] || getDiscriminatorByValue(this.discriminators, doc[discriminatorKey]) :\n        this;\n      if (Model == null) {\n        throw new MongooseError(`Discriminator \"${doc[discriminatorKey]}\" not ` +\n            `found for model \"${this.modelName}\"`);\n      }\n      try {\n        let toSave = doc;\n\n        if (!(toSave instanceof Model)) {\n          toSave = new Model(toSave);\n        }\n\n        await toSave.$save(options);\n\n        return toSave;\n      } catch (err) {\n        if (!firstError) {\n          firstError = err;\n        }\n      }\n    }));\n    if (firstError) {\n      throw firstError;\n    }\n  }\n\n\n  if (!Array.isArray(doc) && args.length === 1) {\n    return res[0];\n  }\n\n  return res;\n};\n\n/**\n * _Requires a replica set running MongoDB >= 3.6.0._ Watches the\n * underlying collection for changes using\n * [MongoDB change streams](https://www.mongodb.com/docs/manual/changeStreams/).\n *\n * This function does **not** trigger any middleware. In particular, it\n * does **not** trigger aggregate middleware.\n *\n * The ChangeStream object is an event emitter that emits the following events:\n *\n * - 'change': A change occurred, see below example\n * - 'error': An unrecoverable error occurred. In particular, change streams currently error out if they lose connection to the replica set primary. Follow [this GitHub issue](https://github.com/Automattic/mongoose/issues/6799) for updates.\n * - 'end': Emitted if the underlying stream is closed\n * - 'close': Emitted if the underlying stream is closed\n *\n * #### Example:\n *\n *     const doc = await Person.create({ name: 'Ned Stark' });\n *     const changeStream = Person.watch().on('change', change => console.log(change));\n *     // Will print from the above `console.log()`:\n *     // { _id: { _data: ... },\n *     //   operationType: 'delete',\n *     //   ns: { db: 'mydb', coll: 'Person' },\n *     //   documentKey: { _id: 5a51b125c5500f5aa094c7bd } }\n *     await doc.remove();\n *\n * @param {Array} [pipeline]\n * @param {Object} [options] see the [mongodb driver options](https://mongodb.github.io/node-mongodb-native/4.9/classes/Collection.html#watch)\n * @param {Boolean} [options.hydrate=false] if true and `fullDocument: 'updateLookup'` is set, Mongoose will automatically hydrate `fullDocument` into a fully fledged Mongoose document\n * @return {ChangeStream} mongoose-specific change stream wrapper, inherits from EventEmitter\n * @api public\n */\n\nModel.watch = function(pipeline, options) {\n  _checkContext(this, 'watch');\n\n  const changeStreamThunk = cb => {\n    pipeline = pipeline || [];\n    prepareDiscriminatorPipeline(pipeline, this.schema, 'fullDocument');\n    if (this.$__collection.buffer) {\n      this.$__collection.addQueue(() => {\n        if (this.closed) {\n          return;\n        }\n        const driverChangeStream = this.$__collection.watch(pipeline, options);\n        cb(null, driverChangeStream);\n      });\n    } else {\n      const driverChangeStream = this.$__collection.watch(pipeline, options);\n      cb(null, driverChangeStream);\n    }\n  };\n\n  options = options || {};\n  options.model = this;\n\n  return new ChangeStream(changeStreamThunk, pipeline, options);\n};\n\n/**\n * _Requires MongoDB >= 3.6.0._ Starts a [MongoDB session](https://www.mongodb.com/docs/manual/release-notes/3.6/#client-sessions)\n * for benefits like causal consistency, [retryable writes](https://www.mongodb.com/docs/manual/core/retryable-writes/),\n * and [transactions](https://thecodebarbarian.com/a-node-js-perspective-on-mongodb-4-transactions.html).\n *\n * Calling `MyModel.startSession()` is equivalent to calling `MyModel.db.startSession()`.\n *\n * This function does not trigger any middleware.\n *\n * #### Example:\n *\n *     const session = await Person.startSession();\n *     let doc = await Person.findOne({ name: 'Ned Stark' }, null, { session });\n *     await doc.remove();\n *     // `doc` will always be null, even if reading from a replica set\n *     // secondary. Without causal consistency, it is possible to\n *     // get a doc back from the below query if the query reads from a\n *     // secondary that is experiencing replication lag.\n *     doc = await Person.findOne({ name: 'Ned Stark' }, null, { session, readPreference: 'secondary' });\n *\n * @param {Object} [options] see the [mongodb driver options](https://mongodb.github.io/node-mongodb-native/4.9/classes/MongoClient.html#startSession)\n * @param {Boolean} [options.causalConsistency=true] set to false to disable causal consistency\n * @return {Promise<ClientSession>} promise that resolves to a MongoDB driver `ClientSession`\n * @api public\n */\n\nModel.startSession = function() {\n  _checkContext(this, 'startSession');\n\n  return this.db.startSession.apply(this.db, arguments);\n};\n\n/**\n * Shortcut for validating an array of documents and inserting them into\n * MongoDB if they're all valid. This function is faster than `.create()`\n * because it only sends one operation to the server, rather than one for each\n * document.\n *\n * Mongoose always validates each document **before** sending `insertMany`\n * to MongoDB. So if one document has a validation error, no documents will\n * be saved, unless you set\n * [the `ordered` option to false](https://www.mongodb.com/docs/manual/reference/method/db.collection.insertMany/#error-handling).\n *\n * This function does **not** trigger save middleware.\n *\n * This function triggers the following middleware.\n *\n * - `insertMany()`\n *\n * #### Example:\n *\n *     await Movies.insertMany([\n *       { name: 'Star Wars' },\n *       { name: 'The Empire Strikes Back' }\n *     ]);\n *\n * @param {Array|Object|*} doc(s)\n * @param {Object} [options] see the [mongodb driver options](https://mongodb.github.io/node-mongodb-native/4.9/classes/Collection.html#insertMany)\n * @param {Boolean} [options.ordered=true] if true, will fail fast on the first error encountered. If false, will insert all the documents it can and report errors later. An `insertMany()` with `ordered = false` is called an \"unordered\" `insertMany()`.\n * @param {Boolean} [options.rawResult=false] if false, the returned promise resolves to the documents that passed mongoose document validation. If `true`, will return the [raw result from the MongoDB driver](https://mongodb.github.io/node-mongodb-native/4.9/interfaces/InsertManyResult.html) with a `mongoose` property that contains `validationErrors` and `results` if this is an unordered `insertMany`.\n * @param {Boolean} [options.lean=false] if `true`, skips hydrating and validating the documents. This option is useful if you need the extra performance, but Mongoose won't validate the documents before inserting.\n * @param {Number} [options.limit=null] this limits the number of documents being processed (validation/casting) by mongoose in parallel, this does **NOT** send the documents in batches to MongoDB. Use this option if you're processing a large number of documents and your app is running out of memory.\n * @param {String|Object|Array} [options.populate=null] populates the result documents. This option is a no-op if `rawResult` is set.\n * @param {Boolean} [options.throwOnValidationError=false] If true and `ordered: false`, throw an error if one of the operations failed validation, but all valid operations completed successfully.\n * @return {Promise} resolving to the raw result from the MongoDB driver if `options.rawResult` was `true`, or the documents that passed validation, otherwise\n * @api public\n */\n\nModel.insertMany = async function insertMany(arr, options) {\n  _checkContext(this, 'insertMany');\n  if (typeof options === 'function' ||\n    typeof arguments[2] === 'function') {\n    throw new MongooseError('Model.insertMany() no longer accepts a callback');\n  }\n\n  return new Promise((resolve, reject) => {\n    this.$__insertMany(arr, options, (err, res) => {\n      if (err != null) {\n        return reject(err);\n      }\n      resolve(res);\n    });\n  });\n};\n\n/**\n * ignore\n *\n * @param {Array} arr\n * @param {Object} options\n * @param {Function} callback\n * @api private\n * @memberOf Model\n * @method $__insertMany\n * @static\n */\n\nModel.$__insertMany = function(arr, options, callback) {\n  const _this = this;\n  if (typeof options === 'function') {\n    callback = options;\n    options = null;\n  }\n\n  callback = callback || utils.noop;\n  options = options || {};\n  const limit = options.limit || 1000;\n  const rawResult = !!options.rawResult;\n  const ordered = typeof options.ordered === 'boolean' ? options.ordered : true;\n  const throwOnValidationError = typeof options.throwOnValidationError === 'boolean' ? options.throwOnValidationError : false;\n  const lean = !!options.lean;\n\n  if (!Array.isArray(arr)) {\n    arr = [arr];\n  }\n\n  const validationErrors = [];\n  const validationErrorsToOriginalOrder = new Map();\n  const results = ordered ? null : new Array(arr.length);\n  const toExecute = arr.map((doc, index) =>\n    callback => {\n      if (!(doc instanceof _this)) {\n        try {\n          doc = new _this(doc);\n        } catch (err) {\n          return callback(err);\n        }\n      }\n      if (options.session != null) {\n        doc.$session(options.session);\n      }\n      // If option `lean` is set to true bypass validation\n      if (lean) {\n        // we have to execute callback at the nextTick to be compatible\n        // with parallelLimit, as `results` variable has TDZ issue if we\n        // execute the callback synchronously\n        return immediate(() => callback(null, doc));\n      }\n      doc.$validate().then(\n        () => { callback(null, doc); },\n        error => {\n          if (ordered === false) {\n            validationErrors.push(error);\n            validationErrorsToOriginalOrder.set(error, index);\n            results[index] = error;\n            return callback(null, null);\n          }\n          callback(error);\n        }\n      );\n    });\n\n  parallelLimit(toExecute, limit, function(error, docs) {\n    if (error) {\n      callback(error, null);\n      return;\n    }\n\n    const originalDocIndex = new Map();\n    const validDocIndexToOriginalIndex = new Map();\n    for (let i = 0; i < docs.length; ++i) {\n      originalDocIndex.set(docs[i], i);\n    }\n\n    // We filter all failed pre-validations by removing nulls\n    const docAttributes = docs.filter(function(doc) {\n      return doc != null;\n    });\n    for (let i = 0; i < docAttributes.length; ++i) {\n      validDocIndexToOriginalIndex.set(i, originalDocIndex.get(docAttributes[i]));\n    }\n\n    // Make sure validation errors are in the same order as the\n    // original documents, so if both doc1 and doc2 both fail validation,\n    // `Model.insertMany([doc1, doc2])` will always have doc1's validation\n    // error before doc2's. Re: gh-12791.\n    if (validationErrors.length > 0) {\n      validationErrors.sort((err1, err2) => {\n        return validationErrorsToOriginalOrder.get(err1) - validationErrorsToOriginalOrder.get(err2);\n      });\n    }\n\n    // Quickly escape while there aren't any valid docAttributes\n    if (docAttributes.length === 0) {\n      if (rawResult) {\n        const res = {\n          acknowledged: true,\n          insertedCount: 0,\n          insertedIds: {},\n          mongoose: {\n            validationErrors: validationErrors\n          }\n        };\n        return callback(null, res);\n      }\n      callback(null, []);\n      return;\n    }\n    const docObjects = docAttributes.map(function(doc) {\n      if (doc.$__schema.options.versionKey) {\n        doc[doc.$__schema.options.versionKey] = 0;\n      }\n      const shouldSetTimestamps = (!options || options.timestamps !== false) && doc.initializeTimestamps && (!doc.$__ || doc.$__.timestamps !== false);\n      if (shouldSetTimestamps) {\n        return doc.initializeTimestamps().toObject(internalToObjectOptions);\n      }\n      return doc.toObject(internalToObjectOptions);\n    });\n\n    _this.$__collection.insertMany(docObjects, options).then(\n      res => {\n        for (const attribute of docAttributes) {\n          attribute.$__reset();\n          _setIsNew(attribute, false);\n        }\n\n        if (ordered === false && throwOnValidationError && validationErrors.length > 0) {\n          for (let i = 0; i < results.length; ++i) {\n            if (results[i] === void 0) {\n              results[i] = docs[i];\n            }\n          }\n          return callback(new MongooseBulkWriteError(\n            validationErrors,\n            results,\n            res,\n            'insertMany'\n          ));\n        }\n\n        if (rawResult) {\n          if (ordered === false) {\n            for (let i = 0; i < results.length; ++i) {\n              if (results[i] === void 0) {\n                results[i] = docs[i];\n              }\n            }\n\n            // Decorate with mongoose validation errors in case of unordered,\n            // because then still do `insertMany()`\n            res.mongoose = {\n              validationErrors: validationErrors,\n              results: results\n            };\n          }\n          return callback(null, res);\n        }\n\n        if (options.populate != null) {\n          return _this.populate(docAttributes, options.populate).then(\n            docs => { callback(null, docs); },\n            err => {\n              if (err != null) {\n                err.insertedDocs = docAttributes;\n              }\n              throw err;\n            }\n          );\n        }\n\n        callback(null, docAttributes);\n      },\n      error => {\n        // `writeErrors` is a property reported by the MongoDB driver,\n        // just not if there's only 1 error.\n        if (error.writeErrors == null &&\n            (error.result && error.result.result && error.result.result.writeErrors) != null) {\n          error.writeErrors = error.result.result.writeErrors;\n        }\n\n        // `insertedDocs` is a Mongoose-specific property\n        const hasWriteErrors = error && error.writeErrors;\n        const erroredIndexes = new Set((error && error.writeErrors || []).map(err => err.index));\n\n        if (error.writeErrors != null) {\n          for (let i = 0; i < error.writeErrors.length; ++i) {\n            const originalIndex = validDocIndexToOriginalIndex.get(error.writeErrors[i].index);\n            error.writeErrors[i] = {\n              ...error.writeErrors[i],\n              index: originalIndex\n            };\n            if (!ordered) {\n              results[originalIndex] = error.writeErrors[i];\n            }\n          }\n        }\n\n        if (!ordered) {\n          for (let i = 0; i < results.length; ++i) {\n            if (results[i] === void 0) {\n              results[i] = docs[i];\n            }\n          }\n\n          error.results = results;\n        }\n\n        let firstErroredIndex = -1;\n        error.insertedDocs = docAttributes.\n          filter((doc, i) => {\n            const isErrored = !hasWriteErrors || erroredIndexes.has(i);\n\n            if (ordered) {\n              if (firstErroredIndex > -1) {\n                return i < firstErroredIndex;\n              }\n\n              if (isErrored) {\n                firstErroredIndex = i;\n              }\n            }\n\n            return !isErrored;\n          }).\n          map(function setIsNewForInsertedDoc(doc) {\n            doc.$__reset();\n            _setIsNew(doc, false);\n            return doc;\n          });\n\n        if (rawResult && ordered === false) {\n          error.mongoose = {\n            validationErrors: validationErrors,\n            results: results\n          };\n        }\n\n        callback(error, null);\n      }\n    );\n  });\n};\n\n/*!\n * ignore\n */\n\nfunction _setIsNew(doc, val) {\n  doc.$isNew = val;\n  doc.$emit('isNew', val);\n  doc.constructor.emit('isNew', val);\n\n  const subdocs = doc.$getAllSubdocs();\n  for (const subdoc of subdocs) {\n    subdoc.$isNew = val;\n    subdoc.$emit('isNew', val);\n  }\n}\n\n/**\n * Sends multiple `insertOne`, `updateOne`, `updateMany`, `replaceOne`,\n * `deleteOne`, and/or `deleteMany` operations to the MongoDB server in one\n * command. This is faster than sending multiple independent operations (e.g.\n * if you use `create()`) because with `bulkWrite()` there is only one round\n * trip to MongoDB.\n *\n * Mongoose will perform casting on all operations you provide.\n *\n * This function does **not** trigger any middleware, neither `save()`, nor `update()`.\n * If you need to trigger\n * `save()` middleware for every document use [`create()`](https://mongoosejs.com/docs/api/model.html#Model.create()) instead.\n *\n * #### Example:\n *\n *     Character.bulkWrite([\n *       {\n *         insertOne: {\n *           document: {\n *             name: 'Eddard Stark',\n *             title: 'Warden of the North'\n *           }\n *         }\n *       },\n *       {\n *         updateOne: {\n *           filter: { name: 'Eddard Stark' },\n *           // If you were using the MongoDB driver directly, you'd need to do\n *           // `update: { $set: { title: ... } }` but mongoose adds $set for\n *           // you.\n *           update: { title: 'Hand of the King' }\n *         }\n *       },\n *       {\n *         deleteOne: {\n *           filter: { name: 'Eddard Stark' }\n *         }\n *       }\n *     ]).then(res => {\n *      // Prints \"1 1 1\"\n *      console.log(res.insertedCount, res.modifiedCount, res.deletedCount);\n *     });\n *\n * The [supported operations](https://www.mongodb.com/docs/manual/reference/method/db.collection.bulkWrite/#db.collection.bulkWrite) are:\n *\n * - `insertOne`\n * - `updateOne`\n * - `updateMany`\n * - `deleteOne`\n * - `deleteMany`\n * - `replaceOne`\n *\n * @param {Array} ops\n * @param {Object} [ops.insertOne.document] The document to insert\n * @param {Object} [ops.updateOne.filter] Update the first document that matches this filter\n * @param {Object} [ops.updateOne.update] An object containing [update operators](https://www.mongodb.com/docs/manual/reference/operator/update/)\n * @param {Boolean} [ops.updateOne.upsert=false] If true, insert a doc if none match\n * @param {Boolean} [ops.updateOne.timestamps=true] If false, do not apply [timestamps](https://mongoosejs.com/docs/guide.html#timestamps) to the operation\n * @param {Object} [ops.updateOne.collation] The [MongoDB collation](https://thecodebarbarian.com/a-nodejs-perspective-on-mongodb-34-collations) to use\n * @param {Array} [ops.updateOne.arrayFilters] The [array filters](https://thecodebarbarian.com/a-nodejs-perspective-on-mongodb-36-array-filters.html) used in `update`\n * @param {Object} [ops.updateMany.filter] Update all the documents that match this filter\n * @param {Object} [ops.updateMany.update] An object containing [update operators](https://www.mongodb.com/docs/manual/reference/operator/update/)\n * @param {Boolean} [ops.updateMany.upsert=false] If true, insert a doc if no documents match `filter`\n * @param {Boolean} [ops.updateMany.timestamps=true] If false, do not apply [timestamps](https://mongoosejs.com/docs/guide.html#timestamps) to the operation\n * @param {Object} [ops.updateMany.collation] The [MongoDB collation](https://thecodebarbarian.com/a-nodejs-perspective-on-mongodb-34-collations) to use\n * @param {Array} [ops.updateMany.arrayFilters] The [array filters](https://thecodebarbarian.com/a-nodejs-perspective-on-mongodb-36-array-filters.html) used in `update`\n * @param {Object} [ops.deleteOne.filter] Delete the first document that matches this filter\n * @param {Object} [ops.deleteMany.filter] Delete all documents that match this filter\n * @param {Object} [ops.replaceOne.filter] Replace the first document that matches this filter\n * @param {Object} [ops.replaceOne.replacement] The replacement document\n * @param {Boolean} [ops.replaceOne.upsert=false] If true, insert a doc if no documents match `filter`\n * @param {Object} [options]\n * @param {Boolean} [options.ordered=true] If true, execute writes in order and stop at the first error. If false, execute writes in parallel and continue until all writes have either succeeded or errored.\n * @param {ClientSession} [options.session=null] The session associated with this bulk write. See [transactions docs](https://mongoosejs.com/docs/transactions.html).\n * @param {String|number} [options.w=1] The [write concern](https://www.mongodb.com/docs/manual/reference/write-concern/). See [`Query#w()`](https://mongoosejs.com/docs/api/query.html#Query.prototype.w()) for more information.\n * @param {number} [options.wtimeout=null] The [write concern timeout](https://www.mongodb.com/docs/manual/reference/write-concern/#wtimeout).\n * @param {Boolean} [options.j=true] If false, disable [journal acknowledgement](https://www.mongodb.com/docs/manual/reference/write-concern/#j-option)\n * @param {Boolean} [options.skipValidation=false] Set to true to skip Mongoose schema validation on bulk write operations. Mongoose currently runs validation on `insertOne` and `replaceOne` operations by default.\n * @param {Boolean} [options.bypassDocumentValidation=false] If true, disable [MongoDB server-side schema validation](https://www.mongodb.com/docs/manual/core/schema-validation/) for all writes in this bulk.\n * @param {Boolean} [options.throwOnValidationError=false] If true and `ordered: false`, throw an error if one of the operations failed validation, but all valid operations completed successfully.\n * @param {Boolean} [options.strict=null] Overwrites the [`strict` option](https://mongoosejs.com/docs/guide.html#strict) on schema. If false, allows filtering and writing fields not defined in the schema for all writes in this bulk.\n * @return {Promise} resolves to a [`BulkWriteOpResult`](https://mongodb.github.io/node-mongodb-native/4.9/classes/BulkWriteResult.html) if the operation succeeds\n * @api public\n */\n\nModel.bulkWrite = async function bulkWrite(ops, options) {\n  _checkContext(this, 'bulkWrite');\n\n  if (typeof options === 'function' ||\n      typeof arguments[2] === 'function') {\n    throw new MongooseError('Model.bulkWrite() no longer accepts a callback');\n  }\n  options = options || {};\n  const ordered = options.ordered == null ? true : options.ordered;\n\n  const validations = ops.map(op => castBulkWrite(this, op, options));\n\n  return new Promise((resolve, reject) => {\n    if (ordered) {\n      each(validations, (fn, cb) => fn(cb), error => {\n        if (error) {\n          return reject(error);\n        }\n\n        if (ops.length === 0) {\n          return resolve(getDefaultBulkwriteResult());\n        }\n\n        try {\n          this.$__collection.bulkWrite(ops, options, (error, res) => {\n            if (error) {\n              return reject(error);\n            }\n\n            resolve(res);\n          });\n        } catch (err) {\n          return reject(err);\n        }\n      });\n\n      return;\n    }\n\n    let remaining = validations.length;\n    let validOps = [];\n    let validationErrors = [];\n    const results = [];\n    if (remaining === 0) {\n      completeUnorderedValidation.call(this);\n    } else {\n      for (let i = 0; i < validations.length; ++i) {\n        validations[i]((err) => {\n          if (err == null) {\n            validOps.push(i);\n          } else {\n            validationErrors.push({ index: i, error: err });\n            results[i] = err;\n          }\n          if (--remaining <= 0) {\n            completeUnorderedValidation.call(this);\n          }\n        });\n      }\n    }\n\n    validationErrors = validationErrors.\n      sort((v1, v2) => v1.index - v2.index).\n      map(v => v.error);\n\n    function completeUnorderedValidation() {\n      const validOpIndexes = validOps;\n      validOps = validOps.sort().map(index => ops[index]);\n\n      if (validOps.length === 0) {\n        return resolve(getDefaultBulkwriteResult());\n      }\n\n      this.$__collection.bulkWrite(validOps, options, (error, res) => {\n        if (error) {\n          if (validationErrors.length > 0) {\n            error.mongoose = error.mongoose || {};\n            error.mongoose.validationErrors = validationErrors;\n          }\n\n          return reject(error);\n        }\n\n        for (let i = 0; i < validOpIndexes.length; ++i) {\n          results[validOpIndexes[i]] = null;\n        }\n        if (validationErrors.length > 0) {\n          if (options.throwOnValidationError) {\n            return reject(new MongooseBulkWriteError(\n              validationErrors,\n              results,\n              res,\n              'bulkWrite'\n            ));\n          } else {\n            res.mongoose = res.mongoose || {};\n            res.mongoose.validationErrors = validationErrors;\n            res.mongoose.results = results;\n          }\n        }\n\n        resolve(res);\n      });\n    }\n  });\n};\n\n/**\n *  takes an array of documents, gets the changes and inserts/updates documents in the database\n *  according to whether or not the document is new, or whether it has changes or not.\n *\n * `bulkSave` uses `bulkWrite` under the hood, so it's mostly useful when dealing with many documents (10K+)\n *\n * @param {Array<Document>} documents\n * @param {Object} [options] options passed to the underlying `bulkWrite()`\n * @param {Boolean} [options.timestamps] defaults to `null`, when set to false, mongoose will not add/update timestamps to the documents.\n * @param {ClientSession} [options.session=null] The session associated with this bulk write. See [transactions docs](https://mongoosejs.com/docs/transactions.html).\n * @param {String|number} [options.w=1] The [write concern](https://www.mongodb.com/docs/manual/reference/write-concern/). See [`Query#w()`](https://mongoosejs.com/docs/api/query.html#Query.prototype.w()) for more information.\n * @param {number} [options.wtimeout=null] The [write concern timeout](https://www.mongodb.com/docs/manual/reference/write-concern/#wtimeout).\n * @param {Boolean} [options.j=true] If false, disable [journal acknowledgement](https://www.mongodb.com/docs/manual/reference/write-concern/#j-option)\n *\n */\nModel.bulkSave = async function bulkSave(documents, options) {\n  options = options || {};\n\n  if (options.timestamps != null) {\n    for (const document of documents) {\n      document.$__.saveOptions = document.$__.saveOptions || {};\n      document.$__.saveOptions.timestamps = options.timestamps;\n    }\n  } else {\n    for (const document of documents) {\n      if (document.$__.timestamps != null) {\n        document.$__.saveOptions = document.$__.saveOptions || {};\n        document.$__.saveOptions.timestamps = document.$__.timestamps;\n      }\n    }\n  }\n\n  await Promise.all(documents.map(buildPreSavePromise));\n\n  const writeOperations = this.buildBulkWriteOperations(documents, { skipValidation: true, timestamps: options.timestamps });\n\n  const { bulkWriteResult, bulkWriteError } = await this.bulkWrite(writeOperations, options).then(\n    (res) => ({ bulkWriteResult: res, bulkWriteError: null }),\n    (err) => ({ bulkWriteResult: null, bulkWriteError: err })\n  );\n\n  await Promise.all(\n    documents.map(async(document) => {\n      const documentError = bulkWriteError && bulkWriteError.writeErrors.find(writeError => {\n        const writeErrorDocumentId = writeError.err.op._id || writeError.err.op.q._id;\n        return writeErrorDocumentId.toString() === document._id.toString();\n      });\n\n      if (documentError == null) {\n        await handleSuccessfulWrite(document);\n      }\n    })\n  );\n\n  if (bulkWriteError && bulkWriteError.writeErrors && bulkWriteError.writeErrors.length) {\n    throw bulkWriteError;\n  }\n\n  return bulkWriteResult;\n};\n\nfunction buildPreSavePromise(document) {\n  return new Promise((resolve, reject) => {\n    document.schema.s.hooks.execPre('save', document, (err) => {\n      if (err) {\n        reject(err);\n        return;\n      }\n      resolve();\n    });\n  });\n}\n\nfunction handleSuccessfulWrite(document) {\n  return new Promise((resolve, reject) => {\n    if (document.$isNew) {\n      _setIsNew(document, false);\n    }\n\n    document.$__reset();\n    document.schema.s.hooks.execPost('save', document, [document], {}, (err) => {\n      if (err) {\n        reject(err);\n        return;\n      }\n      resolve();\n    });\n\n  });\n}\n\n/**\n * Apply defaults to the given document or POJO.\n *\n * @param {Object|Document} obj object or document to apply defaults on\n * @returns {Object|Document}\n * @api public\n */\n\nModel.applyDefaults = function applyDefaults(doc) {\n  if (doc.$__ != null) {\n    applyDefaultsHelper(doc, doc.$__.fields, doc.$__.exclude);\n\n    for (const subdoc of doc.$getAllSubdocs()) {\n      applyDefaults(subdoc, subdoc.$__.fields, subdoc.$__.exclude);\n    }\n\n    return doc;\n  }\n\n  applyDefaultsToPOJO(doc, this.schema);\n\n  return doc;\n};\n\n/**\n * Cast the given POJO to the model's schema\n *\n * #### Example:\n *\n *     const Test = mongoose.model('Test', Schema({ num: Number }));\n *\n *     const obj = Test.castObject({ num: '42' });\n *     obj.num; // 42 as a number\n *\n *     Test.castObject({ num: 'not a number' }); // Throws a ValidationError\n *\n * @param {Object} obj object or document to cast\n * @param {Object} options options passed to castObject\n * @param {Boolean} options.ignoreCastErrors If set to `true` will not throw a ValidationError and only return values that were successfully cast.\n * @returns {Object} POJO casted to the model's schema\n * @throws {ValidationError} if casting failed for at least one path\n * @api public\n */\n\nModel.castObject = function castObject(obj, options) {\n  options = options || {};\n  const ret = {};\n\n  const schema = this.schema;\n  const paths = Object.keys(schema.paths);\n\n  for (const path of paths) {\n    const schemaType = schema.path(path);\n    if (!schemaType || !schemaType.$isMongooseArray) {\n      continue;\n    }\n\n    const val = get(obj, path);\n    pushNestedArrayPaths(paths, val, path);\n  }\n\n  let error = null;\n\n  for (const path of paths) {\n    const schemaType = schema.path(path);\n    if (schemaType == null) {\n      continue;\n    }\n\n    let val = get(obj, path, void 0);\n\n    if (val == null) {\n      continue;\n    }\n\n    const pieces = path.indexOf('.') === -1 ? [path] : path.split('.');\n    let cur = ret;\n    for (let i = 0; i < pieces.length - 1; ++i) {\n      if (cur[pieces[i]] == null) {\n        cur[pieces[i]] = isNaN(pieces[i + 1]) ? {} : [];\n      }\n      cur = cur[pieces[i]];\n    }\n\n    if (schemaType.$isMongooseDocumentArray) {\n      continue;\n    }\n    if (schemaType.$isSingleNested || schemaType.$isMongooseDocumentArrayElement) {\n      try {\n        val = Model.castObject.call(schemaType.caster, val);\n      } catch (err) {\n        if (!options.ignoreCastErrors) {\n          error = error || new ValidationError();\n          error.addError(path, err);\n        }\n        continue;\n      }\n\n      cur[pieces[pieces.length - 1]] = val;\n      continue;\n    }\n\n    try {\n      val = schemaType.cast(val);\n      cur[pieces[pieces.length - 1]] = val;\n    } catch (err) {\n      if (!options.ignoreCastErrors) {\n        error = error || new ValidationError();\n        error.addError(path, err);\n      }\n\n      continue;\n    }\n  }\n\n  if (error != null) {\n    throw error;\n  }\n\n  return ret;\n};\n\n/**\n * Build bulk write operations for `bulkSave()`.\n *\n * @param {Array<Document>} documents The array of documents to build write operations of\n * @param {Object} options\n * @param {Boolean} options.skipValidation defaults to `false`, when set to true, building the write operations will bypass validating the documents.\n * @param {Boolean} options.timestamps defaults to `null`, when set to false, mongoose will not add/update timestamps to the documents.\n * @return {Array<Promise>} Returns a array of all Promises the function executes to be awaited.\n * @api private\n */\n\nModel.buildBulkWriteOperations = function buildBulkWriteOperations(documents, options) {\n  if (!Array.isArray(documents)) {\n    throw new Error(`bulkSave expects an array of documents to be passed, received \\`${documents}\\` instead`);\n  }\n\n  setDefaultOptions();\n  const discriminatorKey = this.schema.options.discriminatorKey;\n\n  const writeOperations = documents.reduce((accumulator, document, i) => {\n    if (!options.skipValidation) {\n      if (!(document instanceof Document)) {\n        throw new Error(`documents.${i} was not a mongoose document, documents must be an array of mongoose documents (instanceof mongoose.Document).`);\n      }\n      const validationError = document.validateSync();\n      if (validationError) {\n        throw validationError;\n      }\n    }\n\n    const isANewDocument = document.isNew;\n    if (isANewDocument) {\n      const writeOperation = { insertOne: { document } };\n      utils.injectTimestampsOption(writeOperation.insertOne, options.timestamps);\n      accumulator.push(writeOperation);\n\n      return accumulator;\n    }\n\n    const delta = document.$__delta();\n    const isDocumentWithChanges = delta != null && !utils.isEmptyObject(delta[0]);\n\n    if (isDocumentWithChanges) {\n      const where = document.$__where(delta[0]);\n      const changes = delta[1];\n\n      _applyCustomWhere(document, where);\n\n      // Set the discriminator key, so bulk write casting knows which\n      // schema to use re: gh-13907\n      if (document[discriminatorKey] != null && !(discriminatorKey in where)) {\n        where[discriminatorKey] = document[discriminatorKey];\n      }\n\n      document.$__version(where, delta);\n      const writeOperation = { updateOne: { filter: where, update: changes } };\n      utils.injectTimestampsOption(writeOperation.updateOne, options.timestamps);\n      accumulator.push(writeOperation);\n\n      return accumulator;\n    }\n\n    return accumulator;\n  }, []);\n\n  return writeOperations;\n\n\n  function setDefaultOptions() {\n    options = options || {};\n    if (options.skipValidation == null) {\n      options.skipValidation = false;\n    }\n  }\n};\n\n\n/**\n * Shortcut for creating a new Document from existing raw data, pre-saved in the DB.\n * The document returned has no paths marked as modified initially.\n *\n * #### Example:\n *\n *     // hydrate previous data into a Mongoose document\n *     const mongooseCandy = Candy.hydrate({ _id: '54108337212ffb6d459f854c', type: 'jelly bean' });\n *\n * @param {Object} obj\n * @param {Object|String|String[]} [projection] optional projection containing which fields should be selected for this document\n * @param {Object} [options] optional options\n * @param {Boolean} [options.setters=false] if true, apply schema setters when hydrating\n * @return {Document} document instance\n * @api public\n */\n\nModel.hydrate = function(obj, projection, options) {\n  _checkContext(this, 'hydrate');\n\n  if (projection != null) {\n    if (obj != null && obj.$__ != null) {\n      obj = obj.toObject(internalToObjectOptions);\n    }\n    obj = applyProjection(obj, projection);\n  }\n\n  const document = (__webpack_require__(/*! ./queryHelpers */ \"(ssr)/./node_modules/mongoose/lib/queryHelpers.js\").createModel)(this, obj, projection);\n  document.$init(obj, options);\n  return document;\n};\n\n/**\n * Same as `updateOne()`, except MongoDB will update _all_ documents that match\n * `filter` (as opposed to just the first one) regardless of the value of\n * the `multi` option.\n *\n * **Note** updateMany will _not_ fire update middleware. Use `pre('updateMany')`\n * and `post('updateMany')` instead.\n *\n * #### Example:\n *\n *     const res = await Person.updateMany({ name: /Stark$/ }, { isDeleted: true });\n *     res.matchedCount; // Number of documents matched\n *     res.modifiedCount; // Number of documents modified\n *     res.acknowledged; // Boolean indicating everything went smoothly.\n *     res.upsertedId; // null or an id containing a document that had to be upserted.\n *     res.upsertedCount; // Number indicating how many documents had to be upserted. Will either be 0 or 1.\n *\n * This function triggers the following middleware.\n *\n * - `updateMany()`\n *\n * @param {Object} filter\n * @param {Object|Array} update\n * @param {Object} [options] optional see [`Query.prototype.setOptions()`](https://mongoosejs.com/docs/api/query.html#Query.prototype.setOptions())\n * @param {Boolean|String} [options.strict] overwrites the schema's [strict mode option](https://mongoosejs.com/docs/guide.html#strict)\n * @param {Boolean} [options.upsert=false] if true, and no documents found, insert a new document\n * @param {Object} [options.writeConcern=null] sets the [write concern](https://www.mongodb.com/docs/manual/reference/write-concern/) for replica sets. Overrides the [schema-level write concern](https://mongoosejs.com/docs/guide.html#writeConcern)\n * @param {Boolean} [options.timestamps=null] If set to `false` and [schema-level timestamps](https://mongoosejs.com/docs/guide.html#timestamps) are enabled, skip timestamps for this update. Does nothing if schema-level timestamps are not set.\n * @param {Boolean} [options.translateAliases=null] If set to `true`, translates any schema-defined aliases in `filter`, `projection`, `update`, and `distinct`. Throws an error if there are any conflicts where both alias and raw property are defined on the same object.\n * @return {Query}\n * @see Query docs https://mongoosejs.com/docs/queries.html\n * @see MongoDB docs https://www.mongodb.com/docs/manual/reference/command/update/#update-command-output\n * @see UpdateResult https://mongodb.github.io/node-mongodb-native/4.9/interfaces/UpdateResult.html\n * @api public\n */\n\nModel.updateMany = function updateMany(conditions, doc, options) {\n  _checkContext(this, 'updateMany');\n\n  return _update(this, 'updateMany', conditions, doc, options);\n};\n\n/**\n * Update _only_ the first document that matches `filter`.\n *\n * - Use `replaceOne()` if you want to overwrite an entire document rather than using atomic operators like `$set`.\n *\n * #### Example:\n *\n *     const res = await Person.updateOne({ name: 'Jean-Luc Picard' }, { ship: 'USS Enterprise' });\n *     res.matchedCount; // Number of documents matched\n *     res.modifiedCount; // Number of documents modified\n *     res.acknowledged; // Boolean indicating everything went smoothly.\n *     res.upsertedId; // null or an id containing a document that had to be upserted.\n *     res.upsertedCount; // Number indicating how many documents had to be upserted. Will either be 0 or 1.\n *\n * This function triggers the following middleware.\n *\n * - `updateOne()`\n *\n * @param {Object} filter\n * @param {Object|Array} update\n * @param {Object} [options] optional see [`Query.prototype.setOptions()`](https://mongoosejs.com/docs/api/query.html#Query.prototype.setOptions())\n * @param {Boolean|String} [options.strict] overwrites the schema's [strict mode option](https://mongoosejs.com/docs/guide.html#strict)\n * @param {Boolean} [options.upsert=false] if true, and no documents found, insert a new document\n * @param {Object} [options.writeConcern=null] sets the [write concern](https://www.mongodb.com/docs/manual/reference/write-concern/) for replica sets. Overrides the [schema-level write concern](https://mongoosejs.com/docs/guide.html#writeConcern)\n * @param {Boolean} [options.timestamps=null] If set to `false` and [schema-level timestamps](https://mongoosejs.com/docs/guide.html#timestamps) are enabled, skip timestamps for this update. Note that this allows you to overwrite timestamps. Does nothing if schema-level timestamps are not set.\n * @param {Boolean} [options.translateAliases=null] If set to `true`, translates any schema-defined aliases in `filter`, `projection`, `update`, and `distinct`. Throws an error if there are any conflicts where both alias and raw property are defined on the same object.\n * @return {Query}\n * @see Query docs https://mongoosejs.com/docs/queries.html\n * @see MongoDB docs https://www.mongodb.com/docs/manual/reference/command/update/#update-command-output\n * @see UpdateResult https://mongodb.github.io/node-mongodb-native/4.9/interfaces/UpdateResult.html\n * @api public\n */\n\nModel.updateOne = function updateOne(conditions, doc, options) {\n  _checkContext(this, 'updateOne');\n\n  return _update(this, 'updateOne', conditions, doc, options);\n};\n\n/**\n * Replace the existing document with the given document (no atomic operators like `$set`).\n *\n * #### Example:\n *\n *     const res = await Person.replaceOne({ _id: 24601 }, { name: 'Jean Valjean' });\n *     res.matchedCount; // Number of documents matched\n *     res.modifiedCount; // Number of documents modified\n *     res.acknowledged; // Boolean indicating everything went smoothly.\n *     res.upsertedId; // null or an id containing a document that had to be upserted.\n *     res.upsertedCount; // Number indicating how many documents had to be upserted. Will either be 0 or 1.\n *\n * This function triggers the following middleware.\n *\n * - `replaceOne()`\n *\n * @param {Object} filter\n * @param {Object} doc\n * @param {Object} [options] optional see [`Query.prototype.setOptions()`](https://mongoosejs.com/docs/api/query.html#Query.prototype.setOptions())\n * @param {Boolean|String} [options.strict] overwrites the schema's [strict mode option](https://mongoosejs.com/docs/guide.html#strict)\n * @param {Boolean} [options.upsert=false] if true, and no documents found, insert a new document\n * @param {Object} [options.writeConcern=null] sets the [write concern](https://www.mongodb.com/docs/manual/reference/write-concern/) for replica sets. Overrides the [schema-level write concern](https://mongoosejs.com/docs/guide.html#writeConcern)\n * @param {Boolean} [options.timestamps=null] If set to `false` and [schema-level timestamps](https://mongoosejs.com/docs/guide.html#timestamps) are enabled, skip timestamps for this update. Does nothing if schema-level timestamps are not set.\n * @param {Boolean} [options.translateAliases=null] If set to `true`, translates any schema-defined aliases in `filter`, `projection`, `update`, and `distinct`. Throws an error if there are any conflicts where both alias and raw property are defined on the same object.\n * @return {Query}\n * @see Query docs https://mongoosejs.com/docs/queries.html\n * @see UpdateResult https://mongodb.github.io/node-mongodb-native/4.9/interfaces/UpdateResult.html\n * @return {Query}\n * @api public\n */\n\nModel.replaceOne = function replaceOne(conditions, doc, options) {\n  _checkContext(this, 'replaceOne');\n\n  const versionKey = this && this.schema && this.schema.options && this.schema.options.versionKey || null;\n  if (versionKey && !doc[versionKey]) {\n    doc[versionKey] = 0;\n  }\n\n  return _update(this, 'replaceOne', conditions, doc, options);\n};\n\n/**\n * Common code for `updateOne()`, `updateMany()`, `replaceOne()`, and `update()`\n * because they need to do the same thing\n * @api private\n */\n\nfunction _update(model, op, conditions, doc, options) {\n  const mq = new model.Query({}, {}, model, model.collection);\n\n  // gh-2406\n  // make local deep copy of conditions\n  if (conditions instanceof Document) {\n    conditions = conditions.toObject();\n  } else {\n    conditions = clone(conditions);\n  }\n  options = typeof options === 'function' ? options : clone(options);\n\n  const versionKey = model &&\n  model.schema &&\n  model.schema.options &&\n  model.schema.options.versionKey || null;\n  decorateUpdateWithVersionKey(doc, options, versionKey);\n\n  return mq[op](conditions, doc, options);\n}\n\n/**\n * Performs [aggregations](https://www.mongodb.com/docs/manual/aggregation/) on the models collection.\n *\n * If a `callback` is passed, the `aggregate` is executed and a `Promise` is returned. If a callback is not passed, the `aggregate` itself is returned.\n *\n * This function triggers the following middleware.\n *\n * - `aggregate()`\n *\n * #### Example:\n *\n *     // Find the max balance of all accounts\n *     const res = await Users.aggregate([\n *       { $group: { _id: null, maxBalance: { $max: '$balance' }}},\n *       { $project: { _id: 0, maxBalance: 1 }}\n *     ]);\n *\n *     console.log(res); // [ { maxBalance: 98000 } ]\n *\n *     // Or use the aggregation pipeline builder.\n *     const res = await Users.aggregate().\n *       group({ _id: null, maxBalance: { $max: '$balance' } }).\n *       project('-id maxBalance').\n *       exec();\n *     console.log(res); // [ { maxBalance: 98 } ]\n *\n * #### Note:\n *\n * - Mongoose does **not** cast aggregation pipelines to the model's schema because `$project` and `$group` operators allow redefining the \"shape\" of the documents at any stage of the pipeline, which may leave documents in an incompatible format. You can use the [mongoose-cast-aggregation plugin](https://github.com/AbdelrahmanHafez/mongoose-cast-aggregation) to enable minimal casting for aggregation pipelines.\n * - The documents returned are plain javascript objects, not mongoose documents (since any shape of document can be returned).\n *\n * #### More About Aggregations:\n *\n * - [Mongoose `Aggregate`](https://mongoosejs.com/docs/api/aggregate.html)\n * - [An Introduction to Mongoose Aggregate](https://masteringjs.io/tutorials/mongoose/aggregate)\n * - [MongoDB Aggregation docs](https://www.mongodb.com/docs/manual/applications/aggregation/)\n *\n * @see Aggregate https://mongoosejs.com/docs/api/aggregate.html#Aggregate()\n * @see MongoDB https://www.mongodb.com/docs/manual/applications/aggregation/\n * @param {Array} [pipeline] aggregation pipeline as an array of objects\n * @param {Object} [options] aggregation options\n * @return {Aggregate}\n * @api public\n */\n\nModel.aggregate = function aggregate(pipeline, options) {\n  _checkContext(this, 'aggregate');\n\n  if (typeof options === 'function' || typeof arguments[2] === 'function') {\n    throw new MongooseError('Model.aggregate() no longer accepts a callback');\n  }\n\n  const aggregate = new Aggregate(pipeline || []);\n  aggregate.model(this);\n  if (options != null) {\n    aggregate.option(options);\n  }\n\n  if (typeof callback === 'undefined') {\n    return aggregate;\n  }\n\n  return aggregate;\n};\n\n/**\n * Casts and validates the given object against this model's schema, passing the\n * given `context` to custom validators.\n *\n * #### Example:\n *\n *     const Model = mongoose.model('Test', Schema({\n *       name: { type: String, required: true },\n *       age: { type: Number, required: true }\n *     });\n *\n *     try {\n *       await Model.validate({ name: null }, ['name'])\n *     } catch (err) {\n *       err instanceof mongoose.Error.ValidationError; // true\n *       Object.keys(err.errors); // ['name']\n *     }\n *\n * @param {Object} obj\n * @param {Object|Array|String} pathsOrOptions\n * @param {Object} [context]\n * @return {Promise<Object>} casted and validated copy of `obj` if validation succeeded\n * @api public\n */\n\nModel.validate = async function validate(obj, pathsOrOptions, context) {\n  if ((arguments.length < 3) || (arguments.length === 3 && typeof arguments[2] === 'function')) {\n    // For convenience, if we're validating a document or an object, make `context` default to\n    // the model so users don't have to always pass `context`, re: gh-10132, gh-10346\n    context = obj;\n  }\n  if (typeof context === 'function' || typeof arguments[3] === 'function') {\n    throw new MongooseError('Model.validate() no longer accepts a callback');\n  }\n\n  let schema = this.schema;\n  const discriminatorKey = schema.options.discriminatorKey;\n  if (schema.discriminators != null && obj != null && obj[discriminatorKey] != null) {\n    schema = getSchemaDiscriminatorByValue(schema, obj[discriminatorKey]) || schema;\n  }\n  let paths = Object.keys(schema.paths);\n\n  if (pathsOrOptions != null) {\n    const _pathsToValidate = typeof pathsOrOptions === 'string' ? new Set(pathsOrOptions.split(' ')) : Array.isArray(pathsOrOptions) ? new Set(pathsOrOptions) : new Set(paths);\n    paths = paths.filter(p => {\n      if (pathsOrOptions.pathsToSkip) {\n        if (Array.isArray(pathsOrOptions.pathsToSkip)) {\n          if (pathsOrOptions.pathsToSkip.find(x => x == p)) {\n            return false;\n          }\n        } else if (typeof pathsOrOptions.pathsToSkip == 'string') {\n          if (pathsOrOptions.pathsToSkip.includes(p)) {\n            return false;\n          }\n        }\n      }\n      const pieces = p.split('.');\n      let cur = pieces[0];\n\n      for (const piece of pieces) {\n        if (_pathsToValidate.has(cur)) {\n          return true;\n        }\n        cur += '.' + piece;\n      }\n\n      return _pathsToValidate.has(p);\n    });\n  }\n\n  for (const path of paths) {\n    const schemaType = schema.path(path);\n    if (!schemaType || !schemaType.$isMongooseArray || schemaType.$isMongooseDocumentArray) {\n      continue;\n    }\n\n    const val = get(obj, path);\n    pushNestedArrayPaths(paths, val, path);\n  }\n\n  let error = null;\n  paths = new Set(paths);\n\n  try {\n    obj = this.castObject(obj);\n  } catch (err) {\n    error = err;\n    for (const key of Object.keys(error.errors || {})) {\n      paths.delete(key);\n    }\n  }\n\n  let remaining = paths.size;\n\n  return new Promise((resolve, reject) => {\n    for (const path of paths) {\n      const schemaType = schema.path(path);\n      if (schemaType == null) {\n        _checkDone();\n        continue;\n      }\n\n      const pieces = path.indexOf('.') === -1 ? [path] : path.split('.');\n      let cur = obj;\n      for (let i = 0; i < pieces.length - 1; ++i) {\n        cur = cur[pieces[i]];\n      }\n\n      const val = get(obj, path, void 0);\n\n      schemaType.doValidate(val, err => {\n        if (err) {\n          error = error || new ValidationError();\n          error.addError(path, err);\n        }\n        _checkDone();\n      }, context, { path: path });\n    }\n\n    function _checkDone() {\n      if (--remaining <= 0) {\n        if (error) {\n          reject(error);\n        } else {\n          resolve(obj);\n        }\n      }\n    }\n  });\n};\n\n/**\n * Populates document references.\n *\n * Changed in Mongoose 6: the model you call `populate()` on should be the\n * \"local field\" model, **not** the \"foreign field\" model.\n *\n * #### Available top-level options:\n *\n * - path: space delimited path(s) to populate\n * - select: optional fields to select\n * - match: optional query conditions to match\n * - model: optional name of the model to use for population\n * - options: optional query options like sort, limit, etc\n * - justOne: optional boolean, if true Mongoose will always set `path` to a document, or `null` if no document was found. If false, Mongoose will always set `path` to an array, which will be empty if no documents are found. Inferred from schema by default.\n * - strictPopulate: optional boolean, set to `false` to allow populating paths that aren't in the schema.\n *\n * #### Example:\n *\n *     const Dog = mongoose.model('Dog', new Schema({ name: String, breed: String }));\n *     const Person = mongoose.model('Person', new Schema({\n *       name: String,\n *       pet: { type: mongoose.ObjectId, ref: 'Dog' }\n *     }));\n *\n *     const pets = await Pet.create([\n *       { name: 'Daisy', breed: 'Beagle' },\n *       { name: 'Einstein', breed: 'Catalan Sheepdog' }\n *     ]);\n *\n *     // populate many plain objects\n *     const users = [\n *       { name: 'John Wick', dog: pets[0]._id },\n *       { name: 'Doc Brown', dog: pets[1]._id }\n *     ];\n *     await User.populate(users, { path: 'dog', select: 'name' });\n *     users[0].dog.name; // 'Daisy'\n *     users[0].dog.breed; // undefined because of `select`\n *\n * @param {Document|Array} docs Either a single document or array of documents to populate.\n * @param {Object|String} options Either the paths to populate or an object specifying all parameters\n * @param {string} [options.path=null] The path to populate.\n * @param {string|PopulateOptions} [options.populate=null] Recursively populate paths in the populated documents. See [deep populate docs](https://mongoosejs.com/docs/populate.html#deep-populate).\n * @param {boolean} [options.retainNullValues=false] By default, Mongoose removes null and undefined values from populated arrays. Use this option to make `populate()` retain `null` and `undefined` array entries.\n * @param {boolean} [options.getters=false] If true, Mongoose will call any getters defined on the `localField`. By default, Mongoose gets the raw value of `localField`. For example, you would need to set this option to `true` if you wanted to [add a `lowercase` getter to your `localField`](https://mongoosejs.com/docs/schematypes.html#schematype-options).\n * @param {boolean} [options.clone=false] When you do `BlogPost.find().populate('author')`, blog posts with the same author will share 1 copy of an `author` doc. Enable this option to make Mongoose clone populated docs before assigning them.\n * @param {Object|Function} [options.match=null] Add an additional filter to the populate query. Can be a filter object containing [MongoDB query syntax](https://www.mongodb.com/docs/manual/tutorial/query-documents/), or a function that returns a filter object.\n * @param {Boolean} [options.skipInvalidIds=false] By default, Mongoose throws a cast error if `localField` and `foreignField` schemas don't line up. If you enable this option, Mongoose will instead filter out any `localField` properties that cannot be casted to `foreignField`'s schema type.\n * @param {Number} [options.perDocumentLimit=null] For legacy reasons, `limit` with `populate()` may give incorrect results because it only executes a single query for every document being populated. If you set `perDocumentLimit`, Mongoose will ensure correct `limit` per document by executing a separate query for each document to `populate()`. For example, `.find().populate({ path: 'test', perDocumentLimit: 2 })` will execute 2 additional queries if `.find()` returns 2 documents.\n * @param {Boolean} [options.strictPopulate=true] Set to false to allow populating paths that aren't defined in the given model's schema.\n * @param {Object} [options.options=null] Additional options like `limit` and `lean`.\n * @param {Function} [options.transform=null] Function that Mongoose will call on every populated document that allows you to transform the populated document.\n * @param {Function} [callback(err,doc)] Optional callback, executed upon completion. Receives `err` and the `doc(s)`.\n * @return {Promise}\n * @api public\n */\n\nModel.populate = async function populate(docs, paths) {\n  _checkContext(this, 'populate');\n  if (typeof paths === 'function' || typeof arguments[2] === 'function') {\n    throw new MongooseError('Model.populate() no longer accepts a callback');\n  }\n  const _this = this;\n  // normalized paths\n  paths = utils.populate(paths);\n  // data that should persist across subPopulate calls\n  const cache = {};\n\n  return new Promise((resolve, reject) => {\n    _populate(_this, docs, paths, cache, (err, res) => {\n      if (err) {\n        return reject(err);\n      }\n      resolve(res);\n    });\n  });\n};\n\n/**\n * Populate helper\n *\n * @param {Model} model the model to use\n * @param {Document|Array} docs Either a single document or array of documents to populate.\n * @param {Object} paths\n * @param {never} cache Unused\n * @param {Function} [callback] Optional callback, executed upon completion. Receives `err` and the `doc(s)`.\n * @return {Function}\n * @api private\n */\n\nfunction _populate(model, docs, paths, cache, callback) {\n  let pending = paths.length;\n  if (paths.length === 0) {\n    return callback(null, docs);\n  }\n  // each path has its own query options and must be executed separately\n  for (const path of paths) {\n    populate(model, docs, path, next);\n  }\n\n  function next(err) {\n    if (err) {\n      return callback(err, null);\n    }\n    if (--pending) {\n      return;\n    }\n    callback(null, docs);\n  }\n}\n\n/*!\n * Populates `docs`\n */\nconst excludeIdReg = /\\s?-_id\\s?/;\nconst excludeIdRegGlobal = /\\s?-_id\\s?/g;\n\nfunction populate(model, docs, options, callback) {\n  const populateOptions = options;\n  if (options.strictPopulate == null) {\n    if (options._localModel != null && options._localModel.schema._userProvidedOptions.strictPopulate != null) {\n      populateOptions.strictPopulate = options._localModel.schema._userProvidedOptions.strictPopulate;\n    } else if (options._localModel != null && model.base.options.strictPopulate != null) {\n      populateOptions.strictPopulate = model.base.options.strictPopulate;\n    } else if (model.base.options.strictPopulate != null) {\n      populateOptions.strictPopulate = model.base.options.strictPopulate;\n    }\n  }\n\n  // normalize single / multiple docs passed\n  if (!Array.isArray(docs)) {\n    docs = [docs];\n  }\n  if (docs.length === 0 || docs.every(utils.isNullOrUndefined)) {\n    return callback();\n  }\n\n  const modelsMap = getModelsMapForPopulate(model, docs, populateOptions);\n\n  if (modelsMap instanceof MongooseError) {\n    return immediate(function() {\n      callback(modelsMap);\n    });\n  }\n  const len = modelsMap.length;\n  let vals = [];\n\n  function flatten(item) {\n    // no need to include undefined values in our query\n    return undefined !== item;\n  }\n\n  let _remaining = len;\n  let hasOne = false;\n  const params = [];\n  for (let i = 0; i < len; ++i) {\n    const mod = modelsMap[i];\n    let select = mod.options.select;\n    let ids = utils.array.flatten(mod.ids, flatten);\n    ids = utils.array.unique(ids);\n\n    const assignmentOpts = {};\n    assignmentOpts.sort = mod &&\n      mod.options &&\n      mod.options.options &&\n      mod.options.options.sort || void 0;\n    assignmentOpts.excludeId = excludeIdReg.test(select) || (select && select._id === 0);\n\n    // Lean transform may delete `_id`, which would cause assignment\n    // to fail. So delay running lean transform until _after_\n    // `_assign()`\n    if (mod.options &&\n        mod.options.options &&\n        mod.options.options.lean &&\n        mod.options.options.lean.transform) {\n      mod.options.options._leanTransform = mod.options.options.lean.transform;\n      mod.options.options.lean = true;\n    }\n\n    if (ids.length === 0 || ids.every(utils.isNullOrUndefined)) {\n      // Ensure that we set to 0 or empty array even\n      // if we don't actually execute a query to make sure there's a value\n      // and we know this path was populated for future sets. See gh-7731, gh-8230\n      --_remaining;\n      _assign(model, [], mod, assignmentOpts);\n      continue;\n    }\n\n    hasOne = true;\n    if (typeof populateOptions.foreignField === 'string') {\n      mod.foreignField.clear();\n      mod.foreignField.add(populateOptions.foreignField);\n    }\n    const match = createPopulateQueryFilter(ids, mod.match, mod.foreignField, mod.model, mod.options.skipInvalidIds);\n    if (assignmentOpts.excludeId) {\n      // override the exclusion from the query so we can use the _id\n      // for document matching during assignment. we'll delete the\n      // _id back off before returning the result.\n      if (typeof select === 'string') {\n        select = select.replace(excludeIdRegGlobal, ' ');\n      } else {\n        // preserve original select conditions by copying\n        select = utils.object.shallowCopy(select);\n        delete select._id;\n      }\n    }\n\n    if (mod.options.options && mod.options.options.limit != null) {\n      assignmentOpts.originalLimit = mod.options.options.limit;\n    } else if (mod.options.limit != null) {\n      assignmentOpts.originalLimit = mod.options.limit;\n    }\n    params.push([mod, match, select, assignmentOpts, _next]);\n  }\n  if (!hasOne) {\n    // If models but no docs, skip further deep populate.\n    if (modelsMap.length !== 0) {\n      return callback();\n    }\n    // If no models to populate but we have a nested populate,\n    // keep trying, re: gh-8946\n    if (populateOptions.populate != null) {\n      const opts = utils.populate(populateOptions.populate).map(pop => Object.assign({}, pop, {\n        path: populateOptions.path + '.' + pop.path\n      }));\n      model.populate(docs, opts).then(res => { callback(null, res); }, err => { callback(err); });\n      return;\n    }\n    return callback();\n  }\n\n  for (const arr of params) {\n    _execPopulateQuery.apply(null, arr);\n  }\n  function _next(err, valsFromDb) {\n    if (err != null) {\n      return callback(err, null);\n    }\n    vals = vals.concat(valsFromDb);\n    if (--_remaining === 0) {\n      _done();\n    }\n  }\n\n  function _done() {\n    for (const arr of params) {\n      const mod = arr[0];\n      const assignmentOpts = arr[3];\n      for (const val of vals) {\n        mod.options._childDocs.push(val);\n      }\n      try {\n        _assign(model, vals, mod, assignmentOpts);\n      } catch (err) {\n        return callback(err);\n      }\n    }\n\n    for (const arr of params) {\n      removeDeselectedForeignField(arr[0].foreignField, arr[0].options, vals);\n    }\n    for (const arr of params) {\n      const mod = arr[0];\n      if (mod.options && mod.options.options && mod.options.options._leanTransform) {\n        for (const doc of vals) {\n          mod.options.options._leanTransform(doc);\n        }\n      }\n    }\n    callback();\n  }\n}\n\n/*!\n * ignore\n */\n\nfunction _execPopulateQuery(mod, match, select, assignmentOpts, callback) {\n  let subPopulate = clone(mod.options.populate);\n  const queryOptions = Object.assign({\n    skip: mod.options.skip,\n    limit: mod.options.limit,\n    perDocumentLimit: mod.options.perDocumentLimit\n  }, mod.options.options);\n\n  if (mod.count) {\n    delete queryOptions.skip;\n  }\n\n  if (queryOptions.perDocumentLimit != null) {\n    queryOptions.limit = queryOptions.perDocumentLimit;\n    delete queryOptions.perDocumentLimit;\n  } else if (queryOptions.limit != null) {\n    queryOptions.limit = queryOptions.limit * mod.ids.length;\n  }\n\n  const query = mod.model.find(match, select, queryOptions);\n  // If we're doing virtual populate and projection is inclusive and foreign\n  // field is not selected, automatically select it because mongoose needs it.\n  // If projection is exclusive and client explicitly unselected the foreign\n  // field, that's the client's fault.\n  for (const foreignField of mod.foreignField) {\n    if (foreignField !== '_id' &&\n        query.selectedInclusively() &&\n        !isPathSelectedInclusive(query._fields, foreignField)) {\n      query.select(foreignField);\n    }\n  }\n\n  // If using count, still need the `foreignField` so we can match counts\n  // to documents, otherwise we would need a separate `count()` for every doc.\n  if (mod.count) {\n    for (const foreignField of mod.foreignField) {\n      query.select(foreignField);\n    }\n  }\n\n  // If we need to sub-populate, call populate recursively\n  if (subPopulate) {\n    // If subpopulating on a discriminator, skip check for non-existent\n    // paths. Because the discriminator may not have the path defined.\n    if (mod.model.baseModelName != null) {\n      if (Array.isArray(subPopulate)) {\n        subPopulate.forEach(pop => { pop.strictPopulate = false; });\n      } else if (typeof subPopulate === 'string') {\n        subPopulate = { path: subPopulate, strictPopulate: false };\n      } else {\n        subPopulate.strictPopulate = false;\n      }\n    }\n    const basePath = mod.options._fullPath || mod.options.path;\n\n    if (Array.isArray(subPopulate)) {\n      for (const pop of subPopulate) {\n        pop._fullPath = basePath + '.' + pop.path;\n      }\n    } else if (typeof subPopulate === 'object') {\n      subPopulate._fullPath = basePath + '.' + subPopulate.path;\n    }\n\n    query.populate(subPopulate);\n  }\n\n  query.exec().then(\n    docs => {\n      for (const val of docs) {\n        leanPopulateMap.set(val, mod.model);\n      }\n      callback(null, docs);\n    },\n    err => {\n      callback(err);\n    }\n  );\n}\n\n/*!\n * ignore\n */\n\nfunction _assign(model, vals, mod, assignmentOpts) {\n  const options = mod.options;\n  const isVirtual = mod.isVirtual;\n  const justOne = mod.justOne;\n  let _val;\n  const lean = options &&\n    options.options &&\n    options.options.lean || false;\n  const len = vals.length;\n  const rawOrder = {};\n  const rawDocs = {};\n  let key;\n  let val;\n\n  // Clone because `assignRawDocsToIdStructure` will mutate the array\n  const allIds = clone(mod.allIds);\n  // optimization:\n  // record the document positions as returned by\n  // the query result.\n  for (let i = 0; i < len; i++) {\n    val = vals[i];\n    if (val == null) {\n      continue;\n    }\n    for (const foreignField of mod.foreignField) {\n      _val = utils.getValue(foreignField, val);\n      if (Array.isArray(_val)) {\n        _val = utils.array.unique(utils.array.flatten(_val));\n\n        for (let __val of _val) {\n          if (__val instanceof Document) {\n            __val = __val._id;\n          }\n          key = String(__val);\n          if (rawDocs[key]) {\n            if (Array.isArray(rawDocs[key])) {\n              rawDocs[key].push(val);\n              rawOrder[key].push(i);\n            } else {\n              rawDocs[key] = [rawDocs[key], val];\n              rawOrder[key] = [rawOrder[key], i];\n            }\n          } else {\n            if (isVirtual && !justOne) {\n              rawDocs[key] = [val];\n              rawOrder[key] = [i];\n            } else {\n              rawDocs[key] = val;\n              rawOrder[key] = i;\n            }\n          }\n        }\n      } else {\n        if (_val instanceof Document) {\n          _val = _val._id;\n        }\n        key = String(_val);\n        if (rawDocs[key]) {\n          if (Array.isArray(rawDocs[key])) {\n            rawDocs[key].push(val);\n            rawOrder[key].push(i);\n          } else if (isVirtual ||\n            rawDocs[key].constructor !== val.constructor ||\n            String(rawDocs[key]._id) !== String(val._id)) {\n            // May need to store multiple docs with the same id if there's multiple models\n            // if we have discriminators or a ref function. But avoid converting to an array\n            // if we have multiple queries on the same model because of `perDocumentLimit` re: gh-9906\n            rawDocs[key] = [rawDocs[key], val];\n            rawOrder[key] = [rawOrder[key], i];\n          }\n        } else {\n          rawDocs[key] = val;\n          rawOrder[key] = i;\n        }\n      }\n      // flag each as result of population\n      if (!lean) {\n        val.$__.wasPopulated = val.$__.wasPopulated || true;\n      }\n    }\n  }\n\n  assignVals({\n    originalModel: model,\n    // If virtual, make sure to not mutate original field\n    rawIds: mod.isVirtual ? allIds : mod.allIds,\n    allIds: allIds,\n    unpopulatedValues: mod.unpopulatedValues,\n    foreignField: mod.foreignField,\n    rawDocs: rawDocs,\n    rawOrder: rawOrder,\n    docs: mod.docs,\n    path: options.path,\n    options: assignmentOpts,\n    justOne: mod.justOne,\n    isVirtual: mod.isVirtual,\n    allOptions: mod,\n    populatedModel: mod.model,\n    lean: lean,\n    virtual: mod.virtual,\n    count: mod.count,\n    match: mod.match\n  });\n}\n\n/**\n * Compiler utility.\n *\n * @param {String|Function} name model name or class extending Model\n * @param {Schema} schema\n * @param {String} collectionName\n * @param {Connection} connection\n * @param {Mongoose} base mongoose instance\n * @api private\n */\n\nModel.compile = function compile(name, schema, collectionName, connection, base) {\n  const versioningEnabled = schema.options.versionKey !== false;\n\n  if (versioningEnabled && !schema.paths[schema.options.versionKey]) {\n    // add versioning to top level documents only\n    const o = {};\n    o[schema.options.versionKey] = Number;\n    schema.add(o);\n  }\n  let model;\n  if (typeof name === 'function' && name.prototype instanceof Model) {\n    model = name;\n    name = model.name;\n    schema.loadClass(model, false);\n    model.prototype.$isMongooseModelPrototype = true;\n  } else {\n    // generate new class\n    model = function model(doc, fields, skipId) {\n      model.hooks.execPreSync('createModel', doc);\n      if (!(this instanceof model)) {\n        return new model(doc, fields, skipId);\n      }\n      const discriminatorKey = model.schema.options.discriminatorKey;\n\n      if (model.discriminators == null || doc == null || doc[discriminatorKey] == null) {\n        Model.call(this, doc, fields, skipId);\n        return;\n      }\n\n      // If discriminator key is set, use the discriminator instead (gh-7586)\n      const Discriminator = model.discriminators[doc[discriminatorKey]] ||\n        getDiscriminatorByValue(model.discriminators, doc[discriminatorKey]);\n      if (Discriminator != null) {\n        return new Discriminator(doc, fields, skipId);\n      }\n\n      // Otherwise, just use the top-level model\n      Model.call(this, doc, fields, skipId);\n    };\n  }\n\n  model.hooks = schema.s.hooks.clone();\n  model.base = base;\n  model.modelName = name;\n\n  if (!(model.prototype instanceof Model)) {\n    Object.setPrototypeOf(model, Model);\n    Object.setPrototypeOf(model.prototype, Model.prototype);\n  }\n  model.model = function model(name) {\n    return this.db.model(name);\n  };\n\n  model.db = connection;\n  model.prototype.db = connection;\n  model.prototype[modelDbSymbol] = connection;\n  model.discriminators = model.prototype.discriminators = undefined;\n  model[modelSymbol] = true;\n  model.events = new EventEmitter();\n\n  schema._preCompile();\n\n  const _userProvidedOptions = schema._userProvidedOptions || {};\n\n  const collectionOptions = {\n    schemaUserProvidedOptions: _userProvidedOptions,\n    capped: schema.options.capped,\n    Promise: model.base.Promise,\n    modelName: name\n  };\n  if (schema.options.autoCreate !== void 0) {\n    collectionOptions.autoCreate = schema.options.autoCreate;\n  }\n\n  const collection = connection.collection(\n    collectionName,\n    collectionOptions\n  );\n\n  model.prototype.collection = collection;\n  model.prototype.$collection = collection;\n  model.prototype[modelCollectionSymbol] = collection;\n\n  model.prototype.$__setSchema(schema);\n\n  // apply methods and statics\n  applyMethods(model, schema);\n  applyStatics(model, schema);\n  applyHooks(model, schema);\n  applyStaticHooks(model, schema.s.hooks, schema.statics);\n\n  model.schema = model.prototype.$__schema;\n  model.collection = collection;\n  model.$__collection = collection;\n\n  // Create custom query constructor\n  model.Query = function() {\n    Query.apply(this, arguments);\n  };\n  Object.setPrototypeOf(model.Query.prototype, Query.prototype);\n  model.Query.base = Query.base;\n  model.Query.prototype.constructor = Query;\n  applyQueryMiddleware(model.Query, model);\n  applyQueryMethods(model, schema.query);\n\n  return model;\n};\n\n/**\n * Register custom query methods for this model\n *\n * @param {Model} model\n * @param {Schema} schema\n * @api private\n */\n\nfunction applyQueryMethods(model, methods) {\n  for (const i in methods) {\n    model.Query.prototype[i] = methods[i];\n  }\n}\n\n/**\n * Subclass this model with `conn`, `schema`, and `collection` settings.\n *\n * @param {Connection} conn\n * @param {Schema} [schema]\n * @param {String} [collection]\n * @return {Model}\n * @api private\n * @memberOf Model\n * @static\n * @method __subclass\n */\n\nModel.__subclass = function subclass(conn, schema, collection) {\n  // subclass model using this connection and collection name\n  const _this = this;\n\n  const Model = function Model(doc, fields, skipId) {\n    if (!(this instanceof Model)) {\n      return new Model(doc, fields, skipId);\n    }\n    _this.call(this, doc, fields, skipId);\n  };\n\n  Object.setPrototypeOf(Model, _this);\n  Object.setPrototypeOf(Model.prototype, _this.prototype);\n  Model.db = conn;\n  Model.prototype.db = conn;\n  Model.prototype[modelDbSymbol] = conn;\n\n  _this[subclassedSymbol] = _this[subclassedSymbol] || [];\n  _this[subclassedSymbol].push(Model);\n  if (_this.discriminators != null) {\n    Model.discriminators = {};\n    for (const key of Object.keys(_this.discriminators)) {\n      Model.discriminators[key] = _this.discriminators[key].\n        __subclass(_this.db, _this.discriminators[key].schema, collection);\n    }\n  }\n\n  const s = schema && typeof schema !== 'string'\n    ? schema\n    : _this.prototype.$__schema;\n\n  const options = s.options || {};\n  const _userProvidedOptions = s._userProvidedOptions || {};\n\n  if (!collection) {\n    collection = _this.prototype.$__schema.get('collection') ||\n      utils.toCollectionName(_this.modelName, this.base.pluralize());\n  }\n\n  const collectionOptions = {\n    schemaUserProvidedOptions: _userProvidedOptions,\n    capped: s && options.capped\n  };\n\n  Model.prototype.collection = conn.collection(collection, collectionOptions);\n  Model.prototype.$collection = Model.prototype.collection;\n  Model.prototype[modelCollectionSymbol] = Model.prototype.collection;\n  Model.collection = Model.prototype.collection;\n  Model.$__collection = Model.collection;\n  // Errors handled internally, so ignore\n  Model.init().catch(() => {});\n  return Model;\n};\n\n/**\n * Helper for console.log. Given a model named 'MyModel', returns the string\n * `'Model { MyModel }'`.\n *\n * #### Example:\n *\n *     const MyModel = mongoose.model('Test', Schema({ name: String }));\n *     MyModel.inspect(); // 'Model { Test }'\n *     console.log(MyModel); // Prints 'Model { Test }'\n *\n * @api public\n */\n\nModel.inspect = function() {\n  return `Model { ${this.modelName} }`;\n};\n\nif (util.inspect.custom) {\n  // Avoid Node deprecation warning DEP0079\n  Model[util.inspect.custom] = Model.inspect;\n}\n\n/*!\n * Module exports.\n */\n\nmodule.exports = exports = Model;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbW9uZ29vc2UvbGliL21vZGVsLmpzIiwibWFwcGluZ3MiOiJBQUFhOztBQUViO0FBQ0E7QUFDQTs7QUFFQSxrQkFBa0IsbUJBQU8sQ0FBQyxtRUFBYTtBQUN2QyxxQkFBcUIsbUJBQU8sQ0FBQyx1RkFBdUI7QUFDcEQsaUJBQWlCLG1CQUFPLENBQUMsaUVBQVk7QUFDckMsOEJBQThCLG1CQUFPLENBQUMsNkVBQWtCO0FBQ3hELDRCQUE0QixtQkFBTyxDQUFDLHlGQUF3QjtBQUM1RCxxQkFBcUIsMERBQThCO0FBQ25ELGVBQWUsbUJBQU8sQ0FBQyxvREFBUTtBQUMvQix1QkFBdUIsbUJBQU8sQ0FBQyx5RUFBZ0I7QUFDL0Msc0JBQXNCLG1CQUFPLENBQUMsdUVBQWU7QUFDN0MsNEJBQTRCLG1CQUFPLENBQUMseUZBQXdCO0FBQzVELGNBQWMsbUJBQU8sQ0FBQywyREFBUztBQUMvQixvQkFBb0IsbUJBQU8sQ0FBQyx1RkFBdUI7QUFDbkQsZUFBZSxtQkFBTyxDQUFDLDZEQUFVO0FBQ2pDLHdCQUF3QixtQkFBTyxDQUFDLGlGQUFvQjtBQUNwRCxxQkFBcUIsbUJBQU8sQ0FBQywyRUFBaUI7QUFDOUMsMEJBQTBCLG1CQUFPLENBQUMscUZBQXNCO0FBQ3hELDRCQUE0QixtQkFBTyxDQUFDLDZHQUFrQztBQUN0RSw0QkFBNEIsbUJBQU8sQ0FBQyxtSEFBcUM7QUFDekUsNkJBQTZCLG1CQUFPLENBQUMscUhBQXNDO0FBQzNFLG1CQUFtQixtQkFBTyxDQUFDLGlHQUE0QjtBQUN2RCxxQkFBcUIsbUJBQU8sQ0FBQyxxR0FBOEI7QUFDM0Qsd0JBQXdCLG1CQUFPLENBQUMscUhBQXNDO0FBQ3RFLDZCQUE2QixtQkFBTyxDQUFDLHlIQUF3QztBQUM3RSx5QkFBeUIsbUJBQU8sQ0FBQyw2R0FBa0M7QUFDbkUscUJBQXFCLG1CQUFPLENBQUMscUdBQThCO0FBQzNELDBCQUEwQixtQkFBTyxDQUFDLGlIQUFvQztBQUN0RSxtQkFBbUIsbUJBQU8s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QUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0IsNkJBQTZCO0FBQzVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0Esb0RBQW9EO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5Qiw2QkFBNkI7QUFDdEQsT0FBTztBQUNQO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FB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QUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0Esc0JBQXNCOztBQUV0QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNENBQTRDO0FBQzVDO0FBQ0EsWUFBWSxPQUFPO0FBQ25CO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSwrRUFBK0U7QUFDL0UsS0FBSztBQUNMLEdBQUc7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O0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLGlCQUFpQjtBQUM1QixXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsWUFBWTtBQUN2QixXQUFXLFVBQVU7QUFDckI7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQixXQUFXLFFBQVE7QUFDbkI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsWUFBWTtBQUN2QixXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCO0FBQzdCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGFBQWEsU0FBUztBQUN0QjtBQUNBO0FBQ0E7QUFDQSx1REFBdUQsY0FBYztBQUNyRSwwQkFBMEIsWUFBWSxNQUFNO0FBQzVDLDZCQUE2QixtQkFBbUIsTUFBTTtBQUN0RDtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxrQkFBa0IsRUFBRSxpQkFBaUI7QUFDckM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vYXBwMS8uL25vZGVfbW9kdWxlcy9tb25nb29zZS9saWIvbW9kZWwuanM/N2I1ZiJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbi8qIVxuICogTW9kdWxlIGRlcGVuZGVuY2llcy5cbiAqL1xuXG5jb25zdCBBZ2dyZWdhdGUgPSByZXF1aXJlKCcuL2FnZ3JlZ2F0ZScpO1xuY29uc3QgQ2hhbmdlU3RyZWFtID0gcmVxdWlyZSgnLi9jdXJzb3IvY2hhbmdlU3RyZWFtJyk7XG5jb25zdCBEb2N1bWVudCA9IHJlcXVpcmUoJy4vZG9jdW1lbnQnKTtcbmNvbnN0IERvY3VtZW50Tm90Rm91bmRFcnJvciA9IHJlcXVpcmUoJy4vZXJyb3Ivbm90Rm91bmQnKTtcbmNvbnN0IERpdmVyZ2VudEFycmF5RXJyb3IgPSByZXF1aXJlKCcuL2Vycm9yL2RpdmVyZ2VudEFycmF5Jyk7XG5jb25zdCBFdmVudEVtaXR0ZXIgPSByZXF1aXJlKCdldmVudHMnKS5FdmVudEVtaXR0ZXI7XG5jb25zdCBLYXJlZW0gPSByZXF1aXJlKCdrYXJlZW0nKTtcbmNvbnN0IE1vbmdvb3NlQnVmZmVyID0gcmVxdWlyZSgnLi90eXBlcy9idWZmZXInKTtcbmNvbnN0IE1vbmdvb3NlRXJyb3IgPSByZXF1aXJlKCcuL2Vycm9yL2luZGV4Jyk7XG5jb25zdCBPdmVyd3JpdGVNb2RlbEVycm9yID0gcmVxdWlyZSgnLi9lcnJvci9vdmVyd3JpdGVNb2RlbCcpO1xuY29uc3QgUXVlcnkgPSByZXF1aXJlKCcuL3F1ZXJ5Jyk7XG5jb25zdCBTYXZlT3B0aW9ucyA9IHJlcXVpcmUoJy4vb3B0aW9ucy9zYXZlT3B0aW9ucycpO1xuY29uc3QgU2NoZW1hID0gcmVxdWlyZSgnLi9zY2hlbWEnKTtcbmNvbnN0IFZhbGlkYXRpb25FcnJvciA9IHJlcXVpcmUoJy4vZXJyb3IvdmFsaWRhdGlvbicpO1xuY29uc3QgVmVyc2lvbkVycm9yID0gcmVxdWlyZSgnLi9lcnJvci92ZXJzaW9uJyk7XG5jb25zdCBQYXJhbGxlbFNhdmVFcnJvciA9IHJlcXVpcmUoJy4vZXJyb3IvcGFyYWxsZWxTYXZlJyk7XG5jb25zdCBhcHBseURlZmF1bHRzSGVscGVyID0gcmVxdWlyZSgnLi9oZWxwZXJzL2RvY3VtZW50L2FwcGx5RGVmYXVsdHMnKTtcbmNvbnN0IGFwcGx5RGVmYXVsdHNUb1BPSk8gPSByZXF1aXJlKCcuL2hlbHBlcnMvbW9kZWwvYXBwbHlEZWZhdWx0c1RvUE9KTycpO1xuY29uc3QgYXBwbHlRdWVyeU1pZGRsZXdhcmUgPSByZXF1aXJlKCcuL2hlbHBlcnMvcXVlcnkvYXBwbHlRdWVyeU1pZGRsZXdhcmUnKTtcbmNvbnN0IGFwcGx5SG9va3MgPSByZXF1aXJlKCcuL2hlbHBlcnMvbW9kZWwvYXBwbHlIb29rcycpO1xuY29uc3QgYXBwbHlNZXRob2RzID0gcmVxdWlyZSgnLi9oZWxwZXJzL21vZGVsL2FwcGx5TWV0aG9kcycpO1xuY29uc3QgYXBwbHlQcm9qZWN0aW9uID0gcmVxdWlyZSgnLi9oZWxwZXJzL3Byb2plY3Rpb24vYXBwbHlQcm9qZWN0aW9uJyk7XG5jb25zdCBhcHBseVNjaGVtYUNvbGxhdGlvbiA9IHJlcXVpcmUoJy4vaGVscGVycy9pbmRleGVzL2FwcGx5U2NoZW1hQ29sbGF0aW9uJyk7XG5jb25zdCBhcHBseVN0YXRpY0hvb2tzID0gcmVxdWlyZSgnLi9oZWxwZXJzL21vZGVsL2FwcGx5U3RhdGljSG9va3MnKTtcbmNvbnN0IGFwcGx5U3RhdGljcyA9IHJlcXVpcmUoJy4vaGVscGVycy9tb2RlbC9hcHBseVN0YXRpY3MnKTtcbmNvbnN0IGFwcGx5V3JpdGVDb25jZXJuID0gcmVxdWlyZSgnLi9oZWxwZXJzL3NjaGVtYS9hcHBseVdyaXRlQ29uY2VybicpO1xuY29uc3QgYXNzaWduVmFscyA9IHJlcXVpcmUoJy4vaGVscGVycy9wb3B1bGF0ZS9hc3NpZ25WYWxzJyk7XG5jb25zdCBjYXN0QnVsa1dyaXRlID0gcmVxdWlyZSgnLi9oZWxwZXJzL21vZGVsL2Nhc3RCdWxrV3JpdGUnKTtcbmNvbnN0IGNsb25lID0gcmVxdWlyZSgnLi9oZWxwZXJzL2Nsb25lJyk7XG5jb25zdCBjcmVhdGVQb3B1bGF0ZVF1ZXJ5RmlsdGVyID0gcmVxdWlyZSgnLi9oZWxwZXJzL3BvcHVsYXRlL2NyZWF0ZVBvcHVsYXRlUXVlcnlGaWx0ZXInKTtcbmNvbnN0IGRlY29yYXRlVXBkYXRlV2l0aFZlcnNpb25LZXkgPSByZXF1aXJlKCcuL2hlbHBlcnMvdXBkYXRlL2RlY29yYXRlVXBkYXRlV2l0aFZlcnNpb25LZXknKTtcbmNvbnN0IGdldERlZmF1bHRCdWxrd3JpdGVSZXN1bHQgPSByZXF1aXJlKCcuL2hlbHBlcnMvZ2V0RGVmYXVsdEJ1bGt3cml0ZVJlc3VsdCcpO1xuY29uc3QgZ2V0U2NoZW1hRGlzY3JpbWluYXRvckJ5VmFsdWUgPSByZXF1aXJlKCcuL2hlbHBlcnMvZGlzY3JpbWluYXRvci9nZXRTY2hlbWFEaXNjcmltaW5hdG9yQnlWYWx1ZScpO1xuY29uc3QgZGlzY3JpbWluYXRvciA9IHJlcXVpcmUoJy4vaGVscGVycy9tb2RlbC9kaXNjcmltaW5hdG9yJyk7XG5jb25zdCBmaXJzdEtleSA9IHJlcXVpcmUoJy4vaGVscGVycy9maXJzdEtleScpO1xuY29uc3QgZWFjaCA9IHJlcXVpcmUoJy4vaGVscGVycy9lYWNoJyk7XG5jb25zdCBnZXQgPSByZXF1aXJlKCcuL2hlbHBlcnMvZ2V0Jyk7XG5jb25zdCBnZXRDb25zdHJ1Y3Rvck5hbWUgPSByZXF1aXJlKCcuL2hlbHBlcnMvZ2V0Q29uc3RydWN0b3JOYW1lJyk7XG5jb25zdCBnZXREaXNjcmltaW5hdG9yQnlWYWx1ZSA9IHJlcXVpcmUoJy4vaGVscGVycy9kaXNjcmltaW5hdG9yL2dldERpc2NyaW1pbmF0b3JCeVZhbHVlJyk7XG5jb25zdCBnZXRNb2RlbHNNYXBGb3JQb3B1bGF0ZSA9IHJlcXVpcmUoJy4vaGVscGVycy9wb3B1bGF0ZS9nZXRNb2RlbHNNYXBGb3JQb3B1bGF0ZScpO1xuY29uc3QgaW1tZWRpYXRlID0gcmVxdWlyZSgnLi9oZWxwZXJzL2ltbWVkaWF0ZScpO1xuY29uc3QgaW50ZXJuYWxUb09iamVjdE9wdGlvbnMgPSByZXF1aXJlKCcuL29wdGlvbnMnKS5pbnRlcm5hbFRvT2JqZWN0T3B0aW9ucztcbmNvbnN0IGlzRGVmYXVsdElkSW5kZXggPSByZXF1aXJlKCcuL2hlbHBlcnMvaW5kZXhlcy9pc0RlZmF1bHRJZEluZGV4Jyk7XG5jb25zdCBpc0luZGV4RXF1YWwgPSByZXF1aXJlKCcuL2hlbHBlcnMvaW5kZXhlcy9pc0luZGV4RXF1YWwnKTtcbmNvbnN0IHtcbiAgZ2V0UmVsYXRlZERCSW5kZXhlcyxcbiAgZ2V0UmVsYXRlZFNjaGVtYUluZGV4ZXNcbn0gPSByZXF1aXJlKCcuL2hlbHBlcnMvaW5kZXhlcy9nZXRSZWxhdGVkSW5kZXhlcycpO1xuY29uc3QgaXNQYXRoRXhjbHVkZWQgPSByZXF1aXJlKCcuL2hlbHBlcnMvcHJvamVjdGlvbi9pc1BhdGhFeGNsdWRlZCcpO1xuY29uc3QgZGVjb3JhdGVEaXNjcmltaW5hdG9ySW5kZXhPcHRpb25zID0gcmVxdWlyZSgnLi9oZWxwZXJzL2luZGV4ZXMvZGVjb3JhdGVEaXNjcmltaW5hdG9ySW5kZXhPcHRpb25zJyk7XG5jb25zdCBpc1BhdGhTZWxlY3RlZEluY2x1c2l2ZSA9IHJlcXVpcmUoJy4vaGVscGVycy9wcm9qZWN0aW9uL2lzUGF0aFNlbGVjdGVkSW5jbHVzaXZlJyk7XG5jb25zdCBsZWFuUG9wdWxhdGVNYXAgPSByZXF1aXJlKCcuL2hlbHBlcnMvcG9wdWxhdGUvbGVhblBvcHVsYXRlTWFwJyk7XG5jb25zdCBwYXJhbGxlbExpbWl0ID0gcmVxdWlyZSgnLi9oZWxwZXJzL3BhcmFsbGVsTGltaXQnKTtcbmNvbnN0IHBhcmVudFBhdGhzID0gcmVxdWlyZSgnLi9oZWxwZXJzL3BhdGgvcGFyZW50UGF0aHMnKTtcbmNvbnN0IHByZXBhcmVEaXNjcmltaW5hdG9yUGlwZWxpbmUgPSByZXF1aXJlKCcuL2hlbHBlcnMvYWdncmVnYXRlL3ByZXBhcmVEaXNjcmltaW5hdG9yUGlwZWxpbmUnKTtcbmNvbnN0IHB1c2hOZXN0ZWRBcnJheVBhdGhzID0gcmVxdWlyZSgnLi9oZWxwZXJzL21vZGVsL3B1c2hOZXN0ZWRBcnJheVBhdGhzJyk7XG5jb25zdCByZW1vdmVEZXNlbGVjdGVkRm9yZWlnbkZpZWxkID0gcmVxdWlyZSgnLi9oZWxwZXJzL3BvcHVsYXRlL3JlbW92ZURlc2VsZWN0ZWRGb3JlaWduRmllbGQnKTtcbmNvbnN0IHNldERvdHRlZFBhdGggPSByZXF1aXJlKCcuL2hlbHBlcnMvcGF0aC9zZXREb3R0ZWRQYXRoJyk7XG5jb25zdCBTVEFURVMgPSByZXF1aXJlKCcuL2Nvbm5lY3Rpb25TdGF0ZScpO1xuY29uc3QgdXRpbCA9IHJlcXVpcmUoJ3V0aWwnKTtcbmNvbnN0IHV0aWxzID0gcmVxdWlyZSgnLi91dGlscycpO1xuY29uc3QgTW9uZ29vc2VCdWxrV3JpdGVFcnJvciA9IHJlcXVpcmUoJy4vZXJyb3IvYnVsa1dyaXRlRXJyb3InKTtcbmNvbnN0IG1pbmltaXplID0gcmVxdWlyZSgnLi9oZWxwZXJzL21pbmltaXplJyk7XG5cbmNvbnN0IFZFUlNJT05fV0hFUkUgPSAxO1xuY29uc3QgVkVSU0lPTl9JTkMgPSAyO1xuY29uc3QgVkVSU0lPTl9BTEwgPSBWRVJTSU9OX1dIRVJFIHwgVkVSU0lPTl9JTkM7XG5cbmNvbnN0IGFycmF5QXRvbWljc1N5bWJvbCA9IHJlcXVpcmUoJy4vaGVscGVycy9zeW1ib2xzJykuYXJyYXlBdG9taWNzU3ltYm9sO1xuY29uc3QgbW9kZWxDb2xsZWN0aW9uU3ltYm9sID0gU3ltYm9sKCdtb25nb29zZSNNb2RlbCNjb2xsZWN0aW9uJyk7XG5jb25zdCBtb2RlbERiU3ltYm9sID0gU3ltYm9sKCdtb25nb29zZSNNb2RlbCNkYicpO1xuY29uc3QgbW9kZWxTeW1ib2wgPSByZXF1aXJlKCcuL2hlbHBlcnMvc3ltYm9scycpLm1vZGVsU3ltYm9sO1xuY29uc3Qgc3ViY2xhc3NlZFN5bWJvbCA9IFN5bWJvbCgnbW9uZ29vc2UjTW9kZWwjc3ViY2xhc3NlZCcpO1xuXG5jb25zdCBzYXZlVG9PYmplY3RPcHRpb25zID0gT2JqZWN0LmFzc2lnbih7fSwgaW50ZXJuYWxUb09iamVjdE9wdGlvbnMsIHtcbiAgYnNvbjogdHJ1ZSxcbiAgZmxhdHRlbk9iamVjdElkczogZmFsc2Vcbn0pO1xuXG4vKipcbiAqIEEgTW9kZWwgaXMgYSBjbGFzcyB0aGF0J3MgeW91ciBwcmltYXJ5IHRvb2wgZm9yIGludGVyYWN0aW5nIHdpdGggTW9uZ29EQi5cbiAqIEFuIGluc3RhbmNlIG9mIGEgTW9kZWwgaXMgY2FsbGVkIGEgW0RvY3VtZW50XShodHRwczovL21vbmdvb3NlanMuY29tL2RvY3MvYXBpL2RvY3VtZW50Lmh0bWwjRG9jdW1lbnQpLlxuICpcbiAqIEluIE1vbmdvb3NlLCB0aGUgdGVybSBcIk1vZGVsXCIgcmVmZXJzIHRvIHN1YmNsYXNzZXMgb2YgdGhlIGBtb25nb29zZS5Nb2RlbGBcbiAqIGNsYXNzLiBZb3Ugc2hvdWxkIG5vdCB1c2UgdGhlIGBtb25nb29zZS5Nb2RlbGAgY2xhc3MgZGlyZWN0bHkuIFRoZVxuICogW2Btb25nb29zZS5tb2RlbCgpYF0oaHR0cHM6Ly9tb25nb29zZWpzLmNvbS9kb2NzL2FwaS9tb25nb29zZS5odG1sI01vbmdvb3NlLnByb3RvdHlwZS5tb2RlbCgpKSBhbmRcbiAqIFtgY29ubmVjdGlvbi5tb2RlbCgpYF0oaHR0cHM6Ly9tb25nb29zZWpzLmNvbS9kb2NzL2FwaS9jb25uZWN0aW9uLmh0bWwjQ29ubmVjdGlvbi5wcm90b3R5cGUubW9kZWwoKSkgZnVuY3Rpb25zXG4gKiBjcmVhdGUgc3ViY2xhc3NlcyBvZiBgbW9uZ29vc2UuTW9kZWxgIGFzIHNob3duIGJlbG93LlxuICpcbiAqICMjIyMgRXhhbXBsZTpcbiAqXG4gKiAgICAgLy8gYFVzZXJNb2RlbGAgaXMgYSBcIk1vZGVsXCIsIGEgc3ViY2xhc3Mgb2YgYG1vbmdvb3NlLk1vZGVsYC5cbiAqICAgICBjb25zdCBVc2VyTW9kZWwgPSBtb25nb29zZS5tb2RlbCgnVXNlcicsIG5ldyBTY2hlbWEoeyBuYW1lOiBTdHJpbmcgfSkpO1xuICpcbiAqICAgICAvLyBZb3UgY2FuIHVzZSBhIE1vZGVsIHRvIGNyZWF0ZSBuZXcgZG9jdW1lbnRzIHVzaW5nIGBuZXdgOlxuICogICAgIGNvbnN0IHVzZXJEb2MgPSBuZXcgVXNlck1vZGVsKHsgbmFtZTogJ0ZvbycgfSk7XG4gKiAgICAgYXdhaXQgdXNlckRvYy5zYXZlKCk7XG4gKlxuICogICAgIC8vIFlvdSBhbHNvIHVzZSBhIG1vZGVsIHRvIGNyZWF0ZSBxdWVyaWVzOlxuICogICAgIGNvbnN0IHVzZXJGcm9tRGIgPSBhd2FpdCBVc2VyTW9kZWwuZmluZE9uZSh7IG5hbWU6ICdGb28nIH0pO1xuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBkb2MgdmFsdWVzIGZvciBpbml0aWFsIHNldFxuICogQHBhcmFtIHtPYmplY3R9IFtmaWVsZHNdIG9wdGlvbmFsIG9iamVjdCBjb250YWluaW5nIHRoZSBmaWVsZHMgdGhhdCB3ZXJlIHNlbGVjdGVkIGluIHRoZSBxdWVyeSB3aGljaCByZXR1cm5lZCB0aGlzIGRvY3VtZW50LiBZb3UgZG8gKipub3QqKiBuZWVkIHRvIHNldCB0aGlzIHBhcmFtZXRlciB0byBlbnN1cmUgTW9uZ29vc2UgaGFuZGxlcyB5b3VyIFtxdWVyeSBwcm9qZWN0aW9uXShodHRwczovL21vbmdvb3NlanMuY29tL2RvY3MvYXBpL3F1ZXJ5Lmh0bWwjUXVlcnkucHJvdG90eXBlLnNlbGVjdCgpKS5cbiAqIEBwYXJhbSB7Qm9vbGVhbn0gW3NraXBJZD1mYWxzZV0gb3B0aW9uYWwgYm9vbGVhbi4gSWYgdHJ1ZSwgbW9uZ29vc2UgZG9lc24ndCBhZGQgYW4gYF9pZGAgZmllbGQgdG8gdGhlIGRvY3VtZW50LlxuICogQGluaGVyaXRzIERvY3VtZW50IGh0dHBzOi8vbW9uZ29vc2Vqcy5jb20vZG9jcy9hcGkvZG9jdW1lbnQuaHRtbFxuICogQGV2ZW50IGBlcnJvcmA6IElmIGxpc3RlbmluZyB0byB0aGlzIGV2ZW50LCAnZXJyb3InIGlzIGVtaXR0ZWQgd2hlbiBhIGRvY3VtZW50IHdhcyBzYXZlZCBhbmQgYW4gYGVycm9yYCBvY2N1cnJlZC4gSWYgbm90IGxpc3RlbmluZywgdGhlIGV2ZW50IGJ1YmJsZXMgdG8gdGhlIGNvbm5lY3Rpb24gdXNlZCB0byBjcmVhdGUgdGhpcyBNb2RlbC5cbiAqIEBldmVudCBgaW5kZXhgOiBFbWl0dGVkIGFmdGVyIGBNb2RlbCNlbnN1cmVJbmRleGVzYCBjb21wbGV0ZXMuIElmIGFuIGVycm9yIG9jY3VycmVkIGl0IGlzIHBhc3NlZCB3aXRoIHRoZSBldmVudC5cbiAqIEBldmVudCBgaW5kZXgtc2luZ2xlLXN0YXJ0YDogRW1pdHRlZCB3aGVuIGFuIGluZGl2aWR1YWwgaW5kZXggc3RhcnRzIHdpdGhpbiBgTW9kZWwjZW5zdXJlSW5kZXhlc2AuIFRoZSBmaWVsZHMgYW5kIG9wdGlvbnMgYmVpbmcgdXNlZCB0byBidWlsZCB0aGUgaW5kZXggYXJlIGFsc28gcGFzc2VkIHdpdGggdGhlIGV2ZW50LlxuICogQGV2ZW50IGBpbmRleC1zaW5nbGUtZG9uZWA6IEVtaXR0ZWQgd2hlbiBhbiBpbmRpdmlkdWFsIGluZGV4IGZpbmlzaGVzIHdpdGhpbiBgTW9kZWwjZW5zdXJlSW5kZXhlc2AuIElmIGFuIGVycm9yIG9jY3VycmVkIGl0IGlzIHBhc3NlZCB3aXRoIHRoZSBldmVudC4gVGhlIGZpZWxkcywgb3B0aW9ucywgYW5kIGluZGV4IG5hbWUgYXJlIGFsc28gcGFzc2VkLlxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5mdW5jdGlvbiBNb2RlbChkb2MsIGZpZWxkcywgc2tpcElkKSB7XG4gIGlmIChmaWVsZHMgaW5zdGFuY2VvZiBTY2hlbWEpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCcybmQgYXJndW1lbnQgdG8gYE1vZGVsYCBtdXN0IGJlIGEgUE9KTyBvciBzdHJpbmcsICcgK1xuICAgICAgJyoqbm90KiogYSBzY2hlbWEuIE1ha2Ugc3VyZSB5b3VcXCdyZSBjYWxsaW5nIGBtb25nb29zZS5tb2RlbCgpYCwgbm90ICcgK1xuICAgICAgJ2Btb25nb29zZS5Nb2RlbCgpYC4nKTtcbiAgfVxuICBEb2N1bWVudC5jYWxsKHRoaXMsIGRvYywgZmllbGRzLCBza2lwSWQpO1xufVxuXG4vKipcbiAqIEluaGVyaXRzIGZyb20gRG9jdW1lbnQuXG4gKlxuICogQWxsIE1vZGVsLnByb3RvdHlwZSBmZWF0dXJlcyBhcmUgYXZhaWxhYmxlIG9uXG4gKiB0b3AgbGV2ZWwgKG5vbi1zdWIpIGRvY3VtZW50cy5cbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbk9iamVjdC5zZXRQcm90b3R5cGVPZihNb2RlbC5wcm90b3R5cGUsIERvY3VtZW50LnByb3RvdHlwZSk7XG5Nb2RlbC5wcm90b3R5cGUuJGlzTW9uZ29vc2VNb2RlbFByb3RvdHlwZSA9IHRydWU7XG5cbi8qKlxuICogQ29ubmVjdGlvbiB0aGUgbW9kZWwgdXNlcy5cbiAqXG4gKiBAYXBpIHB1YmxpY1xuICogQHByb3BlcnR5IGRiXG4gKiBAbWVtYmVyT2YgTW9kZWxcbiAqIEBpbnN0YW5jZVxuICovXG5cbk1vZGVsLnByb3RvdHlwZS5kYjtcblxuLyoqXG4gKiBUaGUgY29sbGVjdGlvbiBpbnN0YW5jZSB0aGlzIG1vZGVsIHVzZXMuXG4gKiBBIE1vbmdvb3NlIGNvbGxlY3Rpb24gaXMgYSB0aGluIHdyYXBwZXIgYXJvdW5kIGEgW01vbmdvREIgTm9kZS5qcyBkcml2ZXIgY29sbGVjdGlvbl0oW01vbmdvREIgTm9kZS5qcyBkcml2ZXIgY29sbGVjdGlvbl0oaHR0cHM6Ly9tb25nb2RiLmdpdGh1Yi5pby9ub2RlLW1vbmdvZGItbmF0aXZlL05leHQvY2xhc3Nlcy9Db2xsZWN0aW9uLmh0bWwpKS5cbiAqIFVzaW5nIGBNb2RlbC5jb2xsZWN0aW9uYCBtZWFucyB5b3UgYnlwYXNzIE1vbmdvb3NlIG1pZGRsZXdhcmUsIHZhbGlkYXRpb24sIGFuZCBjYXN0aW5nLlxuICpcbiAqIFRoaXMgcHJvcGVydHkgaXMgcmVhZC1vbmx5LiBNb2RpZnlpbmcgdGhpcyBwcm9wZXJ0eSBpcyBhIG5vLW9wLlxuICpcbiAqIEBhcGkgcHVibGljXG4gKiBAcHJvcGVydHkgY29sbGVjdGlvblxuICogQG1lbWJlck9mIE1vZGVsXG4gKiBAaW5zdGFuY2VcbiAqL1xuXG5Nb2RlbC5wcm90b3R5cGUuY29sbGVjdGlvbjtcblxuLyoqXG4gKiBJbnRlcm5hbCBjb2xsZWN0aW9uIHRoZSBtb2RlbCB1c2VzLlxuICpcbiAqIFRoaXMgcHJvcGVydHkgaXMgcmVhZC1vbmx5LiBNb2RpZnlpbmcgdGhpcyBwcm9wZXJ0eSBpcyBhIG5vLW9wLlxuICpcbiAqIEBhcGkgcHJpdmF0ZVxuICogQHByb3BlcnR5IGNvbGxlY3Rpb25cbiAqIEBtZW1iZXJPZiBNb2RlbFxuICogQGluc3RhbmNlXG4gKi9cblxuXG5Nb2RlbC5wcm90b3R5cGUuJF9fY29sbGVjdGlvbjtcblxuLyoqXG4gKiBUaGUgbmFtZSBvZiB0aGUgbW9kZWxcbiAqXG4gKiBAYXBpIHB1YmxpY1xuICogQHByb3BlcnR5IG1vZGVsTmFtZVxuICogQG1lbWJlck9mIE1vZGVsXG4gKiBAaW5zdGFuY2VcbiAqL1xuXG5Nb2RlbC5wcm90b3R5cGUubW9kZWxOYW1lO1xuXG4vKipcbiAqIEFkZGl0aW9uYWwgcHJvcGVydGllcyB0byBhdHRhY2ggdG8gdGhlIHF1ZXJ5IHdoZW4gY2FsbGluZyBgc2F2ZSgpYCBhbmRcbiAqIGBpc05ld2AgaXMgZmFsc2UuXG4gKlxuICogQGFwaSBwdWJsaWNcbiAqIEBwcm9wZXJ0eSAkd2hlcmVcbiAqIEBtZW1iZXJPZiBNb2RlbFxuICogQGluc3RhbmNlXG4gKi9cblxuTW9kZWwucHJvdG90eXBlLiR3aGVyZTtcblxuLyoqXG4gKiBJZiB0aGlzIGlzIGEgZGlzY3JpbWluYXRvciBtb2RlbCwgYGJhc2VNb2RlbE5hbWVgIGlzIHRoZSBuYW1lIG9mXG4gKiB0aGUgYmFzZSBtb2RlbC5cbiAqXG4gKiBAYXBpIHB1YmxpY1xuICogQHByb3BlcnR5IGJhc2VNb2RlbE5hbWVcbiAqIEBtZW1iZXJPZiBNb2RlbFxuICogQGluc3RhbmNlXG4gKi9cblxuTW9kZWwucHJvdG90eXBlLmJhc2VNb2RlbE5hbWU7XG5cbi8qKlxuICogRXZlbnQgZW1pdHRlciB0aGF0IHJlcG9ydHMgYW55IGVycm9ycyB0aGF0IG9jY3VycmVkLiBVc2VmdWwgZm9yIGdsb2JhbCBlcnJvclxuICogaGFuZGxpbmcuXG4gKlxuICogIyMjIyBFeGFtcGxlOlxuICpcbiAqICAgICBNeU1vZGVsLmV2ZW50cy5vbignZXJyb3InLCBlcnIgPT4gY29uc29sZS5sb2coZXJyLm1lc3NhZ2UpKTtcbiAqXG4gKiAgICAgLy8gUHJpbnRzIGEgJ0Nhc3RFcnJvcicgYmVjYXVzZSBvZiB0aGUgYWJvdmUgaGFuZGxlclxuICogICAgIGF3YWl0IE15TW9kZWwuZmluZE9uZSh7IF9pZDogJ05vdCBhIHZhbGlkIE9iamVjdElkJyB9KS5jYXRjaChub29wKTtcbiAqXG4gKiBAYXBpIHB1YmxpY1xuICogQHByb3BlcnR5IGV2ZW50c1xuICogQGZpcmVzIGVycm9yIHdoZW5ldmVyIGFueSBxdWVyeSBvciBtb2RlbCBmdW5jdGlvbiBlcnJvcnNcbiAqIEBtZW1iZXJPZiBNb2RlbFxuICogQHN0YXRpY1xuICovXG5cbk1vZGVsLmV2ZW50cztcblxuLyoqXG4gKiBDb21waWxlZCBtaWRkbGV3YXJlIGZvciB0aGlzIG1vZGVsLiBTZXQgaW4gYGFwcGx5SG9va3MoKWAuXG4gKlxuICogQGFwaSBwcml2YXRlXG4gKiBAcHJvcGVydHkgX21pZGRsZXdhcmVcbiAqIEBtZW1iZXJPZiBNb2RlbFxuICogQHN0YXRpY1xuICovXG5cbk1vZGVsLl9taWRkbGV3YXJlO1xuXG4vKiFcbiAqIGlnbm9yZVxuICovXG5cbmZ1bmN0aW9uIF9hcHBseUN1c3RvbVdoZXJlKGRvYywgd2hlcmUpIHtcbiAgaWYgKGRvYy4kd2hlcmUgPT0gbnVsbCkge1xuICAgIHJldHVybjtcbiAgfVxuICBmb3IgKGNvbnN0IGtleSBvZiBPYmplY3Qua2V5cyhkb2MuJHdoZXJlKSkge1xuICAgIHdoZXJlW2tleV0gPSBkb2MuJHdoZXJlW2tleV07XG4gIH1cbn1cblxuLyohXG4gKiBpZ25vcmVcbiAqL1xuXG5Nb2RlbC5wcm90b3R5cGUuJF9faGFuZGxlU2F2ZSA9IGZ1bmN0aW9uKG9wdGlvbnMsIGNhbGxiYWNrKSB7XG4gIGNvbnN0IHNhdmVPcHRpb25zID0ge307XG5cbiAgYXBwbHlXcml0ZUNvbmNlcm4odGhpcy4kX19zY2hlbWEsIG9wdGlvbnMpO1xuICBpZiAodHlwZW9mIG9wdGlvbnMud3JpdGVDb25jZXJuICE9PSAndW5kZWZpbmVkJykge1xuICAgIHNhdmVPcHRpb25zLndyaXRlQ29uY2VybiA9IHt9O1xuICAgIGlmICgndycgaW4gb3B0aW9ucy53cml0ZUNvbmNlcm4pIHtcbiAgICAgIHNhdmVPcHRpb25zLndyaXRlQ29uY2Vybi53ID0gb3B0aW9ucy53cml0ZUNvbmNlcm4udztcbiAgICB9XG4gICAgaWYgKCdqJyBpbiBvcHRpb25zLndyaXRlQ29uY2Vybikge1xuICAgICAgc2F2ZU9wdGlvbnMud3JpdGVDb25jZXJuLmogPSBvcHRpb25zLndyaXRlQ29uY2Vybi5qO1xuICAgIH1cbiAgICBpZiAoJ3d0aW1lb3V0JyBpbiBvcHRpb25zLndyaXRlQ29uY2Vybikge1xuICAgICAgc2F2ZU9wdGlvbnMud3JpdGVDb25jZXJuLnd0aW1lb3V0ID0gb3B0aW9ucy53cml0ZUNvbmNlcm4ud3RpbWVvdXQ7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGlmICgndycgaW4gb3B0aW9ucykge1xuICAgICAgc2F2ZU9wdGlvbnMudyA9IG9wdGlvbnMudztcbiAgICB9XG4gICAgaWYgKCdqJyBpbiBvcHRpb25zKSB7XG4gICAgICBzYXZlT3B0aW9ucy5qID0gb3B0aW9ucy5qO1xuICAgIH1cbiAgICBpZiAoJ3d0aW1lb3V0JyBpbiBvcHRpb25zKSB7XG4gICAgICBzYXZlT3B0aW9ucy53dGltZW91dCA9IG9wdGlvbnMud3RpbWVvdXQ7XG4gICAgfVxuICB9XG4gIGlmICgnY2hlY2tLZXlzJyBpbiBvcHRpb25zKSB7XG4gICAgc2F2ZU9wdGlvbnMuY2hlY2tLZXlzID0gb3B0aW9ucy5jaGVja0tleXM7XG4gIH1cblxuICBjb25zdCBzZXNzaW9uID0gdGhpcy4kc2Vzc2lvbigpO1xuICBpZiAoIXNhdmVPcHRpb25zLmhhc093blByb3BlcnR5KCdzZXNzaW9uJykgJiYgc2Vzc2lvbiAhPSBudWxsKSB7XG4gICAgc2F2ZU9wdGlvbnMuc2Vzc2lvbiA9IHNlc3Npb247XG4gIH1cblxuICBpZiAodGhpcy4kaXNOZXcpIHtcbiAgICAvLyBzZW5kIGVudGlyZSBkb2NcbiAgICBjb25zdCBvYmogPSB0aGlzLnRvT2JqZWN0KHNhdmVUb09iamVjdE9wdGlvbnMpO1xuICAgIGlmICgob2JqIHx8IHt9KS5faWQgPT09IHZvaWQgMCkge1xuICAgICAgLy8gZG9jdW1lbnRzIG11c3QgaGF2ZSBhbiBfaWQgZWxzZSBtb25nb29zZSB3b24ndCBrbm93XG4gICAgICAvLyB3aGF0IHRvIHVwZGF0ZSBsYXRlciBpZiBtb3JlIGNoYW5nZXMgYXJlIG1hZGUuIHRoZSB1c2VyXG4gICAgICAvLyB3b3VsZG4ndCBrbm93IHdoYXQgX2lkIHdhcyBnZW5lcmF0ZWQgYnkgbW9uZ29kYiBlaXRoZXJcbiAgICAgIC8vIG5vciB3b3VsZCB0aGUgT2JqZWN0SWQgZ2VuZXJhdGVkIGJ5IG1vbmdvZGIgbmVjZXNzYXJpbHlcbiAgICAgIC8vIG1hdGNoIHRoZSBzY2hlbWEgZGVmaW5pdGlvbi5cbiAgICAgIGltbWVkaWF0ZShmdW5jdGlvbigpIHtcbiAgICAgICAgY2FsbGJhY2sobmV3IE1vbmdvb3NlRXJyb3IoJ2RvY3VtZW50IG11c3QgaGF2ZSBhbiBfaWQgYmVmb3JlIHNhdmluZycpKTtcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHRoaXMuJF9fdmVyc2lvbih0cnVlLCBvYmopO1xuICAgIHRoaXNbbW9kZWxDb2xsZWN0aW9uU3ltYm9sXS5pbnNlcnRPbmUob2JqLCBzYXZlT3B0aW9ucykudGhlbihcbiAgICAgIHJldCA9PiBjYWxsYmFjayhudWxsLCByZXQpLFxuICAgICAgZXJyID0+IHtcbiAgICAgICAgX3NldElzTmV3KHRoaXMsIHRydWUpO1xuXG4gICAgICAgIGNhbGxiYWNrKGVyciwgbnVsbCk7XG4gICAgICB9XG4gICAgKTtcblxuICAgIHRoaXMuJF9fcmVzZXQoKTtcbiAgICBfc2V0SXNOZXcodGhpcywgZmFsc2UpO1xuICAgIC8vIE1ha2UgaXQgcG9zc2libGUgdG8gcmV0cnkgdGhlIGluc2VydFxuICAgIHRoaXMuJF9fLmluc2VydGluZyA9IHRydWU7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgLy8gTWFrZSBzdXJlIHdlIGRvbid0IHRyZWF0IGl0IGFzIGEgbmV3IG9iamVjdCBvbiBlcnJvcixcbiAgLy8gc2luY2UgaXQgYWxyZWFkeSBleGlzdHNcbiAgdGhpcy4kX18uaW5zZXJ0aW5nID0gZmFsc2U7XG4gIGNvbnN0IGRlbHRhID0gdGhpcy4kX19kZWx0YSgpO1xuICBpZiAoZGVsdGEpIHtcbiAgICBpZiAoZGVsdGEgaW5zdGFuY2VvZiBNb25nb29zZUVycm9yKSB7XG4gICAgICBjYWxsYmFjayhkZWx0YSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgY29uc3Qgd2hlcmUgPSB0aGlzLiRfX3doZXJlKGRlbHRhWzBdKTtcbiAgICBpZiAod2hlcmUgaW5zdGFuY2VvZiBNb25nb29zZUVycm9yKSB7XG4gICAgICBjYWxsYmFjayh3aGVyZSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgX2FwcGx5Q3VzdG9tV2hlcmUodGhpcywgd2hlcmUpO1xuXG4gICAgY29uc3QgdXBkYXRlID0gZGVsdGFbMV07XG4gICAgaWYgKHRoaXMuJF9fc2NoZW1hLm9wdGlvbnMubWluaW1pemUpIHtcbiAgICAgIG1pbmltaXplKHVwZGF0ZSk7XG4gICAgICAvLyBtaW5pbWl6ZSBtaWdodCBsZWF2ZSB1cyB3aXRoIGFuIGVtcHR5IG9iamVjdCwgd2hpY2ggd291bGRcbiAgICAgIC8vIGxlYWQgdG8gTW9uZ29EQiB0aHJvd2luZyBhIFwiVXBkYXRlIGRvY3VtZW50IHJlcXVpcmVzIGF0b21pYyBvcGVyYXRvcnNcIiBlcnJvclxuICAgICAgaWYgKE9iamVjdC5rZXlzKHVwZGF0ZSkubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIGhhbmRsZUVtcHR5VXBkYXRlLmNhbGwodGhpcyk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB0aGlzW21vZGVsQ29sbGVjdGlvblN5bWJvbF0udXBkYXRlT25lKHdoZXJlLCB1cGRhdGUsIHNhdmVPcHRpb25zKS50aGVuKFxuICAgICAgcmV0ID0+IHtcbiAgICAgICAgcmV0LiR3aGVyZSA9IHdoZXJlO1xuICAgICAgICBjYWxsYmFjayhudWxsLCByZXQpO1xuICAgICAgfSxcbiAgICAgIGVyciA9PiB7XG4gICAgICAgIHRoaXMuJF9fdW5kb1Jlc2V0KCk7XG5cbiAgICAgICAgY2FsbGJhY2soZXJyKTtcbiAgICAgIH1cbiAgICApO1xuICB9IGVsc2Uge1xuICAgIGhhbmRsZUVtcHR5VXBkYXRlLmNhbGwodGhpcyk7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgLy8gc3RvcmUgdGhlIG1vZGlmaWVkIHBhdGhzIGJlZm9yZSB0aGUgZG9jdW1lbnQgaXMgcmVzZXRcbiAgdGhpcy4kX18ubW9kaWZpZWRQYXRocyA9IHRoaXMubW9kaWZpZWRQYXRocygpO1xuICB0aGlzLiRfX3Jlc2V0KCk7XG5cbiAgX3NldElzTmV3KHRoaXMsIGZhbHNlKTtcblxuICBmdW5jdGlvbiBoYW5kbGVFbXB0eVVwZGF0ZSgpIHtcbiAgICBjb25zdCBvcHRpb25zV2l0aEN1c3RvbVZhbHVlcyA9IE9iamVjdC5hc3NpZ24oe30sIG9wdGlvbnMsIHNhdmVPcHRpb25zKTtcbiAgICBjb25zdCB3aGVyZSA9IHRoaXMuJF9fd2hlcmUoKTtcbiAgICBjb25zdCBvcHRpbWlzdGljQ29uY3VycmVuY3kgPSB0aGlzLiRfX3NjaGVtYS5vcHRpb25zLm9wdGltaXN0aWNDb25jdXJyZW5jeTtcbiAgICBpZiAob3B0aW1pc3RpY0NvbmN1cnJlbmN5ICYmICFBcnJheS5pc0FycmF5KG9wdGltaXN0aWNDb25jdXJyZW5jeSkpIHtcbiAgICAgIGNvbnN0IGtleSA9IHRoaXMuJF9fc2NoZW1hLm9wdGlvbnMudmVyc2lvbktleTtcbiAgICAgIGNvbnN0IHZhbCA9IHRoaXMuJF9fZ2V0VmFsdWUoa2V5KTtcbiAgICAgIGlmICh2YWwgIT0gbnVsbCkge1xuICAgICAgICB3aGVyZVtrZXldID0gdmFsO1xuICAgICAgfVxuICAgIH1cbiAgICB0aGlzLmNvbnN0cnVjdG9yLmNvbGxlY3Rpb24uZmluZE9uZSh3aGVyZSwgb3B0aW9uc1dpdGhDdXN0b21WYWx1ZXMpXG4gICAgICAudGhlbihkb2N1bWVudEV4aXN0cyA9PiB7XG4gICAgICAgIGNvbnN0IG1hdGNoZWRDb3VudCA9ICFkb2N1bWVudEV4aXN0cyA/IDAgOiAxO1xuICAgICAgICBjYWxsYmFjayhudWxsLCB7ICR3aGVyZTogd2hlcmUsIG1hdGNoZWRDb3VudCB9KTtcbiAgICAgIH0pXG4gICAgICAuY2F0Y2goY2FsbGJhY2spO1xuICB9XG59O1xuXG4vKiFcbiAqIGlnbm9yZVxuICovXG5cbk1vZGVsLnByb3RvdHlwZS4kX19zYXZlID0gZnVuY3Rpb24ob3B0aW9ucywgY2FsbGJhY2spIHtcbiAgdGhpcy4kX19oYW5kbGVTYXZlKG9wdGlvbnMsIChlcnJvciwgcmVzdWx0KSA9PiB7XG4gICAgaWYgKGVycm9yKSB7XG4gICAgICBjb25zdCBob29rcyA9IHRoaXMuJF9fc2NoZW1hLnMuaG9va3M7XG4gICAgICByZXR1cm4gaG9va3MuZXhlY1Bvc3QoJ3NhdmU6ZXJyb3InLCB0aGlzLCBbdGhpc10sIHsgZXJyb3I6IGVycm9yIH0sIChlcnJvcikgPT4ge1xuICAgICAgICBjYWxsYmFjayhlcnJvciwgdGhpcyk7XG4gICAgICB9KTtcbiAgICB9XG4gICAgbGV0IG51bUFmZmVjdGVkID0gMDtcbiAgICBjb25zdCB3cml0ZUNvbmNlcm4gPSBvcHRpb25zICE9IG51bGwgP1xuICAgICAgb3B0aW9ucy53cml0ZUNvbmNlcm4gIT0gbnVsbCA/XG4gICAgICAgIG9wdGlvbnMud3JpdGVDb25jZXJuLncgOlxuICAgICAgICBvcHRpb25zLncgOlxuICAgICAgMDtcbiAgICBpZiAod3JpdGVDb25jZXJuICE9PSAwKSB7XG4gICAgICAvLyBTa2lwIGNoZWNraW5nIGlmIHdyaXRlIHN1Y2NlZWRlZCBpZiB3cml0ZUNvbmNlcm4gaXMgc2V0IHRvXG4gICAgICAvLyB1bmFja25vd2xlZGdlZCB3cml0ZXMsIGJlY2F1c2Ugb3RoZXJ3aXNlIGBudW1BZmZlY3RlZGAgd2lsbCBhbHdheXMgYmUgMFxuICAgICAgaWYgKHJlc3VsdCAhPSBudWxsKSB7XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KHJlc3VsdCkpIHtcbiAgICAgICAgICBudW1BZmZlY3RlZCA9IHJlc3VsdC5sZW5ndGg7XG4gICAgICAgIH0gZWxzZSBpZiAocmVzdWx0Lm1hdGNoZWRDb3VudCAhPSBudWxsKSB7XG4gICAgICAgICAgbnVtQWZmZWN0ZWQgPSByZXN1bHQubWF0Y2hlZENvdW50O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG51bUFmZmVjdGVkID0gcmVzdWx0O1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IHZlcnNpb25CdW1wID0gdGhpcy4kX18udmVyc2lvbjtcbiAgICAgIC8vIHdhcyB0aGlzIGFuIHVwZGF0ZSB0aGF0IHJlcXVpcmVkIGEgdmVyc2lvbiBidW1wP1xuICAgICAgaWYgKHZlcnNpb25CdW1wICYmICF0aGlzLiRfXy5pbnNlcnRpbmcpIHtcbiAgICAgICAgY29uc3QgZG9JbmNyZW1lbnQgPSBWRVJTSU9OX0lOQyA9PT0gKFZFUlNJT05fSU5DICYgdGhpcy4kX18udmVyc2lvbik7XG4gICAgICAgIHRoaXMuJF9fLnZlcnNpb24gPSB1bmRlZmluZWQ7XG4gICAgICAgIGNvbnN0IGtleSA9IHRoaXMuJF9fc2NoZW1hLm9wdGlvbnMudmVyc2lvbktleTtcbiAgICAgICAgY29uc3QgdmVyc2lvbiA9IHRoaXMuJF9fZ2V0VmFsdWUoa2V5KSB8fCAwO1xuICAgICAgICBpZiAobnVtQWZmZWN0ZWQgPD0gMCkge1xuICAgICAgICAgIC8vIHRoZSB1cGRhdGUgZmFpbGVkLiBwYXNzIGFuIGVycm9yIGJhY2tcbiAgICAgICAgICB0aGlzLiRfX3VuZG9SZXNldCgpO1xuICAgICAgICAgIGNvbnN0IGVyciA9IHRoaXMuJF9fLiR2ZXJzaW9uRXJyb3IgfHxcbiAgICAgICAgICAgIG5ldyBWZXJzaW9uRXJyb3IodGhpcywgdmVyc2lvbiwgdGhpcy4kX18ubW9kaWZpZWRQYXRocyk7XG4gICAgICAgICAgcmV0dXJuIGNhbGxiYWNrKGVycik7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBpbmNyZW1lbnQgdmVyc2lvbiBpZiB3YXMgc3VjY2Vzc2Z1bFxuICAgICAgICBpZiAoZG9JbmNyZW1lbnQpIHtcbiAgICAgICAgICB0aGlzLiRfX3NldFZhbHVlKGtleSwgdmVyc2lvbiArIDEpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAocmVzdWx0ICE9IG51bGwgJiYgbnVtQWZmZWN0ZWQgPD0gMCkge1xuICAgICAgICB0aGlzLiRfX3VuZG9SZXNldCgpO1xuICAgICAgICBlcnJvciA9IG5ldyBEb2N1bWVudE5vdEZvdW5kRXJyb3IocmVzdWx0LiR3aGVyZSxcbiAgICAgICAgICB0aGlzLmNvbnN0cnVjdG9yLm1vZGVsTmFtZSwgbnVtQWZmZWN0ZWQsIHJlc3VsdCk7XG4gICAgICAgIGNvbnN0IGhvb2tzID0gdGhpcy4kX19zY2hlbWEucy5ob29rcztcbiAgICAgICAgcmV0dXJuIGhvb2tzLmV4ZWNQb3N0KCdzYXZlOmVycm9yJywgdGhpcywgW3RoaXNdLCB7IGVycm9yOiBlcnJvciB9LCAoZXJyb3IpID0+IHtcbiAgICAgICAgICBjYWxsYmFjayhlcnJvciwgdGhpcyk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1cbiAgICB0aGlzLiRfXy5zYXZpbmcgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy4kX18uc2F2ZWRTdGF0ZSA9IHt9O1xuICAgIHRoaXMuJGVtaXQoJ3NhdmUnLCB0aGlzLCBudW1BZmZlY3RlZCk7XG4gICAgdGhpcy5jb25zdHJ1Y3Rvci5lbWl0KCdzYXZlJywgdGhpcywgbnVtQWZmZWN0ZWQpO1xuICAgIGNhbGxiYWNrKG51bGwsIHRoaXMpO1xuICB9KTtcbn07XG5cbi8qIVxuICogaWdub3JlXG4gKi9cblxuZnVuY3Rpb24gZ2VuZXJhdGVWZXJzaW9uRXJyb3IoZG9jLCBtb2RpZmllZFBhdGhzKSB7XG4gIGNvbnN0IGtleSA9IGRvYy4kX19zY2hlbWEub3B0aW9ucy52ZXJzaW9uS2V5O1xuICBpZiAoIWtleSkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIGNvbnN0IHZlcnNpb24gPSBkb2MuJF9fZ2V0VmFsdWUoa2V5KSB8fCAwO1xuICByZXR1cm4gbmV3IFZlcnNpb25FcnJvcihkb2MsIHZlcnNpb24sIG1vZGlmaWVkUGF0aHMpO1xufVxuXG4vKipcbiAqIFNhdmVzIHRoaXMgZG9jdW1lbnQgYnkgaW5zZXJ0aW5nIGEgbmV3IGRvY3VtZW50IGludG8gdGhlIGRhdGFiYXNlIGlmIFtkb2N1bWVudC5pc05ld10oaHR0cHM6Ly9tb25nb29zZWpzLmNvbS9kb2NzL2FwaS9kb2N1bWVudC5odG1sI0RvY3VtZW50LnByb3RvdHlwZS5pc05ldykgaXMgYHRydWVgLFxuICogb3Igc2VuZHMgYW4gW3VwZGF0ZU9uZV0oaHR0cHM6Ly9tb25nb29zZWpzLmNvbS9kb2NzL2FwaS9kb2N1bWVudC5odG1sI0RvY3VtZW50LnByb3RvdHlwZS51cGRhdGVPbmUoKSkgb3BlcmF0aW9uIHdpdGgganVzdCB0aGUgbW9kaWZpZWQgcGF0aHMgaWYgYGlzTmV3YCBpcyBgZmFsc2VgLlxuICpcbiAqICMjIyMgRXhhbXBsZTpcbiAqXG4gKiAgICAgcHJvZHVjdC5zb2xkID0gRGF0ZS5ub3coKTtcbiAqICAgICBwcm9kdWN0ID0gYXdhaXQgcHJvZHVjdC5zYXZlKCk7XG4gKlxuICogSWYgc2F2ZSBpcyBzdWNjZXNzZnVsLCB0aGUgcmV0dXJuZWQgcHJvbWlzZSB3aWxsIGZ1bGZpbGwgd2l0aCB0aGUgZG9jdW1lbnRcbiAqIHNhdmVkLlxuICpcbiAqICMjIyMgRXhhbXBsZTpcbiAqXG4gKiAgICAgY29uc3QgbmV3UHJvZHVjdCA9IGF3YWl0IHByb2R1Y3Quc2F2ZSgpO1xuICogICAgIG5ld1Byb2R1Y3QgPT09IHByb2R1Y3Q7IC8vIHRydWVcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdIG9wdGlvbnMgb3B0aW9uYWwgb3B0aW9uc1xuICogQHBhcmFtIHtTZXNzaW9ufSBbb3B0aW9ucy5zZXNzaW9uPW51bGxdIHRoZSBbc2Vzc2lvbl0oaHR0cHM6Ly93d3cubW9uZ29kYi5jb20vZG9jcy9tYW51YWwvcmVmZXJlbmNlL3NlcnZlci1zZXNzaW9ucy8pIGFzc29jaWF0ZWQgd2l0aCB0aGlzIHNhdmUgb3BlcmF0aW9uLiBJZiBub3Qgc3BlY2lmaWVkLCBkZWZhdWx0cyB0byB0aGUgW2RvY3VtZW50J3MgYXNzb2NpYXRlZCBzZXNzaW9uXShodHRwczovL21vbmdvb3NlanMuY29tL2RvY3MvYXBpL2RvY3VtZW50Lmh0bWwjRG9jdW1lbnQucHJvdG90eXBlLnNlc3Npb24oKSkuXG4gKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnMuc2FmZV0gKERFUFJFQ0FURUQpIG92ZXJyaWRlcyBbc2NoZW1hJ3Mgc2FmZSBvcHRpb25dKGh0dHBzOi8vbW9uZ29vc2Vqcy5jb20vZG9jcy9ndWlkZS5odG1sI3NhZmUpLiBVc2UgdGhlIGB3YCBvcHRpb24gaW5zdGVhZC5cbiAqIEBwYXJhbSB7Qm9vbGVhbn0gW29wdGlvbnMudmFsaWRhdGVCZWZvcmVTYXZlXSBzZXQgdG8gZmFsc2UgdG8gc2F2ZSB3aXRob3V0IHZhbGlkYXRpbmcuXG4gKiBAcGFyYW0ge0Jvb2xlYW59IFtvcHRpb25zLnZhbGlkYXRlTW9kaWZpZWRPbmx5PWZhbHNlXSBpZiBgdHJ1ZWAsIE1vbmdvb3NlIHdpbGwgb25seSB2YWxpZGF0ZSBtb2RpZmllZCBwYXRocywgYXMgb3Bwb3NlZCB0byBtb2RpZmllZCBwYXRocyBhbmQgYHJlcXVpcmVkYCBwYXRocy5cbiAqIEBwYXJhbSB7TnVtYmVyfFN0cmluZ30gW29wdGlvbnMud10gc2V0IHRoZSBbd3JpdGUgY29uY2Vybl0oaHR0cHM6Ly93d3cubW9uZ29kYi5jb20vZG9jcy9tYW51YWwvcmVmZXJlbmNlL3dyaXRlLWNvbmNlcm4vI3ctb3B0aW9uKS4gT3ZlcnJpZGVzIHRoZSBbc2NoZW1hLWxldmVsIGB3cml0ZUNvbmNlcm5gIG9wdGlvbl0oaHR0cHM6Ly9tb25nb29zZWpzLmNvbS9kb2NzL2d1aWRlLmh0bWwjd3JpdGVDb25jZXJuKVxuICogQHBhcmFtIHtCb29sZWFufSBbb3B0aW9ucy5qXSBzZXQgdG8gdHJ1ZSBmb3IgTW9uZ29EQiB0byB3YWl0IHVudGlsIHRoaXMgYHNhdmUoKWAgaGFzIGJlZW4gW2pvdXJuYWxlZCBiZWZvcmUgcmVzb2x2aW5nIHRoZSByZXR1cm5lZCBwcm9taXNlXShodHRwczovL3d3dy5tb25nb2RiLmNvbS9kb2NzL21hbnVhbC9yZWZlcmVuY2Uvd3JpdGUtY29uY2Vybi8jai1vcHRpb24pLiBPdmVycmlkZXMgdGhlIFtzY2hlbWEtbGV2ZWwgYHdyaXRlQ29uY2VybmAgb3B0aW9uXShodHRwczovL21vbmdvb3NlanMuY29tL2RvY3MvZ3VpZGUuaHRtbCN3cml0ZUNvbmNlcm4pXG4gKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMud3RpbWVvdXRdIHNldHMgYSBbdGltZW91dCBmb3IgdGhlIHdyaXRlIGNvbmNlcm5dKGh0dHBzOi8vd3d3Lm1vbmdvZGIuY29tL2RvY3MvbWFudWFsL3JlZmVyZW5jZS93cml0ZS1jb25jZXJuLyN3dGltZW91dCkuIE92ZXJyaWRlcyB0aGUgW3NjaGVtYS1sZXZlbCBgd3JpdGVDb25jZXJuYCBvcHRpb25dKGh0dHBzOi8vbW9uZ29vc2Vqcy5jb20vZG9jcy9ndWlkZS5odG1sI3dyaXRlQ29uY2VybikuXG4gKiBAcGFyYW0ge0Jvb2xlYW59IFtvcHRpb25zLmNoZWNrS2V5cz10cnVlXSB0aGUgTW9uZ29EQiBkcml2ZXIgcHJldmVudHMgeW91IGZyb20gc2F2aW5nIGtleXMgdGhhdCBzdGFydCB3aXRoICckJyBvciBjb250YWluICcuJyBieSBkZWZhdWx0LiBTZXQgdGhpcyBvcHRpb24gdG8gYGZhbHNlYCB0byBza2lwIHRoYXQgY2hlY2suIFNlZSBbcmVzdHJpY3Rpb25zIG9uIGZpZWxkIG5hbWVzXShodHRwczovL2RvY3MubW9uZ29kYi5jb20vbWFudWFsL3JlZmVyZW5jZS9saW1pdHMvI21vbmdvZGItbGltaXQtUmVzdHJpY3Rpb25zLW9uLUZpZWxkLU5hbWVzKVxuICogQHBhcmFtIHtCb29sZWFufSBbb3B0aW9ucy50aW1lc3RhbXBzPXRydWVdIGlmIGBmYWxzZWAgYW5kIFt0aW1lc3RhbXBzXShodHRwczovL21vbmdvb3NlanMuY29tL2RvY3MvZ3VpZGUuaHRtbCN0aW1lc3RhbXBzKSBhcmUgZW5hYmxlZCwgc2tpcCB0aW1lc3RhbXBzIGZvciB0aGlzIGBzYXZlKClgLlxuICogQHRocm93cyB7RG9jdW1lbnROb3RGb3VuZEVycm9yfSBpZiB0aGlzIFtzYXZlIHVwZGF0ZXMgYW4gZXhpc3RpbmcgZG9jdW1lbnRdKGh0dHBzOi8vbW9uZ29vc2Vqcy5jb20vZG9jcy9hcGkvZG9jdW1lbnQuaHRtbCNEb2N1bWVudC5wcm90b3R5cGUuaXNOZXcpIGJ1dCB0aGUgZG9jdW1lbnQgZG9lc24ndCBleGlzdCBpbiB0aGUgZGF0YWJhc2UuIEZvciBleGFtcGxlLCB5b3Ugd2lsbCBnZXQgdGhpcyBlcnJvciBpZiB0aGUgZG9jdW1lbnQgaXMgW2RlbGV0ZWQgYmV0d2VlbiB3aGVuIHlvdSByZXRyaWV2ZWQgdGhlIGRvY3VtZW50IGFuZCB3aGVuIHlvdSBzYXZlZCBpdF0oZG9jdW1lbnRzLmh0bWwjdXBkYXRpbmcpLlxuICogQHJldHVybiB7UHJvbWlzZX1cbiAqIEBhcGkgcHVibGljXG4gKiBAc2VlIG1pZGRsZXdhcmUgaHR0cHM6Ly9tb25nb29zZWpzLmNvbS9kb2NzL21pZGRsZXdhcmUuaHRtbFxuICovXG5cbk1vZGVsLnByb3RvdHlwZS5zYXZlID0gYXN5bmMgZnVuY3Rpb24gc2F2ZShvcHRpb25zKSB7XG4gIGlmICh0eXBlb2Ygb3B0aW9ucyA9PT0gJ2Z1bmN0aW9uJyB8fCB0eXBlb2YgYXJndW1lbnRzWzFdID09PSAnZnVuY3Rpb24nKSB7XG4gICAgdGhyb3cgbmV3IE1vbmdvb3NlRXJyb3IoJ01vZGVsLnByb3RvdHlwZS5zYXZlKCkgbm8gbG9uZ2VyIGFjY2VwdHMgYSBjYWxsYmFjaycpO1xuICB9XG5cbiAgbGV0IHBhcmFsbGVsU2F2ZTtcbiAgdGhpcy4kb3AgPSAnc2F2ZSc7XG5cbiAgaWYgKHRoaXMuJF9fLnNhdmluZykge1xuICAgIHBhcmFsbGVsU2F2ZSA9IG5ldyBQYXJhbGxlbFNhdmVFcnJvcih0aGlzKTtcbiAgfSBlbHNlIHtcbiAgICB0aGlzLiRfXy5zYXZpbmcgPSBuZXcgUGFyYWxsZWxTYXZlRXJyb3IodGhpcyk7XG4gIH1cblxuICBvcHRpb25zID0gbmV3IFNhdmVPcHRpb25zKG9wdGlvbnMpO1xuICBpZiAob3B0aW9ucy5oYXNPd25Qcm9wZXJ0eSgnc2Vzc2lvbicpKSB7XG4gICAgdGhpcy4kc2Vzc2lvbihvcHRpb25zLnNlc3Npb24pO1xuICB9XG4gIGlmICh0aGlzLiRfXy50aW1lc3RhbXBzICE9IG51bGwpIHtcbiAgICBvcHRpb25zLnRpbWVzdGFtcHMgPSB0aGlzLiRfXy50aW1lc3RhbXBzO1xuICB9XG4gIHRoaXMuJF9fLiR2ZXJzaW9uRXJyb3IgPSBnZW5lcmF0ZVZlcnNpb25FcnJvcih0aGlzLCB0aGlzLm1vZGlmaWVkUGF0aHMoKSk7XG5cbiAgaWYgKHBhcmFsbGVsU2F2ZSkge1xuICAgIHRoaXMuJF9faGFuZGxlUmVqZWN0KHBhcmFsbGVsU2F2ZSk7XG4gICAgdGhyb3cgcGFyYWxsZWxTYXZlO1xuICB9XG5cbiAgdGhpcy4kX18uc2F2ZU9wdGlvbnMgPSBvcHRpb25zO1xuXG4gIGF3YWl0IG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICB0aGlzLiRfX3NhdmUob3B0aW9ucywgZXJyb3IgPT4ge1xuICAgICAgdGhpcy4kX18uc2F2aW5nID0gbnVsbDtcbiAgICAgIHRoaXMuJF9fLnNhdmVPcHRpb25zID0gbnVsbDtcbiAgICAgIHRoaXMuJF9fLiR2ZXJzaW9uRXJyb3IgPSBudWxsO1xuICAgICAgdGhpcy4kb3AgPSBudWxsO1xuICAgICAgaWYgKGVycm9yICE9IG51bGwpIHtcbiAgICAgICAgdGhpcy4kX19oYW5kbGVSZWplY3QoZXJyb3IpO1xuICAgICAgICByZXR1cm4gcmVqZWN0KGVycm9yKTtcbiAgICAgIH1cblxuICAgICAgcmVzb2x2ZSgpO1xuICAgIH0pO1xuICB9KTtcblxuICByZXR1cm4gdGhpcztcbn07XG5cbk1vZGVsLnByb3RvdHlwZS4kc2F2ZSA9IE1vZGVsLnByb3RvdHlwZS5zYXZlO1xuXG4vKipcbiAqIERldGVybWluZXMgd2hldGhlciB2ZXJzaW9uaW5nIHNob3VsZCBiZSBza2lwcGVkIGZvciB0aGUgZ2l2ZW4gcGF0aFxuICpcbiAqIEBwYXJhbSB7RG9jdW1lbnR9IHNlbGZcbiAqIEBwYXJhbSB7U3RyaW5nfSBwYXRoXG4gKiBAcmV0dXJuIHtCb29sZWFufSB0cnVlIGlmIHZlcnNpb25pbmcgc2hvdWxkIGJlIHNraXBwZWQgZm9yIHRoZSBnaXZlbiBwYXRoXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gc2hvdWxkU2tpcFZlcnNpb25pbmcoc2VsZiwgcGF0aCkge1xuICBjb25zdCBza2lwVmVyc2lvbmluZyA9IHNlbGYuJF9fc2NoZW1hLm9wdGlvbnMuc2tpcFZlcnNpb25pbmc7XG4gIGlmICghc2tpcFZlcnNpb25pbmcpIHJldHVybiBmYWxzZTtcblxuICAvLyBSZW1vdmUgYW55IGFycmF5IGluZGV4ZXMgZnJvbSB0aGUgcGF0aFxuICBwYXRoID0gcGF0aC5yZXBsYWNlKC9cXC5cXGQrXFwuLywgJy4nKTtcblxuICByZXR1cm4gc2tpcFZlcnNpb25pbmdbcGF0aF07XG59XG5cbi8qKlxuICogQXBwbHkgdGhlIG9wZXJhdGlvbiB0byB0aGUgZGVsdGEgKHVwZGF0ZSkgY2xhdXNlIGFzXG4gKiB3ZWxsIGFzIHRyYWNrIHZlcnNpb25pbmcgZm9yIG91ciB3aGVyZSBjbGF1c2UuXG4gKlxuICogQHBhcmFtIHtEb2N1bWVudH0gc2VsZlxuICogQHBhcmFtIHtPYmplY3R9IHdoZXJlIFVudXNlZFxuICogQHBhcmFtIHtPYmplY3R9IGRlbHRhXG4gKiBAcGFyYW0ge09iamVjdH0gZGF0YVxuICogQHBhcmFtIHtNaXhlZH0gdmFsXG4gKiBAcGFyYW0ge1N0cmluZ30gW29wXVxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZnVuY3Rpb24gb3BlcmFuZChzZWxmLCB3aGVyZSwgZGVsdGEsIGRhdGEsIHZhbCwgb3ApIHtcbiAgLy8gZGVsdGFcbiAgb3AgfHwgKG9wID0gJyRzZXQnKTtcbiAgaWYgKCFkZWx0YVtvcF0pIGRlbHRhW29wXSA9IHt9O1xuICBkZWx0YVtvcF1bZGF0YS5wYXRoXSA9IHZhbDtcbiAgLy8gZGlzYWJsZWQgdmVyc2lvbmluZz9cbiAgaWYgKHNlbGYuJF9fc2NoZW1hLm9wdGlvbnMudmVyc2lvbktleSA9PT0gZmFsc2UpIHJldHVybjtcblxuICAvLyBwYXRoIGV4Y2x1ZGVkIGZyb20gdmVyc2lvbmluZz9cbiAgaWYgKHNob3VsZFNraXBWZXJzaW9uaW5nKHNlbGYsIGRhdGEucGF0aCkpIHJldHVybjtcblxuICAvLyBhbHJlYWR5IG1hcmtlZCBmb3IgdmVyc2lvbmluZz9cbiAgaWYgKFZFUlNJT05fQUxMID09PSAoVkVSU0lPTl9BTEwgJiBzZWxmLiRfXy52ZXJzaW9uKSkgcmV0dXJuO1xuXG4gIGlmIChzZWxmLiRfX3NjaGVtYS5vcHRpb25zLm9wdGltaXN0aWNDb25jdXJyZW5jeSkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIHN3aXRjaCAob3ApIHtcbiAgICBjYXNlICckc2V0JzpcbiAgICBjYXNlICckdW5zZXQnOlxuICAgIGNhc2UgJyRwb3AnOlxuICAgIGNhc2UgJyRwdWxsJzpcbiAgICBjYXNlICckcHVsbEFsbCc6XG4gICAgY2FzZSAnJHB1c2gnOlxuICAgIGNhc2UgJyRhZGRUb1NldCc6XG4gICAgY2FzZSAnJGluYyc6XG4gICAgICBicmVhaztcbiAgICBkZWZhdWx0OlxuICAgICAgLy8gbm90aGluZyB0byBkb1xuICAgICAgcmV0dXJuO1xuICB9XG5cbiAgLy8gZW5zdXJlIHVwZGF0ZXMgc2VudCB3aXRoIHBvc2l0aW9uYWwgbm90YXRpb24gYXJlXG4gIC8vIGVkaXRpbmcgdGhlIGNvcnJlY3QgYXJyYXkgZWxlbWVudC5cbiAgLy8gb25seSBpbmNyZW1lbnQgdGhlIHZlcnNpb24gaWYgYW4gYXJyYXkgcG9zaXRpb24gY2hhbmdlcy5cbiAgLy8gbW9kaWZ5aW5nIGVsZW1lbnRzIG9mIGFuIGFycmF5IGlzIG9rIGlmIHBvc2l0aW9uIGRvZXMgbm90IGNoYW5nZS5cbiAgaWYgKG9wID09PSAnJHB1c2gnIHx8IG9wID09PSAnJGFkZFRvU2V0JyB8fCBvcCA9PT0gJyRwdWxsQWxsJyB8fCBvcCA9PT0gJyRwdWxsJykge1xuICAgIGlmICgvXFwuXFxkK1xcLnxcXC5cXGQrJC8udGVzdChkYXRhLnBhdGgpKSB7XG4gICAgICBpbmNyZW1lbnQuY2FsbChzZWxmKTtcbiAgICB9IGVsc2Uge1xuICAgICAgc2VsZi4kX18udmVyc2lvbiA9IFZFUlNJT05fSU5DO1xuICAgIH1cbiAgfSBlbHNlIGlmICgvXlxcJHAvLnRlc3Qob3ApKSB7XG4gICAgLy8gcG90ZW50aWFsbHkgY2hhbmdpbmcgYXJyYXkgcG9zaXRpb25zXG4gICAgaW5jcmVtZW50LmNhbGwoc2VsZik7XG4gIH0gZWxzZSBpZiAoQXJyYXkuaXNBcnJheSh2YWwpKSB7XG4gICAgLy8gJHNldCBhbiBhcnJheVxuICAgIGluY3JlbWVudC5jYWxsKHNlbGYpO1xuICB9IGVsc2UgaWYgKC9cXC5cXGQrXFwufFxcLlxcZCskLy50ZXN0KGRhdGEucGF0aCkpIHtcbiAgICAvLyBub3cgaGFuZGxpbmcgJHNldCwgJHVuc2V0XG4gICAgLy8gc3VicGF0aCBvZiBhcnJheVxuICAgIHNlbGYuJF9fLnZlcnNpb24gPSBWRVJTSU9OX1dIRVJFO1xuICB9XG59XG5cbi8qKlxuICogQ29tcGlsZXMgYW4gdXBkYXRlIGFuZCB3aGVyZSBjbGF1c2UgZm9yIGEgYHZhbGAgd2l0aCBfYXRvbWljcy5cbiAqXG4gKiBAcGFyYW0ge0RvY3VtZW50fSBzZWxmXG4gKiBAcGFyYW0ge09iamVjdH0gd2hlcmVcbiAqIEBwYXJhbSB7T2JqZWN0fSBkZWx0YVxuICogQHBhcmFtIHtPYmplY3R9IGRhdGFcbiAqIEBwYXJhbSB7QXJyYXl9IHZhbHVlXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5mdW5jdGlvbiBoYW5kbGVBdG9taWNzKHNlbGYsIHdoZXJlLCBkZWx0YSwgZGF0YSwgdmFsdWUpIHtcbiAgaWYgKGRlbHRhLiRzZXQgJiYgZGVsdGEuJHNldFtkYXRhLnBhdGhdKSB7XG4gICAgLy8gJHNldCBoYXMgcHJlY2VkZW5jZSBvdmVyIG90aGVyIGF0b21pY3NcbiAgICByZXR1cm47XG4gIH1cblxuICBpZiAodHlwZW9mIHZhbHVlLiRfX2dldEF0b21pY3MgPT09ICdmdW5jdGlvbicpIHtcbiAgICB2YWx1ZS4kX19nZXRBdG9taWNzKCkuZm9yRWFjaChmdW5jdGlvbihhdG9taWMpIHtcbiAgICAgIGNvbnN0IG9wID0gYXRvbWljWzBdO1xuICAgICAgY29uc3QgdmFsID0gYXRvbWljWzFdO1xuICAgICAgb3BlcmFuZChzZWxmLCB3aGVyZSwgZGVsdGEsIGRhdGEsIHZhbCwgb3ApO1xuICAgIH0pO1xuICAgIHJldHVybjtcbiAgfVxuXG4gIC8vIGxlZ2FjeSBzdXBwb3J0IGZvciBwbHVnaW5zXG5cbiAgY29uc3QgYXRvbWljcyA9IHZhbHVlW2FycmF5QXRvbWljc1N5bWJvbF07XG4gIGNvbnN0IG9wcyA9IE9iamVjdC5rZXlzKGF0b21pY3MpO1xuICBsZXQgaSA9IG9wcy5sZW5ndGg7XG4gIGxldCB2YWw7XG4gIGxldCBvcDtcblxuICBpZiAoaSA9PT0gMCkge1xuICAgIC8vICRzZXRcblxuICAgIGlmICh1dGlscy5pc01vbmdvb3NlT2JqZWN0KHZhbHVlKSkge1xuICAgICAgdmFsdWUgPSB2YWx1ZS50b09iamVjdCh7IGRlcG9wdWxhdGU6IDEsIF9pc05lc3RlZDogdHJ1ZSB9KTtcbiAgICB9IGVsc2UgaWYgKHZhbHVlLnZhbHVlT2YpIHtcbiAgICAgIHZhbHVlID0gdmFsdWUudmFsdWVPZigpO1xuICAgIH1cblxuICAgIHJldHVybiBvcGVyYW5kKHNlbGYsIHdoZXJlLCBkZWx0YSwgZGF0YSwgdmFsdWUpO1xuICB9XG5cbiAgZnVuY3Rpb24gaXRlcihtZW0pIHtcbiAgICByZXR1cm4gdXRpbHMuaXNNb25nb29zZU9iamVjdChtZW0pXG4gICAgICA/IG1lbS50b09iamVjdCh7IGRlcG9wdWxhdGU6IDEsIF9pc05lc3RlZDogdHJ1ZSB9KVxuICAgICAgOiBtZW07XG4gIH1cblxuICB3aGlsZSAoaS0tKSB7XG4gICAgb3AgPSBvcHNbaV07XG4gICAgdmFsID0gYXRvbWljc1tvcF07XG5cbiAgICBpZiAodXRpbHMuaXNNb25nb29zZU9iamVjdCh2YWwpKSB7XG4gICAgICB2YWwgPSB2YWwudG9PYmplY3QoeyBkZXBvcHVsYXRlOiB0cnVlLCB0cmFuc2Zvcm06IGZhbHNlLCBfaXNOZXN0ZWQ6IHRydWUgfSk7XG4gICAgfSBlbHNlIGlmIChBcnJheS5pc0FycmF5KHZhbCkpIHtcbiAgICAgIHZhbCA9IHZhbC5tYXAoaXRlcik7XG4gICAgfSBlbHNlIGlmICh2YWwudmFsdWVPZikge1xuICAgICAgdmFsID0gdmFsLnZhbHVlT2YoKTtcbiAgICB9XG5cbiAgICBpZiAob3AgPT09ICckYWRkVG9TZXQnKSB7XG4gICAgICB2YWwgPSB7ICRlYWNoOiB2YWwgfTtcbiAgICB9XG5cbiAgICBvcGVyYW5kKHNlbGYsIHdoZXJlLCBkZWx0YSwgZGF0YSwgdmFsLCBvcCk7XG4gIH1cbn1cblxuLyoqXG4gKiBQcm9kdWNlcyBhIHNwZWNpYWwgcXVlcnkgZG9jdW1lbnQgb2YgdGhlIG1vZGlmaWVkIHByb3BlcnRpZXMgdXNlZCBpbiB1cGRhdGVzLlxuICpcbiAqIEBhcGkgcHJpdmF0ZVxuICogQG1ldGhvZCAkX19kZWx0YVxuICogQG1lbWJlck9mIE1vZGVsXG4gKiBAaW5zdGFuY2VcbiAqL1xuXG5Nb2RlbC5wcm90b3R5cGUuJF9fZGVsdGEgPSBmdW5jdGlvbigpIHtcbiAgY29uc3QgZGlydHkgPSB0aGlzLiRfX2RpcnR5KCk7XG5cbiAgY29uc3Qgb3B0aW1pc3RpY0NvbmN1cnJlbmN5ID0gdGhpcy4kX19zY2hlbWEub3B0aW9ucy5vcHRpbWlzdGljQ29uY3VycmVuY3k7XG4gIGlmIChvcHRpbWlzdGljQ29uY3VycmVuY3kpIHtcbiAgICBpZiAoQXJyYXkuaXNBcnJheShvcHRpbWlzdGljQ29uY3VycmVuY3kpKSB7XG4gICAgICBjb25zdCBvcHRDb24gPSBuZXcgU2V0KG9wdGltaXN0aWNDb25jdXJyZW5jeSk7XG4gICAgICBjb25zdCBtb2RQYXRocyA9IHRoaXMubW9kaWZpZWRQYXRocygpO1xuICAgICAgaWYgKG1vZFBhdGhzLmZpbmQocGF0aCA9PiBvcHRDb24uaGFzKHBhdGgpKSkge1xuICAgICAgICB0aGlzLiRfXy52ZXJzaW9uID0gZGlydHkubGVuZ3RoID8gVkVSU0lPTl9BTEwgOiBWRVJTSU9OX1dIRVJFO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLiRfXy52ZXJzaW9uID0gZGlydHkubGVuZ3RoID8gVkVSU0lPTl9BTEwgOiBWRVJTSU9OX1dIRVJFO1xuICAgIH1cbiAgfVxuXG4gIGlmICghZGlydHkubGVuZ3RoICYmIFZFUlNJT05fQUxMICE9PSB0aGlzLiRfXy52ZXJzaW9uKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGNvbnN0IHdoZXJlID0ge307XG4gIGNvbnN0IGRlbHRhID0ge307XG4gIGNvbnN0IGxlbiA9IGRpcnR5Lmxlbmd0aDtcbiAgY29uc3QgZGl2ZXJnZW50ID0gW107XG4gIGxldCBkID0gMDtcblxuICB3aGVyZS5faWQgPSB0aGlzLl9kb2MuX2lkO1xuICAvLyBJZiBgX2lkYCBpcyBhbiBvYmplY3QsIG5lZWQgdG8gZGVwb3B1bGF0ZSwgYnV0IGFsc28gbmVlZCB0byBiZSBjYXJlZnVsXG4gIC8vIGJlY2F1c2UgYF9pZGAgY2FuIHRlY2huaWNhbGx5IGJlIG51bGwgKHNlZSBnaC02NDA2KVxuICBpZiAoKHdoZXJlICYmIHdoZXJlLl9pZCAmJiB3aGVyZS5faWQuJF9fIHx8IG51bGwpICE9IG51bGwpIHtcbiAgICB3aGVyZS5faWQgPSB3aGVyZS5faWQudG9PYmplY3QoeyB0cmFuc2Zvcm06IGZhbHNlLCBkZXBvcHVsYXRlOiB0cnVlIH0pO1xuICB9XG4gIGZvciAoOyBkIDwgbGVuOyArK2QpIHtcbiAgICBjb25zdCBkYXRhID0gZGlydHlbZF07XG4gICAgbGV0IHZhbHVlID0gZGF0YS52YWx1ZTtcbiAgICBjb25zdCBtYXRjaCA9IGNoZWNrRGl2ZXJnZW50QXJyYXkodGhpcywgZGF0YS5wYXRoLCB2YWx1ZSk7XG4gICAgaWYgKG1hdGNoKSB7XG4gICAgICBkaXZlcmdlbnQucHVzaChtYXRjaCk7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICBjb25zdCBwb3AgPSB0aGlzLiRwb3B1bGF0ZWQoZGF0YS5wYXRoLCB0cnVlKTtcbiAgICBpZiAoIXBvcCAmJiB0aGlzLiRfXy5zZWxlY3RlZCkge1xuICAgICAgLy8gSWYgYW55IGFycmF5IHdhcyBzZWxlY3RlZCB1c2luZyBhbiAkZWxlbU1hdGNoIHByb2plY3Rpb24sIHdlIGFsdGVyIHRoZSBwYXRoIGFuZCB3aGVyZSBjbGF1c2VcbiAgICAgIC8vIE5PVEU6IE1vbmdvREIgb25seSBzdXBwb3J0cyBwcm9qZWN0ZWQgJGVsZW1NYXRjaCBvbiB0b3AgbGV2ZWwgYXJyYXkuXG4gICAgICBjb25zdCBwYXRoU3BsaXQgPSBkYXRhLnBhdGguc3BsaXQoJy4nKTtcbiAgICAgIGNvbnN0IHRvcCA9IHBhdGhTcGxpdFswXTtcbiAgICAgIGlmICh0aGlzLiRfXy5zZWxlY3RlZFt0b3BdICYmIHRoaXMuJF9fLnNlbGVjdGVkW3RvcF0uJGVsZW1NYXRjaCkge1xuICAgICAgICAvLyBJZiB0aGUgc2VsZWN0ZWQgYXJyYXkgZW50cnkgd2FzIG1vZGlmaWVkXG4gICAgICAgIGlmIChwYXRoU3BsaXQubGVuZ3RoID4gMSAmJiBwYXRoU3BsaXRbMV0gPT0gMCAmJiB0eXBlb2Ygd2hlcmVbdG9wXSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICB3aGVyZVt0b3BdID0gdGhpcy4kX18uc2VsZWN0ZWRbdG9wXTtcbiAgICAgICAgICBwYXRoU3BsaXRbMV0gPSAnJCc7XG4gICAgICAgICAgZGF0YS5wYXRoID0gcGF0aFNwbGl0LmpvaW4oJy4nKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBpZiB0aGUgc2VsZWN0ZWQgYXJyYXkgd2FzIG1vZGlmaWVkIGluIGFueSBvdGhlciB3YXkgdGhyb3cgYW4gZXJyb3JcbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgZGl2ZXJnZW50LnB1c2goZGF0YS5wYXRoKTtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIC8vIElmIHRoaXMgcGF0aCBpcyBzZXQgdG8gZGVmYXVsdCwgYW5kIGVpdGhlciB0aGlzIHBhdGggb3Igb25lIG9mXG4gICAgLy8gaXRzIHBhcmVudHMgaXMgZXhjbHVkZWQsIGRvbid0IHRyZWF0IHRoaXMgcGF0aCBhcyBkaXJ0eS5cbiAgICBpZiAodGhpcy4kaXNEZWZhdWx0KGRhdGEucGF0aCkgJiYgdGhpcy4kX18uc2VsZWN0ZWQpIHtcbiAgICAgIGlmIChkYXRhLnBhdGguaW5kZXhPZignLicpID09PSAtMSAmJiBpc1BhdGhFeGNsdWRlZCh0aGlzLiRfXy5zZWxlY3RlZCwgZGF0YS5wYXRoKSkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgY29uc3QgcGF0aHNUb0NoZWNrID0gcGFyZW50UGF0aHMoZGF0YS5wYXRoKTtcbiAgICAgIGlmIChwYXRoc1RvQ2hlY2suZmluZChwYXRoID0+IGlzUGF0aEV4Y2x1ZGVkKHRoaXMuJF9fLmlzU2VsZWN0ZWQsIHBhdGgpKSkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoZGl2ZXJnZW50Lmxlbmd0aCkgY29udGludWU7XG4gICAgaWYgKHZhbHVlID09PSB1bmRlZmluZWQpIHtcbiAgICAgIG9wZXJhbmQodGhpcywgd2hlcmUsIGRlbHRhLCBkYXRhLCAxLCAnJHVuc2V0Jyk7XG4gICAgfSBlbHNlIGlmICh2YWx1ZSA9PT0gbnVsbCkge1xuICAgICAgb3BlcmFuZCh0aGlzLCB3aGVyZSwgZGVsdGEsIGRhdGEsIG51bGwpO1xuICAgIH0gZWxzZSBpZiAodXRpbHMuaXNNb25nb29zZUFycmF5KHZhbHVlKSAmJiB2YWx1ZS4kcGF0aCgpICYmIHZhbHVlW2FycmF5QXRvbWljc1N5bWJvbF0pIHtcbiAgICAgIC8vIGFycmF5cyBhbmQgb3RoZXIgY3VzdG9tIHR5cGVzIChzdXBwb3J0IHBsdWdpbnMgZXRjKVxuICAgICAgaGFuZGxlQXRvbWljcyh0aGlzLCB3aGVyZSwgZGVsdGEsIGRhdGEsIHZhbHVlKTtcbiAgICB9IGVsc2UgaWYgKHZhbHVlW01vbmdvb3NlQnVmZmVyLnBhdGhTeW1ib2xdICYmIEJ1ZmZlci5pc0J1ZmZlcih2YWx1ZSkpIHtcbiAgICAgIC8vIE1vbmdvb3NlQnVmZmVyXG4gICAgICB2YWx1ZSA9IHZhbHVlLnRvT2JqZWN0KCk7XG4gICAgICBvcGVyYW5kKHRoaXMsIHdoZXJlLCBkZWx0YSwgZGF0YSwgdmFsdWUpO1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAodGhpcy4kX18ucHJpbWl0aXZlQXRvbWljcyAmJiB0aGlzLiRfXy5wcmltaXRpdmVBdG9taWNzW2RhdGEucGF0aF0gIT0gbnVsbCkge1xuICAgICAgICBjb25zdCB2YWwgPSB0aGlzLiRfXy5wcmltaXRpdmVBdG9taWNzW2RhdGEucGF0aF07XG4gICAgICAgIGNvbnN0IG9wID0gZmlyc3RLZXkodmFsKTtcbiAgICAgICAgb3BlcmFuZCh0aGlzLCB3aGVyZSwgZGVsdGEsIGRhdGEsIHZhbFtvcF0sIG9wKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhbHVlID0gY2xvbmUodmFsdWUsIHtcbiAgICAgICAgICBkZXBvcHVsYXRlOiB0cnVlLFxuICAgICAgICAgIHRyYW5zZm9ybTogZmFsc2UsXG4gICAgICAgICAgdmlydHVhbHM6IGZhbHNlLFxuICAgICAgICAgIGdldHRlcnM6IGZhbHNlLFxuICAgICAgICAgIG9taXRVbmRlZmluZWQ6IHRydWUsXG4gICAgICAgICAgX2lzTmVzdGVkOiB0cnVlXG4gICAgICAgIH0pO1xuICAgICAgICBvcGVyYW5kKHRoaXMsIHdoZXJlLCBkZWx0YSwgZGF0YSwgdmFsdWUpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGlmIChkaXZlcmdlbnQubGVuZ3RoKSB7XG4gICAgcmV0dXJuIG5ldyBEaXZlcmdlbnRBcnJheUVycm9yKGRpdmVyZ2VudCk7XG4gIH1cblxuICBpZiAodGhpcy4kX18udmVyc2lvbikge1xuICAgIHRoaXMuJF9fdmVyc2lvbih3aGVyZSwgZGVsdGEpO1xuICB9XG5cbiAgaWYgKE9iamVjdC5rZXlzKGRlbHRhKS5sZW5ndGggPT09IDApIHtcbiAgICByZXR1cm4gW3doZXJlLCBudWxsXTtcbiAgfVxuXG4gIHJldHVybiBbd2hlcmUsIGRlbHRhXTtcbn07XG5cbi8qKlxuICogRGV0ZXJtaW5lIGlmIGFycmF5IHdhcyBwb3B1bGF0ZWQgd2l0aCBzb21lIGZvcm0gb2YgZmlsdGVyIGFuZCBpcyBub3dcbiAqIGJlaW5nIHVwZGF0ZWQgaW4gYSBtYW5uZXIgd2hpY2ggY291bGQgb3ZlcndyaXRlIGRhdGEgdW5pbnRlbnRpb25hbGx5LlxuICpcbiAqIEBzZWUgaHR0cHM6Ly9naXRodWIuY29tL0F1dG9tYXR0aWMvbW9uZ29vc2UvaXNzdWVzLzEzMzRcbiAqIEBwYXJhbSB7RG9jdW1lbnR9IGRvY1xuICogQHBhcmFtIHtTdHJpbmd9IHBhdGhcbiAqIEBwYXJhbSB7QW55fSBhcnJheVxuICogQHJldHVybiB7U3RyaW5nfHVuZGVmaW5lZH1cbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmZ1bmN0aW9uIGNoZWNrRGl2ZXJnZW50QXJyYXkoZG9jLCBwYXRoLCBhcnJheSkge1xuICAvLyBzZWUgaWYgd2UgcG9wdWxhdGVkIHRoaXMgcGF0aFxuICBjb25zdCBwb3AgPSBkb2MuJHBvcHVsYXRlZChwYXRoLCB0cnVlKTtcblxuICBpZiAoIXBvcCAmJiBkb2MuJF9fLnNlbGVjdGVkKSB7XG4gICAgLy8gSWYgYW55IGFycmF5IHdhcyBzZWxlY3RlZCB1c2luZyBhbiAkZWxlbU1hdGNoIHByb2plY3Rpb24sIHdlIGRlbnkgdGhlIHVwZGF0ZS5cbiAgICAvLyBOT1RFOiBNb25nb0RCIG9ubHkgc3VwcG9ydHMgcHJvamVjdGVkICRlbGVtTWF0Y2ggb24gdG9wIGxldmVsIGFycmF5LlxuICAgIGNvbnN0IHRvcCA9IHBhdGguc3BsaXQoJy4nKVswXTtcbiAgICBpZiAoZG9jLiRfXy5zZWxlY3RlZFt0b3AgKyAnLiQnXSkge1xuICAgICAgcmV0dXJuIHRvcDtcbiAgICB9XG4gIH1cblxuICBpZiAoIShwb3AgJiYgdXRpbHMuaXNNb25nb29zZUFycmF5KGFycmF5KSkpIHJldHVybjtcblxuICAvLyBJZiB0aGUgYXJyYXkgd2FzIHBvcHVsYXRlZCB1c2luZyBvcHRpb25zIHRoYXQgcHJldmVudGVkIGFsbFxuICAvLyBkb2N1bWVudHMgZnJvbSBiZWluZyByZXR1cm5lZCAobWF0Y2gsIHNraXAsIGxpbWl0KSBvciB0aGV5XG4gIC8vIGRlc2VsZWN0ZWQgdGhlIF9pZCBmaWVsZCwgJHBvcCBhbmQgJHNldCBvZiB0aGUgYXJyYXkgYXJlXG4gIC8vIG5vdCBzYWZlIG9wZXJhdGlvbnMuIElmIF9pZCB3YXMgZGVzZWxlY3RlZCwgd2UgZG8gbm90IGtub3dcbiAgLy8gaG93IHRvIHJlbW92ZSBlbGVtZW50cy4gJHBvcCB3aWxsIHBvcCBvZmYgdGhlIF9pZCBmcm9tIHRoZSBlbmRcbiAgLy8gb2YgdGhlIGFycmF5IGluIHRoZSBkYiB3aGljaCBpcyBub3QgZ3VhcmFudGVlZCB0byBiZSB0aGVcbiAgLy8gc2FtZSBhcyB0aGUgbGFzdCBlbGVtZW50IHdlIGhhdmUgaGVyZS4gJHNldCBvZiB0aGUgZW50aXJlIGFycmF5XG4gIC8vIHdvdWxkIGJlIHNpbWlsYXJseSBkZXN0cnVjdGl2ZSBhcyB3ZSBuZXZlciByZWNlaXZlZCBhbGxcbiAgLy8gZWxlbWVudHMgb2YgdGhlIGFycmF5IGFuZCBwb3RlbnRpYWxseSB3b3VsZCBvdmVyd3JpdGUgZGF0YS5cbiAgY29uc3QgY2hlY2sgPSBwb3Aub3B0aW9ucy5tYXRjaCB8fFxuICAgICAgcG9wLm9wdGlvbnMub3B0aW9ucyAmJiB1dGlscy5vYmplY3QuaGFzT3duUHJvcGVydHkocG9wLm9wdGlvbnMub3B0aW9ucywgJ2xpbWl0JykgfHwgLy8gMCBpcyBub3QgcGVybWl0dGVkXG4gICAgICBwb3Aub3B0aW9ucy5vcHRpb25zICYmIHBvcC5vcHRpb25zLm9wdGlvbnMuc2tpcCB8fCAvLyAwIGlzIHBlcm1pdHRlZFxuICAgICAgcG9wLm9wdGlvbnMuc2VsZWN0ICYmIC8vIGRlc2VsZWN0ZWQgX2lkP1xuICAgICAgKHBvcC5vcHRpb25zLnNlbGVjdC5faWQgPT09IDAgfHxcbiAgICAgIC9cXHM/LV9pZFxccz8vLnRlc3QocG9wLm9wdGlvbnMuc2VsZWN0KSk7XG5cbiAgaWYgKGNoZWNrKSB7XG4gICAgY29uc3QgYXRvbWljcyA9IGFycmF5W2FycmF5QXRvbWljc1N5bWJvbF07XG4gICAgaWYgKE9iamVjdC5rZXlzKGF0b21pY3MpLmxlbmd0aCA9PT0gMCB8fCBhdG9taWNzLiRzZXQgfHwgYXRvbWljcy4kcG9wKSB7XG4gICAgICByZXR1cm4gcGF0aDtcbiAgICB9XG4gIH1cbn1cblxuLyoqXG4gKiBBcHBlbmRzIHZlcnNpb25pbmcgdG8gdGhlIHdoZXJlIGFuZCB1cGRhdGUgY2xhdXNlcy5cbiAqXG4gKiBAYXBpIHByaXZhdGVcbiAqIEBtZXRob2QgJF9fdmVyc2lvblxuICogQG1lbWJlck9mIE1vZGVsXG4gKiBAaW5zdGFuY2VcbiAqL1xuXG5Nb2RlbC5wcm90b3R5cGUuJF9fdmVyc2lvbiA9IGZ1bmN0aW9uKHdoZXJlLCBkZWx0YSkge1xuICBjb25zdCBrZXkgPSB0aGlzLiRfX3NjaGVtYS5vcHRpb25zLnZlcnNpb25LZXk7XG4gIGlmICh3aGVyZSA9PT0gdHJ1ZSkge1xuICAgIC8vIHRoaXMgaXMgYW4gaW5zZXJ0XG4gICAgaWYgKGtleSkge1xuICAgICAgc2V0RG90dGVkUGF0aChkZWx0YSwga2V5LCAwKTtcbiAgICAgIHRoaXMuJF9fc2V0VmFsdWUoa2V5LCAwKTtcbiAgICB9XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgaWYgKGtleSA9PT0gZmFsc2UpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICAvLyB1cGRhdGVzXG5cbiAgLy8gb25seSBhcHBseSB2ZXJzaW9uaW5nIGlmIG91ciB2ZXJzaW9uS2V5IHdhcyBzZWxlY3RlZC4gZWxzZVxuICAvLyB0aGVyZSBpcyBubyB3YXkgdG8gc2VsZWN0IHRoZSBjb3JyZWN0IHZlcnNpb24uIHdlIGNvdWxkIGZhaWxcbiAgLy8gZmFzdCBoZXJlIGFuZCBmb3JjZSB0aGVtIHRvIGluY2x1ZGUgdGhlIHZlcnNpb25LZXkgYnV0XG4gIC8vIHRoYXRzIGEgYml0IGludHJ1c2l2ZS4gY2FuIHdlIGRvIHRoaXMgYXV0b21hdGljYWxseT9cblxuICBpZiAoIXRoaXMuJF9faXNTZWxlY3RlZChrZXkpKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgLy8gJHB1c2ggJGFkZFRvU2V0IGRvbid0IG5lZWQgdGhlIHdoZXJlIGNsYXVzZSBzZXRcbiAgaWYgKFZFUlNJT05fV0hFUkUgPT09IChWRVJTSU9OX1dIRVJFICYgdGhpcy4kX18udmVyc2lvbikpIHtcbiAgICBjb25zdCB2YWx1ZSA9IHRoaXMuJF9fZ2V0VmFsdWUoa2V5KTtcbiAgICBpZiAodmFsdWUgIT0gbnVsbCkgd2hlcmVba2V5XSA9IHZhbHVlO1xuICB9XG5cbiAgaWYgKFZFUlNJT05fSU5DID09PSAoVkVSU0lPTl9JTkMgJiB0aGlzLiRfXy52ZXJzaW9uKSkge1xuICAgIGlmIChnZXQoZGVsdGEuJHNldCwga2V5LCBudWxsKSAhPSBudWxsKSB7XG4gICAgICAvLyBWZXJzaW9uIGtleSBpcyBnZXR0aW5nIHNldCwgbWVhbnMgd2UnbGwgaW5jcmVtZW50IHRoZSBkb2MncyB2ZXJzaW9uXG4gICAgICAvLyBhZnRlciBhIHN1Y2Nlc3NmdWwgc2F2ZSwgc28gd2Ugc2hvdWxkIHNldCB0aGUgaW5jcmVtZW50ZWQgdmVyc2lvbiBzb1xuICAgICAgLy8gZnV0dXJlIHNhdmVzIGRvbid0IGZhaWwgKGdoLTU3NzkpXG4gICAgICArK2RlbHRhLiRzZXRba2V5XTtcbiAgICB9IGVsc2Uge1xuICAgICAgZGVsdGEuJGluYyA9IGRlbHRhLiRpbmMgfHwge307XG4gICAgICBkZWx0YS4kaW5jW2tleV0gPSAxO1xuICAgIH1cbiAgfVxufTtcblxuLyohXG4gKiBpZ25vcmVcbiAqL1xuXG5mdW5jdGlvbiBpbmNyZW1lbnQoKSB7XG4gIHRoaXMuJF9fLnZlcnNpb24gPSBWRVJTSU9OX0FMTDtcbiAgcmV0dXJuIHRoaXM7XG59XG5cbi8qKlxuICogU2lnbmFsIHRoYXQgd2UgZGVzaXJlIGFuIGluY3JlbWVudCBvZiB0aGlzIGRvY3VtZW50cyB2ZXJzaW9uLlxuICpcbiAqICMjIyMgRXhhbXBsZTpcbiAqXG4gKiAgICAgY29uc3QgZG9jID0gYXdhaXQgTW9kZWwuZmluZEJ5SWQoaWQpO1xuICogICAgIGRvYy5pbmNyZW1lbnQoKTtcbiAqICAgICBhd2FpdCBkb2Muc2F2ZSgpO1xuICpcbiAqIEBzZWUgdmVyc2lvbktleXMgaHR0cHM6Ly9tb25nb29zZWpzLmNvbS9kb2NzL2d1aWRlLmh0bWwjdmVyc2lvbktleVxuICogQG1lbWJlck9mIE1vZGVsXG4gKiBAbWV0aG9kIGluY3JlbWVudFxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5Nb2RlbC5wcm90b3R5cGUuaW5jcmVtZW50ID0gaW5jcmVtZW50O1xuXG4vKipcbiAqIFJldHVybnMgYSBxdWVyeSBvYmplY3RcbiAqXG4gKiBAYXBpIHByaXZhdGVcbiAqIEBtZXRob2QgJF9fd2hlcmVcbiAqIEBtZW1iZXJPZiBNb2RlbFxuICogQGluc3RhbmNlXG4gKi9cblxuTW9kZWwucHJvdG90eXBlLiRfX3doZXJlID0gZnVuY3Rpb24gX3doZXJlKHdoZXJlKSB7XG4gIHdoZXJlIHx8ICh3aGVyZSA9IHt9KTtcblxuICBpZiAoIXdoZXJlLl9pZCkge1xuICAgIHdoZXJlLl9pZCA9IHRoaXMuX2RvYy5faWQ7XG4gIH1cblxuICBpZiAodGhpcy5fZG9jLl9pZCA9PT0gdm9pZCAwKSB7XG4gICAgcmV0dXJuIG5ldyBNb25nb29zZUVycm9yKCdObyBfaWQgZm91bmQgb24gZG9jdW1lbnQhJyk7XG4gIH1cblxuICByZXR1cm4gd2hlcmU7XG59O1xuXG4vKipcbiAqIERlbGV0ZSB0aGlzIGRvY3VtZW50IGZyb20gdGhlIGRiLlxuICpcbiAqICMjIyMgRXhhbXBsZTpcbiAqXG4gKiAgICAgYXdhaXQgcHJvZHVjdC5kZWxldGVPbmUoKTtcbiAqICAgICBhd2FpdCBQcm9kdWN0LmZpbmRCeUlkKHByb2R1Y3QuX2lkKTsgLy8gbnVsbFxuICpcbiAqIEByZXR1cm4ge1F1ZXJ5fSBRdWVyeVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5Nb2RlbC5wcm90b3R5cGUuZGVsZXRlT25lID0gZnVuY3Rpb24gZGVsZXRlT25lKG9wdGlvbnMpIHtcbiAgaWYgKHR5cGVvZiBvcHRpb25zID09PSAnZnVuY3Rpb24nIHx8XG4gICAgICB0eXBlb2YgYXJndW1lbnRzWzFdID09PSAnZnVuY3Rpb24nKSB7XG4gICAgdGhyb3cgbmV3IE1vbmdvb3NlRXJyb3IoJ01vZGVsLnByb3RvdHlwZS5kZWxldGVPbmUoKSBubyBsb25nZXIgYWNjZXB0cyBhIGNhbGxiYWNrJyk7XG4gIH1cblxuICBpZiAoIW9wdGlvbnMpIHtcbiAgICBvcHRpb25zID0ge307XG4gIH1cblxuICBpZiAob3B0aW9ucy5oYXNPd25Qcm9wZXJ0eSgnc2Vzc2lvbicpKSB7XG4gICAgdGhpcy4kc2Vzc2lvbihvcHRpb25zLnNlc3Npb24pO1xuICB9XG5cbiAgY29uc3Qgc2VsZiA9IHRoaXM7XG4gIGNvbnN0IHdoZXJlID0gdGhpcy4kX193aGVyZSgpO1xuICBpZiAod2hlcmUgaW5zdGFuY2VvZiBFcnJvcikge1xuICAgIHRocm93IHdoZXJlO1xuICB9XG4gIGNvbnN0IHF1ZXJ5ID0gc2VsZi5jb25zdHJ1Y3Rvci5kZWxldGVPbmUod2hlcmUsIG9wdGlvbnMpO1xuXG4gIGlmICh0aGlzLiRzZXNzaW9uKCkgIT0gbnVsbCkge1xuICAgIGlmICghKCdzZXNzaW9uJyBpbiBxdWVyeS5vcHRpb25zKSkge1xuICAgICAgcXVlcnkub3B0aW9ucy5zZXNzaW9uID0gdGhpcy4kc2Vzc2lvbigpO1xuICAgIH1cbiAgfVxuXG4gIHF1ZXJ5LnByZShmdW5jdGlvbiBxdWVyeVByZURlbGV0ZU9uZShjYikge1xuICAgIHNlbGYuY29uc3RydWN0b3IuX21pZGRsZXdhcmUuZXhlY1ByZSgnZGVsZXRlT25lJywgc2VsZiwgW3NlbGZdLCBjYik7XG4gIH0pO1xuICBxdWVyeS5wcmUoZnVuY3Rpb24gY2FsbFN1YmRvY1ByZUhvb2tzKGNiKSB7XG4gICAgZWFjaChzZWxmLiRnZXRBbGxTdWJkb2NzKCksIChzdWJkb2MsIGNiKSA9PiB7XG4gICAgICBzdWJkb2MuY29uc3RydWN0b3IuX21pZGRsZXdhcmUuZXhlY1ByZSgnZGVsZXRlT25lJywgc3ViZG9jLCBbc3ViZG9jXSwgY2IpO1xuICAgIH0sIGNiKTtcbiAgfSk7XG4gIHF1ZXJ5LnByZShmdW5jdGlvbiBza2lwSWZBbHJlYWR5RGVsZXRlZChjYikge1xuICAgIGlmIChzZWxmLiRfXy5pc0RlbGV0ZWQpIHtcbiAgICAgIHJldHVybiBjYihLYXJlZW0uc2tpcFdyYXBwZWRGdW5jdGlvbigpKTtcbiAgICB9XG4gICAgcmV0dXJuIGNiKCk7XG4gIH0pO1xuICBxdWVyeS5wb3N0KGZ1bmN0aW9uIGNhbGxTdWJkb2NQb3N0SG9va3MoY2IpIHtcbiAgICBlYWNoKHNlbGYuJGdldEFsbFN1YmRvY3MoKSwgKHN1YmRvYywgY2IpID0+IHtcbiAgICAgIHN1YmRvYy5jb25zdHJ1Y3Rvci5fbWlkZGxld2FyZS5leGVjUG9zdCgnZGVsZXRlT25lJywgc3ViZG9jLCBbc3ViZG9jXSwge30sIGNiKTtcbiAgICB9LCBjYik7XG4gIH0pO1xuICBxdWVyeS5wb3N0KGZ1bmN0aW9uIHF1ZXJ5UG9zdERlbGV0ZU9uZShjYikge1xuICAgIHNlbGYuY29uc3RydWN0b3IuX21pZGRsZXdhcmUuZXhlY1Bvc3QoJ2RlbGV0ZU9uZScsIHNlbGYsIFtzZWxmXSwge30sIGNiKTtcbiAgfSk7XG5cbiAgcmV0dXJuIHF1ZXJ5O1xufTtcblxuLyoqXG4gKiBSZXR1cm5zIHRoZSBtb2RlbCBpbnN0YW5jZSB1c2VkIHRvIGNyZWF0ZSB0aGlzIGRvY3VtZW50IGlmIG5vIGBuYW1lYCBzcGVjaWZpZWQuXG4gKiBJZiBgbmFtZWAgc3BlY2lmaWVkLCByZXR1cm5zIHRoZSBtb2RlbCB3aXRoIHRoZSBnaXZlbiBgbmFtZWAuXG4gKlxuICogIyMjIyBFeGFtcGxlOlxuICpcbiAqICAgICBjb25zdCBkb2MgPSBuZXcgVGFuayh7fSk7XG4gKiAgICAgZG9jLiRtb2RlbCgpID09PSBUYW5rOyAvLyB0cnVlXG4gKiAgICAgYXdhaXQgZG9jLiRtb2RlbCgnVXNlcicpLmZpbmRCeUlkKGlkKTtcbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gW25hbWVdIG1vZGVsIG5hbWVcbiAqIEBtZXRob2QgJG1vZGVsXG4gKiBAYXBpIHB1YmxpY1xuICogQHJldHVybiB7TW9kZWx9XG4gKi9cblxuTW9kZWwucHJvdG90eXBlLiRtb2RlbCA9IGZ1bmN0aW9uICRtb2RlbChuYW1lKSB7XG4gIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAwKSB7XG4gICAgcmV0dXJuIHRoaXMuY29uc3RydWN0b3I7XG4gIH1cbiAgcmV0dXJuIHRoaXNbbW9kZWxEYlN5bWJvbF0ubW9kZWwobmFtZSk7XG59O1xuXG4vKipcbiAqIFJldHVybnMgdGhlIG1vZGVsIGluc3RhbmNlIHVzZWQgdG8gY3JlYXRlIHRoaXMgZG9jdW1lbnQgaWYgbm8gYG5hbWVgIHNwZWNpZmllZC5cbiAqIElmIGBuYW1lYCBzcGVjaWZpZWQsIHJldHVybnMgdGhlIG1vZGVsIHdpdGggdGhlIGdpdmVuIGBuYW1lYC5cbiAqXG4gKiAjIyMjIEV4YW1wbGU6XG4gKlxuICogICAgIGNvbnN0IGRvYyA9IG5ldyBUYW5rKHt9KTtcbiAqICAgICBkb2MuJG1vZGVsKCkgPT09IFRhbms7IC8vIHRydWVcbiAqICAgICBhd2FpdCBkb2MuJG1vZGVsKCdVc2VyJykuZmluZEJ5SWQoaWQpO1xuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBbbmFtZV0gbW9kZWwgbmFtZVxuICogQG1ldGhvZCBtb2RlbFxuICogQGFwaSBwdWJsaWNcbiAqIEByZXR1cm4ge01vZGVsfVxuICovXG5cbk1vZGVsLnByb3RvdHlwZS5tb2RlbCA9IE1vZGVsLnByb3RvdHlwZS4kbW9kZWw7XG5cbi8qKlxuICogUmV0dXJucyBhIGRvY3VtZW50IHdpdGggYF9pZGAgb25seSBpZiBhdCBsZWFzdCBvbmUgZG9jdW1lbnQgZXhpc3RzIGluIHRoZSBkYXRhYmFzZSB0aGF0IG1hdGNoZXNcbiAqIHRoZSBnaXZlbiBgZmlsdGVyYCwgYW5kIGBudWxsYCBvdGhlcndpc2UuXG4gKlxuICogVW5kZXIgdGhlIGhvb2QsIGBNeU1vZGVsLmV4aXN0cyh7IGFuc3dlcjogNDIgfSlgIGlzIGVxdWl2YWxlbnQgdG9cbiAqIGBNeU1vZGVsLmZpbmRPbmUoeyBhbnN3ZXI6IDQyIH0pLnNlbGVjdCh7IF9pZDogMSB9KS5sZWFuKClgXG4gKlxuICogIyMjIyBFeGFtcGxlOlxuICpcbiAqICAgICBhd2FpdCBDaGFyYWN0ZXIuZGVsZXRlTWFueSh7fSk7XG4gKiAgICAgYXdhaXQgQ2hhcmFjdGVyLmNyZWF0ZSh7IG5hbWU6ICdKZWFuLUx1YyBQaWNhcmQnIH0pO1xuICpcbiAqICAgICBhd2FpdCBDaGFyYWN0ZXIuZXhpc3RzKHsgbmFtZTogL3BpY2FyZC9pIH0pOyAvLyB7IF9pZDogLi4uIH1cbiAqICAgICBhd2FpdCBDaGFyYWN0ZXIuZXhpc3RzKHsgbmFtZTogL3Jpa2VyL2kgfSk7IC8vIG51bGxcbiAqXG4gKiBUaGlzIGZ1bmN0aW9uIHRyaWdnZXJzIHRoZSBmb2xsb3dpbmcgbWlkZGxld2FyZS5cbiAqXG4gKiAtIGBmaW5kT25lKClgXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IGZpbHRlclxuICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSBvcHRpb25hbCBzZWUgW2BRdWVyeS5wcm90b3R5cGUuc2V0T3B0aW9ucygpYF0oaHR0cHM6Ly9tb25nb29zZWpzLmNvbS9kb2NzL2FwaS9xdWVyeS5odG1sI1F1ZXJ5LnByb3RvdHlwZS5zZXRPcHRpb25zKCkpXG4gKiBAcmV0dXJuIHtRdWVyeX1cbiAqL1xuXG5Nb2RlbC5leGlzdHMgPSBmdW5jdGlvbiBleGlzdHMoZmlsdGVyLCBvcHRpb25zKSB7XG4gIF9jaGVja0NvbnRleHQodGhpcywgJ2V4aXN0cycpO1xuICBpZiAodHlwZW9mIGFyZ3VtZW50c1syXSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHRocm93IG5ldyBNb25nb29zZUVycm9yKCdNb2RlbC5leGlzdHMoKSBubyBsb25nZXIgYWNjZXB0cyBhIGNhbGxiYWNrJyk7XG4gIH1cblxuICBjb25zdCBxdWVyeSA9IHRoaXMuZmluZE9uZShmaWx0ZXIpLlxuICAgIHNlbGVjdCh7IF9pZDogMSB9KS5cbiAgICBsZWFuKCkuXG4gICAgc2V0T3B0aW9ucyhvcHRpb25zKTtcblxuICByZXR1cm4gcXVlcnk7XG59O1xuXG4vKipcbiAqIEFkZHMgYSBkaXNjcmltaW5hdG9yIHR5cGUuXG4gKlxuICogIyMjIyBFeGFtcGxlOlxuICpcbiAqICAgICBmdW5jdGlvbiBCYXNlU2NoZW1hKCkge1xuICogICAgICAgU2NoZW1hLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gKlxuICogICAgICAgdGhpcy5hZGQoe1xuICogICAgICAgICBuYW1lOiBTdHJpbmcsXG4gKiAgICAgICAgIGNyZWF0ZWRBdDogRGF0ZVxuICogICAgICAgfSk7XG4gKiAgICAgfVxuICogICAgIHV0aWwuaW5oZXJpdHMoQmFzZVNjaGVtYSwgU2NoZW1hKTtcbiAqXG4gKiAgICAgY29uc3QgUGVyc29uU2NoZW1hID0gbmV3IEJhc2VTY2hlbWEoKTtcbiAqICAgICBjb25zdCBCb3NzU2NoZW1hID0gbmV3IEJhc2VTY2hlbWEoeyBkZXBhcnRtZW50OiBTdHJpbmcgfSk7XG4gKlxuICogICAgIGNvbnN0IFBlcnNvbiA9IG1vbmdvb3NlLm1vZGVsKCdQZXJzb24nLCBQZXJzb25TY2hlbWEpO1xuICogICAgIGNvbnN0IEJvc3MgPSBQZXJzb24uZGlzY3JpbWluYXRvcignQm9zcycsIEJvc3NTY2hlbWEpO1xuICogICAgIG5ldyBCb3NzKCkuX190OyAvLyBcIkJvc3NcIi4gYF9fdGAgaXMgdGhlIGRlZmF1bHQgYGRpc2NyaW1pbmF0b3JLZXlgXG4gKlxuICogICAgIGNvbnN0IGVtcGxveWVlU2NoZW1hID0gbmV3IFNjaGVtYSh7IGJvc3M6IE9iamVjdElkIH0pO1xuICogICAgIGNvbnN0IEVtcGxveWVlID0gUGVyc29uLmRpc2NyaW1pbmF0b3IoJ0VtcGxveWVlJywgZW1wbG95ZWVTY2hlbWEsICdzdGFmZicpO1xuICogICAgIG5ldyBFbXBsb3llZSgpLl9fdDsgLy8gXCJzdGFmZlwiIGJlY2F1c2Ugb2YgM3JkIGFyZ3VtZW50IGFib3ZlXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IG5hbWUgZGlzY3JpbWluYXRvciBtb2RlbCBuYW1lXG4gKiBAcGFyYW0ge1NjaGVtYX0gc2NoZW1hIGRpc2NyaW1pbmF0b3IgbW9kZWwgc2NoZW1hXG4gKiBAcGFyYW0ge09iamVjdHxTdHJpbmd9IFtvcHRpb25zXSBJZiBzdHJpbmcsIHNhbWUgYXMgYG9wdGlvbnMudmFsdWVgLlxuICogQHBhcmFtIHtTdHJpbmd9IFtvcHRpb25zLnZhbHVlXSB0aGUgc3RyaW5nIHN0b3JlZCBpbiB0aGUgYGRpc2NyaW1pbmF0b3JLZXlgIHByb3BlcnR5LiBJZiBub3Qgc3BlY2lmaWVkLCBNb25nb29zZSB1c2VzIHRoZSBgbmFtZWAgcGFyYW1ldGVyLlxuICogQHBhcmFtIHtCb29sZWFufSBbb3B0aW9ucy5jbG9uZT10cnVlXSBCeSBkZWZhdWx0LCBgZGlzY3JpbWluYXRvcigpYCBjbG9uZXMgdGhlIGdpdmVuIGBzY2hlbWFgLiBTZXQgdG8gYGZhbHNlYCB0byBza2lwIGNsb25pbmcuXG4gKiBAcGFyYW0ge0Jvb2xlYW59IFtvcHRpb25zLm92ZXJ3cml0ZU1vZGVscz1mYWxzZV0gYnkgZGVmYXVsdCwgTW9uZ29vc2UgZG9lcyBub3QgYWxsb3cgeW91IHRvIGRlZmluZSBhIGRpc2NyaW1pbmF0b3Igd2l0aCB0aGUgc2FtZSBuYW1lIGFzIGFub3RoZXIgZGlzY3JpbWluYXRvci4gU2V0IHRoaXMgdG8gYWxsb3cgb3ZlcndyaXRpbmcgZGlzY3JpbWluYXRvcnMgd2l0aCB0aGUgc2FtZSBuYW1lLlxuICogQHBhcmFtIHtCb29sZWFufSBbb3B0aW9ucy5tZXJnZUhvb2tzPXRydWVdIEJ5IGRlZmF1bHQsIE1vbmdvb3NlIG1lcmdlcyB0aGUgYmFzZSBzY2hlbWEncyBob29rcyB3aXRoIHRoZSBkaXNjcmltaW5hdG9yIHNjaGVtYSdzIGhvb2tzLiBTZXQgdGhpcyBvcHRpb24gdG8gYGZhbHNlYCB0byBtYWtlIE1vbmdvb3NlIHVzZSB0aGUgZGlzY3JpbWluYXRvciBzY2hlbWEncyBob29rcyBpbnN0ZWFkLlxuICogQHBhcmFtIHtCb29sZWFufSBbb3B0aW9ucy5tZXJnZVBsdWdpbnM9dHJ1ZV0gQnkgZGVmYXVsdCwgTW9uZ29vc2UgbWVyZ2VzIHRoZSBiYXNlIHNjaGVtYSdzIHBsdWdpbnMgd2l0aCB0aGUgZGlzY3JpbWluYXRvciBzY2hlbWEncyBwbHVnaW5zLiBTZXQgdGhpcyBvcHRpb24gdG8gYGZhbHNlYCB0byBtYWtlIE1vbmdvb3NlIHVzZSB0aGUgZGlzY3JpbWluYXRvciBzY2hlbWEncyBwbHVnaW5zIGluc3RlYWQuXG4gKiBAcmV0dXJuIHtNb2RlbH0gVGhlIG5ld2x5IGNyZWF0ZWQgZGlzY3JpbWluYXRvciBtb2RlbFxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5Nb2RlbC5kaXNjcmltaW5hdG9yID0gZnVuY3Rpb24obmFtZSwgc2NoZW1hLCBvcHRpb25zKSB7XG4gIGxldCBtb2RlbDtcbiAgaWYgKHR5cGVvZiBuYW1lID09PSAnZnVuY3Rpb24nKSB7XG4gICAgbW9kZWwgPSBuYW1lO1xuICAgIG5hbWUgPSB1dGlscy5nZXRGdW5jdGlvbk5hbWUobW9kZWwpO1xuICAgIGlmICghKG1vZGVsLnByb3RvdHlwZSBpbnN0YW5jZW9mIE1vZGVsKSkge1xuICAgICAgdGhyb3cgbmV3IE1vbmdvb3NlRXJyb3IoJ1RoZSBwcm92aWRlZCBjbGFzcyAnICsgbmFtZSArICcgbXVzdCBleHRlbmQgTW9kZWwnKTtcbiAgICB9XG4gIH1cblxuICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgY29uc3QgdmFsdWUgPSB1dGlscy5pc1BPSk8ob3B0aW9ucykgPyBvcHRpb25zLnZhbHVlIDogb3B0aW9ucztcbiAgY29uc3QgY2xvbmUgPSB0eXBlb2Ygb3B0aW9ucy5jbG9uZSA9PT0gJ2Jvb2xlYW4nID8gb3B0aW9ucy5jbG9uZSA6IHRydWU7XG4gIGNvbnN0IG1lcmdlUGx1Z2lucyA9IHR5cGVvZiBvcHRpb25zLm1lcmdlUGx1Z2lucyA9PT0gJ2Jvb2xlYW4nID8gb3B0aW9ucy5tZXJnZVBsdWdpbnMgOiB0cnVlO1xuXG4gIF9jaGVja0NvbnRleHQodGhpcywgJ2Rpc2NyaW1pbmF0b3InKTtcblxuICBpZiAodXRpbHMuaXNPYmplY3Qoc2NoZW1hKSAmJiAhc2NoZW1hLmluc3RhbmNlT2ZTY2hlbWEpIHtcbiAgICBzY2hlbWEgPSBuZXcgU2NoZW1hKHNjaGVtYSk7XG4gIH1cbiAgaWYgKHNjaGVtYSBpbnN0YW5jZW9mIFNjaGVtYSAmJiBjbG9uZSkge1xuICAgIHNjaGVtYSA9IHNjaGVtYS5jbG9uZSgpO1xuICB9XG5cbiAgc2NoZW1hID0gZGlzY3JpbWluYXRvcih0aGlzLCBuYW1lLCBzY2hlbWEsIHZhbHVlLCBtZXJnZVBsdWdpbnMsIG9wdGlvbnMubWVyZ2VIb29rcyk7XG4gIGlmICh0aGlzLmRiLm1vZGVsc1tuYW1lXSAmJiAhc2NoZW1hLm9wdGlvbnMub3ZlcndyaXRlTW9kZWxzKSB7XG4gICAgdGhyb3cgbmV3IE92ZXJ3cml0ZU1vZGVsRXJyb3IobmFtZSk7XG4gIH1cblxuICBzY2hlbWEuJGlzUm9vdERpc2NyaW1pbmF0b3IgPSB0cnVlO1xuICBzY2hlbWEuJGdsb2JhbFBsdWdpbnNBcHBsaWVkID0gdHJ1ZTtcblxuICBtb2RlbCA9IHRoaXMuZGIubW9kZWwobW9kZWwgfHwgbmFtZSwgc2NoZW1hLCB0aGlzLiRfX2NvbGxlY3Rpb24ubmFtZSk7XG4gIHRoaXMuZGlzY3JpbWluYXRvcnNbbmFtZV0gPSBtb2RlbDtcbiAgY29uc3QgZCA9IHRoaXMuZGlzY3JpbWluYXRvcnNbbmFtZV07XG4gIE9iamVjdC5zZXRQcm90b3R5cGVPZihkLnByb3RvdHlwZSwgdGhpcy5wcm90b3R5cGUpO1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZCwgJ2Jhc2VNb2RlbE5hbWUnLCB7XG4gICAgdmFsdWU6IHRoaXMubW9kZWxOYW1lLFxuICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICB3cml0YWJsZTogZmFsc2VcbiAgfSk7XG5cbiAgLy8gYXBwbHkgbWV0aG9kcyBhbmQgc3RhdGljc1xuICBhcHBseU1ldGhvZHMoZCwgc2NoZW1hKTtcbiAgYXBwbHlTdGF0aWNzKGQsIHNjaGVtYSk7XG5cbiAgaWYgKHRoaXNbc3ViY2xhc3NlZFN5bWJvbF0gIT0gbnVsbCkge1xuICAgIGZvciAoY29uc3Qgc3VibW9kZWwgb2YgdGhpc1tzdWJjbGFzc2VkU3ltYm9sXSkge1xuICAgICAgc3VibW9kZWwuZGlzY3JpbWluYXRvcnMgPSBzdWJtb2RlbC5kaXNjcmltaW5hdG9ycyB8fCB7fTtcbiAgICAgIHN1Ym1vZGVsLmRpc2NyaW1pbmF0b3JzW25hbWVdID1cbiAgICAgICAgbW9kZWwuX19zdWJjbGFzcyhtb2RlbC5kYiwgc2NoZW1hLCBzdWJtb2RlbC5jb2xsZWN0aW9uLm5hbWUpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBkO1xufTtcblxuLyoqXG4gKiBNYWtlIHN1cmUgYHRoaXNgIGlzIGEgbW9kZWxcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmZ1bmN0aW9uIF9jaGVja0NvbnRleHQoY3R4LCBmbk5hbWUpIHtcbiAgLy8gQ2hlY2sgY29udGV4dCwgYmVjYXVzZSBpdCBpcyBlYXN5IHRvIG1pc3Rha2VubHkgdHlwZVxuICAvLyBgbmV3IE1vZGVsLmRpc2NyaW1pbmF0b3IoKWAgYW5kIGdldCBhbiBpbmNvbXByZWhlbnNpYmxlIGVycm9yXG4gIGlmIChjdHggPT0gbnVsbCB8fCBjdHggPT09IGdsb2JhbCkge1xuICAgIHRocm93IG5ldyBNb25nb29zZUVycm9yKCdgTW9kZWwuJyArIGZuTmFtZSArICcoKWAgY2Fubm90IHJ1biB3aXRob3V0IGEgJyArXG4gICAgICAnbW9kZWwgYXMgYHRoaXNgLiBNYWtlIHN1cmUgeW91IGFyZSBjYWxsaW5nIGBNeU1vZGVsLicgKyBmbk5hbWUgKyAnKClgICcgK1xuICAgICAgJ3doZXJlIGBNeU1vZGVsYCBpcyBhIE1vbmdvb3NlIG1vZGVsLicpO1xuICB9IGVsc2UgaWYgKGN0eFttb2RlbFN5bWJvbF0gPT0gbnVsbCkge1xuICAgIHRocm93IG5ldyBNb25nb29zZUVycm9yKCdgTW9kZWwuJyArIGZuTmFtZSArICcoKWAgY2Fubm90IHJ1biB3aXRob3V0IGEgJyArXG4gICAgICAnbW9kZWwgYXMgYHRoaXNgLiBNYWtlIHN1cmUgeW91IGFyZSBub3QgY2FsbGluZyAnICtcbiAgICAgICdgbmV3IE1vZGVsLicgKyBmbk5hbWUgKyAnKClgJyk7XG4gIH1cbn1cblxuLy8gTW9kZWwgKGNsYXNzKSBmZWF0dXJlc1xuXG4vKiFcbiAqIEdpdmUgdGhlIGNvbnN0cnVjdG9yIHRoZSBhYmlsaXR5IHRvIGVtaXQgZXZlbnRzLlxuICovXG5cbmZvciAoY29uc3QgaSBpbiBFdmVudEVtaXR0ZXIucHJvdG90eXBlKSB7XG4gIE1vZGVsW2ldID0gRXZlbnRFbWl0dGVyLnByb3RvdHlwZVtpXTtcbn1cblxuLyoqXG4gKiBUaGlzIGZ1bmN0aW9uIGlzIHJlc3BvbnNpYmxlIGZvciBidWlsZGluZyBbaW5kZXhlc10oaHR0cHM6Ly93d3cubW9uZ29kYi5jb20vZG9jcy9tYW51YWwvaW5kZXhlcy8pLFxuICogdW5sZXNzIFtgYXV0b0luZGV4YF0oaHR0cHM6Ly9tb25nb29zZWpzLmNvbS9kb2NzL2d1aWRlLmh0bWwjYXV0b0luZGV4KSBpcyB0dXJuZWQgb2ZmLlxuICpcbiAqIE1vbmdvb3NlIGNhbGxzIHRoaXMgZnVuY3Rpb24gYXV0b21hdGljYWxseSB3aGVuIGEgbW9kZWwgaXMgY3JlYXRlZCB1c2luZ1xuICogW2Btb25nb29zZS5tb2RlbCgpYF0oaHR0cHM6Ly9tb25nb29zZWpzLmNvbS9kb2NzL2FwaS9tb25nb29zZS5odG1sI01vbmdvb3NlLnByb3RvdHlwZS5tb2RlbCgpKSBvclxuICogW2Bjb25uZWN0aW9uLm1vZGVsKClgXShodHRwczovL21vbmdvb3NlanMuY29tL2RvY3MvYXBpL2Nvbm5lY3Rpb24uaHRtbCNDb25uZWN0aW9uLnByb3RvdHlwZS5tb2RlbCgpKSwgc28geW91XG4gKiBkb24ndCBuZWVkIHRvIGNhbGwgYGluaXQoKWAgdG8gdHJpZ2dlciBpbmRleCBidWlsZHMuXG4gKlxuICogSG93ZXZlciwgeW91IF9tYXlfIG5lZWQgdG8gY2FsbCBgaW5pdCgpYCAgdG8gZ2V0IGJhY2sgYSBwcm9taXNlIHRoYXQgd2lsbCByZXNvbHZlIHdoZW4geW91ciBpbmRleGVzIGFyZSBmaW5pc2hlZC5cbiAqIENhbGxpbmcgYGF3YWl0IE1vZGVsLmluaXQoKWAgaXMgaGVscGZ1bCBpZiB5b3UgbmVlZCB0byB3YWl0IGZvciBpbmRleGVzIHRvIGJ1aWxkIGJlZm9yZSBjb250aW51aW5nLlxuICogRm9yIGV4YW1wbGUsIGlmIHlvdSB3YW50IHRvIHdhaXQgZm9yIHVuaXF1ZSBpbmRleGVzIHRvIGJ1aWxkIGJlZm9yZSBjb250aW51aW5nIHdpdGggYSB0ZXN0IGNhc2UuXG4gKlxuICogIyMjIyBFeGFtcGxlOlxuICpcbiAqICAgICBjb25zdCBldmVudFNjaGVtYSA9IG5ldyBTY2hlbWEoeyB0aGluZzogeyB0eXBlOiAnc3RyaW5nJywgdW5pcXVlOiB0cnVlIH0gfSlcbiAqICAgICAvLyBUaGlzIGNhbGxzIGBFdmVudC5pbml0KClgIGltcGxpY2l0bHksIHNvIHlvdSBkb24ndCBuZWVkIHRvIGNhbGxcbiAqICAgICAvLyBgRXZlbnQuaW5pdCgpYCBvbiB5b3VyIG93bi5cbiAqICAgICBjb25zdCBFdmVudCA9IG1vbmdvb3NlLm1vZGVsKCdFdmVudCcsIGV2ZW50U2NoZW1hKTtcbiAqXG4gKiAgICAgYXdhaXQgRXZlbnQuaW5pdCgpO1xuICogICAgIGNvbnNvbGUubG9nKCdJbmRleGVzIGFyZSBkb25lIGJ1aWxkaW5nIScpO1xuICpcbiAqIEBhcGkgcHVibGljXG4gKiBAcmV0dXJucyB7UHJvbWlzZX1cbiAqL1xuXG5Nb2RlbC5pbml0ID0gZnVuY3Rpb24gaW5pdCgpIHtcbiAgX2NoZWNrQ29udGV4dCh0aGlzLCAnaW5pdCcpO1xuICBpZiAodHlwZW9mIGFyZ3VtZW50c1swXSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHRocm93IG5ldyBNb25nb29zZUVycm9yKCdNb2RlbC5pbml0KCkgbm8gbG9uZ2VyIGFjY2VwdHMgYSBjYWxsYmFjaycpO1xuICB9XG5cbiAgdGhpcy5zY2hlbWEuZW1pdCgnaW5pdCcsIHRoaXMpO1xuXG4gIGlmICh0aGlzLiRpbml0ICE9IG51bGwpIHtcbiAgICByZXR1cm4gdGhpcy4kaW5pdDtcbiAgfVxuXG4gIGNvbnN0IGNvbm4gPSB0aGlzLmRiO1xuICBjb25zdCBfZW5zdXJlSW5kZXhlcyA9IGFzeW5jKCkgPT4ge1xuICAgIGNvbnN0IGF1dG9JbmRleCA9IHV0aWxzLmdldE9wdGlvbihcbiAgICAgICdhdXRvSW5kZXgnLFxuICAgICAgdGhpcy5zY2hlbWEub3B0aW9ucyxcbiAgICAgIGNvbm4uY29uZmlnLFxuICAgICAgY29ubi5iYXNlLm9wdGlvbnNcbiAgICApO1xuICAgIGlmICghYXV0b0luZGV4KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHJldHVybiBhd2FpdCB0aGlzLmVuc3VyZUluZGV4ZXMoeyBfYXV0b21hdGljOiB0cnVlIH0pO1xuICB9O1xuICBjb25zdCBfY3JlYXRlQ29sbGVjdGlvbiA9IGFzeW5jKCkgPT4ge1xuICAgIGlmICgoY29ubi5yZWFkeVN0YXRlID09PSBTVEFURVMuY29ubmVjdGluZyB8fCBjb25uLnJlYWR5U3RhdGUgPT09IFNUQVRFUy5kaXNjb25uZWN0ZWQpICYmIGNvbm4uX3Nob3VsZEJ1ZmZlckNvbW1hbmRzKCkpIHtcbiAgICAgIGF3YWl0IG5ldyBQcm9taXNlKHJlc29sdmUgPT4ge1xuICAgICAgICBjb25uLl9xdWV1ZS5wdXNoKHsgZm46IHJlc29sdmUgfSk7XG4gICAgICB9KTtcbiAgICB9XG4gICAgY29uc3QgYXV0b0NyZWF0ZSA9IHV0aWxzLmdldE9wdGlvbihcbiAgICAgICdhdXRvQ3JlYXRlJyxcbiAgICAgIHRoaXMuc2NoZW1hLm9wdGlvbnMsXG4gICAgICBjb25uLmNvbmZpZyxcbiAgICAgIGNvbm4uYmFzZS5vcHRpb25zXG4gICAgKTtcbiAgICBpZiAoIWF1dG9DcmVhdGUpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgcmV0dXJuIGF3YWl0IHRoaXMuY3JlYXRlQ29sbGVjdGlvbigpO1xuICB9O1xuXG4gIHRoaXMuJGluaXQgPSBfY3JlYXRlQ29sbGVjdGlvbigpLnRoZW4oKCkgPT4gX2Vuc3VyZUluZGV4ZXMoKSk7XG5cbiAgY29uc3QgX2NhdGNoID0gdGhpcy4kaW5pdC5jYXRjaDtcbiAgY29uc3QgX3RoaXMgPSB0aGlzO1xuICB0aGlzLiRpbml0LmNhdGNoID0gZnVuY3Rpb24oKSB7XG4gICAgX3RoaXMuJGNhdWdodCA9IHRydWU7XG4gICAgcmV0dXJuIF9jYXRjaC5hcHBseShfdGhpcy4kaW5pdCwgYXJndW1lbnRzKTtcbiAgfTtcblxuICByZXR1cm4gdGhpcy4kaW5pdDtcbn07XG5cblxuLyoqXG4gKiBDcmVhdGUgdGhlIGNvbGxlY3Rpb24gZm9yIHRoaXMgbW9kZWwuIEJ5IGRlZmF1bHQsIGlmIG5vIGluZGV4ZXMgYXJlIHNwZWNpZmllZCxcbiAqIG1vbmdvb3NlIHdpbGwgbm90IGNyZWF0ZSB0aGUgY29sbGVjdGlvbiBmb3IgdGhlIG1vZGVsIHVudGlsIGFueSBkb2N1bWVudHMgYXJlXG4gKiBjcmVhdGVkLiBVc2UgdGhpcyBtZXRob2QgdG8gY3JlYXRlIHRoZSBjb2xsZWN0aW9uIGV4cGxpY2l0bHkuXG4gKlxuICogTm90ZSAxOiBZb3UgbWF5IG5lZWQgdG8gY2FsbCB0aGlzIGJlZm9yZSBzdGFydGluZyBhIHRyYW5zYWN0aW9uXG4gKiBTZWUgaHR0cHM6Ly93d3cubW9uZ29kYi5jb20vZG9jcy9tYW51YWwvY29yZS90cmFuc2FjdGlvbnMvI3RyYW5zYWN0aW9ucy1hbmQtb3BlcmF0aW9uc1xuICpcbiAqIE5vdGUgMjogWW91IGRvbid0IGhhdmUgdG8gY2FsbCB0aGlzIGlmIHlvdXIgc2NoZW1hIGNvbnRhaW5zIGluZGV4IG9yIHVuaXF1ZSBmaWVsZC5cbiAqIEluIHRoYXQgY2FzZSwganVzdCB1c2UgYE1vZGVsLmluaXQoKWBcbiAqXG4gKiAjIyMjIEV4YW1wbGU6XG4gKlxuICogICAgIGNvbnN0IHVzZXJTY2hlbWEgPSBuZXcgU2NoZW1hKHsgbmFtZTogU3RyaW5nIH0pXG4gKiAgICAgY29uc3QgVXNlciA9IG1vbmdvb3NlLm1vZGVsKCdVc2VyJywgdXNlclNjaGVtYSk7XG4gKlxuICogICAgIFVzZXIuY3JlYXRlQ29sbGVjdGlvbigpLnRoZW4oZnVuY3Rpb24oY29sbGVjdGlvbikge1xuICogICAgICAgY29uc29sZS5sb2coJ0NvbGxlY3Rpb24gaXMgY3JlYXRlZCEnKTtcbiAqICAgICB9KTtcbiAqXG4gKiBAYXBpIHB1YmxpY1xuICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSBzZWUgW01vbmdvREIgZHJpdmVyIGRvY3NdKGh0dHBzOi8vbW9uZ29kYi5naXRodWIuaW8vbm9kZS1tb25nb2RiLW5hdGl2ZS80LjkvY2xhc3Nlcy9EYi5odG1sI2NyZWF0ZUNvbGxlY3Rpb24pXG4gKiBAcmV0dXJucyB7UHJvbWlzZX1cbiAqL1xuXG5Nb2RlbC5jcmVhdGVDb2xsZWN0aW9uID0gYXN5bmMgZnVuY3Rpb24gY3JlYXRlQ29sbGVjdGlvbihvcHRpb25zKSB7XG4gIF9jaGVja0NvbnRleHQodGhpcywgJ2NyZWF0ZUNvbGxlY3Rpb24nKTtcbiAgaWYgKHR5cGVvZiBhcmd1bWVudHNbMF0gPT09ICdmdW5jdGlvbicgfHwgdHlwZW9mIGFyZ3VtZW50c1sxXSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHRocm93IG5ldyBNb25nb29zZUVycm9yKCdNb2RlbC5jcmVhdGVDb2xsZWN0aW9uKCkgbm8gbG9uZ2VyIGFjY2VwdHMgYSBjYWxsYmFjaycpO1xuICB9XG5cbiAgY29uc3QgY29sbGVjdGlvbk9wdGlvbnMgPSB0aGlzICYmXG4gICAgdGhpcy5zY2hlbWEgJiZcbiAgICB0aGlzLnNjaGVtYS5vcHRpb25zICYmXG4gICAgdGhpcy5zY2hlbWEub3B0aW9ucy5jb2xsZWN0aW9uT3B0aW9ucztcbiAgaWYgKGNvbGxlY3Rpb25PcHRpb25zICE9IG51bGwpIHtcbiAgICBvcHRpb25zID0gT2JqZWN0LmFzc2lnbih7fSwgY29sbGVjdGlvbk9wdGlvbnMsIG9wdGlvbnMpO1xuICB9XG5cbiAgY29uc3Qgc2NoZW1hQ29sbGF0aW9uID0gdGhpcyAmJlxuICAgIHRoaXMuc2NoZW1hICYmXG4gICAgdGhpcy5zY2hlbWEub3B0aW9ucyAmJlxuICAgIHRoaXMuc2NoZW1hLm9wdGlvbnMuY29sbGF0aW9uO1xuICBpZiAoc2NoZW1hQ29sbGF0aW9uICE9IG51bGwpIHtcbiAgICBvcHRpb25zID0gT2JqZWN0LmFzc2lnbih7IGNvbGxhdGlvbjogc2NoZW1hQ29sbGF0aW9uIH0sIG9wdGlvbnMpO1xuICB9XG4gIGNvbnN0IGNhcHBlZCA9IHRoaXMgJiZcbiAgICB0aGlzLnNjaGVtYSAmJlxuICAgIHRoaXMuc2NoZW1hLm9wdGlvbnMgJiZcbiAgICB0aGlzLnNjaGVtYS5vcHRpb25zLmNhcHBlZDtcbiAgaWYgKGNhcHBlZCAhPSBudWxsKSB7XG4gICAgaWYgKHR5cGVvZiBjYXBwZWQgPT09ICdudW1iZXInKSB7XG4gICAgICBvcHRpb25zID0gT2JqZWN0LmFzc2lnbih7IGNhcHBlZDogdHJ1ZSwgc2l6ZTogY2FwcGVkIH0sIG9wdGlvbnMpO1xuICAgIH0gZWxzZSBpZiAodHlwZW9mIGNhcHBlZCA9PT0gJ29iamVjdCcpIHtcbiAgICAgIG9wdGlvbnMgPSBPYmplY3QuYXNzaWduKHsgY2FwcGVkOiB0cnVlIH0sIGNhcHBlZCwgb3B0aW9ucyk7XG4gICAgfVxuICB9XG4gIGNvbnN0IHRpbWVzZXJpZXMgPSB0aGlzICYmXG4gICAgdGhpcy5zY2hlbWEgJiZcbiAgICB0aGlzLnNjaGVtYS5vcHRpb25zICYmXG4gICAgdGhpcy5zY2hlbWEub3B0aW9ucy50aW1lc2VyaWVzO1xuICBpZiAodGltZXNlcmllcyAhPSBudWxsKSB7XG4gICAgb3B0aW9ucyA9IE9iamVjdC5hc3NpZ24oeyB0aW1lc2VyaWVzIH0sIG9wdGlvbnMpO1xuICAgIGlmIChvcHRpb25zLmV4cGlyZUFmdGVyU2Vjb25kcyAhPSBudWxsKSB7XG4gICAgICAvLyBkbyBub3RoaW5nXG4gICAgfSBlbHNlIGlmIChvcHRpb25zLmV4cGlyZXMgIT0gbnVsbCkge1xuICAgICAgdXRpbHMuZXhwaXJlcyhvcHRpb25zKTtcbiAgICB9IGVsc2UgaWYgKHRoaXMuc2NoZW1hLm9wdGlvbnMuZXhwaXJlQWZ0ZXJTZWNvbmRzICE9IG51bGwpIHtcbiAgICAgIG9wdGlvbnMuZXhwaXJlQWZ0ZXJTZWNvbmRzID0gdGhpcy5zY2hlbWEub3B0aW9ucy5leHBpcmVBZnRlclNlY29uZHM7XG4gICAgfSBlbHNlIGlmICh0aGlzLnNjaGVtYS5vcHRpb25zLmV4cGlyZXMgIT0gbnVsbCkge1xuICAgICAgb3B0aW9ucy5leHBpcmVzID0gdGhpcy5zY2hlbWEub3B0aW9ucy5leHBpcmVzO1xuICAgICAgdXRpbHMuZXhwaXJlcyhvcHRpb25zKTtcbiAgICB9XG4gIH1cblxuICBjb25zdCBjbHVzdGVyZWRJbmRleCA9IHRoaXMgJiZcbiAgICB0aGlzLnNjaGVtYSAmJlxuICAgIHRoaXMuc2NoZW1hLm9wdGlvbnMgJiZcbiAgICB0aGlzLnNjaGVtYS5vcHRpb25zLmNsdXN0ZXJlZEluZGV4O1xuICBpZiAoY2x1c3RlcmVkSW5kZXggIT0gbnVsbCkge1xuICAgIG9wdGlvbnMgPSBPYmplY3QuYXNzaWduKHsgY2x1c3RlcmVkSW5kZXg6IHsgLi4uY2x1c3RlcmVkSW5kZXgsIHVuaXF1ZTogdHJ1ZSB9IH0sIG9wdGlvbnMpO1xuICB9XG5cbiAgdHJ5IHtcbiAgICBhd2FpdCB0aGlzLmRiLmNyZWF0ZUNvbGxlY3Rpb24odGhpcy4kX19jb2xsZWN0aW9uLmNvbGxlY3Rpb25OYW1lLCBvcHRpb25zKTtcbiAgfSBjYXRjaCAoZXJyKSB7XG5cbiAgICBpZiAoZXJyICE9IG51bGwgJiYgKGVyci5uYW1lICE9PSAnTW9uZ29TZXJ2ZXJFcnJvcicgfHwgZXJyLmNvZGUgIT09IDQ4KSkge1xuICAgICAgdGhyb3cgZXJyO1xuICAgIH1cbiAgfVxuICByZXR1cm4gdGhpcy4kX19jb2xsZWN0aW9uO1xufTtcblxuLyoqXG4gKiBNYWtlcyB0aGUgaW5kZXhlcyBpbiBNb25nb0RCIG1hdGNoIHRoZSBpbmRleGVzIGRlZmluZWQgaW4gdGhpcyBtb2RlbCdzXG4gKiBzY2hlbWEuIFRoaXMgZnVuY3Rpb24gd2lsbCBkcm9wIGFueSBpbmRleGVzIHRoYXQgYXJlIG5vdCBkZWZpbmVkIGluXG4gKiB0aGUgbW9kZWwncyBzY2hlbWEgZXhjZXB0IHRoZSBgX2lkYCBpbmRleCwgYW5kIGJ1aWxkIGFueSBpbmRleGVzIHRoYXRcbiAqIGFyZSBpbiB5b3VyIHNjaGVtYSBidXQgbm90IGluIE1vbmdvREIuXG4gKlxuICogU2VlIHRoZSBbaW50cm9kdWN0b3J5IGJsb2cgcG9zdF0oaHR0cHM6Ly90aGVjb2RlYmFyYmFyaWFuLmNvbS93aGF0cy1uZXctaW4tbW9uZ29vc2UtNS0yLXN5bmNpbmRleGVzKVxuICogZm9yIG1vcmUgaW5mb3JtYXRpb24uXG4gKlxuICogIyMjIyBFeGFtcGxlOlxuICpcbiAqICAgICBjb25zdCBzY2hlbWEgPSBuZXcgU2NoZW1hKHsgbmFtZTogeyB0eXBlOiBTdHJpbmcsIHVuaXF1ZTogdHJ1ZSB9IH0pO1xuICogICAgIGNvbnN0IEN1c3RvbWVyID0gbW9uZ29vc2UubW9kZWwoJ0N1c3RvbWVyJywgc2NoZW1hKTtcbiAqICAgICBhd2FpdCBDdXN0b21lci5jb2xsZWN0aW9uLmNyZWF0ZUluZGV4KHsgYWdlOiAxIH0pOyAvLyBJbmRleCBpcyBub3QgaW4gc2NoZW1hXG4gKiAgICAgLy8gV2lsbCBkcm9wIHRoZSAnYWdlJyBpbmRleCBhbmQgY3JlYXRlIGFuIGluZGV4IG9uIGBuYW1lYFxuICogICAgIGF3YWl0IEN1c3RvbWVyLnN5bmNJbmRleGVzKCk7XG4gKlxuICogWW91IHNob3VsZCBiZSBjYXJlZnVsIGFib3V0IHJ1bm5pbmcgYHN5bmNJbmRleGVzKClgIG9uIHByb2R1Y3Rpb24gYXBwbGljYXRpb25zIHVuZGVyIGhlYXZ5IGxvYWQsXG4gKiBiZWNhdXNlIGluZGV4IGJ1aWxkcyBhcmUgZXhwZW5zaXZlIG9wZXJhdGlvbnMsIGFuZCB1bmV4cGVjdGVkIGluZGV4IGRyb3BzIGNhbiBsZWFkIHRvIGRlZ3JhZGVkXG4gKiBwZXJmb3JtYW5jZS4gQmVmb3JlIHJ1bm5pbmcgYHN5bmNJbmRleGVzKClgLCB5b3UgY2FuIHVzZSB0aGUgW2BkaWZmSW5kZXhlcygpYCBmdW5jdGlvbl0oI01vZGVsLmRpZmZJbmRleGVzKCkpXG4gKiB0byBjaGVjayB3aGF0IGluZGV4ZXMgYHN5bmNJbmRleGVzKClgIHdpbGwgZHJvcCBhbmQgY3JlYXRlLlxuICpcbiAqICMjIyMgRXhhbXBsZTpcbiAqXG4gKiAgICAgY29uc3QgeyB0b0Ryb3AsIHRvQ3JlYXRlIH0gPSBhd2FpdCBNb2RlbC5kaWZmSW5kZXhlcygpO1xuICogICAgIHRvRHJvcDsgLy8gQXJyYXkgb2Ygc3RyaW5ncyBjb250YWluaW5nIG5hbWVzIG9mIGluZGV4ZXMgdGhhdCBgc3luY0luZGV4ZXMoKWAgd2lsbCBkcm9wXG4gKiAgICAgdG9DcmVhdGU7IC8vIEFycmF5IG9mIHN0cmluZ3MgY29udGFpbmluZyBuYW1lcyBvZiBpbmRleGVzIHRoYXQgYHN5bmNJbmRleGVzKClgIHdpbGwgY3JlYXRlXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSBvcHRpb25zIHRvIHBhc3MgdG8gYGVuc3VyZUluZGV4ZXMoKWBcbiAqIEBwYXJhbSB7Qm9vbGVhbn0gW29wdGlvbnMuYmFja2dyb3VuZD1udWxsXSBpZiBzcGVjaWZpZWQsIG92ZXJyaWRlcyBlYWNoIGluZGV4J3MgYGJhY2tncm91bmRgIHByb3BlcnR5XG4gKiBAcmV0dXJuIHtQcm9taXNlfVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5Nb2RlbC5zeW5jSW5kZXhlcyA9IGFzeW5jIGZ1bmN0aW9uIHN5bmNJbmRleGVzKG9wdGlvbnMpIHtcbiAgX2NoZWNrQ29udGV4dCh0aGlzLCAnc3luY0luZGV4ZXMnKTtcbiAgaWYgKHR5cGVvZiBhcmd1bWVudHNbMF0gPT09ICdmdW5jdGlvbicgfHwgdHlwZW9mIGFyZ3VtZW50c1sxXSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHRocm93IG5ldyBNb25nb29zZUVycm9yKCdNb2RlbC5zeW5jSW5kZXhlcygpIG5vIGxvbmdlciBhY2NlcHRzIGEgY2FsbGJhY2snKTtcbiAgfVxuXG4gIGNvbnN0IG1vZGVsID0gdGhpcztcblxuICB0cnkge1xuICAgIGF3YWl0IG1vZGVsLmNyZWF0ZUNvbGxlY3Rpb24oKTtcbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgaWYgKGVyciAhPSBudWxsICYmIChlcnIubmFtZSAhPT0gJ01vbmdvU2VydmVyRXJyb3InIHx8IGVyci5jb2RlICE9PSA0OCkpIHtcbiAgICAgIHRocm93IGVycjtcbiAgICB9XG4gIH1cblxuICBjb25zdCBkaWZmSW5kZXhlc1Jlc3VsdCA9IGF3YWl0IG1vZGVsLmRpZmZJbmRleGVzKCk7XG4gIGNvbnN0IGRyb3BwZWQgPSBhd2FpdCBtb2RlbC5jbGVhbkluZGV4ZXMoeyAuLi5vcHRpb25zLCB0b0Ryb3A6IGRpZmZJbmRleGVzUmVzdWx0LnRvRHJvcCB9KTtcbiAgYXdhaXQgbW9kZWwuY3JlYXRlSW5kZXhlcyh7IC4uLm9wdGlvbnMsIHRvQ3JlYXRlOiBkaWZmSW5kZXhlc1Jlc3VsdC50b0NyZWF0ZSB9KTtcblxuICByZXR1cm4gZHJvcHBlZDtcbn07XG5cbi8qKlxuICogRG9lcyBhIGRyeS1ydW4gb2YgYE1vZGVsLnN5bmNJbmRleGVzKClgLCByZXR1cm5pbmcgdGhlIGluZGV4ZXMgdGhhdCBgc3luY0luZGV4ZXMoKWAgd291bGQgZHJvcCBhbmQgY3JlYXRlIGlmIHlvdSB3ZXJlIHRvIHJ1biBgc3luY0luZGV4ZXMoKWAuXG4gKlxuICogIyMjIyBFeGFtcGxlOlxuICpcbiAqICAgICBjb25zdCB7IHRvRHJvcCwgdG9DcmVhdGUgfSA9IGF3YWl0IE1vZGVsLmRpZmZJbmRleGVzKCk7XG4gKiAgICAgdG9Ecm9wOyAvLyBBcnJheSBvZiBzdHJpbmdzIGNvbnRhaW5pbmcgbmFtZXMgb2YgaW5kZXhlcyB0aGF0IGBzeW5jSW5kZXhlcygpYCB3aWxsIGRyb3BcbiAqICAgICB0b0NyZWF0ZTsgLy8gQXJyYXkgb2Ygc3RyaW5ncyBjb250YWluaW5nIG5hbWVzIG9mIGluZGV4ZXMgdGhhdCBgc3luY0luZGV4ZXMoKWAgd2lsbCBjcmVhdGVcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdXG4gKiBAcmV0dXJuIHtQcm9taXNlPE9iamVjdD59IGNvbnRhaW5zIHRoZSBpbmRleGVzIHRoYXQgd291bGQgYmUgZHJvcHBlZCBpbiBNb25nb0RCIGFuZCBpbmRleGVzIHRoYXQgd291bGQgYmUgY3JlYXRlZCBpbiBNb25nb0RCIGFzIGB7IHRvRHJvcDogc3RyaW5nW10sIHRvQ3JlYXRlOiBzdHJpbmdbXSB9YC5cbiAqL1xuXG5Nb2RlbC5kaWZmSW5kZXhlcyA9IGFzeW5jIGZ1bmN0aW9uIGRpZmZJbmRleGVzKCkge1xuICBpZiAodHlwZW9mIGFyZ3VtZW50c1swXSA9PT0gJ2Z1bmN0aW9uJyB8fCB0eXBlb2YgYXJndW1lbnRzWzFdID09PSAnZnVuY3Rpb24nKSB7XG4gICAgdGhyb3cgbmV3IE1vbmdvb3NlRXJyb3IoJ01vZGVsLnN5bmNJbmRleGVzKCkgbm8gbG9uZ2VyIGFjY2VwdHMgYSBjYWxsYmFjaycpO1xuICB9XG5cbiAgY29uc3QgbW9kZWwgPSB0aGlzO1xuXG4gIGxldCBkYkluZGV4ZXMgPSBhd2FpdCBtb2RlbC5saXN0SW5kZXhlcygpLmNhdGNoKGVyciA9PiB7XG4gICAgaWYgKGVyci5jb2RlTmFtZSA9PSAnTmFtZXNwYWNlTm90Rm91bmQnKSB7XG4gICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH1cbiAgICB0aHJvdyBlcnI7XG4gIH0pO1xuICBpZiAoZGJJbmRleGVzID09PSB1bmRlZmluZWQpIHtcbiAgICBkYkluZGV4ZXMgPSBbXTtcbiAgfVxuICBkYkluZGV4ZXMgPSBnZXRSZWxhdGVkREJJbmRleGVzKG1vZGVsLCBkYkluZGV4ZXMpO1xuXG4gIGNvbnN0IHNjaGVtYSA9IG1vZGVsLnNjaGVtYTtcbiAgY29uc3Qgc2NoZW1hSW5kZXhlcyA9IGdldFJlbGF0ZWRTY2hlbWFJbmRleGVzKG1vZGVsLCBzY2hlbWEuaW5kZXhlcygpKTtcblxuICBjb25zdCB0b0Ryb3AgPSBnZXRJbmRleGVzVG9Ecm9wKHNjaGVtYSwgc2NoZW1hSW5kZXhlcywgZGJJbmRleGVzKTtcbiAgY29uc3QgdG9DcmVhdGUgPSBnZXRJbmRleGVzVG9DcmVhdGUoc2NoZW1hLCBzY2hlbWFJbmRleGVzLCBkYkluZGV4ZXMsIHRvRHJvcCk7XG5cbiAgcmV0dXJuIHsgdG9Ecm9wLCB0b0NyZWF0ZSB9O1xufTtcblxuZnVuY3Rpb24gZ2V0SW5kZXhlc1RvQ3JlYXRlKHNjaGVtYSwgc2NoZW1hSW5kZXhlcywgZGJJbmRleGVzLCB0b0Ryb3ApIHtcbiAgY29uc3QgdG9DcmVhdGUgPSBbXTtcblxuICBmb3IgKGNvbnN0IFtzY2hlbWFJbmRleEtleXNPYmplY3QsIHNjaGVtYUluZGV4T3B0aW9uc10gb2Ygc2NoZW1hSW5kZXhlcykge1xuICAgIGxldCBmb3VuZCA9IGZhbHNlO1xuXG4gICAgY29uc3Qgb3B0aW9ucyA9IGRlY29yYXRlRGlzY3JpbWluYXRvckluZGV4T3B0aW9ucyhzY2hlbWEsIGNsb25lKHNjaGVtYUluZGV4T3B0aW9ucykpO1xuXG4gICAgZm9yIChjb25zdCBpbmRleCBvZiBkYkluZGV4ZXMpIHtcbiAgICAgIGlmIChpc0RlZmF1bHRJZEluZGV4KGluZGV4KSkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIGlmIChcbiAgICAgICAgaXNJbmRleEVxdWFsKHNjaGVtYUluZGV4S2V5c09iamVjdCwgb3B0aW9ucywgaW5kZXgpICYmXG4gICAgICAgICF0b0Ryb3AuaW5jbHVkZXMoaW5kZXgubmFtZSlcbiAgICAgICkge1xuICAgICAgICBmb3VuZCA9IHRydWU7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmICghZm91bmQpIHtcbiAgICAgIHRvQ3JlYXRlLnB1c2goc2NoZW1hSW5kZXhLZXlzT2JqZWN0KTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gdG9DcmVhdGU7XG59XG5cbmZ1bmN0aW9uIGdldEluZGV4ZXNUb0Ryb3Aoc2NoZW1hLCBzY2hlbWFJbmRleGVzLCBkYkluZGV4ZXMpIHtcbiAgY29uc3QgdG9Ecm9wID0gW107XG5cbiAgZm9yIChjb25zdCBkYkluZGV4IG9mIGRiSW5kZXhlcykge1xuICAgIGxldCBmb3VuZCA9IGZhbHNlO1xuICAgIC8vIE5ldmVyIHRyeSB0byBkcm9wIGBfaWRgIGluZGV4LCBNb25nb0RCIHNlcnZlciBkb2Vzbid0IGFsbG93IGl0XG4gICAgaWYgKGlzRGVmYXVsdElkSW5kZXgoZGJJbmRleCkpIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIGZvciAoY29uc3QgW3NjaGVtYUluZGV4S2V5c09iamVjdCwgc2NoZW1hSW5kZXhPcHRpb25zXSBvZiBzY2hlbWFJbmRleGVzKSB7XG4gICAgICBjb25zdCBvcHRpb25zID0gZGVjb3JhdGVEaXNjcmltaW5hdG9ySW5kZXhPcHRpb25zKHNjaGVtYSwgY2xvbmUoc2NoZW1hSW5kZXhPcHRpb25zKSk7XG4gICAgICBhcHBseVNjaGVtYUNvbGxhdGlvbihzY2hlbWFJbmRleEtleXNPYmplY3QsIG9wdGlvbnMsIHNjaGVtYS5vcHRpb25zKTtcblxuICAgICAgaWYgKGlzSW5kZXhFcXVhbChzY2hlbWFJbmRleEtleXNPYmplY3QsIG9wdGlvbnMsIGRiSW5kZXgpKSB7XG4gICAgICAgIGZvdW5kID0gdHJ1ZTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKCFmb3VuZCkge1xuICAgICAgdG9Ecm9wLnB1c2goZGJJbmRleC5uYW1lKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gdG9Ecm9wO1xufVxuLyoqXG4gKiBEZWxldGVzIGFsbCBpbmRleGVzIHRoYXQgYXJlbid0IGRlZmluZWQgaW4gdGhpcyBtb2RlbCdzIHNjaGVtYS4gVXNlZCBieVxuICogYHN5bmNJbmRleGVzKClgLlxuICpcbiAqIFRoZSByZXR1cm5lZCBwcm9taXNlIHJlc29sdmVzIHRvIGEgbGlzdCBvZiB0aGUgZHJvcHBlZCBpbmRleGVzJyBuYW1lcyBhcyBhbiBhcnJheVxuICpcbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtjYWxsYmFja10gb3B0aW9uYWwgY2FsbGJhY2tcbiAqIEByZXR1cm4ge1Byb21pc2V8dW5kZWZpbmVkfSBSZXR1cm5zIGB1bmRlZmluZWRgIGlmIGNhbGxiYWNrIGlzIHNwZWNpZmllZCwgcmV0dXJucyBhIHByb21pc2UgaWYgbm8gY2FsbGJhY2suXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbk1vZGVsLmNsZWFuSW5kZXhlcyA9IGFzeW5jIGZ1bmN0aW9uIGNsZWFuSW5kZXhlcyhvcHRpb25zKSB7XG4gIF9jaGVja0NvbnRleHQodGhpcywgJ2NsZWFuSW5kZXhlcycpO1xuICBpZiAodHlwZW9mIGFyZ3VtZW50c1swXSA9PT0gJ2Z1bmN0aW9uJyB8fCB0eXBlb2YgYXJndW1lbnRzWzFdID09PSAnZnVuY3Rpb24nKSB7XG4gICAgdGhyb3cgbmV3IE1vbmdvb3NlRXJyb3IoJ01vZGVsLmNsZWFuSW5kZXhlcygpIG5vIGxvbmdlciBhY2NlcHRzIGEgY2FsbGJhY2snKTtcbiAgfVxuICBjb25zdCBtb2RlbCA9IHRoaXM7XG5cbiAgY29uc3QgY29sbGVjdGlvbiA9IG1vZGVsLiRfX2NvbGxlY3Rpb247XG5cbiAgaWYgKEFycmF5LmlzQXJyYXkob3B0aW9ucyAmJiBvcHRpb25zLnRvRHJvcCkpIHtcbiAgICBjb25zdCByZXMgPSBhd2FpdCBfZHJvcEluZGV4ZXMob3B0aW9ucy50b0Ryb3AsIGNvbGxlY3Rpb24pO1xuICAgIHJldHVybiByZXM7XG4gIH1cblxuICBjb25zdCByZXMgPSBhd2FpdCBtb2RlbC5kaWZmSW5kZXhlcygpO1xuICByZXR1cm4gYXdhaXQgX2Ryb3BJbmRleGVzKHJlcy50b0Ryb3AsIGNvbGxlY3Rpb24pO1xufTtcblxuYXN5bmMgZnVuY3Rpb24gX2Ryb3BJbmRleGVzKHRvRHJvcCwgY29sbGVjdGlvbikge1xuICBpZiAodG9Ecm9wLmxlbmd0aCA9PT0gMCkge1xuICAgIHJldHVybiBbXTtcbiAgfVxuXG4gIGF3YWl0IFByb21pc2UuYWxsKHRvRHJvcC5tYXAoaW5kZXhOYW1lID0+IGNvbGxlY3Rpb24uZHJvcEluZGV4KGluZGV4TmFtZSkpKTtcbiAgcmV0dXJuIHRvRHJvcDtcbn1cblxuLyoqXG4gKiBMaXN0cyB0aGUgaW5kZXhlcyBjdXJyZW50bHkgZGVmaW5lZCBpbiBNb25nb0RCLiBUaGlzIG1heSBvciBtYXkgbm90IGJlXG4gKiB0aGUgc2FtZSBhcyB0aGUgaW5kZXhlcyBkZWZpbmVkIGluIHlvdXIgc2NoZW1hIGRlcGVuZGluZyBvbiB3aGV0aGVyIHlvdVxuICogdXNlIHRoZSBbYGF1dG9JbmRleGAgb3B0aW9uXShodHRwczovL21vbmdvb3NlanMuY29tL2RvY3MvZ3VpZGUuaHRtbCNhdXRvSW5kZXgpIGFuZCBpZiB5b3VcbiAqIGJ1aWxkIGluZGV4ZXMgbWFudWFsbHkuXG4gKlxuICogQHJldHVybiB7UHJvbWlzZX1cbiAqIEBhcGkgcHVibGljXG4gKi9cblxuTW9kZWwubGlzdEluZGV4ZXMgPSBhc3luYyBmdW5jdGlvbiBsaXN0SW5kZXhlcygpIHtcbiAgX2NoZWNrQ29udGV4dCh0aGlzLCAnbGlzdEluZGV4ZXMnKTtcbiAgaWYgKHR5cGVvZiBhcmd1bWVudHNbMF0gPT09ICdmdW5jdGlvbicpIHtcbiAgICB0aHJvdyBuZXcgTW9uZ29vc2VFcnJvcignTW9kZWwubGlzdEluZGV4ZXMoKSBubyBsb25nZXIgYWNjZXB0cyBhIGNhbGxiYWNrJyk7XG4gIH1cblxuICBpZiAodGhpcy4kX19jb2xsZWN0aW9uLmJ1ZmZlcikge1xuICAgIGF3YWl0IG5ldyBQcm9taXNlKHJlc29sdmUgPT4ge1xuICAgICAgdGhpcy4kX19jb2xsZWN0aW9uLmFkZFF1ZXVlKHJlc29sdmUpO1xuICAgIH0pO1xuICB9XG5cbiAgcmV0dXJuIHRoaXMuJF9fY29sbGVjdGlvbi5saXN0SW5kZXhlcygpLnRvQXJyYXkoKTtcbn07XG5cbi8qKlxuICogU2VuZHMgYGNyZWF0ZUluZGV4YCBjb21tYW5kcyB0byBtb25nbyBmb3IgZWFjaCBpbmRleCBkZWNsYXJlZCBpbiB0aGUgc2NoZW1hLlxuICogVGhlIGBjcmVhdGVJbmRleGAgY29tbWFuZHMgYXJlIHNlbnQgaW4gc2VyaWVzLlxuICpcbiAqICMjIyMgRXhhbXBsZTpcbiAqXG4gKiAgICAgRXZlbnQuZW5zdXJlSW5kZXhlcyhmdW5jdGlvbiAoZXJyKSB7XG4gKiAgICAgICBpZiAoZXJyKSByZXR1cm4gaGFuZGxlRXJyb3IoZXJyKTtcbiAqICAgICB9KTtcbiAqXG4gKiBBZnRlciBjb21wbGV0aW9uLCBhbiBgaW5kZXhgIGV2ZW50IGlzIGVtaXR0ZWQgb24gdGhpcyBgTW9kZWxgIHBhc3NpbmcgYW4gZXJyb3IgaWYgb25lIG9jY3VycmVkLlxuICpcbiAqICMjIyMgRXhhbXBsZTpcbiAqXG4gKiAgICAgY29uc3QgZXZlbnRTY2hlbWEgPSBuZXcgU2NoZW1hKHsgdGhpbmc6IHsgdHlwZTogJ3N0cmluZycsIHVuaXF1ZTogdHJ1ZSB9IH0pXG4gKiAgICAgY29uc3QgRXZlbnQgPSBtb25nb29zZS5tb2RlbCgnRXZlbnQnLCBldmVudFNjaGVtYSk7XG4gKlxuICogICAgIEV2ZW50Lm9uKCdpbmRleCcsIGZ1bmN0aW9uIChlcnIpIHtcbiAqICAgICAgIGlmIChlcnIpIGNvbnNvbGUuZXJyb3IoZXJyKTsgLy8gZXJyb3Igb2NjdXJyZWQgZHVyaW5nIGluZGV4IGNyZWF0aW9uXG4gKiAgICAgfSlcbiAqXG4gKiBfTk9URTogSXQgaXMgbm90IHJlY29tbWVuZGVkIHRoYXQgeW91IHJ1biB0aGlzIGluIHByb2R1Y3Rpb24uIEluZGV4IGNyZWF0aW9uIG1heSBpbXBhY3QgZGF0YWJhc2UgcGVyZm9ybWFuY2UgZGVwZW5kaW5nIG9uIHlvdXIgbG9hZC4gVXNlIHdpdGggY2F1dGlvbi5fXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSBpbnRlcm5hbCBvcHRpb25zXG4gKiBAcmV0dXJuIHtQcm9taXNlfVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5Nb2RlbC5lbnN1cmVJbmRleGVzID0gYXN5bmMgZnVuY3Rpb24gZW5zdXJlSW5kZXhlcyhvcHRpb25zKSB7XG4gIF9jaGVja0NvbnRleHQodGhpcywgJ2Vuc3VyZUluZGV4ZXMnKTtcbiAgaWYgKHR5cGVvZiBhcmd1bWVudHNbMF0gPT09ICdmdW5jdGlvbicgfHwgdHlwZW9mIGFyZ3VtZW50c1sxXSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHRocm93IG5ldyBNb25nb29zZUVycm9yKCdNb2RlbC5lbnN1cmVJbmRleGVzKCkgbm8gbG9uZ2VyIGFjY2VwdHMgYSBjYWxsYmFjaycpO1xuICB9XG5cbiAgYXdhaXQgbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgIF9lbnN1cmVJbmRleGVzKHRoaXMsIG9wdGlvbnMsIChlcnIpID0+IHtcbiAgICAgIGlmIChlcnIgIT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gcmVqZWN0KGVycik7XG4gICAgICB9XG4gICAgICByZXNvbHZlKCk7XG4gICAgfSk7XG4gIH0pO1xufTtcblxuLyoqXG4gKiBTaW1pbGFyIHRvIGBlbnN1cmVJbmRleGVzKClgLCBleGNlcHQgZm9yIGl0IHVzZXMgdGhlIFtgY3JlYXRlSW5kZXhgXShodHRwczovL21vbmdvZGIuZ2l0aHViLmlvL25vZGUtbW9uZ29kYi1uYXRpdmUvNC45L2NsYXNzZXMvRGIuaHRtbCNjcmVhdGVJbmRleClcbiAqIGZ1bmN0aW9uLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gaW50ZXJuYWwgb3B0aW9uc1xuICogQHJldHVybiB7UHJvbWlzZX1cbiAqIEBhcGkgcHVibGljXG4gKi9cblxuTW9kZWwuY3JlYXRlSW5kZXhlcyA9IGFzeW5jIGZ1bmN0aW9uIGNyZWF0ZUluZGV4ZXMob3B0aW9ucykge1xuICBfY2hlY2tDb250ZXh0KHRoaXMsICdjcmVhdGVJbmRleGVzJyk7XG5cbiAgaWYgKHR5cGVvZiBhcmd1bWVudHNbMF0gPT09ICdmdW5jdGlvbicgfHwgdHlwZW9mIGFyZ3VtZW50c1sxXSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHRocm93IG5ldyBNb25nb29zZUVycm9yKCdNb2RlbC5jcmVhdGVJbmRleGVzKCkgbm8gbG9uZ2VyIGFjY2VwdHMgYSBjYWxsYmFjaycpO1xuICB9XG5cbiAgcmV0dXJuIHRoaXMuZW5zdXJlSW5kZXhlcyhvcHRpb25zKTtcbn07XG5cblxuLyohXG4gKiBpZ25vcmVcbiAqL1xuXG5mdW5jdGlvbiBfZW5zdXJlSW5kZXhlcyhtb2RlbCwgb3B0aW9ucywgY2FsbGJhY2spIHtcbiAgY29uc3QgaW5kZXhlcyA9IG1vZGVsLnNjaGVtYS5pbmRleGVzKCk7XG4gIGxldCBpbmRleEVycm9yO1xuXG4gIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICBjb25zdCBkb25lID0gZnVuY3Rpb24oZXJyKSB7XG4gICAgaWYgKGVyciAmJiAhbW9kZWwuJGNhdWdodCkge1xuICAgICAgbW9kZWwuZW1pdCgnZXJyb3InLCBlcnIpO1xuICAgIH1cbiAgICBtb2RlbC5lbWl0KCdpbmRleCcsIGVyciB8fCBpbmRleEVycm9yKTtcbiAgICBjYWxsYmFjayAmJiBjYWxsYmFjayhlcnIgfHwgaW5kZXhFcnJvcik7XG4gIH07XG5cbiAgZm9yIChjb25zdCBpbmRleCBvZiBpbmRleGVzKSB7XG4gICAgaWYgKGlzRGVmYXVsdElkSW5kZXgoaW5kZXgpKSB7XG4gICAgICB1dGlscy53YXJuKCdtb25nb29zZTogQ2Fubm90IHNwZWNpZnkgYSBjdXN0b20gaW5kZXggb24gYF9pZGAgZm9yICcgK1xuICAgICAgICAnbW9kZWwgbmFtZSBcIicgKyBtb2RlbC5tb2RlbE5hbWUgKyAnXCIsICcgK1xuICAgICAgICAnTW9uZ29EQiBkb2VzIG5vdCBhbGxvdyBvdmVyd3JpdGluZyB0aGUgZGVmYXVsdCBgX2lkYCBpbmRleC4gU2VlICcgK1xuICAgICAgICAnaHR0cHM6Ly9iaXQubHkvbW9uZ29kYi1pZC1pbmRleCcpO1xuICAgIH1cbiAgfVxuXG4gIGlmICghaW5kZXhlcy5sZW5ndGgpIHtcbiAgICBpbW1lZGlhdGUoZnVuY3Rpb24oKSB7XG4gICAgICBkb25lKCk7XG4gICAgfSk7XG4gICAgcmV0dXJuO1xuICB9XG4gIC8vIEluZGV4ZXMgYXJlIGNyZWF0ZWQgb25lLWJ5LW9uZSB0byBzdXBwb3J0IGhvdyBNb25nb0RCIDwgMi40IGRlYWxzXG4gIC8vIHdpdGggYmFja2dyb3VuZCBpbmRleGVzLlxuXG4gIGNvbnN0IGluZGV4U2luZ2xlRG9uZSA9IGZ1bmN0aW9uKGVyciwgZmllbGRzLCBvcHRpb25zLCBuYW1lKSB7XG4gICAgbW9kZWwuZW1pdCgnaW5kZXgtc2luZ2xlLWRvbmUnLCBlcnIsIGZpZWxkcywgb3B0aW9ucywgbmFtZSk7XG4gIH07XG4gIGNvbnN0IGluZGV4U2luZ2xlU3RhcnQgPSBmdW5jdGlvbihmaWVsZHMsIG9wdGlvbnMpIHtcbiAgICBtb2RlbC5lbWl0KCdpbmRleC1zaW5nbGUtc3RhcnQnLCBmaWVsZHMsIG9wdGlvbnMpO1xuICB9O1xuXG4gIGNvbnN0IGJhc2VTY2hlbWEgPSBtb2RlbC5zY2hlbWEuX2Jhc2VTY2hlbWE7XG4gIGNvbnN0IGJhc2VTY2hlbWFJbmRleGVzID0gYmFzZVNjaGVtYSA/IGJhc2VTY2hlbWEuaW5kZXhlcygpIDogW107XG5cbiAgaW1tZWRpYXRlKGZ1bmN0aW9uKCkge1xuICAgIC8vIElmIGJ1ZmZlcmluZyBpcyBvZmYsIGRvIHRoaXMgbWFudWFsbHkuXG4gICAgaWYgKG9wdGlvbnMuX2F1dG9tYXRpYyAmJiAhbW9kZWwuY29sbGVjdGlvbi5jb2xsZWN0aW9uKSB7XG4gICAgICBtb2RlbC5jb2xsZWN0aW9uLmFkZFF1ZXVlKGNyZWF0ZSwgW10pO1xuICAgIH0gZWxzZSB7XG4gICAgICBjcmVhdGUoKTtcbiAgICB9XG4gIH0pO1xuXG5cbiAgZnVuY3Rpb24gY3JlYXRlKCkge1xuICAgIGlmIChvcHRpb25zLl9hdXRvbWF0aWMpIHtcbiAgICAgIGlmIChtb2RlbC5zY2hlbWEub3B0aW9ucy5hdXRvSW5kZXggPT09IGZhbHNlIHx8XG4gICAgICAgICAgKG1vZGVsLnNjaGVtYS5vcHRpb25zLmF1dG9JbmRleCA9PSBudWxsICYmIG1vZGVsLmRiLmNvbmZpZy5hdXRvSW5kZXggPT09IGZhbHNlKSkge1xuICAgICAgICByZXR1cm4gZG9uZSgpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGNvbnN0IGluZGV4ID0gaW5kZXhlcy5zaGlmdCgpO1xuICAgIGlmICghaW5kZXgpIHtcbiAgICAgIHJldHVybiBkb25lKCk7XG4gICAgfVxuICAgIGlmIChvcHRpb25zLl9hdXRvbWF0aWMgJiYgaW5kZXhbMV0uX2F1dG9JbmRleCA9PT0gZmFsc2UpIHtcbiAgICAgIHJldHVybiBjcmVhdGUoKTtcbiAgICB9XG5cbiAgICBpZiAoYmFzZVNjaGVtYUluZGV4ZXMuZmluZChpID0+IHV0aWxzLmRlZXBFcXVhbChpLCBpbmRleCkpKSB7XG4gICAgICByZXR1cm4gY3JlYXRlKCk7XG4gICAgfVxuXG4gICAgY29uc3QgaW5kZXhGaWVsZHMgPSBjbG9uZShpbmRleFswXSk7XG4gICAgY29uc3QgaW5kZXhPcHRpb25zID0gY2xvbmUoaW5kZXhbMV0pO1xuXG4gICAgZGVsZXRlIGluZGV4T3B0aW9ucy5fYXV0b0luZGV4O1xuICAgIGRlY29yYXRlRGlzY3JpbWluYXRvckluZGV4T3B0aW9ucyhtb2RlbC5zY2hlbWEsIGluZGV4T3B0aW9ucyk7XG4gICAgYXBwbHlXcml0ZUNvbmNlcm4obW9kZWwuc2NoZW1hLCBpbmRleE9wdGlvbnMpO1xuICAgIGFwcGx5U2NoZW1hQ29sbGF0aW9uKGluZGV4RmllbGRzLCBpbmRleE9wdGlvbnMsIG1vZGVsLnNjaGVtYS5vcHRpb25zKTtcblxuICAgIGluZGV4U2luZ2xlU3RhcnQoaW5kZXhGaWVsZHMsIG9wdGlvbnMpO1xuXG4gICAgaWYgKCdiYWNrZ3JvdW5kJyBpbiBvcHRpb25zKSB7XG4gICAgICBpbmRleE9wdGlvbnMuYmFja2dyb3VuZCA9IG9wdGlvbnMuYmFja2dyb3VuZDtcbiAgICB9XG5cbiAgICBpZiAoJ3RvQ3JlYXRlJyBpbiBvcHRpb25zKSB7XG4gICAgICBpZiAob3B0aW9ucy50b0NyZWF0ZS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgcmV0dXJuIGRvbmUoKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBtb2RlbC5jb2xsZWN0aW9uLmNyZWF0ZUluZGV4KGluZGV4RmllbGRzLCBpbmRleE9wdGlvbnMpLnRoZW4oXG4gICAgICBuYW1lID0+IHtcbiAgICAgICAgaW5kZXhTaW5nbGVEb25lKG51bGwsIGluZGV4RmllbGRzLCBpbmRleE9wdGlvbnMsIG5hbWUpO1xuICAgICAgICBjcmVhdGUoKTtcbiAgICAgIH0sXG4gICAgICBlcnIgPT4ge1xuICAgICAgICBpZiAoIWluZGV4RXJyb3IpIHtcbiAgICAgICAgICBpbmRleEVycm9yID0gZXJyO1xuICAgICAgICB9XG4gICAgICAgIGlmICghbW9kZWwuJGNhdWdodCkge1xuICAgICAgICAgIG1vZGVsLmVtaXQoJ2Vycm9yJywgZXJyKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGluZGV4U2luZ2xlRG9uZShlcnIsIGluZGV4RmllbGRzLCBpbmRleE9wdGlvbnMpO1xuICAgICAgICBjcmVhdGUoKTtcbiAgICAgIH1cbiAgICApO1xuICB9XG59XG5cbi8qKlxuICogU2NoZW1hIHRoZSBtb2RlbCB1c2VzLlxuICpcbiAqIEBwcm9wZXJ0eSBzY2hlbWFcbiAqIEBzdGF0aWNcbiAqIEBhcGkgcHVibGljXG4gKiBAbWVtYmVyT2YgTW9kZWxcbiAqL1xuXG5Nb2RlbC5zY2hlbWE7XG5cbi8qKlxuICogQ29ubmVjdGlvbiBpbnN0YW5jZSB0aGUgbW9kZWwgdXNlcy5cbiAqXG4gKiBAcHJvcGVydHkgZGJcbiAqIEBzdGF0aWNcbiAqIEBhcGkgcHVibGljXG4gKiBAbWVtYmVyT2YgTW9kZWxcbiAqL1xuXG5Nb2RlbC5kYjtcblxuLyoqXG4gKiBDb2xsZWN0aW9uIHRoZSBtb2RlbCB1c2VzLlxuICpcbiAqIEBwcm9wZXJ0eSBjb2xsZWN0aW9uXG4gKiBAYXBpIHB1YmxpY1xuICogQG1lbWJlck9mIE1vZGVsXG4gKi9cblxuTW9kZWwuY29sbGVjdGlvbjtcblxuLyoqXG4gKiBJbnRlcm5hbCBjb2xsZWN0aW9uIHRoZSBtb2RlbCB1c2VzLlxuICpcbiAqIEBwcm9wZXJ0eSBjb2xsZWN0aW9uXG4gKiBAYXBpIHByaXZhdGVcbiAqIEBtZW1iZXJPZiBNb2RlbFxuICovXG5Nb2RlbC4kX19jb2xsZWN0aW9uO1xuXG4vKipcbiAqIEJhc2UgTW9uZ29vc2UgaW5zdGFuY2UgdGhlIG1vZGVsIHVzZXMuXG4gKlxuICogQHByb3BlcnR5IGJhc2VcbiAqIEBhcGkgcHVibGljXG4gKiBAbWVtYmVyT2YgTW9kZWxcbiAqL1xuXG5Nb2RlbC5iYXNlO1xuXG4vKipcbiAqIFJlZ2lzdGVyZWQgZGlzY3JpbWluYXRvcnMgZm9yIHRoaXMgbW9kZWwuXG4gKlxuICogQHByb3BlcnR5IGRpc2NyaW1pbmF0b3JzXG4gKiBAYXBpIHB1YmxpY1xuICogQG1lbWJlck9mIE1vZGVsXG4gKi9cblxuTW9kZWwuZGlzY3JpbWluYXRvcnM7XG5cbi8qKlxuICogVHJhbnNsYXRlIGFueSBhbGlhc2VzIGZpZWxkcy9jb25kaXRpb25zIHNvIHRoZSBmaW5hbCBxdWVyeSBvciBkb2N1bWVudCBvYmplY3QgaXMgcHVyZVxuICpcbiAqICMjIyMgRXhhbXBsZTpcbiAqXG4gKiAgICAgYXdhaXQgQ2hhcmFjdGVyLmZpbmQoQ2hhcmFjdGVyLnRyYW5zbGF0ZUFsaWFzZXMoe1xuICogICAgICAgICflkI0nOiAnRWRkYXJkIFN0YXJrJyAvLyBBbGlhcyBmb3IgJ25hbWUnXG4gKiAgICAgfSk7XG4gKlxuICogQnkgZGVmYXVsdCwgYHRyYW5zbGF0ZUFsaWFzZXMoKWAgb3ZlcndyaXRlcyByYXcgZmllbGRzIHdpdGggYWxpYXNlZCBmaWVsZHMuXG4gKiBTbyBpZiBgbmAgaXMgYW4gYWxpYXMgZm9yIGBuYW1lYCwgYHsgbjogJ2FsaWFzJywgbmFtZTogJ3JhdycgfWAgd2lsbCByZXNvbHZlIHRvIGB7IG5hbWU6ICdhbGlhcycgfWAuXG4gKiBIb3dldmVyLCB5b3UgY2FuIHNldCB0aGUgYGVycm9yT25EdXBsaWNhdGVzYCBvcHRpb24gdG8gdGhyb3cgYW4gZXJyb3IgaWYgdGhlcmUgYXJlIHBvdGVudGlhbGx5IGNvbmZsaWN0aW5nIHBhdGhzLlxuICogVGhlIGB0cmFuc2xhdGVBbGlhc2VzYCBvcHRpb24gZm9yIHF1ZXJpZXMgdXNlcyBgZXJyb3JPbkR1cGxpY2F0ZXNgLlxuICpcbiAqICMjIyMgTm90ZTpcbiAqXG4gKiBPbmx5IHRyYW5zbGF0ZSBhcmd1bWVudHMgb2Ygb2JqZWN0IHR5cGUgYW55dGhpbmcgZWxzZSBpcyByZXR1cm5lZCByYXdcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gZmllbGRzIGZpZWxkcy9jb25kaXRpb25zIHRoYXQgbWF5IGNvbnRhaW4gYWxpYXNlZCBrZXlzXG4gKiBAcGFyYW0ge0Jvb2xlYW59IFtlcnJvck9uRHVwbGljYXRlc10gaWYgdHJ1ZSwgdGhyb3cgYW4gZXJyb3IgaWYgdGhlcmUncyBib3RoIGEga2V5IGFuZCBhbiBhbGlhcyBmb3IgdGhhdCBrZXkgaW4gYGZpZWxkc2BcbiAqIEByZXR1cm4ge09iamVjdH0gdGhlIHRyYW5zbGF0ZWQgJ3B1cmUnIGZpZWxkcy9jb25kaXRpb25zXG4gKi9cbk1vZGVsLnRyYW5zbGF0ZUFsaWFzZXMgPSBmdW5jdGlvbiB0cmFuc2xhdGVBbGlhc2VzKGZpZWxkcywgZXJyb3JPbkR1cGxpY2F0ZXMpIHtcbiAgX2NoZWNrQ29udGV4dCh0aGlzLCAndHJhbnNsYXRlQWxpYXNlcycpO1xuXG4gIGNvbnN0IHRyYW5zbGF0ZSA9IChrZXksIHZhbHVlKSA9PiB7XG4gICAgbGV0IGFsaWFzO1xuICAgIGNvbnN0IHRyYW5zbGF0ZWQgPSBbXTtcbiAgICBjb25zdCBmaWVsZEtleXMgPSBrZXkuc3BsaXQoJy4nKTtcbiAgICBsZXQgY3VycmVudFNjaGVtYSA9IHRoaXMuc2NoZW1hO1xuICAgIGZvciAoY29uc3QgaSBpbiBmaWVsZEtleXMpIHtcbiAgICAgIGNvbnN0IG5hbWUgPSBmaWVsZEtleXNbaV07XG4gICAgICBpZiAoY3VycmVudFNjaGVtYSAmJiBjdXJyZW50U2NoZW1hLmFsaWFzZXNbbmFtZV0pIHtcbiAgICAgICAgYWxpYXMgPSBjdXJyZW50U2NoZW1hLmFsaWFzZXNbbmFtZV07XG4gICAgICAgIGlmIChlcnJvck9uRHVwbGljYXRlcyAmJiBhbGlhcyBpbiBmaWVsZHMpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgTW9uZ29vc2VFcnJvcihgUHJvdmlkZWQgb2JqZWN0IGhhcyBib3RoIGZpZWxkIFwiJHtuYW1lfVwiIGFuZCBpdHMgYWxpYXMgXCIke2FsaWFzfVwiYCk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gQWxpYXMgZm91bmQsXG4gICAgICAgIHRyYW5zbGF0ZWQucHVzaChhbGlhcyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBhbGlhcyA9IG5hbWU7XG4gICAgICAgIC8vIEFsaWFzIG5vdCBmb3VuZCwgc28gdHJlYXQgYXMgdW4tYWxpYXNlZCBrZXlcbiAgICAgICAgdHJhbnNsYXRlZC5wdXNoKG5hbWUpO1xuICAgICAgfVxuXG4gICAgICAvLyBDaGVjayBpZiBhbGlhc2VkIHBhdGggaXMgYSBzY2hlbWFcbiAgICAgIGlmIChjdXJyZW50U2NoZW1hICYmIGN1cnJlbnRTY2hlbWEucGF0aHNbYWxpYXNdKSB7XG4gICAgICAgIGN1cnJlbnRTY2hlbWEgPSBjdXJyZW50U2NoZW1hLnBhdGhzW2FsaWFzXS5zY2hlbWE7XG4gICAgICB9XG4gICAgICBlbHNlXG4gICAgICAgIGN1cnJlbnRTY2hlbWEgPSBudWxsO1xuICAgIH1cblxuICAgIGNvbnN0IHRyYW5zbGF0ZWRLZXkgPSB0cmFuc2xhdGVkLmpvaW4oJy4nKTtcbiAgICBpZiAoZmllbGRzIGluc3RhbmNlb2YgTWFwKVxuICAgICAgZmllbGRzLnNldCh0cmFuc2xhdGVkS2V5LCB2YWx1ZSk7XG4gICAgZWxzZVxuICAgICAgZmllbGRzW3RyYW5zbGF0ZWRLZXldID0gdmFsdWU7XG5cbiAgICBpZiAodHJhbnNsYXRlZEtleSAhPT0ga2V5KSB7XG4gICAgICAvLyBXZSdsbCBiZSB1c2luZyB0aGUgdHJhbnNsYXRlZCBrZXkgaW5zdGVhZFxuICAgICAgaWYgKGZpZWxkcyBpbnN0YW5jZW9mIE1hcCkge1xuICAgICAgICAvLyBEZWxldGUgZnJvbSBtYXBcbiAgICAgICAgZmllbGRzLmRlbGV0ZShrZXkpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gRGVsZXRlIGZyb20gb2JqZWN0XG4gICAgICAgIGRlbGV0ZSBmaWVsZHNba2V5XTsgLy8gV2UnbGwgYmUgdXNpbmcgdGhlIHRyYW5zbGF0ZWQga2V5IGluc3RlYWRcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGZpZWxkcztcbiAgfTtcblxuICBpZiAodHlwZW9mIGZpZWxkcyA9PT0gJ29iamVjdCcpIHtcbiAgICAvLyBGaWVsZHMgaXMgYW4gb2JqZWN0IChxdWVyeSBjb25kaXRpb25zIG9yIGRvY3VtZW50IGZpZWxkcylcbiAgICBpZiAoZmllbGRzIGluc3RhbmNlb2YgTWFwKSB7XG4gICAgICAvLyBBIE1hcCB3YXMgc3VwcGxpZWRcbiAgICAgIGZvciAoY29uc3QgZmllbGQgb2YgbmV3IE1hcChmaWVsZHMpKSB7XG4gICAgICAgIGZpZWxkcyA9IHRyYW5zbGF0ZShmaWVsZFswXSwgZmllbGRbMV0pO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAvLyBJbmZlciBhIHJlZ3VsYXIgb2JqZWN0IHdhcyBzdXBwbGllZFxuICAgICAgZm9yIChjb25zdCBrZXkgb2YgT2JqZWN0LmtleXMoZmllbGRzKSkge1xuICAgICAgICBmaWVsZHMgPSB0cmFuc2xhdGUoa2V5LCBmaWVsZHNba2V5XSk7XG4gICAgICAgIGlmIChrZXlbMF0gPT09ICckJykge1xuICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KGZpZWxkc1trZXldKSkge1xuICAgICAgICAgICAgZm9yIChjb25zdCBpIGluIGZpZWxkc1trZXldKSB7XG4gICAgICAgICAgICAgIC8vIFJlY3Vyc2l2ZWx5IHRyYW5zbGF0ZSBuZXN0ZWQgcXVlcmllc1xuICAgICAgICAgICAgICBmaWVsZHNba2V5XVtpXSA9IHRoaXMudHJhbnNsYXRlQWxpYXNlcyhmaWVsZHNba2V5XVtpXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMudHJhbnNsYXRlQWxpYXNlcyhmaWVsZHNba2V5XSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGZpZWxkcztcbiAgfSBlbHNlIHtcbiAgICAvLyBEb24ndCBrbm93IHR5cGVvZiBmaWVsZHNcbiAgICByZXR1cm4gZmllbGRzO1xuICB9XG59O1xuXG4vKipcbiAqIERlbGV0ZXMgdGhlIGZpcnN0IGRvY3VtZW50IHRoYXQgbWF0Y2hlcyBgY29uZGl0aW9uc2AgZnJvbSB0aGUgY29sbGVjdGlvbi5cbiAqIEl0IHJldHVybnMgYW4gb2JqZWN0IHdpdGggdGhlIHByb3BlcnR5IGBkZWxldGVkQ291bnRgIGluZGljYXRpbmcgaG93IG1hbnkgZG9jdW1lbnRzIHdlcmUgZGVsZXRlZC5cbiAqIEJlaGF2ZXMgbGlrZSBgcmVtb3ZlKClgLCBidXQgZGVsZXRlcyBhdCBtb3N0IG9uZSBkb2N1bWVudCByZWdhcmRsZXNzIG9mIHRoZVxuICogYHNpbmdsZWAgb3B0aW9uLlxuICpcbiAqICMjIyMgRXhhbXBsZTpcbiAqXG4gKiAgICAgYXdhaXQgQ2hhcmFjdGVyLmRlbGV0ZU9uZSh7IG5hbWU6ICdFZGRhcmQgU3RhcmsnIH0pOyAvLyByZXR1cm5zIHtkZWxldGVkQ291bnQ6IDF9XG4gKlxuICogIyMjIyBOb3RlOlxuICpcbiAqIFRoaXMgZnVuY3Rpb24gdHJpZ2dlcnMgYGRlbGV0ZU9uZWAgcXVlcnkgaG9va3MuIFJlYWQgdGhlXG4gKiBbbWlkZGxld2FyZSBkb2NzXShodHRwczovL21vbmdvb3NlanMuY29tL2RvY3MvbWlkZGxld2FyZS5odG1sI25hbWluZykgdG8gbGVhcm4gbW9yZS5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gY29uZGl0aW9uc1xuICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSBvcHRpb25hbCBzZWUgW2BRdWVyeS5wcm90b3R5cGUuc2V0T3B0aW9ucygpYF0oaHR0cHM6Ly9tb25nb29zZWpzLmNvbS9kb2NzL2FwaS9xdWVyeS5odG1sI1F1ZXJ5LnByb3RvdHlwZS5zZXRPcHRpb25zKCkpXG4gKiBAcGFyYW0ge0Jvb2xlYW59IFtvcHRpb25zLnRyYW5zbGF0ZUFsaWFzZXM9bnVsbF0gSWYgc2V0IHRvIGB0cnVlYCwgdHJhbnNsYXRlcyBhbnkgc2NoZW1hLWRlZmluZWQgYWxpYXNlcyBpbiBgZmlsdGVyYCwgYHByb2plY3Rpb25gLCBgdXBkYXRlYCwgYW5kIGBkaXN0aW5jdGAuIFRocm93cyBhbiBlcnJvciBpZiB0aGVyZSBhcmUgYW55IGNvbmZsaWN0cyB3aGVyZSBib3RoIGFsaWFzIGFuZCByYXcgcHJvcGVydHkgYXJlIGRlZmluZWQgb24gdGhlIHNhbWUgb2JqZWN0LlxuICogQHJldHVybiB7UXVlcnl9XG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbk1vZGVsLmRlbGV0ZU9uZSA9IGZ1bmN0aW9uIGRlbGV0ZU9uZShjb25kaXRpb25zLCBvcHRpb25zKSB7XG4gIF9jaGVja0NvbnRleHQodGhpcywgJ2RlbGV0ZU9uZScpO1xuXG4gIGlmICh0eXBlb2YgYXJndW1lbnRzWzBdID09PSAnZnVuY3Rpb24nIHx8IHR5cGVvZiBhcmd1bWVudHNbMV0gPT09ICdmdW5jdGlvbicgfHwgdHlwZW9mIGFyZ3VtZW50c1syXSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHRocm93IG5ldyBNb25nb29zZUVycm9yKCdNb2RlbC5wcm90b3R5cGUuZGVsZXRlT25lKCkgbm8gbG9uZ2VyIGFjY2VwdHMgYSBjYWxsYmFjaycpO1xuICB9XG5cbiAgY29uc3QgbXEgPSBuZXcgdGhpcy5RdWVyeSh7fSwge30sIHRoaXMsIHRoaXMuJF9fY29sbGVjdGlvbik7XG4gIG1xLnNldE9wdGlvbnMob3B0aW9ucyk7XG5cbiAgcmV0dXJuIG1xLmRlbGV0ZU9uZShjb25kaXRpb25zKTtcbn07XG5cbi8qKlxuICogRGVsZXRlcyBhbGwgb2YgdGhlIGRvY3VtZW50cyB0aGF0IG1hdGNoIGBjb25kaXRpb25zYCBmcm9tIHRoZSBjb2xsZWN0aW9uLlxuICogSXQgcmV0dXJucyBhbiBvYmplY3Qgd2l0aCB0aGUgcHJvcGVydHkgYGRlbGV0ZWRDb3VudGAgY29udGFpbmluZyB0aGUgbnVtYmVyIG9mIGRvY3VtZW50cyBkZWxldGVkLlxuICogQmVoYXZlcyBsaWtlIGByZW1vdmUoKWAsIGJ1dCBkZWxldGVzIGFsbCBkb2N1bWVudHMgdGhhdCBtYXRjaCBgY29uZGl0aW9uc2BcbiAqIHJlZ2FyZGxlc3Mgb2YgdGhlIGBzaW5nbGVgIG9wdGlvbi5cbiAqXG4gKiAjIyMjIEV4YW1wbGU6XG4gKlxuICogICAgIGF3YWl0IENoYXJhY3Rlci5kZWxldGVNYW55KHsgbmFtZTogL1N0YXJrLywgYWdlOiB7ICRndGU6IDE4IH0gfSk7IC8vIHJldHVybnMge2RlbGV0ZWRDb3VudDogeH0gd2hlcmUgeCBpcyB0aGUgbnVtYmVyIG9mIGRvY3VtZW50cyBkZWxldGVkLlxuICpcbiAqICMjIyMgTm90ZTpcbiAqXG4gKiBUaGlzIGZ1bmN0aW9uIHRyaWdnZXJzIGBkZWxldGVNYW55YCBxdWVyeSBob29rcy4gUmVhZCB0aGVcbiAqIFttaWRkbGV3YXJlIGRvY3NdKGh0dHBzOi8vbW9uZ29vc2Vqcy5jb20vZG9jcy9taWRkbGV3YXJlLmh0bWwjbmFtaW5nKSB0byBsZWFybiBtb3JlLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBjb25kaXRpb25zXG4gKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdIG9wdGlvbmFsIHNlZSBbYFF1ZXJ5LnByb3RvdHlwZS5zZXRPcHRpb25zKClgXShodHRwczovL21vbmdvb3NlanMuY29tL2RvY3MvYXBpL3F1ZXJ5Lmh0bWwjUXVlcnkucHJvdG90eXBlLnNldE9wdGlvbnMoKSlcbiAqIEBwYXJhbSB7Qm9vbGVhbn0gW29wdGlvbnMudHJhbnNsYXRlQWxpYXNlcz1udWxsXSBJZiBzZXQgdG8gYHRydWVgLCB0cmFuc2xhdGVzIGFueSBzY2hlbWEtZGVmaW5lZCBhbGlhc2VzIGluIGBmaWx0ZXJgLCBgcHJvamVjdGlvbmAsIGB1cGRhdGVgLCBhbmQgYGRpc3RpbmN0YC4gVGhyb3dzIGFuIGVycm9yIGlmIHRoZXJlIGFyZSBhbnkgY29uZmxpY3RzIHdoZXJlIGJvdGggYWxpYXMgYW5kIHJhdyBwcm9wZXJ0eSBhcmUgZGVmaW5lZCBvbiB0aGUgc2FtZSBvYmplY3QuXG4gKiBAcmV0dXJuIHtRdWVyeX1cbiAqIEBhcGkgcHVibGljXG4gKi9cblxuTW9kZWwuZGVsZXRlTWFueSA9IGZ1bmN0aW9uIGRlbGV0ZU1hbnkoY29uZGl0aW9ucywgb3B0aW9ucykge1xuICBfY2hlY2tDb250ZXh0KHRoaXMsICdkZWxldGVNYW55Jyk7XG5cbiAgaWYgKHR5cGVvZiBhcmd1bWVudHNbMF0gPT09ICdmdW5jdGlvbicgfHwgdHlwZW9mIGFyZ3VtZW50c1sxXSA9PT0gJ2Z1bmN0aW9uJyB8fCB0eXBlb2YgYXJndW1lbnRzWzJdID09PSAnZnVuY3Rpb24nKSB7XG4gICAgdGhyb3cgbmV3IE1vbmdvb3NlRXJyb3IoJ01vZGVsLmRlbGV0ZU1hbnkoKSBubyBsb25nZXIgYWNjZXB0cyBhIGNhbGxiYWNrJyk7XG4gIH1cblxuICBjb25zdCBtcSA9IG5ldyB0aGlzLlF1ZXJ5KHt9LCB7fSwgdGhpcywgdGhpcy4kX19jb2xsZWN0aW9uKTtcbiAgbXEuc2V0T3B0aW9ucyhvcHRpb25zKTtcblxuICByZXR1cm4gbXEuZGVsZXRlTWFueShjb25kaXRpb25zKTtcbn07XG5cbi8qKlxuICogRmluZHMgZG9jdW1lbnRzLlxuICpcbiAqIE1vbmdvb3NlIGNhc3RzIHRoZSBgZmlsdGVyYCB0byBtYXRjaCB0aGUgbW9kZWwncyBzY2hlbWEgYmVmb3JlIHRoZSBjb21tYW5kIGlzIHNlbnQuXG4gKiBTZWUgb3VyIFtxdWVyeSBjYXN0aW5nIHR1dG9yaWFsXShodHRwczovL21vbmdvb3NlanMuY29tL2RvY3MvdHV0b3JpYWxzL3F1ZXJ5X2Nhc3RpbmcuaHRtbCkgZm9yXG4gKiBtb3JlIGluZm9ybWF0aW9uIG9uIGhvdyBNb25nb29zZSBjYXN0cyBgZmlsdGVyYC5cbiAqXG4gKiAjIyMjIEV4YW1wbGU6XG4gKlxuICogICAgIC8vIGZpbmQgYWxsIGRvY3VtZW50c1xuICogICAgIGF3YWl0IE15TW9kZWwuZmluZCh7fSk7XG4gKlxuICogICAgIC8vIGZpbmQgYWxsIGRvY3VtZW50cyBuYW1lZCBqb2huIGFuZCBhdCBsZWFzdCAxOFxuICogICAgIGF3YWl0IE15TW9kZWwuZmluZCh7IG5hbWU6ICdqb2huJywgYWdlOiB7ICRndGU6IDE4IH0gfSkuZXhlYygpO1xuICpcbiAqICAgICAvLyBleGVjdXRlcywgbmFtZSBMSUtFIGpvaG4gYW5kIG9ubHkgc2VsZWN0aW5nIHRoZSBcIm5hbWVcIiBhbmQgXCJmcmllbmRzXCIgZmllbGRzXG4gKiAgICAgYXdhaXQgTXlNb2RlbC5maW5kKHsgbmFtZTogL2pvaG4vaSB9LCAnbmFtZSBmcmllbmRzJykuZXhlYygpO1xuICpcbiAqICAgICAvLyBwYXNzaW5nIG9wdGlvbnNcbiAqICAgICBhd2FpdCBNeU1vZGVsLmZpbmQoeyBuYW1lOiAvam9obi9pIH0sIG51bGwsIHsgc2tpcDogMTAgfSkuZXhlYygpO1xuICpcbiAqIEBwYXJhbSB7T2JqZWN0fE9iamVjdElkfSBmaWx0ZXJcbiAqIEBwYXJhbSB7T2JqZWN0fFN0cmluZ3xTdHJpbmdbXX0gW3Byb2plY3Rpb25dIG9wdGlvbmFsIGZpZWxkcyB0byByZXR1cm4sIHNlZSBbYFF1ZXJ5LnByb3RvdHlwZS5zZWxlY3QoKWBdKGh0dHBzOi8vbW9uZ29vc2Vqcy5jb20vZG9jcy9hcGkvcXVlcnkuaHRtbCNRdWVyeS5wcm90b3R5cGUuc2VsZWN0KCkpXG4gKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdIG9wdGlvbmFsIHNlZSBbYFF1ZXJ5LnByb3RvdHlwZS5zZXRPcHRpb25zKClgXShodHRwczovL21vbmdvb3NlanMuY29tL2RvY3MvYXBpL3F1ZXJ5Lmh0bWwjUXVlcnkucHJvdG90eXBlLnNldE9wdGlvbnMoKSlcbiAqIEBwYXJhbSB7Qm9vbGVhbn0gW29wdGlvbnMudHJhbnNsYXRlQWxpYXNlcz1udWxsXSBJZiBzZXQgdG8gYHRydWVgLCB0cmFuc2xhdGVzIGFueSBzY2hlbWEtZGVmaW5lZCBhbGlhc2VzIGluIGBmaWx0ZXJgLCBgcHJvamVjdGlvbmAsIGB1cGRhdGVgLCBhbmQgYGRpc3RpbmN0YC4gVGhyb3dzIGFuIGVycm9yIGlmIHRoZXJlIGFyZSBhbnkgY29uZmxpY3RzIHdoZXJlIGJvdGggYWxpYXMgYW5kIHJhdyBwcm9wZXJ0eSBhcmUgZGVmaW5lZCBvbiB0aGUgc2FtZSBvYmplY3QuXG4gKiBAcmV0dXJuIHtRdWVyeX1cbiAqIEBzZWUgZmllbGQgc2VsZWN0aW9uIGh0dHBzOi8vbW9uZ29vc2Vqcy5jb20vZG9jcy9hcGkvcXVlcnkuaHRtbCNRdWVyeS5wcm90b3R5cGUuc2VsZWN0KClcbiAqIEBzZWUgcXVlcnkgY2FzdGluZyBodHRwczovL21vbmdvb3NlanMuY29tL2RvY3MvdHV0b3JpYWxzL3F1ZXJ5X2Nhc3RpbmcuaHRtbFxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5Nb2RlbC5maW5kID0gZnVuY3Rpb24gZmluZChjb25kaXRpb25zLCBwcm9qZWN0aW9uLCBvcHRpb25zKSB7XG4gIF9jaGVja0NvbnRleHQodGhpcywgJ2ZpbmQnKTtcbiAgaWYgKHR5cGVvZiBhcmd1bWVudHNbMF0gPT09ICdmdW5jdGlvbicgfHwgdHlwZW9mIGFyZ3VtZW50c1sxXSA9PT0gJ2Z1bmN0aW9uJyB8fCB0eXBlb2YgYXJndW1lbnRzWzJdID09PSAnZnVuY3Rpb24nIHx8IHR5cGVvZiBhcmd1bWVudHNbM10gPT09ICdmdW5jdGlvbicpIHtcbiAgICB0aHJvdyBuZXcgTW9uZ29vc2VFcnJvcignTW9kZWwuZmluZCgpIG5vIGxvbmdlciBhY2NlcHRzIGEgY2FsbGJhY2snKTtcbiAgfVxuXG4gIGNvbnN0IG1xID0gbmV3IHRoaXMuUXVlcnkoe30sIHt9LCB0aGlzLCB0aGlzLiRfX2NvbGxlY3Rpb24pO1xuICBtcS5zZWxlY3QocHJvamVjdGlvbik7XG4gIG1xLnNldE9wdGlvbnMob3B0aW9ucyk7XG5cbiAgcmV0dXJuIG1xLmZpbmQoY29uZGl0aW9ucyk7XG59O1xuXG4vKipcbiAqIEZpbmRzIGEgc2luZ2xlIGRvY3VtZW50IGJ5IGl0cyBfaWQgZmllbGQuIGBmaW5kQnlJZChpZClgIGlzIGFsbW9zdCpcbiAqIGVxdWl2YWxlbnQgdG8gYGZpbmRPbmUoeyBfaWQ6IGlkIH0pYC4gSWYgeW91IHdhbnQgdG8gcXVlcnkgYnkgYSBkb2N1bWVudCdzXG4gKiBgX2lkYCwgdXNlIGBmaW5kQnlJZCgpYCBpbnN0ZWFkIG9mIGBmaW5kT25lKClgLlxuICpcbiAqIFRoZSBgaWRgIGlzIGNhc3QgYmFzZWQgb24gdGhlIFNjaGVtYSBiZWZvcmUgc2VuZGluZyB0aGUgY29tbWFuZC5cbiAqXG4gKiBUaGlzIGZ1bmN0aW9uIHRyaWdnZXJzIHRoZSBmb2xsb3dpbmcgbWlkZGxld2FyZS5cbiAqXG4gKiAtIGBmaW5kT25lKClgXG4gKlxuICogXFwqIEV4Y2VwdCBmb3IgaG93IGl0IHRyZWF0cyBgdW5kZWZpbmVkYC4gSWYgeW91IHVzZSBgZmluZE9uZSgpYCwgeW91J2xsIHNlZVxuICogdGhhdCBgZmluZE9uZSh1bmRlZmluZWQpYCBhbmQgYGZpbmRPbmUoeyBfaWQ6IHVuZGVmaW5lZCB9KWAgYXJlIGVxdWl2YWxlbnRcbiAqIHRvIGBmaW5kT25lKHt9KWAgYW5kIHJldHVybiBhcmJpdHJhcnkgZG9jdW1lbnRzLiBIb3dldmVyLCBtb25nb29zZVxuICogdHJhbnNsYXRlcyBgZmluZEJ5SWQodW5kZWZpbmVkKWAgaW50byBgZmluZE9uZSh7IF9pZDogbnVsbCB9KWAuXG4gKlxuICogIyMjIyBFeGFtcGxlOlxuICpcbiAqICAgICAvLyBGaW5kIHRoZSBhZHZlbnR1cmUgd2l0aCB0aGUgZ2l2ZW4gYGlkYCwgb3IgYG51bGxgIGlmIG5vdCBmb3VuZFxuICogICAgIGF3YWl0IEFkdmVudHVyZS5maW5kQnlJZChpZCkuZXhlYygpO1xuICpcbiAqICAgICAvLyBzZWxlY3Qgb25seSB0aGUgYWR2ZW50dXJlcyBuYW1lIGFuZCBsZW5ndGhcbiAqICAgICBhd2FpdCBBZHZlbnR1cmUuZmluZEJ5SWQoaWQsICduYW1lIGxlbmd0aCcpLmV4ZWMoKTtcbiAqXG4gKiBAcGFyYW0ge0FueX0gaWQgdmFsdWUgb2YgYF9pZGAgdG8gcXVlcnkgYnlcbiAqIEBwYXJhbSB7T2JqZWN0fFN0cmluZ3xTdHJpbmdbXX0gW3Byb2plY3Rpb25dIG9wdGlvbmFsIGZpZWxkcyB0byByZXR1cm4sIHNlZSBbYFF1ZXJ5LnByb3RvdHlwZS5zZWxlY3QoKWBdKGh0dHBzOi8vbW9uZ29vc2Vqcy5jb20vZG9jcy9hcGkvcXVlcnkuaHRtbCNRdWVyeS5wcm90b3R5cGUuc2VsZWN0KCkpXG4gKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdIG9wdGlvbmFsIHNlZSBbYFF1ZXJ5LnByb3RvdHlwZS5zZXRPcHRpb25zKClgXShodHRwczovL21vbmdvb3NlanMuY29tL2RvY3MvYXBpL3F1ZXJ5Lmh0bWwjUXVlcnkucHJvdG90eXBlLnNldE9wdGlvbnMoKSlcbiAqIEByZXR1cm4ge1F1ZXJ5fVxuICogQHNlZSBmaWVsZCBzZWxlY3Rpb24gaHR0cHM6Ly9tb25nb29zZWpzLmNvbS9kb2NzL2FwaS9xdWVyeS5odG1sI1F1ZXJ5LnByb3RvdHlwZS5zZWxlY3QoKVxuICogQHNlZSBsZWFuIHF1ZXJpZXMgaHR0cHM6Ly9tb25nb29zZWpzLmNvbS9kb2NzL3R1dG9yaWFscy9sZWFuLmh0bWxcbiAqIEBzZWUgZmluZEJ5SWQgaW4gTW9uZ29vc2UgaHR0cHM6Ly9tYXN0ZXJpbmdqcy5pby90dXRvcmlhbHMvbW9uZ29vc2UvZmluZC1ieS1pZFxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5Nb2RlbC5maW5kQnlJZCA9IGZ1bmN0aW9uIGZpbmRCeUlkKGlkLCBwcm9qZWN0aW9uLCBvcHRpb25zKSB7XG4gIF9jaGVja0NvbnRleHQodGhpcywgJ2ZpbmRCeUlkJyk7XG4gIGlmICh0eXBlb2YgYXJndW1lbnRzWzBdID09PSAnZnVuY3Rpb24nIHx8IHR5cGVvZiBhcmd1bWVudHNbMV0gPT09ICdmdW5jdGlvbicgfHwgdHlwZW9mIGFyZ3VtZW50c1syXSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHRocm93IG5ldyBNb25nb29zZUVycm9yKCdNb2RlbC5maW5kQnlJZCgpIG5vIGxvbmdlciBhY2NlcHRzIGEgY2FsbGJhY2snKTtcbiAgfVxuXG4gIGlmICh0eXBlb2YgaWQgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgaWQgPSBudWxsO1xuICB9XG5cbiAgcmV0dXJuIHRoaXMuZmluZE9uZSh7IF9pZDogaWQgfSwgcHJvamVjdGlvbiwgb3B0aW9ucyk7XG59O1xuXG4vKipcbiAqIEZpbmRzIG9uZSBkb2N1bWVudC5cbiAqXG4gKiBUaGUgYGNvbmRpdGlvbnNgIGFyZSBjYXN0IHRvIHRoZWlyIHJlc3BlY3RpdmUgU2NoZW1hVHlwZXMgYmVmb3JlIHRoZSBjb21tYW5kIGlzIHNlbnQuXG4gKlxuICogKk5vdGU6KiBgY29uZGl0aW9uc2AgaXMgb3B0aW9uYWwsIGFuZCBpZiBgY29uZGl0aW9uc2AgaXMgbnVsbCBvciB1bmRlZmluZWQsXG4gKiBtb25nb29zZSB3aWxsIHNlbmQgYW4gZW1wdHkgYGZpbmRPbmVgIGNvbW1hbmQgdG8gTW9uZ29EQiwgd2hpY2ggd2lsbCByZXR1cm5cbiAqIGFuIGFyYml0cmFyeSBkb2N1bWVudC4gSWYgeW91J3JlIHF1ZXJ5aW5nIGJ5IGBfaWRgLCB1c2UgYGZpbmRCeUlkKClgIGluc3RlYWQuXG4gKlxuICogIyMjIyBFeGFtcGxlOlxuICpcbiAqICAgICAvLyBGaW5kIG9uZSBhZHZlbnR1cmUgd2hvc2UgYGNvdW50cnlgIGlzICdDcm9hdGlhJywgb3RoZXJ3aXNlIGBudWxsYFxuICogICAgIGF3YWl0IEFkdmVudHVyZS5maW5kT25lKHsgY291bnRyeTogJ0Nyb2F0aWEnIH0pLmV4ZWMoKTtcbiAqXG4gKiAgICAgLy8gTW9kZWwuZmluZE9uZSgpIG5vIGxvbmdlciBhY2NlcHRzIGEgY2FsbGJhY2tcbiAqXG4gKiAgICAgLy8gU2VsZWN0IG9ubHkgdGhlIGFkdmVudHVyZXMgbmFtZSBhbmQgbGVuZ3RoXG4gKiAgICAgYXdhaXQgQWR2ZW50dXJlLmZpbmRPbmUoeyBjb3VudHJ5OiAnQ3JvYXRpYScgfSwgJ25hbWUgbGVuZ3RoJykuZXhlYygpO1xuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBbY29uZGl0aW9uc11cbiAqIEBwYXJhbSB7T2JqZWN0fFN0cmluZ3xTdHJpbmdbXX0gW3Byb2plY3Rpb25dIG9wdGlvbmFsIGZpZWxkcyB0byByZXR1cm4sIHNlZSBbYFF1ZXJ5LnByb3RvdHlwZS5zZWxlY3QoKWBdKGh0dHBzOi8vbW9uZ29vc2Vqcy5jb20vZG9jcy9hcGkvcXVlcnkuaHRtbCNRdWVyeS5wcm90b3R5cGUuc2VsZWN0KCkpXG4gKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdIG9wdGlvbmFsIHNlZSBbYFF1ZXJ5LnByb3RvdHlwZS5zZXRPcHRpb25zKClgXShodHRwczovL21vbmdvb3NlanMuY29tL2RvY3MvYXBpL3F1ZXJ5Lmh0bWwjUXVlcnkucHJvdG90eXBlLnNldE9wdGlvbnMoKSlcbiAqIEBwYXJhbSB7Qm9vbGVhbn0gW29wdGlvbnMudHJhbnNsYXRlQWxpYXNlcz1udWxsXSBJZiBzZXQgdG8gYHRydWVgLCB0cmFuc2xhdGVzIGFueSBzY2hlbWEtZGVmaW5lZCBhbGlhc2VzIGluIGBmaWx0ZXJgLCBgcHJvamVjdGlvbmAsIGB1cGRhdGVgLCBhbmQgYGRpc3RpbmN0YC4gVGhyb3dzIGFuIGVycm9yIGlmIHRoZXJlIGFyZSBhbnkgY29uZmxpY3RzIHdoZXJlIGJvdGggYWxpYXMgYW5kIHJhdyBwcm9wZXJ0eSBhcmUgZGVmaW5lZCBvbiB0aGUgc2FtZSBvYmplY3QuXG4gKiBAcmV0dXJuIHtRdWVyeX1cbiAqIEBzZWUgZmllbGQgc2VsZWN0aW9uIGh0dHBzOi8vbW9uZ29vc2Vqcy5jb20vZG9jcy9hcGkvcXVlcnkuaHRtbCNRdWVyeS5wcm90b3R5cGUuc2VsZWN0KClcbiAqIEBzZWUgbGVhbiBxdWVyaWVzIGh0dHBzOi8vbW9uZ29vc2Vqcy5jb20vZG9jcy90dXRvcmlhbHMvbGVhbi5odG1sXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbk1vZGVsLmZpbmRPbmUgPSBmdW5jdGlvbiBmaW5kT25lKGNvbmRpdGlvbnMsIHByb2plY3Rpb24sIG9wdGlvbnMpIHtcbiAgX2NoZWNrQ29udGV4dCh0aGlzLCAnZmluZE9uZScpO1xuICBpZiAodHlwZW9mIGFyZ3VtZW50c1swXSA9PT0gJ2Z1bmN0aW9uJyB8fCB0eXBlb2YgYXJndW1lbnRzWzFdID09PSAnZnVuY3Rpb24nIHx8IHR5cGVvZiBhcmd1bWVudHNbMl0gPT09ICdmdW5jdGlvbicpIHtcbiAgICB0aHJvdyBuZXcgTW9uZ29vc2VFcnJvcignTW9kZWwuZmluZE9uZSgpIG5vIGxvbmdlciBhY2NlcHRzIGEgY2FsbGJhY2snKTtcbiAgfVxuXG4gIGNvbnN0IG1xID0gbmV3IHRoaXMuUXVlcnkoe30sIHt9LCB0aGlzLCB0aGlzLiRfX2NvbGxlY3Rpb24pO1xuICBtcS5zZWxlY3QocHJvamVjdGlvbik7XG4gIG1xLnNldE9wdGlvbnMob3B0aW9ucyk7XG5cbiAgcmV0dXJuIG1xLmZpbmRPbmUoY29uZGl0aW9ucyk7XG59O1xuXG4vKipcbiAqIEVzdGltYXRlcyB0aGUgbnVtYmVyIG9mIGRvY3VtZW50cyBpbiB0aGUgTW9uZ29EQiBjb2xsZWN0aW9uLiBGYXN0ZXIgdGhhblxuICogdXNpbmcgYGNvdW50RG9jdW1lbnRzKClgIGZvciBsYXJnZSBjb2xsZWN0aW9ucyBiZWNhdXNlXG4gKiBgZXN0aW1hdGVkRG9jdW1lbnRDb3VudCgpYCB1c2VzIGNvbGxlY3Rpb24gbWV0YWRhdGEgcmF0aGVyIHRoYW4gc2Nhbm5pbmdcbiAqIHRoZSBlbnRpcmUgY29sbGVjdGlvbi5cbiAqXG4gKiAjIyMjIEV4YW1wbGU6XG4gKlxuICogICAgIGNvbnN0IG51bUFkdmVudHVyZXMgPSBhd2FpdCBBZHZlbnR1cmUuZXN0aW1hdGVkRG9jdW1lbnRDb3VudCgpO1xuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc11cbiAqIEByZXR1cm4ge1F1ZXJ5fVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5Nb2RlbC5lc3RpbWF0ZWREb2N1bWVudENvdW50ID0gZnVuY3Rpb24gZXN0aW1hdGVkRG9jdW1lbnRDb3VudChvcHRpb25zKSB7XG4gIF9jaGVja0NvbnRleHQodGhpcywgJ2VzdGltYXRlZERvY3VtZW50Q291bnQnKTtcblxuICBjb25zdCBtcSA9IG5ldyB0aGlzLlF1ZXJ5KHt9LCB7fSwgdGhpcywgdGhpcy4kX19jb2xsZWN0aW9uKTtcblxuICByZXR1cm4gbXEuZXN0aW1hdGVkRG9jdW1lbnRDb3VudChvcHRpb25zKTtcbn07XG5cbi8qKlxuICogQ291bnRzIG51bWJlciBvZiBkb2N1bWVudHMgbWF0Y2hpbmcgYGZpbHRlcmAgaW4gYSBkYXRhYmFzZSBjb2xsZWN0aW9uLlxuICpcbiAqICMjIyMgRXhhbXBsZTpcbiAqXG4gKiAgICAgQWR2ZW50dXJlLmNvdW50RG9jdW1lbnRzKHsgdHlwZTogJ2p1bmdsZScgfSwgZnVuY3Rpb24gKGVyciwgY291bnQpIHtcbiAqICAgICAgIGNvbnNvbGUubG9nKCd0aGVyZSBhcmUgJWQganVuZ2xlIGFkdmVudHVyZXMnLCBjb3VudCk7XG4gKiAgICAgfSk7XG4gKlxuICogSWYgeW91IHdhbnQgdG8gY291bnQgYWxsIGRvY3VtZW50cyBpbiBhIGxhcmdlIGNvbGxlY3Rpb24sXG4gKiB1c2UgdGhlIFtgZXN0aW1hdGVkRG9jdW1lbnRDb3VudCgpYCBmdW5jdGlvbl0oaHR0cHM6Ly9tb25nb29zZWpzLmNvbS9kb2NzL2FwaS9tb2RlbC5odG1sI01vZGVsLmVzdGltYXRlZERvY3VtZW50Q291bnQoKSlcbiAqIGluc3RlYWQuIElmIHlvdSBjYWxsIGBjb3VudERvY3VtZW50cyh7fSlgLCBNb25nb0RCIHdpbGwgYWx3YXlzIGV4ZWN1dGVcbiAqIGEgZnVsbCBjb2xsZWN0aW9uIHNjYW4gYW5kICoqbm90KiogdXNlIGFueSBpbmRleGVzLlxuICpcbiAqIFRoZSBgY291bnREb2N1bWVudHMoKWAgZnVuY3Rpb24gaXMgc2ltaWxhciB0byBgY291bnQoKWAsIGJ1dCB0aGVyZSBhcmUgYVxuICogW2ZldyBvcGVyYXRvcnMgdGhhdCBgY291bnREb2N1bWVudHMoKWAgZG9lcyBub3Qgc3VwcG9ydF0oaHR0cHM6Ly9tb25nb2RiLmdpdGh1Yi5pby9ub2RlLW1vbmdvZGItbmF0aXZlLzQuOS9jbGFzc2VzL0NvbGxlY3Rpb24uaHRtbCNjb3VudERvY3VtZW50cykuXG4gKiBCZWxvdyBhcmUgdGhlIG9wZXJhdG9ycyB0aGF0IGBjb3VudCgpYCBzdXBwb3J0cyBidXQgYGNvdW50RG9jdW1lbnRzKClgIGRvZXMgbm90LFxuICogYW5kIHRoZSBzdWdnZXN0ZWQgcmVwbGFjZW1lbnQ6XG4gKlxuICogLSBgJHdoZXJlYDogW2AkZXhwcmBdKGh0dHBzOi8vd3d3Lm1vbmdvZGIuY29tL2RvY3MvbWFudWFsL3JlZmVyZW5jZS9vcGVyYXRvci9xdWVyeS9leHByLylcbiAqIC0gYCRuZWFyYDogW2AkZ2VvV2l0aGluYF0oaHR0cHM6Ly93d3cubW9uZ29kYi5jb20vZG9jcy9tYW51YWwvcmVmZXJlbmNlL29wZXJhdG9yL3F1ZXJ5L2dlb1dpdGhpbi8pIHdpdGggW2AkY2VudGVyYF0oaHR0cHM6Ly93d3cubW9uZ29kYi5jb20vZG9jcy9tYW51YWwvcmVmZXJlbmNlL29wZXJhdG9yL3F1ZXJ5L2NlbnRlci8jb3AuX1NfY2VudGVyKVxuICogLSBgJG5lYXJTcGhlcmVgOiBbYCRnZW9XaXRoaW5gXShodHRwczovL3d3dy5tb25nb2RiLmNvbS9kb2NzL21hbnVhbC9yZWZlcmVuY2Uvb3BlcmF0b3IvcXVlcnkvZ2VvV2l0aGluLykgd2l0aCBbYCRjZW50ZXJTcGhlcmVgXShodHRwczovL3d3dy5tb25nb2RiLmNvbS9kb2NzL21hbnVhbC9yZWZlcmVuY2Uvb3BlcmF0b3IvcXVlcnkvY2VudGVyU3BoZXJlLyNvcC5fU19jZW50ZXJTcGhlcmUpXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IGZpbHRlclxuICogQHJldHVybiB7UXVlcnl9XG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbk1vZGVsLmNvdW50RG9jdW1lbnRzID0gZnVuY3Rpb24gY291bnREb2N1bWVudHMoY29uZGl0aW9ucywgb3B0aW9ucykge1xuICBfY2hlY2tDb250ZXh0KHRoaXMsICdjb3VudERvY3VtZW50cycpO1xuICBpZiAodHlwZW9mIGFyZ3VtZW50c1swXSA9PT0gJ2Z1bmN0aW9uJyB8fCB0eXBlb2YgYXJndW1lbnRzWzFdID09PSAnZnVuY3Rpb24nIHx8IHR5cGVvZiBhcmd1bWVudHNbMl0gPT09ICdmdW5jdGlvbicpIHtcbiAgICB0aHJvdyBuZXcgTW9uZ29vc2VFcnJvcignTW9kZWwuY291bnREb2N1bWVudHMoKSBubyBsb25nZXIgYWNjZXB0cyBhIGNhbGxiYWNrJyk7XG4gIH1cblxuICBjb25zdCBtcSA9IG5ldyB0aGlzLlF1ZXJ5KHt9LCB7fSwgdGhpcywgdGhpcy4kX19jb2xsZWN0aW9uKTtcbiAgaWYgKG9wdGlvbnMgIT0gbnVsbCkge1xuICAgIG1xLnNldE9wdGlvbnMob3B0aW9ucyk7XG4gIH1cblxuICByZXR1cm4gbXEuY291bnREb2N1bWVudHMoY29uZGl0aW9ucyk7XG59O1xuXG5cbi8qKlxuICogQ3JlYXRlcyBhIFF1ZXJ5IGZvciBhIGBkaXN0aW5jdGAgb3BlcmF0aW9uLlxuICpcbiAqICMjIyMgRXhhbXBsZTpcbiAqXG4gKiAgICAgY29uc3QgcXVlcnkgPSBMaW5rLmRpc3RpbmN0KCd1cmwnKTtcbiAqICAgICBxdWVyeS5leGVjKCk7XG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IGZpZWxkXG4gKiBAcGFyYW0ge09iamVjdH0gW2NvbmRpdGlvbnNdIG9wdGlvbmFsXG4gKiBAcmV0dXJuIHtRdWVyeX1cbiAqIEBhcGkgcHVibGljXG4gKi9cblxuTW9kZWwuZGlzdGluY3QgPSBmdW5jdGlvbiBkaXN0aW5jdChmaWVsZCwgY29uZGl0aW9ucykge1xuICBfY2hlY2tDb250ZXh0KHRoaXMsICdkaXN0aW5jdCcpO1xuICBpZiAodHlwZW9mIGFyZ3VtZW50c1swXSA9PT0gJ2Z1bmN0aW9uJyB8fCB0eXBlb2YgYXJndW1lbnRzWzFdID09PSAnZnVuY3Rpb24nKSB7XG4gICAgdGhyb3cgbmV3IE1vbmdvb3NlRXJyb3IoJ01vZGVsLmRpc3RpbmN0KCkgbm8gbG9uZ2VyIGFjY2VwdHMgYSBjYWxsYmFjaycpO1xuICB9XG5cbiAgY29uc3QgbXEgPSBuZXcgdGhpcy5RdWVyeSh7fSwge30sIHRoaXMsIHRoaXMuJF9fY29sbGVjdGlvbik7XG5cbiAgcmV0dXJuIG1xLmRpc3RpbmN0KGZpZWxkLCBjb25kaXRpb25zKTtcbn07XG5cbi8qKlxuICogQ3JlYXRlcyBhIFF1ZXJ5LCBhcHBsaWVzIHRoZSBwYXNzZWQgY29uZGl0aW9ucywgYW5kIHJldHVybnMgdGhlIFF1ZXJ5LlxuICpcbiAqIEZvciBleGFtcGxlLCBpbnN0ZWFkIG9mIHdyaXRpbmc6XG4gKlxuICogICAgIFVzZXIuZmluZCh7IGFnZTogeyAkZ3RlOiAyMSwgJGx0ZTogNjUgfSB9KTtcbiAqXG4gKiB3ZSBjYW4gaW5zdGVhZCB3cml0ZTpcbiAqXG4gKiAgICAgVXNlci53aGVyZSgnYWdlJykuZ3RlKDIxKS5sdGUoNjUpLmV4ZWMoKTtcbiAqXG4gKiBTaW5jZSB0aGUgUXVlcnkgY2xhc3MgYWxzbyBzdXBwb3J0cyBgd2hlcmVgIHlvdSBjYW4gY29udGludWUgY2hhaW5pbmdcbiAqXG4gKiAgICAgVXNlclxuICogICAgIC53aGVyZSgnYWdlJykuZ3RlKDIxKS5sdGUoNjUpXG4gKiAgICAgLndoZXJlKCduYW1lJywgL15iL2kpXG4gKiAgICAgLi4uIGV0Y1xuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBwYXRoXG4gKiBAcGFyYW0ge09iamVjdH0gW3ZhbF0gb3B0aW9uYWwgdmFsdWVcbiAqIEByZXR1cm4ge1F1ZXJ5fVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5Nb2RlbC53aGVyZSA9IGZ1bmN0aW9uIHdoZXJlKHBhdGgsIHZhbCkge1xuICBfY2hlY2tDb250ZXh0KHRoaXMsICd3aGVyZScpO1xuXG4gIHZvaWQgdmFsOyAvLyBlc2xpbnRcbiAgY29uc3QgbXEgPSBuZXcgdGhpcy5RdWVyeSh7fSwge30sIHRoaXMsIHRoaXMuJF9fY29sbGVjdGlvbikuZmluZCh7fSk7XG4gIHJldHVybiBtcS53aGVyZS5hcHBseShtcSwgYXJndW1lbnRzKTtcbn07XG5cbi8qKlxuICogQ3JlYXRlcyBhIGBRdWVyeWAgYW5kIHNwZWNpZmllcyBhIGAkd2hlcmVgIGNvbmRpdGlvbi5cbiAqXG4gKiBTb21ldGltZXMgeW91IG5lZWQgdG8gcXVlcnkgZm9yIHRoaW5ncyBpbiBtb25nb2RiIHVzaW5nIGEgSmF2YVNjcmlwdCBleHByZXNzaW9uLiBZb3UgY2FuIGRvIHNvIHZpYSBgZmluZCh7ICR3aGVyZTogamF2YXNjcmlwdCB9KWAsIG9yIHlvdSBjYW4gdXNlIHRoZSBtb25nb29zZSBzaG9ydGN1dCBtZXRob2QgJHdoZXJlIHZpYSBhIFF1ZXJ5IGNoYWluIG9yIGZyb20geW91ciBtb25nb29zZSBNb2RlbC5cbiAqXG4gKiAgICAgQmxvZy4kd2hlcmUoJ3RoaXMudXNlcm5hbWUuaW5kZXhPZihcInZhbFwiKSAhPT0gLTEnKS5leGVjKGZ1bmN0aW9uIChlcnIsIGRvY3MpIHt9KTtcbiAqXG4gKiBAcGFyYW0ge1N0cmluZ3xGdW5jdGlvbn0gYXJndW1lbnQgaXMgYSBqYXZhc2NyaXB0IHN0cmluZyBvciBhbm9ueW1vdXMgZnVuY3Rpb25cbiAqIEBtZXRob2QgJHdoZXJlXG4gKiBAbWVtYmVyT2YgTW9kZWxcbiAqIEByZXR1cm4ge1F1ZXJ5fVxuICogQHNlZSBRdWVyeS4kd2hlcmUgaHR0cHM6Ly9tb25nb29zZWpzLmNvbS9kb2NzL2FwaS9xdWVyeS5odG1sI1F1ZXJ5LnByb3RvdHlwZS4kd2hlcmVcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuTW9kZWwuJHdoZXJlID0gZnVuY3Rpb24gJHdoZXJlKCkge1xuICBfY2hlY2tDb250ZXh0KHRoaXMsICckd2hlcmUnKTtcblxuICBjb25zdCBtcSA9IG5ldyB0aGlzLlF1ZXJ5KHt9LCB7fSwgdGhpcywgdGhpcy4kX19jb2xsZWN0aW9uKS5maW5kKHt9KTtcbiAgcmV0dXJuIG1xLiR3aGVyZS5hcHBseShtcSwgYXJndW1lbnRzKTtcbn07XG5cbi8qKlxuICogSXNzdWVzIGEgbW9uZ29kYiBmaW5kT25lQW5kVXBkYXRlIGNvbW1hbmQuXG4gKlxuICogRmluZHMgYSBtYXRjaGluZyBkb2N1bWVudCwgdXBkYXRlcyBpdCBhY2NvcmRpbmcgdG8gdGhlIGB1cGRhdGVgIGFyZywgcGFzc2luZyBhbnkgYG9wdGlvbnNgLCBhbmQgcmV0dXJucyB0aGUgZm91bmQgZG9jdW1lbnQgKGlmIGFueSkgdG8gdGhlIGNhbGxiYWNrLiBUaGUgcXVlcnkgZXhlY3V0ZXMgaWYgYGNhbGxiYWNrYCBpcyBwYXNzZWQgZWxzZSBhIFF1ZXJ5IG9iamVjdCBpcyByZXR1cm5lZC5cbiAqXG4gKiAjIyMjIEV4YW1wbGU6XG4gKlxuICogICAgIEEuZmluZE9uZUFuZFVwZGF0ZShjb25kaXRpb25zLCB1cGRhdGUsIG9wdGlvbnMpICAvLyByZXR1cm5zIFF1ZXJ5XG4gKiAgICAgQS5maW5kT25lQW5kVXBkYXRlKGNvbmRpdGlvbnMsIHVwZGF0ZSkgICAgICAgICAgIC8vIHJldHVybnMgUXVlcnlcbiAqICAgICBBLmZpbmRPbmVBbmRVcGRhdGUoKSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gcmV0dXJucyBRdWVyeVxuICpcbiAqICMjIyMgTm90ZTpcbiAqXG4gKiBBbGwgdG9wIGxldmVsIHVwZGF0ZSBrZXlzIHdoaWNoIGFyZSBub3QgYGF0b21pY2Agb3BlcmF0aW9uIG5hbWVzIGFyZSB0cmVhdGVkIGFzIHNldCBvcGVyYXRpb25zOlxuICpcbiAqICMjIyMgRXhhbXBsZTpcbiAqXG4gKiAgICAgY29uc3QgcXVlcnkgPSB7IG5hbWU6ICdib3JuZScgfTtcbiAqICAgICBNb2RlbC5maW5kT25lQW5kVXBkYXRlKHF1ZXJ5LCB7IG5hbWU6ICdqYXNvbiBib3VybmUnIH0sIG9wdGlvbnMpXG4gKlxuICogICAgIC8vIGlzIHNlbnQgYXNcbiAqICAgICBNb2RlbC5maW5kT25lQW5kVXBkYXRlKHF1ZXJ5LCB7ICRzZXQ6IHsgbmFtZTogJ2phc29uIGJvdXJuZScgfX0sIG9wdGlvbnMpXG4gKlxuICogIyMjIyBOb3RlOlxuICpcbiAqIGBmaW5kT25lQW5kWGAgYW5kIGBmaW5kQnlJZEFuZFhgIGZ1bmN0aW9ucyBzdXBwb3J0IGxpbWl0ZWQgdmFsaWRhdGlvbiB0aGF0XG4gKiB5b3UgY2FuIGVuYWJsZSBieSBzZXR0aW5nIHRoZSBgcnVuVmFsaWRhdG9yc2Agb3B0aW9uLlxuICpcbiAqIElmIHlvdSBuZWVkIGZ1bGwtZmxlZGdlZCB2YWxpZGF0aW9uLCB1c2UgdGhlIHRyYWRpdGlvbmFsIGFwcHJvYWNoIG9mIGZpcnN0XG4gKiByZXRyaWV2aW5nIHRoZSBkb2N1bWVudC5cbiAqXG4gKiAgICAgY29uc3QgZG9jID0gYXdhaXQgTW9kZWwuZmluZEJ5SWQoaWQpO1xuICogICAgIGRvYy5uYW1lID0gJ2phc29uIGJvdXJuZSc7XG4gKiAgICAgYXdhaXQgZG9jLnNhdmUoKTtcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gW2NvbmRpdGlvbnNdXG4gKiBAcGFyYW0ge09iamVjdH0gW3VwZGF0ZV1cbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gb3B0aW9uYWwgc2VlIFtgUXVlcnkucHJvdG90eXBlLnNldE9wdGlvbnMoKWBdKGh0dHBzOi8vbW9uZ29vc2Vqcy5jb20vZG9jcy9hcGkvcXVlcnkuaHRtbCNRdWVyeS5wcm90b3R5cGUuc2V0T3B0aW9ucygpKVxuICogQHBhcmFtIHtTdHJpbmd9IFtvcHRpb25zLnJldHVybkRvY3VtZW50PSdiZWZvcmUnXSBIYXMgdHdvIHBvc3NpYmxlIHZhbHVlcywgYCdiZWZvcmUnYCBhbmQgYCdhZnRlcidgLiBCeSBkZWZhdWx0LCBpdCB3aWxsIHJldHVybiB0aGUgZG9jdW1lbnQgYmVmb3JlIHRoZSB1cGRhdGUgd2FzIGFwcGxpZWQuXG4gKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnMubGVhbl0gaWYgdHJ1dGh5LCBtb25nb29zZSB3aWxsIHJldHVybiB0aGUgZG9jdW1lbnQgYXMgYSBwbGFpbiBKYXZhU2NyaXB0IG9iamVjdCByYXRoZXIgdGhhbiBhIG1vbmdvb3NlIGRvY3VtZW50LiBTZWUgW2BRdWVyeS5sZWFuKClgXShodHRwczovL21vbmdvb3NlanMuY29tL2RvY3MvYXBpL3F1ZXJ5Lmh0bWwjUXVlcnkucHJvdG90eXBlLmxlYW4oKSkgYW5kIFt0aGUgTW9uZ29vc2UgbGVhbiB0dXRvcmlhbF0oaHR0cHM6Ly9tb25nb29zZWpzLmNvbS9kb2NzL3R1dG9yaWFscy9sZWFuLmh0bWwpLlxuICogQHBhcmFtIHtDbGllbnRTZXNzaW9ufSBbb3B0aW9ucy5zZXNzaW9uPW51bGxdIFRoZSBzZXNzaW9uIGFzc29jaWF0ZWQgd2l0aCB0aGlzIHF1ZXJ5LiBTZWUgW3RyYW5zYWN0aW9ucyBkb2NzXShodHRwczovL21vbmdvb3NlanMuY29tL2RvY3MvdHJhbnNhY3Rpb25zLmh0bWwpLlxuICogQHBhcmFtIHtCb29sZWFufFN0cmluZ30gW29wdGlvbnMuc3RyaWN0XSBvdmVyd3JpdGVzIHRoZSBzY2hlbWEncyBbc3RyaWN0IG1vZGUgb3B0aW9uXShodHRwczovL21vbmdvb3NlanMuY29tL2RvY3MvZ3VpZGUuaHRtbCNzdHJpY3QpXG4gKiBAcGFyYW0ge0Jvb2xlYW59IFtvcHRpb25zLnRpbWVzdGFtcHM9bnVsbF0gSWYgc2V0IHRvIGBmYWxzZWAgYW5kIFtzY2hlbWEtbGV2ZWwgdGltZXN0YW1wc10oaHR0cHM6Ly9tb25nb29zZWpzLmNvbS9kb2NzL2d1aWRlLmh0bWwjdGltZXN0YW1wcykgYXJlIGVuYWJsZWQsIHNraXAgdGltZXN0YW1wcyBmb3IgdGhpcyB1cGRhdGUuIE5vdGUgdGhhdCB0aGlzIGFsbG93cyB5b3UgdG8gb3ZlcndyaXRlIHRpbWVzdGFtcHMuIERvZXMgbm90aGluZyBpZiBzY2hlbWEtbGV2ZWwgdGltZXN0YW1wcyBhcmUgbm90IHNldC5cbiAqIEBwYXJhbSB7Qm9vbGVhbn0gW29wdGlvbnMudXBzZXJ0PWZhbHNlXSBpZiB0cnVlLCBhbmQgbm8gZG9jdW1lbnRzIGZvdW5kLCBpbnNlcnQgYSBuZXcgZG9jdW1lbnRcbiAqIEBwYXJhbSB7T2JqZWN0fFN0cmluZ3xTdHJpbmdbXX0gW29wdGlvbnMucHJvamVjdGlvbj1udWxsXSBvcHRpb25hbCBmaWVsZHMgdG8gcmV0dXJuLCBzZWUgW2BRdWVyeS5wcm90b3R5cGUuc2VsZWN0KClgXShodHRwczovL21vbmdvb3NlanMuY29tL2RvY3MvYXBpL3F1ZXJ5Lmh0bWwjUXVlcnkucHJvdG90eXBlLnNlbGVjdCgpKVxuICogQHBhcmFtIHtCb29sZWFufSBbb3B0aW9ucy5uZXc9ZmFsc2VdIGlmIHRydWUsIHJldHVybiB0aGUgbW9kaWZpZWQgZG9jdW1lbnQgcmF0aGVyIHRoYW4gdGhlIG9yaWdpbmFsXG4gKiBAcGFyYW0ge09iamVjdHxTdHJpbmd9IFtvcHRpb25zLmZpZWxkc10gRmllbGQgc2VsZWN0aW9uLiBFcXVpdmFsZW50IHRvIGAuc2VsZWN0KGZpZWxkcykuZmluZE9uZUFuZFVwZGF0ZSgpYFxuICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLm1heFRpbWVNU10gcHV0cyBhIHRpbWUgbGltaXQgb24gdGhlIHF1ZXJ5IC0gcmVxdWlyZXMgbW9uZ29kYiA+PSAyLjYuMFxuICogQHBhcmFtIHtPYmplY3R8U3RyaW5nfSBbb3B0aW9ucy5zb3J0XSBpZiBtdWx0aXBsZSBkb2NzIGFyZSBmb3VuZCBieSB0aGUgY29uZGl0aW9ucywgc2V0cyB0aGUgc29ydCBvcmRlciB0byBjaG9vc2Ugd2hpY2ggZG9jIHRvIHVwZGF0ZS5cbiAqIEBwYXJhbSB7Qm9vbGVhbn0gW29wdGlvbnMucnVuVmFsaWRhdG9yc10gaWYgdHJ1ZSwgcnVucyBbdXBkYXRlIHZhbGlkYXRvcnNdKGh0dHBzOi8vbW9uZ29vc2Vqcy5jb20vZG9jcy92YWxpZGF0aW9uLmh0bWwjdXBkYXRlLXZhbGlkYXRvcnMpIG9uIHRoaXMgY29tbWFuZC4gVXBkYXRlIHZhbGlkYXRvcnMgdmFsaWRhdGUgdGhlIHVwZGF0ZSBvcGVyYXRpb24gYWdhaW5zdCB0aGUgbW9kZWwncyBzY2hlbWFcbiAqIEBwYXJhbSB7Qm9vbGVhbn0gW29wdGlvbnMuc2V0RGVmYXVsdHNPbkluc2VydD10cnVlXSBJZiBgc2V0RGVmYXVsdHNPbkluc2VydGAgYW5kIGB1cHNlcnRgIGFyZSB0cnVlLCBtb25nb29zZSB3aWxsIGFwcGx5IHRoZSBbZGVmYXVsdHNdKGh0dHBzOi8vbW9uZ29vc2Vqcy5jb20vZG9jcy9kZWZhdWx0cy5odG1sKSBzcGVjaWZpZWQgaW4gdGhlIG1vZGVsJ3Mgc2NoZW1hIGlmIGEgbmV3IGRvY3VtZW50IGlzIGNyZWF0ZWRcbiAqIEBwYXJhbSB7Qm9vbGVhbn0gW29wdGlvbnMuaW5jbHVkZVJlc3VsdE1ldGFkYXRhXSBpZiB0cnVlLCByZXR1cm5zIHRoZSBbcmF3IHJlc3VsdCBmcm9tIHRoZSBNb25nb0RCIGRyaXZlcl0oaHR0cHM6Ly9tb25nb2RiLmdpdGh1Yi5pby9ub2RlLW1vbmdvZGItbmF0aXZlLzQuOS9pbnRlcmZhY2VzL01vZGlmeVJlc3VsdC5odG1sKVxuICogQHBhcmFtIHtCb29sZWFufSBbb3B0aW9ucy50cmFuc2xhdGVBbGlhc2VzPW51bGxdIElmIHNldCB0byBgdHJ1ZWAsIHRyYW5zbGF0ZXMgYW55IHNjaGVtYS1kZWZpbmVkIGFsaWFzZXMgaW4gYGZpbHRlcmAsIGBwcm9qZWN0aW9uYCwgYHVwZGF0ZWAsIGFuZCBgZGlzdGluY3RgLiBUaHJvd3MgYW4gZXJyb3IgaWYgdGhlcmUgYXJlIGFueSBjb25mbGljdHMgd2hlcmUgYm90aCBhbGlhcyBhbmQgcmF3IHByb3BlcnR5IGFyZSBkZWZpbmVkIG9uIHRoZSBzYW1lIG9iamVjdC5cbiAqIEByZXR1cm4ge1F1ZXJ5fVxuICogQHNlZSBUdXRvcmlhbCBodHRwczovL21vbmdvb3NlanMuY29tL2RvY3MvdHV0b3JpYWxzL2ZpbmRvbmVhbmR1cGRhdGUuaHRtbFxuICogQHNlZSBtb25nb2RiIGh0dHBzOi8vd3d3Lm1vbmdvZGIuY29tL2RvY3MvbWFudWFsL3JlZmVyZW5jZS9jb21tYW5kL2ZpbmRBbmRNb2RpZnkvXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbk1vZGVsLmZpbmRPbmVBbmRVcGRhdGUgPSBmdW5jdGlvbihjb25kaXRpb25zLCB1cGRhdGUsIG9wdGlvbnMpIHtcbiAgX2NoZWNrQ29udGV4dCh0aGlzLCAnZmluZE9uZUFuZFVwZGF0ZScpO1xuICBpZiAodHlwZW9mIGFyZ3VtZW50c1swXSA9PT0gJ2Z1bmN0aW9uJyB8fCB0eXBlb2YgYXJndW1lbnRzWzFdID09PSAnZnVuY3Rpb24nIHx8IHR5cGVvZiBhcmd1bWVudHNbMl0gPT09ICdmdW5jdGlvbicgfHwgdHlwZW9mIGFyZ3VtZW50c1szXSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHRocm93IG5ldyBNb25nb29zZUVycm9yKCdNb2RlbC5maW5kT25lQW5kVXBkYXRlKCkgbm8gbG9uZ2VyIGFjY2VwdHMgYSBjYWxsYmFjaycpO1xuICB9XG5cbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDEpIHtcbiAgICB1cGRhdGUgPSBjb25kaXRpb25zO1xuICAgIGNvbmRpdGlvbnMgPSBudWxsO1xuICAgIG9wdGlvbnMgPSBudWxsO1xuICB9XG5cbiAgbGV0IGZpZWxkcztcbiAgaWYgKG9wdGlvbnMpIHtcbiAgICBmaWVsZHMgPSBvcHRpb25zLmZpZWxkcyB8fCBvcHRpb25zLnByb2plY3Rpb247XG4gIH1cblxuICB1cGRhdGUgPSBjbG9uZSh1cGRhdGUsIHtcbiAgICBkZXBvcHVsYXRlOiB0cnVlLFxuICAgIF9pc05lc3RlZDogdHJ1ZVxuICB9KTtcblxuICBkZWNvcmF0ZVVwZGF0ZVdpdGhWZXJzaW9uS2V5KHVwZGF0ZSwgb3B0aW9ucywgdGhpcy5zY2hlbWEub3B0aW9ucy52ZXJzaW9uS2V5KTtcblxuICBjb25zdCBtcSA9IG5ldyB0aGlzLlF1ZXJ5KHt9LCB7fSwgdGhpcywgdGhpcy4kX19jb2xsZWN0aW9uKTtcbiAgbXEuc2VsZWN0KGZpZWxkcyk7XG5cbiAgcmV0dXJuIG1xLmZpbmRPbmVBbmRVcGRhdGUoY29uZGl0aW9ucywgdXBkYXRlLCBvcHRpb25zKTtcbn07XG5cbi8qKlxuICogSXNzdWVzIGEgbW9uZ29kYiBmaW5kT25lQW5kVXBkYXRlIGNvbW1hbmQgYnkgYSBkb2N1bWVudCdzIF9pZCBmaWVsZC5cbiAqIGBmaW5kQnlJZEFuZFVwZGF0ZShpZCwgLi4uKWAgaXMgZXF1aXZhbGVudCB0byBgZmluZE9uZUFuZFVwZGF0ZSh7IF9pZDogaWQgfSwgLi4uKWAuXG4gKlxuICogRmluZHMgYSBtYXRjaGluZyBkb2N1bWVudCwgdXBkYXRlcyBpdCBhY2NvcmRpbmcgdG8gdGhlIGB1cGRhdGVgIGFyZyxcbiAqIHBhc3NpbmcgYW55IGBvcHRpb25zYCwgYW5kIHJldHVybnMgdGhlIGZvdW5kIGRvY3VtZW50IChpZiBhbnkpLlxuICpcbiAqIFRoaXMgZnVuY3Rpb24gdHJpZ2dlcnMgdGhlIGZvbGxvd2luZyBtaWRkbGV3YXJlLlxuICpcbiAqIC0gYGZpbmRPbmVBbmRVcGRhdGUoKWBcbiAqXG4gKiAjIyMjIEV4YW1wbGU6XG4gKlxuICogICAgIEEuZmluZEJ5SWRBbmRVcGRhdGUoaWQsIHVwZGF0ZSwgb3B0aW9ucykgIC8vIHJldHVybnMgUXVlcnlcbiAqICAgICBBLmZpbmRCeUlkQW5kVXBkYXRlKGlkLCB1cGRhdGUpICAgICAgICAgICAvLyByZXR1cm5zIFF1ZXJ5XG4gKiAgICAgQS5maW5kQnlJZEFuZFVwZGF0ZSgpICAgICAgICAgICAgICAgICAgICAgLy8gcmV0dXJucyBRdWVyeVxuICpcbiAqICMjIyMgTm90ZTpcbiAqXG4gKiBBbGwgdG9wIGxldmVsIHVwZGF0ZSBrZXlzIHdoaWNoIGFyZSBub3QgYGF0b21pY2Agb3BlcmF0aW9uIG5hbWVzIGFyZSB0cmVhdGVkIGFzIHNldCBvcGVyYXRpb25zOlxuICpcbiAqICMjIyMgRXhhbXBsZTpcbiAqXG4gKiAgICAgTW9kZWwuZmluZEJ5SWRBbmRVcGRhdGUoaWQsIHsgbmFtZTogJ2phc29uIGJvdXJuZScgfSwgb3B0aW9ucylcbiAqXG4gKiAgICAgLy8gaXMgc2VudCBhc1xuICogICAgIE1vZGVsLmZpbmRCeUlkQW5kVXBkYXRlKGlkLCB7ICRzZXQ6IHsgbmFtZTogJ2phc29uIGJvdXJuZScgfX0sIG9wdGlvbnMpXG4gKlxuICogIyMjIyBOb3RlOlxuICpcbiAqIGBmaW5kT25lQW5kWGAgYW5kIGBmaW5kQnlJZEFuZFhgIGZ1bmN0aW9ucyBzdXBwb3J0IGxpbWl0ZWQgdmFsaWRhdGlvbi4gWW91IGNhblxuICogZW5hYmxlIHZhbGlkYXRpb24gYnkgc2V0dGluZyB0aGUgYHJ1blZhbGlkYXRvcnNgIG9wdGlvbi5cbiAqXG4gKiBJZiB5b3UgbmVlZCBmdWxsLWZsZWRnZWQgdmFsaWRhdGlvbiwgdXNlIHRoZSB0cmFkaXRpb25hbCBhcHByb2FjaCBvZiBmaXJzdFxuICogcmV0cmlldmluZyB0aGUgZG9jdW1lbnQuXG4gKlxuICogICAgIGNvbnN0IGRvYyA9IGF3YWl0IE1vZGVsLmZpbmRCeUlkKGlkKVxuICogICAgIGRvYy5uYW1lID0gJ2phc29uIGJvdXJuZSc7XG4gKiAgICAgYXdhaXQgZG9jLnNhdmUoKTtcbiAqXG4gKiBAcGFyYW0ge09iamVjdHxOdW1iZXJ8U3RyaW5nfSBpZCB2YWx1ZSBvZiBgX2lkYCB0byBxdWVyeSBieVxuICogQHBhcmFtIHtPYmplY3R9IFt1cGRhdGVdXG4gKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdIG9wdGlvbmFsIHNlZSBbYFF1ZXJ5LnByb3RvdHlwZS5zZXRPcHRpb25zKClgXShodHRwczovL21vbmdvb3NlanMuY29tL2RvY3MvYXBpL3F1ZXJ5Lmh0bWwjUXVlcnkucHJvdG90eXBlLnNldE9wdGlvbnMoKSlcbiAqIEBwYXJhbSB7U3RyaW5nfSBbb3B0aW9ucy5yZXR1cm5Eb2N1bWVudD0nYmVmb3JlJ10gSGFzIHR3byBwb3NzaWJsZSB2YWx1ZXMsIGAnYmVmb3JlJ2AgYW5kIGAnYWZ0ZXInYC4gQnkgZGVmYXVsdCwgaXQgd2lsbCByZXR1cm4gdGhlIGRvY3VtZW50IGJlZm9yZSB0aGUgdXBkYXRlIHdhcyBhcHBsaWVkLlxuICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zLmxlYW5dIGlmIHRydXRoeSwgbW9uZ29vc2Ugd2lsbCByZXR1cm4gdGhlIGRvY3VtZW50IGFzIGEgcGxhaW4gSmF2YVNjcmlwdCBvYmplY3QgcmF0aGVyIHRoYW4gYSBtb25nb29zZSBkb2N1bWVudC4gU2VlIFtgUXVlcnkubGVhbigpYF0oaHR0cHM6Ly9tb25nb29zZWpzLmNvbS9kb2NzL2FwaS9xdWVyeS5odG1sI1F1ZXJ5LnByb3RvdHlwZS5sZWFuKCkpIGFuZCBbdGhlIE1vbmdvb3NlIGxlYW4gdHV0b3JpYWxdKGh0dHBzOi8vbW9uZ29vc2Vqcy5jb20vZG9jcy90dXRvcmlhbHMvbGVhbi5odG1sKS5cbiAqIEBwYXJhbSB7Q2xpZW50U2Vzc2lvbn0gW29wdGlvbnMuc2Vzc2lvbj1udWxsXSBUaGUgc2Vzc2lvbiBhc3NvY2lhdGVkIHdpdGggdGhpcyBxdWVyeS4gU2VlIFt0cmFuc2FjdGlvbnMgZG9jc10oaHR0cHM6Ly9tb25nb29zZWpzLmNvbS9kb2NzL3RyYW5zYWN0aW9ucy5odG1sKS5cbiAqIEBwYXJhbSB7Qm9vbGVhbnxTdHJpbmd9IFtvcHRpb25zLnN0cmljdF0gb3ZlcndyaXRlcyB0aGUgc2NoZW1hJ3MgW3N0cmljdCBtb2RlIG9wdGlvbl0oaHR0cHM6Ly9tb25nb29zZWpzLmNvbS9kb2NzL2d1aWRlLmh0bWwjc3RyaWN0KVxuICogQHBhcmFtIHtCb29sZWFufSBbb3B0aW9ucy50aW1lc3RhbXBzPW51bGxdIElmIHNldCB0byBgZmFsc2VgIGFuZCBbc2NoZW1hLWxldmVsIHRpbWVzdGFtcHNdKGh0dHBzOi8vbW9uZ29vc2Vqcy5jb20vZG9jcy9ndWlkZS5odG1sI3RpbWVzdGFtcHMpIGFyZSBlbmFibGVkLCBza2lwIHRpbWVzdGFtcHMgZm9yIHRoaXMgdXBkYXRlLiBOb3RlIHRoYXQgdGhpcyBhbGxvd3MgeW91IHRvIG92ZXJ3cml0ZSB0aW1lc3RhbXBzLiBEb2VzIG5vdGhpbmcgaWYgc2NoZW1hLWxldmVsIHRpbWVzdGFtcHMgYXJlIG5vdCBzZXQuXG4gKiBAcGFyYW0ge09iamVjdHxTdHJpbmd9IFtvcHRpb25zLnNvcnRdIGlmIG11bHRpcGxlIGRvY3MgYXJlIGZvdW5kIGJ5IHRoZSBjb25kaXRpb25zLCBzZXRzIHRoZSBzb3J0IG9yZGVyIHRvIGNob29zZSB3aGljaCBkb2MgdG8gdXBkYXRlLlxuICogQHBhcmFtIHtCb29sZWFufSBbb3B0aW9ucy5ydW5WYWxpZGF0b3JzXSBpZiB0cnVlLCBydW5zIFt1cGRhdGUgdmFsaWRhdG9yc10oaHR0cHM6Ly9tb25nb29zZWpzLmNvbS9kb2NzL3ZhbGlkYXRpb24uaHRtbCN1cGRhdGUtdmFsaWRhdG9ycykgb24gdGhpcyBjb21tYW5kLiBVcGRhdGUgdmFsaWRhdG9ycyB2YWxpZGF0ZSB0aGUgdXBkYXRlIG9wZXJhdGlvbiBhZ2FpbnN0IHRoZSBtb2RlbCdzIHNjaGVtYVxuICogQHBhcmFtIHtCb29sZWFufSBbb3B0aW9ucy5zZXREZWZhdWx0c09uSW5zZXJ0PXRydWVdIElmIGBzZXREZWZhdWx0c09uSW5zZXJ0YCBhbmQgYHVwc2VydGAgYXJlIHRydWUsIG1vbmdvb3NlIHdpbGwgYXBwbHkgdGhlIFtkZWZhdWx0c10oaHR0cHM6Ly9tb25nb29zZWpzLmNvbS9kb2NzL2RlZmF1bHRzLmh0bWwpIHNwZWNpZmllZCBpbiB0aGUgbW9kZWwncyBzY2hlbWEgaWYgYSBuZXcgZG9jdW1lbnQgaXMgY3JlYXRlZFxuICogQHBhcmFtIHtCb29sZWFufSBbb3B0aW9ucy5pbmNsdWRlUmVzdWx0TWV0YWRhdGFdIGlmIHRydWUsIHJldHVybnMgdGhlIGZ1bGwgW01vZGlmeVJlc3VsdCBmcm9tIHRoZSBNb25nb0RCIGRyaXZlcl0oaHR0cHM6Ly9tb25nb2RiLmdpdGh1Yi5pby9ub2RlLW1vbmdvZGItbmF0aXZlLzQuOS9pbnRlcmZhY2VzL01vZGlmeVJlc3VsdC5odG1sKSByYXRoZXIgdGhhbiBqdXN0IHRoZSBkb2N1bWVudFxuICogQHBhcmFtIHtCb29sZWFufSBbb3B0aW9ucy51cHNlcnQ9ZmFsc2VdIGlmIHRydWUsIGFuZCBubyBkb2N1bWVudHMgZm91bmQsIGluc2VydCBhIG5ldyBkb2N1bWVudFxuICogQHBhcmFtIHtCb29sZWFufSBbb3B0aW9ucy5uZXc9ZmFsc2VdIGlmIHRydWUsIHJldHVybiB0aGUgbW9kaWZpZWQgZG9jdW1lbnQgcmF0aGVyIHRoYW4gdGhlIG9yaWdpbmFsXG4gKiBAcGFyYW0ge09iamVjdHxTdHJpbmd9IFtvcHRpb25zLnNlbGVjdF0gc2V0cyB0aGUgZG9jdW1lbnQgZmllbGRzIHRvIHJldHVybi5cbiAqIEBwYXJhbSB7Qm9vbGVhbn0gW29wdGlvbnMudHJhbnNsYXRlQWxpYXNlcz1udWxsXSBJZiBzZXQgdG8gYHRydWVgLCB0cmFuc2xhdGVzIGFueSBzY2hlbWEtZGVmaW5lZCBhbGlhc2VzIGluIGBmaWx0ZXJgLCBgcHJvamVjdGlvbmAsIGB1cGRhdGVgLCBhbmQgYGRpc3RpbmN0YC4gVGhyb3dzIGFuIGVycm9yIGlmIHRoZXJlIGFyZSBhbnkgY29uZmxpY3RzIHdoZXJlIGJvdGggYWxpYXMgYW5kIHJhdyBwcm9wZXJ0eSBhcmUgZGVmaW5lZCBvbiB0aGUgc2FtZSBvYmplY3QuXG4gKiBAcmV0dXJuIHtRdWVyeX1cbiAqIEBzZWUgTW9kZWwuZmluZE9uZUFuZFVwZGF0ZSBodHRwczovL21vbmdvb3NlanMuY29tL2RvY3MvYXBpL21vZGVsLmh0bWwjTW9kZWwuZmluZE9uZUFuZFVwZGF0ZSgpXG4gKiBAc2VlIG1vbmdvZGIgaHR0cHM6Ly93d3cubW9uZ29kYi5jb20vZG9jcy9tYW51YWwvcmVmZXJlbmNlL2NvbW1hbmQvZmluZEFuZE1vZGlmeS9cbiAqIEBhcGkgcHVibGljXG4gKi9cblxuTW9kZWwuZmluZEJ5SWRBbmRVcGRhdGUgPSBmdW5jdGlvbihpZCwgdXBkYXRlLCBvcHRpb25zKSB7XG4gIF9jaGVja0NvbnRleHQodGhpcywgJ2ZpbmRCeUlkQW5kVXBkYXRlJyk7XG4gIGlmICh0eXBlb2YgYXJndW1lbnRzWzBdID09PSAnZnVuY3Rpb24nIHx8IHR5cGVvZiBhcmd1bWVudHNbMV0gPT09ICdmdW5jdGlvbicgfHwgdHlwZW9mIGFyZ3VtZW50c1syXSA9PT0gJ2Z1bmN0aW9uJyB8fCB0eXBlb2YgYXJndW1lbnRzWzNdID09PSAnZnVuY3Rpb24nKSB7XG4gICAgdGhyb3cgbmV3IE1vbmdvb3NlRXJyb3IoJ01vZGVsLmZpbmRCeUlkQW5kVXBkYXRlKCkgbm8gbG9uZ2VyIGFjY2VwdHMgYSBjYWxsYmFjaycpO1xuICB9XG5cbiAgLy8gaWYgYSBtb2RlbCBpcyBwYXNzZWQgaW4gaW5zdGVhZCBvZiBhbiBpZFxuICBpZiAoaWQgaW5zdGFuY2VvZiBEb2N1bWVudCkge1xuICAgIGlkID0gaWQuX2lkO1xuICB9XG5cbiAgcmV0dXJuIHRoaXMuZmluZE9uZUFuZFVwZGF0ZS5jYWxsKHRoaXMsIHsgX2lkOiBpZCB9LCB1cGRhdGUsIG9wdGlvbnMpO1xufTtcblxuLyoqXG4gKiBJc3N1ZSBhIE1vbmdvREIgYGZpbmRPbmVBbmREZWxldGUoKWAgY29tbWFuZC5cbiAqXG4gKiBGaW5kcyBhIG1hdGNoaW5nIGRvY3VtZW50LCByZW1vdmVzIGl0LCBhbmQgcmV0dXJucyB0aGUgZm91bmQgZG9jdW1lbnQgKGlmIGFueSkuXG4gKlxuICogVGhpcyBmdW5jdGlvbiB0cmlnZ2VycyB0aGUgZm9sbG93aW5nIG1pZGRsZXdhcmUuXG4gKlxuICogLSBgZmluZE9uZUFuZERlbGV0ZSgpYFxuICpcbiAqICMjIyMgRXhhbXBsZTpcbiAqXG4gKiAgICAgQS5maW5kT25lQW5kRGVsZXRlKGNvbmRpdGlvbnMsIG9wdGlvbnMpICAvLyByZXR1cm4gUXVlcnlcbiAqICAgICBBLmZpbmRPbmVBbmREZWxldGUoY29uZGl0aW9ucykgLy8gcmV0dXJucyBRdWVyeVxuICogICAgIEEuZmluZE9uZUFuZERlbGV0ZSgpICAgICAgICAgICAvLyByZXR1cm5zIFF1ZXJ5XG4gKlxuICogYGZpbmRPbmVBbmRYYCBhbmQgYGZpbmRCeUlkQW5kWGAgZnVuY3Rpb25zIHN1cHBvcnQgbGltaXRlZCB2YWxpZGF0aW9uLiBZb3UgY2FuXG4gKiBlbmFibGUgdmFsaWRhdGlvbiBieSBzZXR0aW5nIHRoZSBgcnVuVmFsaWRhdG9yc2Agb3B0aW9uLlxuICpcbiAqIElmIHlvdSBuZWVkIGZ1bGwtZmxlZGdlZCB2YWxpZGF0aW9uLCB1c2UgdGhlIHRyYWRpdGlvbmFsIGFwcHJvYWNoIG9mIGZpcnN0XG4gKiByZXRyaWV2aW5nIHRoZSBkb2N1bWVudC5cbiAqXG4gKiAgICAgY29uc3QgZG9jID0gYXdhaXQgTW9kZWwuZmluZEJ5SWQoaWQpXG4gKiAgICAgZG9jLm5hbWUgPSAnamFzb24gYm91cm5lJztcbiAqICAgICBhd2FpdCBkb2Muc2F2ZSgpO1xuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBjb25kaXRpb25zXG4gKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdIG9wdGlvbmFsIHNlZSBbYFF1ZXJ5LnByb3RvdHlwZS5zZXRPcHRpb25zKClgXShodHRwczovL21vbmdvb3NlanMuY29tL2RvY3MvYXBpL3F1ZXJ5Lmh0bWwjUXVlcnkucHJvdG90eXBlLnNldE9wdGlvbnMoKSlcbiAqIEBwYXJhbSB7Qm9vbGVhbnxTdHJpbmd9IFtvcHRpb25zLnN0cmljdF0gb3ZlcndyaXRlcyB0aGUgc2NoZW1hJ3MgW3N0cmljdCBtb2RlIG9wdGlvbl0oaHR0cHM6Ly9tb25nb29zZWpzLmNvbS9kb2NzL2d1aWRlLmh0bWwjc3RyaWN0KVxuICogQHBhcmFtIHtPYmplY3R8U3RyaW5nfFN0cmluZ1tdfSBbb3B0aW9ucy5wcm9qZWN0aW9uPW51bGxdIG9wdGlvbmFsIGZpZWxkcyB0byByZXR1cm4sIHNlZSBbYFF1ZXJ5LnByb3RvdHlwZS5zZWxlY3QoKWBdKGh0dHBzOi8vbW9uZ29vc2Vqcy5jb20vZG9jcy9hcGkvcXVlcnkuaHRtbCNRdWVyeS5wcm90b3R5cGUuc2VsZWN0KCkpXG4gKiBAcGFyYW0ge0NsaWVudFNlc3Npb259IFtvcHRpb25zLnNlc3Npb249bnVsbF0gVGhlIHNlc3Npb24gYXNzb2NpYXRlZCB3aXRoIHRoaXMgcXVlcnkuIFNlZSBbdHJhbnNhY3Rpb25zIGRvY3NdKGh0dHBzOi8vbW9uZ29vc2Vqcy5jb20vZG9jcy90cmFuc2FjdGlvbnMuaHRtbCkuXG4gKiBAcGFyYW0ge0Jvb2xlYW59IFtvcHRpb25zLmluY2x1ZGVSZXN1bHRNZXRhZGF0YV0gaWYgdHJ1ZSwgcmV0dXJucyB0aGUgZnVsbCBbTW9kaWZ5UmVzdWx0IGZyb20gdGhlIE1vbmdvREIgZHJpdmVyXShodHRwczovL21vbmdvZGIuZ2l0aHViLmlvL25vZGUtbW9uZ29kYi1uYXRpdmUvNC45L2ludGVyZmFjZXMvTW9kaWZ5UmVzdWx0Lmh0bWwpIHJhdGhlciB0aGFuIGp1c3QgdGhlIGRvY3VtZW50XG4gKiBAcGFyYW0ge09iamVjdHxTdHJpbmd9IFtvcHRpb25zLnNvcnRdIGlmIG11bHRpcGxlIGRvY3MgYXJlIGZvdW5kIGJ5IHRoZSBjb25kaXRpb25zLCBzZXRzIHRoZSBzb3J0IG9yZGVyIHRvIGNob29zZSB3aGljaCBkb2MgdG8gdXBkYXRlLlxuICogQHBhcmFtIHtPYmplY3R8U3RyaW5nfSBbb3B0aW9ucy5zZWxlY3RdIHNldHMgdGhlIGRvY3VtZW50IGZpZWxkcyB0byByZXR1cm4uXG4gKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMubWF4VGltZU1TXSBwdXRzIGEgdGltZSBsaW1pdCBvbiB0aGUgcXVlcnkgLSByZXF1aXJlcyBtb25nb2RiID49IDIuNi4wXG4gKiBAcGFyYW0ge0Jvb2xlYW59IFtvcHRpb25zLnRyYW5zbGF0ZUFsaWFzZXM9bnVsbF0gSWYgc2V0IHRvIGB0cnVlYCwgdHJhbnNsYXRlcyBhbnkgc2NoZW1hLWRlZmluZWQgYWxpYXNlcyBpbiBgZmlsdGVyYCwgYHByb2plY3Rpb25gLCBgdXBkYXRlYCwgYW5kIGBkaXN0aW5jdGAuIFRocm93cyBhbiBlcnJvciBpZiB0aGVyZSBhcmUgYW55IGNvbmZsaWN0cyB3aGVyZSBib3RoIGFsaWFzIGFuZCByYXcgcHJvcGVydHkgYXJlIGRlZmluZWQgb24gdGhlIHNhbWUgb2JqZWN0LlxuICogQHJldHVybiB7UXVlcnl9XG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbk1vZGVsLmZpbmRPbmVBbmREZWxldGUgPSBmdW5jdGlvbihjb25kaXRpb25zLCBvcHRpb25zKSB7XG4gIF9jaGVja0NvbnRleHQodGhpcywgJ2ZpbmRPbmVBbmREZWxldGUnKTtcblxuICBpZiAodHlwZW9mIGFyZ3VtZW50c1swXSA9PT0gJ2Z1bmN0aW9uJyB8fCB0eXBlb2YgYXJndW1lbnRzWzFdID09PSAnZnVuY3Rpb24nIHx8IHR5cGVvZiBhcmd1bWVudHNbMl0gPT09ICdmdW5jdGlvbicpIHtcbiAgICB0aHJvdyBuZXcgTW9uZ29vc2VFcnJvcignTW9kZWwuZmluZE9uZUFuZERlbGV0ZSgpIG5vIGxvbmdlciBhY2NlcHRzIGEgY2FsbGJhY2snKTtcbiAgfVxuXG4gIGxldCBmaWVsZHM7XG4gIGlmIChvcHRpb25zKSB7XG4gICAgZmllbGRzID0gb3B0aW9ucy5zZWxlY3Q7XG4gICAgb3B0aW9ucy5zZWxlY3QgPSB1bmRlZmluZWQ7XG4gIH1cblxuICBjb25zdCBtcSA9IG5ldyB0aGlzLlF1ZXJ5KHt9LCB7fSwgdGhpcywgdGhpcy4kX19jb2xsZWN0aW9uKTtcbiAgbXEuc2VsZWN0KGZpZWxkcyk7XG5cbiAgcmV0dXJuIG1xLmZpbmRPbmVBbmREZWxldGUoY29uZGl0aW9ucywgb3B0aW9ucyk7XG59O1xuXG4vKipcbiAqIElzc3VlIGEgTW9uZ29EQiBgZmluZE9uZUFuZERlbGV0ZSgpYCBjb21tYW5kIGJ5IGEgZG9jdW1lbnQncyBfaWQgZmllbGQuXG4gKiBJbiBvdGhlciB3b3JkcywgYGZpbmRCeUlkQW5kRGVsZXRlKGlkKWAgaXMgYSBzaG9ydGhhbmQgZm9yXG4gKiBgZmluZE9uZUFuZERlbGV0ZSh7IF9pZDogaWQgfSlgLlxuICpcbiAqIFRoaXMgZnVuY3Rpb24gdHJpZ2dlcnMgdGhlIGZvbGxvd2luZyBtaWRkbGV3YXJlLlxuICpcbiAqIC0gYGZpbmRPbmVBbmREZWxldGUoKWBcbiAqXG4gKiBAcGFyYW0ge09iamVjdHxOdW1iZXJ8U3RyaW5nfSBpZCB2YWx1ZSBvZiBgX2lkYCB0byBxdWVyeSBieVxuICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSBvcHRpb25hbCBzZWUgW2BRdWVyeS5wcm90b3R5cGUuc2V0T3B0aW9ucygpYF0oaHR0cHM6Ly9tb25nb29zZWpzLmNvbS9kb2NzL2FwaS9xdWVyeS5odG1sI1F1ZXJ5LnByb3RvdHlwZS5zZXRPcHRpb25zKCkpXG4gKiBAcGFyYW0ge0Jvb2xlYW58U3RyaW5nfSBbb3B0aW9ucy5zdHJpY3RdIG92ZXJ3cml0ZXMgdGhlIHNjaGVtYSdzIFtzdHJpY3QgbW9kZSBvcHRpb25dKGh0dHBzOi8vbW9uZ29vc2Vqcy5jb20vZG9jcy9ndWlkZS5odG1sI3N0cmljdClcbiAqIEBwYXJhbSB7Qm9vbGVhbn0gW29wdGlvbnMudHJhbnNsYXRlQWxpYXNlcz1udWxsXSBJZiBzZXQgdG8gYHRydWVgLCB0cmFuc2xhdGVzIGFueSBzY2hlbWEtZGVmaW5lZCBhbGlhc2VzIGluIGBmaWx0ZXJgLCBgcHJvamVjdGlvbmAsIGB1cGRhdGVgLCBhbmQgYGRpc3RpbmN0YC4gVGhyb3dzIGFuIGVycm9yIGlmIHRoZXJlIGFyZSBhbnkgY29uZmxpY3RzIHdoZXJlIGJvdGggYWxpYXMgYW5kIHJhdyBwcm9wZXJ0eSBhcmUgZGVmaW5lZCBvbiB0aGUgc2FtZSBvYmplY3QuXG4gKiBAcmV0dXJuIHtRdWVyeX1cbiAqIEBzZWUgTW9kZWwuZmluZE9uZUFuZERlbGV0ZSBodHRwczovL21vbmdvb3NlanMuY29tL2RvY3MvYXBpL21vZGVsLmh0bWwjTW9kZWwuZmluZE9uZUFuZERlbGV0ZSgpXG4gKiBAc2VlIG1vbmdvZGIgaHR0cHM6Ly93d3cubW9uZ29kYi5jb20vZG9jcy9tYW51YWwvcmVmZXJlbmNlL2NvbW1hbmQvZmluZEFuZE1vZGlmeS9cbiAqL1xuXG5Nb2RlbC5maW5kQnlJZEFuZERlbGV0ZSA9IGZ1bmN0aW9uKGlkLCBvcHRpb25zKSB7XG4gIF9jaGVja0NvbnRleHQodGhpcywgJ2ZpbmRCeUlkQW5kRGVsZXRlJyk7XG5cbiAgaWYgKHR5cGVvZiBhcmd1bWVudHNbMF0gPT09ICdmdW5jdGlvbicgfHwgdHlwZW9mIGFyZ3VtZW50c1sxXSA9PT0gJ2Z1bmN0aW9uJyB8fCB0eXBlb2YgYXJndW1lbnRzWzJdID09PSAnZnVuY3Rpb24nKSB7XG4gICAgdGhyb3cgbmV3IE1vbmdvb3NlRXJyb3IoJ01vZGVsLmZpbmRCeUlkQW5kRGVsZXRlKCkgbm8gbG9uZ2VyIGFjY2VwdHMgYSBjYWxsYmFjaycpO1xuICB9XG5cbiAgcmV0dXJuIHRoaXMuZmluZE9uZUFuZERlbGV0ZSh7IF9pZDogaWQgfSwgb3B0aW9ucyk7XG59O1xuXG4vKipcbiAqIElzc3VlIGEgTW9uZ29EQiBgZmluZE9uZUFuZFJlcGxhY2UoKWAgY29tbWFuZC5cbiAqXG4gKiBGaW5kcyBhIG1hdGNoaW5nIGRvY3VtZW50LCByZXBsYWNlcyBpdCB3aXRoIHRoZSBwcm92aWRlZCBkb2MsIGFuZCByZXR1cm5zIHRoZSBkb2N1bWVudC5cbiAqXG4gKiBUaGlzIGZ1bmN0aW9uIHRyaWdnZXJzIHRoZSBmb2xsb3dpbmcgcXVlcnkgbWlkZGxld2FyZS5cbiAqXG4gKiAtIGBmaW5kT25lQW5kUmVwbGFjZSgpYFxuICpcbiAqICMjIyMgRXhhbXBsZTpcbiAqXG4gKiAgICAgQS5maW5kT25lQW5kUmVwbGFjZShmaWx0ZXIsIHJlcGxhY2VtZW50LCBvcHRpb25zKSAgLy8gcmV0dXJuIFF1ZXJ5XG4gKiAgICAgQS5maW5kT25lQW5kUmVwbGFjZShmaWx0ZXIsIHJlcGxhY2VtZW50KSAvLyByZXR1cm5zIFF1ZXJ5XG4gKiAgICAgQS5maW5kT25lQW5kUmVwbGFjZSgpICAgICAgICAgICAgICAgICAgICAvLyByZXR1cm5zIFF1ZXJ5XG4gKlxuICogQHBhcmFtIHtPYmplY3R9IGZpbHRlciBSZXBsYWNlIHRoZSBmaXJzdCBkb2N1bWVudCB0aGF0IG1hdGNoZXMgdGhpcyBmaWx0ZXJcbiAqIEBwYXJhbSB7T2JqZWN0fSBbcmVwbGFjZW1lbnRdIFJlcGxhY2Ugd2l0aCB0aGlzIGRvY3VtZW50XG4gKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdIG9wdGlvbmFsIHNlZSBbYFF1ZXJ5LnByb3RvdHlwZS5zZXRPcHRpb25zKClgXShodHRwczovL21vbmdvb3NlanMuY29tL2RvY3MvYXBpL3F1ZXJ5Lmh0bWwjUXVlcnkucHJvdG90eXBlLnNldE9wdGlvbnMoKSlcbiAqIEBwYXJhbSB7U3RyaW5nfSBbb3B0aW9ucy5yZXR1cm5Eb2N1bWVudD0nYmVmb3JlJ10gSGFzIHR3byBwb3NzaWJsZSB2YWx1ZXMsIGAnYmVmb3JlJ2AgYW5kIGAnYWZ0ZXInYC4gQnkgZGVmYXVsdCwgaXQgd2lsbCByZXR1cm4gdGhlIGRvY3VtZW50IGJlZm9yZSB0aGUgdXBkYXRlIHdhcyBhcHBsaWVkLlxuICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zLmxlYW5dIGlmIHRydXRoeSwgbW9uZ29vc2Ugd2lsbCByZXR1cm4gdGhlIGRvY3VtZW50IGFzIGEgcGxhaW4gSmF2YVNjcmlwdCBvYmplY3QgcmF0aGVyIHRoYW4gYSBtb25nb29zZSBkb2N1bWVudC4gU2VlIFtgUXVlcnkubGVhbigpYF0oaHR0cHM6Ly9tb25nb29zZWpzLmNvbS9kb2NzL2FwaS9xdWVyeS5odG1sI1F1ZXJ5LnByb3RvdHlwZS5sZWFuKCkpIGFuZCBbdGhlIE1vbmdvb3NlIGxlYW4gdHV0b3JpYWxdKGh0dHBzOi8vbW9uZ29vc2Vqcy5jb20vZG9jcy90dXRvcmlhbHMvbGVhbi5odG1sKS5cbiAqIEBwYXJhbSB7Q2xpZW50U2Vzc2lvbn0gW29wdGlvbnMuc2Vzc2lvbj1udWxsXSBUaGUgc2Vzc2lvbiBhc3NvY2lhdGVkIHdpdGggdGhpcyBxdWVyeS4gU2VlIFt0cmFuc2FjdGlvbnMgZG9jc10oaHR0cHM6Ly9tb25nb29zZWpzLmNvbS9kb2NzL3RyYW5zYWN0aW9ucy5odG1sKS5cbiAqIEBwYXJhbSB7Qm9vbGVhbnxTdHJpbmd9IFtvcHRpb25zLnN0cmljdF0gb3ZlcndyaXRlcyB0aGUgc2NoZW1hJ3MgW3N0cmljdCBtb2RlIG9wdGlvbl0oaHR0cHM6Ly9tb25nb29zZWpzLmNvbS9kb2NzL2d1aWRlLmh0bWwjc3RyaWN0KVxuICogQHBhcmFtIHtCb29sZWFufSBbb3B0aW9ucy50aW1lc3RhbXBzPW51bGxdIElmIHNldCB0byBgZmFsc2VgIGFuZCBbc2NoZW1hLWxldmVsIHRpbWVzdGFtcHNdKGh0dHBzOi8vbW9uZ29vc2Vqcy5jb20vZG9jcy9ndWlkZS5odG1sI3RpbWVzdGFtcHMpIGFyZSBlbmFibGVkLCBza2lwIHRpbWVzdGFtcHMgZm9yIHRoaXMgdXBkYXRlLiBOb3RlIHRoYXQgdGhpcyBhbGxvd3MgeW91IHRvIG92ZXJ3cml0ZSB0aW1lc3RhbXBzLiBEb2VzIG5vdGhpbmcgaWYgc2NoZW1hLWxldmVsIHRpbWVzdGFtcHMgYXJlIG5vdCBzZXQuXG4gKiBAcGFyYW0ge09iamVjdHxTdHJpbmd8U3RyaW5nW119IFtvcHRpb25zLnByb2plY3Rpb249bnVsbF0gb3B0aW9uYWwgZmllbGRzIHRvIHJldHVybiwgc2VlIFtgUXVlcnkucHJvdG90eXBlLnNlbGVjdCgpYF0oaHR0cHM6Ly9tb25nb29zZWpzLmNvbS9kb2NzL2FwaS9xdWVyeS5odG1sI1F1ZXJ5LnByb3RvdHlwZS5zZWxlY3QoKSlcbiAqIEBwYXJhbSB7T2JqZWN0fFN0cmluZ30gW29wdGlvbnMuc29ydF0gaWYgbXVsdGlwbGUgZG9jcyBhcmUgZm91bmQgYnkgdGhlIGNvbmRpdGlvbnMsIHNldHMgdGhlIHNvcnQgb3JkZXIgdG8gY2hvb3NlIHdoaWNoIGRvYyB0byB1cGRhdGUuXG4gKiBAcGFyYW0ge0Jvb2xlYW59IFtvcHRpb25zLmluY2x1ZGVSZXN1bHRNZXRhZGF0YV0gaWYgdHJ1ZSwgcmV0dXJucyB0aGUgZnVsbCBbTW9kaWZ5UmVzdWx0IGZyb20gdGhlIE1vbmdvREIgZHJpdmVyXShodHRwczovL21vbmdvZGIuZ2l0aHViLmlvL25vZGUtbW9uZ29kYi1uYXRpdmUvNC45L2ludGVyZmFjZXMvTW9kaWZ5UmVzdWx0Lmh0bWwpIHJhdGhlciB0aGFuIGp1c3QgdGhlIGRvY3VtZW50XG4gKiBAcGFyYW0ge09iamVjdHxTdHJpbmd9IFtvcHRpb25zLnNlbGVjdF0gc2V0cyB0aGUgZG9jdW1lbnQgZmllbGRzIHRvIHJldHVybi5cbiAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy5tYXhUaW1lTVNdIHB1dHMgYSB0aW1lIGxpbWl0IG9uIHRoZSBxdWVyeSAtIHJlcXVpcmVzIG1vbmdvZGIgPj0gMi42LjBcbiAqIEBwYXJhbSB7Qm9vbGVhbn0gW29wdGlvbnMudHJhbnNsYXRlQWxpYXNlcz1udWxsXSBJZiBzZXQgdG8gYHRydWVgLCB0cmFuc2xhdGVzIGFueSBzY2hlbWEtZGVmaW5lZCBhbGlhc2VzIGluIGBmaWx0ZXJgLCBgcHJvamVjdGlvbmAsIGB1cGRhdGVgLCBhbmQgYGRpc3RpbmN0YC4gVGhyb3dzIGFuIGVycm9yIGlmIHRoZXJlIGFyZSBhbnkgY29uZmxpY3RzIHdoZXJlIGJvdGggYWxpYXMgYW5kIHJhdyBwcm9wZXJ0eSBhcmUgZGVmaW5lZCBvbiB0aGUgc2FtZSBvYmplY3QuXG4gKiBAcmV0dXJuIHtRdWVyeX1cbiAqIEBhcGkgcHVibGljXG4gKi9cblxuTW9kZWwuZmluZE9uZUFuZFJlcGxhY2UgPSBmdW5jdGlvbihmaWx0ZXIsIHJlcGxhY2VtZW50LCBvcHRpb25zKSB7XG4gIF9jaGVja0NvbnRleHQodGhpcywgJ2ZpbmRPbmVBbmRSZXBsYWNlJyk7XG5cbiAgaWYgKHR5cGVvZiBhcmd1bWVudHNbMF0gPT09ICdmdW5jdGlvbicgfHwgdHlwZW9mIGFyZ3VtZW50c1sxXSA9PT0gJ2Z1bmN0aW9uJyB8fCB0eXBlb2YgYXJndW1lbnRzWzJdID09PSAnZnVuY3Rpb24nIHx8IHR5cGVvZiBhcmd1bWVudHNbM10gPT09ICdmdW5jdGlvbicpIHtcbiAgICB0aHJvdyBuZXcgTW9uZ29vc2VFcnJvcignTW9kZWwuZmluZE9uZUFuZFJlcGxhY2UoKSBubyBsb25nZXIgYWNjZXB0cyBhIGNhbGxiYWNrJyk7XG4gIH1cblxuICBsZXQgZmllbGRzO1xuICBpZiAob3B0aW9ucykge1xuICAgIGZpZWxkcyA9IG9wdGlvbnMuc2VsZWN0O1xuICAgIG9wdGlvbnMuc2VsZWN0ID0gdW5kZWZpbmVkO1xuICB9XG5cbiAgY29uc3QgbXEgPSBuZXcgdGhpcy5RdWVyeSh7fSwge30sIHRoaXMsIHRoaXMuJF9fY29sbGVjdGlvbik7XG4gIG1xLnNlbGVjdChmaWVsZHMpO1xuXG4gIHJldHVybiBtcS5maW5kT25lQW5kUmVwbGFjZShmaWx0ZXIsIHJlcGxhY2VtZW50LCBvcHRpb25zKTtcbn07XG5cbi8qKlxuICogU2hvcnRjdXQgZm9yIHNhdmluZyBvbmUgb3IgbW9yZSBkb2N1bWVudHMgdG8gdGhlIGRhdGFiYXNlLlxuICogYE15TW9kZWwuY3JlYXRlKGRvY3MpYCBkb2VzIGBuZXcgTXlNb2RlbChkb2MpLnNhdmUoKWAgZm9yIGV2ZXJ5IGRvYyBpblxuICogZG9jcy5cbiAqXG4gKiBUaGlzIGZ1bmN0aW9uIHRyaWdnZXJzIHRoZSBmb2xsb3dpbmcgbWlkZGxld2FyZS5cbiAqXG4gKiAtIGBzYXZlKClgXG4gKlxuICogIyMjIyBFeGFtcGxlOlxuICpcbiAqICAgICAvLyBJbnNlcnQgb25lIG5ldyBgQ2hhcmFjdGVyYCBkb2N1bWVudFxuICogICAgIGF3YWl0IENoYXJhY3Rlci5jcmVhdGUoeyBuYW1lOiAnSmVhbi1MdWMgUGljYXJkJyB9KTtcbiAqXG4gKiAgICAgLy8gSW5zZXJ0IG11bHRpcGxlIG5ldyBgQ2hhcmFjdGVyYCBkb2N1bWVudHNcbiAqICAgICBhd2FpdCBDaGFyYWN0ZXIuY3JlYXRlKFt7IG5hbWU6ICdXaWxsIFJpa2VyJyB9LCB7IG5hbWU6ICdHZW9yZGkgTGFGb3JnZScgfV0pO1xuICpcbiAqICAgICAvLyBDcmVhdGUgYSBuZXcgY2hhcmFjdGVyIHdpdGhpbiBhIHRyYW5zYWN0aW9uLiBOb3RlIHRoYXQgeW91ICoqbXVzdCoqXG4gKiAgICAgLy8gcGFzcyBhbiBhcnJheSBhcyB0aGUgZmlyc3QgcGFyYW1ldGVyIHRvIGBjcmVhdGUoKWAgaWYgeW91IHdhbnQgdG9cbiAqICAgICAvLyBzcGVjaWZ5IG9wdGlvbnMuXG4gKiAgICAgYXdhaXQgQ2hhcmFjdGVyLmNyZWF0ZShbeyBuYW1lOiAnSmVhbi1MdWMgUGljYXJkJyB9XSwgeyBzZXNzaW9uIH0pO1xuICpcbiAqIEBwYXJhbSB7QXJyYXl8T2JqZWN0fSBkb2NzIERvY3VtZW50cyB0byBpbnNlcnQsIGFzIGEgc3ByZWFkIG9yIGFycmF5XG4gKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdIE9wdGlvbnMgcGFzc2VkIGRvd24gdG8gYHNhdmUoKWAuIFRvIHNwZWNpZnkgYG9wdGlvbnNgLCBgZG9jc2AgKiptdXN0KiogYmUgYW4gYXJyYXksIG5vdCBhIHNwcmVhZC4gU2VlIFtNb2RlbC5zYXZlXShodHRwczovL21vbmdvb3NlanMuY29tL2RvY3MvYXBpL21vZGVsLmh0bWwjTW9kZWwucHJvdG90eXBlLnNhdmUoKSkgZm9yIGF2YWlsYWJsZSBvcHRpb25zLlxuICogQHBhcmFtIHtCb29sZWFufSBbb3B0aW9ucy5vcmRlcmVkXSBzYXZlcyB0aGUgZG9jcyBpbiBzZXJpZXMgcmF0aGVyIHRoYW4gcGFyYWxsZWwuXG4gKiBAcGFyYW0ge0Jvb2xlYW59IFtvcHRpb25zLmFnZ3JlZ2F0ZUVycm9yc10gQWdncmVnYXRlIEVycm9ycyBpbnN0ZWFkIG9mIHRocm93aW5nIHRoZSBmaXJzdCBvbmUgdGhhdCBvY2N1cnMuIERlZmF1bHQ6IGZhbHNlXG4gKiBAcmV0dXJuIHtQcm9taXNlfVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5Nb2RlbC5jcmVhdGUgPSBhc3luYyBmdW5jdGlvbiBjcmVhdGUoZG9jLCBvcHRpb25zKSB7XG4gIGlmICh0eXBlb2Ygb3B0aW9ucyA9PT0gJ2Z1bmN0aW9uJyB8fFxuICAgICAgdHlwZW9mIGFyZ3VtZW50c1syXSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHRocm93IG5ldyBNb25nb29zZUVycm9yKCdNb2RlbC5jcmVhdGUoKSBubyBsb25nZXIgYWNjZXB0cyBhIGNhbGxiYWNrJyk7XG4gIH1cblxuICBfY2hlY2tDb250ZXh0KHRoaXMsICdjcmVhdGUnKTtcblxuICBsZXQgYXJncztcbiAgY29uc3QgZGlzY3JpbWluYXRvcktleSA9IHRoaXMuc2NoZW1hLm9wdGlvbnMuZGlzY3JpbWluYXRvcktleTtcblxuICBpZiAoQXJyYXkuaXNBcnJheShkb2MpKSB7XG4gICAgYXJncyA9IGRvYztcbiAgICBvcHRpb25zID0gb3B0aW9ucyAhPSBudWxsICYmIHR5cGVvZiBvcHRpb25zID09PSAnb2JqZWN0JyA/IG9wdGlvbnMgOiB7fTtcbiAgfSBlbHNlIHtcbiAgICBjb25zdCBsYXN0ID0gYXJndW1lbnRzW2FyZ3VtZW50cy5sZW5ndGggLSAxXTtcbiAgICBvcHRpb25zID0ge307XG4gICAgY29uc3QgaGFzQ2FsbGJhY2sgPSB0eXBlb2YgbGFzdCA9PT0gJ2Z1bmN0aW9uJyB8fFxuICAgICAgdHlwZW9mIG9wdGlvbnMgPT09ICdmdW5jdGlvbicgfHxcbiAgICAgIHR5cGVvZiBhcmd1bWVudHNbMl0gPT09ICdmdW5jdGlvbic7XG4gICAgaWYgKGhhc0NhbGxiYWNrKSB7XG4gICAgICB0aHJvdyBuZXcgTW9uZ29vc2VFcnJvcignTW9kZWwuY3JlYXRlKCkgbm8gbG9uZ2VyIGFjY2VwdHMgYSBjYWxsYmFjaycpO1xuICAgIH0gZWxzZSB7XG4gICAgICBhcmdzID0gWy4uLmFyZ3VtZW50c107XG4gICAgICAvLyBGb3IgYmFja3dhcmRzIGNvbXBhdGliaWxpdHkgd2l0aCA2LngsIGJlY2F1c2Ugb2YgZ2gtNTA2MSBNb25nb29zZSA2LnggYW5kXG4gICAgICAvLyBvbGRlciB3b3VsZCB0cmVhdCBhIGZhbHN5IGxhc3QgYXJnIGFzIGEgY2FsbGJhY2suIFdlIGRvbid0IHdhbnQgdG8gdGhyb3dcbiAgICAgIC8vIGFuIGVycm9yIGhlcmUsIGJlY2F1c2UgaXQgd291bGQgbG9vayBzdHJhbmdlIGlmIGBUZXN0LmNyZWF0ZSh7fSwgdm9pZCAwKWBcbiAgICAgIC8vIHRocmV3IGEgY2FsbGJhY2sgZXJyb3IuIEJ1dCB3ZSBhbHNvIGRvbid0IHdhbnQgdG8gY3JlYXRlIGFuIHVubmVjZXNzYXJ5IGRvY3VtZW50LlxuICAgICAgaWYgKGFyZ3MubGVuZ3RoID4gMSAmJiAhbGFzdCkge1xuICAgICAgICBhcmdzLnBvcCgpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChhcmdzLmxlbmd0aCA9PT0gMiAmJlxuICAgICAgICBhcmdzWzBdICE9IG51bGwgJiZcbiAgICAgICAgYXJnc1sxXSAhPSBudWxsICYmXG4gICAgICAgIGFyZ3NbMF0uc2Vzc2lvbiA9PSBudWxsICYmXG4gICAgICAgIGxhc3QgJiZcbiAgICAgICAgZ2V0Q29uc3RydWN0b3JOYW1lKGxhc3Quc2Vzc2lvbikgPT09ICdDbGllbnRTZXNzaW9uJyAmJlxuICAgICAgICAhdGhpcy5zY2hlbWEucGF0aCgnc2Vzc2lvbicpKSB7XG4gICAgICAvLyBQcm9iYWJseSBtZWFucyB0aGUgdXNlciBpcyBydW5uaW5nIGludG8gdGhlIGNvbW1vbiBtaXN0YWtlIG9mIHRyeWluZ1xuICAgICAgLy8gdG8gdXNlIGEgc3ByZWFkIHRvIHNwZWNpZnkgb3B0aW9ucywgc2VlIGdoLTc1MzVcbiAgICAgIHV0aWxzLndhcm4oJ1dBUk5JTkc6IHRvIHBhc3MgYSBgc2Vzc2lvbmAgdG8gYE1vZGVsLmNyZWF0ZSgpYCBpbiAnICtcbiAgICAgICAgJ01vbmdvb3NlLCB5b3UgKiptdXN0KiogcGFzcyBhbiBhcnJheSBhcyB0aGUgZmlyc3QgYXJndW1lbnQuIFNlZTogJyArXG4gICAgICAgICdodHRwczovL21vbmdvb3NlanMuY29tL2RvY3MvYXBpL21vZGVsLmh0bWwjTW9kZWwuY3JlYXRlKCknKTtcbiAgICB9XG4gIH1cblxuICBpZiAoYXJncy5sZW5ndGggPT09IDApIHtcbiAgICByZXR1cm4gQXJyYXkuaXNBcnJheShkb2MpID8gW10gOiBudWxsO1xuICB9XG4gIGxldCByZXMgPSBbXTtcbiAgY29uc3QgaW1tZWRpYXRlRXJyb3IgPSB0eXBlb2Ygb3B0aW9ucy5hZ2dyZWdhdGVFcnJvcnMgPT09ICdib29sZWFuJyA/ICFvcHRpb25zLmFnZ3JlZ2F0ZUVycm9ycyA6IHRydWU7XG5cbiAgZGVsZXRlIG9wdGlvbnMuYWdncmVnYXRlRXJyb3JzOyAvLyBkb250IHBhc3Mgb24gdGhlIG9wdGlvbiB0byBcIiRzYXZlXCJcblxuICBpZiAob3B0aW9ucy5vcmRlcmVkKSB7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBhcmdzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB0cnkge1xuICAgICAgICBjb25zdCBkb2MgPSBhcmdzW2ldO1xuICAgICAgICBjb25zdCBNb2RlbCA9IHRoaXMuZGlzY3JpbWluYXRvcnMgJiYgZG9jW2Rpc2NyaW1pbmF0b3JLZXldICE9IG51bGwgP1xuICAgICAgICAgIHRoaXMuZGlzY3JpbWluYXRvcnNbZG9jW2Rpc2NyaW1pbmF0b3JLZXldXSB8fCBnZXREaXNjcmltaW5hdG9yQnlWYWx1ZSh0aGlzLmRpc2NyaW1pbmF0b3JzLCBkb2NbZGlzY3JpbWluYXRvcktleV0pIDpcbiAgICAgICAgICB0aGlzO1xuICAgICAgICBpZiAoTW9kZWwgPT0gbnVsbCkge1xuICAgICAgICAgIHRocm93IG5ldyBNb25nb29zZUVycm9yKGBEaXNjcmltaW5hdG9yIFwiJHtkb2NbZGlzY3JpbWluYXRvcktleV19XCIgbm90IGAgK1xuICAgICAgICAgIGBmb3VuZCBmb3IgbW9kZWwgXCIke3RoaXMubW9kZWxOYW1lfVwiYCk7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHRvU2F2ZSA9IGRvYztcbiAgICAgICAgaWYgKCEodG9TYXZlIGluc3RhbmNlb2YgTW9kZWwpKSB7XG4gICAgICAgICAgdG9TYXZlID0gbmV3IE1vZGVsKHRvU2F2ZSk7XG4gICAgICAgIH1cblxuICAgICAgICBhd2FpdCB0b1NhdmUuJHNhdmUob3B0aW9ucyk7XG4gICAgICAgIHJlcy5wdXNoKHRvU2F2ZSk7XG4gICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgaWYgKCFpbW1lZGlhdGVFcnJvcikge1xuICAgICAgICAgIHJlcy5wdXNoKGVycik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhyb3cgZXJyO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiByZXM7XG4gIH0gZWxzZSBpZiAoIWltbWVkaWF0ZUVycm9yKSB7XG4gICAgcmVzID0gYXdhaXQgUHJvbWlzZS5hbGxTZXR0bGVkKGFyZ3MubWFwKGFzeW5jIGRvYyA9PiB7XG4gICAgICBjb25zdCBNb2RlbCA9IHRoaXMuZGlzY3JpbWluYXRvcnMgJiYgZG9jW2Rpc2NyaW1pbmF0b3JLZXldICE9IG51bGwgP1xuICAgICAgICB0aGlzLmRpc2NyaW1pbmF0b3JzW2RvY1tkaXNjcmltaW5hdG9yS2V5XV0gfHwgZ2V0RGlzY3JpbWluYXRvckJ5VmFsdWUodGhpcy5kaXNjcmltaW5hdG9ycywgZG9jW2Rpc2NyaW1pbmF0b3JLZXldKSA6XG4gICAgICAgIHRoaXM7XG4gICAgICBpZiAoTW9kZWwgPT0gbnVsbCkge1xuICAgICAgICB0aHJvdyBuZXcgTW9uZ29vc2VFcnJvcihgRGlzY3JpbWluYXRvciBcIiR7ZG9jW2Rpc2NyaW1pbmF0b3JLZXldfVwiIG5vdCBgICtcbiAgICAgICAgICAgIGBmb3VuZCBmb3IgbW9kZWwgXCIke3RoaXMubW9kZWxOYW1lfVwiYCk7XG4gICAgICB9XG4gICAgICBsZXQgdG9TYXZlID0gZG9jO1xuXG4gICAgICBpZiAoISh0b1NhdmUgaW5zdGFuY2VvZiBNb2RlbCkpIHtcbiAgICAgICAgdG9TYXZlID0gbmV3IE1vZGVsKHRvU2F2ZSk7XG4gICAgICB9XG5cbiAgICAgIGF3YWl0IHRvU2F2ZS4kc2F2ZShvcHRpb25zKTtcblxuICAgICAgcmV0dXJuIHRvU2F2ZTtcbiAgICB9KSk7XG4gICAgcmVzID0gcmVzLm1hcChyZXN1bHQgPT4gcmVzdWx0LnN0YXR1cyA9PT0gJ2Z1bGZpbGxlZCcgPyByZXN1bHQudmFsdWUgOiByZXN1bHQucmVhc29uKTtcbiAgfSBlbHNlIHtcbiAgICBsZXQgZmlyc3RFcnJvciA9IG51bGw7XG4gICAgcmVzID0gYXdhaXQgUHJvbWlzZS5hbGwoYXJncy5tYXAoYXN5bmMgZG9jID0+IHtcbiAgICAgIGNvbnN0IE1vZGVsID0gdGhpcy5kaXNjcmltaW5hdG9ycyAmJiBkb2NbZGlzY3JpbWluYXRvcktleV0gIT0gbnVsbCA/XG4gICAgICAgIHRoaXMuZGlzY3JpbWluYXRvcnNbZG9jW2Rpc2NyaW1pbmF0b3JLZXldXSB8fCBnZXREaXNjcmltaW5hdG9yQnlWYWx1ZSh0aGlzLmRpc2NyaW1pbmF0b3JzLCBkb2NbZGlzY3JpbWluYXRvcktleV0pIDpcbiAgICAgICAgdGhpcztcbiAgICAgIGlmIChNb2RlbCA9PSBudWxsKSB7XG4gICAgICAgIHRocm93IG5ldyBNb25nb29zZUVycm9yKGBEaXNjcmltaW5hdG9yIFwiJHtkb2NbZGlzY3JpbWluYXRvcktleV19XCIgbm90IGAgK1xuICAgICAgICAgICAgYGZvdW5kIGZvciBtb2RlbCBcIiR7dGhpcy5tb2RlbE5hbWV9XCJgKTtcbiAgICAgIH1cbiAgICAgIHRyeSB7XG4gICAgICAgIGxldCB0b1NhdmUgPSBkb2M7XG5cbiAgICAgICAgaWYgKCEodG9TYXZlIGluc3RhbmNlb2YgTW9kZWwpKSB7XG4gICAgICAgICAgdG9TYXZlID0gbmV3IE1vZGVsKHRvU2F2ZSk7XG4gICAgICAgIH1cblxuICAgICAgICBhd2FpdCB0b1NhdmUuJHNhdmUob3B0aW9ucyk7XG5cbiAgICAgICAgcmV0dXJuIHRvU2F2ZTtcbiAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICBpZiAoIWZpcnN0RXJyb3IpIHtcbiAgICAgICAgICBmaXJzdEVycm9yID0gZXJyO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSkpO1xuICAgIGlmIChmaXJzdEVycm9yKSB7XG4gICAgICB0aHJvdyBmaXJzdEVycm9yO1xuICAgIH1cbiAgfVxuXG5cbiAgaWYgKCFBcnJheS5pc0FycmF5KGRvYykgJiYgYXJncy5sZW5ndGggPT09IDEpIHtcbiAgICByZXR1cm4gcmVzWzBdO1xuICB9XG5cbiAgcmV0dXJuIHJlcztcbn07XG5cbi8qKlxuICogX1JlcXVpcmVzIGEgcmVwbGljYSBzZXQgcnVubmluZyBNb25nb0RCID49IDMuNi4wLl8gV2F0Y2hlcyB0aGVcbiAqIHVuZGVybHlpbmcgY29sbGVjdGlvbiBmb3IgY2hhbmdlcyB1c2luZ1xuICogW01vbmdvREIgY2hhbmdlIHN0cmVhbXNdKGh0dHBzOi8vd3d3Lm1vbmdvZGIuY29tL2RvY3MvbWFudWFsL2NoYW5nZVN0cmVhbXMvKS5cbiAqXG4gKiBUaGlzIGZ1bmN0aW9uIGRvZXMgKipub3QqKiB0cmlnZ2VyIGFueSBtaWRkbGV3YXJlLiBJbiBwYXJ0aWN1bGFyLCBpdFxuICogZG9lcyAqKm5vdCoqIHRyaWdnZXIgYWdncmVnYXRlIG1pZGRsZXdhcmUuXG4gKlxuICogVGhlIENoYW5nZVN0cmVhbSBvYmplY3QgaXMgYW4gZXZlbnQgZW1pdHRlciB0aGF0IGVtaXRzIHRoZSBmb2xsb3dpbmcgZXZlbnRzOlxuICpcbiAqIC0gJ2NoYW5nZSc6IEEgY2hhbmdlIG9jY3VycmVkLCBzZWUgYmVsb3cgZXhhbXBsZVxuICogLSAnZXJyb3InOiBBbiB1bnJlY292ZXJhYmxlIGVycm9yIG9jY3VycmVkLiBJbiBwYXJ0aWN1bGFyLCBjaGFuZ2Ugc3RyZWFtcyBjdXJyZW50bHkgZXJyb3Igb3V0IGlmIHRoZXkgbG9zZSBjb25uZWN0aW9uIHRvIHRoZSByZXBsaWNhIHNldCBwcmltYXJ5LiBGb2xsb3cgW3RoaXMgR2l0SHViIGlzc3VlXShodHRwczovL2dpdGh1Yi5jb20vQXV0b21hdHRpYy9tb25nb29zZS9pc3N1ZXMvNjc5OSkgZm9yIHVwZGF0ZXMuXG4gKiAtICdlbmQnOiBFbWl0dGVkIGlmIHRoZSB1bmRlcmx5aW5nIHN0cmVhbSBpcyBjbG9zZWRcbiAqIC0gJ2Nsb3NlJzogRW1pdHRlZCBpZiB0aGUgdW5kZXJseWluZyBzdHJlYW0gaXMgY2xvc2VkXG4gKlxuICogIyMjIyBFeGFtcGxlOlxuICpcbiAqICAgICBjb25zdCBkb2MgPSBhd2FpdCBQZXJzb24uY3JlYXRlKHsgbmFtZTogJ05lZCBTdGFyaycgfSk7XG4gKiAgICAgY29uc3QgY2hhbmdlU3RyZWFtID0gUGVyc29uLndhdGNoKCkub24oJ2NoYW5nZScsIGNoYW5nZSA9PiBjb25zb2xlLmxvZyhjaGFuZ2UpKTtcbiAqICAgICAvLyBXaWxsIHByaW50IGZyb20gdGhlIGFib3ZlIGBjb25zb2xlLmxvZygpYDpcbiAqICAgICAvLyB7IF9pZDogeyBfZGF0YTogLi4uIH0sXG4gKiAgICAgLy8gICBvcGVyYXRpb25UeXBlOiAnZGVsZXRlJyxcbiAqICAgICAvLyAgIG5zOiB7IGRiOiAnbXlkYicsIGNvbGw6ICdQZXJzb24nIH0sXG4gKiAgICAgLy8gICBkb2N1bWVudEtleTogeyBfaWQ6IDVhNTFiMTI1YzU1MDBmNWFhMDk0YzdiZCB9IH1cbiAqICAgICBhd2FpdCBkb2MucmVtb3ZlKCk7XG4gKlxuICogQHBhcmFtIHtBcnJheX0gW3BpcGVsaW5lXVxuICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSBzZWUgdGhlIFttb25nb2RiIGRyaXZlciBvcHRpb25zXShodHRwczovL21vbmdvZGIuZ2l0aHViLmlvL25vZGUtbW9uZ29kYi1uYXRpdmUvNC45L2NsYXNzZXMvQ29sbGVjdGlvbi5odG1sI3dhdGNoKVxuICogQHBhcmFtIHtCb29sZWFufSBbb3B0aW9ucy5oeWRyYXRlPWZhbHNlXSBpZiB0cnVlIGFuZCBgZnVsbERvY3VtZW50OiAndXBkYXRlTG9va3VwJ2AgaXMgc2V0LCBNb25nb29zZSB3aWxsIGF1dG9tYXRpY2FsbHkgaHlkcmF0ZSBgZnVsbERvY3VtZW50YCBpbnRvIGEgZnVsbHkgZmxlZGdlZCBNb25nb29zZSBkb2N1bWVudFxuICogQHJldHVybiB7Q2hhbmdlU3RyZWFtfSBtb25nb29zZS1zcGVjaWZpYyBjaGFuZ2Ugc3RyZWFtIHdyYXBwZXIsIGluaGVyaXRzIGZyb20gRXZlbnRFbWl0dGVyXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbk1vZGVsLndhdGNoID0gZnVuY3Rpb24ocGlwZWxpbmUsIG9wdGlvbnMpIHtcbiAgX2NoZWNrQ29udGV4dCh0aGlzLCAnd2F0Y2gnKTtcblxuICBjb25zdCBjaGFuZ2VTdHJlYW1UaHVuayA9IGNiID0+IHtcbiAgICBwaXBlbGluZSA9IHBpcGVsaW5lIHx8IFtdO1xuICAgIHByZXBhcmVEaXNjcmltaW5hdG9yUGlwZWxpbmUocGlwZWxpbmUsIHRoaXMuc2NoZW1hLCAnZnVsbERvY3VtZW50Jyk7XG4gICAgaWYgKHRoaXMuJF9fY29sbGVjdGlvbi5idWZmZXIpIHtcbiAgICAgIHRoaXMuJF9fY29sbGVjdGlvbi5hZGRRdWV1ZSgoKSA9PiB7XG4gICAgICAgIGlmICh0aGlzLmNsb3NlZCkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBkcml2ZXJDaGFuZ2VTdHJlYW0gPSB0aGlzLiRfX2NvbGxlY3Rpb24ud2F0Y2gocGlwZWxpbmUsIG9wdGlvbnMpO1xuICAgICAgICBjYihudWxsLCBkcml2ZXJDaGFuZ2VTdHJlYW0pO1xuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IGRyaXZlckNoYW5nZVN0cmVhbSA9IHRoaXMuJF9fY29sbGVjdGlvbi53YXRjaChwaXBlbGluZSwgb3B0aW9ucyk7XG4gICAgICBjYihudWxsLCBkcml2ZXJDaGFuZ2VTdHJlYW0pO1xuICAgIH1cbiAgfTtcblxuICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgb3B0aW9ucy5tb2RlbCA9IHRoaXM7XG5cbiAgcmV0dXJuIG5ldyBDaGFuZ2VTdHJlYW0oY2hhbmdlU3RyZWFtVGh1bmssIHBpcGVsaW5lLCBvcHRpb25zKTtcbn07XG5cbi8qKlxuICogX1JlcXVpcmVzIE1vbmdvREIgPj0gMy42LjAuXyBTdGFydHMgYSBbTW9uZ29EQiBzZXNzaW9uXShodHRwczovL3d3dy5tb25nb2RiLmNvbS9kb2NzL21hbnVhbC9yZWxlYXNlLW5vdGVzLzMuNi8jY2xpZW50LXNlc3Npb25zKVxuICogZm9yIGJlbmVmaXRzIGxpa2UgY2F1c2FsIGNvbnNpc3RlbmN5LCBbcmV0cnlhYmxlIHdyaXRlc10oaHR0cHM6Ly93d3cubW9uZ29kYi5jb20vZG9jcy9tYW51YWwvY29yZS9yZXRyeWFibGUtd3JpdGVzLyksXG4gKiBhbmQgW3RyYW5zYWN0aW9uc10oaHR0cHM6Ly90aGVjb2RlYmFyYmFyaWFuLmNvbS9hLW5vZGUtanMtcGVyc3BlY3RpdmUtb24tbW9uZ29kYi00LXRyYW5zYWN0aW9ucy5odG1sKS5cbiAqXG4gKiBDYWxsaW5nIGBNeU1vZGVsLnN0YXJ0U2Vzc2lvbigpYCBpcyBlcXVpdmFsZW50IHRvIGNhbGxpbmcgYE15TW9kZWwuZGIuc3RhcnRTZXNzaW9uKClgLlxuICpcbiAqIFRoaXMgZnVuY3Rpb24gZG9lcyBub3QgdHJpZ2dlciBhbnkgbWlkZGxld2FyZS5cbiAqXG4gKiAjIyMjIEV4YW1wbGU6XG4gKlxuICogICAgIGNvbnN0IHNlc3Npb24gPSBhd2FpdCBQZXJzb24uc3RhcnRTZXNzaW9uKCk7XG4gKiAgICAgbGV0IGRvYyA9IGF3YWl0IFBlcnNvbi5maW5kT25lKHsgbmFtZTogJ05lZCBTdGFyaycgfSwgbnVsbCwgeyBzZXNzaW9uIH0pO1xuICogICAgIGF3YWl0IGRvYy5yZW1vdmUoKTtcbiAqICAgICAvLyBgZG9jYCB3aWxsIGFsd2F5cyBiZSBudWxsLCBldmVuIGlmIHJlYWRpbmcgZnJvbSBhIHJlcGxpY2Egc2V0XG4gKiAgICAgLy8gc2Vjb25kYXJ5LiBXaXRob3V0IGNhdXNhbCBjb25zaXN0ZW5jeSwgaXQgaXMgcG9zc2libGUgdG9cbiAqICAgICAvLyBnZXQgYSBkb2MgYmFjayBmcm9tIHRoZSBiZWxvdyBxdWVyeSBpZiB0aGUgcXVlcnkgcmVhZHMgZnJvbSBhXG4gKiAgICAgLy8gc2Vjb25kYXJ5IHRoYXQgaXMgZXhwZXJpZW5jaW5nIHJlcGxpY2F0aW9uIGxhZy5cbiAqICAgICBkb2MgPSBhd2FpdCBQZXJzb24uZmluZE9uZSh7IG5hbWU6ICdOZWQgU3RhcmsnIH0sIG51bGwsIHsgc2Vzc2lvbiwgcmVhZFByZWZlcmVuY2U6ICdzZWNvbmRhcnknIH0pO1xuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gc2VlIHRoZSBbbW9uZ29kYiBkcml2ZXIgb3B0aW9uc10oaHR0cHM6Ly9tb25nb2RiLmdpdGh1Yi5pby9ub2RlLW1vbmdvZGItbmF0aXZlLzQuOS9jbGFzc2VzL01vbmdvQ2xpZW50Lmh0bWwjc3RhcnRTZXNzaW9uKVxuICogQHBhcmFtIHtCb29sZWFufSBbb3B0aW9ucy5jYXVzYWxDb25zaXN0ZW5jeT10cnVlXSBzZXQgdG8gZmFsc2UgdG8gZGlzYWJsZSBjYXVzYWwgY29uc2lzdGVuY3lcbiAqIEByZXR1cm4ge1Byb21pc2U8Q2xpZW50U2Vzc2lvbj59IHByb21pc2UgdGhhdCByZXNvbHZlcyB0byBhIE1vbmdvREIgZHJpdmVyIGBDbGllbnRTZXNzaW9uYFxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5Nb2RlbC5zdGFydFNlc3Npb24gPSBmdW5jdGlvbigpIHtcbiAgX2NoZWNrQ29udGV4dCh0aGlzLCAnc3RhcnRTZXNzaW9uJyk7XG5cbiAgcmV0dXJuIHRoaXMuZGIuc3RhcnRTZXNzaW9uLmFwcGx5KHRoaXMuZGIsIGFyZ3VtZW50cyk7XG59O1xuXG4vKipcbiAqIFNob3J0Y3V0IGZvciB2YWxpZGF0aW5nIGFuIGFycmF5IG9mIGRvY3VtZW50cyBhbmQgaW5zZXJ0aW5nIHRoZW0gaW50b1xuICogTW9uZ29EQiBpZiB0aGV5J3JlIGFsbCB2YWxpZC4gVGhpcyBmdW5jdGlvbiBpcyBmYXN0ZXIgdGhhbiBgLmNyZWF0ZSgpYFxuICogYmVjYXVzZSBpdCBvbmx5IHNlbmRzIG9uZSBvcGVyYXRpb24gdG8gdGhlIHNlcnZlciwgcmF0aGVyIHRoYW4gb25lIGZvciBlYWNoXG4gKiBkb2N1bWVudC5cbiAqXG4gKiBNb25nb29zZSBhbHdheXMgdmFsaWRhdGVzIGVhY2ggZG9jdW1lbnQgKipiZWZvcmUqKiBzZW5kaW5nIGBpbnNlcnRNYW55YFxuICogdG8gTW9uZ29EQi4gU28gaWYgb25lIGRvY3VtZW50IGhhcyBhIHZhbGlkYXRpb24gZXJyb3IsIG5vIGRvY3VtZW50cyB3aWxsXG4gKiBiZSBzYXZlZCwgdW5sZXNzIHlvdSBzZXRcbiAqIFt0aGUgYG9yZGVyZWRgIG9wdGlvbiB0byBmYWxzZV0oaHR0cHM6Ly93d3cubW9uZ29kYi5jb20vZG9jcy9tYW51YWwvcmVmZXJlbmNlL21ldGhvZC9kYi5jb2xsZWN0aW9uLmluc2VydE1hbnkvI2Vycm9yLWhhbmRsaW5nKS5cbiAqXG4gKiBUaGlzIGZ1bmN0aW9uIGRvZXMgKipub3QqKiB0cmlnZ2VyIHNhdmUgbWlkZGxld2FyZS5cbiAqXG4gKiBUaGlzIGZ1bmN0aW9uIHRyaWdnZXJzIHRoZSBmb2xsb3dpbmcgbWlkZGxld2FyZS5cbiAqXG4gKiAtIGBpbnNlcnRNYW55KClgXG4gKlxuICogIyMjIyBFeGFtcGxlOlxuICpcbiAqICAgICBhd2FpdCBNb3ZpZXMuaW5zZXJ0TWFueShbXG4gKiAgICAgICB7IG5hbWU6ICdTdGFyIFdhcnMnIH0sXG4gKiAgICAgICB7IG5hbWU6ICdUaGUgRW1waXJlIFN0cmlrZXMgQmFjaycgfVxuICogICAgIF0pO1xuICpcbiAqIEBwYXJhbSB7QXJyYXl8T2JqZWN0fCp9IGRvYyhzKVxuICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSBzZWUgdGhlIFttb25nb2RiIGRyaXZlciBvcHRpb25zXShodHRwczovL21vbmdvZGIuZ2l0aHViLmlvL25vZGUtbW9uZ29kYi1uYXRpdmUvNC45L2NsYXNzZXMvQ29sbGVjdGlvbi5odG1sI2luc2VydE1hbnkpXG4gKiBAcGFyYW0ge0Jvb2xlYW59IFtvcHRpb25zLm9yZGVyZWQ9dHJ1ZV0gaWYgdHJ1ZSwgd2lsbCBmYWlsIGZhc3Qgb24gdGhlIGZpcnN0IGVycm9yIGVuY291bnRlcmVkLiBJZiBmYWxzZSwgd2lsbCBpbnNlcnQgYWxsIHRoZSBkb2N1bWVudHMgaXQgY2FuIGFuZCByZXBvcnQgZXJyb3JzIGxhdGVyLiBBbiBgaW5zZXJ0TWFueSgpYCB3aXRoIGBvcmRlcmVkID0gZmFsc2VgIGlzIGNhbGxlZCBhbiBcInVub3JkZXJlZFwiIGBpbnNlcnRNYW55KClgLlxuICogQHBhcmFtIHtCb29sZWFufSBbb3B0aW9ucy5yYXdSZXN1bHQ9ZmFsc2VdIGlmIGZhbHNlLCB0aGUgcmV0dXJuZWQgcHJvbWlzZSByZXNvbHZlcyB0byB0aGUgZG9jdW1lbnRzIHRoYXQgcGFzc2VkIG1vbmdvb3NlIGRvY3VtZW50IHZhbGlkYXRpb24uIElmIGB0cnVlYCwgd2lsbCByZXR1cm4gdGhlIFtyYXcgcmVzdWx0IGZyb20gdGhlIE1vbmdvREIgZHJpdmVyXShodHRwczovL21vbmdvZGIuZ2l0aHViLmlvL25vZGUtbW9uZ29kYi1uYXRpdmUvNC45L2ludGVyZmFjZXMvSW5zZXJ0TWFueVJlc3VsdC5odG1sKSB3aXRoIGEgYG1vbmdvb3NlYCBwcm9wZXJ0eSB0aGF0IGNvbnRhaW5zIGB2YWxpZGF0aW9uRXJyb3JzYCBhbmQgYHJlc3VsdHNgIGlmIHRoaXMgaXMgYW4gdW5vcmRlcmVkIGBpbnNlcnRNYW55YC5cbiAqIEBwYXJhbSB7Qm9vbGVhbn0gW29wdGlvbnMubGVhbj1mYWxzZV0gaWYgYHRydWVgLCBza2lwcyBoeWRyYXRpbmcgYW5kIHZhbGlkYXRpbmcgdGhlIGRvY3VtZW50cy4gVGhpcyBvcHRpb24gaXMgdXNlZnVsIGlmIHlvdSBuZWVkIHRoZSBleHRyYSBwZXJmb3JtYW5jZSwgYnV0IE1vbmdvb3NlIHdvbid0IHZhbGlkYXRlIHRoZSBkb2N1bWVudHMgYmVmb3JlIGluc2VydGluZy5cbiAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy5saW1pdD1udWxsXSB0aGlzIGxpbWl0cyB0aGUgbnVtYmVyIG9mIGRvY3VtZW50cyBiZWluZyBwcm9jZXNzZWQgKHZhbGlkYXRpb24vY2FzdGluZykgYnkgbW9uZ29vc2UgaW4gcGFyYWxsZWwsIHRoaXMgZG9lcyAqKk5PVCoqIHNlbmQgdGhlIGRvY3VtZW50cyBpbiBiYXRjaGVzIHRvIE1vbmdvREIuIFVzZSB0aGlzIG9wdGlvbiBpZiB5b3UncmUgcHJvY2Vzc2luZyBhIGxhcmdlIG51bWJlciBvZiBkb2N1bWVudHMgYW5kIHlvdXIgYXBwIGlzIHJ1bm5pbmcgb3V0IG9mIG1lbW9yeS5cbiAqIEBwYXJhbSB7U3RyaW5nfE9iamVjdHxBcnJheX0gW29wdGlvbnMucG9wdWxhdGU9bnVsbF0gcG9wdWxhdGVzIHRoZSByZXN1bHQgZG9jdW1lbnRzLiBUaGlzIG9wdGlvbiBpcyBhIG5vLW9wIGlmIGByYXdSZXN1bHRgIGlzIHNldC5cbiAqIEBwYXJhbSB7Qm9vbGVhbn0gW29wdGlvbnMudGhyb3dPblZhbGlkYXRpb25FcnJvcj1mYWxzZV0gSWYgdHJ1ZSBhbmQgYG9yZGVyZWQ6IGZhbHNlYCwgdGhyb3cgYW4gZXJyb3IgaWYgb25lIG9mIHRoZSBvcGVyYXRpb25zIGZhaWxlZCB2YWxpZGF0aW9uLCBidXQgYWxsIHZhbGlkIG9wZXJhdGlvbnMgY29tcGxldGVkIHN1Y2Nlc3NmdWxseS5cbiAqIEByZXR1cm4ge1Byb21pc2V9IHJlc29sdmluZyB0byB0aGUgcmF3IHJlc3VsdCBmcm9tIHRoZSBNb25nb0RCIGRyaXZlciBpZiBgb3B0aW9ucy5yYXdSZXN1bHRgIHdhcyBgdHJ1ZWAsIG9yIHRoZSBkb2N1bWVudHMgdGhhdCBwYXNzZWQgdmFsaWRhdGlvbiwgb3RoZXJ3aXNlXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbk1vZGVsLmluc2VydE1hbnkgPSBhc3luYyBmdW5jdGlvbiBpbnNlcnRNYW55KGFyciwgb3B0aW9ucykge1xuICBfY2hlY2tDb250ZXh0KHRoaXMsICdpbnNlcnRNYW55Jyk7XG4gIGlmICh0eXBlb2Ygb3B0aW9ucyA9PT0gJ2Z1bmN0aW9uJyB8fFxuICAgIHR5cGVvZiBhcmd1bWVudHNbMl0gPT09ICdmdW5jdGlvbicpIHtcbiAgICB0aHJvdyBuZXcgTW9uZ29vc2VFcnJvcignTW9kZWwuaW5zZXJ0TWFueSgpIG5vIGxvbmdlciBhY2NlcHRzIGEgY2FsbGJhY2snKTtcbiAgfVxuXG4gIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgdGhpcy4kX19pbnNlcnRNYW55KGFyciwgb3B0aW9ucywgKGVyciwgcmVzKSA9PiB7XG4gICAgICBpZiAoZXJyICE9IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIHJlamVjdChlcnIpO1xuICAgICAgfVxuICAgICAgcmVzb2x2ZShyZXMpO1xuICAgIH0pO1xuICB9KTtcbn07XG5cbi8qKlxuICogaWdub3JlXG4gKlxuICogQHBhcmFtIHtBcnJheX0gYXJyXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xuICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2tcbiAqIEBhcGkgcHJpdmF0ZVxuICogQG1lbWJlck9mIE1vZGVsXG4gKiBAbWV0aG9kICRfX2luc2VydE1hbnlcbiAqIEBzdGF0aWNcbiAqL1xuXG5Nb2RlbC4kX19pbnNlcnRNYW55ID0gZnVuY3Rpb24oYXJyLCBvcHRpb25zLCBjYWxsYmFjaykge1xuICBjb25zdCBfdGhpcyA9IHRoaXM7XG4gIGlmICh0eXBlb2Ygb3B0aW9ucyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIGNhbGxiYWNrID0gb3B0aW9ucztcbiAgICBvcHRpb25zID0gbnVsbDtcbiAgfVxuXG4gIGNhbGxiYWNrID0gY2FsbGJhY2sgfHwgdXRpbHMubm9vcDtcbiAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gIGNvbnN0IGxpbWl0ID0gb3B0aW9ucy5saW1pdCB8fCAxMDAwO1xuICBjb25zdCByYXdSZXN1bHQgPSAhIW9wdGlvbnMucmF3UmVzdWx0O1xuICBjb25zdCBvcmRlcmVkID0gdHlwZW9mIG9wdGlvbnMub3JkZXJlZCA9PT0gJ2Jvb2xlYW4nID8gb3B0aW9ucy5vcmRlcmVkIDogdHJ1ZTtcbiAgY29uc3QgdGhyb3dPblZhbGlkYXRpb25FcnJvciA9IHR5cGVvZiBvcHRpb25zLnRocm93T25WYWxpZGF0aW9uRXJyb3IgPT09ICdib29sZWFuJyA/IG9wdGlvbnMudGhyb3dPblZhbGlkYXRpb25FcnJvciA6IGZhbHNlO1xuICBjb25zdCBsZWFuID0gISFvcHRpb25zLmxlYW47XG5cbiAgaWYgKCFBcnJheS5pc0FycmF5KGFycikpIHtcbiAgICBhcnIgPSBbYXJyXTtcbiAgfVxuXG4gIGNvbnN0IHZhbGlkYXRpb25FcnJvcnMgPSBbXTtcbiAgY29uc3QgdmFsaWRhdGlvbkVycm9yc1RvT3JpZ2luYWxPcmRlciA9IG5ldyBNYXAoKTtcbiAgY29uc3QgcmVzdWx0cyA9IG9yZGVyZWQgPyBudWxsIDogbmV3IEFycmF5KGFyci5sZW5ndGgpO1xuICBjb25zdCB0b0V4ZWN1dGUgPSBhcnIubWFwKChkb2MsIGluZGV4KSA9PlxuICAgIGNhbGxiYWNrID0+IHtcbiAgICAgIGlmICghKGRvYyBpbnN0YW5jZW9mIF90aGlzKSkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIGRvYyA9IG5ldyBfdGhpcyhkb2MpO1xuICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICByZXR1cm4gY2FsbGJhY2soZXJyKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKG9wdGlvbnMuc2Vzc2lvbiAhPSBudWxsKSB7XG4gICAgICAgIGRvYy4kc2Vzc2lvbihvcHRpb25zLnNlc3Npb24pO1xuICAgICAgfVxuICAgICAgLy8gSWYgb3B0aW9uIGBsZWFuYCBpcyBzZXQgdG8gdHJ1ZSBieXBhc3MgdmFsaWRhdGlvblxuICAgICAgaWYgKGxlYW4pIHtcbiAgICAgICAgLy8gd2UgaGF2ZSB0byBleGVjdXRlIGNhbGxiYWNrIGF0IHRoZSBuZXh0VGljayB0byBiZSBjb21wYXRpYmxlXG4gICAgICAgIC8vIHdpdGggcGFyYWxsZWxMaW1pdCwgYXMgYHJlc3VsdHNgIHZhcmlhYmxlIGhhcyBURFogaXNzdWUgaWYgd2VcbiAgICAgICAgLy8gZXhlY3V0ZSB0aGUgY2FsbGJhY2sgc3luY2hyb25vdXNseVxuICAgICAgICByZXR1cm4gaW1tZWRpYXRlKCgpID0+IGNhbGxiYWNrKG51bGwsIGRvYykpO1xuICAgICAgfVxuICAgICAgZG9jLiR2YWxpZGF0ZSgpLnRoZW4oXG4gICAgICAgICgpID0+IHsgY2FsbGJhY2sobnVsbCwgZG9jKTsgfSxcbiAgICAgICAgZXJyb3IgPT4ge1xuICAgICAgICAgIGlmIChvcmRlcmVkID09PSBmYWxzZSkge1xuICAgICAgICAgICAgdmFsaWRhdGlvbkVycm9ycy5wdXNoKGVycm9yKTtcbiAgICAgICAgICAgIHZhbGlkYXRpb25FcnJvcnNUb09yaWdpbmFsT3JkZXIuc2V0KGVycm9yLCBpbmRleCk7XG4gICAgICAgICAgICByZXN1bHRzW2luZGV4XSA9IGVycm9yO1xuICAgICAgICAgICAgcmV0dXJuIGNhbGxiYWNrKG51bGwsIG51bGwpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjYWxsYmFjayhlcnJvcik7XG4gICAgICAgIH1cbiAgICAgICk7XG4gICAgfSk7XG5cbiAgcGFyYWxsZWxMaW1pdCh0b0V4ZWN1dGUsIGxpbWl0LCBmdW5jdGlvbihlcnJvciwgZG9jcykge1xuICAgIGlmIChlcnJvcikge1xuICAgICAgY2FsbGJhY2soZXJyb3IsIG51bGwpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGNvbnN0IG9yaWdpbmFsRG9jSW5kZXggPSBuZXcgTWFwKCk7XG4gICAgY29uc3QgdmFsaWREb2NJbmRleFRvT3JpZ2luYWxJbmRleCA9IG5ldyBNYXAoKTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGRvY3MubGVuZ3RoOyArK2kpIHtcbiAgICAgIG9yaWdpbmFsRG9jSW5kZXguc2V0KGRvY3NbaV0sIGkpO1xuICAgIH1cblxuICAgIC8vIFdlIGZpbHRlciBhbGwgZmFpbGVkIHByZS12YWxpZGF0aW9ucyBieSByZW1vdmluZyBudWxsc1xuICAgIGNvbnN0IGRvY0F0dHJpYnV0ZXMgPSBkb2NzLmZpbHRlcihmdW5jdGlvbihkb2MpIHtcbiAgICAgIHJldHVybiBkb2MgIT0gbnVsbDtcbiAgICB9KTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGRvY0F0dHJpYnV0ZXMubGVuZ3RoOyArK2kpIHtcbiAgICAgIHZhbGlkRG9jSW5kZXhUb09yaWdpbmFsSW5kZXguc2V0KGksIG9yaWdpbmFsRG9jSW5kZXguZ2V0KGRvY0F0dHJpYnV0ZXNbaV0pKTtcbiAgICB9XG5cbiAgICAvLyBNYWtlIHN1cmUgdmFsaWRhdGlvbiBlcnJvcnMgYXJlIGluIHRoZSBzYW1lIG9yZGVyIGFzIHRoZVxuICAgIC8vIG9yaWdpbmFsIGRvY3VtZW50cywgc28gaWYgYm90aCBkb2MxIGFuZCBkb2MyIGJvdGggZmFpbCB2YWxpZGF0aW9uLFxuICAgIC8vIGBNb2RlbC5pbnNlcnRNYW55KFtkb2MxLCBkb2MyXSlgIHdpbGwgYWx3YXlzIGhhdmUgZG9jMSdzIHZhbGlkYXRpb25cbiAgICAvLyBlcnJvciBiZWZvcmUgZG9jMidzLiBSZTogZ2gtMTI3OTEuXG4gICAgaWYgKHZhbGlkYXRpb25FcnJvcnMubGVuZ3RoID4gMCkge1xuICAgICAgdmFsaWRhdGlvbkVycm9ycy5zb3J0KChlcnIxLCBlcnIyKSA9PiB7XG4gICAgICAgIHJldHVybiB2YWxpZGF0aW9uRXJyb3JzVG9PcmlnaW5hbE9yZGVyLmdldChlcnIxKSAtIHZhbGlkYXRpb25FcnJvcnNUb09yaWdpbmFsT3JkZXIuZ2V0KGVycjIpO1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgLy8gUXVpY2tseSBlc2NhcGUgd2hpbGUgdGhlcmUgYXJlbid0IGFueSB2YWxpZCBkb2NBdHRyaWJ1dGVzXG4gICAgaWYgKGRvY0F0dHJpYnV0ZXMubGVuZ3RoID09PSAwKSB7XG4gICAgICBpZiAocmF3UmVzdWx0KSB7XG4gICAgICAgIGNvbnN0IHJlcyA9IHtcbiAgICAgICAgICBhY2tub3dsZWRnZWQ6IHRydWUsXG4gICAgICAgICAgaW5zZXJ0ZWRDb3VudDogMCxcbiAgICAgICAgICBpbnNlcnRlZElkczoge30sXG4gICAgICAgICAgbW9uZ29vc2U6IHtcbiAgICAgICAgICAgIHZhbGlkYXRpb25FcnJvcnM6IHZhbGlkYXRpb25FcnJvcnNcbiAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBjYWxsYmFjayhudWxsLCByZXMpO1xuICAgICAgfVxuICAgICAgY2FsbGJhY2sobnVsbCwgW10pO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBkb2NPYmplY3RzID0gZG9jQXR0cmlidXRlcy5tYXAoZnVuY3Rpb24oZG9jKSB7XG4gICAgICBpZiAoZG9jLiRfX3NjaGVtYS5vcHRpb25zLnZlcnNpb25LZXkpIHtcbiAgICAgICAgZG9jW2RvYy4kX19zY2hlbWEub3B0aW9ucy52ZXJzaW9uS2V5XSA9IDA7XG4gICAgICB9XG4gICAgICBjb25zdCBzaG91bGRTZXRUaW1lc3RhbXBzID0gKCFvcHRpb25zIHx8IG9wdGlvbnMudGltZXN0YW1wcyAhPT0gZmFsc2UpICYmIGRvYy5pbml0aWFsaXplVGltZXN0YW1wcyAmJiAoIWRvYy4kX18gfHwgZG9jLiRfXy50aW1lc3RhbXBzICE9PSBmYWxzZSk7XG4gICAgICBpZiAoc2hvdWxkU2V0VGltZXN0YW1wcykge1xuICAgICAgICByZXR1cm4gZG9jLmluaXRpYWxpemVUaW1lc3RhbXBzKCkudG9PYmplY3QoaW50ZXJuYWxUb09iamVjdE9wdGlvbnMpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGRvYy50b09iamVjdChpbnRlcm5hbFRvT2JqZWN0T3B0aW9ucyk7XG4gICAgfSk7XG5cbiAgICBfdGhpcy4kX19jb2xsZWN0aW9uLmluc2VydE1hbnkoZG9jT2JqZWN0cywgb3B0aW9ucykudGhlbihcbiAgICAgIHJlcyA9PiB7XG4gICAgICAgIGZvciAoY29uc3QgYXR0cmlidXRlIG9mIGRvY0F0dHJpYnV0ZXMpIHtcbiAgICAgICAgICBhdHRyaWJ1dGUuJF9fcmVzZXQoKTtcbiAgICAgICAgICBfc2V0SXNOZXcoYXR0cmlidXRlLCBmYWxzZSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAob3JkZXJlZCA9PT0gZmFsc2UgJiYgdGhyb3dPblZhbGlkYXRpb25FcnJvciAmJiB2YWxpZGF0aW9uRXJyb3JzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHJlc3VsdHMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgIGlmIChyZXN1bHRzW2ldID09PSB2b2lkIDApIHtcbiAgICAgICAgICAgICAgcmVzdWx0c1tpXSA9IGRvY3NbaV07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBjYWxsYmFjayhuZXcgTW9uZ29vc2VCdWxrV3JpdGVFcnJvcihcbiAgICAgICAgICAgIHZhbGlkYXRpb25FcnJvcnMsXG4gICAgICAgICAgICByZXN1bHRzLFxuICAgICAgICAgICAgcmVzLFxuICAgICAgICAgICAgJ2luc2VydE1hbnknXG4gICAgICAgICAgKSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAocmF3UmVzdWx0KSB7XG4gICAgICAgICAgaWYgKG9yZGVyZWQgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHJlc3VsdHMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgICAgaWYgKHJlc3VsdHNbaV0gPT09IHZvaWQgMCkge1xuICAgICAgICAgICAgICAgIHJlc3VsdHNbaV0gPSBkb2NzW2ldO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIERlY29yYXRlIHdpdGggbW9uZ29vc2UgdmFsaWRhdGlvbiBlcnJvcnMgaW4gY2FzZSBvZiB1bm9yZGVyZWQsXG4gICAgICAgICAgICAvLyBiZWNhdXNlIHRoZW4gc3RpbGwgZG8gYGluc2VydE1hbnkoKWBcbiAgICAgICAgICAgIHJlcy5tb25nb29zZSA9IHtcbiAgICAgICAgICAgICAgdmFsaWRhdGlvbkVycm9yczogdmFsaWRhdGlvbkVycm9ycyxcbiAgICAgICAgICAgICAgcmVzdWx0czogcmVzdWx0c1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIGNhbGxiYWNrKG51bGwsIHJlcyk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAob3B0aW9ucy5wb3B1bGF0ZSAhPSBudWxsKSB7XG4gICAgICAgICAgcmV0dXJuIF90aGlzLnBvcHVsYXRlKGRvY0F0dHJpYnV0ZXMsIG9wdGlvbnMucG9wdWxhdGUpLnRoZW4oXG4gICAgICAgICAgICBkb2NzID0+IHsgY2FsbGJhY2sobnVsbCwgZG9jcyk7IH0sXG4gICAgICAgICAgICBlcnIgPT4ge1xuICAgICAgICAgICAgICBpZiAoZXJyICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICBlcnIuaW5zZXJ0ZWREb2NzID0gZG9jQXR0cmlidXRlcztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB0aHJvdyBlcnI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNhbGxiYWNrKG51bGwsIGRvY0F0dHJpYnV0ZXMpO1xuICAgICAgfSxcbiAgICAgIGVycm9yID0+IHtcbiAgICAgICAgLy8gYHdyaXRlRXJyb3JzYCBpcyBhIHByb3BlcnR5IHJlcG9ydGVkIGJ5IHRoZSBNb25nb0RCIGRyaXZlcixcbiAgICAgICAgLy8ganVzdCBub3QgaWYgdGhlcmUncyBvbmx5IDEgZXJyb3IuXG4gICAgICAgIGlmIChlcnJvci53cml0ZUVycm9ycyA9PSBudWxsICYmXG4gICAgICAgICAgICAoZXJyb3IucmVzdWx0ICYmIGVycm9yLnJlc3VsdC5yZXN1bHQgJiYgZXJyb3IucmVzdWx0LnJlc3VsdC53cml0ZUVycm9ycykgIT0gbnVsbCkge1xuICAgICAgICAgIGVycm9yLndyaXRlRXJyb3JzID0gZXJyb3IucmVzdWx0LnJlc3VsdC53cml0ZUVycm9ycztcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGBpbnNlcnRlZERvY3NgIGlzIGEgTW9uZ29vc2Utc3BlY2lmaWMgcHJvcGVydHlcbiAgICAgICAgY29uc3QgaGFzV3JpdGVFcnJvcnMgPSBlcnJvciAmJiBlcnJvci53cml0ZUVycm9ycztcbiAgICAgICAgY29uc3QgZXJyb3JlZEluZGV4ZXMgPSBuZXcgU2V0KChlcnJvciAmJiBlcnJvci53cml0ZUVycm9ycyB8fCBbXSkubWFwKGVyciA9PiBlcnIuaW5kZXgpKTtcblxuICAgICAgICBpZiAoZXJyb3Iud3JpdGVFcnJvcnMgIT0gbnVsbCkge1xuICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZXJyb3Iud3JpdGVFcnJvcnMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgIGNvbnN0IG9yaWdpbmFsSW5kZXggPSB2YWxpZERvY0luZGV4VG9PcmlnaW5hbEluZGV4LmdldChlcnJvci53cml0ZUVycm9yc1tpXS5pbmRleCk7XG4gICAgICAgICAgICBlcnJvci53cml0ZUVycm9yc1tpXSA9IHtcbiAgICAgICAgICAgICAgLi4uZXJyb3Iud3JpdGVFcnJvcnNbaV0sXG4gICAgICAgICAgICAgIGluZGV4OiBvcmlnaW5hbEluZGV4XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgaWYgKCFvcmRlcmVkKSB7XG4gICAgICAgICAgICAgIHJlc3VsdHNbb3JpZ2luYWxJbmRleF0gPSBlcnJvci53cml0ZUVycm9yc1tpXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIW9yZGVyZWQpIHtcbiAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHJlc3VsdHMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgIGlmIChyZXN1bHRzW2ldID09PSB2b2lkIDApIHtcbiAgICAgICAgICAgICAgcmVzdWx0c1tpXSA9IGRvY3NbaV07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgZXJyb3IucmVzdWx0cyA9IHJlc3VsdHM7XG4gICAgICAgIH1cblxuICAgICAgICBsZXQgZmlyc3RFcnJvcmVkSW5kZXggPSAtMTtcbiAgICAgICAgZXJyb3IuaW5zZXJ0ZWREb2NzID0gZG9jQXR0cmlidXRlcy5cbiAgICAgICAgICBmaWx0ZXIoKGRvYywgaSkgPT4ge1xuICAgICAgICAgICAgY29uc3QgaXNFcnJvcmVkID0gIWhhc1dyaXRlRXJyb3JzIHx8IGVycm9yZWRJbmRleGVzLmhhcyhpKTtcblxuICAgICAgICAgICAgaWYgKG9yZGVyZWQpIHtcbiAgICAgICAgICAgICAgaWYgKGZpcnN0RXJyb3JlZEluZGV4ID4gLTEpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaSA8IGZpcnN0RXJyb3JlZEluZGV4O1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgaWYgKGlzRXJyb3JlZCkge1xuICAgICAgICAgICAgICAgIGZpcnN0RXJyb3JlZEluZGV4ID0gaTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gIWlzRXJyb3JlZDtcbiAgICAgICAgICB9KS5cbiAgICAgICAgICBtYXAoZnVuY3Rpb24gc2V0SXNOZXdGb3JJbnNlcnRlZERvYyhkb2MpIHtcbiAgICAgICAgICAgIGRvYy4kX19yZXNldCgpO1xuICAgICAgICAgICAgX3NldElzTmV3KGRvYywgZmFsc2UpO1xuICAgICAgICAgICAgcmV0dXJuIGRvYztcbiAgICAgICAgICB9KTtcblxuICAgICAgICBpZiAocmF3UmVzdWx0ICYmIG9yZGVyZWQgPT09IGZhbHNlKSB7XG4gICAgICAgICAgZXJyb3IubW9uZ29vc2UgPSB7XG4gICAgICAgICAgICB2YWxpZGF0aW9uRXJyb3JzOiB2YWxpZGF0aW9uRXJyb3JzLFxuICAgICAgICAgICAgcmVzdWx0czogcmVzdWx0c1xuICAgICAgICAgIH07XG4gICAgICAgIH1cblxuICAgICAgICBjYWxsYmFjayhlcnJvciwgbnVsbCk7XG4gICAgICB9XG4gICAgKTtcbiAgfSk7XG59O1xuXG4vKiFcbiAqIGlnbm9yZVxuICovXG5cbmZ1bmN0aW9uIF9zZXRJc05ldyhkb2MsIHZhbCkge1xuICBkb2MuJGlzTmV3ID0gdmFsO1xuICBkb2MuJGVtaXQoJ2lzTmV3JywgdmFsKTtcbiAgZG9jLmNvbnN0cnVjdG9yLmVtaXQoJ2lzTmV3JywgdmFsKTtcblxuICBjb25zdCBzdWJkb2NzID0gZG9jLiRnZXRBbGxTdWJkb2NzKCk7XG4gIGZvciAoY29uc3Qgc3ViZG9jIG9mIHN1YmRvY3MpIHtcbiAgICBzdWJkb2MuJGlzTmV3ID0gdmFsO1xuICAgIHN1YmRvYy4kZW1pdCgnaXNOZXcnLCB2YWwpO1xuICB9XG59XG5cbi8qKlxuICogU2VuZHMgbXVsdGlwbGUgYGluc2VydE9uZWAsIGB1cGRhdGVPbmVgLCBgdXBkYXRlTWFueWAsIGByZXBsYWNlT25lYCxcbiAqIGBkZWxldGVPbmVgLCBhbmQvb3IgYGRlbGV0ZU1hbnlgIG9wZXJhdGlvbnMgdG8gdGhlIE1vbmdvREIgc2VydmVyIGluIG9uZVxuICogY29tbWFuZC4gVGhpcyBpcyBmYXN0ZXIgdGhhbiBzZW5kaW5nIG11bHRpcGxlIGluZGVwZW5kZW50IG9wZXJhdGlvbnMgKGUuZy5cbiAqIGlmIHlvdSB1c2UgYGNyZWF0ZSgpYCkgYmVjYXVzZSB3aXRoIGBidWxrV3JpdGUoKWAgdGhlcmUgaXMgb25seSBvbmUgcm91bmRcbiAqIHRyaXAgdG8gTW9uZ29EQi5cbiAqXG4gKiBNb25nb29zZSB3aWxsIHBlcmZvcm0gY2FzdGluZyBvbiBhbGwgb3BlcmF0aW9ucyB5b3UgcHJvdmlkZS5cbiAqXG4gKiBUaGlzIGZ1bmN0aW9uIGRvZXMgKipub3QqKiB0cmlnZ2VyIGFueSBtaWRkbGV3YXJlLCBuZWl0aGVyIGBzYXZlKClgLCBub3IgYHVwZGF0ZSgpYC5cbiAqIElmIHlvdSBuZWVkIHRvIHRyaWdnZXJcbiAqIGBzYXZlKClgIG1pZGRsZXdhcmUgZm9yIGV2ZXJ5IGRvY3VtZW50IHVzZSBbYGNyZWF0ZSgpYF0oaHR0cHM6Ly9tb25nb29zZWpzLmNvbS9kb2NzL2FwaS9tb2RlbC5odG1sI01vZGVsLmNyZWF0ZSgpKSBpbnN0ZWFkLlxuICpcbiAqICMjIyMgRXhhbXBsZTpcbiAqXG4gKiAgICAgQ2hhcmFjdGVyLmJ1bGtXcml0ZShbXG4gKiAgICAgICB7XG4gKiAgICAgICAgIGluc2VydE9uZToge1xuICogICAgICAgICAgIGRvY3VtZW50OiB7XG4gKiAgICAgICAgICAgICBuYW1lOiAnRWRkYXJkIFN0YXJrJyxcbiAqICAgICAgICAgICAgIHRpdGxlOiAnV2FyZGVuIG9mIHRoZSBOb3J0aCdcbiAqICAgICAgICAgICB9XG4gKiAgICAgICAgIH1cbiAqICAgICAgIH0sXG4gKiAgICAgICB7XG4gKiAgICAgICAgIHVwZGF0ZU9uZToge1xuICogICAgICAgICAgIGZpbHRlcjogeyBuYW1lOiAnRWRkYXJkIFN0YXJrJyB9LFxuICogICAgICAgICAgIC8vIElmIHlvdSB3ZXJlIHVzaW5nIHRoZSBNb25nb0RCIGRyaXZlciBkaXJlY3RseSwgeW91J2QgbmVlZCB0byBkb1xuICogICAgICAgICAgIC8vIGB1cGRhdGU6IHsgJHNldDogeyB0aXRsZTogLi4uIH0gfWAgYnV0IG1vbmdvb3NlIGFkZHMgJHNldCBmb3JcbiAqICAgICAgICAgICAvLyB5b3UuXG4gKiAgICAgICAgICAgdXBkYXRlOiB7IHRpdGxlOiAnSGFuZCBvZiB0aGUgS2luZycgfVxuICogICAgICAgICB9XG4gKiAgICAgICB9LFxuICogICAgICAge1xuICogICAgICAgICBkZWxldGVPbmU6IHtcbiAqICAgICAgICAgICBmaWx0ZXI6IHsgbmFtZTogJ0VkZGFyZCBTdGFyaycgfVxuICogICAgICAgICB9XG4gKiAgICAgICB9XG4gKiAgICAgXSkudGhlbihyZXMgPT4ge1xuICogICAgICAvLyBQcmludHMgXCIxIDEgMVwiXG4gKiAgICAgIGNvbnNvbGUubG9nKHJlcy5pbnNlcnRlZENvdW50LCByZXMubW9kaWZpZWRDb3VudCwgcmVzLmRlbGV0ZWRDb3VudCk7XG4gKiAgICAgfSk7XG4gKlxuICogVGhlIFtzdXBwb3J0ZWQgb3BlcmF0aW9uc10oaHR0cHM6Ly93d3cubW9uZ29kYi5jb20vZG9jcy9tYW51YWwvcmVmZXJlbmNlL21ldGhvZC9kYi5jb2xsZWN0aW9uLmJ1bGtXcml0ZS8jZGIuY29sbGVjdGlvbi5idWxrV3JpdGUpIGFyZTpcbiAqXG4gKiAtIGBpbnNlcnRPbmVgXG4gKiAtIGB1cGRhdGVPbmVgXG4gKiAtIGB1cGRhdGVNYW55YFxuICogLSBgZGVsZXRlT25lYFxuICogLSBgZGVsZXRlTWFueWBcbiAqIC0gYHJlcGxhY2VPbmVgXG4gKlxuICogQHBhcmFtIHtBcnJheX0gb3BzXG4gKiBAcGFyYW0ge09iamVjdH0gW29wcy5pbnNlcnRPbmUuZG9jdW1lbnRdIFRoZSBkb2N1bWVudCB0byBpbnNlcnRcbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3BzLnVwZGF0ZU9uZS5maWx0ZXJdIFVwZGF0ZSB0aGUgZmlyc3QgZG9jdW1lbnQgdGhhdCBtYXRjaGVzIHRoaXMgZmlsdGVyXG4gKiBAcGFyYW0ge09iamVjdH0gW29wcy51cGRhdGVPbmUudXBkYXRlXSBBbiBvYmplY3QgY29udGFpbmluZyBbdXBkYXRlIG9wZXJhdG9yc10oaHR0cHM6Ly93d3cubW9uZ29kYi5jb20vZG9jcy9tYW51YWwvcmVmZXJlbmNlL29wZXJhdG9yL3VwZGF0ZS8pXG4gKiBAcGFyYW0ge0Jvb2xlYW59IFtvcHMudXBkYXRlT25lLnVwc2VydD1mYWxzZV0gSWYgdHJ1ZSwgaW5zZXJ0IGEgZG9jIGlmIG5vbmUgbWF0Y2hcbiAqIEBwYXJhbSB7Qm9vbGVhbn0gW29wcy51cGRhdGVPbmUudGltZXN0YW1wcz10cnVlXSBJZiBmYWxzZSwgZG8gbm90IGFwcGx5IFt0aW1lc3RhbXBzXShodHRwczovL21vbmdvb3NlanMuY29tL2RvY3MvZ3VpZGUuaHRtbCN0aW1lc3RhbXBzKSB0byB0aGUgb3BlcmF0aW9uXG4gKiBAcGFyYW0ge09iamVjdH0gW29wcy51cGRhdGVPbmUuY29sbGF0aW9uXSBUaGUgW01vbmdvREIgY29sbGF0aW9uXShodHRwczovL3RoZWNvZGViYXJiYXJpYW4uY29tL2Etbm9kZWpzLXBlcnNwZWN0aXZlLW9uLW1vbmdvZGItMzQtY29sbGF0aW9ucykgdG8gdXNlXG4gKiBAcGFyYW0ge0FycmF5fSBbb3BzLnVwZGF0ZU9uZS5hcnJheUZpbHRlcnNdIFRoZSBbYXJyYXkgZmlsdGVyc10oaHR0cHM6Ly90aGVjb2RlYmFyYmFyaWFuLmNvbS9hLW5vZGVqcy1wZXJzcGVjdGl2ZS1vbi1tb25nb2RiLTM2LWFycmF5LWZpbHRlcnMuaHRtbCkgdXNlZCBpbiBgdXBkYXRlYFxuICogQHBhcmFtIHtPYmplY3R9IFtvcHMudXBkYXRlTWFueS5maWx0ZXJdIFVwZGF0ZSBhbGwgdGhlIGRvY3VtZW50cyB0aGF0IG1hdGNoIHRoaXMgZmlsdGVyXG4gKiBAcGFyYW0ge09iamVjdH0gW29wcy51cGRhdGVNYW55LnVwZGF0ZV0gQW4gb2JqZWN0IGNvbnRhaW5pbmcgW3VwZGF0ZSBvcGVyYXRvcnNdKGh0dHBzOi8vd3d3Lm1vbmdvZGIuY29tL2RvY3MvbWFudWFsL3JlZmVyZW5jZS9vcGVyYXRvci91cGRhdGUvKVxuICogQHBhcmFtIHtCb29sZWFufSBbb3BzLnVwZGF0ZU1hbnkudXBzZXJ0PWZhbHNlXSBJZiB0cnVlLCBpbnNlcnQgYSBkb2MgaWYgbm8gZG9jdW1lbnRzIG1hdGNoIGBmaWx0ZXJgXG4gKiBAcGFyYW0ge0Jvb2xlYW59IFtvcHMudXBkYXRlTWFueS50aW1lc3RhbXBzPXRydWVdIElmIGZhbHNlLCBkbyBub3QgYXBwbHkgW3RpbWVzdGFtcHNdKGh0dHBzOi8vbW9uZ29vc2Vqcy5jb20vZG9jcy9ndWlkZS5odG1sI3RpbWVzdGFtcHMpIHRvIHRoZSBvcGVyYXRpb25cbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3BzLnVwZGF0ZU1hbnkuY29sbGF0aW9uXSBUaGUgW01vbmdvREIgY29sbGF0aW9uXShodHRwczovL3RoZWNvZGViYXJiYXJpYW4uY29tL2Etbm9kZWpzLXBlcnNwZWN0aXZlLW9uLW1vbmdvZGItMzQtY29sbGF0aW9ucykgdG8gdXNlXG4gKiBAcGFyYW0ge0FycmF5fSBbb3BzLnVwZGF0ZU1hbnkuYXJyYXlGaWx0ZXJzXSBUaGUgW2FycmF5IGZpbHRlcnNdKGh0dHBzOi8vdGhlY29kZWJhcmJhcmlhbi5jb20vYS1ub2RlanMtcGVyc3BlY3RpdmUtb24tbW9uZ29kYi0zNi1hcnJheS1maWx0ZXJzLmh0bWwpIHVzZWQgaW4gYHVwZGF0ZWBcbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3BzLmRlbGV0ZU9uZS5maWx0ZXJdIERlbGV0ZSB0aGUgZmlyc3QgZG9jdW1lbnQgdGhhdCBtYXRjaGVzIHRoaXMgZmlsdGVyXG4gKiBAcGFyYW0ge09iamVjdH0gW29wcy5kZWxldGVNYW55LmZpbHRlcl0gRGVsZXRlIGFsbCBkb2N1bWVudHMgdGhhdCBtYXRjaCB0aGlzIGZpbHRlclxuICogQHBhcmFtIHtPYmplY3R9IFtvcHMucmVwbGFjZU9uZS5maWx0ZXJdIFJlcGxhY2UgdGhlIGZpcnN0IGRvY3VtZW50IHRoYXQgbWF0Y2hlcyB0aGlzIGZpbHRlclxuICogQHBhcmFtIHtPYmplY3R9IFtvcHMucmVwbGFjZU9uZS5yZXBsYWNlbWVudF0gVGhlIHJlcGxhY2VtZW50IGRvY3VtZW50XG4gKiBAcGFyYW0ge0Jvb2xlYW59IFtvcHMucmVwbGFjZU9uZS51cHNlcnQ9ZmFsc2VdIElmIHRydWUsIGluc2VydCBhIGRvYyBpZiBubyBkb2N1bWVudHMgbWF0Y2ggYGZpbHRlcmBcbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc11cbiAqIEBwYXJhbSB7Qm9vbGVhbn0gW29wdGlvbnMub3JkZXJlZD10cnVlXSBJZiB0cnVlLCBleGVjdXRlIHdyaXRlcyBpbiBvcmRlciBhbmQgc3RvcCBhdCB0aGUgZmlyc3QgZXJyb3IuIElmIGZhbHNlLCBleGVjdXRlIHdyaXRlcyBpbiBwYXJhbGxlbCBhbmQgY29udGludWUgdW50aWwgYWxsIHdyaXRlcyBoYXZlIGVpdGhlciBzdWNjZWVkZWQgb3IgZXJyb3JlZC5cbiAqIEBwYXJhbSB7Q2xpZW50U2Vzc2lvbn0gW29wdGlvbnMuc2Vzc2lvbj1udWxsXSBUaGUgc2Vzc2lvbiBhc3NvY2lhdGVkIHdpdGggdGhpcyBidWxrIHdyaXRlLiBTZWUgW3RyYW5zYWN0aW9ucyBkb2NzXShodHRwczovL21vbmdvb3NlanMuY29tL2RvY3MvdHJhbnNhY3Rpb25zLmh0bWwpLlxuICogQHBhcmFtIHtTdHJpbmd8bnVtYmVyfSBbb3B0aW9ucy53PTFdIFRoZSBbd3JpdGUgY29uY2Vybl0oaHR0cHM6Ly93d3cubW9uZ29kYi5jb20vZG9jcy9tYW51YWwvcmVmZXJlbmNlL3dyaXRlLWNvbmNlcm4vKS4gU2VlIFtgUXVlcnkjdygpYF0oaHR0cHM6Ly9tb25nb29zZWpzLmNvbS9kb2NzL2FwaS9xdWVyeS5odG1sI1F1ZXJ5LnByb3RvdHlwZS53KCkpIGZvciBtb3JlIGluZm9ybWF0aW9uLlxuICogQHBhcmFtIHtudW1iZXJ9IFtvcHRpb25zLnd0aW1lb3V0PW51bGxdIFRoZSBbd3JpdGUgY29uY2VybiB0aW1lb3V0XShodHRwczovL3d3dy5tb25nb2RiLmNvbS9kb2NzL21hbnVhbC9yZWZlcmVuY2Uvd3JpdGUtY29uY2Vybi8jd3RpbWVvdXQpLlxuICogQHBhcmFtIHtCb29sZWFufSBbb3B0aW9ucy5qPXRydWVdIElmIGZhbHNlLCBkaXNhYmxlIFtqb3VybmFsIGFja25vd2xlZGdlbWVudF0oaHR0cHM6Ly93d3cubW9uZ29kYi5jb20vZG9jcy9tYW51YWwvcmVmZXJlbmNlL3dyaXRlLWNvbmNlcm4vI2otb3B0aW9uKVxuICogQHBhcmFtIHtCb29sZWFufSBbb3B0aW9ucy5za2lwVmFsaWRhdGlvbj1mYWxzZV0gU2V0IHRvIHRydWUgdG8gc2tpcCBNb25nb29zZSBzY2hlbWEgdmFsaWRhdGlvbiBvbiBidWxrIHdyaXRlIG9wZXJhdGlvbnMuIE1vbmdvb3NlIGN1cnJlbnRseSBydW5zIHZhbGlkYXRpb24gb24gYGluc2VydE9uZWAgYW5kIGByZXBsYWNlT25lYCBvcGVyYXRpb25zIGJ5IGRlZmF1bHQuXG4gKiBAcGFyYW0ge0Jvb2xlYW59IFtvcHRpb25zLmJ5cGFzc0RvY3VtZW50VmFsaWRhdGlvbj1mYWxzZV0gSWYgdHJ1ZSwgZGlzYWJsZSBbTW9uZ29EQiBzZXJ2ZXItc2lkZSBzY2hlbWEgdmFsaWRhdGlvbl0oaHR0cHM6Ly93d3cubW9uZ29kYi5jb20vZG9jcy9tYW51YWwvY29yZS9zY2hlbWEtdmFsaWRhdGlvbi8pIGZvciBhbGwgd3JpdGVzIGluIHRoaXMgYnVsay5cbiAqIEBwYXJhbSB7Qm9vbGVhbn0gW29wdGlvbnMudGhyb3dPblZhbGlkYXRpb25FcnJvcj1mYWxzZV0gSWYgdHJ1ZSBhbmQgYG9yZGVyZWQ6IGZhbHNlYCwgdGhyb3cgYW4gZXJyb3IgaWYgb25lIG9mIHRoZSBvcGVyYXRpb25zIGZhaWxlZCB2YWxpZGF0aW9uLCBidXQgYWxsIHZhbGlkIG9wZXJhdGlvbnMgY29tcGxldGVkIHN1Y2Nlc3NmdWxseS5cbiAqIEBwYXJhbSB7Qm9vbGVhbn0gW29wdGlvbnMuc3RyaWN0PW51bGxdIE92ZXJ3cml0ZXMgdGhlIFtgc3RyaWN0YCBvcHRpb25dKGh0dHBzOi8vbW9uZ29vc2Vqcy5jb20vZG9jcy9ndWlkZS5odG1sI3N0cmljdCkgb24gc2NoZW1hLiBJZiBmYWxzZSwgYWxsb3dzIGZpbHRlcmluZyBhbmQgd3JpdGluZyBmaWVsZHMgbm90IGRlZmluZWQgaW4gdGhlIHNjaGVtYSBmb3IgYWxsIHdyaXRlcyBpbiB0aGlzIGJ1bGsuXG4gKiBAcmV0dXJuIHtQcm9taXNlfSByZXNvbHZlcyB0byBhIFtgQnVsa1dyaXRlT3BSZXN1bHRgXShodHRwczovL21vbmdvZGIuZ2l0aHViLmlvL25vZGUtbW9uZ29kYi1uYXRpdmUvNC45L2NsYXNzZXMvQnVsa1dyaXRlUmVzdWx0Lmh0bWwpIGlmIHRoZSBvcGVyYXRpb24gc3VjY2VlZHNcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuTW9kZWwuYnVsa1dyaXRlID0gYXN5bmMgZnVuY3Rpb24gYnVsa1dyaXRlKG9wcywgb3B0aW9ucykge1xuICBfY2hlY2tDb250ZXh0KHRoaXMsICdidWxrV3JpdGUnKTtcblxuICBpZiAodHlwZW9mIG9wdGlvbnMgPT09ICdmdW5jdGlvbicgfHxcbiAgICAgIHR5cGVvZiBhcmd1bWVudHNbMl0gPT09ICdmdW5jdGlvbicpIHtcbiAgICB0aHJvdyBuZXcgTW9uZ29vc2VFcnJvcignTW9kZWwuYnVsa1dyaXRlKCkgbm8gbG9uZ2VyIGFjY2VwdHMgYSBjYWxsYmFjaycpO1xuICB9XG4gIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICBjb25zdCBvcmRlcmVkID0gb3B0aW9ucy5vcmRlcmVkID09IG51bGwgPyB0cnVlIDogb3B0aW9ucy5vcmRlcmVkO1xuXG4gIGNvbnN0IHZhbGlkYXRpb25zID0gb3BzLm1hcChvcCA9PiBjYXN0QnVsa1dyaXRlKHRoaXMsIG9wLCBvcHRpb25zKSk7XG5cbiAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICBpZiAob3JkZXJlZCkge1xuICAgICAgZWFjaCh2YWxpZGF0aW9ucywgKGZuLCBjYikgPT4gZm4oY2IpLCBlcnJvciA9PiB7XG4gICAgICAgIGlmIChlcnJvcikge1xuICAgICAgICAgIHJldHVybiByZWplY3QoZXJyb3IpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKG9wcy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICByZXR1cm4gcmVzb2x2ZShnZXREZWZhdWx0QnVsa3dyaXRlUmVzdWx0KCkpO1xuICAgICAgICB9XG5cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICB0aGlzLiRfX2NvbGxlY3Rpb24uYnVsa1dyaXRlKG9wcywgb3B0aW9ucywgKGVycm9yLCByZXMpID0+IHtcbiAgICAgICAgICAgIGlmIChlcnJvcikge1xuICAgICAgICAgICAgICByZXR1cm4gcmVqZWN0KGVycm9yKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmVzb2x2ZShyZXMpO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICByZXR1cm4gcmVqZWN0KGVycik7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuXG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgbGV0IHJlbWFpbmluZyA9IHZhbGlkYXRpb25zLmxlbmd0aDtcbiAgICBsZXQgdmFsaWRPcHMgPSBbXTtcbiAgICBsZXQgdmFsaWRhdGlvbkVycm9ycyA9IFtdO1xuICAgIGNvbnN0IHJlc3VsdHMgPSBbXTtcbiAgICBpZiAocmVtYWluaW5nID09PSAwKSB7XG4gICAgICBjb21wbGV0ZVVub3JkZXJlZFZhbGlkYXRpb24uY2FsbCh0aGlzKTtcbiAgICB9IGVsc2Uge1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB2YWxpZGF0aW9ucy5sZW5ndGg7ICsraSkge1xuICAgICAgICB2YWxpZGF0aW9uc1tpXSgoZXJyKSA9PiB7XG4gICAgICAgICAgaWYgKGVyciA9PSBudWxsKSB7XG4gICAgICAgICAgICB2YWxpZE9wcy5wdXNoKGkpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB2YWxpZGF0aW9uRXJyb3JzLnB1c2goeyBpbmRleDogaSwgZXJyb3I6IGVyciB9KTtcbiAgICAgICAgICAgIHJlc3VsdHNbaV0gPSBlcnI7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICgtLXJlbWFpbmluZyA8PSAwKSB7XG4gICAgICAgICAgICBjb21wbGV0ZVVub3JkZXJlZFZhbGlkYXRpb24uY2FsbCh0aGlzKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1cblxuICAgIHZhbGlkYXRpb25FcnJvcnMgPSB2YWxpZGF0aW9uRXJyb3JzLlxuICAgICAgc29ydCgodjEsIHYyKSA9PiB2MS5pbmRleCAtIHYyLmluZGV4KS5cbiAgICAgIG1hcCh2ID0+IHYuZXJyb3IpO1xuXG4gICAgZnVuY3Rpb24gY29tcGxldGVVbm9yZGVyZWRWYWxpZGF0aW9uKCkge1xuICAgICAgY29uc3QgdmFsaWRPcEluZGV4ZXMgPSB2YWxpZE9wcztcbiAgICAgIHZhbGlkT3BzID0gdmFsaWRPcHMuc29ydCgpLm1hcChpbmRleCA9PiBvcHNbaW5kZXhdKTtcblxuICAgICAgaWYgKHZhbGlkT3BzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICByZXR1cm4gcmVzb2x2ZShnZXREZWZhdWx0QnVsa3dyaXRlUmVzdWx0KCkpO1xuICAgICAgfVxuXG4gICAgICB0aGlzLiRfX2NvbGxlY3Rpb24uYnVsa1dyaXRlKHZhbGlkT3BzLCBvcHRpb25zLCAoZXJyb3IsIHJlcykgPT4ge1xuICAgICAgICBpZiAoZXJyb3IpIHtcbiAgICAgICAgICBpZiAodmFsaWRhdGlvbkVycm9ycy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICBlcnJvci5tb25nb29zZSA9IGVycm9yLm1vbmdvb3NlIHx8IHt9O1xuICAgICAgICAgICAgZXJyb3IubW9uZ29vc2UudmFsaWRhdGlvbkVycm9ycyA9IHZhbGlkYXRpb25FcnJvcnM7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmV0dXJuIHJlamVjdChlcnJvcik7XG4gICAgICAgIH1cblxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHZhbGlkT3BJbmRleGVzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgcmVzdWx0c1t2YWxpZE9wSW5kZXhlc1tpXV0gPSBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGlmICh2YWxpZGF0aW9uRXJyb3JzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICBpZiAob3B0aW9ucy50aHJvd09uVmFsaWRhdGlvbkVycm9yKSB7XG4gICAgICAgICAgICByZXR1cm4gcmVqZWN0KG5ldyBNb25nb29zZUJ1bGtXcml0ZUVycm9yKFxuICAgICAgICAgICAgICB2YWxpZGF0aW9uRXJyb3JzLFxuICAgICAgICAgICAgICByZXN1bHRzLFxuICAgICAgICAgICAgICByZXMsXG4gICAgICAgICAgICAgICdidWxrV3JpdGUnXG4gICAgICAgICAgICApKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmVzLm1vbmdvb3NlID0gcmVzLm1vbmdvb3NlIHx8IHt9O1xuICAgICAgICAgICAgcmVzLm1vbmdvb3NlLnZhbGlkYXRpb25FcnJvcnMgPSB2YWxpZGF0aW9uRXJyb3JzO1xuICAgICAgICAgICAgcmVzLm1vbmdvb3NlLnJlc3VsdHMgPSByZXN1bHRzO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJlc29sdmUocmVzKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfSk7XG59O1xuXG4vKipcbiAqICB0YWtlcyBhbiBhcnJheSBvZiBkb2N1bWVudHMsIGdldHMgdGhlIGNoYW5nZXMgYW5kIGluc2VydHMvdXBkYXRlcyBkb2N1bWVudHMgaW4gdGhlIGRhdGFiYXNlXG4gKiAgYWNjb3JkaW5nIHRvIHdoZXRoZXIgb3Igbm90IHRoZSBkb2N1bWVudCBpcyBuZXcsIG9yIHdoZXRoZXIgaXQgaGFzIGNoYW5nZXMgb3Igbm90LlxuICpcbiAqIGBidWxrU2F2ZWAgdXNlcyBgYnVsa1dyaXRlYCB1bmRlciB0aGUgaG9vZCwgc28gaXQncyBtb3N0bHkgdXNlZnVsIHdoZW4gZGVhbGluZyB3aXRoIG1hbnkgZG9jdW1lbnRzICgxMEsrKVxuICpcbiAqIEBwYXJhbSB7QXJyYXk8RG9jdW1lbnQ+fSBkb2N1bWVudHNcbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gb3B0aW9ucyBwYXNzZWQgdG8gdGhlIHVuZGVybHlpbmcgYGJ1bGtXcml0ZSgpYFxuICogQHBhcmFtIHtCb29sZWFufSBbb3B0aW9ucy50aW1lc3RhbXBzXSBkZWZhdWx0cyB0byBgbnVsbGAsIHdoZW4gc2V0IHRvIGZhbHNlLCBtb25nb29zZSB3aWxsIG5vdCBhZGQvdXBkYXRlIHRpbWVzdGFtcHMgdG8gdGhlIGRvY3VtZW50cy5cbiAqIEBwYXJhbSB7Q2xpZW50U2Vzc2lvbn0gW29wdGlvbnMuc2Vzc2lvbj1udWxsXSBUaGUgc2Vzc2lvbiBhc3NvY2lhdGVkIHdpdGggdGhpcyBidWxrIHdyaXRlLiBTZWUgW3RyYW5zYWN0aW9ucyBkb2NzXShodHRwczovL21vbmdvb3NlanMuY29tL2RvY3MvdHJhbnNhY3Rpb25zLmh0bWwpLlxuICogQHBhcmFtIHtTdHJpbmd8bnVtYmVyfSBbb3B0aW9ucy53PTFdIFRoZSBbd3JpdGUgY29uY2Vybl0oaHR0cHM6Ly93d3cubW9uZ29kYi5jb20vZG9jcy9tYW51YWwvcmVmZXJlbmNlL3dyaXRlLWNvbmNlcm4vKS4gU2VlIFtgUXVlcnkjdygpYF0oaHR0cHM6Ly9tb25nb29zZWpzLmNvbS9kb2NzL2FwaS9xdWVyeS5odG1sI1F1ZXJ5LnByb3RvdHlwZS53KCkpIGZvciBtb3JlIGluZm9ybWF0aW9uLlxuICogQHBhcmFtIHtudW1iZXJ9IFtvcHRpb25zLnd0aW1lb3V0PW51bGxdIFRoZSBbd3JpdGUgY29uY2VybiB0aW1lb3V0XShodHRwczovL3d3dy5tb25nb2RiLmNvbS9kb2NzL21hbnVhbC9yZWZlcmVuY2Uvd3JpdGUtY29uY2Vybi8jd3RpbWVvdXQpLlxuICogQHBhcmFtIHtCb29sZWFufSBbb3B0aW9ucy5qPXRydWVdIElmIGZhbHNlLCBkaXNhYmxlIFtqb3VybmFsIGFja25vd2xlZGdlbWVudF0oaHR0cHM6Ly93d3cubW9uZ29kYi5jb20vZG9jcy9tYW51YWwvcmVmZXJlbmNlL3dyaXRlLWNvbmNlcm4vI2otb3B0aW9uKVxuICpcbiAqL1xuTW9kZWwuYnVsa1NhdmUgPSBhc3luYyBmdW5jdGlvbiBidWxrU2F2ZShkb2N1bWVudHMsIG9wdGlvbnMpIHtcbiAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG5cbiAgaWYgKG9wdGlvbnMudGltZXN0YW1wcyAhPSBudWxsKSB7XG4gICAgZm9yIChjb25zdCBkb2N1bWVudCBvZiBkb2N1bWVudHMpIHtcbiAgICAgIGRvY3VtZW50LiRfXy5zYXZlT3B0aW9ucyA9IGRvY3VtZW50LiRfXy5zYXZlT3B0aW9ucyB8fCB7fTtcbiAgICAgIGRvY3VtZW50LiRfXy5zYXZlT3B0aW9ucy50aW1lc3RhbXBzID0gb3B0aW9ucy50aW1lc3RhbXBzO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBmb3IgKGNvbnN0IGRvY3VtZW50IG9mIGRvY3VtZW50cykge1xuICAgICAgaWYgKGRvY3VtZW50LiRfXy50aW1lc3RhbXBzICE9IG51bGwpIHtcbiAgICAgICAgZG9jdW1lbnQuJF9fLnNhdmVPcHRpb25zID0gZG9jdW1lbnQuJF9fLnNhdmVPcHRpb25zIHx8IHt9O1xuICAgICAgICBkb2N1bWVudC4kX18uc2F2ZU9wdGlvbnMudGltZXN0YW1wcyA9IGRvY3VtZW50LiRfXy50aW1lc3RhbXBzO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGF3YWl0IFByb21pc2UuYWxsKGRvY3VtZW50cy5tYXAoYnVpbGRQcmVTYXZlUHJvbWlzZSkpO1xuXG4gIGNvbnN0IHdyaXRlT3BlcmF0aW9ucyA9IHRoaXMuYnVpbGRCdWxrV3JpdGVPcGVyYXRpb25zKGRvY3VtZW50cywgeyBza2lwVmFsaWRhdGlvbjogdHJ1ZSwgdGltZXN0YW1wczogb3B0aW9ucy50aW1lc3RhbXBzIH0pO1xuXG4gIGNvbnN0IHsgYnVsa1dyaXRlUmVzdWx0LCBidWxrV3JpdGVFcnJvciB9ID0gYXdhaXQgdGhpcy5idWxrV3JpdGUod3JpdGVPcGVyYXRpb25zLCBvcHRpb25zKS50aGVuKFxuICAgIChyZXMpID0+ICh7IGJ1bGtXcml0ZVJlc3VsdDogcmVzLCBidWxrV3JpdGVFcnJvcjogbnVsbCB9KSxcbiAgICAoZXJyKSA9PiAoeyBidWxrV3JpdGVSZXN1bHQ6IG51bGwsIGJ1bGtXcml0ZUVycm9yOiBlcnIgfSlcbiAgKTtcblxuICBhd2FpdCBQcm9taXNlLmFsbChcbiAgICBkb2N1bWVudHMubWFwKGFzeW5jKGRvY3VtZW50KSA9PiB7XG4gICAgICBjb25zdCBkb2N1bWVudEVycm9yID0gYnVsa1dyaXRlRXJyb3IgJiYgYnVsa1dyaXRlRXJyb3Iud3JpdGVFcnJvcnMuZmluZCh3cml0ZUVycm9yID0+IHtcbiAgICAgICAgY29uc3Qgd3JpdGVFcnJvckRvY3VtZW50SWQgPSB3cml0ZUVycm9yLmVyci5vcC5faWQgfHwgd3JpdGVFcnJvci5lcnIub3AucS5faWQ7XG4gICAgICAgIHJldHVybiB3cml0ZUVycm9yRG9jdW1lbnRJZC50b1N0cmluZygpID09PSBkb2N1bWVudC5faWQudG9TdHJpbmcoKTtcbiAgICAgIH0pO1xuXG4gICAgICBpZiAoZG9jdW1lbnRFcnJvciA9PSBudWxsKSB7XG4gICAgICAgIGF3YWl0IGhhbmRsZVN1Y2Nlc3NmdWxXcml0ZShkb2N1bWVudCk7XG4gICAgICB9XG4gICAgfSlcbiAgKTtcblxuICBpZiAoYnVsa1dyaXRlRXJyb3IgJiYgYnVsa1dyaXRlRXJyb3Iud3JpdGVFcnJvcnMgJiYgYnVsa1dyaXRlRXJyb3Iud3JpdGVFcnJvcnMubGVuZ3RoKSB7XG4gICAgdGhyb3cgYnVsa1dyaXRlRXJyb3I7XG4gIH1cblxuICByZXR1cm4gYnVsa1dyaXRlUmVzdWx0O1xufTtcblxuZnVuY3Rpb24gYnVpbGRQcmVTYXZlUHJvbWlzZShkb2N1bWVudCkge1xuICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgIGRvY3VtZW50LnNjaGVtYS5zLmhvb2tzLmV4ZWNQcmUoJ3NhdmUnLCBkb2N1bWVudCwgKGVycikgPT4ge1xuICAgICAgaWYgKGVycikge1xuICAgICAgICByZWplY3QoZXJyKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgcmVzb2x2ZSgpO1xuICAgIH0pO1xuICB9KTtcbn1cblxuZnVuY3Rpb24gaGFuZGxlU3VjY2Vzc2Z1bFdyaXRlKGRvY3VtZW50KSB7XG4gIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgaWYgKGRvY3VtZW50LiRpc05ldykge1xuICAgICAgX3NldElzTmV3KGRvY3VtZW50LCBmYWxzZSk7XG4gICAgfVxuXG4gICAgZG9jdW1lbnQuJF9fcmVzZXQoKTtcbiAgICBkb2N1bWVudC5zY2hlbWEucy5ob29rcy5leGVjUG9zdCgnc2F2ZScsIGRvY3VtZW50LCBbZG9jdW1lbnRdLCB7fSwgKGVycikgPT4ge1xuICAgICAgaWYgKGVycikge1xuICAgICAgICByZWplY3QoZXJyKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgcmVzb2x2ZSgpO1xuICAgIH0pO1xuXG4gIH0pO1xufVxuXG4vKipcbiAqIEFwcGx5IGRlZmF1bHRzIHRvIHRoZSBnaXZlbiBkb2N1bWVudCBvciBQT0pPLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fERvY3VtZW50fSBvYmogb2JqZWN0IG9yIGRvY3VtZW50IHRvIGFwcGx5IGRlZmF1bHRzIG9uXG4gKiBAcmV0dXJucyB7T2JqZWN0fERvY3VtZW50fVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5Nb2RlbC5hcHBseURlZmF1bHRzID0gZnVuY3Rpb24gYXBwbHlEZWZhdWx0cyhkb2MpIHtcbiAgaWYgKGRvYy4kX18gIT0gbnVsbCkge1xuICAgIGFwcGx5RGVmYXVsdHNIZWxwZXIoZG9jLCBkb2MuJF9fLmZpZWxkcywgZG9jLiRfXy5leGNsdWRlKTtcblxuICAgIGZvciAoY29uc3Qgc3ViZG9jIG9mIGRvYy4kZ2V0QWxsU3ViZG9jcygpKSB7XG4gICAgICBhcHBseURlZmF1bHRzKHN1YmRvYywgc3ViZG9jLiRfXy5maWVsZHMsIHN1YmRvYy4kX18uZXhjbHVkZSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGRvYztcbiAgfVxuXG4gIGFwcGx5RGVmYXVsdHNUb1BPSk8oZG9jLCB0aGlzLnNjaGVtYSk7XG5cbiAgcmV0dXJuIGRvYztcbn07XG5cbi8qKlxuICogQ2FzdCB0aGUgZ2l2ZW4gUE9KTyB0byB0aGUgbW9kZWwncyBzY2hlbWFcbiAqXG4gKiAjIyMjIEV4YW1wbGU6XG4gKlxuICogICAgIGNvbnN0IFRlc3QgPSBtb25nb29zZS5tb2RlbCgnVGVzdCcsIFNjaGVtYSh7IG51bTogTnVtYmVyIH0pKTtcbiAqXG4gKiAgICAgY29uc3Qgb2JqID0gVGVzdC5jYXN0T2JqZWN0KHsgbnVtOiAnNDInIH0pO1xuICogICAgIG9iai5udW07IC8vIDQyIGFzIGEgbnVtYmVyXG4gKlxuICogICAgIFRlc3QuY2FzdE9iamVjdCh7IG51bTogJ25vdCBhIG51bWJlcicgfSk7IC8vIFRocm93cyBhIFZhbGlkYXRpb25FcnJvclxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmogb2JqZWN0IG9yIGRvY3VtZW50IHRvIGNhc3RcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIG9wdGlvbnMgcGFzc2VkIHRvIGNhc3RPYmplY3RcbiAqIEBwYXJhbSB7Qm9vbGVhbn0gb3B0aW9ucy5pZ25vcmVDYXN0RXJyb3JzIElmIHNldCB0byBgdHJ1ZWAgd2lsbCBub3QgdGhyb3cgYSBWYWxpZGF0aW9uRXJyb3IgYW5kIG9ubHkgcmV0dXJuIHZhbHVlcyB0aGF0IHdlcmUgc3VjY2Vzc2Z1bGx5IGNhc3QuXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBQT0pPIGNhc3RlZCB0byB0aGUgbW9kZWwncyBzY2hlbWFcbiAqIEB0aHJvd3Mge1ZhbGlkYXRpb25FcnJvcn0gaWYgY2FzdGluZyBmYWlsZWQgZm9yIGF0IGxlYXN0IG9uZSBwYXRoXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbk1vZGVsLmNhc3RPYmplY3QgPSBmdW5jdGlvbiBjYXN0T2JqZWN0KG9iaiwgb3B0aW9ucykge1xuICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgY29uc3QgcmV0ID0ge307XG5cbiAgY29uc3Qgc2NoZW1hID0gdGhpcy5zY2hlbWE7XG4gIGNvbnN0IHBhdGhzID0gT2JqZWN0LmtleXMoc2NoZW1hLnBhdGhzKTtcblxuICBmb3IgKGNvbnN0IHBhdGggb2YgcGF0aHMpIHtcbiAgICBjb25zdCBzY2hlbWFUeXBlID0gc2NoZW1hLnBhdGgocGF0aCk7XG4gICAgaWYgKCFzY2hlbWFUeXBlIHx8ICFzY2hlbWFUeXBlLiRpc01vbmdvb3NlQXJyYXkpIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIGNvbnN0IHZhbCA9IGdldChvYmosIHBhdGgpO1xuICAgIHB1c2hOZXN0ZWRBcnJheVBhdGhzKHBhdGhzLCB2YWwsIHBhdGgpO1xuICB9XG5cbiAgbGV0IGVycm9yID0gbnVsbDtcblxuICBmb3IgKGNvbnN0IHBhdGggb2YgcGF0aHMpIHtcbiAgICBjb25zdCBzY2hlbWFUeXBlID0gc2NoZW1hLnBhdGgocGF0aCk7XG4gICAgaWYgKHNjaGVtYVR5cGUgPT0gbnVsbCkge1xuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgbGV0IHZhbCA9IGdldChvYmosIHBhdGgsIHZvaWQgMCk7XG5cbiAgICBpZiAodmFsID09IG51bGwpIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIGNvbnN0IHBpZWNlcyA9IHBhdGguaW5kZXhPZignLicpID09PSAtMSA/IFtwYXRoXSA6IHBhdGguc3BsaXQoJy4nKTtcbiAgICBsZXQgY3VyID0gcmV0O1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcGllY2VzLmxlbmd0aCAtIDE7ICsraSkge1xuICAgICAgaWYgKGN1cltwaWVjZXNbaV1dID09IG51bGwpIHtcbiAgICAgICAgY3VyW3BpZWNlc1tpXV0gPSBpc05hTihwaWVjZXNbaSArIDFdKSA/IHt9IDogW107XG4gICAgICB9XG4gICAgICBjdXIgPSBjdXJbcGllY2VzW2ldXTtcbiAgICB9XG5cbiAgICBpZiAoc2NoZW1hVHlwZS4kaXNNb25nb29zZURvY3VtZW50QXJyYXkpIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICBpZiAoc2NoZW1hVHlwZS4kaXNTaW5nbGVOZXN0ZWQgfHwgc2NoZW1hVHlwZS4kaXNNb25nb29zZURvY3VtZW50QXJyYXlFbGVtZW50KSB7XG4gICAgICB0cnkge1xuICAgICAgICB2YWwgPSBNb2RlbC5jYXN0T2JqZWN0LmNhbGwoc2NoZW1hVHlwZS5jYXN0ZXIsIHZhbCk7XG4gICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgaWYgKCFvcHRpb25zLmlnbm9yZUNhc3RFcnJvcnMpIHtcbiAgICAgICAgICBlcnJvciA9IGVycm9yIHx8IG5ldyBWYWxpZGF0aW9uRXJyb3IoKTtcbiAgICAgICAgICBlcnJvci5hZGRFcnJvcihwYXRoLCBlcnIpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuXG4gICAgICBjdXJbcGllY2VzW3BpZWNlcy5sZW5ndGggLSAxXV0gPSB2YWw7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICB0cnkge1xuICAgICAgdmFsID0gc2NoZW1hVHlwZS5jYXN0KHZhbCk7XG4gICAgICBjdXJbcGllY2VzW3BpZWNlcy5sZW5ndGggLSAxXV0gPSB2YWw7XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICBpZiAoIW9wdGlvbnMuaWdub3JlQ2FzdEVycm9ycykge1xuICAgICAgICBlcnJvciA9IGVycm9yIHx8IG5ldyBWYWxpZGF0aW9uRXJyb3IoKTtcbiAgICAgICAgZXJyb3IuYWRkRXJyb3IocGF0aCwgZXJyKTtcbiAgICAgIH1cblxuICAgICAgY29udGludWU7XG4gICAgfVxuICB9XG5cbiAgaWYgKGVycm9yICE9IG51bGwpIHtcbiAgICB0aHJvdyBlcnJvcjtcbiAgfVxuXG4gIHJldHVybiByZXQ7XG59O1xuXG4vKipcbiAqIEJ1aWxkIGJ1bGsgd3JpdGUgb3BlcmF0aW9ucyBmb3IgYGJ1bGtTYXZlKClgLlxuICpcbiAqIEBwYXJhbSB7QXJyYXk8RG9jdW1lbnQ+fSBkb2N1bWVudHMgVGhlIGFycmF5IG9mIGRvY3VtZW50cyB0byBidWlsZCB3cml0ZSBvcGVyYXRpb25zIG9mXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xuICogQHBhcmFtIHtCb29sZWFufSBvcHRpb25zLnNraXBWYWxpZGF0aW9uIGRlZmF1bHRzIHRvIGBmYWxzZWAsIHdoZW4gc2V0IHRvIHRydWUsIGJ1aWxkaW5nIHRoZSB3cml0ZSBvcGVyYXRpb25zIHdpbGwgYnlwYXNzIHZhbGlkYXRpbmcgdGhlIGRvY3VtZW50cy5cbiAqIEBwYXJhbSB7Qm9vbGVhbn0gb3B0aW9ucy50aW1lc3RhbXBzIGRlZmF1bHRzIHRvIGBudWxsYCwgd2hlbiBzZXQgdG8gZmFsc2UsIG1vbmdvb3NlIHdpbGwgbm90IGFkZC91cGRhdGUgdGltZXN0YW1wcyB0byB0aGUgZG9jdW1lbnRzLlxuICogQHJldHVybiB7QXJyYXk8UHJvbWlzZT59IFJldHVybnMgYSBhcnJheSBvZiBhbGwgUHJvbWlzZXMgdGhlIGZ1bmN0aW9uIGV4ZWN1dGVzIHRvIGJlIGF3YWl0ZWQuXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5Nb2RlbC5idWlsZEJ1bGtXcml0ZU9wZXJhdGlvbnMgPSBmdW5jdGlvbiBidWlsZEJ1bGtXcml0ZU9wZXJhdGlvbnMoZG9jdW1lbnRzLCBvcHRpb25zKSB7XG4gIGlmICghQXJyYXkuaXNBcnJheShkb2N1bWVudHMpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBidWxrU2F2ZSBleHBlY3RzIGFuIGFycmF5IG9mIGRvY3VtZW50cyB0byBiZSBwYXNzZWQsIHJlY2VpdmVkIFxcYCR7ZG9jdW1lbnRzfVxcYCBpbnN0ZWFkYCk7XG4gIH1cblxuICBzZXREZWZhdWx0T3B0aW9ucygpO1xuICBjb25zdCBkaXNjcmltaW5hdG9yS2V5ID0gdGhpcy5zY2hlbWEub3B0aW9ucy5kaXNjcmltaW5hdG9yS2V5O1xuXG4gIGNvbnN0IHdyaXRlT3BlcmF0aW9ucyA9IGRvY3VtZW50cy5yZWR1Y2UoKGFjY3VtdWxhdG9yLCBkb2N1bWVudCwgaSkgPT4ge1xuICAgIGlmICghb3B0aW9ucy5za2lwVmFsaWRhdGlvbikge1xuICAgICAgaWYgKCEoZG9jdW1lbnQgaW5zdGFuY2VvZiBEb2N1bWVudCkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBkb2N1bWVudHMuJHtpfSB3YXMgbm90IGEgbW9uZ29vc2UgZG9jdW1lbnQsIGRvY3VtZW50cyBtdXN0IGJlIGFuIGFycmF5IG9mIG1vbmdvb3NlIGRvY3VtZW50cyAoaW5zdGFuY2VvZiBtb25nb29zZS5Eb2N1bWVudCkuYCk7XG4gICAgICB9XG4gICAgICBjb25zdCB2YWxpZGF0aW9uRXJyb3IgPSBkb2N1bWVudC52YWxpZGF0ZVN5bmMoKTtcbiAgICAgIGlmICh2YWxpZGF0aW9uRXJyb3IpIHtcbiAgICAgICAgdGhyb3cgdmFsaWRhdGlvbkVycm9yO1xuICAgICAgfVxuICAgIH1cblxuICAgIGNvbnN0IGlzQU5ld0RvY3VtZW50ID0gZG9jdW1lbnQuaXNOZXc7XG4gICAgaWYgKGlzQU5ld0RvY3VtZW50KSB7XG4gICAgICBjb25zdCB3cml0ZU9wZXJhdGlvbiA9IHsgaW5zZXJ0T25lOiB7IGRvY3VtZW50IH0gfTtcbiAgICAgIHV0aWxzLmluamVjdFRpbWVzdGFtcHNPcHRpb24od3JpdGVPcGVyYXRpb24uaW5zZXJ0T25lLCBvcHRpb25zLnRpbWVzdGFtcHMpO1xuICAgICAgYWNjdW11bGF0b3IucHVzaCh3cml0ZU9wZXJhdGlvbik7XG5cbiAgICAgIHJldHVybiBhY2N1bXVsYXRvcjtcbiAgICB9XG5cbiAgICBjb25zdCBkZWx0YSA9IGRvY3VtZW50LiRfX2RlbHRhKCk7XG4gICAgY29uc3QgaXNEb2N1bWVudFdpdGhDaGFuZ2VzID0gZGVsdGEgIT0gbnVsbCAmJiAhdXRpbHMuaXNFbXB0eU9iamVjdChkZWx0YVswXSk7XG5cbiAgICBpZiAoaXNEb2N1bWVudFdpdGhDaGFuZ2VzKSB7XG4gICAgICBjb25zdCB3aGVyZSA9IGRvY3VtZW50LiRfX3doZXJlKGRlbHRhWzBdKTtcbiAgICAgIGNvbnN0IGNoYW5nZXMgPSBkZWx0YVsxXTtcblxuICAgICAgX2FwcGx5Q3VzdG9tV2hlcmUoZG9jdW1lbnQsIHdoZXJlKTtcblxuICAgICAgLy8gU2V0IHRoZSBkaXNjcmltaW5hdG9yIGtleSwgc28gYnVsayB3cml0ZSBjYXN0aW5nIGtub3dzIHdoaWNoXG4gICAgICAvLyBzY2hlbWEgdG8gdXNlIHJlOiBnaC0xMzkwN1xuICAgICAgaWYgKGRvY3VtZW50W2Rpc2NyaW1pbmF0b3JLZXldICE9IG51bGwgJiYgIShkaXNjcmltaW5hdG9yS2V5IGluIHdoZXJlKSkge1xuICAgICAgICB3aGVyZVtkaXNjcmltaW5hdG9yS2V5XSA9IGRvY3VtZW50W2Rpc2NyaW1pbmF0b3JLZXldO1xuICAgICAgfVxuXG4gICAgICBkb2N1bWVudC4kX192ZXJzaW9uKHdoZXJlLCBkZWx0YSk7XG4gICAgICBjb25zdCB3cml0ZU9wZXJhdGlvbiA9IHsgdXBkYXRlT25lOiB7IGZpbHRlcjogd2hlcmUsIHVwZGF0ZTogY2hhbmdlcyB9IH07XG4gICAgICB1dGlscy5pbmplY3RUaW1lc3RhbXBzT3B0aW9uKHdyaXRlT3BlcmF0aW9uLnVwZGF0ZU9uZSwgb3B0aW9ucy50aW1lc3RhbXBzKTtcbiAgICAgIGFjY3VtdWxhdG9yLnB1c2god3JpdGVPcGVyYXRpb24pO1xuXG4gICAgICByZXR1cm4gYWNjdW11bGF0b3I7XG4gICAgfVxuXG4gICAgcmV0dXJuIGFjY3VtdWxhdG9yO1xuICB9LCBbXSk7XG5cbiAgcmV0dXJuIHdyaXRlT3BlcmF0aW9ucztcblxuXG4gIGZ1bmN0aW9uIHNldERlZmF1bHRPcHRpb25zKCkge1xuICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICAgIGlmIChvcHRpb25zLnNraXBWYWxpZGF0aW9uID09IG51bGwpIHtcbiAgICAgIG9wdGlvbnMuc2tpcFZhbGlkYXRpb24gPSBmYWxzZTtcbiAgICB9XG4gIH1cbn07XG5cblxuLyoqXG4gKiBTaG9ydGN1dCBmb3IgY3JlYXRpbmcgYSBuZXcgRG9jdW1lbnQgZnJvbSBleGlzdGluZyByYXcgZGF0YSwgcHJlLXNhdmVkIGluIHRoZSBEQi5cbiAqIFRoZSBkb2N1bWVudCByZXR1cm5lZCBoYXMgbm8gcGF0aHMgbWFya2VkIGFzIG1vZGlmaWVkIGluaXRpYWxseS5cbiAqXG4gKiAjIyMjIEV4YW1wbGU6XG4gKlxuICogICAgIC8vIGh5ZHJhdGUgcHJldmlvdXMgZGF0YSBpbnRvIGEgTW9uZ29vc2UgZG9jdW1lbnRcbiAqICAgICBjb25zdCBtb25nb29zZUNhbmR5ID0gQ2FuZHkuaHlkcmF0ZSh7IF9pZDogJzU0MTA4MzM3MjEyZmZiNmQ0NTlmODU0YycsIHR5cGU6ICdqZWxseSBiZWFuJyB9KTtcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqXG4gKiBAcGFyYW0ge09iamVjdHxTdHJpbmd8U3RyaW5nW119IFtwcm9qZWN0aW9uXSBvcHRpb25hbCBwcm9qZWN0aW9uIGNvbnRhaW5pbmcgd2hpY2ggZmllbGRzIHNob3VsZCBiZSBzZWxlY3RlZCBmb3IgdGhpcyBkb2N1bWVudFxuICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSBvcHRpb25hbCBvcHRpb25zXG4gKiBAcGFyYW0ge0Jvb2xlYW59IFtvcHRpb25zLnNldHRlcnM9ZmFsc2VdIGlmIHRydWUsIGFwcGx5IHNjaGVtYSBzZXR0ZXJzIHdoZW4gaHlkcmF0aW5nXG4gKiBAcmV0dXJuIHtEb2N1bWVudH0gZG9jdW1lbnQgaW5zdGFuY2VcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuTW9kZWwuaHlkcmF0ZSA9IGZ1bmN0aW9uKG9iaiwgcHJvamVjdGlvbiwgb3B0aW9ucykge1xuICBfY2hlY2tDb250ZXh0KHRoaXMsICdoeWRyYXRlJyk7XG5cbiAgaWYgKHByb2plY3Rpb24gIT0gbnVsbCkge1xuICAgIGlmIChvYmogIT0gbnVsbCAmJiBvYmouJF9fICE9IG51bGwpIHtcbiAgICAgIG9iaiA9IG9iai50b09iamVjdChpbnRlcm5hbFRvT2JqZWN0T3B0aW9ucyk7XG4gICAgfVxuICAgIG9iaiA9IGFwcGx5UHJvamVjdGlvbihvYmosIHByb2plY3Rpb24pO1xuICB9XG5cbiAgY29uc3QgZG9jdW1lbnQgPSByZXF1aXJlKCcuL3F1ZXJ5SGVscGVycycpLmNyZWF0ZU1vZGVsKHRoaXMsIG9iaiwgcHJvamVjdGlvbik7XG4gIGRvY3VtZW50LiRpbml0KG9iaiwgb3B0aW9ucyk7XG4gIHJldHVybiBkb2N1bWVudDtcbn07XG5cbi8qKlxuICogU2FtZSBhcyBgdXBkYXRlT25lKClgLCBleGNlcHQgTW9uZ29EQiB3aWxsIHVwZGF0ZSBfYWxsXyBkb2N1bWVudHMgdGhhdCBtYXRjaFxuICogYGZpbHRlcmAgKGFzIG9wcG9zZWQgdG8ganVzdCB0aGUgZmlyc3Qgb25lKSByZWdhcmRsZXNzIG9mIHRoZSB2YWx1ZSBvZlxuICogdGhlIGBtdWx0aWAgb3B0aW9uLlxuICpcbiAqICoqTm90ZSoqIHVwZGF0ZU1hbnkgd2lsbCBfbm90XyBmaXJlIHVwZGF0ZSBtaWRkbGV3YXJlLiBVc2UgYHByZSgndXBkYXRlTWFueScpYFxuICogYW5kIGBwb3N0KCd1cGRhdGVNYW55JylgIGluc3RlYWQuXG4gKlxuICogIyMjIyBFeGFtcGxlOlxuICpcbiAqICAgICBjb25zdCByZXMgPSBhd2FpdCBQZXJzb24udXBkYXRlTWFueSh7IG5hbWU6IC9TdGFyayQvIH0sIHsgaXNEZWxldGVkOiB0cnVlIH0pO1xuICogICAgIHJlcy5tYXRjaGVkQ291bnQ7IC8vIE51bWJlciBvZiBkb2N1bWVudHMgbWF0Y2hlZFxuICogICAgIHJlcy5tb2RpZmllZENvdW50OyAvLyBOdW1iZXIgb2YgZG9jdW1lbnRzIG1vZGlmaWVkXG4gKiAgICAgcmVzLmFja25vd2xlZGdlZDsgLy8gQm9vbGVhbiBpbmRpY2F0aW5nIGV2ZXJ5dGhpbmcgd2VudCBzbW9vdGhseS5cbiAqICAgICByZXMudXBzZXJ0ZWRJZDsgLy8gbnVsbCBvciBhbiBpZCBjb250YWluaW5nIGEgZG9jdW1lbnQgdGhhdCBoYWQgdG8gYmUgdXBzZXJ0ZWQuXG4gKiAgICAgcmVzLnVwc2VydGVkQ291bnQ7IC8vIE51bWJlciBpbmRpY2F0aW5nIGhvdyBtYW55IGRvY3VtZW50cyBoYWQgdG8gYmUgdXBzZXJ0ZWQuIFdpbGwgZWl0aGVyIGJlIDAgb3IgMS5cbiAqXG4gKiBUaGlzIGZ1bmN0aW9uIHRyaWdnZXJzIHRoZSBmb2xsb3dpbmcgbWlkZGxld2FyZS5cbiAqXG4gKiAtIGB1cGRhdGVNYW55KClgXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IGZpbHRlclxuICogQHBhcmFtIHtPYmplY3R8QXJyYXl9IHVwZGF0ZVxuICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSBvcHRpb25hbCBzZWUgW2BRdWVyeS5wcm90b3R5cGUuc2V0T3B0aW9ucygpYF0oaHR0cHM6Ly9tb25nb29zZWpzLmNvbS9kb2NzL2FwaS9xdWVyeS5odG1sI1F1ZXJ5LnByb3RvdHlwZS5zZXRPcHRpb25zKCkpXG4gKiBAcGFyYW0ge0Jvb2xlYW58U3RyaW5nfSBbb3B0aW9ucy5zdHJpY3RdIG92ZXJ3cml0ZXMgdGhlIHNjaGVtYSdzIFtzdHJpY3QgbW9kZSBvcHRpb25dKGh0dHBzOi8vbW9uZ29vc2Vqcy5jb20vZG9jcy9ndWlkZS5odG1sI3N0cmljdClcbiAqIEBwYXJhbSB7Qm9vbGVhbn0gW29wdGlvbnMudXBzZXJ0PWZhbHNlXSBpZiB0cnVlLCBhbmQgbm8gZG9jdW1lbnRzIGZvdW5kLCBpbnNlcnQgYSBuZXcgZG9jdW1lbnRcbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9ucy53cml0ZUNvbmNlcm49bnVsbF0gc2V0cyB0aGUgW3dyaXRlIGNvbmNlcm5dKGh0dHBzOi8vd3d3Lm1vbmdvZGIuY29tL2RvY3MvbWFudWFsL3JlZmVyZW5jZS93cml0ZS1jb25jZXJuLykgZm9yIHJlcGxpY2Egc2V0cy4gT3ZlcnJpZGVzIHRoZSBbc2NoZW1hLWxldmVsIHdyaXRlIGNvbmNlcm5dKGh0dHBzOi8vbW9uZ29vc2Vqcy5jb20vZG9jcy9ndWlkZS5odG1sI3dyaXRlQ29uY2VybilcbiAqIEBwYXJhbSB7Qm9vbGVhbn0gW29wdGlvbnMudGltZXN0YW1wcz1udWxsXSBJZiBzZXQgdG8gYGZhbHNlYCBhbmQgW3NjaGVtYS1sZXZlbCB0aW1lc3RhbXBzXShodHRwczovL21vbmdvb3NlanMuY29tL2RvY3MvZ3VpZGUuaHRtbCN0aW1lc3RhbXBzKSBhcmUgZW5hYmxlZCwgc2tpcCB0aW1lc3RhbXBzIGZvciB0aGlzIHVwZGF0ZS4gRG9lcyBub3RoaW5nIGlmIHNjaGVtYS1sZXZlbCB0aW1lc3RhbXBzIGFyZSBub3Qgc2V0LlxuICogQHBhcmFtIHtCb29sZWFufSBbb3B0aW9ucy50cmFuc2xhdGVBbGlhc2VzPW51bGxdIElmIHNldCB0byBgdHJ1ZWAsIHRyYW5zbGF0ZXMgYW55IHNjaGVtYS1kZWZpbmVkIGFsaWFzZXMgaW4gYGZpbHRlcmAsIGBwcm9qZWN0aW9uYCwgYHVwZGF0ZWAsIGFuZCBgZGlzdGluY3RgLiBUaHJvd3MgYW4gZXJyb3IgaWYgdGhlcmUgYXJlIGFueSBjb25mbGljdHMgd2hlcmUgYm90aCBhbGlhcyBhbmQgcmF3IHByb3BlcnR5IGFyZSBkZWZpbmVkIG9uIHRoZSBzYW1lIG9iamVjdC5cbiAqIEByZXR1cm4ge1F1ZXJ5fVxuICogQHNlZSBRdWVyeSBkb2NzIGh0dHBzOi8vbW9uZ29vc2Vqcy5jb20vZG9jcy9xdWVyaWVzLmh0bWxcbiAqIEBzZWUgTW9uZ29EQiBkb2NzIGh0dHBzOi8vd3d3Lm1vbmdvZGIuY29tL2RvY3MvbWFudWFsL3JlZmVyZW5jZS9jb21tYW5kL3VwZGF0ZS8jdXBkYXRlLWNvbW1hbmQtb3V0cHV0XG4gKiBAc2VlIFVwZGF0ZVJlc3VsdCBodHRwczovL21vbmdvZGIuZ2l0aHViLmlvL25vZGUtbW9uZ29kYi1uYXRpdmUvNC45L2ludGVyZmFjZXMvVXBkYXRlUmVzdWx0Lmh0bWxcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuTW9kZWwudXBkYXRlTWFueSA9IGZ1bmN0aW9uIHVwZGF0ZU1hbnkoY29uZGl0aW9ucywgZG9jLCBvcHRpb25zKSB7XG4gIF9jaGVja0NvbnRleHQodGhpcywgJ3VwZGF0ZU1hbnknKTtcblxuICByZXR1cm4gX3VwZGF0ZSh0aGlzLCAndXBkYXRlTWFueScsIGNvbmRpdGlvbnMsIGRvYywgb3B0aW9ucyk7XG59O1xuXG4vKipcbiAqIFVwZGF0ZSBfb25seV8gdGhlIGZpcnN0IGRvY3VtZW50IHRoYXQgbWF0Y2hlcyBgZmlsdGVyYC5cbiAqXG4gKiAtIFVzZSBgcmVwbGFjZU9uZSgpYCBpZiB5b3Ugd2FudCB0byBvdmVyd3JpdGUgYW4gZW50aXJlIGRvY3VtZW50IHJhdGhlciB0aGFuIHVzaW5nIGF0b21pYyBvcGVyYXRvcnMgbGlrZSBgJHNldGAuXG4gKlxuICogIyMjIyBFeGFtcGxlOlxuICpcbiAqICAgICBjb25zdCByZXMgPSBhd2FpdCBQZXJzb24udXBkYXRlT25lKHsgbmFtZTogJ0plYW4tTHVjIFBpY2FyZCcgfSwgeyBzaGlwOiAnVVNTIEVudGVycHJpc2UnIH0pO1xuICogICAgIHJlcy5tYXRjaGVkQ291bnQ7IC8vIE51bWJlciBvZiBkb2N1bWVudHMgbWF0Y2hlZFxuICogICAgIHJlcy5tb2RpZmllZENvdW50OyAvLyBOdW1iZXIgb2YgZG9jdW1lbnRzIG1vZGlmaWVkXG4gKiAgICAgcmVzLmFja25vd2xlZGdlZDsgLy8gQm9vbGVhbiBpbmRpY2F0aW5nIGV2ZXJ5dGhpbmcgd2VudCBzbW9vdGhseS5cbiAqICAgICByZXMudXBzZXJ0ZWRJZDsgLy8gbnVsbCBvciBhbiBpZCBjb250YWluaW5nIGEgZG9jdW1lbnQgdGhhdCBoYWQgdG8gYmUgdXBzZXJ0ZWQuXG4gKiAgICAgcmVzLnVwc2VydGVkQ291bnQ7IC8vIE51bWJlciBpbmRpY2F0aW5nIGhvdyBtYW55IGRvY3VtZW50cyBoYWQgdG8gYmUgdXBzZXJ0ZWQuIFdpbGwgZWl0aGVyIGJlIDAgb3IgMS5cbiAqXG4gKiBUaGlzIGZ1bmN0aW9uIHRyaWdnZXJzIHRoZSBmb2xsb3dpbmcgbWlkZGxld2FyZS5cbiAqXG4gKiAtIGB1cGRhdGVPbmUoKWBcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gZmlsdGVyXG4gKiBAcGFyYW0ge09iamVjdHxBcnJheX0gdXBkYXRlXG4gKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdIG9wdGlvbmFsIHNlZSBbYFF1ZXJ5LnByb3RvdHlwZS5zZXRPcHRpb25zKClgXShodHRwczovL21vbmdvb3NlanMuY29tL2RvY3MvYXBpL3F1ZXJ5Lmh0bWwjUXVlcnkucHJvdG90eXBlLnNldE9wdGlvbnMoKSlcbiAqIEBwYXJhbSB7Qm9vbGVhbnxTdHJpbmd9IFtvcHRpb25zLnN0cmljdF0gb3ZlcndyaXRlcyB0aGUgc2NoZW1hJ3MgW3N0cmljdCBtb2RlIG9wdGlvbl0oaHR0cHM6Ly9tb25nb29zZWpzLmNvbS9kb2NzL2d1aWRlLmh0bWwjc3RyaWN0KVxuICogQHBhcmFtIHtCb29sZWFufSBbb3B0aW9ucy51cHNlcnQ9ZmFsc2VdIGlmIHRydWUsIGFuZCBubyBkb2N1bWVudHMgZm91bmQsIGluc2VydCBhIG5ldyBkb2N1bWVudFxuICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zLndyaXRlQ29uY2Vybj1udWxsXSBzZXRzIHRoZSBbd3JpdGUgY29uY2Vybl0oaHR0cHM6Ly93d3cubW9uZ29kYi5jb20vZG9jcy9tYW51YWwvcmVmZXJlbmNlL3dyaXRlLWNvbmNlcm4vKSBmb3IgcmVwbGljYSBzZXRzLiBPdmVycmlkZXMgdGhlIFtzY2hlbWEtbGV2ZWwgd3JpdGUgY29uY2Vybl0oaHR0cHM6Ly9tb25nb29zZWpzLmNvbS9kb2NzL2d1aWRlLmh0bWwjd3JpdGVDb25jZXJuKVxuICogQHBhcmFtIHtCb29sZWFufSBbb3B0aW9ucy50aW1lc3RhbXBzPW51bGxdIElmIHNldCB0byBgZmFsc2VgIGFuZCBbc2NoZW1hLWxldmVsIHRpbWVzdGFtcHNdKGh0dHBzOi8vbW9uZ29vc2Vqcy5jb20vZG9jcy9ndWlkZS5odG1sI3RpbWVzdGFtcHMpIGFyZSBlbmFibGVkLCBza2lwIHRpbWVzdGFtcHMgZm9yIHRoaXMgdXBkYXRlLiBOb3RlIHRoYXQgdGhpcyBhbGxvd3MgeW91IHRvIG92ZXJ3cml0ZSB0aW1lc3RhbXBzLiBEb2VzIG5vdGhpbmcgaWYgc2NoZW1hLWxldmVsIHRpbWVzdGFtcHMgYXJlIG5vdCBzZXQuXG4gKiBAcGFyYW0ge0Jvb2xlYW59IFtvcHRpb25zLnRyYW5zbGF0ZUFsaWFzZXM9bnVsbF0gSWYgc2V0IHRvIGB0cnVlYCwgdHJhbnNsYXRlcyBhbnkgc2NoZW1hLWRlZmluZWQgYWxpYXNlcyBpbiBgZmlsdGVyYCwgYHByb2plY3Rpb25gLCBgdXBkYXRlYCwgYW5kIGBkaXN0aW5jdGAuIFRocm93cyBhbiBlcnJvciBpZiB0aGVyZSBhcmUgYW55IGNvbmZsaWN0cyB3aGVyZSBib3RoIGFsaWFzIGFuZCByYXcgcHJvcGVydHkgYXJlIGRlZmluZWQgb24gdGhlIHNhbWUgb2JqZWN0LlxuICogQHJldHVybiB7UXVlcnl9XG4gKiBAc2VlIFF1ZXJ5IGRvY3MgaHR0cHM6Ly9tb25nb29zZWpzLmNvbS9kb2NzL3F1ZXJpZXMuaHRtbFxuICogQHNlZSBNb25nb0RCIGRvY3MgaHR0cHM6Ly93d3cubW9uZ29kYi5jb20vZG9jcy9tYW51YWwvcmVmZXJlbmNlL2NvbW1hbmQvdXBkYXRlLyN1cGRhdGUtY29tbWFuZC1vdXRwdXRcbiAqIEBzZWUgVXBkYXRlUmVzdWx0IGh0dHBzOi8vbW9uZ29kYi5naXRodWIuaW8vbm9kZS1tb25nb2RiLW5hdGl2ZS80LjkvaW50ZXJmYWNlcy9VcGRhdGVSZXN1bHQuaHRtbFxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5Nb2RlbC51cGRhdGVPbmUgPSBmdW5jdGlvbiB1cGRhdGVPbmUoY29uZGl0aW9ucywgZG9jLCBvcHRpb25zKSB7XG4gIF9jaGVja0NvbnRleHQodGhpcywgJ3VwZGF0ZU9uZScpO1xuXG4gIHJldHVybiBfdXBkYXRlKHRoaXMsICd1cGRhdGVPbmUnLCBjb25kaXRpb25zLCBkb2MsIG9wdGlvbnMpO1xufTtcblxuLyoqXG4gKiBSZXBsYWNlIHRoZSBleGlzdGluZyBkb2N1bWVudCB3aXRoIHRoZSBnaXZlbiBkb2N1bWVudCAobm8gYXRvbWljIG9wZXJhdG9ycyBsaWtlIGAkc2V0YCkuXG4gKlxuICogIyMjIyBFeGFtcGxlOlxuICpcbiAqICAgICBjb25zdCByZXMgPSBhd2FpdCBQZXJzb24ucmVwbGFjZU9uZSh7IF9pZDogMjQ2MDEgfSwgeyBuYW1lOiAnSmVhbiBWYWxqZWFuJyB9KTtcbiAqICAgICByZXMubWF0Y2hlZENvdW50OyAvLyBOdW1iZXIgb2YgZG9jdW1lbnRzIG1hdGNoZWRcbiAqICAgICByZXMubW9kaWZpZWRDb3VudDsgLy8gTnVtYmVyIG9mIGRvY3VtZW50cyBtb2RpZmllZFxuICogICAgIHJlcy5hY2tub3dsZWRnZWQ7IC8vIEJvb2xlYW4gaW5kaWNhdGluZyBldmVyeXRoaW5nIHdlbnQgc21vb3RobHkuXG4gKiAgICAgcmVzLnVwc2VydGVkSWQ7IC8vIG51bGwgb3IgYW4gaWQgY29udGFpbmluZyBhIGRvY3VtZW50IHRoYXQgaGFkIHRvIGJlIHVwc2VydGVkLlxuICogICAgIHJlcy51cHNlcnRlZENvdW50OyAvLyBOdW1iZXIgaW5kaWNhdGluZyBob3cgbWFueSBkb2N1bWVudHMgaGFkIHRvIGJlIHVwc2VydGVkLiBXaWxsIGVpdGhlciBiZSAwIG9yIDEuXG4gKlxuICogVGhpcyBmdW5jdGlvbiB0cmlnZ2VycyB0aGUgZm9sbG93aW5nIG1pZGRsZXdhcmUuXG4gKlxuICogLSBgcmVwbGFjZU9uZSgpYFxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBmaWx0ZXJcbiAqIEBwYXJhbSB7T2JqZWN0fSBkb2NcbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gb3B0aW9uYWwgc2VlIFtgUXVlcnkucHJvdG90eXBlLnNldE9wdGlvbnMoKWBdKGh0dHBzOi8vbW9uZ29vc2Vqcy5jb20vZG9jcy9hcGkvcXVlcnkuaHRtbCNRdWVyeS5wcm90b3R5cGUuc2V0T3B0aW9ucygpKVxuICogQHBhcmFtIHtCb29sZWFufFN0cmluZ30gW29wdGlvbnMuc3RyaWN0XSBvdmVyd3JpdGVzIHRoZSBzY2hlbWEncyBbc3RyaWN0IG1vZGUgb3B0aW9uXShodHRwczovL21vbmdvb3NlanMuY29tL2RvY3MvZ3VpZGUuaHRtbCNzdHJpY3QpXG4gKiBAcGFyYW0ge0Jvb2xlYW59IFtvcHRpb25zLnVwc2VydD1mYWxzZV0gaWYgdHJ1ZSwgYW5kIG5vIGRvY3VtZW50cyBmb3VuZCwgaW5zZXJ0IGEgbmV3IGRvY3VtZW50XG4gKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnMud3JpdGVDb25jZXJuPW51bGxdIHNldHMgdGhlIFt3cml0ZSBjb25jZXJuXShodHRwczovL3d3dy5tb25nb2RiLmNvbS9kb2NzL21hbnVhbC9yZWZlcmVuY2Uvd3JpdGUtY29uY2Vybi8pIGZvciByZXBsaWNhIHNldHMuIE92ZXJyaWRlcyB0aGUgW3NjaGVtYS1sZXZlbCB3cml0ZSBjb25jZXJuXShodHRwczovL21vbmdvb3NlanMuY29tL2RvY3MvZ3VpZGUuaHRtbCN3cml0ZUNvbmNlcm4pXG4gKiBAcGFyYW0ge0Jvb2xlYW59IFtvcHRpb25zLnRpbWVzdGFtcHM9bnVsbF0gSWYgc2V0IHRvIGBmYWxzZWAgYW5kIFtzY2hlbWEtbGV2ZWwgdGltZXN0YW1wc10oaHR0cHM6Ly9tb25nb29zZWpzLmNvbS9kb2NzL2d1aWRlLmh0bWwjdGltZXN0YW1wcykgYXJlIGVuYWJsZWQsIHNraXAgdGltZXN0YW1wcyBmb3IgdGhpcyB1cGRhdGUuIERvZXMgbm90aGluZyBpZiBzY2hlbWEtbGV2ZWwgdGltZXN0YW1wcyBhcmUgbm90IHNldC5cbiAqIEBwYXJhbSB7Qm9vbGVhbn0gW29wdGlvbnMudHJhbnNsYXRlQWxpYXNlcz1udWxsXSBJZiBzZXQgdG8gYHRydWVgLCB0cmFuc2xhdGVzIGFueSBzY2hlbWEtZGVmaW5lZCBhbGlhc2VzIGluIGBmaWx0ZXJgLCBgcHJvamVjdGlvbmAsIGB1cGRhdGVgLCBhbmQgYGRpc3RpbmN0YC4gVGhyb3dzIGFuIGVycm9yIGlmIHRoZXJlIGFyZSBhbnkgY29uZmxpY3RzIHdoZXJlIGJvdGggYWxpYXMgYW5kIHJhdyBwcm9wZXJ0eSBhcmUgZGVmaW5lZCBvbiB0aGUgc2FtZSBvYmplY3QuXG4gKiBAcmV0dXJuIHtRdWVyeX1cbiAqIEBzZWUgUXVlcnkgZG9jcyBodHRwczovL21vbmdvb3NlanMuY29tL2RvY3MvcXVlcmllcy5odG1sXG4gKiBAc2VlIFVwZGF0ZVJlc3VsdCBodHRwczovL21vbmdvZGIuZ2l0aHViLmlvL25vZGUtbW9uZ29kYi1uYXRpdmUvNC45L2ludGVyZmFjZXMvVXBkYXRlUmVzdWx0Lmh0bWxcbiAqIEByZXR1cm4ge1F1ZXJ5fVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5Nb2RlbC5yZXBsYWNlT25lID0gZnVuY3Rpb24gcmVwbGFjZU9uZShjb25kaXRpb25zLCBkb2MsIG9wdGlvbnMpIHtcbiAgX2NoZWNrQ29udGV4dCh0aGlzLCAncmVwbGFjZU9uZScpO1xuXG4gIGNvbnN0IHZlcnNpb25LZXkgPSB0aGlzICYmIHRoaXMuc2NoZW1hICYmIHRoaXMuc2NoZW1hLm9wdGlvbnMgJiYgdGhpcy5zY2hlbWEub3B0aW9ucy52ZXJzaW9uS2V5IHx8IG51bGw7XG4gIGlmICh2ZXJzaW9uS2V5ICYmICFkb2NbdmVyc2lvbktleV0pIHtcbiAgICBkb2NbdmVyc2lvbktleV0gPSAwO1xuICB9XG5cbiAgcmV0dXJuIF91cGRhdGUodGhpcywgJ3JlcGxhY2VPbmUnLCBjb25kaXRpb25zLCBkb2MsIG9wdGlvbnMpO1xufTtcblxuLyoqXG4gKiBDb21tb24gY29kZSBmb3IgYHVwZGF0ZU9uZSgpYCwgYHVwZGF0ZU1hbnkoKWAsIGByZXBsYWNlT25lKClgLCBhbmQgYHVwZGF0ZSgpYFxuICogYmVjYXVzZSB0aGV5IG5lZWQgdG8gZG8gdGhlIHNhbWUgdGhpbmdcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmZ1bmN0aW9uIF91cGRhdGUobW9kZWwsIG9wLCBjb25kaXRpb25zLCBkb2MsIG9wdGlvbnMpIHtcbiAgY29uc3QgbXEgPSBuZXcgbW9kZWwuUXVlcnkoe30sIHt9LCBtb2RlbCwgbW9kZWwuY29sbGVjdGlvbik7XG5cbiAgLy8gZ2gtMjQwNlxuICAvLyBtYWtlIGxvY2FsIGRlZXAgY29weSBvZiBjb25kaXRpb25zXG4gIGlmIChjb25kaXRpb25zIGluc3RhbmNlb2YgRG9jdW1lbnQpIHtcbiAgICBjb25kaXRpb25zID0gY29uZGl0aW9ucy50b09iamVjdCgpO1xuICB9IGVsc2Uge1xuICAgIGNvbmRpdGlvbnMgPSBjbG9uZShjb25kaXRpb25zKTtcbiAgfVxuICBvcHRpb25zID0gdHlwZW9mIG9wdGlvbnMgPT09ICdmdW5jdGlvbicgPyBvcHRpb25zIDogY2xvbmUob3B0aW9ucyk7XG5cbiAgY29uc3QgdmVyc2lvbktleSA9IG1vZGVsICYmXG4gIG1vZGVsLnNjaGVtYSAmJlxuICBtb2RlbC5zY2hlbWEub3B0aW9ucyAmJlxuICBtb2RlbC5zY2hlbWEub3B0aW9ucy52ZXJzaW9uS2V5IHx8IG51bGw7XG4gIGRlY29yYXRlVXBkYXRlV2l0aFZlcnNpb25LZXkoZG9jLCBvcHRpb25zLCB2ZXJzaW9uS2V5KTtcblxuICByZXR1cm4gbXFbb3BdKGNvbmRpdGlvbnMsIGRvYywgb3B0aW9ucyk7XG59XG5cbi8qKlxuICogUGVyZm9ybXMgW2FnZ3JlZ2F0aW9uc10oaHR0cHM6Ly93d3cubW9uZ29kYi5jb20vZG9jcy9tYW51YWwvYWdncmVnYXRpb24vKSBvbiB0aGUgbW9kZWxzIGNvbGxlY3Rpb24uXG4gKlxuICogSWYgYSBgY2FsbGJhY2tgIGlzIHBhc3NlZCwgdGhlIGBhZ2dyZWdhdGVgIGlzIGV4ZWN1dGVkIGFuZCBhIGBQcm9taXNlYCBpcyByZXR1cm5lZC4gSWYgYSBjYWxsYmFjayBpcyBub3QgcGFzc2VkLCB0aGUgYGFnZ3JlZ2F0ZWAgaXRzZWxmIGlzIHJldHVybmVkLlxuICpcbiAqIFRoaXMgZnVuY3Rpb24gdHJpZ2dlcnMgdGhlIGZvbGxvd2luZyBtaWRkbGV3YXJlLlxuICpcbiAqIC0gYGFnZ3JlZ2F0ZSgpYFxuICpcbiAqICMjIyMgRXhhbXBsZTpcbiAqXG4gKiAgICAgLy8gRmluZCB0aGUgbWF4IGJhbGFuY2Ugb2YgYWxsIGFjY291bnRzXG4gKiAgICAgY29uc3QgcmVzID0gYXdhaXQgVXNlcnMuYWdncmVnYXRlKFtcbiAqICAgICAgIHsgJGdyb3VwOiB7IF9pZDogbnVsbCwgbWF4QmFsYW5jZTogeyAkbWF4OiAnJGJhbGFuY2UnIH19fSxcbiAqICAgICAgIHsgJHByb2plY3Q6IHsgX2lkOiAwLCBtYXhCYWxhbmNlOiAxIH19XG4gKiAgICAgXSk7XG4gKlxuICogICAgIGNvbnNvbGUubG9nKHJlcyk7IC8vIFsgeyBtYXhCYWxhbmNlOiA5ODAwMCB9IF1cbiAqXG4gKiAgICAgLy8gT3IgdXNlIHRoZSBhZ2dyZWdhdGlvbiBwaXBlbGluZSBidWlsZGVyLlxuICogICAgIGNvbnN0IHJlcyA9IGF3YWl0IFVzZXJzLmFnZ3JlZ2F0ZSgpLlxuICogICAgICAgZ3JvdXAoeyBfaWQ6IG51bGwsIG1heEJhbGFuY2U6IHsgJG1heDogJyRiYWxhbmNlJyB9IH0pLlxuICogICAgICAgcHJvamVjdCgnLWlkIG1heEJhbGFuY2UnKS5cbiAqICAgICAgIGV4ZWMoKTtcbiAqICAgICBjb25zb2xlLmxvZyhyZXMpOyAvLyBbIHsgbWF4QmFsYW5jZTogOTggfSBdXG4gKlxuICogIyMjIyBOb3RlOlxuICpcbiAqIC0gTW9uZ29vc2UgZG9lcyAqKm5vdCoqIGNhc3QgYWdncmVnYXRpb24gcGlwZWxpbmVzIHRvIHRoZSBtb2RlbCdzIHNjaGVtYSBiZWNhdXNlIGAkcHJvamVjdGAgYW5kIGAkZ3JvdXBgIG9wZXJhdG9ycyBhbGxvdyByZWRlZmluaW5nIHRoZSBcInNoYXBlXCIgb2YgdGhlIGRvY3VtZW50cyBhdCBhbnkgc3RhZ2Ugb2YgdGhlIHBpcGVsaW5lLCB3aGljaCBtYXkgbGVhdmUgZG9jdW1lbnRzIGluIGFuIGluY29tcGF0aWJsZSBmb3JtYXQuIFlvdSBjYW4gdXNlIHRoZSBbbW9uZ29vc2UtY2FzdC1hZ2dyZWdhdGlvbiBwbHVnaW5dKGh0dHBzOi8vZ2l0aHViLmNvbS9BYmRlbHJhaG1hbkhhZmV6L21vbmdvb3NlLWNhc3QtYWdncmVnYXRpb24pIHRvIGVuYWJsZSBtaW5pbWFsIGNhc3RpbmcgZm9yIGFnZ3JlZ2F0aW9uIHBpcGVsaW5lcy5cbiAqIC0gVGhlIGRvY3VtZW50cyByZXR1cm5lZCBhcmUgcGxhaW4gamF2YXNjcmlwdCBvYmplY3RzLCBub3QgbW9uZ29vc2UgZG9jdW1lbnRzIChzaW5jZSBhbnkgc2hhcGUgb2YgZG9jdW1lbnQgY2FuIGJlIHJldHVybmVkKS5cbiAqXG4gKiAjIyMjIE1vcmUgQWJvdXQgQWdncmVnYXRpb25zOlxuICpcbiAqIC0gW01vbmdvb3NlIGBBZ2dyZWdhdGVgXShodHRwczovL21vbmdvb3NlanMuY29tL2RvY3MvYXBpL2FnZ3JlZ2F0ZS5odG1sKVxuICogLSBbQW4gSW50cm9kdWN0aW9uIHRvIE1vbmdvb3NlIEFnZ3JlZ2F0ZV0oaHR0cHM6Ly9tYXN0ZXJpbmdqcy5pby90dXRvcmlhbHMvbW9uZ29vc2UvYWdncmVnYXRlKVxuICogLSBbTW9uZ29EQiBBZ2dyZWdhdGlvbiBkb2NzXShodHRwczovL3d3dy5tb25nb2RiLmNvbS9kb2NzL21hbnVhbC9hcHBsaWNhdGlvbnMvYWdncmVnYXRpb24vKVxuICpcbiAqIEBzZWUgQWdncmVnYXRlIGh0dHBzOi8vbW9uZ29vc2Vqcy5jb20vZG9jcy9hcGkvYWdncmVnYXRlLmh0bWwjQWdncmVnYXRlKClcbiAqIEBzZWUgTW9uZ29EQiBodHRwczovL3d3dy5tb25nb2RiLmNvbS9kb2NzL21hbnVhbC9hcHBsaWNhdGlvbnMvYWdncmVnYXRpb24vXG4gKiBAcGFyYW0ge0FycmF5fSBbcGlwZWxpbmVdIGFnZ3JlZ2F0aW9uIHBpcGVsaW5lIGFzIGFuIGFycmF5IG9mIG9iamVjdHNcbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gYWdncmVnYXRpb24gb3B0aW9uc1xuICogQHJldHVybiB7QWdncmVnYXRlfVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5Nb2RlbC5hZ2dyZWdhdGUgPSBmdW5jdGlvbiBhZ2dyZWdhdGUocGlwZWxpbmUsIG9wdGlvbnMpIHtcbiAgX2NoZWNrQ29udGV4dCh0aGlzLCAnYWdncmVnYXRlJyk7XG5cbiAgaWYgKHR5cGVvZiBvcHRpb25zID09PSAnZnVuY3Rpb24nIHx8IHR5cGVvZiBhcmd1bWVudHNbMl0gPT09ICdmdW5jdGlvbicpIHtcbiAgICB0aHJvdyBuZXcgTW9uZ29vc2VFcnJvcignTW9kZWwuYWdncmVnYXRlKCkgbm8gbG9uZ2VyIGFjY2VwdHMgYSBjYWxsYmFjaycpO1xuICB9XG5cbiAgY29uc3QgYWdncmVnYXRlID0gbmV3IEFnZ3JlZ2F0ZShwaXBlbGluZSB8fCBbXSk7XG4gIGFnZ3JlZ2F0ZS5tb2RlbCh0aGlzKTtcbiAgaWYgKG9wdGlvbnMgIT0gbnVsbCkge1xuICAgIGFnZ3JlZ2F0ZS5vcHRpb24ob3B0aW9ucyk7XG4gIH1cblxuICBpZiAodHlwZW9mIGNhbGxiYWNrID09PSAndW5kZWZpbmVkJykge1xuICAgIHJldHVybiBhZ2dyZWdhdGU7XG4gIH1cblxuICByZXR1cm4gYWdncmVnYXRlO1xufTtcblxuLyoqXG4gKiBDYXN0cyBhbmQgdmFsaWRhdGVzIHRoZSBnaXZlbiBvYmplY3QgYWdhaW5zdCB0aGlzIG1vZGVsJ3Mgc2NoZW1hLCBwYXNzaW5nIHRoZVxuICogZ2l2ZW4gYGNvbnRleHRgIHRvIGN1c3RvbSB2YWxpZGF0b3JzLlxuICpcbiAqICMjIyMgRXhhbXBsZTpcbiAqXG4gKiAgICAgY29uc3QgTW9kZWwgPSBtb25nb29zZS5tb2RlbCgnVGVzdCcsIFNjaGVtYSh7XG4gKiAgICAgICBuYW1lOiB7IHR5cGU6IFN0cmluZywgcmVxdWlyZWQ6IHRydWUgfSxcbiAqICAgICAgIGFnZTogeyB0eXBlOiBOdW1iZXIsIHJlcXVpcmVkOiB0cnVlIH1cbiAqICAgICB9KTtcbiAqXG4gKiAgICAgdHJ5IHtcbiAqICAgICAgIGF3YWl0IE1vZGVsLnZhbGlkYXRlKHsgbmFtZTogbnVsbCB9LCBbJ25hbWUnXSlcbiAqICAgICB9IGNhdGNoIChlcnIpIHtcbiAqICAgICAgIGVyciBpbnN0YW5jZW9mIG1vbmdvb3NlLkVycm9yLlZhbGlkYXRpb25FcnJvcjsgLy8gdHJ1ZVxuICogICAgICAgT2JqZWN0LmtleXMoZXJyLmVycm9ycyk7IC8vIFsnbmFtZSddXG4gKiAgICAgfVxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmpcbiAqIEBwYXJhbSB7T2JqZWN0fEFycmF5fFN0cmluZ30gcGF0aHNPck9wdGlvbnNcbiAqIEBwYXJhbSB7T2JqZWN0fSBbY29udGV4dF1cbiAqIEByZXR1cm4ge1Byb21pc2U8T2JqZWN0Pn0gY2FzdGVkIGFuZCB2YWxpZGF0ZWQgY29weSBvZiBgb2JqYCBpZiB2YWxpZGF0aW9uIHN1Y2NlZWRlZFxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5Nb2RlbC52YWxpZGF0ZSA9IGFzeW5jIGZ1bmN0aW9uIHZhbGlkYXRlKG9iaiwgcGF0aHNPck9wdGlvbnMsIGNvbnRleHQpIHtcbiAgaWYgKChhcmd1bWVudHMubGVuZ3RoIDwgMykgfHwgKGFyZ3VtZW50cy5sZW5ndGggPT09IDMgJiYgdHlwZW9mIGFyZ3VtZW50c1syXSA9PT0gJ2Z1bmN0aW9uJykpIHtcbiAgICAvLyBGb3IgY29udmVuaWVuY2UsIGlmIHdlJ3JlIHZhbGlkYXRpbmcgYSBkb2N1bWVudCBvciBhbiBvYmplY3QsIG1ha2UgYGNvbnRleHRgIGRlZmF1bHQgdG9cbiAgICAvLyB0aGUgbW9kZWwgc28gdXNlcnMgZG9uJ3QgaGF2ZSB0byBhbHdheXMgcGFzcyBgY29udGV4dGAsIHJlOiBnaC0xMDEzMiwgZ2gtMTAzNDZcbiAgICBjb250ZXh0ID0gb2JqO1xuICB9XG4gIGlmICh0eXBlb2YgY29udGV4dCA9PT0gJ2Z1bmN0aW9uJyB8fCB0eXBlb2YgYXJndW1lbnRzWzNdID09PSAnZnVuY3Rpb24nKSB7XG4gICAgdGhyb3cgbmV3IE1vbmdvb3NlRXJyb3IoJ01vZGVsLnZhbGlkYXRlKCkgbm8gbG9uZ2VyIGFjY2VwdHMgYSBjYWxsYmFjaycpO1xuICB9XG5cbiAgbGV0IHNjaGVtYSA9IHRoaXMuc2NoZW1hO1xuICBjb25zdCBkaXNjcmltaW5hdG9yS2V5ID0gc2NoZW1hLm9wdGlvbnMuZGlzY3JpbWluYXRvcktleTtcbiAgaWYgKHNjaGVtYS5kaXNjcmltaW5hdG9ycyAhPSBudWxsICYmIG9iaiAhPSBudWxsICYmIG9ialtkaXNjcmltaW5hdG9yS2V5XSAhPSBudWxsKSB7XG4gICAgc2NoZW1hID0gZ2V0U2NoZW1hRGlzY3JpbWluYXRvckJ5VmFsdWUoc2NoZW1hLCBvYmpbZGlzY3JpbWluYXRvcktleV0pIHx8IHNjaGVtYTtcbiAgfVxuICBsZXQgcGF0aHMgPSBPYmplY3Qua2V5cyhzY2hlbWEucGF0aHMpO1xuXG4gIGlmIChwYXRoc09yT3B0aW9ucyAhPSBudWxsKSB7XG4gICAgY29uc3QgX3BhdGhzVG9WYWxpZGF0ZSA9IHR5cGVvZiBwYXRoc09yT3B0aW9ucyA9PT0gJ3N0cmluZycgPyBuZXcgU2V0KHBhdGhzT3JPcHRpb25zLnNwbGl0KCcgJykpIDogQXJyYXkuaXNBcnJheShwYXRoc09yT3B0aW9ucykgPyBuZXcgU2V0KHBhdGhzT3JPcHRpb25zKSA6IG5ldyBTZXQocGF0aHMpO1xuICAgIHBhdGhzID0gcGF0aHMuZmlsdGVyKHAgPT4ge1xuICAgICAgaWYgKHBhdGhzT3JPcHRpb25zLnBhdGhzVG9Ta2lwKSB7XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KHBhdGhzT3JPcHRpb25zLnBhdGhzVG9Ta2lwKSkge1xuICAgICAgICAgIGlmIChwYXRoc09yT3B0aW9ucy5wYXRoc1RvU2tpcC5maW5kKHggPT4geCA9PSBwKSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmICh0eXBlb2YgcGF0aHNPck9wdGlvbnMucGF0aHNUb1NraXAgPT0gJ3N0cmluZycpIHtcbiAgICAgICAgICBpZiAocGF0aHNPck9wdGlvbnMucGF0aHNUb1NraXAuaW5jbHVkZXMocCkpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGNvbnN0IHBpZWNlcyA9IHAuc3BsaXQoJy4nKTtcbiAgICAgIGxldCBjdXIgPSBwaWVjZXNbMF07XG5cbiAgICAgIGZvciAoY29uc3QgcGllY2Ugb2YgcGllY2VzKSB7XG4gICAgICAgIGlmIChfcGF0aHNUb1ZhbGlkYXRlLmhhcyhjdXIpKSB7XG4gICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgY3VyICs9ICcuJyArIHBpZWNlO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gX3BhdGhzVG9WYWxpZGF0ZS5oYXMocCk7XG4gICAgfSk7XG4gIH1cblxuICBmb3IgKGNvbnN0IHBhdGggb2YgcGF0aHMpIHtcbiAgICBjb25zdCBzY2hlbWFUeXBlID0gc2NoZW1hLnBhdGgocGF0aCk7XG4gICAgaWYgKCFzY2hlbWFUeXBlIHx8ICFzY2hlbWFUeXBlLiRpc01vbmdvb3NlQXJyYXkgfHwgc2NoZW1hVHlwZS4kaXNNb25nb29zZURvY3VtZW50QXJyYXkpIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIGNvbnN0IHZhbCA9IGdldChvYmosIHBhdGgpO1xuICAgIHB1c2hOZXN0ZWRBcnJheVBhdGhzKHBhdGhzLCB2YWwsIHBhdGgpO1xuICB9XG5cbiAgbGV0IGVycm9yID0gbnVsbDtcbiAgcGF0aHMgPSBuZXcgU2V0KHBhdGhzKTtcblxuICB0cnkge1xuICAgIG9iaiA9IHRoaXMuY2FzdE9iamVjdChvYmopO1xuICB9IGNhdGNoIChlcnIpIHtcbiAgICBlcnJvciA9IGVycjtcbiAgICBmb3IgKGNvbnN0IGtleSBvZiBPYmplY3Qua2V5cyhlcnJvci5lcnJvcnMgfHwge30pKSB7XG4gICAgICBwYXRocy5kZWxldGUoa2V5KTtcbiAgICB9XG4gIH1cblxuICBsZXQgcmVtYWluaW5nID0gcGF0aHMuc2l6ZTtcblxuICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgIGZvciAoY29uc3QgcGF0aCBvZiBwYXRocykge1xuICAgICAgY29uc3Qgc2NoZW1hVHlwZSA9IHNjaGVtYS5wYXRoKHBhdGgpO1xuICAgICAgaWYgKHNjaGVtYVR5cGUgPT0gbnVsbCkge1xuICAgICAgICBfY2hlY2tEb25lKCk7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuXG4gICAgICBjb25zdCBwaWVjZXMgPSBwYXRoLmluZGV4T2YoJy4nKSA9PT0gLTEgPyBbcGF0aF0gOiBwYXRoLnNwbGl0KCcuJyk7XG4gICAgICBsZXQgY3VyID0gb2JqO1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBwaWVjZXMubGVuZ3RoIC0gMTsgKytpKSB7XG4gICAgICAgIGN1ciA9IGN1cltwaWVjZXNbaV1dO1xuICAgICAgfVxuXG4gICAgICBjb25zdCB2YWwgPSBnZXQob2JqLCBwYXRoLCB2b2lkIDApO1xuXG4gICAgICBzY2hlbWFUeXBlLmRvVmFsaWRhdGUodmFsLCBlcnIgPT4ge1xuICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgZXJyb3IgPSBlcnJvciB8fCBuZXcgVmFsaWRhdGlvbkVycm9yKCk7XG4gICAgICAgICAgZXJyb3IuYWRkRXJyb3IocGF0aCwgZXJyKTtcbiAgICAgICAgfVxuICAgICAgICBfY2hlY2tEb25lKCk7XG4gICAgICB9LCBjb250ZXh0LCB7IHBhdGg6IHBhdGggfSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gX2NoZWNrRG9uZSgpIHtcbiAgICAgIGlmICgtLXJlbWFpbmluZyA8PSAwKSB7XG4gICAgICAgIGlmIChlcnJvcikge1xuICAgICAgICAgIHJlamVjdChlcnJvcik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmVzb2x2ZShvYmopO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9KTtcbn07XG5cbi8qKlxuICogUG9wdWxhdGVzIGRvY3VtZW50IHJlZmVyZW5jZXMuXG4gKlxuICogQ2hhbmdlZCBpbiBNb25nb29zZSA2OiB0aGUgbW9kZWwgeW91IGNhbGwgYHBvcHVsYXRlKClgIG9uIHNob3VsZCBiZSB0aGVcbiAqIFwibG9jYWwgZmllbGRcIiBtb2RlbCwgKipub3QqKiB0aGUgXCJmb3JlaWduIGZpZWxkXCIgbW9kZWwuXG4gKlxuICogIyMjIyBBdmFpbGFibGUgdG9wLWxldmVsIG9wdGlvbnM6XG4gKlxuICogLSBwYXRoOiBzcGFjZSBkZWxpbWl0ZWQgcGF0aChzKSB0byBwb3B1bGF0ZVxuICogLSBzZWxlY3Q6IG9wdGlvbmFsIGZpZWxkcyB0byBzZWxlY3RcbiAqIC0gbWF0Y2g6IG9wdGlvbmFsIHF1ZXJ5IGNvbmRpdGlvbnMgdG8gbWF0Y2hcbiAqIC0gbW9kZWw6IG9wdGlvbmFsIG5hbWUgb2YgdGhlIG1vZGVsIHRvIHVzZSBmb3IgcG9wdWxhdGlvblxuICogLSBvcHRpb25zOiBvcHRpb25hbCBxdWVyeSBvcHRpb25zIGxpa2Ugc29ydCwgbGltaXQsIGV0Y1xuICogLSBqdXN0T25lOiBvcHRpb25hbCBib29sZWFuLCBpZiB0cnVlIE1vbmdvb3NlIHdpbGwgYWx3YXlzIHNldCBgcGF0aGAgdG8gYSBkb2N1bWVudCwgb3IgYG51bGxgIGlmIG5vIGRvY3VtZW50IHdhcyBmb3VuZC4gSWYgZmFsc2UsIE1vbmdvb3NlIHdpbGwgYWx3YXlzIHNldCBgcGF0aGAgdG8gYW4gYXJyYXksIHdoaWNoIHdpbGwgYmUgZW1wdHkgaWYgbm8gZG9jdW1lbnRzIGFyZSBmb3VuZC4gSW5mZXJyZWQgZnJvbSBzY2hlbWEgYnkgZGVmYXVsdC5cbiAqIC0gc3RyaWN0UG9wdWxhdGU6IG9wdGlvbmFsIGJvb2xlYW4sIHNldCB0byBgZmFsc2VgIHRvIGFsbG93IHBvcHVsYXRpbmcgcGF0aHMgdGhhdCBhcmVuJ3QgaW4gdGhlIHNjaGVtYS5cbiAqXG4gKiAjIyMjIEV4YW1wbGU6XG4gKlxuICogICAgIGNvbnN0IERvZyA9IG1vbmdvb3NlLm1vZGVsKCdEb2cnLCBuZXcgU2NoZW1hKHsgbmFtZTogU3RyaW5nLCBicmVlZDogU3RyaW5nIH0pKTtcbiAqICAgICBjb25zdCBQZXJzb24gPSBtb25nb29zZS5tb2RlbCgnUGVyc29uJywgbmV3IFNjaGVtYSh7XG4gKiAgICAgICBuYW1lOiBTdHJpbmcsXG4gKiAgICAgICBwZXQ6IHsgdHlwZTogbW9uZ29vc2UuT2JqZWN0SWQsIHJlZjogJ0RvZycgfVxuICogICAgIH0pKTtcbiAqXG4gKiAgICAgY29uc3QgcGV0cyA9IGF3YWl0IFBldC5jcmVhdGUoW1xuICogICAgICAgeyBuYW1lOiAnRGFpc3knLCBicmVlZDogJ0JlYWdsZScgfSxcbiAqICAgICAgIHsgbmFtZTogJ0VpbnN0ZWluJywgYnJlZWQ6ICdDYXRhbGFuIFNoZWVwZG9nJyB9XG4gKiAgICAgXSk7XG4gKlxuICogICAgIC8vIHBvcHVsYXRlIG1hbnkgcGxhaW4gb2JqZWN0c1xuICogICAgIGNvbnN0IHVzZXJzID0gW1xuICogICAgICAgeyBuYW1lOiAnSm9obiBXaWNrJywgZG9nOiBwZXRzWzBdLl9pZCB9LFxuICogICAgICAgeyBuYW1lOiAnRG9jIEJyb3duJywgZG9nOiBwZXRzWzFdLl9pZCB9XG4gKiAgICAgXTtcbiAqICAgICBhd2FpdCBVc2VyLnBvcHVsYXRlKHVzZXJzLCB7IHBhdGg6ICdkb2cnLCBzZWxlY3Q6ICduYW1lJyB9KTtcbiAqICAgICB1c2Vyc1swXS5kb2cubmFtZTsgLy8gJ0RhaXN5J1xuICogICAgIHVzZXJzWzBdLmRvZy5icmVlZDsgLy8gdW5kZWZpbmVkIGJlY2F1c2Ugb2YgYHNlbGVjdGBcbiAqXG4gKiBAcGFyYW0ge0RvY3VtZW50fEFycmF5fSBkb2NzIEVpdGhlciBhIHNpbmdsZSBkb2N1bWVudCBvciBhcnJheSBvZiBkb2N1bWVudHMgdG8gcG9wdWxhdGUuXG4gKiBAcGFyYW0ge09iamVjdHxTdHJpbmd9IG9wdGlvbnMgRWl0aGVyIHRoZSBwYXRocyB0byBwb3B1bGF0ZSBvciBhbiBvYmplY3Qgc3BlY2lmeWluZyBhbGwgcGFyYW1ldGVyc1xuICogQHBhcmFtIHtzdHJpbmd9IFtvcHRpb25zLnBhdGg9bnVsbF0gVGhlIHBhdGggdG8gcG9wdWxhdGUuXG4gKiBAcGFyYW0ge3N0cmluZ3xQb3B1bGF0ZU9wdGlvbnN9IFtvcHRpb25zLnBvcHVsYXRlPW51bGxdIFJlY3Vyc2l2ZWx5IHBvcHVsYXRlIHBhdGhzIGluIHRoZSBwb3B1bGF0ZWQgZG9jdW1lbnRzLiBTZWUgW2RlZXAgcG9wdWxhdGUgZG9jc10oaHR0cHM6Ly9tb25nb29zZWpzLmNvbS9kb2NzL3BvcHVsYXRlLmh0bWwjZGVlcC1wb3B1bGF0ZSkuXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRpb25zLnJldGFpbk51bGxWYWx1ZXM9ZmFsc2VdIEJ5IGRlZmF1bHQsIE1vbmdvb3NlIHJlbW92ZXMgbnVsbCBhbmQgdW5kZWZpbmVkIHZhbHVlcyBmcm9tIHBvcHVsYXRlZCBhcnJheXMuIFVzZSB0aGlzIG9wdGlvbiB0byBtYWtlIGBwb3B1bGF0ZSgpYCByZXRhaW4gYG51bGxgIGFuZCBgdW5kZWZpbmVkYCBhcnJheSBlbnRyaWVzLlxuICogQHBhcmFtIHtib29sZWFufSBbb3B0aW9ucy5nZXR0ZXJzPWZhbHNlXSBJZiB0cnVlLCBNb25nb29zZSB3aWxsIGNhbGwgYW55IGdldHRlcnMgZGVmaW5lZCBvbiB0aGUgYGxvY2FsRmllbGRgLiBCeSBkZWZhdWx0LCBNb25nb29zZSBnZXRzIHRoZSByYXcgdmFsdWUgb2YgYGxvY2FsRmllbGRgLiBGb3IgZXhhbXBsZSwgeW91IHdvdWxkIG5lZWQgdG8gc2V0IHRoaXMgb3B0aW9uIHRvIGB0cnVlYCBpZiB5b3Ugd2FudGVkIHRvIFthZGQgYSBgbG93ZXJjYXNlYCBnZXR0ZXIgdG8geW91ciBgbG9jYWxGaWVsZGBdKGh0dHBzOi8vbW9uZ29vc2Vqcy5jb20vZG9jcy9zY2hlbWF0eXBlcy5odG1sI3NjaGVtYXR5cGUtb3B0aW9ucykuXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRpb25zLmNsb25lPWZhbHNlXSBXaGVuIHlvdSBkbyBgQmxvZ1Bvc3QuZmluZCgpLnBvcHVsYXRlKCdhdXRob3InKWAsIGJsb2cgcG9zdHMgd2l0aCB0aGUgc2FtZSBhdXRob3Igd2lsbCBzaGFyZSAxIGNvcHkgb2YgYW4gYGF1dGhvcmAgZG9jLiBFbmFibGUgdGhpcyBvcHRpb24gdG8gbWFrZSBNb25nb29zZSBjbG9uZSBwb3B1bGF0ZWQgZG9jcyBiZWZvcmUgYXNzaWduaW5nIHRoZW0uXG4gKiBAcGFyYW0ge09iamVjdHxGdW5jdGlvbn0gW29wdGlvbnMubWF0Y2g9bnVsbF0gQWRkIGFuIGFkZGl0aW9uYWwgZmlsdGVyIHRvIHRoZSBwb3B1bGF0ZSBxdWVyeS4gQ2FuIGJlIGEgZmlsdGVyIG9iamVjdCBjb250YWluaW5nIFtNb25nb0RCIHF1ZXJ5IHN5bnRheF0oaHR0cHM6Ly93d3cubW9uZ29kYi5jb20vZG9jcy9tYW51YWwvdHV0b3JpYWwvcXVlcnktZG9jdW1lbnRzLyksIG9yIGEgZnVuY3Rpb24gdGhhdCByZXR1cm5zIGEgZmlsdGVyIG9iamVjdC5cbiAqIEBwYXJhbSB7Qm9vbGVhbn0gW29wdGlvbnMuc2tpcEludmFsaWRJZHM9ZmFsc2VdIEJ5IGRlZmF1bHQsIE1vbmdvb3NlIHRocm93cyBhIGNhc3QgZXJyb3IgaWYgYGxvY2FsRmllbGRgIGFuZCBgZm9yZWlnbkZpZWxkYCBzY2hlbWFzIGRvbid0IGxpbmUgdXAuIElmIHlvdSBlbmFibGUgdGhpcyBvcHRpb24sIE1vbmdvb3NlIHdpbGwgaW5zdGVhZCBmaWx0ZXIgb3V0IGFueSBgbG9jYWxGaWVsZGAgcHJvcGVydGllcyB0aGF0IGNhbm5vdCBiZSBjYXN0ZWQgdG8gYGZvcmVpZ25GaWVsZGAncyBzY2hlbWEgdHlwZS5cbiAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy5wZXJEb2N1bWVudExpbWl0PW51bGxdIEZvciBsZWdhY3kgcmVhc29ucywgYGxpbWl0YCB3aXRoIGBwb3B1bGF0ZSgpYCBtYXkgZ2l2ZSBpbmNvcnJlY3QgcmVzdWx0cyBiZWNhdXNlIGl0IG9ubHkgZXhlY3V0ZXMgYSBzaW5nbGUgcXVlcnkgZm9yIGV2ZXJ5IGRvY3VtZW50IGJlaW5nIHBvcHVsYXRlZC4gSWYgeW91IHNldCBgcGVyRG9jdW1lbnRMaW1pdGAsIE1vbmdvb3NlIHdpbGwgZW5zdXJlIGNvcnJlY3QgYGxpbWl0YCBwZXIgZG9jdW1lbnQgYnkgZXhlY3V0aW5nIGEgc2VwYXJhdGUgcXVlcnkgZm9yIGVhY2ggZG9jdW1lbnQgdG8gYHBvcHVsYXRlKClgLiBGb3IgZXhhbXBsZSwgYC5maW5kKCkucG9wdWxhdGUoeyBwYXRoOiAndGVzdCcsIHBlckRvY3VtZW50TGltaXQ6IDIgfSlgIHdpbGwgZXhlY3V0ZSAyIGFkZGl0aW9uYWwgcXVlcmllcyBpZiBgLmZpbmQoKWAgcmV0dXJucyAyIGRvY3VtZW50cy5cbiAqIEBwYXJhbSB7Qm9vbGVhbn0gW29wdGlvbnMuc3RyaWN0UG9wdWxhdGU9dHJ1ZV0gU2V0IHRvIGZhbHNlIHRvIGFsbG93IHBvcHVsYXRpbmcgcGF0aHMgdGhhdCBhcmVuJ3QgZGVmaW5lZCBpbiB0aGUgZ2l2ZW4gbW9kZWwncyBzY2hlbWEuXG4gKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnMub3B0aW9ucz1udWxsXSBBZGRpdGlvbmFsIG9wdGlvbnMgbGlrZSBgbGltaXRgIGFuZCBgbGVhbmAuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbb3B0aW9ucy50cmFuc2Zvcm09bnVsbF0gRnVuY3Rpb24gdGhhdCBNb25nb29zZSB3aWxsIGNhbGwgb24gZXZlcnkgcG9wdWxhdGVkIGRvY3VtZW50IHRoYXQgYWxsb3dzIHlvdSB0byB0cmFuc2Zvcm0gdGhlIHBvcHVsYXRlZCBkb2N1bWVudC5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtjYWxsYmFjayhlcnIsZG9jKV0gT3B0aW9uYWwgY2FsbGJhY2ssIGV4ZWN1dGVkIHVwb24gY29tcGxldGlvbi4gUmVjZWl2ZXMgYGVycmAgYW5kIHRoZSBgZG9jKHMpYC5cbiAqIEByZXR1cm4ge1Byb21pc2V9XG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbk1vZGVsLnBvcHVsYXRlID0gYXN5bmMgZnVuY3Rpb24gcG9wdWxhdGUoZG9jcywgcGF0aHMpIHtcbiAgX2NoZWNrQ29udGV4dCh0aGlzLCAncG9wdWxhdGUnKTtcbiAgaWYgKHR5cGVvZiBwYXRocyA9PT0gJ2Z1bmN0aW9uJyB8fCB0eXBlb2YgYXJndW1lbnRzWzJdID09PSAnZnVuY3Rpb24nKSB7XG4gICAgdGhyb3cgbmV3IE1vbmdvb3NlRXJyb3IoJ01vZGVsLnBvcHVsYXRlKCkgbm8gbG9uZ2VyIGFjY2VwdHMgYSBjYWxsYmFjaycpO1xuICB9XG4gIGNvbnN0IF90aGlzID0gdGhpcztcbiAgLy8gbm9ybWFsaXplZCBwYXRoc1xuICBwYXRocyA9IHV0aWxzLnBvcHVsYXRlKHBhdGhzKTtcbiAgLy8gZGF0YSB0aGF0IHNob3VsZCBwZXJzaXN0IGFjcm9zcyBzdWJQb3B1bGF0ZSBjYWxsc1xuICBjb25zdCBjYWNoZSA9IHt9O1xuXG4gIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgX3BvcHVsYXRlKF90aGlzLCBkb2NzLCBwYXRocywgY2FjaGUsIChlcnIsIHJlcykgPT4ge1xuICAgICAgaWYgKGVycikge1xuICAgICAgICByZXR1cm4gcmVqZWN0KGVycik7XG4gICAgICB9XG4gICAgICByZXNvbHZlKHJlcyk7XG4gICAgfSk7XG4gIH0pO1xufTtcblxuLyoqXG4gKiBQb3B1bGF0ZSBoZWxwZXJcbiAqXG4gKiBAcGFyYW0ge01vZGVsfSBtb2RlbCB0aGUgbW9kZWwgdG8gdXNlXG4gKiBAcGFyYW0ge0RvY3VtZW50fEFycmF5fSBkb2NzIEVpdGhlciBhIHNpbmdsZSBkb2N1bWVudCBvciBhcnJheSBvZiBkb2N1bWVudHMgdG8gcG9wdWxhdGUuXG4gKiBAcGFyYW0ge09iamVjdH0gcGF0aHNcbiAqIEBwYXJhbSB7bmV2ZXJ9IGNhY2hlIFVudXNlZFxuICogQHBhcmFtIHtGdW5jdGlvbn0gW2NhbGxiYWNrXSBPcHRpb25hbCBjYWxsYmFjaywgZXhlY3V0ZWQgdXBvbiBjb21wbGV0aW9uLiBSZWNlaXZlcyBgZXJyYCBhbmQgdGhlIGBkb2MocylgLlxuICogQHJldHVybiB7RnVuY3Rpb259XG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5mdW5jdGlvbiBfcG9wdWxhdGUobW9kZWwsIGRvY3MsIHBhdGhzLCBjYWNoZSwgY2FsbGJhY2spIHtcbiAgbGV0IHBlbmRpbmcgPSBwYXRocy5sZW5ndGg7XG4gIGlmIChwYXRocy5sZW5ndGggPT09IDApIHtcbiAgICByZXR1cm4gY2FsbGJhY2sobnVsbCwgZG9jcyk7XG4gIH1cbiAgLy8gZWFjaCBwYXRoIGhhcyBpdHMgb3duIHF1ZXJ5IG9wdGlvbnMgYW5kIG11c3QgYmUgZXhlY3V0ZWQgc2VwYXJhdGVseVxuICBmb3IgKGNvbnN0IHBhdGggb2YgcGF0aHMpIHtcbiAgICBwb3B1bGF0ZShtb2RlbCwgZG9jcywgcGF0aCwgbmV4dCk7XG4gIH1cblxuICBmdW5jdGlvbiBuZXh0KGVycikge1xuICAgIGlmIChlcnIpIHtcbiAgICAgIHJldHVybiBjYWxsYmFjayhlcnIsIG51bGwpO1xuICAgIH1cbiAgICBpZiAoLS1wZW5kaW5nKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNhbGxiYWNrKG51bGwsIGRvY3MpO1xuICB9XG59XG5cbi8qIVxuICogUG9wdWxhdGVzIGBkb2NzYFxuICovXG5jb25zdCBleGNsdWRlSWRSZWcgPSAvXFxzPy1faWRcXHM/LztcbmNvbnN0IGV4Y2x1ZGVJZFJlZ0dsb2JhbCA9IC9cXHM/LV9pZFxccz8vZztcblxuZnVuY3Rpb24gcG9wdWxhdGUobW9kZWwsIGRvY3MsIG9wdGlvbnMsIGNhbGxiYWNrKSB7XG4gIGNvbnN0IHBvcHVsYXRlT3B0aW9ucyA9IG9wdGlvbnM7XG4gIGlmIChvcHRpb25zLnN0cmljdFBvcHVsYXRlID09IG51bGwpIHtcbiAgICBpZiAob3B0aW9ucy5fbG9jYWxNb2RlbCAhPSBudWxsICYmIG9wdGlvbnMuX2xvY2FsTW9kZWwuc2NoZW1hLl91c2VyUHJvdmlkZWRPcHRpb25zLnN0cmljdFBvcHVsYXRlICE9IG51bGwpIHtcbiAgICAgIHBvcHVsYXRlT3B0aW9ucy5zdHJpY3RQb3B1bGF0ZSA9IG9wdGlvbnMuX2xvY2FsTW9kZWwuc2NoZW1hLl91c2VyUHJvdmlkZWRPcHRpb25zLnN0cmljdFBvcHVsYXRlO1xuICAgIH0gZWxzZSBpZiAob3B0aW9ucy5fbG9jYWxNb2RlbCAhPSBudWxsICYmIG1vZGVsLmJhc2Uub3B0aW9ucy5zdHJpY3RQb3B1bGF0ZSAhPSBudWxsKSB7XG4gICAgICBwb3B1bGF0ZU9wdGlvbnMuc3RyaWN0UG9wdWxhdGUgPSBtb2RlbC5iYXNlLm9wdGlvbnMuc3RyaWN0UG9wdWxhdGU7XG4gICAgfSBlbHNlIGlmIChtb2RlbC5iYXNlLm9wdGlvbnMuc3RyaWN0UG9wdWxhdGUgIT0gbnVsbCkge1xuICAgICAgcG9wdWxhdGVPcHRpb25zLnN0cmljdFBvcHVsYXRlID0gbW9kZWwuYmFzZS5vcHRpb25zLnN0cmljdFBvcHVsYXRlO1xuICAgIH1cbiAgfVxuXG4gIC8vIG5vcm1hbGl6ZSBzaW5nbGUgLyBtdWx0aXBsZSBkb2NzIHBhc3NlZFxuICBpZiAoIUFycmF5LmlzQXJyYXkoZG9jcykpIHtcbiAgICBkb2NzID0gW2RvY3NdO1xuICB9XG4gIGlmIChkb2NzLmxlbmd0aCA9PT0gMCB8fCBkb2NzLmV2ZXJ5KHV0aWxzLmlzTnVsbE9yVW5kZWZpbmVkKSkge1xuICAgIHJldHVybiBjYWxsYmFjaygpO1xuICB9XG5cbiAgY29uc3QgbW9kZWxzTWFwID0gZ2V0TW9kZWxzTWFwRm9yUG9wdWxhdGUobW9kZWwsIGRvY3MsIHBvcHVsYXRlT3B0aW9ucyk7XG5cbiAgaWYgKG1vZGVsc01hcCBpbnN0YW5jZW9mIE1vbmdvb3NlRXJyb3IpIHtcbiAgICByZXR1cm4gaW1tZWRpYXRlKGZ1bmN0aW9uKCkge1xuICAgICAgY2FsbGJhY2sobW9kZWxzTWFwKTtcbiAgICB9KTtcbiAgfVxuICBjb25zdCBsZW4gPSBtb2RlbHNNYXAubGVuZ3RoO1xuICBsZXQgdmFscyA9IFtdO1xuXG4gIGZ1bmN0aW9uIGZsYXR0ZW4oaXRlbSkge1xuICAgIC8vIG5vIG5lZWQgdG8gaW5jbHVkZSB1bmRlZmluZWQgdmFsdWVzIGluIG91ciBxdWVyeVxuICAgIHJldHVybiB1bmRlZmluZWQgIT09IGl0ZW07XG4gIH1cblxuICBsZXQgX3JlbWFpbmluZyA9IGxlbjtcbiAgbGV0IGhhc09uZSA9IGZhbHNlO1xuICBjb25zdCBwYXJhbXMgPSBbXTtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZW47ICsraSkge1xuICAgIGNvbnN0IG1vZCA9IG1vZGVsc01hcFtpXTtcbiAgICBsZXQgc2VsZWN0ID0gbW9kLm9wdGlvbnMuc2VsZWN0O1xuICAgIGxldCBpZHMgPSB1dGlscy5hcnJheS5mbGF0dGVuKG1vZC5pZHMsIGZsYXR0ZW4pO1xuICAgIGlkcyA9IHV0aWxzLmFycmF5LnVuaXF1ZShpZHMpO1xuXG4gICAgY29uc3QgYXNzaWdubWVudE9wdHMgPSB7fTtcbiAgICBhc3NpZ25tZW50T3B0cy5zb3J0ID0gbW9kICYmXG4gICAgICBtb2Qub3B0aW9ucyAmJlxuICAgICAgbW9kLm9wdGlvbnMub3B0aW9ucyAmJlxuICAgICAgbW9kLm9wdGlvbnMub3B0aW9ucy5zb3J0IHx8IHZvaWQgMDtcbiAgICBhc3NpZ25tZW50T3B0cy5leGNsdWRlSWQgPSBleGNsdWRlSWRSZWcudGVzdChzZWxlY3QpIHx8IChzZWxlY3QgJiYgc2VsZWN0Ll9pZCA9PT0gMCk7XG5cbiAgICAvLyBMZWFuIHRyYW5zZm9ybSBtYXkgZGVsZXRlIGBfaWRgLCB3aGljaCB3b3VsZCBjYXVzZSBhc3NpZ25tZW50XG4gICAgLy8gdG8gZmFpbC4gU28gZGVsYXkgcnVubmluZyBsZWFuIHRyYW5zZm9ybSB1bnRpbCBfYWZ0ZXJfXG4gICAgLy8gYF9hc3NpZ24oKWBcbiAgICBpZiAobW9kLm9wdGlvbnMgJiZcbiAgICAgICAgbW9kLm9wdGlvbnMub3B0aW9ucyAmJlxuICAgICAgICBtb2Qub3B0aW9ucy5vcHRpb25zLmxlYW4gJiZcbiAgICAgICAgbW9kLm9wdGlvbnMub3B0aW9ucy5sZWFuLnRyYW5zZm9ybSkge1xuICAgICAgbW9kLm9wdGlvbnMub3B0aW9ucy5fbGVhblRyYW5zZm9ybSA9IG1vZC5vcHRpb25zLm9wdGlvbnMubGVhbi50cmFuc2Zvcm07XG4gICAgICBtb2Qub3B0aW9ucy5vcHRpb25zLmxlYW4gPSB0cnVlO1xuICAgIH1cblxuICAgIGlmIChpZHMubGVuZ3RoID09PSAwIHx8IGlkcy5ldmVyeSh1dGlscy5pc051bGxPclVuZGVmaW5lZCkpIHtcbiAgICAgIC8vIEVuc3VyZSB0aGF0IHdlIHNldCB0byAwIG9yIGVtcHR5IGFycmF5IGV2ZW5cbiAgICAgIC8vIGlmIHdlIGRvbid0IGFjdHVhbGx5IGV4ZWN1dGUgYSBxdWVyeSB0byBtYWtlIHN1cmUgdGhlcmUncyBhIHZhbHVlXG4gICAgICAvLyBhbmQgd2Uga25vdyB0aGlzIHBhdGggd2FzIHBvcHVsYXRlZCBmb3IgZnV0dXJlIHNldHMuIFNlZSBnaC03NzMxLCBnaC04MjMwXG4gICAgICAtLV9yZW1haW5pbmc7XG4gICAgICBfYXNzaWduKG1vZGVsLCBbXSwgbW9kLCBhc3NpZ25tZW50T3B0cyk7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICBoYXNPbmUgPSB0cnVlO1xuICAgIGlmICh0eXBlb2YgcG9wdWxhdGVPcHRpb25zLmZvcmVpZ25GaWVsZCA9PT0gJ3N0cmluZycpIHtcbiAgICAgIG1vZC5mb3JlaWduRmllbGQuY2xlYXIoKTtcbiAgICAgIG1vZC5mb3JlaWduRmllbGQuYWRkKHBvcHVsYXRlT3B0aW9ucy5mb3JlaWduRmllbGQpO1xuICAgIH1cbiAgICBjb25zdCBtYXRjaCA9IGNyZWF0ZVBvcHVsYXRlUXVlcnlGaWx0ZXIoaWRzLCBtb2QubWF0Y2gsIG1vZC5mb3JlaWduRmllbGQsIG1vZC5tb2RlbCwgbW9kLm9wdGlvbnMuc2tpcEludmFsaWRJZHMpO1xuICAgIGlmIChhc3NpZ25tZW50T3B0cy5leGNsdWRlSWQpIHtcbiAgICAgIC8vIG92ZXJyaWRlIHRoZSBleGNsdXNpb24gZnJvbSB0aGUgcXVlcnkgc28gd2UgY2FuIHVzZSB0aGUgX2lkXG4gICAgICAvLyBmb3IgZG9jdW1lbnQgbWF0Y2hpbmcgZHVyaW5nIGFzc2lnbm1lbnQuIHdlJ2xsIGRlbGV0ZSB0aGVcbiAgICAgIC8vIF9pZCBiYWNrIG9mZiBiZWZvcmUgcmV0dXJuaW5nIHRoZSByZXN1bHQuXG4gICAgICBpZiAodHlwZW9mIHNlbGVjdCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgc2VsZWN0ID0gc2VsZWN0LnJlcGxhY2UoZXhjbHVkZUlkUmVnR2xvYmFsLCAnICcpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gcHJlc2VydmUgb3JpZ2luYWwgc2VsZWN0IGNvbmRpdGlvbnMgYnkgY29weWluZ1xuICAgICAgICBzZWxlY3QgPSB1dGlscy5vYmplY3Quc2hhbGxvd0NvcHkoc2VsZWN0KTtcbiAgICAgICAgZGVsZXRlIHNlbGVjdC5faWQ7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKG1vZC5vcHRpb25zLm9wdGlvbnMgJiYgbW9kLm9wdGlvbnMub3B0aW9ucy5saW1pdCAhPSBudWxsKSB7XG4gICAgICBhc3NpZ25tZW50T3B0cy5vcmlnaW5hbExpbWl0ID0gbW9kLm9wdGlvbnMub3B0aW9ucy5saW1pdDtcbiAgICB9IGVsc2UgaWYgKG1vZC5vcHRpb25zLmxpbWl0ICE9IG51bGwpIHtcbiAgICAgIGFzc2lnbm1lbnRPcHRzLm9yaWdpbmFsTGltaXQgPSBtb2Qub3B0aW9ucy5saW1pdDtcbiAgICB9XG4gICAgcGFyYW1zLnB1c2goW21vZCwgbWF0Y2gsIHNlbGVjdCwgYXNzaWdubWVudE9wdHMsIF9uZXh0XSk7XG4gIH1cbiAgaWYgKCFoYXNPbmUpIHtcbiAgICAvLyBJZiBtb2RlbHMgYnV0IG5vIGRvY3MsIHNraXAgZnVydGhlciBkZWVwIHBvcHVsYXRlLlxuICAgIGlmIChtb2RlbHNNYXAubGVuZ3RoICE9PSAwKSB7XG4gICAgICByZXR1cm4gY2FsbGJhY2soKTtcbiAgICB9XG4gICAgLy8gSWYgbm8gbW9kZWxzIHRvIHBvcHVsYXRlIGJ1dCB3ZSBoYXZlIGEgbmVzdGVkIHBvcHVsYXRlLFxuICAgIC8vIGtlZXAgdHJ5aW5nLCByZTogZ2gtODk0NlxuICAgIGlmIChwb3B1bGF0ZU9wdGlvbnMucG9wdWxhdGUgIT0gbnVsbCkge1xuICAgICAgY29uc3Qgb3B0cyA9IHV0aWxzLnBvcHVsYXRlKHBvcHVsYXRlT3B0aW9ucy5wb3B1bGF0ZSkubWFwKHBvcCA9PiBPYmplY3QuYXNzaWduKHt9LCBwb3AsIHtcbiAgICAgICAgcGF0aDogcG9wdWxhdGVPcHRpb25zLnBhdGggKyAnLicgKyBwb3AucGF0aFxuICAgICAgfSkpO1xuICAgICAgbW9kZWwucG9wdWxhdGUoZG9jcywgb3B0cykudGhlbihyZXMgPT4geyBjYWxsYmFjayhudWxsLCByZXMpOyB9LCBlcnIgPT4geyBjYWxsYmFjayhlcnIpOyB9KTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgcmV0dXJuIGNhbGxiYWNrKCk7XG4gIH1cblxuICBmb3IgKGNvbnN0IGFyciBvZiBwYXJhbXMpIHtcbiAgICBfZXhlY1BvcHVsYXRlUXVlcnkuYXBwbHkobnVsbCwgYXJyKTtcbiAgfVxuICBmdW5jdGlvbiBfbmV4dChlcnIsIHZhbHNGcm9tRGIpIHtcbiAgICBpZiAoZXJyICE9IG51bGwpIHtcbiAgICAgIHJldHVybiBjYWxsYmFjayhlcnIsIG51bGwpO1xuICAgIH1cbiAgICB2YWxzID0gdmFscy5jb25jYXQodmFsc0Zyb21EYik7XG4gICAgaWYgKC0tX3JlbWFpbmluZyA9PT0gMCkge1xuICAgICAgX2RvbmUoKTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBfZG9uZSgpIHtcbiAgICBmb3IgKGNvbnN0IGFyciBvZiBwYXJhbXMpIHtcbiAgICAgIGNvbnN0IG1vZCA9IGFyclswXTtcbiAgICAgIGNvbnN0IGFzc2lnbm1lbnRPcHRzID0gYXJyWzNdO1xuICAgICAgZm9yIChjb25zdCB2YWwgb2YgdmFscykge1xuICAgICAgICBtb2Qub3B0aW9ucy5fY2hpbGREb2NzLnB1c2godmFsKTtcbiAgICAgIH1cbiAgICAgIHRyeSB7XG4gICAgICAgIF9hc3NpZ24obW9kZWwsIHZhbHMsIG1vZCwgYXNzaWdubWVudE9wdHMpO1xuICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgIHJldHVybiBjYWxsYmFjayhlcnIpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGZvciAoY29uc3QgYXJyIG9mIHBhcmFtcykge1xuICAgICAgcmVtb3ZlRGVzZWxlY3RlZEZvcmVpZ25GaWVsZChhcnJbMF0uZm9yZWlnbkZpZWxkLCBhcnJbMF0ub3B0aW9ucywgdmFscyk7XG4gICAgfVxuICAgIGZvciAoY29uc3QgYXJyIG9mIHBhcmFtcykge1xuICAgICAgY29uc3QgbW9kID0gYXJyWzBdO1xuICAgICAgaWYgKG1vZC5vcHRpb25zICYmIG1vZC5vcHRpb25zLm9wdGlvbnMgJiYgbW9kLm9wdGlvbnMub3B0aW9ucy5fbGVhblRyYW5zZm9ybSkge1xuICAgICAgICBmb3IgKGNvbnN0IGRvYyBvZiB2YWxzKSB7XG4gICAgICAgICAgbW9kLm9wdGlvbnMub3B0aW9ucy5fbGVhblRyYW5zZm9ybShkb2MpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIGNhbGxiYWNrKCk7XG4gIH1cbn1cblxuLyohXG4gKiBpZ25vcmVcbiAqL1xuXG5mdW5jdGlvbiBfZXhlY1BvcHVsYXRlUXVlcnkobW9kLCBtYXRjaCwgc2VsZWN0LCBhc3NpZ25tZW50T3B0cywgY2FsbGJhY2spIHtcbiAgbGV0IHN1YlBvcHVsYXRlID0gY2xvbmUobW9kLm9wdGlvbnMucG9wdWxhdGUpO1xuICBjb25zdCBxdWVyeU9wdGlvbnMgPSBPYmplY3QuYXNzaWduKHtcbiAgICBza2lwOiBtb2Qub3B0aW9ucy5za2lwLFxuICAgIGxpbWl0OiBtb2Qub3B0aW9ucy5saW1pdCxcbiAgICBwZXJEb2N1bWVudExpbWl0OiBtb2Qub3B0aW9ucy5wZXJEb2N1bWVudExpbWl0XG4gIH0sIG1vZC5vcHRpb25zLm9wdGlvbnMpO1xuXG4gIGlmIChtb2QuY291bnQpIHtcbiAgICBkZWxldGUgcXVlcnlPcHRpb25zLnNraXA7XG4gIH1cblxuICBpZiAocXVlcnlPcHRpb25zLnBlckRvY3VtZW50TGltaXQgIT0gbnVsbCkge1xuICAgIHF1ZXJ5T3B0aW9ucy5saW1pdCA9IHF1ZXJ5T3B0aW9ucy5wZXJEb2N1bWVudExpbWl0O1xuICAgIGRlbGV0ZSBxdWVyeU9wdGlvbnMucGVyRG9jdW1lbnRMaW1pdDtcbiAgfSBlbHNlIGlmIChxdWVyeU9wdGlvbnMubGltaXQgIT0gbnVsbCkge1xuICAgIHF1ZXJ5T3B0aW9ucy5saW1pdCA9IHF1ZXJ5T3B0aW9ucy5saW1pdCAqIG1vZC5pZHMubGVuZ3RoO1xuICB9XG5cbiAgY29uc3QgcXVlcnkgPSBtb2QubW9kZWwuZmluZChtYXRjaCwgc2VsZWN0LCBxdWVyeU9wdGlvbnMpO1xuICAvLyBJZiB3ZSdyZSBkb2luZyB2aXJ0dWFsIHBvcHVsYXRlIGFuZCBwcm9qZWN0aW9uIGlzIGluY2x1c2l2ZSBhbmQgZm9yZWlnblxuICAvLyBmaWVsZCBpcyBub3Qgc2VsZWN0ZWQsIGF1dG9tYXRpY2FsbHkgc2VsZWN0IGl0IGJlY2F1c2UgbW9uZ29vc2UgbmVlZHMgaXQuXG4gIC8vIElmIHByb2plY3Rpb24gaXMgZXhjbHVzaXZlIGFuZCBjbGllbnQgZXhwbGljaXRseSB1bnNlbGVjdGVkIHRoZSBmb3JlaWduXG4gIC8vIGZpZWxkLCB0aGF0J3MgdGhlIGNsaWVudCdzIGZhdWx0LlxuICBmb3IgKGNvbnN0IGZvcmVpZ25GaWVsZCBvZiBtb2QuZm9yZWlnbkZpZWxkKSB7XG4gICAgaWYgKGZvcmVpZ25GaWVsZCAhPT0gJ19pZCcgJiZcbiAgICAgICAgcXVlcnkuc2VsZWN0ZWRJbmNsdXNpdmVseSgpICYmXG4gICAgICAgICFpc1BhdGhTZWxlY3RlZEluY2x1c2l2ZShxdWVyeS5fZmllbGRzLCBmb3JlaWduRmllbGQpKSB7XG4gICAgICBxdWVyeS5zZWxlY3QoZm9yZWlnbkZpZWxkKTtcbiAgICB9XG4gIH1cblxuICAvLyBJZiB1c2luZyBjb3VudCwgc3RpbGwgbmVlZCB0aGUgYGZvcmVpZ25GaWVsZGAgc28gd2UgY2FuIG1hdGNoIGNvdW50c1xuICAvLyB0byBkb2N1bWVudHMsIG90aGVyd2lzZSB3ZSB3b3VsZCBuZWVkIGEgc2VwYXJhdGUgYGNvdW50KClgIGZvciBldmVyeSBkb2MuXG4gIGlmIChtb2QuY291bnQpIHtcbiAgICBmb3IgKGNvbnN0IGZvcmVpZ25GaWVsZCBvZiBtb2QuZm9yZWlnbkZpZWxkKSB7XG4gICAgICBxdWVyeS5zZWxlY3QoZm9yZWlnbkZpZWxkKTtcbiAgICB9XG4gIH1cblxuICAvLyBJZiB3ZSBuZWVkIHRvIHN1Yi1wb3B1bGF0ZSwgY2FsbCBwb3B1bGF0ZSByZWN1cnNpdmVseVxuICBpZiAoc3ViUG9wdWxhdGUpIHtcbiAgICAvLyBJZiBzdWJwb3B1bGF0aW5nIG9uIGEgZGlzY3JpbWluYXRvciwgc2tpcCBjaGVjayBmb3Igbm9uLWV4aXN0ZW50XG4gICAgLy8gcGF0aHMuIEJlY2F1c2UgdGhlIGRpc2NyaW1pbmF0b3IgbWF5IG5vdCBoYXZlIHRoZSBwYXRoIGRlZmluZWQuXG4gICAgaWYgKG1vZC5tb2RlbC5iYXNlTW9kZWxOYW1lICE9IG51bGwpIHtcbiAgICAgIGlmIChBcnJheS5pc0FycmF5KHN1YlBvcHVsYXRlKSkge1xuICAgICAgICBzdWJQb3B1bGF0ZS5mb3JFYWNoKHBvcCA9PiB7IHBvcC5zdHJpY3RQb3B1bGF0ZSA9IGZhbHNlOyB9KTtcbiAgICAgIH0gZWxzZSBpZiAodHlwZW9mIHN1YlBvcHVsYXRlID09PSAnc3RyaW5nJykge1xuICAgICAgICBzdWJQb3B1bGF0ZSA9IHsgcGF0aDogc3ViUG9wdWxhdGUsIHN0cmljdFBvcHVsYXRlOiBmYWxzZSB9O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc3ViUG9wdWxhdGUuc3RyaWN0UG9wdWxhdGUgPSBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG4gICAgY29uc3QgYmFzZVBhdGggPSBtb2Qub3B0aW9ucy5fZnVsbFBhdGggfHwgbW9kLm9wdGlvbnMucGF0aDtcblxuICAgIGlmIChBcnJheS5pc0FycmF5KHN1YlBvcHVsYXRlKSkge1xuICAgICAgZm9yIChjb25zdCBwb3Agb2Ygc3ViUG9wdWxhdGUpIHtcbiAgICAgICAgcG9wLl9mdWxsUGF0aCA9IGJhc2VQYXRoICsgJy4nICsgcG9wLnBhdGg7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmICh0eXBlb2Ygc3ViUG9wdWxhdGUgPT09ICdvYmplY3QnKSB7XG4gICAgICBzdWJQb3B1bGF0ZS5fZnVsbFBhdGggPSBiYXNlUGF0aCArICcuJyArIHN1YlBvcHVsYXRlLnBhdGg7XG4gICAgfVxuXG4gICAgcXVlcnkucG9wdWxhdGUoc3ViUG9wdWxhdGUpO1xuICB9XG5cbiAgcXVlcnkuZXhlYygpLnRoZW4oXG4gICAgZG9jcyA9PiB7XG4gICAgICBmb3IgKGNvbnN0IHZhbCBvZiBkb2NzKSB7XG4gICAgICAgIGxlYW5Qb3B1bGF0ZU1hcC5zZXQodmFsLCBtb2QubW9kZWwpO1xuICAgICAgfVxuICAgICAgY2FsbGJhY2sobnVsbCwgZG9jcyk7XG4gICAgfSxcbiAgICBlcnIgPT4ge1xuICAgICAgY2FsbGJhY2soZXJyKTtcbiAgICB9XG4gICk7XG59XG5cbi8qIVxuICogaWdub3JlXG4gKi9cblxuZnVuY3Rpb24gX2Fzc2lnbihtb2RlbCwgdmFscywgbW9kLCBhc3NpZ25tZW50T3B0cykge1xuICBjb25zdCBvcHRpb25zID0gbW9kLm9wdGlvbnM7XG4gIGNvbnN0IGlzVmlydHVhbCA9IG1vZC5pc1ZpcnR1YWw7XG4gIGNvbnN0IGp1c3RPbmUgPSBtb2QuanVzdE9uZTtcbiAgbGV0IF92YWw7XG4gIGNvbnN0IGxlYW4gPSBvcHRpb25zICYmXG4gICAgb3B0aW9ucy5vcHRpb25zICYmXG4gICAgb3B0aW9ucy5vcHRpb25zLmxlYW4gfHwgZmFsc2U7XG4gIGNvbnN0IGxlbiA9IHZhbHMubGVuZ3RoO1xuICBjb25zdCByYXdPcmRlciA9IHt9O1xuICBjb25zdCByYXdEb2NzID0ge307XG4gIGxldCBrZXk7XG4gIGxldCB2YWw7XG5cbiAgLy8gQ2xvbmUgYmVjYXVzZSBgYXNzaWduUmF3RG9jc1RvSWRTdHJ1Y3R1cmVgIHdpbGwgbXV0YXRlIHRoZSBhcnJheVxuICBjb25zdCBhbGxJZHMgPSBjbG9uZShtb2QuYWxsSWRzKTtcbiAgLy8gb3B0aW1pemF0aW9uOlxuICAvLyByZWNvcmQgdGhlIGRvY3VtZW50IHBvc2l0aW9ucyBhcyByZXR1cm5lZCBieVxuICAvLyB0aGUgcXVlcnkgcmVzdWx0LlxuICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgdmFsID0gdmFsc1tpXTtcbiAgICBpZiAodmFsID09IG51bGwpIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICBmb3IgKGNvbnN0IGZvcmVpZ25GaWVsZCBvZiBtb2QuZm9yZWlnbkZpZWxkKSB7XG4gICAgICBfdmFsID0gdXRpbHMuZ2V0VmFsdWUoZm9yZWlnbkZpZWxkLCB2YWwpO1xuICAgICAgaWYgKEFycmF5LmlzQXJyYXkoX3ZhbCkpIHtcbiAgICAgICAgX3ZhbCA9IHV0aWxzLmFycmF5LnVuaXF1ZSh1dGlscy5hcnJheS5mbGF0dGVuKF92YWwpKTtcblxuICAgICAgICBmb3IgKGxldCBfX3ZhbCBvZiBfdmFsKSB7XG4gICAgICAgICAgaWYgKF9fdmFsIGluc3RhbmNlb2YgRG9jdW1lbnQpIHtcbiAgICAgICAgICAgIF9fdmFsID0gX192YWwuX2lkO1xuICAgICAgICAgIH1cbiAgICAgICAgICBrZXkgPSBTdHJpbmcoX192YWwpO1xuICAgICAgICAgIGlmIChyYXdEb2NzW2tleV0pIHtcbiAgICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KHJhd0RvY3Nba2V5XSkpIHtcbiAgICAgICAgICAgICAgcmF3RG9jc1trZXldLnB1c2godmFsKTtcbiAgICAgICAgICAgICAgcmF3T3JkZXJba2V5XS5wdXNoKGkpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgcmF3RG9jc1trZXldID0gW3Jhd0RvY3Nba2V5XSwgdmFsXTtcbiAgICAgICAgICAgICAgcmF3T3JkZXJba2V5XSA9IFtyYXdPcmRlcltrZXldLCBpXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaWYgKGlzVmlydHVhbCAmJiAhanVzdE9uZSkge1xuICAgICAgICAgICAgICByYXdEb2NzW2tleV0gPSBbdmFsXTtcbiAgICAgICAgICAgICAgcmF3T3JkZXJba2V5XSA9IFtpXTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHJhd0RvY3Nba2V5XSA9IHZhbDtcbiAgICAgICAgICAgICAgcmF3T3JkZXJba2V5XSA9IGk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAoX3ZhbCBpbnN0YW5jZW9mIERvY3VtZW50KSB7XG4gICAgICAgICAgX3ZhbCA9IF92YWwuX2lkO1xuICAgICAgICB9XG4gICAgICAgIGtleSA9IFN0cmluZyhfdmFsKTtcbiAgICAgICAgaWYgKHJhd0RvY3Nba2V5XSkge1xuICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KHJhd0RvY3Nba2V5XSkpIHtcbiAgICAgICAgICAgIHJhd0RvY3Nba2V5XS5wdXNoKHZhbCk7XG4gICAgICAgICAgICByYXdPcmRlcltrZXldLnB1c2goaSk7XG4gICAgICAgICAgfSBlbHNlIGlmIChpc1ZpcnR1YWwgfHxcbiAgICAgICAgICAgIHJhd0RvY3Nba2V5XS5jb25zdHJ1Y3RvciAhPT0gdmFsLmNvbnN0cnVjdG9yIHx8XG4gICAgICAgICAgICBTdHJpbmcocmF3RG9jc1trZXldLl9pZCkgIT09IFN0cmluZyh2YWwuX2lkKSkge1xuICAgICAgICAgICAgLy8gTWF5IG5lZWQgdG8gc3RvcmUgbXVsdGlwbGUgZG9jcyB3aXRoIHRoZSBzYW1lIGlkIGlmIHRoZXJlJ3MgbXVsdGlwbGUgbW9kZWxzXG4gICAgICAgICAgICAvLyBpZiB3ZSBoYXZlIGRpc2NyaW1pbmF0b3JzIG9yIGEgcmVmIGZ1bmN0aW9uLiBCdXQgYXZvaWQgY29udmVydGluZyB0byBhbiBhcnJheVxuICAgICAgICAgICAgLy8gaWYgd2UgaGF2ZSBtdWx0aXBsZSBxdWVyaWVzIG9uIHRoZSBzYW1lIG1vZGVsIGJlY2F1c2Ugb2YgYHBlckRvY3VtZW50TGltaXRgIHJlOiBnaC05OTA2XG4gICAgICAgICAgICByYXdEb2NzW2tleV0gPSBbcmF3RG9jc1trZXldLCB2YWxdO1xuICAgICAgICAgICAgcmF3T3JkZXJba2V5XSA9IFtyYXdPcmRlcltrZXldLCBpXTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmF3RG9jc1trZXldID0gdmFsO1xuICAgICAgICAgIHJhd09yZGVyW2tleV0gPSBpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICAvLyBmbGFnIGVhY2ggYXMgcmVzdWx0IG9mIHBvcHVsYXRpb25cbiAgICAgIGlmICghbGVhbikge1xuICAgICAgICB2YWwuJF9fLndhc1BvcHVsYXRlZCA9IHZhbC4kX18ud2FzUG9wdWxhdGVkIHx8IHRydWU7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgYXNzaWduVmFscyh7XG4gICAgb3JpZ2luYWxNb2RlbDogbW9kZWwsXG4gICAgLy8gSWYgdmlydHVhbCwgbWFrZSBzdXJlIHRvIG5vdCBtdXRhdGUgb3JpZ2luYWwgZmllbGRcbiAgICByYXdJZHM6IG1vZC5pc1ZpcnR1YWwgPyBhbGxJZHMgOiBtb2QuYWxsSWRzLFxuICAgIGFsbElkczogYWxsSWRzLFxuICAgIHVucG9wdWxhdGVkVmFsdWVzOiBtb2QudW5wb3B1bGF0ZWRWYWx1ZXMsXG4gICAgZm9yZWlnbkZpZWxkOiBtb2QuZm9yZWlnbkZpZWxkLFxuICAgIHJhd0RvY3M6IHJhd0RvY3MsXG4gICAgcmF3T3JkZXI6IHJhd09yZGVyLFxuICAgIGRvY3M6IG1vZC5kb2NzLFxuICAgIHBhdGg6IG9wdGlvbnMucGF0aCxcbiAgICBvcHRpb25zOiBhc3NpZ25tZW50T3B0cyxcbiAgICBqdXN0T25lOiBtb2QuanVzdE9uZSxcbiAgICBpc1ZpcnR1YWw6IG1vZC5pc1ZpcnR1YWwsXG4gICAgYWxsT3B0aW9uczogbW9kLFxuICAgIHBvcHVsYXRlZE1vZGVsOiBtb2QubW9kZWwsXG4gICAgbGVhbjogbGVhbixcbiAgICB2aXJ0dWFsOiBtb2QudmlydHVhbCxcbiAgICBjb3VudDogbW9kLmNvdW50LFxuICAgIG1hdGNoOiBtb2QubWF0Y2hcbiAgfSk7XG59XG5cbi8qKlxuICogQ29tcGlsZXIgdXRpbGl0eS5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ3xGdW5jdGlvbn0gbmFtZSBtb2RlbCBuYW1lIG9yIGNsYXNzIGV4dGVuZGluZyBNb2RlbFxuICogQHBhcmFtIHtTY2hlbWF9IHNjaGVtYVxuICogQHBhcmFtIHtTdHJpbmd9IGNvbGxlY3Rpb25OYW1lXG4gKiBAcGFyYW0ge0Nvbm5lY3Rpb259IGNvbm5lY3Rpb25cbiAqIEBwYXJhbSB7TW9uZ29vc2V9IGJhc2UgbW9uZ29vc2UgaW5zdGFuY2VcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbk1vZGVsLmNvbXBpbGUgPSBmdW5jdGlvbiBjb21waWxlKG5hbWUsIHNjaGVtYSwgY29sbGVjdGlvbk5hbWUsIGNvbm5lY3Rpb24sIGJhc2UpIHtcbiAgY29uc3QgdmVyc2lvbmluZ0VuYWJsZWQgPSBzY2hlbWEub3B0aW9ucy52ZXJzaW9uS2V5ICE9PSBmYWxzZTtcblxuICBpZiAodmVyc2lvbmluZ0VuYWJsZWQgJiYgIXNjaGVtYS5wYXRoc1tzY2hlbWEub3B0aW9ucy52ZXJzaW9uS2V5XSkge1xuICAgIC8vIGFkZCB2ZXJzaW9uaW5nIHRvIHRvcCBsZXZlbCBkb2N1bWVudHMgb25seVxuICAgIGNvbnN0IG8gPSB7fTtcbiAgICBvW3NjaGVtYS5vcHRpb25zLnZlcnNpb25LZXldID0gTnVtYmVyO1xuICAgIHNjaGVtYS5hZGQobyk7XG4gIH1cbiAgbGV0IG1vZGVsO1xuICBpZiAodHlwZW9mIG5hbWUgPT09ICdmdW5jdGlvbicgJiYgbmFtZS5wcm90b3R5cGUgaW5zdGFuY2VvZiBNb2RlbCkge1xuICAgIG1vZGVsID0gbmFtZTtcbiAgICBuYW1lID0gbW9kZWwubmFtZTtcbiAgICBzY2hlbWEubG9hZENsYXNzKG1vZGVsLCBmYWxzZSk7XG4gICAgbW9kZWwucHJvdG90eXBlLiRpc01vbmdvb3NlTW9kZWxQcm90b3R5cGUgPSB0cnVlO1xuICB9IGVsc2Uge1xuICAgIC8vIGdlbmVyYXRlIG5ldyBjbGFzc1xuICAgIG1vZGVsID0gZnVuY3Rpb24gbW9kZWwoZG9jLCBmaWVsZHMsIHNraXBJZCkge1xuICAgICAgbW9kZWwuaG9va3MuZXhlY1ByZVN5bmMoJ2NyZWF0ZU1vZGVsJywgZG9jKTtcbiAgICAgIGlmICghKHRoaXMgaW5zdGFuY2VvZiBtb2RlbCkpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBtb2RlbChkb2MsIGZpZWxkcywgc2tpcElkKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGRpc2NyaW1pbmF0b3JLZXkgPSBtb2RlbC5zY2hlbWEub3B0aW9ucy5kaXNjcmltaW5hdG9yS2V5O1xuXG4gICAgICBpZiAobW9kZWwuZGlzY3JpbWluYXRvcnMgPT0gbnVsbCB8fCBkb2MgPT0gbnVsbCB8fCBkb2NbZGlzY3JpbWluYXRvcktleV0gPT0gbnVsbCkge1xuICAgICAgICBNb2RlbC5jYWxsKHRoaXMsIGRvYywgZmllbGRzLCBza2lwSWQpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIC8vIElmIGRpc2NyaW1pbmF0b3Iga2V5IGlzIHNldCwgdXNlIHRoZSBkaXNjcmltaW5hdG9yIGluc3RlYWQgKGdoLTc1ODYpXG4gICAgICBjb25zdCBEaXNjcmltaW5hdG9yID0gbW9kZWwuZGlzY3JpbWluYXRvcnNbZG9jW2Rpc2NyaW1pbmF0b3JLZXldXSB8fFxuICAgICAgICBnZXREaXNjcmltaW5hdG9yQnlWYWx1ZShtb2RlbC5kaXNjcmltaW5hdG9ycywgZG9jW2Rpc2NyaW1pbmF0b3JLZXldKTtcbiAgICAgIGlmIChEaXNjcmltaW5hdG9yICE9IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBEaXNjcmltaW5hdG9yKGRvYywgZmllbGRzLCBza2lwSWQpO1xuICAgICAgfVxuXG4gICAgICAvLyBPdGhlcndpc2UsIGp1c3QgdXNlIHRoZSB0b3AtbGV2ZWwgbW9kZWxcbiAgICAgIE1vZGVsLmNhbGwodGhpcywgZG9jLCBmaWVsZHMsIHNraXBJZCk7XG4gICAgfTtcbiAgfVxuXG4gIG1vZGVsLmhvb2tzID0gc2NoZW1hLnMuaG9va3MuY2xvbmUoKTtcbiAgbW9kZWwuYmFzZSA9IGJhc2U7XG4gIG1vZGVsLm1vZGVsTmFtZSA9IG5hbWU7XG5cbiAgaWYgKCEobW9kZWwucHJvdG90eXBlIGluc3RhbmNlb2YgTW9kZWwpKSB7XG4gICAgT2JqZWN0LnNldFByb3RvdHlwZU9mKG1vZGVsLCBNb2RlbCk7XG4gICAgT2JqZWN0LnNldFByb3RvdHlwZU9mKG1vZGVsLnByb3RvdHlwZSwgTW9kZWwucHJvdG90eXBlKTtcbiAgfVxuICBtb2RlbC5tb2RlbCA9IGZ1bmN0aW9uIG1vZGVsKG5hbWUpIHtcbiAgICByZXR1cm4gdGhpcy5kYi5tb2RlbChuYW1lKTtcbiAgfTtcblxuICBtb2RlbC5kYiA9IGNvbm5lY3Rpb247XG4gIG1vZGVsLnByb3RvdHlwZS5kYiA9IGNvbm5lY3Rpb247XG4gIG1vZGVsLnByb3RvdHlwZVttb2RlbERiU3ltYm9sXSA9IGNvbm5lY3Rpb247XG4gIG1vZGVsLmRpc2NyaW1pbmF0b3JzID0gbW9kZWwucHJvdG90eXBlLmRpc2NyaW1pbmF0b3JzID0gdW5kZWZpbmVkO1xuICBtb2RlbFttb2RlbFN5bWJvbF0gPSB0cnVlO1xuICBtb2RlbC5ldmVudHMgPSBuZXcgRXZlbnRFbWl0dGVyKCk7XG5cbiAgc2NoZW1hLl9wcmVDb21waWxlKCk7XG5cbiAgY29uc3QgX3VzZXJQcm92aWRlZE9wdGlvbnMgPSBzY2hlbWEuX3VzZXJQcm92aWRlZE9wdGlvbnMgfHwge307XG5cbiAgY29uc3QgY29sbGVjdGlvbk9wdGlvbnMgPSB7XG4gICAgc2NoZW1hVXNlclByb3ZpZGVkT3B0aW9uczogX3VzZXJQcm92aWRlZE9wdGlvbnMsXG4gICAgY2FwcGVkOiBzY2hlbWEub3B0aW9ucy5jYXBwZWQsXG4gICAgUHJvbWlzZTogbW9kZWwuYmFzZS5Qcm9taXNlLFxuICAgIG1vZGVsTmFtZTogbmFtZVxuICB9O1xuICBpZiAoc2NoZW1hLm9wdGlvbnMuYXV0b0NyZWF0ZSAhPT0gdm9pZCAwKSB7XG4gICAgY29sbGVjdGlvbk9wdGlvbnMuYXV0b0NyZWF0ZSA9IHNjaGVtYS5vcHRpb25zLmF1dG9DcmVhdGU7XG4gIH1cblxuICBjb25zdCBjb2xsZWN0aW9uID0gY29ubmVjdGlvbi5jb2xsZWN0aW9uKFxuICAgIGNvbGxlY3Rpb25OYW1lLFxuICAgIGNvbGxlY3Rpb25PcHRpb25zXG4gICk7XG5cbiAgbW9kZWwucHJvdG90eXBlLmNvbGxlY3Rpb24gPSBjb2xsZWN0aW9uO1xuICBtb2RlbC5wcm90b3R5cGUuJGNvbGxlY3Rpb24gPSBjb2xsZWN0aW9uO1xuICBtb2RlbC5wcm90b3R5cGVbbW9kZWxDb2xsZWN0aW9uU3ltYm9sXSA9IGNvbGxlY3Rpb247XG5cbiAgbW9kZWwucHJvdG90eXBlLiRfX3NldFNjaGVtYShzY2hlbWEpO1xuXG4gIC8vIGFwcGx5IG1ldGhvZHMgYW5kIHN0YXRpY3NcbiAgYXBwbHlNZXRob2RzKG1vZGVsLCBzY2hlbWEpO1xuICBhcHBseVN0YXRpY3MobW9kZWwsIHNjaGVtYSk7XG4gIGFwcGx5SG9va3MobW9kZWwsIHNjaGVtYSk7XG4gIGFwcGx5U3RhdGljSG9va3MobW9kZWwsIHNjaGVtYS5zLmhvb2tzLCBzY2hlbWEuc3RhdGljcyk7XG5cbiAgbW9kZWwuc2NoZW1hID0gbW9kZWwucHJvdG90eXBlLiRfX3NjaGVtYTtcbiAgbW9kZWwuY29sbGVjdGlvbiA9IGNvbGxlY3Rpb247XG4gIG1vZGVsLiRfX2NvbGxlY3Rpb24gPSBjb2xsZWN0aW9uO1xuXG4gIC8vIENyZWF0ZSBjdXN0b20gcXVlcnkgY29uc3RydWN0b3JcbiAgbW9kZWwuUXVlcnkgPSBmdW5jdGlvbigpIHtcbiAgICBRdWVyeS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICB9O1xuICBPYmplY3Quc2V0UHJvdG90eXBlT2YobW9kZWwuUXVlcnkucHJvdG90eXBlLCBRdWVyeS5wcm90b3R5cGUpO1xuICBtb2RlbC5RdWVyeS5iYXNlID0gUXVlcnkuYmFzZTtcbiAgbW9kZWwuUXVlcnkucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gUXVlcnk7XG4gIGFwcGx5UXVlcnlNaWRkbGV3YXJlKG1vZGVsLlF1ZXJ5LCBtb2RlbCk7XG4gIGFwcGx5UXVlcnlNZXRob2RzKG1vZGVsLCBzY2hlbWEucXVlcnkpO1xuXG4gIHJldHVybiBtb2RlbDtcbn07XG5cbi8qKlxuICogUmVnaXN0ZXIgY3VzdG9tIHF1ZXJ5IG1ldGhvZHMgZm9yIHRoaXMgbW9kZWxcbiAqXG4gKiBAcGFyYW0ge01vZGVsfSBtb2RlbFxuICogQHBhcmFtIHtTY2hlbWF9IHNjaGVtYVxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZnVuY3Rpb24gYXBwbHlRdWVyeU1ldGhvZHMobW9kZWwsIG1ldGhvZHMpIHtcbiAgZm9yIChjb25zdCBpIGluIG1ldGhvZHMpIHtcbiAgICBtb2RlbC5RdWVyeS5wcm90b3R5cGVbaV0gPSBtZXRob2RzW2ldO1xuICB9XG59XG5cbi8qKlxuICogU3ViY2xhc3MgdGhpcyBtb2RlbCB3aXRoIGBjb25uYCwgYHNjaGVtYWAsIGFuZCBgY29sbGVjdGlvbmAgc2V0dGluZ3MuXG4gKlxuICogQHBhcmFtIHtDb25uZWN0aW9ufSBjb25uXG4gKiBAcGFyYW0ge1NjaGVtYX0gW3NjaGVtYV1cbiAqIEBwYXJhbSB7U3RyaW5nfSBbY29sbGVjdGlvbl1cbiAqIEByZXR1cm4ge01vZGVsfVxuICogQGFwaSBwcml2YXRlXG4gKiBAbWVtYmVyT2YgTW9kZWxcbiAqIEBzdGF0aWNcbiAqIEBtZXRob2QgX19zdWJjbGFzc1xuICovXG5cbk1vZGVsLl9fc3ViY2xhc3MgPSBmdW5jdGlvbiBzdWJjbGFzcyhjb25uLCBzY2hlbWEsIGNvbGxlY3Rpb24pIHtcbiAgLy8gc3ViY2xhc3MgbW9kZWwgdXNpbmcgdGhpcyBjb25uZWN0aW9uIGFuZCBjb2xsZWN0aW9uIG5hbWVcbiAgY29uc3QgX3RoaXMgPSB0aGlzO1xuXG4gIGNvbnN0IE1vZGVsID0gZnVuY3Rpb24gTW9kZWwoZG9jLCBmaWVsZHMsIHNraXBJZCkge1xuICAgIGlmICghKHRoaXMgaW5zdGFuY2VvZiBNb2RlbCkpIHtcbiAgICAgIHJldHVybiBuZXcgTW9kZWwoZG9jLCBmaWVsZHMsIHNraXBJZCk7XG4gICAgfVxuICAgIF90aGlzLmNhbGwodGhpcywgZG9jLCBmaWVsZHMsIHNraXBJZCk7XG4gIH07XG5cbiAgT2JqZWN0LnNldFByb3RvdHlwZU9mKE1vZGVsLCBfdGhpcyk7XG4gIE9iamVjdC5zZXRQcm90b3R5cGVPZihNb2RlbC5wcm90b3R5cGUsIF90aGlzLnByb3RvdHlwZSk7XG4gIE1vZGVsLmRiID0gY29ubjtcbiAgTW9kZWwucHJvdG90eXBlLmRiID0gY29ubjtcbiAgTW9kZWwucHJvdG90eXBlW21vZGVsRGJTeW1ib2xdID0gY29ubjtcblxuICBfdGhpc1tzdWJjbGFzc2VkU3ltYm9sXSA9IF90aGlzW3N1YmNsYXNzZWRTeW1ib2xdIHx8IFtdO1xuICBfdGhpc1tzdWJjbGFzc2VkU3ltYm9sXS5wdXNoKE1vZGVsKTtcbiAgaWYgKF90aGlzLmRpc2NyaW1pbmF0b3JzICE9IG51bGwpIHtcbiAgICBNb2RlbC5kaXNjcmltaW5hdG9ycyA9IHt9O1xuICAgIGZvciAoY29uc3Qga2V5IG9mIE9iamVjdC5rZXlzKF90aGlzLmRpc2NyaW1pbmF0b3JzKSkge1xuICAgICAgTW9kZWwuZGlzY3JpbWluYXRvcnNba2V5XSA9IF90aGlzLmRpc2NyaW1pbmF0b3JzW2tleV0uXG4gICAgICAgIF9fc3ViY2xhc3MoX3RoaXMuZGIsIF90aGlzLmRpc2NyaW1pbmF0b3JzW2tleV0uc2NoZW1hLCBjb2xsZWN0aW9uKTtcbiAgICB9XG4gIH1cblxuICBjb25zdCBzID0gc2NoZW1hICYmIHR5cGVvZiBzY2hlbWEgIT09ICdzdHJpbmcnXG4gICAgPyBzY2hlbWFcbiAgICA6IF90aGlzLnByb3RvdHlwZS4kX19zY2hlbWE7XG5cbiAgY29uc3Qgb3B0aW9ucyA9IHMub3B0aW9ucyB8fCB7fTtcbiAgY29uc3QgX3VzZXJQcm92aWRlZE9wdGlvbnMgPSBzLl91c2VyUHJvdmlkZWRPcHRpb25zIHx8IHt9O1xuXG4gIGlmICghY29sbGVjdGlvbikge1xuICAgIGNvbGxlY3Rpb24gPSBfdGhpcy5wcm90b3R5cGUuJF9fc2NoZW1hLmdldCgnY29sbGVjdGlvbicpIHx8XG4gICAgICB1dGlscy50b0NvbGxlY3Rpb25OYW1lKF90aGlzLm1vZGVsTmFtZSwgdGhpcy5iYXNlLnBsdXJhbGl6ZSgpKTtcbiAgfVxuXG4gIGNvbnN0IGNvbGxlY3Rpb25PcHRpb25zID0ge1xuICAgIHNjaGVtYVVzZXJQcm92aWRlZE9wdGlvbnM6IF91c2VyUHJvdmlkZWRPcHRpb25zLFxuICAgIGNhcHBlZDogcyAmJiBvcHRpb25zLmNhcHBlZFxuICB9O1xuXG4gIE1vZGVsLnByb3RvdHlwZS5jb2xsZWN0aW9uID0gY29ubi5jb2xsZWN0aW9uKGNvbGxlY3Rpb24sIGNvbGxlY3Rpb25PcHRpb25zKTtcbiAgTW9kZWwucHJvdG90eXBlLiRjb2xsZWN0aW9uID0gTW9kZWwucHJvdG90eXBlLmNvbGxlY3Rpb247XG4gIE1vZGVsLnByb3RvdHlwZVttb2RlbENvbGxlY3Rpb25TeW1ib2xdID0gTW9kZWwucHJvdG90eXBlLmNvbGxlY3Rpb247XG4gIE1vZGVsLmNvbGxlY3Rpb24gPSBNb2RlbC5wcm90b3R5cGUuY29sbGVjdGlvbjtcbiAgTW9kZWwuJF9fY29sbGVjdGlvbiA9IE1vZGVsLmNvbGxlY3Rpb247XG4gIC8vIEVycm9ycyBoYW5kbGVkIGludGVybmFsbHksIHNvIGlnbm9yZVxuICBNb2RlbC5pbml0KCkuY2F0Y2goKCkgPT4ge30pO1xuICByZXR1cm4gTW9kZWw7XG59O1xuXG4vKipcbiAqIEhlbHBlciBmb3IgY29uc29sZS5sb2cuIEdpdmVuIGEgbW9kZWwgbmFtZWQgJ015TW9kZWwnLCByZXR1cm5zIHRoZSBzdHJpbmdcbiAqIGAnTW9kZWwgeyBNeU1vZGVsIH0nYC5cbiAqXG4gKiAjIyMjIEV4YW1wbGU6XG4gKlxuICogICAgIGNvbnN0IE15TW9kZWwgPSBtb25nb29zZS5tb2RlbCgnVGVzdCcsIFNjaGVtYSh7IG5hbWU6IFN0cmluZyB9KSk7XG4gKiAgICAgTXlNb2RlbC5pbnNwZWN0KCk7IC8vICdNb2RlbCB7IFRlc3QgfSdcbiAqICAgICBjb25zb2xlLmxvZyhNeU1vZGVsKTsgLy8gUHJpbnRzICdNb2RlbCB7IFRlc3QgfSdcbiAqXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbk1vZGVsLmluc3BlY3QgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIGBNb2RlbCB7ICR7dGhpcy5tb2RlbE5hbWV9IH1gO1xufTtcblxuaWYgKHV0aWwuaW5zcGVjdC5jdXN0b20pIHtcbiAgLy8gQXZvaWQgTm9kZSBkZXByZWNhdGlvbiB3YXJuaW5nIERFUDAwNzlcbiAgTW9kZWxbdXRpbC5pbnNwZWN0LmN1c3RvbV0gPSBNb2RlbC5pbnNwZWN0O1xufVxuXG4vKiFcbiAqIE1vZHVsZSBleHBvcnRzLlxuICovXG5cbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0cyA9IE1vZGVsO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/mongoose/lib/model.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/mongoose/lib/mongoose.js":
/*!***********************************************!*\
  !*** ./node_modules/mongoose/lib/mongoose.js ***!
  \***********************************************/
/***/ ((module, exports, __webpack_require__) => {

eval("\n\n/*!\n * Module dependencies.\n */\n\nconst Document = __webpack_require__(/*! ./document */ \"(ssr)/./node_modules/mongoose/lib/document.js\");\nconst EventEmitter = (__webpack_require__(/*! events */ \"events\").EventEmitter);\nconst Kareem = __webpack_require__(/*! kareem */ \"(ssr)/./node_modules/kareem/index.js\");\nconst Schema = __webpack_require__(/*! ./schema */ \"(ssr)/./node_modules/mongoose/lib/schema.js\");\nconst SchemaType = __webpack_require__(/*! ./schemaType */ \"(ssr)/./node_modules/mongoose/lib/schemaType.js\");\nconst SchemaTypes = __webpack_require__(/*! ./schema/index */ \"(ssr)/./node_modules/mongoose/lib/schema/index.js\");\nconst VirtualType = __webpack_require__(/*! ./virtualType */ \"(ssr)/./node_modules/mongoose/lib/virtualType.js\");\nconst STATES = __webpack_require__(/*! ./connectionState */ \"(ssr)/./node_modules/mongoose/lib/connectionState.js\");\nconst VALID_OPTIONS = __webpack_require__(/*! ./validOptions */ \"(ssr)/./node_modules/mongoose/lib/validOptions.js\");\nconst Types = __webpack_require__(/*! ./types */ \"(ssr)/./node_modules/mongoose/lib/types/index.js\");\nconst Query = __webpack_require__(/*! ./query */ \"(ssr)/./node_modules/mongoose/lib/query.js\");\nconst Model = __webpack_require__(/*! ./model */ \"(ssr)/./node_modules/mongoose/lib/model.js\");\nconst applyPlugins = __webpack_require__(/*! ./helpers/schema/applyPlugins */ \"(ssr)/./node_modules/mongoose/lib/helpers/schema/applyPlugins.js\");\nconst builtinPlugins = __webpack_require__(/*! ./plugins */ \"(ssr)/./node_modules/mongoose/lib/plugins/index.js\");\nconst driver = __webpack_require__(/*! ./driver */ \"(ssr)/./node_modules/mongoose/lib/driver.js\");\nconst legacyPluralize = __webpack_require__(/*! ./helpers/pluralize */ \"(ssr)/./node_modules/mongoose/lib/helpers/pluralize.js\");\nconst utils = __webpack_require__(/*! ./utils */ \"(ssr)/./node_modules/mongoose/lib/utils.js\");\nconst pkg = __webpack_require__(/*! ../package.json */ \"(ssr)/./node_modules/mongoose/package.json\");\nconst cast = __webpack_require__(/*! ./cast */ \"(ssr)/./node_modules/mongoose/lib/cast.js\");\n\nconst Aggregate = __webpack_require__(/*! ./aggregate */ \"(ssr)/./node_modules/mongoose/lib/aggregate.js\");\nconst trusted = (__webpack_require__(/*! ./helpers/query/trusted */ \"(ssr)/./node_modules/mongoose/lib/helpers/query/trusted.js\").trusted);\nconst sanitizeFilter = __webpack_require__(/*! ./helpers/query/sanitizeFilter */ \"(ssr)/./node_modules/mongoose/lib/helpers/query/sanitizeFilter.js\");\nconst isBsonType = __webpack_require__(/*! ./helpers/isBsonType */ \"(ssr)/./node_modules/mongoose/lib/helpers/isBsonType.js\");\nconst MongooseError = __webpack_require__(/*! ./error/mongooseError */ \"(ssr)/./node_modules/mongoose/lib/error/mongooseError.js\");\nconst SetOptionError = __webpack_require__(/*! ./error/setOptionError */ \"(ssr)/./node_modules/mongoose/lib/error/setOptionError.js\");\n\nconst defaultMongooseSymbol = Symbol.for('mongoose:default');\n\n__webpack_require__(/*! ./helpers/printJestWarning */ \"(ssr)/./node_modules/mongoose/lib/helpers/printJestWarning.js\");\n\nconst objectIdHexRegexp = /^[0-9A-Fa-f]{24}$/;\n\n/**\n * Mongoose constructor.\n *\n * The exports object of the `mongoose` module is an instance of this class.\n * Most apps will only use this one instance.\n *\n * #### Example:\n *\n *     const mongoose = require('mongoose');\n *     mongoose instanceof mongoose.Mongoose; // true\n *\n *     // Create a new Mongoose instance with its own `connect()`, `set()`, `model()`, etc.\n *     const m = new mongoose.Mongoose();\n *\n * @api public\n * @param {Object} options see [`Mongoose#set()` docs](https://mongoosejs.com/docs/api/mongoose.html#Mongoose.prototype.set())\n */\nfunction Mongoose(options) {\n  this.connections = [];\n  this.nextConnectionId = 0;\n  this.models = {};\n  this.events = new EventEmitter();\n  this.__driver = driver.get();\n  // default global options\n  this.options = Object.assign({\n    pluralization: true,\n    autoIndex: true,\n    autoCreate: true\n  }, options);\n  const createInitialConnection = utils.getOption('createInitialConnection', this.options);\n  if (createInitialConnection == null || createInitialConnection) {\n    const conn = this.createConnection(); // default connection\n    conn.models = this.models;\n  }\n\n  if (this.options.pluralization) {\n    this._pluralize = legacyPluralize;\n  }\n\n  // If a user creates their own Mongoose instance, give them a separate copy\n  // of the `Schema` constructor so they get separate custom types. (gh-6933)\n  if (!options || !options[defaultMongooseSymbol]) {\n    const _this = this;\n    this.Schema = function() {\n      this.base = _this;\n      return Schema.apply(this, arguments);\n    };\n    this.Schema.prototype = Object.create(Schema.prototype);\n\n    Object.assign(this.Schema, Schema);\n    this.Schema.base = this;\n    this.Schema.Types = Object.assign({}, Schema.Types);\n  } else {\n    // Hack to work around babel's strange behavior with\n    // `import mongoose, { Schema } from 'mongoose'`. Because `Schema` is not\n    // an own property of a Mongoose global, Schema will be undefined. See gh-5648\n    for (const key of ['Schema', 'model']) {\n      this[key] = Mongoose.prototype[key];\n    }\n  }\n  this.Schema.prototype.base = this;\n\n  Object.defineProperty(this, 'plugins', {\n    configurable: false,\n    enumerable: true,\n    writable: false,\n    value: Object.values(builtinPlugins).map(plugin => ([plugin, { deduplicate: true }]))\n  });\n}\n\nMongoose.prototype.cast = cast;\n/**\n * Expose connection states for user-land\n *\n * @memberOf Mongoose\n * @property STATES\n * @api public\n */\nMongoose.prototype.STATES = STATES;\n\n/**\n * Expose connection states for user-land\n *\n * @memberOf Mongoose\n * @property ConnectionStates\n * @api public\n */\nMongoose.prototype.ConnectionStates = STATES;\n\n/**\n * Object with `get()` and `set()` containing the underlying driver this Mongoose instance\n * uses to communicate with the database. A driver is a Mongoose-specific interface that defines functions\n * like `find()`.\n *\n * @deprecated\n * @memberOf Mongoose\n * @property driver\n * @api public\n */\n\nMongoose.prototype.driver = driver;\n\n/**\n * Overwrites the current driver used by this Mongoose instance. A driver is a\n * Mongoose-specific interface that defines functions like `find()`.\n *\n * @memberOf Mongoose\n * @method setDriver\n * @api public\n */\n\nMongoose.prototype.setDriver = function setDriver(driver) {\n  const _mongoose = this instanceof Mongoose ? this : mongoose;\n\n  if (_mongoose.__driver === driver) {\n    return _mongoose;\n  }\n\n  const openConnection = _mongoose.connections && _mongoose.connections.find(conn => conn.readyState !== STATES.disconnected);\n  if (openConnection) {\n    const msg = 'Cannot modify Mongoose driver if a connection is already open. ' +\n      'Call `mongoose.disconnect()` before modifying the driver';\n    throw new MongooseError(msg);\n  }\n  _mongoose.__driver = driver;\n\n  const Connection = driver.Connection;\n  _mongoose.connections = [new Connection(_mongoose)];\n  _mongoose.connections[0].models = _mongoose.models;\n\n  return _mongoose;\n};\n\n/**\n * Sets mongoose options\n *\n * `key` can be used a object to set multiple options at once.\n * If a error gets thrown for one option, other options will still be evaluated.\n *\n * #### Example:\n *\n *     mongoose.set('test', value) // sets the 'test' option to `value`\n *\n *     mongoose.set('debug', true) // enable logging collection methods + arguments to the console/file\n *\n *     mongoose.set('debug', function(collectionName, methodName, ...methodArgs) {}); // use custom function to log collection methods + arguments\n *\n *     mongoose.set({ debug: true, autoIndex: false }); // set multiple options at once\n *\n * Currently supported options are:\n * - `allowDiskUse`: Set to `true` to set `allowDiskUse` to true to all aggregation operations by default.\n * - `applyPluginsToChildSchemas`: `true` by default. Set to false to skip applying global plugins to child schemas\n * - `applyPluginsToDiscriminators`: `false` by default. Set to true to apply global plugins to discriminator schemas. This typically isn't necessary because plugins are applied to the base schema and discriminators copy all middleware, methods, statics, and properties from the base schema.\n * - `autoCreate`: Set to `true` to make Mongoose call [`Model.createCollection()`](https://mongoosejs.com/docs/api/model.html#Model.createCollection()) automatically when you create a model with `mongoose.model()` or `conn.model()`. This is useful for testing transactions, change streams, and other features that require the collection to exist.\n * - `autoIndex`: `true` by default. Set to false to disable automatic index creation for all models associated with this Mongoose instance.\n * - `bufferCommands`: enable/disable mongoose's buffering mechanism for all connections and models\n * - `bufferTimeoutMS`: If bufferCommands is on, this option sets the maximum amount of time Mongoose buffering will wait before throwing an error. If not specified, Mongoose will use 10000 (10 seconds).\n * - `cloneSchemas`: `false` by default. Set to `true` to `clone()` all schemas before compiling into a model.\n * - `debug`: If `true`, prints the operations mongoose sends to MongoDB to the console. If a writable stream is passed, it will log to that stream, without colorization. If a callback function is passed, it will receive the collection name, the method name, then all arguments passed to the method. For example, if you wanted to replicate the default logging, you could output from the callback `Mongoose: ${collectionName}.${methodName}(${methodArgs.join(', ')})`.\n * - `id`: If `true`, adds a `id` virtual to all schemas unless overwritten on a per-schema basis.\n * - `timestamps.createdAt.immutable`: `true` by default. If `false`, it will change the `createdAt` field to be [`immutable: false`](https://mongoosejs.com/docs/api/schematype.html#SchemaType.prototype.immutable) which means you can update the `createdAt`\n * - `maxTimeMS`: If set, attaches [maxTimeMS](https://www.mongodb.com/docs/manual/reference/operator/meta/maxTimeMS/) to every query\n * - `objectIdGetter`: `true` by default. Mongoose adds a getter to MongoDB ObjectId's called `_id` that returns `this` for convenience with populate. Set this to false to remove the getter.\n * - `overwriteModels`: Set to `true` to default to overwriting models with the same name when calling `mongoose.model()`, as opposed to throwing an `OverwriteModelError`.\n * - `returnOriginal`: If `false`, changes the default `returnOriginal` option to `findOneAndUpdate()`, `findByIdAndUpdate`, and `findOneAndReplace()` to false. This is equivalent to setting the `new` option to `true` for `findOneAndX()` calls by default. Read our [`findOneAndUpdate()` tutorial](https://mongoosejs.com/docs/tutorials/findoneandupdate.html) for more information.\n * - `runValidators`: `false` by default. Set to true to enable [update validators](https://mongoosejs.com/docs/validation.html#update-validators) for all validators by default.\n * - `sanitizeFilter`: `false` by default. Set to true to enable the [sanitization of the query filters](https://mongoosejs.com/docs/api/mongoose.html#Mongoose.prototype.sanitizeFilter()) against query selector injection attacks by wrapping any nested objects that have a property whose name starts with `$` in a `$eq`.\n * - `selectPopulatedPaths`: `true` by default. Set to false to opt out of Mongoose adding all fields that you `populate()` to your `select()`. The schema-level option `selectPopulatedPaths` overwrites this one.\n * - `strict`: `true` by default, may be `false`, `true`, or `'throw'`. Sets the default strict mode for schemas.\n * - `strictQuery`: `false` by default. May be `false`, `true`, or `'throw'`. Sets the default [strictQuery](https://mongoosejs.com/docs/guide.html#strictQuery) mode for schemas.\n * - `toJSON`: `{ transform: true, flattenDecimals: true }` by default. Overwrites default objects to [`toJSON()`](https://mongoosejs.com/docs/api/document.html#Document.prototype.toJSON()), for determining how Mongoose documents get serialized by `JSON.stringify()`\n * - `toObject`: `{ transform: true, flattenDecimals: true }` by default. Overwrites default objects to [`toObject()`](https://mongoosejs.com/docs/api/document.html#Document.prototype.toObject())\n *\n * @param {String|Object} key The name of the option or a object of multiple key-value pairs\n * @param {String|Function|Boolean} value The value of the option, unused if \"key\" is a object\n * @returns {Mongoose} The used Mongoose instnace\n * @api public\n */\n\nMongoose.prototype.set = function(key, value) {\n  const _mongoose = this instanceof Mongoose ? this : mongoose;\n\n  if (arguments.length === 1 && typeof key !== 'object') {\n    if (VALID_OPTIONS.indexOf(key) === -1) {\n      const error = new SetOptionError();\n      error.addError(key, new SetOptionError.SetOptionInnerError(key));\n      throw error;\n    }\n\n    return _mongoose.options[key];\n  }\n\n  let options = {};\n\n  if (arguments.length === 2) {\n    options = { [key]: value };\n  }\n\n  if (arguments.length === 1 && typeof key === 'object') {\n    options = key;\n  }\n\n  // array for errors to collect all errors for all key-value pairs, like \".validate\"\n  let error = undefined;\n\n  for (const [optionKey, optionValue] of Object.entries(options)) {\n    if (VALID_OPTIONS.indexOf(optionKey) === -1) {\n      if (!error) {\n        error = new SetOptionError();\n      }\n      error.addError(optionKey, new SetOptionError.SetOptionInnerError(optionKey));\n      continue;\n    }\n\n    _mongoose.options[optionKey] = optionValue;\n\n    if (optionKey === 'objectIdGetter') {\n      if (optionValue) {\n        Object.defineProperty(mongoose.Types.ObjectId.prototype, '_id', {\n          enumerable: false,\n          configurable: true,\n          get: function() {\n            return this;\n          }\n        });\n      } else {\n        delete mongoose.Types.ObjectId.prototype._id;\n      }\n    }\n  }\n\n  if (error) {\n    throw error;\n  }\n\n  return _mongoose;\n};\n\n/**\n * Gets mongoose options\n *\n * #### Example:\n *\n *     mongoose.get('test') // returns the 'test' value\n *\n * @param {String} key\n * @method get\n * @api public\n */\n\nMongoose.prototype.get = Mongoose.prototype.set;\n\n/**\n * Creates a Connection instance.\n *\n * Each `connection` instance maps to a single database. This method is helpful when managing multiple db connections.\n *\n *\n * _Options passed take precedence over options included in connection strings._\n *\n * #### Example:\n *\n *     // with mongodb:// URI\n *     db = mongoose.createConnection('mongodb://user:pass@127.0.0.1:port/database');\n *\n *     // and options\n *     const opts = { db: { native_parser: true }}\n *     db = mongoose.createConnection('mongodb://user:pass@127.0.0.1:port/database', opts);\n *\n *     // replica sets\n *     db = mongoose.createConnection('mongodb://user:pass@127.0.0.1:port,anotherhost:port,yetanother:port/database');\n *\n *     // and options\n *     const opts = { replset: { strategy: 'ping', rs_name: 'testSet' }}\n *     db = mongoose.createConnection('mongodb://user:pass@127.0.0.1:port,anotherhost:port,yetanother:port/database', opts);\n *\n *     // initialize now, connect later\n *     db = mongoose.createConnection();\n *     db.openUri('127.0.0.1', 'database', port, [opts]);\n *\n * @param {String} uri mongodb URI to connect to\n * @param {Object} [options] passed down to the [MongoDB driver's `connect()` function](https://mongodb.github.io/node-mongodb-native/4.9/interfaces/MongoClientOptions.html), except for 4 mongoose-specific options explained below.\n * @param {Boolean} [options.bufferCommands=true] Mongoose specific option. Set to false to [disable buffering](https://mongoosejs.com/docs/faq.html#callback_never_executes) on all models associated with this connection.\n * @param {String} [options.dbName] The name of the database you want to use. If not provided, Mongoose uses the database name from connection string.\n * @param {String} [options.user] username for authentication, equivalent to `options.auth.user`. Maintained for backwards compatibility.\n * @param {String} [options.pass] password for authentication, equivalent to `options.auth.password`. Maintained for backwards compatibility.\n * @param {Boolean} [options.autoIndex=true] Mongoose-specific option. Set to false to disable automatic index creation for all models associated with this connection.\n * @param {Class} [options.promiseLibrary] Sets the [underlying driver's promise library](https://mongodb.github.io/node-mongodb-native/4.9/interfaces/MongoClientOptions.html#promiseLibrary).\n * @param {Number} [options.maxPoolSize=5] The maximum number of sockets the MongoDB driver will keep open for this connection. Keep in mind that MongoDB only allows one operation per socket at a time, so you may want to increase this if you find you have a few slow queries that are blocking faster queries from proceeding. See [Slow Trains in MongoDB and Node.js](https://thecodebarbarian.com/slow-trains-in-mongodb-and-nodejs).\n * @param {Number} [options.minPoolSize=1] The minimum number of sockets the MongoDB driver will keep open for this connection. Keep in mind that MongoDB only allows one operation per socket at a time, so you may want to increase this if you find you have a few slow queries that are blocking faster queries from proceeding. See [Slow Trains in MongoDB and Node.js](https://thecodebarbarian.com/slow-trains-in-mongodb-and-nodejs).\n * @param {Number} [options.socketTimeoutMS=0] How long the MongoDB driver will wait before killing a socket due to inactivity _after initial connection_. Defaults to 0, which means Node.js will not time out the socket due to inactivity. A socket may be inactive because of either no activity or a long-running operation. This option is passed to [Node.js `socket#setTimeout()` function](https://nodejs.org/api/net.html#net_socket_settimeout_timeout_callback) after the MongoDB driver successfully completes.\n * @param {Number} [options.family=0] Passed transparently to [Node.js' `dns.lookup()`](https://nodejs.org/api/dns.html#dns_dns_lookup_hostname_options_callback) function. May be either `0`, `4`, or `6`. `4` means use IPv4 only, `6` means use IPv6 only, `0` means try both.\n * @return {Connection} the created Connection object. Connections are not thenable, so you can't do `await mongoose.createConnection()`. To await use `mongoose.createConnection(uri).asPromise()` instead.\n * @api public\n */\n\nMongoose.prototype.createConnection = function(uri, options) {\n  const _mongoose = this instanceof Mongoose ? this : mongoose;\n\n  const Connection = _mongoose.__driver.Connection;\n  const conn = new Connection(_mongoose);\n  _mongoose.connections.push(conn);\n  _mongoose.nextConnectionId++;\n  _mongoose.events.emit('createConnection', conn);\n\n  if (arguments.length > 0) {\n    conn.openUri(uri, { ...options, _fireAndForget: true });\n  }\n\n  return conn;\n};\n\n/**\n * Opens the default mongoose connection.\n *\n * #### Example:\n *\n *     mongoose.connect('mongodb://user:pass@127.0.0.1:port/database');\n *\n *     // replica sets\n *     const uri = 'mongodb://user:pass@127.0.0.1:port,anotherhost:port,yetanother:port/mydatabase';\n *     mongoose.connect(uri);\n *\n *     // with options\n *     mongoose.connect(uri, options);\n *\n *     // optional callback that gets fired when initial connection completed\n *     const uri = 'mongodb://nonexistent.domain:27000';\n *     mongoose.connect(uri, function(error) {\n *       // if error is truthy, the initial connection failed.\n *     })\n *\n * @param {String} uri mongodb URI to connect to\n * @param {Object} [options] passed down to the [MongoDB driver's `connect()` function](https://mongodb.github.io/node-mongodb-native/4.9/interfaces/MongoClientOptions.html), except for 4 mongoose-specific options explained below.\n * @param {Boolean} [options.bufferCommands=true] Mongoose specific option. Set to false to [disable buffering](https://mongoosejs.com/docs/faq.html#callback_never_executes) on all models associated with this connection.\n * @param {Number} [options.bufferTimeoutMS=10000] Mongoose specific option. If `bufferCommands` is true, Mongoose will throw an error after `bufferTimeoutMS` if the operation is still buffered.\n * @param {String} [options.dbName] The name of the database we want to use. If not provided, use database name from connection string.\n * @param {String} [options.user] username for authentication, equivalent to `options.auth.user`. Maintained for backwards compatibility.\n * @param {String} [options.pass] password for authentication, equivalent to `options.auth.password`. Maintained for backwards compatibility.\n * @param {Number} [options.maxPoolSize=100] The maximum number of sockets the MongoDB driver will keep open for this connection. Keep in mind that MongoDB only allows one operation per socket at a time, so you may want to increase this if you find you have a few slow queries that are blocking faster queries from proceeding. See [Slow Trains in MongoDB and Node.js](https://thecodebarbarian.com/slow-trains-in-mongodb-and-nodejs).\n * @param {Number} [options.minPoolSize=0] The minimum number of sockets the MongoDB driver will keep open for this connection.\n * @param {Number} [options.serverSelectionTimeoutMS] If `useUnifiedTopology = true`, the MongoDB driver will try to find a server to send any given operation to, and keep retrying for `serverSelectionTimeoutMS` milliseconds before erroring out. If not set, the MongoDB driver defaults to using `30000` (30 seconds).\n * @param {Number} [options.heartbeatFrequencyMS] If `useUnifiedTopology = true`, the MongoDB driver sends a heartbeat every `heartbeatFrequencyMS` to check on the status of the connection. A heartbeat is subject to `serverSelectionTimeoutMS`, so the MongoDB driver will retry failed heartbeats for up to 30 seconds by default. Mongoose only emits a `'disconnected'` event after a heartbeat has failed, so you may want to decrease this setting to reduce the time between when your server goes down and when Mongoose emits `'disconnected'`. We recommend you do **not** set this setting below 1000, too many heartbeats can lead to performance degradation.\n * @param {Boolean} [options.autoIndex=true] Mongoose-specific option. Set to false to disable automatic index creation for all models associated with this connection.\n * @param {Class} [options.promiseLibrary] Sets the [underlying driver's promise library](https://mongodb.github.io/node-mongodb-native/4.9/interfaces/MongoClientOptions.html#promiseLibrary).\n * @param {Number} [options.socketTimeoutMS=0] How long the MongoDB driver will wait before killing a socket due to inactivity _after initial connection_. A socket may be inactive because of either no activity or a long-running operation. `socketTimeoutMS` defaults to 0, which means Node.js will not time out the socket due to inactivity. This option is passed to [Node.js `socket#setTimeout()` function](https://nodejs.org/api/net.html#net_socket_settimeout_timeout_callback) after the MongoDB driver successfully completes.\n * @param {Number} [options.family=0] Passed transparently to [Node.js' `dns.lookup()`](https://nodejs.org/api/dns.html#dns_dns_lookup_hostname_options_callback) function. May be either `0`, `4`, or `6`. `4` means use IPv4 only, `6` means use IPv6 only, `0` means try both.\n * @param {Boolean} [options.autoCreate=false] Set to `true` to make Mongoose automatically call `createCollection()` on every model created on this connection.\n * @param {Function} [callback]\n * @see Mongoose#createConnection https://mongoosejs.com/docs/api/mongoose.html#Mongoose.prototype.createConnection()\n * @api public\n * @return {Promise} resolves to `this` if connection succeeded\n */\n\nMongoose.prototype.connect = async function connect(uri, options) {\n  if (typeof options === 'function' || (arguments.length >= 3 && typeof arguments[2] === 'function')) {\n    throw new MongooseError('Mongoose.prototype.connect() no longer accepts a callback');\n  }\n\n  const _mongoose = this instanceof Mongoose ? this : mongoose;\n  const conn = _mongoose.connection;\n\n  return conn.openUri(uri, options).then(() => _mongoose);\n};\n\n/**\n * Runs `.close()` on all connections in parallel.\n *\n * @return {Promise} resolves when all connections are closed, or rejects with the first error that occurred.\n * @api public\n */\n\nMongoose.prototype.disconnect = async function disconnect() {\n  if (arguments.length >= 1 && typeof arguments[0] === 'function') {\n    throw new MongooseError('Mongoose.prototype.disconnect() no longer accepts a callback');\n  }\n\n  const _mongoose = this instanceof Mongoose ? this : mongoose;\n\n  const remaining = _mongoose.connections.length;\n  if (remaining <= 0) {\n    return;\n  }\n  await Promise.all(_mongoose.connections.map(conn => conn.close()));\n};\n\n/**\n * _Requires MongoDB >= 3.6.0._ Starts a [MongoDB session](https://www.mongodb.com/docs/manual/release-notes/3.6/#client-sessions)\n * for benefits like causal consistency, [retryable writes](https://www.mongodb.com/docs/manual/core/retryable-writes/),\n * and [transactions](https://thecodebarbarian.com/a-node-js-perspective-on-mongodb-4-transactions.html).\n *\n * Calling `mongoose.startSession()` is equivalent to calling `mongoose.connection.startSession()`.\n * Sessions are scoped to a connection, so calling `mongoose.startSession()`\n * starts a session on the [default mongoose connection](https://mongoosejs.com/docs/api/mongoose.html#Mongoose.prototype.connection).\n *\n * @param {Object} [options] see the [mongodb driver options](https://mongodb.github.io/node-mongodb-native/4.9/classes/MongoClient.html#startSession)\n * @param {Boolean} [options.causalConsistency=true] set to false to disable causal consistency\n * @param {Function} [callback]\n * @return {Promise<ClientSession>} promise that resolves to a MongoDB driver `ClientSession`\n * @api public\n */\n\nMongoose.prototype.startSession = function() {\n  const _mongoose = this instanceof Mongoose ? this : mongoose;\n\n  return _mongoose.connection.startSession.apply(_mongoose.connection, arguments);\n};\n\n/**\n * Getter/setter around function for pluralizing collection names.\n *\n * @param {Function|null} [fn] overwrites the function used to pluralize collection names\n * @return {Function|null} the current function used to pluralize collection names, defaults to the legacy function from `mongoose-legacy-pluralize`.\n * @api public\n */\n\nMongoose.prototype.pluralize = function(fn) {\n  const _mongoose = this instanceof Mongoose ? this : mongoose;\n\n  if (arguments.length > 0) {\n    _mongoose._pluralize = fn;\n  }\n  return _mongoose._pluralize;\n};\n\n/**\n * Defines a model or retrieves it.\n *\n * Models defined on the `mongoose` instance are available to all connection\n * created by the same `mongoose` instance.\n *\n * If you call `mongoose.model()` with twice the same name but a different schema,\n * you will get an `OverwriteModelError`. If you call `mongoose.model()` with\n * the same name and same schema, you'll get the same schema back.\n *\n * #### Example:\n *\n *     const mongoose = require('mongoose');\n *\n *     // define an Actor model with this mongoose instance\n *     const schema = new Schema({ name: String });\n *     mongoose.model('Actor', schema);\n *\n *     // create a new connection\n *     const conn = mongoose.createConnection(..);\n *\n *     // create Actor model\n *     const Actor = conn.model('Actor', schema);\n *     conn.model('Actor') === Actor; // true\n *     conn.model('Actor', schema) === Actor; // true, same schema\n *     conn.model('Actor', schema, 'actors') === Actor; // true, same schema and collection name\n *\n *     // This throws an `OverwriteModelError` because the schema is different.\n *     conn.model('Actor', new Schema({ name: String }));\n *\n * _When no `collection` argument is passed, Mongoose uses the model name. If you don't like this behavior, either pass a collection name, use `mongoose.pluralize()`, or set your schemas collection name option._\n *\n * #### Example:\n *\n *     const schema = new Schema({ name: String }, { collection: 'actor' });\n *\n *     // or\n *\n *     schema.set('collection', 'actor');\n *\n *     // or\n *\n *     const collectionName = 'actor'\n *     const M = mongoose.model('Actor', schema, collectionName)\n *\n * @param {String|Function} name model name or class extending Model\n * @param {Schema} [schema] the schema to use.\n * @param {String} [collection] name (optional, inferred from model name)\n * @return {Model} The model associated with `name`. Mongoose will create the model if it doesn't already exist.\n * @api public\n */\n\nMongoose.prototype.model = function(name, schema, collection, options) {\n  const _mongoose = this instanceof Mongoose ? this : mongoose;\n\n  if (typeof schema === 'string') {\n    collection = schema;\n    schema = false;\n  }\n\n  if (arguments.length === 1) {\n    const model = _mongoose.models[name];\n    if (!model) {\n      throw new MongooseError.MissingSchemaError(name);\n    }\n    return model;\n  }\n\n  if (utils.isObject(schema) && !(schema instanceof Schema)) {\n    schema = new Schema(schema);\n  }\n  if (schema && !(schema instanceof Schema)) {\n    throw new Error('The 2nd parameter to `mongoose.model()` should be a ' +\n      'schema or a POJO');\n  }\n\n  // handle internal options from connection.model()\n  options = options || {};\n\n  const originalSchema = schema;\n  if (schema) {\n    if (_mongoose.get('cloneSchemas')) {\n      schema = schema.clone();\n    }\n    _mongoose._applyPlugins(schema);\n  }\n\n  // connection.model() may be passing a different schema for\n  // an existing model name. in this case don't read from cache.\n  const overwriteModels = _mongoose.options.hasOwnProperty('overwriteModels') ?\n    _mongoose.options.overwriteModels :\n    options.overwriteModels;\n  if (_mongoose.models.hasOwnProperty(name) && options.cache !== false && overwriteModels !== true) {\n    if (originalSchema &&\n        originalSchema.instanceOfSchema &&\n        originalSchema !== _mongoose.models[name].schema) {\n      throw new _mongoose.Error.OverwriteModelError(name);\n    }\n    if (collection && collection !== _mongoose.models[name].collection.name) {\n      // subclass current model with alternate collection\n      const model = _mongoose.models[name];\n      schema = model.prototype.schema;\n      const sub = model.__subclass(_mongoose.connection, schema, collection);\n      // do not cache the sub model\n      return sub;\n    }\n    return _mongoose.models[name];\n  }\n  if (schema == null) {\n    throw new _mongoose.Error.MissingSchemaError(name);\n  }\n\n  const model = _mongoose._model(name, schema, collection, options);\n  _mongoose.connection.models[name] = model;\n  _mongoose.models[name] = model;\n\n  return model;\n};\n\n/*!\n * ignore\n */\n\nMongoose.prototype._model = function(name, schema, collection, options) {\n  const _mongoose = this instanceof Mongoose ? this : mongoose;\n\n  let model;\n  if (typeof name === 'function') {\n    model = name;\n    name = model.name;\n    if (!(model.prototype instanceof Model)) {\n      throw new _mongoose.Error('The provided class ' + name + ' must extend Model');\n    }\n  }\n\n  if (schema) {\n    if (_mongoose.get('cloneSchemas')) {\n      schema = schema.clone();\n    }\n    _mongoose._applyPlugins(schema);\n  }\n\n  // Apply relevant \"global\" options to the schema\n  if (schema == null || !('pluralization' in schema.options)) {\n    schema.options.pluralization = _mongoose.options.pluralization;\n  }\n\n  if (!collection) {\n    collection = schema.get('collection') ||\n      utils.toCollectionName(name, _mongoose.pluralize());\n  }\n\n  const connection = options.connection || _mongoose.connection;\n  model = _mongoose.Model.compile(model || name, schema, collection, connection, _mongoose);\n  // Errors handled internally, so safe to ignore error\n  model.init().catch(function $modelInitNoop() {});\n\n  connection.emit('model', model);\n\n  if (schema._applyDiscriminators != null) {\n    for (const disc of schema._applyDiscriminators.keys()) {\n      model.discriminator(disc, schema._applyDiscriminators.get(disc));\n    }\n  }\n\n  return model;\n};\n\n/**\n * Removes the model named `name` from the default connection, if it exists.\n * You can use this function to clean up any models you created in your tests to\n * prevent OverwriteModelErrors.\n *\n * Equivalent to `mongoose.connection.deleteModel(name)`.\n *\n * #### Example:\n *\n *     mongoose.model('User', new Schema({ name: String }));\n *     console.log(mongoose.model('User')); // Model object\n *     mongoose.deleteModel('User');\n *     console.log(mongoose.model('User')); // undefined\n *\n *     // Usually useful in a Mocha `afterEach()` hook\n *     afterEach(function() {\n *       mongoose.deleteModel(/.+/); // Delete every model\n *     });\n *\n * @api public\n * @param {String|RegExp} name if string, the name of the model to remove. If regexp, removes all models whose name matches the regexp.\n * @return {Mongoose} this\n */\n\nMongoose.prototype.deleteModel = function(name) {\n  const _mongoose = this instanceof Mongoose ? this : mongoose;\n\n  _mongoose.connection.deleteModel(name);\n  delete _mongoose.models[name];\n  return _mongoose;\n};\n\n/**\n * Returns an array of model names created on this instance of Mongoose.\n *\n * #### Note:\n *\n * _Does not include names of models created using `connection.model()`._\n *\n * @api public\n * @return {Array}\n */\n\nMongoose.prototype.modelNames = function() {\n  const _mongoose = this instanceof Mongoose ? this : mongoose;\n\n  const names = Object.keys(_mongoose.models);\n  return names;\n};\n\n/**\n * Applies global plugins to `schema`.\n *\n * @param {Schema} schema\n * @api private\n */\n\nMongoose.prototype._applyPlugins = function(schema, options) {\n  const _mongoose = this instanceof Mongoose ? this : mongoose;\n\n  options = options || {};\n  options.applyPluginsToDiscriminators = _mongoose.options && _mongoose.options.applyPluginsToDiscriminators || false;\n  options.applyPluginsToChildSchemas = typeof (_mongoose.options && _mongoose.options.applyPluginsToChildSchemas) === 'boolean' ?\n    _mongoose.options.applyPluginsToChildSchemas :\n    true;\n  applyPlugins(schema, _mongoose.plugins, options, '$globalPluginsApplied');\n};\n\n/**\n * Declares a global plugin executed on all Schemas.\n *\n * Equivalent to calling `.plugin(fn)` on each Schema you create.\n *\n * @param {Function} fn plugin callback\n * @param {Object} [opts] optional options\n * @return {Mongoose} this\n * @see plugins https://mongoosejs.com/docs/plugins.html\n * @api public\n */\n\nMongoose.prototype.plugin = function(fn, opts) {\n  const _mongoose = this instanceof Mongoose ? this : mongoose;\n\n  _mongoose.plugins.push([fn, opts]);\n  return _mongoose;\n};\n\n/**\n * The Mongoose module's default connection. Equivalent to `mongoose.connections[0]`, see [`connections`](https://mongoosejs.com/docs/api/mongoose.html#Mongoose.prototype.connections).\n *\n * #### Example:\n *\n *     const mongoose = require('mongoose');\n *     mongoose.connect(...);\n *     mongoose.connection.on('error', cb);\n *\n * This is the connection used by default for every model created using [mongoose.model](https://mongoosejs.com/docs/api/mongoose.html#Mongoose.prototype.model()).\n *\n * To create a new connection, use [`createConnection()`](https://mongoosejs.com/docs/api/mongoose.html#Mongoose.prototype.createConnection()).\n *\n * @memberOf Mongoose\n * @instance\n * @property {Connection} connection\n * @api public\n */\n\nMongoose.prototype.__defineGetter__('connection', function() {\n  return this.connections[0];\n});\n\nMongoose.prototype.__defineSetter__('connection', function(v) {\n  if (v instanceof this.__driver.Connection) {\n    this.connections[0] = v;\n    this.models = v.models;\n  }\n});\n\n/**\n * An array containing all [connections](connection.html) associated with this\n * Mongoose instance. By default, there is 1 connection. Calling\n * [`createConnection()`](https://mongoosejs.com/docs/api/mongoose.html#Mongoose.prototype.createConnection()) adds a connection\n * to this array.\n *\n * #### Example:\n *\n *     const mongoose = require('mongoose');\n *     mongoose.connections.length; // 1, just the default connection\n *     mongoose.connections[0] === mongoose.connection; // true\n *\n *     mongoose.createConnection('mongodb://127.0.0.1:27017/test');\n *     mongoose.connections.length; // 2\n *\n * @memberOf Mongoose\n * @instance\n * @property {Array} connections\n * @api public\n */\n\nMongoose.prototype.connections;\n\n/**\n * An integer containing the value of the next connection id. Calling\n * [`createConnection()`](https://mongoosejs.com/docs/api/mongoose.html#Mongoose.prototype.createConnection()) increments\n * this value.\n *\n * #### Example:\n *\n *     const mongoose = require('mongoose');\n *     mongoose.createConnection(); // id `0`, `nextConnectionId` becomes `1`\n *     mongoose.createConnection(); // id `1`, `nextConnectionId` becomes `2`\n *     mongoose.connections[0].destroy() // Removes connection with id `0`\n *     mongoose.createConnection(); // id `2`, `nextConnectionId` becomes `3`\n *\n * @memberOf Mongoose\n * @instance\n * @property {Number} nextConnectionId\n * @api private\n */\n\nMongoose.prototype.nextConnectionId;\n\n/**\n * The Mongoose Aggregate constructor\n *\n * @method Aggregate\n * @api public\n */\n\nMongoose.prototype.Aggregate = Aggregate;\n\n/**\n * The Mongoose Collection constructor\n *\n * @memberOf Mongoose\n * @instance\n * @method Collection\n * @api public\n */\n\nObject.defineProperty(Mongoose.prototype, 'Collection', {\n  get: function() {\n    return this.__driver.Collection;\n  },\n  set: function(Collection) {\n    this.__driver.Collection = Collection;\n  }\n});\n\n/**\n * The Mongoose [Connection](https://mongoosejs.com/docs/api/connection.html#Connection()) constructor\n *\n * @memberOf Mongoose\n * @instance\n * @method Connection\n * @api public\n */\n\nObject.defineProperty(Mongoose.prototype, 'Connection', {\n  get: function() {\n    return this.__driver.Connection;\n  },\n  set: function(Connection) {\n    if (Connection === this.__driver.Connection) {\n      return;\n    }\n\n    this.__driver.Connection = Connection;\n  }\n});\n\n/**\n * The Mongoose version\n *\n * #### Example:\n *\n *     console.log(mongoose.version); // '5.x.x'\n *\n * @property version\n * @api public\n */\n\nMongoose.prototype.version = pkg.version;\n\n/**\n * The Mongoose constructor\n *\n * The exports of the mongoose module is an instance of this class.\n *\n * #### Example:\n *\n *     const mongoose = require('mongoose');\n *     const mongoose2 = new mongoose.Mongoose();\n *\n * @method Mongoose\n * @api public\n */\n\nMongoose.prototype.Mongoose = Mongoose;\n\n/**\n * The Mongoose [Schema](https://mongoosejs.com/docs/api/schema.html#Schema()) constructor\n *\n * #### Example:\n *\n *     const mongoose = require('mongoose');\n *     const Schema = mongoose.Schema;\n *     const CatSchema = new Schema(..);\n *\n * @method Schema\n * @api public\n */\n\nMongoose.prototype.Schema = Schema;\n\n/**\n * The Mongoose [SchemaType](https://mongoosejs.com/docs/api/schematype.html#SchemaType()) constructor\n *\n * @method SchemaType\n * @api public\n */\n\nMongoose.prototype.SchemaType = SchemaType;\n\n/**\n * The various Mongoose SchemaTypes.\n *\n * #### Note:\n *\n * _Alias of mongoose.Schema.Types for backwards compatibility._\n *\n * @property SchemaTypes\n * @see Schema.SchemaTypes https://mongoosejs.com/docs/schematypes.html\n * @api public\n */\n\nMongoose.prototype.SchemaTypes = Schema.Types;\n\n/**\n * The Mongoose [VirtualType](https://mongoosejs.com/docs/api/virtualtype.html#VirtualType()) constructor\n *\n * @method VirtualType\n * @api public\n */\n\nMongoose.prototype.VirtualType = VirtualType;\n\n/**\n * The various Mongoose Types.\n *\n * #### Example:\n *\n *     const mongoose = require('mongoose');\n *     const array = mongoose.Types.Array;\n *\n * #### Types:\n *\n * - [Array](https://mongoosejs.com/docs/schematypes.html#arrays)\n * - [Buffer](https://mongoosejs.com/docs/schematypes.html#buffers)\n * - [Embedded](https://mongoosejs.com/docs/schematypes.html#schemas)\n * - [DocumentArray](https://mongoosejs.com/docs/api/documentarraypath.html)\n * - [Decimal128](https://mongoosejs.com/docs/api/mongoose.html#Mongoose.prototype.Decimal128)\n * - [ObjectId](https://mongoosejs.com/docs/schematypes.html#objectids)\n * - [Map](https://mongoosejs.com/docs/schematypes.html#maps)\n * - [Subdocument](https://mongoosejs.com/docs/schematypes.html#schemas)\n *\n * Using this exposed access to the `ObjectId` type, we can construct ids on demand.\n *\n *     const ObjectId = mongoose.Types.ObjectId;\n *     const id1 = new ObjectId;\n *\n * @property Types\n * @api public\n */\n\nMongoose.prototype.Types = Types;\n\n/**\n * The Mongoose [Query](https://mongoosejs.com/docs/api/query.html#Query()) constructor.\n *\n * @method Query\n * @api public\n */\n\nMongoose.prototype.Query = Query;\n\n/**\n * The Mongoose [Model](https://mongoosejs.com/docs/api/model.html#Model()) constructor.\n *\n * @method Model\n * @api public\n */\n\nMongoose.prototype.Model = Model;\n\n/**\n * The Mongoose [Document](https://mongoosejs.com/docs/api/document.html#Document()) constructor.\n *\n * @method Document\n * @api public\n */\n\nMongoose.prototype.Document = Document;\n\n/**\n * The Mongoose DocumentProvider constructor. Mongoose users should not have to\n * use this directly\n *\n * @method DocumentProvider\n * @api public\n */\n\nMongoose.prototype.DocumentProvider = __webpack_require__(/*! ./documentProvider */ \"(ssr)/./node_modules/mongoose/lib/documentProvider.js\");\n\n/**\n * The Mongoose ObjectId [SchemaType](https://mongoosejs.com/docs/schematypes.html). Used for\n * declaring paths in your schema that should be\n * [MongoDB ObjectIds](https://www.mongodb.com/docs/manual/reference/method/ObjectId/).\n * Do not use this to create a new ObjectId instance, use `mongoose.Types.ObjectId`\n * instead.\n *\n * #### Example:\n *\n *     const childSchema = new Schema({ parentId: mongoose.ObjectId });\n *\n * @property ObjectId\n * @api public\n */\n\nMongoose.prototype.ObjectId = SchemaTypes.ObjectId;\n\n/**\n * Returns true if Mongoose can cast the given value to an ObjectId, or\n * false otherwise.\n *\n * #### Example:\n *\n *     mongoose.isValidObjectId(new mongoose.Types.ObjectId()); // true\n *     mongoose.isValidObjectId('0123456789ab'); // true\n *     mongoose.isValidObjectId(6); // true\n *     mongoose.isValidObjectId(new User({ name: 'test' })); // true\n *\n *     mongoose.isValidObjectId({ test: 42 }); // false\n *\n * @method isValidObjectId\n * @param {Any} v\n * @returns {boolean} true if `v` is something Mongoose can coerce to an ObjectId\n * @api public\n */\n\nMongoose.prototype.isValidObjectId = function(v) {\n  const _mongoose = this instanceof Mongoose ? this : mongoose;\n  return _mongoose.Types.ObjectId.isValid(v);\n};\n\n/**\n * Returns true if the given value is a Mongoose ObjectId (using `instanceof`) or if the\n * given value is a 24 character hex string, which is the most commonly used string representation\n * of an ObjectId.\n *\n * This function is similar to `isValidObjectId()`, but considerably more strict, because\n * `isValidObjectId()` will return `true` for _any_ value that Mongoose can convert to an\n * ObjectId. That includes Mongoose documents, any string of length 12, and any number.\n * `isObjectIdOrHexString()` returns true only for `ObjectId` instances or 24 character hex\n * strings, and will return false for numbers, documents, and strings of length 12.\n *\n * #### Example:\n *\n *     mongoose.isObjectIdOrHexString(new mongoose.Types.ObjectId()); // true\n *     mongoose.isObjectIdOrHexString('62261a65d66c6be0a63c051f'); // true\n *\n *     mongoose.isObjectIdOrHexString('0123456789ab'); // false\n *     mongoose.isObjectIdOrHexString(6); // false\n *     mongoose.isObjectIdOrHexString(new User({ name: 'test' })); // false\n *     mongoose.isObjectIdOrHexString({ test: 42 }); // false\n *\n * @method isObjectIdOrHexString\n * @param {Any} v\n * @returns {boolean} true if `v` is an ObjectId instance _or_ a 24 char hex string\n * @api public\n */\n\nMongoose.prototype.isObjectIdOrHexString = function(v) {\n  return isBsonType(v, 'ObjectId') || (typeof v === 'string' && objectIdHexRegexp.test(v));\n};\n\n/**\n *\n * Syncs all the indexes for the models registered with this connection.\n *\n * @param {Object} options\n * @param {Boolean} options.continueOnError `false` by default. If set to `true`, mongoose will not throw an error if one model syncing failed, and will return an object where the keys are the names of the models, and the values are the results/errors for each model.\n * @return {Promise} Returns a Promise, when the Promise resolves the value is a list of the dropped indexes.\n */\nMongoose.prototype.syncIndexes = function(options) {\n  const _mongoose = this instanceof Mongoose ? this : mongoose;\n  return _mongoose.connection.syncIndexes(options);\n};\n\n/**\n * The Mongoose Decimal128 [SchemaType](https://mongoosejs.com/docs/schematypes.html). Used for\n * declaring paths in your schema that should be\n * [128-bit decimal floating points](https://thecodebarbarian.com/a-nodejs-perspective-on-mongodb-34-decimal.html).\n * Do not use this to create a new Decimal128 instance, use `mongoose.Types.Decimal128`\n * instead.\n *\n * #### Example:\n *\n *     const vehicleSchema = new Schema({ fuelLevel: mongoose.Decimal128 });\n *\n * @property Decimal128\n * @api public\n */\n\nMongoose.prototype.Decimal128 = SchemaTypes.Decimal128;\n\n/**\n * The Mongoose Mixed [SchemaType](https://mongoosejs.com/docs/schematypes.html). Used for\n * declaring paths in your schema that Mongoose's change tracking, casting,\n * and validation should ignore.\n *\n * #### Example:\n *\n *     const schema = new Schema({ arbitrary: mongoose.Mixed });\n *\n * @property Mixed\n * @api public\n */\n\nMongoose.prototype.Mixed = SchemaTypes.Mixed;\n\n/**\n * The Mongoose Date [SchemaType](https://mongoosejs.com/docs/schematypes.html).\n *\n * #### Example:\n *\n *     const schema = new Schema({ test: Date });\n *     schema.path('test') instanceof mongoose.Date; // true\n *\n * @property Date\n * @api public\n */\n\nMongoose.prototype.Date = SchemaTypes.Date;\n\n/**\n * The Mongoose Number [SchemaType](https://mongoosejs.com/docs/schematypes.html). Used for\n * declaring paths in your schema that Mongoose should cast to numbers.\n *\n * #### Example:\n *\n *     const schema = new Schema({ num: mongoose.Number });\n *     // Equivalent to:\n *     const schema = new Schema({ num: 'number' });\n *\n * @property Number\n * @api public\n */\n\nMongoose.prototype.Number = SchemaTypes.Number;\n\n/**\n * The [MongooseError](https://mongoosejs.com/docs/api/error.html#Error()) constructor.\n *\n * @method Error\n * @api public\n */\n\nMongoose.prototype.Error = __webpack_require__(/*! ./error/index */ \"(ssr)/./node_modules/mongoose/lib/error/index.js\");\nMongoose.prototype.MongooseError = __webpack_require__(/*! ./error/mongooseError */ \"(ssr)/./node_modules/mongoose/lib/error/mongooseError.js\");\n\n/**\n * Mongoose uses this function to get the current time when setting\n * [timestamps](https://mongoosejs.com/docs/guide.html#timestamps). You may stub out this function\n * using a tool like [Sinon](https://www.npmjs.com/package/sinon) for testing.\n *\n * @method now\n * @returns Date the current time\n * @api public\n */\n\nMongoose.prototype.now = function now() { return new Date(); };\n\n/**\n * The Mongoose CastError constructor\n *\n * @method CastError\n * @param {String} type The name of the type\n * @param {Any} value The value that failed to cast\n * @param {String} path The path `a.b.c` in the doc where this cast error occurred\n * @param {Error} [reason] The original error that was thrown\n * @api public\n */\n\nMongoose.prototype.CastError = __webpack_require__(/*! ./error/cast */ \"(ssr)/./node_modules/mongoose/lib/error/cast.js\");\n\n/**\n * The constructor used for schematype options\n *\n * @method SchemaTypeOptions\n * @api public\n */\n\nMongoose.prototype.SchemaTypeOptions = __webpack_require__(/*! ./options/schemaTypeOptions */ \"(ssr)/./node_modules/mongoose/lib/options/schemaTypeOptions.js\");\n\n/**\n * The [mquery](https://github.com/aheckmann/mquery) query builder Mongoose uses.\n *\n * @property mquery\n * @api public\n */\n\nMongoose.prototype.mquery = __webpack_require__(/*! mquery */ \"(ssr)/./node_modules/mquery/lib/mquery.js\");\n\n/**\n * Sanitizes query filters against [query selector injection attacks](https://thecodebarbarian.com/2014/09/04/defending-against-query-selector-injection-attacks.html)\n * by wrapping any nested objects that have a property whose name starts with `$` in a `$eq`.\n *\n * ```javascript\n * const obj = { username: 'val', pwd: { $ne: null } };\n * sanitizeFilter(obj);\n * obj; // { username: 'val', pwd: { $eq: { $ne: null } } });\n * ```\n *\n * @method sanitizeFilter\n * @param {Object} filter\n * @returns Object the sanitized object\n * @api public\n */\n\nMongoose.prototype.sanitizeFilter = sanitizeFilter;\n\n/**\n * Tells `sanitizeFilter()` to skip the given object when filtering out potential [query selector injection attacks](https://thecodebarbarian.com/2014/09/04/defending-against-query-selector-injection-attacks.html).\n * Use this method when you have a known query selector that you want to use.\n *\n * ```javascript\n * const obj = { username: 'val', pwd: trusted({ $type: 'string', $eq: 'my secret' }) };\n * sanitizeFilter(obj);\n *\n * // Note that `sanitizeFilter()` did not add `$eq` around `$type`.\n * obj; // { username: 'val', pwd: { $type: 'string', $eq: 'my secret' } });\n * ```\n *\n * @method trusted\n * @param {Object} obj\n * @returns Object the passed in object\n * @api public\n */\n\nMongoose.prototype.trusted = trusted;\n\n/**\n * Use this function in `pre()` middleware to skip calling the wrapped function.\n *\n * #### Example:\n *\n *     schema.pre('save', function() {\n *       // Will skip executing `save()`, but will execute post hooks as if\n *       // `save()` had executed with the result `{ matchedCount: 0 }`\n *       return mongoose.skipMiddlewareFunction({ matchedCount: 0 });\n *     });\n *\n * @method skipMiddlewareFunction\n * @param {any} result\n * @api public\n */\n\nMongoose.prototype.skipMiddlewareFunction = Kareem.skipWrappedFunction;\n\n/**\n * Use this function in `post()` middleware to replace the result\n *\n * #### Example:\n *\n *     schema.post('find', function(res) {\n *       // Normally you have to modify `res` in place. But with\n *       // `overwriteMiddlewarResult()`, you can make `find()` return a\n *       // completely different value.\n *       return mongoose.overwriteMiddlewareResult(res.filter(doc => !doc.isDeleted));\n *     });\n *\n * @method overwriteMiddlewareResult\n * @param {any} result\n * @api public\n */\n\nMongoose.prototype.overwriteMiddlewareResult = Kareem.overwriteResult;\n\n/**\n * The exports object is an instance of Mongoose.\n *\n * @api private\n */\n\nconst mongoose = module.exports = exports = new Mongoose({\n  [defaultMongooseSymbol]: true\n});\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbW9uZ29vc2UvbGliL21vbmdvb3NlLmpzIiwibWFwcGluZ3MiOiJBQUFhOztBQUViO0FBQ0E7QUFDQTs7QUFFQSxpQkFBaUIsbUJBQU8sQ0FBQyxpRUFBWTtBQUNyQyxxQkFBcUIsMERBQThCO0FBQ25ELGVBQWUsbUJBQU8sQ0FBQyxvREFBUTtBQUMvQixlQUFlLG1CQUFPLENBQUMsNkRBQVU7QUFDakMsbUJBQW1CLG1CQUFPLENBQUMscUVBQWM7QUFDekMsb0JBQW9CLG1CQUFPLENBQUMseUVBQWdCO0FBQzVDLG9CQUFvQixtQkFBTyxDQUFDLHVFQUFlO0FBQzNDLGVBQWUsbUJBQU8sQ0FBQywrRUFBbUI7QUFDMUMsc0JBQXNCLG1CQUFPLENBQUMseUVBQWdCO0FBQzlDLGNBQWMsbUJBQU8sQ0FBQyxpRUFBUztBQUMvQixjQUFjLG1CQUFPLENBQUMsMkRBQVM7QUFDL0IsY0FBYyxtQkFBTyxDQUFDLDJEQUFTO0FBQy9CLHFCQUFxQixtQkFBTyxDQUFDLHVHQUErQjtBQUM1RCx1QkFBdUIsbUJBQU8sQ0FBQyxxRUFBVztBQUMxQyxlQUFlLG1CQUFPLENBQUMsNkRBQVU7QUFDakMsd0JBQXdCLG1CQUFPLENBQUMsbUZBQXFCO0FBQ3JELGNBQWMsbUJBQU8sQ0FBQywyREFBUztBQUMvQixZQUFZLG1CQUFPLENBQUMsbUVBQWlCO0FBQ3JDLGFBQWEsbUJBQU8sQ0FBQyx5REFBUTs7QUFFN0Isa0JBQWtCLG1CQUFPLENBQUMsbUVBQWE7QUFDdkMsZ0JBQWdCLDBIQUEwQztBQUMxRCx1QkFBdUIsbUJBQU8sQ0FBQyx5R0FBZ0M7QUFDL0QsbUJBQW1CLG1CQUFPLENBQUMscUZBQXNCO0FBQ2pELHNCQUFzQixtQkFBTyxDQUFDLHVGQUF1QjtBQUNyRCx1QkFBdUIsbUJBQU8sQ0FBQyx5RkFBd0I7O0FBRXZEOztBQUVBLG1CQUFPLENBQUMsaUdBQTRCOztBQUVwQyx3Q0FBd0MsR0FBRzs7QUFFM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtB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Q0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHNDQUFzQyxtQkFBTyxDQUFDLGlGQUFvQjs7QUFFbEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0NBQXdDLDZCQUE2QjtBQUNyRTtB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LEtBQUs7QUFDaEI7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxDQUFDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vYXBwMS8uL25vZGVfbW9kdWxlcy9tb25nb29zZS9saWIvbW9uZ29vc2UuanM/Y2IzNiJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbi8qIVxuICogTW9kdWxlIGRlcGVuZGVuY2llcy5cbiAqL1xuXG5jb25zdCBEb2N1bWVudCA9IHJlcXVpcmUoJy4vZG9jdW1lbnQnKTtcbmNvbnN0IEV2ZW50RW1pdHRlciA9IHJlcXVpcmUoJ2V2ZW50cycpLkV2ZW50RW1pdHRlcjtcbmNvbnN0IEthcmVlbSA9IHJlcXVpcmUoJ2thcmVlbScpO1xuY29uc3QgU2NoZW1hID0gcmVxdWlyZSgnLi9zY2hlbWEnKTtcbmNvbnN0IFNjaGVtYVR5cGUgPSByZXF1aXJlKCcuL3NjaGVtYVR5cGUnKTtcbmNvbnN0IFNjaGVtYVR5cGVzID0gcmVxdWlyZSgnLi9zY2hlbWEvaW5kZXgnKTtcbmNvbnN0IFZpcnR1YWxUeXBlID0gcmVxdWlyZSgnLi92aXJ0dWFsVHlwZScpO1xuY29uc3QgU1RBVEVTID0gcmVxdWlyZSgnLi9jb25uZWN0aW9uU3RhdGUnKTtcbmNvbnN0IFZBTElEX09QVElPTlMgPSByZXF1aXJlKCcuL3ZhbGlkT3B0aW9ucycpO1xuY29uc3QgVHlwZXMgPSByZXF1aXJlKCcuL3R5cGVzJyk7XG5jb25zdCBRdWVyeSA9IHJlcXVpcmUoJy4vcXVlcnknKTtcbmNvbnN0IE1vZGVsID0gcmVxdWlyZSgnLi9tb2RlbCcpO1xuY29uc3QgYXBwbHlQbHVnaW5zID0gcmVxdWlyZSgnLi9oZWxwZXJzL3NjaGVtYS9hcHBseVBsdWdpbnMnKTtcbmNvbnN0IGJ1aWx0aW5QbHVnaW5zID0gcmVxdWlyZSgnLi9wbHVnaW5zJyk7XG5jb25zdCBkcml2ZXIgPSByZXF1aXJlKCcuL2RyaXZlcicpO1xuY29uc3QgbGVnYWN5UGx1cmFsaXplID0gcmVxdWlyZSgnLi9oZWxwZXJzL3BsdXJhbGl6ZScpO1xuY29uc3QgdXRpbHMgPSByZXF1aXJlKCcuL3V0aWxzJyk7XG5jb25zdCBwa2cgPSByZXF1aXJlKCcuLi9wYWNrYWdlLmpzb24nKTtcbmNvbnN0IGNhc3QgPSByZXF1aXJlKCcuL2Nhc3QnKTtcblxuY29uc3QgQWdncmVnYXRlID0gcmVxdWlyZSgnLi9hZ2dyZWdhdGUnKTtcbmNvbnN0IHRydXN0ZWQgPSByZXF1aXJlKCcuL2hlbHBlcnMvcXVlcnkvdHJ1c3RlZCcpLnRydXN0ZWQ7XG5jb25zdCBzYW5pdGl6ZUZpbHRlciA9IHJlcXVpcmUoJy4vaGVscGVycy9xdWVyeS9zYW5pdGl6ZUZpbHRlcicpO1xuY29uc3QgaXNCc29uVHlwZSA9IHJlcXVpcmUoJy4vaGVscGVycy9pc0Jzb25UeXBlJyk7XG5jb25zdCBNb25nb29zZUVycm9yID0gcmVxdWlyZSgnLi9lcnJvci9tb25nb29zZUVycm9yJyk7XG5jb25zdCBTZXRPcHRpb25FcnJvciA9IHJlcXVpcmUoJy4vZXJyb3Ivc2V0T3B0aW9uRXJyb3InKTtcblxuY29uc3QgZGVmYXVsdE1vbmdvb3NlU3ltYm9sID0gU3ltYm9sLmZvcignbW9uZ29vc2U6ZGVmYXVsdCcpO1xuXG5yZXF1aXJlKCcuL2hlbHBlcnMvcHJpbnRKZXN0V2FybmluZycpO1xuXG5jb25zdCBvYmplY3RJZEhleFJlZ2V4cCA9IC9eWzAtOUEtRmEtZl17MjR9JC87XG5cbi8qKlxuICogTW9uZ29vc2UgY29uc3RydWN0b3IuXG4gKlxuICogVGhlIGV4cG9ydHMgb2JqZWN0IG9mIHRoZSBgbW9uZ29vc2VgIG1vZHVsZSBpcyBhbiBpbnN0YW5jZSBvZiB0aGlzIGNsYXNzLlxuICogTW9zdCBhcHBzIHdpbGwgb25seSB1c2UgdGhpcyBvbmUgaW5zdGFuY2UuXG4gKlxuICogIyMjIyBFeGFtcGxlOlxuICpcbiAqICAgICBjb25zdCBtb25nb29zZSA9IHJlcXVpcmUoJ21vbmdvb3NlJyk7XG4gKiAgICAgbW9uZ29vc2UgaW5zdGFuY2VvZiBtb25nb29zZS5Nb25nb29zZTsgLy8gdHJ1ZVxuICpcbiAqICAgICAvLyBDcmVhdGUgYSBuZXcgTW9uZ29vc2UgaW5zdGFuY2Ugd2l0aCBpdHMgb3duIGBjb25uZWN0KClgLCBgc2V0KClgLCBgbW9kZWwoKWAsIGV0Yy5cbiAqICAgICBjb25zdCBtID0gbmV3IG1vbmdvb3NlLk1vbmdvb3NlKCk7XG4gKlxuICogQGFwaSBwdWJsaWNcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIHNlZSBbYE1vbmdvb3NlI3NldCgpYCBkb2NzXShodHRwczovL21vbmdvb3NlanMuY29tL2RvY3MvYXBpL21vbmdvb3NlLmh0bWwjTW9uZ29vc2UucHJvdG90eXBlLnNldCgpKVxuICovXG5mdW5jdGlvbiBNb25nb29zZShvcHRpb25zKSB7XG4gIHRoaXMuY29ubmVjdGlvbnMgPSBbXTtcbiAgdGhpcy5uZXh0Q29ubmVjdGlvbklkID0gMDtcbiAgdGhpcy5tb2RlbHMgPSB7fTtcbiAgdGhpcy5ldmVudHMgPSBuZXcgRXZlbnRFbWl0dGVyKCk7XG4gIHRoaXMuX19kcml2ZXIgPSBkcml2ZXIuZ2V0KCk7XG4gIC8vIGRlZmF1bHQgZ2xvYmFsIG9wdGlvbnNcbiAgdGhpcy5vcHRpb25zID0gT2JqZWN0LmFzc2lnbih7XG4gICAgcGx1cmFsaXphdGlvbjogdHJ1ZSxcbiAgICBhdXRvSW5kZXg6IHRydWUsXG4gICAgYXV0b0NyZWF0ZTogdHJ1ZVxuICB9LCBvcHRpb25zKTtcbiAgY29uc3QgY3JlYXRlSW5pdGlhbENvbm5lY3Rpb24gPSB1dGlscy5nZXRPcHRpb24oJ2NyZWF0ZUluaXRpYWxDb25uZWN0aW9uJywgdGhpcy5vcHRpb25zKTtcbiAgaWYgKGNyZWF0ZUluaXRpYWxDb25uZWN0aW9uID09IG51bGwgfHwgY3JlYXRlSW5pdGlhbENvbm5lY3Rpb24pIHtcbiAgICBjb25zdCBjb25uID0gdGhpcy5jcmVhdGVDb25uZWN0aW9uKCk7IC8vIGRlZmF1bHQgY29ubmVjdGlvblxuICAgIGNvbm4ubW9kZWxzID0gdGhpcy5tb2RlbHM7XG4gIH1cblxuICBpZiAodGhpcy5vcHRpb25zLnBsdXJhbGl6YXRpb24pIHtcbiAgICB0aGlzLl9wbHVyYWxpemUgPSBsZWdhY3lQbHVyYWxpemU7XG4gIH1cblxuICAvLyBJZiBhIHVzZXIgY3JlYXRlcyB0aGVpciBvd24gTW9uZ29vc2UgaW5zdGFuY2UsIGdpdmUgdGhlbSBhIHNlcGFyYXRlIGNvcHlcbiAgLy8gb2YgdGhlIGBTY2hlbWFgIGNvbnN0cnVjdG9yIHNvIHRoZXkgZ2V0IHNlcGFyYXRlIGN1c3RvbSB0eXBlcy4gKGdoLTY5MzMpXG4gIGlmICghb3B0aW9ucyB8fCAhb3B0aW9uc1tkZWZhdWx0TW9uZ29vc2VTeW1ib2xdKSB7XG4gICAgY29uc3QgX3RoaXMgPSB0aGlzO1xuICAgIHRoaXMuU2NoZW1hID0gZnVuY3Rpb24oKSB7XG4gICAgICB0aGlzLmJhc2UgPSBfdGhpcztcbiAgICAgIHJldHVybiBTY2hlbWEuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9O1xuICAgIHRoaXMuU2NoZW1hLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoU2NoZW1hLnByb3RvdHlwZSk7XG5cbiAgICBPYmplY3QuYXNzaWduKHRoaXMuU2NoZW1hLCBTY2hlbWEpO1xuICAgIHRoaXMuU2NoZW1hLmJhc2UgPSB0aGlzO1xuICAgIHRoaXMuU2NoZW1hLlR5cGVzID0gT2JqZWN0LmFzc2lnbih7fSwgU2NoZW1hLlR5cGVzKTtcbiAgfSBlbHNlIHtcbiAgICAvLyBIYWNrIHRvIHdvcmsgYXJvdW5kIGJhYmVsJ3Mgc3RyYW5nZSBiZWhhdmlvciB3aXRoXG4gICAgLy8gYGltcG9ydCBtb25nb29zZSwgeyBTY2hlbWEgfSBmcm9tICdtb25nb29zZSdgLiBCZWNhdXNlIGBTY2hlbWFgIGlzIG5vdFxuICAgIC8vIGFuIG93biBwcm9wZXJ0eSBvZiBhIE1vbmdvb3NlIGdsb2JhbCwgU2NoZW1hIHdpbGwgYmUgdW5kZWZpbmVkLiBTZWUgZ2gtNTY0OFxuICAgIGZvciAoY29uc3Qga2V5IG9mIFsnU2NoZW1hJywgJ21vZGVsJ10pIHtcbiAgICAgIHRoaXNba2V5XSA9IE1vbmdvb3NlLnByb3RvdHlwZVtrZXldO1xuICAgIH1cbiAgfVxuICB0aGlzLlNjaGVtYS5wcm90b3R5cGUuYmFzZSA9IHRoaXM7XG5cbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsICdwbHVnaW5zJywge1xuICAgIGNvbmZpZ3VyYWJsZTogZmFsc2UsXG4gICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICB3cml0YWJsZTogZmFsc2UsXG4gICAgdmFsdWU6IE9iamVjdC52YWx1ZXMoYnVpbHRpblBsdWdpbnMpLm1hcChwbHVnaW4gPT4gKFtwbHVnaW4sIHsgZGVkdXBsaWNhdGU6IHRydWUgfV0pKVxuICB9KTtcbn1cblxuTW9uZ29vc2UucHJvdG90eXBlLmNhc3QgPSBjYXN0O1xuLyoqXG4gKiBFeHBvc2UgY29ubmVjdGlvbiBzdGF0ZXMgZm9yIHVzZXItbGFuZFxuICpcbiAqIEBtZW1iZXJPZiBNb25nb29zZVxuICogQHByb3BlcnR5IFNUQVRFU1xuICogQGFwaSBwdWJsaWNcbiAqL1xuTW9uZ29vc2UucHJvdG90eXBlLlNUQVRFUyA9IFNUQVRFUztcblxuLyoqXG4gKiBFeHBvc2UgY29ubmVjdGlvbiBzdGF0ZXMgZm9yIHVzZXItbGFuZFxuICpcbiAqIEBtZW1iZXJPZiBNb25nb29zZVxuICogQHByb3BlcnR5IENvbm5lY3Rpb25TdGF0ZXNcbiAqIEBhcGkgcHVibGljXG4gKi9cbk1vbmdvb3NlLnByb3RvdHlwZS5Db25uZWN0aW9uU3RhdGVzID0gU1RBVEVTO1xuXG4vKipcbiAqIE9iamVjdCB3aXRoIGBnZXQoKWAgYW5kIGBzZXQoKWAgY29udGFpbmluZyB0aGUgdW5kZXJseWluZyBkcml2ZXIgdGhpcyBNb25nb29zZSBpbnN0YW5jZVxuICogdXNlcyB0byBjb21tdW5pY2F0ZSB3aXRoIHRoZSBkYXRhYmFzZS4gQSBkcml2ZXIgaXMgYSBNb25nb29zZS1zcGVjaWZpYyBpbnRlcmZhY2UgdGhhdCBkZWZpbmVzIGZ1bmN0aW9uc1xuICogbGlrZSBgZmluZCgpYC5cbiAqXG4gKiBAZGVwcmVjYXRlZFxuICogQG1lbWJlck9mIE1vbmdvb3NlXG4gKiBAcHJvcGVydHkgZHJpdmVyXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbk1vbmdvb3NlLnByb3RvdHlwZS5kcml2ZXIgPSBkcml2ZXI7XG5cbi8qKlxuICogT3ZlcndyaXRlcyB0aGUgY3VycmVudCBkcml2ZXIgdXNlZCBieSB0aGlzIE1vbmdvb3NlIGluc3RhbmNlLiBBIGRyaXZlciBpcyBhXG4gKiBNb25nb29zZS1zcGVjaWZpYyBpbnRlcmZhY2UgdGhhdCBkZWZpbmVzIGZ1bmN0aW9ucyBsaWtlIGBmaW5kKClgLlxuICpcbiAqIEBtZW1iZXJPZiBNb25nb29zZVxuICogQG1ldGhvZCBzZXREcml2ZXJcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuTW9uZ29vc2UucHJvdG90eXBlLnNldERyaXZlciA9IGZ1bmN0aW9uIHNldERyaXZlcihkcml2ZXIpIHtcbiAgY29uc3QgX21vbmdvb3NlID0gdGhpcyBpbnN0YW5jZW9mIE1vbmdvb3NlID8gdGhpcyA6IG1vbmdvb3NlO1xuXG4gIGlmIChfbW9uZ29vc2UuX19kcml2ZXIgPT09IGRyaXZlcikge1xuICAgIHJldHVybiBfbW9uZ29vc2U7XG4gIH1cblxuICBjb25zdCBvcGVuQ29ubmVjdGlvbiA9IF9tb25nb29zZS5jb25uZWN0aW9ucyAmJiBfbW9uZ29vc2UuY29ubmVjdGlvbnMuZmluZChjb25uID0+IGNvbm4ucmVhZHlTdGF0ZSAhPT0gU1RBVEVTLmRpc2Nvbm5lY3RlZCk7XG4gIGlmIChvcGVuQ29ubmVjdGlvbikge1xuICAgIGNvbnN0IG1zZyA9ICdDYW5ub3QgbW9kaWZ5IE1vbmdvb3NlIGRyaXZlciBpZiBhIGNvbm5lY3Rpb24gaXMgYWxyZWFkeSBvcGVuLiAnICtcbiAgICAgICdDYWxsIGBtb25nb29zZS5kaXNjb25uZWN0KClgIGJlZm9yZSBtb2RpZnlpbmcgdGhlIGRyaXZlcic7XG4gICAgdGhyb3cgbmV3IE1vbmdvb3NlRXJyb3IobXNnKTtcbiAgfVxuICBfbW9uZ29vc2UuX19kcml2ZXIgPSBkcml2ZXI7XG5cbiAgY29uc3QgQ29ubmVjdGlvbiA9IGRyaXZlci5Db25uZWN0aW9uO1xuICBfbW9uZ29vc2UuY29ubmVjdGlvbnMgPSBbbmV3IENvbm5lY3Rpb24oX21vbmdvb3NlKV07XG4gIF9tb25nb29zZS5jb25uZWN0aW9uc1swXS5tb2RlbHMgPSBfbW9uZ29vc2UubW9kZWxzO1xuXG4gIHJldHVybiBfbW9uZ29vc2U7XG59O1xuXG4vKipcbiAqIFNldHMgbW9uZ29vc2Ugb3B0aW9uc1xuICpcbiAqIGBrZXlgIGNhbiBiZSB1c2VkIGEgb2JqZWN0IHRvIHNldCBtdWx0aXBsZSBvcHRpb25zIGF0IG9uY2UuXG4gKiBJZiBhIGVycm9yIGdldHMgdGhyb3duIGZvciBvbmUgb3B0aW9uLCBvdGhlciBvcHRpb25zIHdpbGwgc3RpbGwgYmUgZXZhbHVhdGVkLlxuICpcbiAqICMjIyMgRXhhbXBsZTpcbiAqXG4gKiAgICAgbW9uZ29vc2Uuc2V0KCd0ZXN0JywgdmFsdWUpIC8vIHNldHMgdGhlICd0ZXN0JyBvcHRpb24gdG8gYHZhbHVlYFxuICpcbiAqICAgICBtb25nb29zZS5zZXQoJ2RlYnVnJywgdHJ1ZSkgLy8gZW5hYmxlIGxvZ2dpbmcgY29sbGVjdGlvbiBtZXRob2RzICsgYXJndW1lbnRzIHRvIHRoZSBjb25zb2xlL2ZpbGVcbiAqXG4gKiAgICAgbW9uZ29vc2Uuc2V0KCdkZWJ1ZycsIGZ1bmN0aW9uKGNvbGxlY3Rpb25OYW1lLCBtZXRob2ROYW1lLCAuLi5tZXRob2RBcmdzKSB7fSk7IC8vIHVzZSBjdXN0b20gZnVuY3Rpb24gdG8gbG9nIGNvbGxlY3Rpb24gbWV0aG9kcyArIGFyZ3VtZW50c1xuICpcbiAqICAgICBtb25nb29zZS5zZXQoeyBkZWJ1ZzogdHJ1ZSwgYXV0b0luZGV4OiBmYWxzZSB9KTsgLy8gc2V0IG11bHRpcGxlIG9wdGlvbnMgYXQgb25jZVxuICpcbiAqIEN1cnJlbnRseSBzdXBwb3J0ZWQgb3B0aW9ucyBhcmU6XG4gKiAtIGBhbGxvd0Rpc2tVc2VgOiBTZXQgdG8gYHRydWVgIHRvIHNldCBgYWxsb3dEaXNrVXNlYCB0byB0cnVlIHRvIGFsbCBhZ2dyZWdhdGlvbiBvcGVyYXRpb25zIGJ5IGRlZmF1bHQuXG4gKiAtIGBhcHBseVBsdWdpbnNUb0NoaWxkU2NoZW1hc2A6IGB0cnVlYCBieSBkZWZhdWx0LiBTZXQgdG8gZmFsc2UgdG8gc2tpcCBhcHBseWluZyBnbG9iYWwgcGx1Z2lucyB0byBjaGlsZCBzY2hlbWFzXG4gKiAtIGBhcHBseVBsdWdpbnNUb0Rpc2NyaW1pbmF0b3JzYDogYGZhbHNlYCBieSBkZWZhdWx0LiBTZXQgdG8gdHJ1ZSB0byBhcHBseSBnbG9iYWwgcGx1Z2lucyB0byBkaXNjcmltaW5hdG9yIHNjaGVtYXMuIFRoaXMgdHlwaWNhbGx5IGlzbid0IG5lY2Vzc2FyeSBiZWNhdXNlIHBsdWdpbnMgYXJlIGFwcGxpZWQgdG8gdGhlIGJhc2Ugc2NoZW1hIGFuZCBkaXNjcmltaW5hdG9ycyBjb3B5IGFsbCBtaWRkbGV3YXJlLCBtZXRob2RzLCBzdGF0aWNzLCBhbmQgcHJvcGVydGllcyBmcm9tIHRoZSBiYXNlIHNjaGVtYS5cbiAqIC0gYGF1dG9DcmVhdGVgOiBTZXQgdG8gYHRydWVgIHRvIG1ha2UgTW9uZ29vc2UgY2FsbCBbYE1vZGVsLmNyZWF0ZUNvbGxlY3Rpb24oKWBdKGh0dHBzOi8vbW9uZ29vc2Vqcy5jb20vZG9jcy9hcGkvbW9kZWwuaHRtbCNNb2RlbC5jcmVhdGVDb2xsZWN0aW9uKCkpIGF1dG9tYXRpY2FsbHkgd2hlbiB5b3UgY3JlYXRlIGEgbW9kZWwgd2l0aCBgbW9uZ29vc2UubW9kZWwoKWAgb3IgYGNvbm4ubW9kZWwoKWAuIFRoaXMgaXMgdXNlZnVsIGZvciB0ZXN0aW5nIHRyYW5zYWN0aW9ucywgY2hhbmdlIHN0cmVhbXMsIGFuZCBvdGhlciBmZWF0dXJlcyB0aGF0IHJlcXVpcmUgdGhlIGNvbGxlY3Rpb24gdG8gZXhpc3QuXG4gKiAtIGBhdXRvSW5kZXhgOiBgdHJ1ZWAgYnkgZGVmYXVsdC4gU2V0IHRvIGZhbHNlIHRvIGRpc2FibGUgYXV0b21hdGljIGluZGV4IGNyZWF0aW9uIGZvciBhbGwgbW9kZWxzIGFzc29jaWF0ZWQgd2l0aCB0aGlzIE1vbmdvb3NlIGluc3RhbmNlLlxuICogLSBgYnVmZmVyQ29tbWFuZHNgOiBlbmFibGUvZGlzYWJsZSBtb25nb29zZSdzIGJ1ZmZlcmluZyBtZWNoYW5pc20gZm9yIGFsbCBjb25uZWN0aW9ucyBhbmQgbW9kZWxzXG4gKiAtIGBidWZmZXJUaW1lb3V0TVNgOiBJZiBidWZmZXJDb21tYW5kcyBpcyBvbiwgdGhpcyBvcHRpb24gc2V0cyB0aGUgbWF4aW11bSBhbW91bnQgb2YgdGltZSBNb25nb29zZSBidWZmZXJpbmcgd2lsbCB3YWl0IGJlZm9yZSB0aHJvd2luZyBhbiBlcnJvci4gSWYgbm90IHNwZWNpZmllZCwgTW9uZ29vc2Ugd2lsbCB1c2UgMTAwMDAgKDEwIHNlY29uZHMpLlxuICogLSBgY2xvbmVTY2hlbWFzYDogYGZhbHNlYCBieSBkZWZhdWx0LiBTZXQgdG8gYHRydWVgIHRvIGBjbG9uZSgpYCBhbGwgc2NoZW1hcyBiZWZvcmUgY29tcGlsaW5nIGludG8gYSBtb2RlbC5cbiAqIC0gYGRlYnVnYDogSWYgYHRydWVgLCBwcmludHMgdGhlIG9wZXJhdGlvbnMgbW9uZ29vc2Ugc2VuZHMgdG8gTW9uZ29EQiB0byB0aGUgY29uc29sZS4gSWYgYSB3cml0YWJsZSBzdHJlYW0gaXMgcGFzc2VkLCBpdCB3aWxsIGxvZyB0byB0aGF0IHN0cmVhbSwgd2l0aG91dCBjb2xvcml6YXRpb24uIElmIGEgY2FsbGJhY2sgZnVuY3Rpb24gaXMgcGFzc2VkLCBpdCB3aWxsIHJlY2VpdmUgdGhlIGNvbGxlY3Rpb24gbmFtZSwgdGhlIG1ldGhvZCBuYW1lLCB0aGVuIGFsbCBhcmd1bWVudHMgcGFzc2VkIHRvIHRoZSBtZXRob2QuIEZvciBleGFtcGxlLCBpZiB5b3Ugd2FudGVkIHRvIHJlcGxpY2F0ZSB0aGUgZGVmYXVsdCBsb2dnaW5nLCB5b3UgY291bGQgb3V0cHV0IGZyb20gdGhlIGNhbGxiYWNrIGBNb25nb29zZTogJHtjb2xsZWN0aW9uTmFtZX0uJHttZXRob2ROYW1lfSgke21ldGhvZEFyZ3Muam9pbignLCAnKX0pYC5cbiAqIC0gYGlkYDogSWYgYHRydWVgLCBhZGRzIGEgYGlkYCB2aXJ0dWFsIHRvIGFsbCBzY2hlbWFzIHVubGVzcyBvdmVyd3JpdHRlbiBvbiBhIHBlci1zY2hlbWEgYmFzaXMuXG4gKiAtIGB0aW1lc3RhbXBzLmNyZWF0ZWRBdC5pbW11dGFibGVgOiBgdHJ1ZWAgYnkgZGVmYXVsdC4gSWYgYGZhbHNlYCwgaXQgd2lsbCBjaGFuZ2UgdGhlIGBjcmVhdGVkQXRgIGZpZWxkIHRvIGJlIFtgaW1tdXRhYmxlOiBmYWxzZWBdKGh0dHBzOi8vbW9uZ29vc2Vqcy5jb20vZG9jcy9hcGkvc2NoZW1hdHlwZS5odG1sI1NjaGVtYVR5cGUucHJvdG90eXBlLmltbXV0YWJsZSkgd2hpY2ggbWVhbnMgeW91IGNhbiB1cGRhdGUgdGhlIGBjcmVhdGVkQXRgXG4gKiAtIGBtYXhUaW1lTVNgOiBJZiBzZXQsIGF0dGFjaGVzIFttYXhUaW1lTVNdKGh0dHBzOi8vd3d3Lm1vbmdvZGIuY29tL2RvY3MvbWFudWFsL3JlZmVyZW5jZS9vcGVyYXRvci9tZXRhL21heFRpbWVNUy8pIHRvIGV2ZXJ5IHF1ZXJ5XG4gKiAtIGBvYmplY3RJZEdldHRlcmA6IGB0cnVlYCBieSBkZWZhdWx0LiBNb25nb29zZSBhZGRzIGEgZ2V0dGVyIHRvIE1vbmdvREIgT2JqZWN0SWQncyBjYWxsZWQgYF9pZGAgdGhhdCByZXR1cm5zIGB0aGlzYCBmb3IgY29udmVuaWVuY2Ugd2l0aCBwb3B1bGF0ZS4gU2V0IHRoaXMgdG8gZmFsc2UgdG8gcmVtb3ZlIHRoZSBnZXR0ZXIuXG4gKiAtIGBvdmVyd3JpdGVNb2RlbHNgOiBTZXQgdG8gYHRydWVgIHRvIGRlZmF1bHQgdG8gb3ZlcndyaXRpbmcgbW9kZWxzIHdpdGggdGhlIHNhbWUgbmFtZSB3aGVuIGNhbGxpbmcgYG1vbmdvb3NlLm1vZGVsKClgLCBhcyBvcHBvc2VkIHRvIHRocm93aW5nIGFuIGBPdmVyd3JpdGVNb2RlbEVycm9yYC5cbiAqIC0gYHJldHVybk9yaWdpbmFsYDogSWYgYGZhbHNlYCwgY2hhbmdlcyB0aGUgZGVmYXVsdCBgcmV0dXJuT3JpZ2luYWxgIG9wdGlvbiB0byBgZmluZE9uZUFuZFVwZGF0ZSgpYCwgYGZpbmRCeUlkQW5kVXBkYXRlYCwgYW5kIGBmaW5kT25lQW5kUmVwbGFjZSgpYCB0byBmYWxzZS4gVGhpcyBpcyBlcXVpdmFsZW50IHRvIHNldHRpbmcgdGhlIGBuZXdgIG9wdGlvbiB0byBgdHJ1ZWAgZm9yIGBmaW5kT25lQW5kWCgpYCBjYWxscyBieSBkZWZhdWx0LiBSZWFkIG91ciBbYGZpbmRPbmVBbmRVcGRhdGUoKWAgdHV0b3JpYWxdKGh0dHBzOi8vbW9uZ29vc2Vqcy5jb20vZG9jcy90dXRvcmlhbHMvZmluZG9uZWFuZHVwZGF0ZS5odG1sKSBmb3IgbW9yZSBpbmZvcm1hdGlvbi5cbiAqIC0gYHJ1blZhbGlkYXRvcnNgOiBgZmFsc2VgIGJ5IGRlZmF1bHQuIFNldCB0byB0cnVlIHRvIGVuYWJsZSBbdXBkYXRlIHZhbGlkYXRvcnNdKGh0dHBzOi8vbW9uZ29vc2Vqcy5jb20vZG9jcy92YWxpZGF0aW9uLmh0bWwjdXBkYXRlLXZhbGlkYXRvcnMpIGZvciBhbGwgdmFsaWRhdG9ycyBieSBkZWZhdWx0LlxuICogLSBgc2FuaXRpemVGaWx0ZXJgOiBgZmFsc2VgIGJ5IGRlZmF1bHQuIFNldCB0byB0cnVlIHRvIGVuYWJsZSB0aGUgW3Nhbml0aXphdGlvbiBvZiB0aGUgcXVlcnkgZmlsdGVyc10oaHR0cHM6Ly9tb25nb29zZWpzLmNvbS9kb2NzL2FwaS9tb25nb29zZS5odG1sI01vbmdvb3NlLnByb3RvdHlwZS5zYW5pdGl6ZUZpbHRlcigpKSBhZ2FpbnN0IHF1ZXJ5IHNlbGVjdG9yIGluamVjdGlvbiBhdHRhY2tzIGJ5IHdyYXBwaW5nIGFueSBuZXN0ZWQgb2JqZWN0cyB0aGF0IGhhdmUgYSBwcm9wZXJ0eSB3aG9zZSBuYW1lIHN0YXJ0cyB3aXRoIGAkYCBpbiBhIGAkZXFgLlxuICogLSBgc2VsZWN0UG9wdWxhdGVkUGF0aHNgOiBgdHJ1ZWAgYnkgZGVmYXVsdC4gU2V0IHRvIGZhbHNlIHRvIG9wdCBvdXQgb2YgTW9uZ29vc2UgYWRkaW5nIGFsbCBmaWVsZHMgdGhhdCB5b3UgYHBvcHVsYXRlKClgIHRvIHlvdXIgYHNlbGVjdCgpYC4gVGhlIHNjaGVtYS1sZXZlbCBvcHRpb24gYHNlbGVjdFBvcHVsYXRlZFBhdGhzYCBvdmVyd3JpdGVzIHRoaXMgb25lLlxuICogLSBgc3RyaWN0YDogYHRydWVgIGJ5IGRlZmF1bHQsIG1heSBiZSBgZmFsc2VgLCBgdHJ1ZWAsIG9yIGAndGhyb3cnYC4gU2V0cyB0aGUgZGVmYXVsdCBzdHJpY3QgbW9kZSBmb3Igc2NoZW1hcy5cbiAqIC0gYHN0cmljdFF1ZXJ5YDogYGZhbHNlYCBieSBkZWZhdWx0LiBNYXkgYmUgYGZhbHNlYCwgYHRydWVgLCBvciBgJ3Rocm93J2AuIFNldHMgdGhlIGRlZmF1bHQgW3N0cmljdFF1ZXJ5XShodHRwczovL21vbmdvb3NlanMuY29tL2RvY3MvZ3VpZGUuaHRtbCNzdHJpY3RRdWVyeSkgbW9kZSBmb3Igc2NoZW1hcy5cbiAqIC0gYHRvSlNPTmA6IGB7IHRyYW5zZm9ybTogdHJ1ZSwgZmxhdHRlbkRlY2ltYWxzOiB0cnVlIH1gIGJ5IGRlZmF1bHQuIE92ZXJ3cml0ZXMgZGVmYXVsdCBvYmplY3RzIHRvIFtgdG9KU09OKClgXShodHRwczovL21vbmdvb3NlanMuY29tL2RvY3MvYXBpL2RvY3VtZW50Lmh0bWwjRG9jdW1lbnQucHJvdG90eXBlLnRvSlNPTigpKSwgZm9yIGRldGVybWluaW5nIGhvdyBNb25nb29zZSBkb2N1bWVudHMgZ2V0IHNlcmlhbGl6ZWQgYnkgYEpTT04uc3RyaW5naWZ5KClgXG4gKiAtIGB0b09iamVjdGA6IGB7IHRyYW5zZm9ybTogdHJ1ZSwgZmxhdHRlbkRlY2ltYWxzOiB0cnVlIH1gIGJ5IGRlZmF1bHQuIE92ZXJ3cml0ZXMgZGVmYXVsdCBvYmplY3RzIHRvIFtgdG9PYmplY3QoKWBdKGh0dHBzOi8vbW9uZ29vc2Vqcy5jb20vZG9jcy9hcGkvZG9jdW1lbnQuaHRtbCNEb2N1bWVudC5wcm90b3R5cGUudG9PYmplY3QoKSlcbiAqXG4gKiBAcGFyYW0ge1N0cmluZ3xPYmplY3R9IGtleSBUaGUgbmFtZSBvZiB0aGUgb3B0aW9uIG9yIGEgb2JqZWN0IG9mIG11bHRpcGxlIGtleS12YWx1ZSBwYWlyc1xuICogQHBhcmFtIHtTdHJpbmd8RnVuY3Rpb258Qm9vbGVhbn0gdmFsdWUgVGhlIHZhbHVlIG9mIHRoZSBvcHRpb24sIHVudXNlZCBpZiBcImtleVwiIGlzIGEgb2JqZWN0XG4gKiBAcmV0dXJucyB7TW9uZ29vc2V9IFRoZSB1c2VkIE1vbmdvb3NlIGluc3RuYWNlXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbk1vbmdvb3NlLnByb3RvdHlwZS5zZXQgPSBmdW5jdGlvbihrZXksIHZhbHVlKSB7XG4gIGNvbnN0IF9tb25nb29zZSA9IHRoaXMgaW5zdGFuY2VvZiBNb25nb29zZSA/IHRoaXMgOiBtb25nb29zZTtcblxuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMSAmJiB0eXBlb2Yga2V5ICE9PSAnb2JqZWN0Jykge1xuICAgIGlmIChWQUxJRF9PUFRJT05TLmluZGV4T2Yoa2V5KSA9PT0gLTEpIHtcbiAgICAgIGNvbnN0IGVycm9yID0gbmV3IFNldE9wdGlvbkVycm9yKCk7XG4gICAgICBlcnJvci5hZGRFcnJvcihrZXksIG5ldyBTZXRPcHRpb25FcnJvci5TZXRPcHRpb25Jbm5lckVycm9yKGtleSkpO1xuICAgICAgdGhyb3cgZXJyb3I7XG4gICAgfVxuXG4gICAgcmV0dXJuIF9tb25nb29zZS5vcHRpb25zW2tleV07XG4gIH1cblxuICBsZXQgb3B0aW9ucyA9IHt9O1xuXG4gIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAyKSB7XG4gICAgb3B0aW9ucyA9IHsgW2tleV06IHZhbHVlIH07XG4gIH1cblxuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMSAmJiB0eXBlb2Yga2V5ID09PSAnb2JqZWN0Jykge1xuICAgIG9wdGlvbnMgPSBrZXk7XG4gIH1cblxuICAvLyBhcnJheSBmb3IgZXJyb3JzIHRvIGNvbGxlY3QgYWxsIGVycm9ycyBmb3IgYWxsIGtleS12YWx1ZSBwYWlycywgbGlrZSBcIi52YWxpZGF0ZVwiXG4gIGxldCBlcnJvciA9IHVuZGVmaW5lZDtcblxuICBmb3IgKGNvbnN0IFtvcHRpb25LZXksIG9wdGlvblZhbHVlXSBvZiBPYmplY3QuZW50cmllcyhvcHRpb25zKSkge1xuICAgIGlmIChWQUxJRF9PUFRJT05TLmluZGV4T2Yob3B0aW9uS2V5KSA9PT0gLTEpIHtcbiAgICAgIGlmICghZXJyb3IpIHtcbiAgICAgICAgZXJyb3IgPSBuZXcgU2V0T3B0aW9uRXJyb3IoKTtcbiAgICAgIH1cbiAgICAgIGVycm9yLmFkZEVycm9yKG9wdGlvbktleSwgbmV3IFNldE9wdGlvbkVycm9yLlNldE9wdGlvbklubmVyRXJyb3Iob3B0aW9uS2V5KSk7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICBfbW9uZ29vc2Uub3B0aW9uc1tvcHRpb25LZXldID0gb3B0aW9uVmFsdWU7XG5cbiAgICBpZiAob3B0aW9uS2V5ID09PSAnb2JqZWN0SWRHZXR0ZXInKSB7XG4gICAgICBpZiAob3B0aW9uVmFsdWUpIHtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG1vbmdvb3NlLlR5cGVzLk9iamVjdElkLnByb3RvdHlwZSwgJ19pZCcsIHtcbiAgICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBkZWxldGUgbW9uZ29vc2UuVHlwZXMuT2JqZWN0SWQucHJvdG90eXBlLl9pZDtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBpZiAoZXJyb3IpIHtcbiAgICB0aHJvdyBlcnJvcjtcbiAgfVxuXG4gIHJldHVybiBfbW9uZ29vc2U7XG59O1xuXG4vKipcbiAqIEdldHMgbW9uZ29vc2Ugb3B0aW9uc1xuICpcbiAqICMjIyMgRXhhbXBsZTpcbiAqXG4gKiAgICAgbW9uZ29vc2UuZ2V0KCd0ZXN0JykgLy8gcmV0dXJucyB0aGUgJ3Rlc3QnIHZhbHVlXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IGtleVxuICogQG1ldGhvZCBnZXRcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuTW9uZ29vc2UucHJvdG90eXBlLmdldCA9IE1vbmdvb3NlLnByb3RvdHlwZS5zZXQ7XG5cbi8qKlxuICogQ3JlYXRlcyBhIENvbm5lY3Rpb24gaW5zdGFuY2UuXG4gKlxuICogRWFjaCBgY29ubmVjdGlvbmAgaW5zdGFuY2UgbWFwcyB0byBhIHNpbmdsZSBkYXRhYmFzZS4gVGhpcyBtZXRob2QgaXMgaGVscGZ1bCB3aGVuIG1hbmFnaW5nIG11bHRpcGxlIGRiIGNvbm5lY3Rpb25zLlxuICpcbiAqXG4gKiBfT3B0aW9ucyBwYXNzZWQgdGFrZSBwcmVjZWRlbmNlIG92ZXIgb3B0aW9ucyBpbmNsdWRlZCBpbiBjb25uZWN0aW9uIHN0cmluZ3MuX1xuICpcbiAqICMjIyMgRXhhbXBsZTpcbiAqXG4gKiAgICAgLy8gd2l0aCBtb25nb2RiOi8vIFVSSVxuICogICAgIGRiID0gbW9uZ29vc2UuY3JlYXRlQ29ubmVjdGlvbignbW9uZ29kYjovL3VzZXI6cGFzc0AxMjcuMC4wLjE6cG9ydC9kYXRhYmFzZScpO1xuICpcbiAqICAgICAvLyBhbmQgb3B0aW9uc1xuICogICAgIGNvbnN0IG9wdHMgPSB7IGRiOiB7IG5hdGl2ZV9wYXJzZXI6IHRydWUgfX1cbiAqICAgICBkYiA9IG1vbmdvb3NlLmNyZWF0ZUNvbm5lY3Rpb24oJ21vbmdvZGI6Ly91c2VyOnBhc3NAMTI3LjAuMC4xOnBvcnQvZGF0YWJhc2UnLCBvcHRzKTtcbiAqXG4gKiAgICAgLy8gcmVwbGljYSBzZXRzXG4gKiAgICAgZGIgPSBtb25nb29zZS5jcmVhdGVDb25uZWN0aW9uKCdtb25nb2RiOi8vdXNlcjpwYXNzQDEyNy4wLjAuMTpwb3J0LGFub3RoZXJob3N0OnBvcnQseWV0YW5vdGhlcjpwb3J0L2RhdGFiYXNlJyk7XG4gKlxuICogICAgIC8vIGFuZCBvcHRpb25zXG4gKiAgICAgY29uc3Qgb3B0cyA9IHsgcmVwbHNldDogeyBzdHJhdGVneTogJ3BpbmcnLCByc19uYW1lOiAndGVzdFNldCcgfX1cbiAqICAgICBkYiA9IG1vbmdvb3NlLmNyZWF0ZUNvbm5lY3Rpb24oJ21vbmdvZGI6Ly91c2VyOnBhc3NAMTI3LjAuMC4xOnBvcnQsYW5vdGhlcmhvc3Q6cG9ydCx5ZXRhbm90aGVyOnBvcnQvZGF0YWJhc2UnLCBvcHRzKTtcbiAqXG4gKiAgICAgLy8gaW5pdGlhbGl6ZSBub3csIGNvbm5lY3QgbGF0ZXJcbiAqICAgICBkYiA9IG1vbmdvb3NlLmNyZWF0ZUNvbm5lY3Rpb24oKTtcbiAqICAgICBkYi5vcGVuVXJpKCcxMjcuMC4wLjEnLCAnZGF0YWJhc2UnLCBwb3J0LCBbb3B0c10pO1xuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSB1cmkgbW9uZ29kYiBVUkkgdG8gY29ubmVjdCB0b1xuICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSBwYXNzZWQgZG93biB0byB0aGUgW01vbmdvREIgZHJpdmVyJ3MgYGNvbm5lY3QoKWAgZnVuY3Rpb25dKGh0dHBzOi8vbW9uZ29kYi5naXRodWIuaW8vbm9kZS1tb25nb2RiLW5hdGl2ZS80LjkvaW50ZXJmYWNlcy9Nb25nb0NsaWVudE9wdGlvbnMuaHRtbCksIGV4Y2VwdCBmb3IgNCBtb25nb29zZS1zcGVjaWZpYyBvcHRpb25zIGV4cGxhaW5lZCBiZWxvdy5cbiAqIEBwYXJhbSB7Qm9vbGVhbn0gW29wdGlvbnMuYnVmZmVyQ29tbWFuZHM9dHJ1ZV0gTW9uZ29vc2Ugc3BlY2lmaWMgb3B0aW9uLiBTZXQgdG8gZmFsc2UgdG8gW2Rpc2FibGUgYnVmZmVyaW5nXShodHRwczovL21vbmdvb3NlanMuY29tL2RvY3MvZmFxLmh0bWwjY2FsbGJhY2tfbmV2ZXJfZXhlY3V0ZXMpIG9uIGFsbCBtb2RlbHMgYXNzb2NpYXRlZCB3aXRoIHRoaXMgY29ubmVjdGlvbi5cbiAqIEBwYXJhbSB7U3RyaW5nfSBbb3B0aW9ucy5kYk5hbWVdIFRoZSBuYW1lIG9mIHRoZSBkYXRhYmFzZSB5b3Ugd2FudCB0byB1c2UuIElmIG5vdCBwcm92aWRlZCwgTW9uZ29vc2UgdXNlcyB0aGUgZGF0YWJhc2UgbmFtZSBmcm9tIGNvbm5lY3Rpb24gc3RyaW5nLlxuICogQHBhcmFtIHtTdHJpbmd9IFtvcHRpb25zLnVzZXJdIHVzZXJuYW1lIGZvciBhdXRoZW50aWNhdGlvbiwgZXF1aXZhbGVudCB0byBgb3B0aW9ucy5hdXRoLnVzZXJgLiBNYWludGFpbmVkIGZvciBiYWNrd2FyZHMgY29tcGF0aWJpbGl0eS5cbiAqIEBwYXJhbSB7U3RyaW5nfSBbb3B0aW9ucy5wYXNzXSBwYXNzd29yZCBmb3IgYXV0aGVudGljYXRpb24sIGVxdWl2YWxlbnQgdG8gYG9wdGlvbnMuYXV0aC5wYXNzd29yZGAuIE1haW50YWluZWQgZm9yIGJhY2t3YXJkcyBjb21wYXRpYmlsaXR5LlxuICogQHBhcmFtIHtCb29sZWFufSBbb3B0aW9ucy5hdXRvSW5kZXg9dHJ1ZV0gTW9uZ29vc2Utc3BlY2lmaWMgb3B0aW9uLiBTZXQgdG8gZmFsc2UgdG8gZGlzYWJsZSBhdXRvbWF0aWMgaW5kZXggY3JlYXRpb24gZm9yIGFsbCBtb2RlbHMgYXNzb2NpYXRlZCB3aXRoIHRoaXMgY29ubmVjdGlvbi5cbiAqIEBwYXJhbSB7Q2xhc3N9IFtvcHRpb25zLnByb21pc2VMaWJyYXJ5XSBTZXRzIHRoZSBbdW5kZXJseWluZyBkcml2ZXIncyBwcm9taXNlIGxpYnJhcnldKGh0dHBzOi8vbW9uZ29kYi5naXRodWIuaW8vbm9kZS1tb25nb2RiLW5hdGl2ZS80LjkvaW50ZXJmYWNlcy9Nb25nb0NsaWVudE9wdGlvbnMuaHRtbCNwcm9taXNlTGlicmFyeSkuXG4gKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMubWF4UG9vbFNpemU9NV0gVGhlIG1heGltdW0gbnVtYmVyIG9mIHNvY2tldHMgdGhlIE1vbmdvREIgZHJpdmVyIHdpbGwga2VlcCBvcGVuIGZvciB0aGlzIGNvbm5lY3Rpb24uIEtlZXAgaW4gbWluZCB0aGF0IE1vbmdvREIgb25seSBhbGxvd3Mgb25lIG9wZXJhdGlvbiBwZXIgc29ja2V0IGF0IGEgdGltZSwgc28geW91IG1heSB3YW50IHRvIGluY3JlYXNlIHRoaXMgaWYgeW91IGZpbmQgeW91IGhhdmUgYSBmZXcgc2xvdyBxdWVyaWVzIHRoYXQgYXJlIGJsb2NraW5nIGZhc3RlciBxdWVyaWVzIGZyb20gcHJvY2VlZGluZy4gU2VlIFtTbG93IFRyYWlucyBpbiBNb25nb0RCIGFuZCBOb2RlLmpzXShodHRwczovL3RoZWNvZGViYXJiYXJpYW4uY29tL3Nsb3ctdHJhaW5zLWluLW1vbmdvZGItYW5kLW5vZGVqcykuXG4gKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMubWluUG9vbFNpemU9MV0gVGhlIG1pbmltdW0gbnVtYmVyIG9mIHNvY2tldHMgdGhlIE1vbmdvREIgZHJpdmVyIHdpbGwga2VlcCBvcGVuIGZvciB0aGlzIGNvbm5lY3Rpb24uIEtlZXAgaW4gbWluZCB0aGF0IE1vbmdvREIgb25seSBhbGxvd3Mgb25lIG9wZXJhdGlvbiBwZXIgc29ja2V0IGF0IGEgdGltZSwgc28geW91IG1heSB3YW50IHRvIGluY3JlYXNlIHRoaXMgaWYgeW91IGZpbmQgeW91IGhhdmUgYSBmZXcgc2xvdyBxdWVyaWVzIHRoYXQgYXJlIGJsb2NraW5nIGZhc3RlciBxdWVyaWVzIGZyb20gcHJvY2VlZGluZy4gU2VlIFtTbG93IFRyYWlucyBpbiBNb25nb0RCIGFuZCBOb2RlLmpzXShodHRwczovL3RoZWNvZGViYXJiYXJpYW4uY29tL3Nsb3ctdHJhaW5zLWluLW1vbmdvZGItYW5kLW5vZGVqcykuXG4gKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMuc29ja2V0VGltZW91dE1TPTBdIEhvdyBsb25nIHRoZSBNb25nb0RCIGRyaXZlciB3aWxsIHdhaXQgYmVmb3JlIGtpbGxpbmcgYSBzb2NrZXQgZHVlIHRvIGluYWN0aXZpdHkgX2FmdGVyIGluaXRpYWwgY29ubmVjdGlvbl8uIERlZmF1bHRzIHRvIDAsIHdoaWNoIG1lYW5zIE5vZGUuanMgd2lsbCBub3QgdGltZSBvdXQgdGhlIHNvY2tldCBkdWUgdG8gaW5hY3Rpdml0eS4gQSBzb2NrZXQgbWF5IGJlIGluYWN0aXZlIGJlY2F1c2Ugb2YgZWl0aGVyIG5vIGFjdGl2aXR5IG9yIGEgbG9uZy1ydW5uaW5nIG9wZXJhdGlvbi4gVGhpcyBvcHRpb24gaXMgcGFzc2VkIHRvIFtOb2RlLmpzIGBzb2NrZXQjc2V0VGltZW91dCgpYCBmdW5jdGlvbl0oaHR0cHM6Ly9ub2RlanMub3JnL2FwaS9uZXQuaHRtbCNuZXRfc29ja2V0X3NldHRpbWVvdXRfdGltZW91dF9jYWxsYmFjaykgYWZ0ZXIgdGhlIE1vbmdvREIgZHJpdmVyIHN1Y2Nlc3NmdWxseSBjb21wbGV0ZXMuXG4gKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMuZmFtaWx5PTBdIFBhc3NlZCB0cmFuc3BhcmVudGx5IHRvIFtOb2RlLmpzJyBgZG5zLmxvb2t1cCgpYF0oaHR0cHM6Ly9ub2RlanMub3JnL2FwaS9kbnMuaHRtbCNkbnNfZG5zX2xvb2t1cF9ob3N0bmFtZV9vcHRpb25zX2NhbGxiYWNrKSBmdW5jdGlvbi4gTWF5IGJlIGVpdGhlciBgMGAsIGA0YCwgb3IgYDZgLiBgNGAgbWVhbnMgdXNlIElQdjQgb25seSwgYDZgIG1lYW5zIHVzZSBJUHY2IG9ubHksIGAwYCBtZWFucyB0cnkgYm90aC5cbiAqIEByZXR1cm4ge0Nvbm5lY3Rpb259IHRoZSBjcmVhdGVkIENvbm5lY3Rpb24gb2JqZWN0LiBDb25uZWN0aW9ucyBhcmUgbm90IHRoZW5hYmxlLCBzbyB5b3UgY2FuJ3QgZG8gYGF3YWl0IG1vbmdvb3NlLmNyZWF0ZUNvbm5lY3Rpb24oKWAuIFRvIGF3YWl0IHVzZSBgbW9uZ29vc2UuY3JlYXRlQ29ubmVjdGlvbih1cmkpLmFzUHJvbWlzZSgpYCBpbnN0ZWFkLlxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5Nb25nb29zZS5wcm90b3R5cGUuY3JlYXRlQ29ubmVjdGlvbiA9IGZ1bmN0aW9uKHVyaSwgb3B0aW9ucykge1xuICBjb25zdCBfbW9uZ29vc2UgPSB0aGlzIGluc3RhbmNlb2YgTW9uZ29vc2UgPyB0aGlzIDogbW9uZ29vc2U7XG5cbiAgY29uc3QgQ29ubmVjdGlvbiA9IF9tb25nb29zZS5fX2RyaXZlci5Db25uZWN0aW9uO1xuICBjb25zdCBjb25uID0gbmV3IENvbm5lY3Rpb24oX21vbmdvb3NlKTtcbiAgX21vbmdvb3NlLmNvbm5lY3Rpb25zLnB1c2goY29ubik7XG4gIF9tb25nb29zZS5uZXh0Q29ubmVjdGlvbklkKys7XG4gIF9tb25nb29zZS5ldmVudHMuZW1pdCgnY3JlYXRlQ29ubmVjdGlvbicsIGNvbm4pO1xuXG4gIGlmIChhcmd1bWVudHMubGVuZ3RoID4gMCkge1xuICAgIGNvbm4ub3BlblVyaSh1cmksIHsgLi4ub3B0aW9ucywgX2ZpcmVBbmRGb3JnZXQ6IHRydWUgfSk7XG4gIH1cblxuICByZXR1cm4gY29ubjtcbn07XG5cbi8qKlxuICogT3BlbnMgdGhlIGRlZmF1bHQgbW9uZ29vc2UgY29ubmVjdGlvbi5cbiAqXG4gKiAjIyMjIEV4YW1wbGU6XG4gKlxuICogICAgIG1vbmdvb3NlLmNvbm5lY3QoJ21vbmdvZGI6Ly91c2VyOnBhc3NAMTI3LjAuMC4xOnBvcnQvZGF0YWJhc2UnKTtcbiAqXG4gKiAgICAgLy8gcmVwbGljYSBzZXRzXG4gKiAgICAgY29uc3QgdXJpID0gJ21vbmdvZGI6Ly91c2VyOnBhc3NAMTI3LjAuMC4xOnBvcnQsYW5vdGhlcmhvc3Q6cG9ydCx5ZXRhbm90aGVyOnBvcnQvbXlkYXRhYmFzZSc7XG4gKiAgICAgbW9uZ29vc2UuY29ubmVjdCh1cmkpO1xuICpcbiAqICAgICAvLyB3aXRoIG9wdGlvbnNcbiAqICAgICBtb25nb29zZS5jb25uZWN0KHVyaSwgb3B0aW9ucyk7XG4gKlxuICogICAgIC8vIG9wdGlvbmFsIGNhbGxiYWNrIHRoYXQgZ2V0cyBmaXJlZCB3aGVuIGluaXRpYWwgY29ubmVjdGlvbiBjb21wbGV0ZWRcbiAqICAgICBjb25zdCB1cmkgPSAnbW9uZ29kYjovL25vbmV4aXN0ZW50LmRvbWFpbjoyNzAwMCc7XG4gKiAgICAgbW9uZ29vc2UuY29ubmVjdCh1cmksIGZ1bmN0aW9uKGVycm9yKSB7XG4gKiAgICAgICAvLyBpZiBlcnJvciBpcyB0cnV0aHksIHRoZSBpbml0aWFsIGNvbm5lY3Rpb24gZmFpbGVkLlxuICogICAgIH0pXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IHVyaSBtb25nb2RiIFVSSSB0byBjb25uZWN0IHRvXG4gKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdIHBhc3NlZCBkb3duIHRvIHRoZSBbTW9uZ29EQiBkcml2ZXIncyBgY29ubmVjdCgpYCBmdW5jdGlvbl0oaHR0cHM6Ly9tb25nb2RiLmdpdGh1Yi5pby9ub2RlLW1vbmdvZGItbmF0aXZlLzQuOS9pbnRlcmZhY2VzL01vbmdvQ2xpZW50T3B0aW9ucy5odG1sKSwgZXhjZXB0IGZvciA0IG1vbmdvb3NlLXNwZWNpZmljIG9wdGlvbnMgZXhwbGFpbmVkIGJlbG93LlxuICogQHBhcmFtIHtCb29sZWFufSBbb3B0aW9ucy5idWZmZXJDb21tYW5kcz10cnVlXSBNb25nb29zZSBzcGVjaWZpYyBvcHRpb24uIFNldCB0byBmYWxzZSB0byBbZGlzYWJsZSBidWZmZXJpbmddKGh0dHBzOi8vbW9uZ29vc2Vqcy5jb20vZG9jcy9mYXEuaHRtbCNjYWxsYmFja19uZXZlcl9leGVjdXRlcykgb24gYWxsIG1vZGVscyBhc3NvY2lhdGVkIHdpdGggdGhpcyBjb25uZWN0aW9uLlxuICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLmJ1ZmZlclRpbWVvdXRNUz0xMDAwMF0gTW9uZ29vc2Ugc3BlY2lmaWMgb3B0aW9uLiBJZiBgYnVmZmVyQ29tbWFuZHNgIGlzIHRydWUsIE1vbmdvb3NlIHdpbGwgdGhyb3cgYW4gZXJyb3IgYWZ0ZXIgYGJ1ZmZlclRpbWVvdXRNU2AgaWYgdGhlIG9wZXJhdGlvbiBpcyBzdGlsbCBidWZmZXJlZC5cbiAqIEBwYXJhbSB7U3RyaW5nfSBbb3B0aW9ucy5kYk5hbWVdIFRoZSBuYW1lIG9mIHRoZSBkYXRhYmFzZSB3ZSB3YW50IHRvIHVzZS4gSWYgbm90IHByb3ZpZGVkLCB1c2UgZGF0YWJhc2UgbmFtZSBmcm9tIGNvbm5lY3Rpb24gc3RyaW5nLlxuICogQHBhcmFtIHtTdHJpbmd9IFtvcHRpb25zLnVzZXJdIHVzZXJuYW1lIGZvciBhdXRoZW50aWNhdGlvbiwgZXF1aXZhbGVudCB0byBgb3B0aW9ucy5hdXRoLnVzZXJgLiBNYWludGFpbmVkIGZvciBiYWNrd2FyZHMgY29tcGF0aWJpbGl0eS5cbiAqIEBwYXJhbSB7U3RyaW5nfSBbb3B0aW9ucy5wYXNzXSBwYXNzd29yZCBmb3IgYXV0aGVudGljYXRpb24sIGVxdWl2YWxlbnQgdG8gYG9wdGlvbnMuYXV0aC5wYXNzd29yZGAuIE1haW50YWluZWQgZm9yIGJhY2t3YXJkcyBjb21wYXRpYmlsaXR5LlxuICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLm1heFBvb2xTaXplPTEwMF0gVGhlIG1heGltdW0gbnVtYmVyIG9mIHNvY2tldHMgdGhlIE1vbmdvREIgZHJpdmVyIHdpbGwga2VlcCBvcGVuIGZvciB0aGlzIGNvbm5lY3Rpb24uIEtlZXAgaW4gbWluZCB0aGF0IE1vbmdvREIgb25seSBhbGxvd3Mgb25lIG9wZXJhdGlvbiBwZXIgc29ja2V0IGF0IGEgdGltZSwgc28geW91IG1heSB3YW50IHRvIGluY3JlYXNlIHRoaXMgaWYgeW91IGZpbmQgeW91IGhhdmUgYSBmZXcgc2xvdyBxdWVyaWVzIHRoYXQgYXJlIGJsb2NraW5nIGZhc3RlciBxdWVyaWVzIGZyb20gcHJvY2VlZGluZy4gU2VlIFtTbG93IFRyYWlucyBpbiBNb25nb0RCIGFuZCBOb2RlLmpzXShodHRwczovL3RoZWNvZGViYXJiYXJpYW4uY29tL3Nsb3ctdHJhaW5zLWluLW1vbmdvZGItYW5kLW5vZGVqcykuXG4gKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMubWluUG9vbFNpemU9MF0gVGhlIG1pbmltdW0gbnVtYmVyIG9mIHNvY2tldHMgdGhlIE1vbmdvREIgZHJpdmVyIHdpbGwga2VlcCBvcGVuIGZvciB0aGlzIGNvbm5lY3Rpb24uXG4gKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMuc2VydmVyU2VsZWN0aW9uVGltZW91dE1TXSBJZiBgdXNlVW5pZmllZFRvcG9sb2d5ID0gdHJ1ZWAsIHRoZSBNb25nb0RCIGRyaXZlciB3aWxsIHRyeSB0byBmaW5kIGEgc2VydmVyIHRvIHNlbmQgYW55IGdpdmVuIG9wZXJhdGlvbiB0bywgYW5kIGtlZXAgcmV0cnlpbmcgZm9yIGBzZXJ2ZXJTZWxlY3Rpb25UaW1lb3V0TVNgIG1pbGxpc2Vjb25kcyBiZWZvcmUgZXJyb3Jpbmcgb3V0LiBJZiBub3Qgc2V0LCB0aGUgTW9uZ29EQiBkcml2ZXIgZGVmYXVsdHMgdG8gdXNpbmcgYDMwMDAwYCAoMzAgc2Vjb25kcykuXG4gKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMuaGVhcnRiZWF0RnJlcXVlbmN5TVNdIElmIGB1c2VVbmlmaWVkVG9wb2xvZ3kgPSB0cnVlYCwgdGhlIE1vbmdvREIgZHJpdmVyIHNlbmRzIGEgaGVhcnRiZWF0IGV2ZXJ5IGBoZWFydGJlYXRGcmVxdWVuY3lNU2AgdG8gY2hlY2sgb24gdGhlIHN0YXR1cyBvZiB0aGUgY29ubmVjdGlvbi4gQSBoZWFydGJlYXQgaXMgc3ViamVjdCB0byBgc2VydmVyU2VsZWN0aW9uVGltZW91dE1TYCwgc28gdGhlIE1vbmdvREIgZHJpdmVyIHdpbGwgcmV0cnkgZmFpbGVkIGhlYXJ0YmVhdHMgZm9yIHVwIHRvIDMwIHNlY29uZHMgYnkgZGVmYXVsdC4gTW9uZ29vc2Ugb25seSBlbWl0cyBhIGAnZGlzY29ubmVjdGVkJ2AgZXZlbnQgYWZ0ZXIgYSBoZWFydGJlYXQgaGFzIGZhaWxlZCwgc28geW91IG1heSB3YW50IHRvIGRlY3JlYXNlIHRoaXMgc2V0dGluZyB0byByZWR1Y2UgdGhlIHRpbWUgYmV0d2VlbiB3aGVuIHlvdXIgc2VydmVyIGdvZXMgZG93biBhbmQgd2hlbiBNb25nb29zZSBlbWl0cyBgJ2Rpc2Nvbm5lY3RlZCdgLiBXZSByZWNvbW1lbmQgeW91IGRvICoqbm90Kiogc2V0IHRoaXMgc2V0dGluZyBiZWxvdyAxMDAwLCB0b28gbWFueSBoZWFydGJlYXRzIGNhbiBsZWFkIHRvIHBlcmZvcm1hbmNlIGRlZ3JhZGF0aW9uLlxuICogQHBhcmFtIHtCb29sZWFufSBbb3B0aW9ucy5hdXRvSW5kZXg9dHJ1ZV0gTW9uZ29vc2Utc3BlY2lmaWMgb3B0aW9uLiBTZXQgdG8gZmFsc2UgdG8gZGlzYWJsZSBhdXRvbWF0aWMgaW5kZXggY3JlYXRpb24gZm9yIGFsbCBtb2RlbHMgYXNzb2NpYXRlZCB3aXRoIHRoaXMgY29ubmVjdGlvbi5cbiAqIEBwYXJhbSB7Q2xhc3N9IFtvcHRpb25zLnByb21pc2VMaWJyYXJ5XSBTZXRzIHRoZSBbdW5kZXJseWluZyBkcml2ZXIncyBwcm9taXNlIGxpYnJhcnldKGh0dHBzOi8vbW9uZ29kYi5naXRodWIuaW8vbm9kZS1tb25nb2RiLW5hdGl2ZS80LjkvaW50ZXJmYWNlcy9Nb25nb0NsaWVudE9wdGlvbnMuaHRtbCNwcm9taXNlTGlicmFyeSkuXG4gKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMuc29ja2V0VGltZW91dE1TPTBdIEhvdyBsb25nIHRoZSBNb25nb0RCIGRyaXZlciB3aWxsIHdhaXQgYmVmb3JlIGtpbGxpbmcgYSBzb2NrZXQgZHVlIHRvIGluYWN0aXZpdHkgX2FmdGVyIGluaXRpYWwgY29ubmVjdGlvbl8uIEEgc29ja2V0IG1heSBiZSBpbmFjdGl2ZSBiZWNhdXNlIG9mIGVpdGhlciBubyBhY3Rpdml0eSBvciBhIGxvbmctcnVubmluZyBvcGVyYXRpb24uIGBzb2NrZXRUaW1lb3V0TVNgIGRlZmF1bHRzIHRvIDAsIHdoaWNoIG1lYW5zIE5vZGUuanMgd2lsbCBub3QgdGltZSBvdXQgdGhlIHNvY2tldCBkdWUgdG8gaW5hY3Rpdml0eS4gVGhpcyBvcHRpb24gaXMgcGFzc2VkIHRvIFtOb2RlLmpzIGBzb2NrZXQjc2V0VGltZW91dCgpYCBmdW5jdGlvbl0oaHR0cHM6Ly9ub2RlanMub3JnL2FwaS9uZXQuaHRtbCNuZXRfc29ja2V0X3NldHRpbWVvdXRfdGltZW91dF9jYWxsYmFjaykgYWZ0ZXIgdGhlIE1vbmdvREIgZHJpdmVyIHN1Y2Nlc3NmdWxseSBjb21wbGV0ZXMuXG4gKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMuZmFtaWx5PTBdIFBhc3NlZCB0cmFuc3BhcmVudGx5IHRvIFtOb2RlLmpzJyBgZG5zLmxvb2t1cCgpYF0oaHR0cHM6Ly9ub2RlanMub3JnL2FwaS9kbnMuaHRtbCNkbnNfZG5zX2xvb2t1cF9ob3N0bmFtZV9vcHRpb25zX2NhbGxiYWNrKSBmdW5jdGlvbi4gTWF5IGJlIGVpdGhlciBgMGAsIGA0YCwgb3IgYDZgLiBgNGAgbWVhbnMgdXNlIElQdjQgb25seSwgYDZgIG1lYW5zIHVzZSBJUHY2IG9ubHksIGAwYCBtZWFucyB0cnkgYm90aC5cbiAqIEBwYXJhbSB7Qm9vbGVhbn0gW29wdGlvbnMuYXV0b0NyZWF0ZT1mYWxzZV0gU2V0IHRvIGB0cnVlYCB0byBtYWtlIE1vbmdvb3NlIGF1dG9tYXRpY2FsbHkgY2FsbCBgY3JlYXRlQ29sbGVjdGlvbigpYCBvbiBldmVyeSBtb2RlbCBjcmVhdGVkIG9uIHRoaXMgY29ubmVjdGlvbi5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtjYWxsYmFja11cbiAqIEBzZWUgTW9uZ29vc2UjY3JlYXRlQ29ubmVjdGlvbiBodHRwczovL21vbmdvb3NlanMuY29tL2RvY3MvYXBpL21vbmdvb3NlLmh0bWwjTW9uZ29vc2UucHJvdG90eXBlLmNyZWF0ZUNvbm5lY3Rpb24oKVxuICogQGFwaSBwdWJsaWNcbiAqIEByZXR1cm4ge1Byb21pc2V9IHJlc29sdmVzIHRvIGB0aGlzYCBpZiBjb25uZWN0aW9uIHN1Y2NlZWRlZFxuICovXG5cbk1vbmdvb3NlLnByb3RvdHlwZS5jb25uZWN0ID0gYXN5bmMgZnVuY3Rpb24gY29ubmVjdCh1cmksIG9wdGlvbnMpIHtcbiAgaWYgKHR5cGVvZiBvcHRpb25zID09PSAnZnVuY3Rpb24nIHx8IChhcmd1bWVudHMubGVuZ3RoID49IDMgJiYgdHlwZW9mIGFyZ3VtZW50c1syXSA9PT0gJ2Z1bmN0aW9uJykpIHtcbiAgICB0aHJvdyBuZXcgTW9uZ29vc2VFcnJvcignTW9uZ29vc2UucHJvdG90eXBlLmNvbm5lY3QoKSBubyBsb25nZXIgYWNjZXB0cyBhIGNhbGxiYWNrJyk7XG4gIH1cblxuICBjb25zdCBfbW9uZ29vc2UgPSB0aGlzIGluc3RhbmNlb2YgTW9uZ29vc2UgPyB0aGlzIDogbW9uZ29vc2U7XG4gIGNvbnN0IGNvbm4gPSBfbW9uZ29vc2UuY29ubmVjdGlvbjtcblxuICByZXR1cm4gY29ubi5vcGVuVXJpKHVyaSwgb3B0aW9ucykudGhlbigoKSA9PiBfbW9uZ29vc2UpO1xufTtcblxuLyoqXG4gKiBSdW5zIGAuY2xvc2UoKWAgb24gYWxsIGNvbm5lY3Rpb25zIGluIHBhcmFsbGVsLlxuICpcbiAqIEByZXR1cm4ge1Byb21pc2V9IHJlc29sdmVzIHdoZW4gYWxsIGNvbm5lY3Rpb25zIGFyZSBjbG9zZWQsIG9yIHJlamVjdHMgd2l0aCB0aGUgZmlyc3QgZXJyb3IgdGhhdCBvY2N1cnJlZC5cbiAqIEBhcGkgcHVibGljXG4gKi9cblxuTW9uZ29vc2UucHJvdG90eXBlLmRpc2Nvbm5lY3QgPSBhc3luYyBmdW5jdGlvbiBkaXNjb25uZWN0KCkge1xuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA+PSAxICYmIHR5cGVvZiBhcmd1bWVudHNbMF0gPT09ICdmdW5jdGlvbicpIHtcbiAgICB0aHJvdyBuZXcgTW9uZ29vc2VFcnJvcignTW9uZ29vc2UucHJvdG90eXBlLmRpc2Nvbm5lY3QoKSBubyBsb25nZXIgYWNjZXB0cyBhIGNhbGxiYWNrJyk7XG4gIH1cblxuICBjb25zdCBfbW9uZ29vc2UgPSB0aGlzIGluc3RhbmNlb2YgTW9uZ29vc2UgPyB0aGlzIDogbW9uZ29vc2U7XG5cbiAgY29uc3QgcmVtYWluaW5nID0gX21vbmdvb3NlLmNvbm5lY3Rpb25zLmxlbmd0aDtcbiAgaWYgKHJlbWFpbmluZyA8PSAwKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGF3YWl0IFByb21pc2UuYWxsKF9tb25nb29zZS5jb25uZWN0aW9ucy5tYXAoY29ubiA9PiBjb25uLmNsb3NlKCkpKTtcbn07XG5cbi8qKlxuICogX1JlcXVpcmVzIE1vbmdvREIgPj0gMy42LjAuXyBTdGFydHMgYSBbTW9uZ29EQiBzZXNzaW9uXShodHRwczovL3d3dy5tb25nb2RiLmNvbS9kb2NzL21hbnVhbC9yZWxlYXNlLW5vdGVzLzMuNi8jY2xpZW50LXNlc3Npb25zKVxuICogZm9yIGJlbmVmaXRzIGxpa2UgY2F1c2FsIGNvbnNpc3RlbmN5LCBbcmV0cnlhYmxlIHdyaXRlc10oaHR0cHM6Ly93d3cubW9uZ29kYi5jb20vZG9jcy9tYW51YWwvY29yZS9yZXRyeWFibGUtd3JpdGVzLyksXG4gKiBhbmQgW3RyYW5zYWN0aW9uc10oaHR0cHM6Ly90aGVjb2RlYmFyYmFyaWFuLmNvbS9hLW5vZGUtanMtcGVyc3BlY3RpdmUtb24tbW9uZ29kYi00LXRyYW5zYWN0aW9ucy5odG1sKS5cbiAqXG4gKiBDYWxsaW5nIGBtb25nb29zZS5zdGFydFNlc3Npb24oKWAgaXMgZXF1aXZhbGVudCB0byBjYWxsaW5nIGBtb25nb29zZS5jb25uZWN0aW9uLnN0YXJ0U2Vzc2lvbigpYC5cbiAqIFNlc3Npb25zIGFyZSBzY29wZWQgdG8gYSBjb25uZWN0aW9uLCBzbyBjYWxsaW5nIGBtb25nb29zZS5zdGFydFNlc3Npb24oKWBcbiAqIHN0YXJ0cyBhIHNlc3Npb24gb24gdGhlIFtkZWZhdWx0IG1vbmdvb3NlIGNvbm5lY3Rpb25dKGh0dHBzOi8vbW9uZ29vc2Vqcy5jb20vZG9jcy9hcGkvbW9uZ29vc2UuaHRtbCNNb25nb29zZS5wcm90b3R5cGUuY29ubmVjdGlvbikuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSBzZWUgdGhlIFttb25nb2RiIGRyaXZlciBvcHRpb25zXShodHRwczovL21vbmdvZGIuZ2l0aHViLmlvL25vZGUtbW9uZ29kYi1uYXRpdmUvNC45L2NsYXNzZXMvTW9uZ29DbGllbnQuaHRtbCNzdGFydFNlc3Npb24pXG4gKiBAcGFyYW0ge0Jvb2xlYW59IFtvcHRpb25zLmNhdXNhbENvbnNpc3RlbmN5PXRydWVdIHNldCB0byBmYWxzZSB0byBkaXNhYmxlIGNhdXNhbCBjb25zaXN0ZW5jeVxuICogQHBhcmFtIHtGdW5jdGlvbn0gW2NhbGxiYWNrXVxuICogQHJldHVybiB7UHJvbWlzZTxDbGllbnRTZXNzaW9uPn0gcHJvbWlzZSB0aGF0IHJlc29sdmVzIHRvIGEgTW9uZ29EQiBkcml2ZXIgYENsaWVudFNlc3Npb25gXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbk1vbmdvb3NlLnByb3RvdHlwZS5zdGFydFNlc3Npb24gPSBmdW5jdGlvbigpIHtcbiAgY29uc3QgX21vbmdvb3NlID0gdGhpcyBpbnN0YW5jZW9mIE1vbmdvb3NlID8gdGhpcyA6IG1vbmdvb3NlO1xuXG4gIHJldHVybiBfbW9uZ29vc2UuY29ubmVjdGlvbi5zdGFydFNlc3Npb24uYXBwbHkoX21vbmdvb3NlLmNvbm5lY3Rpb24sIGFyZ3VtZW50cyk7XG59O1xuXG4vKipcbiAqIEdldHRlci9zZXR0ZXIgYXJvdW5kIGZ1bmN0aW9uIGZvciBwbHVyYWxpemluZyBjb2xsZWN0aW9uIG5hbWVzLlxuICpcbiAqIEBwYXJhbSB7RnVuY3Rpb258bnVsbH0gW2ZuXSBvdmVyd3JpdGVzIHRoZSBmdW5jdGlvbiB1c2VkIHRvIHBsdXJhbGl6ZSBjb2xsZWN0aW9uIG5hbWVzXG4gKiBAcmV0dXJuIHtGdW5jdGlvbnxudWxsfSB0aGUgY3VycmVudCBmdW5jdGlvbiB1c2VkIHRvIHBsdXJhbGl6ZSBjb2xsZWN0aW9uIG5hbWVzLCBkZWZhdWx0cyB0byB0aGUgbGVnYWN5IGZ1bmN0aW9uIGZyb20gYG1vbmdvb3NlLWxlZ2FjeS1wbHVyYWxpemVgLlxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5Nb25nb29zZS5wcm90b3R5cGUucGx1cmFsaXplID0gZnVuY3Rpb24oZm4pIHtcbiAgY29uc3QgX21vbmdvb3NlID0gdGhpcyBpbnN0YW5jZW9mIE1vbmdvb3NlID8gdGhpcyA6IG1vbmdvb3NlO1xuXG4gIGlmIChhcmd1bWVudHMubGVuZ3RoID4gMCkge1xuICAgIF9tb25nb29zZS5fcGx1cmFsaXplID0gZm47XG4gIH1cbiAgcmV0dXJuIF9tb25nb29zZS5fcGx1cmFsaXplO1xufTtcblxuLyoqXG4gKiBEZWZpbmVzIGEgbW9kZWwgb3IgcmV0cmlldmVzIGl0LlxuICpcbiAqIE1vZGVscyBkZWZpbmVkIG9uIHRoZSBgbW9uZ29vc2VgIGluc3RhbmNlIGFyZSBhdmFpbGFibGUgdG8gYWxsIGNvbm5lY3Rpb25cbiAqIGNyZWF0ZWQgYnkgdGhlIHNhbWUgYG1vbmdvb3NlYCBpbnN0YW5jZS5cbiAqXG4gKiBJZiB5b3UgY2FsbCBgbW9uZ29vc2UubW9kZWwoKWAgd2l0aCB0d2ljZSB0aGUgc2FtZSBuYW1lIGJ1dCBhIGRpZmZlcmVudCBzY2hlbWEsXG4gKiB5b3Ugd2lsbCBnZXQgYW4gYE92ZXJ3cml0ZU1vZGVsRXJyb3JgLiBJZiB5b3UgY2FsbCBgbW9uZ29vc2UubW9kZWwoKWAgd2l0aFxuICogdGhlIHNhbWUgbmFtZSBhbmQgc2FtZSBzY2hlbWEsIHlvdSdsbCBnZXQgdGhlIHNhbWUgc2NoZW1hIGJhY2suXG4gKlxuICogIyMjIyBFeGFtcGxlOlxuICpcbiAqICAgICBjb25zdCBtb25nb29zZSA9IHJlcXVpcmUoJ21vbmdvb3NlJyk7XG4gKlxuICogICAgIC8vIGRlZmluZSBhbiBBY3RvciBtb2RlbCB3aXRoIHRoaXMgbW9uZ29vc2UgaW5zdGFuY2VcbiAqICAgICBjb25zdCBzY2hlbWEgPSBuZXcgU2NoZW1hKHsgbmFtZTogU3RyaW5nIH0pO1xuICogICAgIG1vbmdvb3NlLm1vZGVsKCdBY3RvcicsIHNjaGVtYSk7XG4gKlxuICogICAgIC8vIGNyZWF0ZSBhIG5ldyBjb25uZWN0aW9uXG4gKiAgICAgY29uc3QgY29ubiA9IG1vbmdvb3NlLmNyZWF0ZUNvbm5lY3Rpb24oLi4pO1xuICpcbiAqICAgICAvLyBjcmVhdGUgQWN0b3IgbW9kZWxcbiAqICAgICBjb25zdCBBY3RvciA9IGNvbm4ubW9kZWwoJ0FjdG9yJywgc2NoZW1hKTtcbiAqICAgICBjb25uLm1vZGVsKCdBY3RvcicpID09PSBBY3RvcjsgLy8gdHJ1ZVxuICogICAgIGNvbm4ubW9kZWwoJ0FjdG9yJywgc2NoZW1hKSA9PT0gQWN0b3I7IC8vIHRydWUsIHNhbWUgc2NoZW1hXG4gKiAgICAgY29ubi5tb2RlbCgnQWN0b3InLCBzY2hlbWEsICdhY3RvcnMnKSA9PT0gQWN0b3I7IC8vIHRydWUsIHNhbWUgc2NoZW1hIGFuZCBjb2xsZWN0aW9uIG5hbWVcbiAqXG4gKiAgICAgLy8gVGhpcyB0aHJvd3MgYW4gYE92ZXJ3cml0ZU1vZGVsRXJyb3JgIGJlY2F1c2UgdGhlIHNjaGVtYSBpcyBkaWZmZXJlbnQuXG4gKiAgICAgY29ubi5tb2RlbCgnQWN0b3InLCBuZXcgU2NoZW1hKHsgbmFtZTogU3RyaW5nIH0pKTtcbiAqXG4gKiBfV2hlbiBubyBgY29sbGVjdGlvbmAgYXJndW1lbnQgaXMgcGFzc2VkLCBNb25nb29zZSB1c2VzIHRoZSBtb2RlbCBuYW1lLiBJZiB5b3UgZG9uJ3QgbGlrZSB0aGlzIGJlaGF2aW9yLCBlaXRoZXIgcGFzcyBhIGNvbGxlY3Rpb24gbmFtZSwgdXNlIGBtb25nb29zZS5wbHVyYWxpemUoKWAsIG9yIHNldCB5b3VyIHNjaGVtYXMgY29sbGVjdGlvbiBuYW1lIG9wdGlvbi5fXG4gKlxuICogIyMjIyBFeGFtcGxlOlxuICpcbiAqICAgICBjb25zdCBzY2hlbWEgPSBuZXcgU2NoZW1hKHsgbmFtZTogU3RyaW5nIH0sIHsgY29sbGVjdGlvbjogJ2FjdG9yJyB9KTtcbiAqXG4gKiAgICAgLy8gb3JcbiAqXG4gKiAgICAgc2NoZW1hLnNldCgnY29sbGVjdGlvbicsICdhY3RvcicpO1xuICpcbiAqICAgICAvLyBvclxuICpcbiAqICAgICBjb25zdCBjb2xsZWN0aW9uTmFtZSA9ICdhY3RvcidcbiAqICAgICBjb25zdCBNID0gbW9uZ29vc2UubW9kZWwoJ0FjdG9yJywgc2NoZW1hLCBjb2xsZWN0aW9uTmFtZSlcbiAqXG4gKiBAcGFyYW0ge1N0cmluZ3xGdW5jdGlvbn0gbmFtZSBtb2RlbCBuYW1lIG9yIGNsYXNzIGV4dGVuZGluZyBNb2RlbFxuICogQHBhcmFtIHtTY2hlbWF9IFtzY2hlbWFdIHRoZSBzY2hlbWEgdG8gdXNlLlxuICogQHBhcmFtIHtTdHJpbmd9IFtjb2xsZWN0aW9uXSBuYW1lIChvcHRpb25hbCwgaW5mZXJyZWQgZnJvbSBtb2RlbCBuYW1lKVxuICogQHJldHVybiB7TW9kZWx9IFRoZSBtb2RlbCBhc3NvY2lhdGVkIHdpdGggYG5hbWVgLiBNb25nb29zZSB3aWxsIGNyZWF0ZSB0aGUgbW9kZWwgaWYgaXQgZG9lc24ndCBhbHJlYWR5IGV4aXN0LlxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5Nb25nb29zZS5wcm90b3R5cGUubW9kZWwgPSBmdW5jdGlvbihuYW1lLCBzY2hlbWEsIGNvbGxlY3Rpb24sIG9wdGlvbnMpIHtcbiAgY29uc3QgX21vbmdvb3NlID0gdGhpcyBpbnN0YW5jZW9mIE1vbmdvb3NlID8gdGhpcyA6IG1vbmdvb3NlO1xuXG4gIGlmICh0eXBlb2Ygc2NoZW1hID09PSAnc3RyaW5nJykge1xuICAgIGNvbGxlY3Rpb24gPSBzY2hlbWE7XG4gICAgc2NoZW1hID0gZmFsc2U7XG4gIH1cblxuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMSkge1xuICAgIGNvbnN0IG1vZGVsID0gX21vbmdvb3NlLm1vZGVsc1tuYW1lXTtcbiAgICBpZiAoIW1vZGVsKSB7XG4gICAgICB0aHJvdyBuZXcgTW9uZ29vc2VFcnJvci5NaXNzaW5nU2NoZW1hRXJyb3IobmFtZSk7XG4gICAgfVxuICAgIHJldHVybiBtb2RlbDtcbiAgfVxuXG4gIGlmICh1dGlscy5pc09iamVjdChzY2hlbWEpICYmICEoc2NoZW1hIGluc3RhbmNlb2YgU2NoZW1hKSkge1xuICAgIHNjaGVtYSA9IG5ldyBTY2hlbWEoc2NoZW1hKTtcbiAgfVxuICBpZiAoc2NoZW1hICYmICEoc2NoZW1hIGluc3RhbmNlb2YgU2NoZW1hKSkge1xuICAgIHRocm93IG5ldyBFcnJvcignVGhlIDJuZCBwYXJhbWV0ZXIgdG8gYG1vbmdvb3NlLm1vZGVsKClgIHNob3VsZCBiZSBhICcgK1xuICAgICAgJ3NjaGVtYSBvciBhIFBPSk8nKTtcbiAgfVxuXG4gIC8vIGhhbmRsZSBpbnRlcm5hbCBvcHRpb25zIGZyb20gY29ubmVjdGlvbi5tb2RlbCgpXG4gIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuXG4gIGNvbnN0IG9yaWdpbmFsU2NoZW1hID0gc2NoZW1hO1xuICBpZiAoc2NoZW1hKSB7XG4gICAgaWYgKF9tb25nb29zZS5nZXQoJ2Nsb25lU2NoZW1hcycpKSB7XG4gICAgICBzY2hlbWEgPSBzY2hlbWEuY2xvbmUoKTtcbiAgICB9XG4gICAgX21vbmdvb3NlLl9hcHBseVBsdWdpbnMoc2NoZW1hKTtcbiAgfVxuXG4gIC8vIGNvbm5lY3Rpb24ubW9kZWwoKSBtYXkgYmUgcGFzc2luZyBhIGRpZmZlcmVudCBzY2hlbWEgZm9yXG4gIC8vIGFuIGV4aXN0aW5nIG1vZGVsIG5hbWUuIGluIHRoaXMgY2FzZSBkb24ndCByZWFkIGZyb20gY2FjaGUuXG4gIGNvbnN0IG92ZXJ3cml0ZU1vZGVscyA9IF9tb25nb29zZS5vcHRpb25zLmhhc093blByb3BlcnR5KCdvdmVyd3JpdGVNb2RlbHMnKSA/XG4gICAgX21vbmdvb3NlLm9wdGlvbnMub3ZlcndyaXRlTW9kZWxzIDpcbiAgICBvcHRpb25zLm92ZXJ3cml0ZU1vZGVscztcbiAgaWYgKF9tb25nb29zZS5tb2RlbHMuaGFzT3duUHJvcGVydHkobmFtZSkgJiYgb3B0aW9ucy5jYWNoZSAhPT0gZmFsc2UgJiYgb3ZlcndyaXRlTW9kZWxzICE9PSB0cnVlKSB7XG4gICAgaWYgKG9yaWdpbmFsU2NoZW1hICYmXG4gICAgICAgIG9yaWdpbmFsU2NoZW1hLmluc3RhbmNlT2ZTY2hlbWEgJiZcbiAgICAgICAgb3JpZ2luYWxTY2hlbWEgIT09IF9tb25nb29zZS5tb2RlbHNbbmFtZV0uc2NoZW1hKSB7XG4gICAgICB0aHJvdyBuZXcgX21vbmdvb3NlLkVycm9yLk92ZXJ3cml0ZU1vZGVsRXJyb3IobmFtZSk7XG4gICAgfVxuICAgIGlmIChjb2xsZWN0aW9uICYmIGNvbGxlY3Rpb24gIT09IF9tb25nb29zZS5tb2RlbHNbbmFtZV0uY29sbGVjdGlvbi5uYW1lKSB7XG4gICAgICAvLyBzdWJjbGFzcyBjdXJyZW50IG1vZGVsIHdpdGggYWx0ZXJuYXRlIGNvbGxlY3Rpb25cbiAgICAgIGNvbnN0IG1vZGVsID0gX21vbmdvb3NlLm1vZGVsc1tuYW1lXTtcbiAgICAgIHNjaGVtYSA9IG1vZGVsLnByb3RvdHlwZS5zY2hlbWE7XG4gICAgICBjb25zdCBzdWIgPSBtb2RlbC5fX3N1YmNsYXNzKF9tb25nb29zZS5jb25uZWN0aW9uLCBzY2hlbWEsIGNvbGxlY3Rpb24pO1xuICAgICAgLy8gZG8gbm90IGNhY2hlIHRoZSBzdWIgbW9kZWxcbiAgICAgIHJldHVybiBzdWI7XG4gICAgfVxuICAgIHJldHVybiBfbW9uZ29vc2UubW9kZWxzW25hbWVdO1xuICB9XG4gIGlmIChzY2hlbWEgPT0gbnVsbCkge1xuICAgIHRocm93IG5ldyBfbW9uZ29vc2UuRXJyb3IuTWlzc2luZ1NjaGVtYUVycm9yKG5hbWUpO1xuICB9XG5cbiAgY29uc3QgbW9kZWwgPSBfbW9uZ29vc2UuX21vZGVsKG5hbWUsIHNjaGVtYSwgY29sbGVjdGlvbiwgb3B0aW9ucyk7XG4gIF9tb25nb29zZS5jb25uZWN0aW9uLm1vZGVsc1tuYW1lXSA9IG1vZGVsO1xuICBfbW9uZ29vc2UubW9kZWxzW25hbWVdID0gbW9kZWw7XG5cbiAgcmV0dXJuIG1vZGVsO1xufTtcblxuLyohXG4gKiBpZ25vcmVcbiAqL1xuXG5Nb25nb29zZS5wcm90b3R5cGUuX21vZGVsID0gZnVuY3Rpb24obmFtZSwgc2NoZW1hLCBjb2xsZWN0aW9uLCBvcHRpb25zKSB7XG4gIGNvbnN0IF9tb25nb29zZSA9IHRoaXMgaW5zdGFuY2VvZiBNb25nb29zZSA/IHRoaXMgOiBtb25nb29zZTtcblxuICBsZXQgbW9kZWw7XG4gIGlmICh0eXBlb2YgbmFtZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIG1vZGVsID0gbmFtZTtcbiAgICBuYW1lID0gbW9kZWwubmFtZTtcbiAgICBpZiAoIShtb2RlbC5wcm90b3R5cGUgaW5zdGFuY2VvZiBNb2RlbCkpIHtcbiAgICAgIHRocm93IG5ldyBfbW9uZ29vc2UuRXJyb3IoJ1RoZSBwcm92aWRlZCBjbGFzcyAnICsgbmFtZSArICcgbXVzdCBleHRlbmQgTW9kZWwnKTtcbiAgICB9XG4gIH1cblxuICBpZiAoc2NoZW1hKSB7XG4gICAgaWYgKF9tb25nb29zZS5nZXQoJ2Nsb25lU2NoZW1hcycpKSB7XG4gICAgICBzY2hlbWEgPSBzY2hlbWEuY2xvbmUoKTtcbiAgICB9XG4gICAgX21vbmdvb3NlLl9hcHBseVBsdWdpbnMoc2NoZW1hKTtcbiAgfVxuXG4gIC8vIEFwcGx5IHJlbGV2YW50IFwiZ2xvYmFsXCIgb3B0aW9ucyB0byB0aGUgc2NoZW1hXG4gIGlmIChzY2hlbWEgPT0gbnVsbCB8fCAhKCdwbHVyYWxpemF0aW9uJyBpbiBzY2hlbWEub3B0aW9ucykpIHtcbiAgICBzY2hlbWEub3B0aW9ucy5wbHVyYWxpemF0aW9uID0gX21vbmdvb3NlLm9wdGlvbnMucGx1cmFsaXphdGlvbjtcbiAgfVxuXG4gIGlmICghY29sbGVjdGlvbikge1xuICAgIGNvbGxlY3Rpb24gPSBzY2hlbWEuZ2V0KCdjb2xsZWN0aW9uJykgfHxcbiAgICAgIHV0aWxzLnRvQ29sbGVjdGlvbk5hbWUobmFtZSwgX21vbmdvb3NlLnBsdXJhbGl6ZSgpKTtcbiAgfVxuXG4gIGNvbnN0IGNvbm5lY3Rpb24gPSBvcHRpb25zLmNvbm5lY3Rpb24gfHwgX21vbmdvb3NlLmNvbm5lY3Rpb247XG4gIG1vZGVsID0gX21vbmdvb3NlLk1vZGVsLmNvbXBpbGUobW9kZWwgfHwgbmFtZSwgc2NoZW1hLCBjb2xsZWN0aW9uLCBjb25uZWN0aW9uLCBfbW9uZ29vc2UpO1xuICAvLyBFcnJvcnMgaGFuZGxlZCBpbnRlcm5hbGx5LCBzbyBzYWZlIHRvIGlnbm9yZSBlcnJvclxuICBtb2RlbC5pbml0KCkuY2F0Y2goZnVuY3Rpb24gJG1vZGVsSW5pdE5vb3AoKSB7fSk7XG5cbiAgY29ubmVjdGlvbi5lbWl0KCdtb2RlbCcsIG1vZGVsKTtcblxuICBpZiAoc2NoZW1hLl9hcHBseURpc2NyaW1pbmF0b3JzICE9IG51bGwpIHtcbiAgICBmb3IgKGNvbnN0IGRpc2Mgb2Ygc2NoZW1hLl9hcHBseURpc2NyaW1pbmF0b3JzLmtleXMoKSkge1xuICAgICAgbW9kZWwuZGlzY3JpbWluYXRvcihkaXNjLCBzY2hlbWEuX2FwcGx5RGlzY3JpbWluYXRvcnMuZ2V0KGRpc2MpKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gbW9kZWw7XG59O1xuXG4vKipcbiAqIFJlbW92ZXMgdGhlIG1vZGVsIG5hbWVkIGBuYW1lYCBmcm9tIHRoZSBkZWZhdWx0IGNvbm5lY3Rpb24sIGlmIGl0IGV4aXN0cy5cbiAqIFlvdSBjYW4gdXNlIHRoaXMgZnVuY3Rpb24gdG8gY2xlYW4gdXAgYW55IG1vZGVscyB5b3UgY3JlYXRlZCBpbiB5b3VyIHRlc3RzIHRvXG4gKiBwcmV2ZW50IE92ZXJ3cml0ZU1vZGVsRXJyb3JzLlxuICpcbiAqIEVxdWl2YWxlbnQgdG8gYG1vbmdvb3NlLmNvbm5lY3Rpb24uZGVsZXRlTW9kZWwobmFtZSlgLlxuICpcbiAqICMjIyMgRXhhbXBsZTpcbiAqXG4gKiAgICAgbW9uZ29vc2UubW9kZWwoJ1VzZXInLCBuZXcgU2NoZW1hKHsgbmFtZTogU3RyaW5nIH0pKTtcbiAqICAgICBjb25zb2xlLmxvZyhtb25nb29zZS5tb2RlbCgnVXNlcicpKTsgLy8gTW9kZWwgb2JqZWN0XG4gKiAgICAgbW9uZ29vc2UuZGVsZXRlTW9kZWwoJ1VzZXInKTtcbiAqICAgICBjb25zb2xlLmxvZyhtb25nb29zZS5tb2RlbCgnVXNlcicpKTsgLy8gdW5kZWZpbmVkXG4gKlxuICogICAgIC8vIFVzdWFsbHkgdXNlZnVsIGluIGEgTW9jaGEgYGFmdGVyRWFjaCgpYCBob29rXG4gKiAgICAgYWZ0ZXJFYWNoKGZ1bmN0aW9uKCkge1xuICogICAgICAgbW9uZ29vc2UuZGVsZXRlTW9kZWwoLy4rLyk7IC8vIERlbGV0ZSBldmVyeSBtb2RlbFxuICogICAgIH0pO1xuICpcbiAqIEBhcGkgcHVibGljXG4gKiBAcGFyYW0ge1N0cmluZ3xSZWdFeHB9IG5hbWUgaWYgc3RyaW5nLCB0aGUgbmFtZSBvZiB0aGUgbW9kZWwgdG8gcmVtb3ZlLiBJZiByZWdleHAsIHJlbW92ZXMgYWxsIG1vZGVscyB3aG9zZSBuYW1lIG1hdGNoZXMgdGhlIHJlZ2V4cC5cbiAqIEByZXR1cm4ge01vbmdvb3NlfSB0aGlzXG4gKi9cblxuTW9uZ29vc2UucHJvdG90eXBlLmRlbGV0ZU1vZGVsID0gZnVuY3Rpb24obmFtZSkge1xuICBjb25zdCBfbW9uZ29vc2UgPSB0aGlzIGluc3RhbmNlb2YgTW9uZ29vc2UgPyB0aGlzIDogbW9uZ29vc2U7XG5cbiAgX21vbmdvb3NlLmNvbm5lY3Rpb24uZGVsZXRlTW9kZWwobmFtZSk7XG4gIGRlbGV0ZSBfbW9uZ29vc2UubW9kZWxzW25hbWVdO1xuICByZXR1cm4gX21vbmdvb3NlO1xufTtcblxuLyoqXG4gKiBSZXR1cm5zIGFuIGFycmF5IG9mIG1vZGVsIG5hbWVzIGNyZWF0ZWQgb24gdGhpcyBpbnN0YW5jZSBvZiBNb25nb29zZS5cbiAqXG4gKiAjIyMjIE5vdGU6XG4gKlxuICogX0RvZXMgbm90IGluY2x1ZGUgbmFtZXMgb2YgbW9kZWxzIGNyZWF0ZWQgdXNpbmcgYGNvbm5lY3Rpb24ubW9kZWwoKWAuX1xuICpcbiAqIEBhcGkgcHVibGljXG4gKiBAcmV0dXJuIHtBcnJheX1cbiAqL1xuXG5Nb25nb29zZS5wcm90b3R5cGUubW9kZWxOYW1lcyA9IGZ1bmN0aW9uKCkge1xuICBjb25zdCBfbW9uZ29vc2UgPSB0aGlzIGluc3RhbmNlb2YgTW9uZ29vc2UgPyB0aGlzIDogbW9uZ29vc2U7XG5cbiAgY29uc3QgbmFtZXMgPSBPYmplY3Qua2V5cyhfbW9uZ29vc2UubW9kZWxzKTtcbiAgcmV0dXJuIG5hbWVzO1xufTtcblxuLyoqXG4gKiBBcHBsaWVzIGdsb2JhbCBwbHVnaW5zIHRvIGBzY2hlbWFgLlxuICpcbiAqIEBwYXJhbSB7U2NoZW1hfSBzY2hlbWFcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbk1vbmdvb3NlLnByb3RvdHlwZS5fYXBwbHlQbHVnaW5zID0gZnVuY3Rpb24oc2NoZW1hLCBvcHRpb25zKSB7XG4gIGNvbnN0IF9tb25nb29zZSA9IHRoaXMgaW5zdGFuY2VvZiBNb25nb29zZSA/IHRoaXMgOiBtb25nb29zZTtcblxuICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgb3B0aW9ucy5hcHBseVBsdWdpbnNUb0Rpc2NyaW1pbmF0b3JzID0gX21vbmdvb3NlLm9wdGlvbnMgJiYgX21vbmdvb3NlLm9wdGlvbnMuYXBwbHlQbHVnaW5zVG9EaXNjcmltaW5hdG9ycyB8fCBmYWxzZTtcbiAgb3B0aW9ucy5hcHBseVBsdWdpbnNUb0NoaWxkU2NoZW1hcyA9IHR5cGVvZiAoX21vbmdvb3NlLm9wdGlvbnMgJiYgX21vbmdvb3NlLm9wdGlvbnMuYXBwbHlQbHVnaW5zVG9DaGlsZFNjaGVtYXMpID09PSAnYm9vbGVhbicgP1xuICAgIF9tb25nb29zZS5vcHRpb25zLmFwcGx5UGx1Z2luc1RvQ2hpbGRTY2hlbWFzIDpcbiAgICB0cnVlO1xuICBhcHBseVBsdWdpbnMoc2NoZW1hLCBfbW9uZ29vc2UucGx1Z2lucywgb3B0aW9ucywgJyRnbG9iYWxQbHVnaW5zQXBwbGllZCcpO1xufTtcblxuLyoqXG4gKiBEZWNsYXJlcyBhIGdsb2JhbCBwbHVnaW4gZXhlY3V0ZWQgb24gYWxsIFNjaGVtYXMuXG4gKlxuICogRXF1aXZhbGVudCB0byBjYWxsaW5nIGAucGx1Z2luKGZuKWAgb24gZWFjaCBTY2hlbWEgeW91IGNyZWF0ZS5cbiAqXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmbiBwbHVnaW4gY2FsbGJhY2tcbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0c10gb3B0aW9uYWwgb3B0aW9uc1xuICogQHJldHVybiB7TW9uZ29vc2V9IHRoaXNcbiAqIEBzZWUgcGx1Z2lucyBodHRwczovL21vbmdvb3NlanMuY29tL2RvY3MvcGx1Z2lucy5odG1sXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbk1vbmdvb3NlLnByb3RvdHlwZS5wbHVnaW4gPSBmdW5jdGlvbihmbiwgb3B0cykge1xuICBjb25zdCBfbW9uZ29vc2UgPSB0aGlzIGluc3RhbmNlb2YgTW9uZ29vc2UgPyB0aGlzIDogbW9uZ29vc2U7XG5cbiAgX21vbmdvb3NlLnBsdWdpbnMucHVzaChbZm4sIG9wdHNdKTtcbiAgcmV0dXJuIF9tb25nb29zZTtcbn07XG5cbi8qKlxuICogVGhlIE1vbmdvb3NlIG1vZHVsZSdzIGRlZmF1bHQgY29ubmVjdGlvbi4gRXF1aXZhbGVudCB0byBgbW9uZ29vc2UuY29ubmVjdGlvbnNbMF1gLCBzZWUgW2Bjb25uZWN0aW9uc2BdKGh0dHBzOi8vbW9uZ29vc2Vqcy5jb20vZG9jcy9hcGkvbW9uZ29vc2UuaHRtbCNNb25nb29zZS5wcm90b3R5cGUuY29ubmVjdGlvbnMpLlxuICpcbiAqICMjIyMgRXhhbXBsZTpcbiAqXG4gKiAgICAgY29uc3QgbW9uZ29vc2UgPSByZXF1aXJlKCdtb25nb29zZScpO1xuICogICAgIG1vbmdvb3NlLmNvbm5lY3QoLi4uKTtcbiAqICAgICBtb25nb29zZS5jb25uZWN0aW9uLm9uKCdlcnJvcicsIGNiKTtcbiAqXG4gKiBUaGlzIGlzIHRoZSBjb25uZWN0aW9uIHVzZWQgYnkgZGVmYXVsdCBmb3IgZXZlcnkgbW9kZWwgY3JlYXRlZCB1c2luZyBbbW9uZ29vc2UubW9kZWxdKGh0dHBzOi8vbW9uZ29vc2Vqcy5jb20vZG9jcy9hcGkvbW9uZ29vc2UuaHRtbCNNb25nb29zZS5wcm90b3R5cGUubW9kZWwoKSkuXG4gKlxuICogVG8gY3JlYXRlIGEgbmV3IGNvbm5lY3Rpb24sIHVzZSBbYGNyZWF0ZUNvbm5lY3Rpb24oKWBdKGh0dHBzOi8vbW9uZ29vc2Vqcy5jb20vZG9jcy9hcGkvbW9uZ29vc2UuaHRtbCNNb25nb29zZS5wcm90b3R5cGUuY3JlYXRlQ29ubmVjdGlvbigpKS5cbiAqXG4gKiBAbWVtYmVyT2YgTW9uZ29vc2VcbiAqIEBpbnN0YW5jZVxuICogQHByb3BlcnR5IHtDb25uZWN0aW9ufSBjb25uZWN0aW9uXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbk1vbmdvb3NlLnByb3RvdHlwZS5fX2RlZmluZUdldHRlcl9fKCdjb25uZWN0aW9uJywgZnVuY3Rpb24oKSB7XG4gIHJldHVybiB0aGlzLmNvbm5lY3Rpb25zWzBdO1xufSk7XG5cbk1vbmdvb3NlLnByb3RvdHlwZS5fX2RlZmluZVNldHRlcl9fKCdjb25uZWN0aW9uJywgZnVuY3Rpb24odikge1xuICBpZiAodiBpbnN0YW5jZW9mIHRoaXMuX19kcml2ZXIuQ29ubmVjdGlvbikge1xuICAgIHRoaXMuY29ubmVjdGlvbnNbMF0gPSB2O1xuICAgIHRoaXMubW9kZWxzID0gdi5tb2RlbHM7XG4gIH1cbn0pO1xuXG4vKipcbiAqIEFuIGFycmF5IGNvbnRhaW5pbmcgYWxsIFtjb25uZWN0aW9uc10oY29ubmVjdGlvbi5odG1sKSBhc3NvY2lhdGVkIHdpdGggdGhpc1xuICogTW9uZ29vc2UgaW5zdGFuY2UuIEJ5IGRlZmF1bHQsIHRoZXJlIGlzIDEgY29ubmVjdGlvbi4gQ2FsbGluZ1xuICogW2BjcmVhdGVDb25uZWN0aW9uKClgXShodHRwczovL21vbmdvb3NlanMuY29tL2RvY3MvYXBpL21vbmdvb3NlLmh0bWwjTW9uZ29vc2UucHJvdG90eXBlLmNyZWF0ZUNvbm5lY3Rpb24oKSkgYWRkcyBhIGNvbm5lY3Rpb25cbiAqIHRvIHRoaXMgYXJyYXkuXG4gKlxuICogIyMjIyBFeGFtcGxlOlxuICpcbiAqICAgICBjb25zdCBtb25nb29zZSA9IHJlcXVpcmUoJ21vbmdvb3NlJyk7XG4gKiAgICAgbW9uZ29vc2UuY29ubmVjdGlvbnMubGVuZ3RoOyAvLyAxLCBqdXN0IHRoZSBkZWZhdWx0IGNvbm5lY3Rpb25cbiAqICAgICBtb25nb29zZS5jb25uZWN0aW9uc1swXSA9PT0gbW9uZ29vc2UuY29ubmVjdGlvbjsgLy8gdHJ1ZVxuICpcbiAqICAgICBtb25nb29zZS5jcmVhdGVDb25uZWN0aW9uKCdtb25nb2RiOi8vMTI3LjAuMC4xOjI3MDE3L3Rlc3QnKTtcbiAqICAgICBtb25nb29zZS5jb25uZWN0aW9ucy5sZW5ndGg7IC8vIDJcbiAqXG4gKiBAbWVtYmVyT2YgTW9uZ29vc2VcbiAqIEBpbnN0YW5jZVxuICogQHByb3BlcnR5IHtBcnJheX0gY29ubmVjdGlvbnNcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuTW9uZ29vc2UucHJvdG90eXBlLmNvbm5lY3Rpb25zO1xuXG4vKipcbiAqIEFuIGludGVnZXIgY29udGFpbmluZyB0aGUgdmFsdWUgb2YgdGhlIG5leHQgY29ubmVjdGlvbiBpZC4gQ2FsbGluZ1xuICogW2BjcmVhdGVDb25uZWN0aW9uKClgXShodHRwczovL21vbmdvb3NlanMuY29tL2RvY3MvYXBpL21vbmdvb3NlLmh0bWwjTW9uZ29vc2UucHJvdG90eXBlLmNyZWF0ZUNvbm5lY3Rpb24oKSkgaW5jcmVtZW50c1xuICogdGhpcyB2YWx1ZS5cbiAqXG4gKiAjIyMjIEV4YW1wbGU6XG4gKlxuICogICAgIGNvbnN0IG1vbmdvb3NlID0gcmVxdWlyZSgnbW9uZ29vc2UnKTtcbiAqICAgICBtb25nb29zZS5jcmVhdGVDb25uZWN0aW9uKCk7IC8vIGlkIGAwYCwgYG5leHRDb25uZWN0aW9uSWRgIGJlY29tZXMgYDFgXG4gKiAgICAgbW9uZ29vc2UuY3JlYXRlQ29ubmVjdGlvbigpOyAvLyBpZCBgMWAsIGBuZXh0Q29ubmVjdGlvbklkYCBiZWNvbWVzIGAyYFxuICogICAgIG1vbmdvb3NlLmNvbm5lY3Rpb25zWzBdLmRlc3Ryb3koKSAvLyBSZW1vdmVzIGNvbm5lY3Rpb24gd2l0aCBpZCBgMGBcbiAqICAgICBtb25nb29zZS5jcmVhdGVDb25uZWN0aW9uKCk7IC8vIGlkIGAyYCwgYG5leHRDb25uZWN0aW9uSWRgIGJlY29tZXMgYDNgXG4gKlxuICogQG1lbWJlck9mIE1vbmdvb3NlXG4gKiBAaW5zdGFuY2VcbiAqIEBwcm9wZXJ0eSB7TnVtYmVyfSBuZXh0Q29ubmVjdGlvbklkXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5Nb25nb29zZS5wcm90b3R5cGUubmV4dENvbm5lY3Rpb25JZDtcblxuLyoqXG4gKiBUaGUgTW9uZ29vc2UgQWdncmVnYXRlIGNvbnN0cnVjdG9yXG4gKlxuICogQG1ldGhvZCBBZ2dyZWdhdGVcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuTW9uZ29vc2UucHJvdG90eXBlLkFnZ3JlZ2F0ZSA9IEFnZ3JlZ2F0ZTtcblxuLyoqXG4gKiBUaGUgTW9uZ29vc2UgQ29sbGVjdGlvbiBjb25zdHJ1Y3RvclxuICpcbiAqIEBtZW1iZXJPZiBNb25nb29zZVxuICogQGluc3RhbmNlXG4gKiBAbWV0aG9kIENvbGxlY3Rpb25cbiAqIEBhcGkgcHVibGljXG4gKi9cblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KE1vbmdvb3NlLnByb3RvdHlwZSwgJ0NvbGxlY3Rpb24nLCB7XG4gIGdldDogZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMuX19kcml2ZXIuQ29sbGVjdGlvbjtcbiAgfSxcbiAgc2V0OiBmdW5jdGlvbihDb2xsZWN0aW9uKSB7XG4gICAgdGhpcy5fX2RyaXZlci5Db2xsZWN0aW9uID0gQ29sbGVjdGlvbjtcbiAgfVxufSk7XG5cbi8qKlxuICogVGhlIE1vbmdvb3NlIFtDb25uZWN0aW9uXShodHRwczovL21vbmdvb3NlanMuY29tL2RvY3MvYXBpL2Nvbm5lY3Rpb24uaHRtbCNDb25uZWN0aW9uKCkpIGNvbnN0cnVjdG9yXG4gKlxuICogQG1lbWJlck9mIE1vbmdvb3NlXG4gKiBAaW5zdGFuY2VcbiAqIEBtZXRob2QgQ29ubmVjdGlvblxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoTW9uZ29vc2UucHJvdG90eXBlLCAnQ29ubmVjdGlvbicsIHtcbiAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy5fX2RyaXZlci5Db25uZWN0aW9uO1xuICB9LFxuICBzZXQ6IGZ1bmN0aW9uKENvbm5lY3Rpb24pIHtcbiAgICBpZiAoQ29ubmVjdGlvbiA9PT0gdGhpcy5fX2RyaXZlci5Db25uZWN0aW9uKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdGhpcy5fX2RyaXZlci5Db25uZWN0aW9uID0gQ29ubmVjdGlvbjtcbiAgfVxufSk7XG5cbi8qKlxuICogVGhlIE1vbmdvb3NlIHZlcnNpb25cbiAqXG4gKiAjIyMjIEV4YW1wbGU6XG4gKlxuICogICAgIGNvbnNvbGUubG9nKG1vbmdvb3NlLnZlcnNpb24pOyAvLyAnNS54LngnXG4gKlxuICogQHByb3BlcnR5IHZlcnNpb25cbiAqIEBhcGkgcHVibGljXG4gKi9cblxuTW9uZ29vc2UucHJvdG90eXBlLnZlcnNpb24gPSBwa2cudmVyc2lvbjtcblxuLyoqXG4gKiBUaGUgTW9uZ29vc2UgY29uc3RydWN0b3JcbiAqXG4gKiBUaGUgZXhwb3J0cyBvZiB0aGUgbW9uZ29vc2UgbW9kdWxlIGlzIGFuIGluc3RhbmNlIG9mIHRoaXMgY2xhc3MuXG4gKlxuICogIyMjIyBFeGFtcGxlOlxuICpcbiAqICAgICBjb25zdCBtb25nb29zZSA9IHJlcXVpcmUoJ21vbmdvb3NlJyk7XG4gKiAgICAgY29uc3QgbW9uZ29vc2UyID0gbmV3IG1vbmdvb3NlLk1vbmdvb3NlKCk7XG4gKlxuICogQG1ldGhvZCBNb25nb29zZVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5Nb25nb29zZS5wcm90b3R5cGUuTW9uZ29vc2UgPSBNb25nb29zZTtcblxuLyoqXG4gKiBUaGUgTW9uZ29vc2UgW1NjaGVtYV0oaHR0cHM6Ly9tb25nb29zZWpzLmNvbS9kb2NzL2FwaS9zY2hlbWEuaHRtbCNTY2hlbWEoKSkgY29uc3RydWN0b3JcbiAqXG4gKiAjIyMjIEV4YW1wbGU6XG4gKlxuICogICAgIGNvbnN0IG1vbmdvb3NlID0gcmVxdWlyZSgnbW9uZ29vc2UnKTtcbiAqICAgICBjb25zdCBTY2hlbWEgPSBtb25nb29zZS5TY2hlbWE7XG4gKiAgICAgY29uc3QgQ2F0U2NoZW1hID0gbmV3IFNjaGVtYSguLik7XG4gKlxuICogQG1ldGhvZCBTY2hlbWFcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuTW9uZ29vc2UucHJvdG90eXBlLlNjaGVtYSA9IFNjaGVtYTtcblxuLyoqXG4gKiBUaGUgTW9uZ29vc2UgW1NjaGVtYVR5cGVdKGh0dHBzOi8vbW9uZ29vc2Vqcy5jb20vZG9jcy9hcGkvc2NoZW1hdHlwZS5odG1sI1NjaGVtYVR5cGUoKSkgY29uc3RydWN0b3JcbiAqXG4gKiBAbWV0aG9kIFNjaGVtYVR5cGVcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuTW9uZ29vc2UucHJvdG90eXBlLlNjaGVtYVR5cGUgPSBTY2hlbWFUeXBlO1xuXG4vKipcbiAqIFRoZSB2YXJpb3VzIE1vbmdvb3NlIFNjaGVtYVR5cGVzLlxuICpcbiAqICMjIyMgTm90ZTpcbiAqXG4gKiBfQWxpYXMgb2YgbW9uZ29vc2UuU2NoZW1hLlR5cGVzIGZvciBiYWNrd2FyZHMgY29tcGF0aWJpbGl0eS5fXG4gKlxuICogQHByb3BlcnR5IFNjaGVtYVR5cGVzXG4gKiBAc2VlIFNjaGVtYS5TY2hlbWFUeXBlcyBodHRwczovL21vbmdvb3NlanMuY29tL2RvY3Mvc2NoZW1hdHlwZXMuaHRtbFxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5Nb25nb29zZS5wcm90b3R5cGUuU2NoZW1hVHlwZXMgPSBTY2hlbWEuVHlwZXM7XG5cbi8qKlxuICogVGhlIE1vbmdvb3NlIFtWaXJ0dWFsVHlwZV0oaHR0cHM6Ly9tb25nb29zZWpzLmNvbS9kb2NzL2FwaS92aXJ0dWFsdHlwZS5odG1sI1ZpcnR1YWxUeXBlKCkpIGNvbnN0cnVjdG9yXG4gKlxuICogQG1ldGhvZCBWaXJ0dWFsVHlwZVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5Nb25nb29zZS5wcm90b3R5cGUuVmlydHVhbFR5cGUgPSBWaXJ0dWFsVHlwZTtcblxuLyoqXG4gKiBUaGUgdmFyaW91cyBNb25nb29zZSBUeXBlcy5cbiAqXG4gKiAjIyMjIEV4YW1wbGU6XG4gKlxuICogICAgIGNvbnN0IG1vbmdvb3NlID0gcmVxdWlyZSgnbW9uZ29vc2UnKTtcbiAqICAgICBjb25zdCBhcnJheSA9IG1vbmdvb3NlLlR5cGVzLkFycmF5O1xuICpcbiAqICMjIyMgVHlwZXM6XG4gKlxuICogLSBbQXJyYXldKGh0dHBzOi8vbW9uZ29vc2Vqcy5jb20vZG9jcy9zY2hlbWF0eXBlcy5odG1sI2FycmF5cylcbiAqIC0gW0J1ZmZlcl0oaHR0cHM6Ly9tb25nb29zZWpzLmNvbS9kb2NzL3NjaGVtYXR5cGVzLmh0bWwjYnVmZmVycylcbiAqIC0gW0VtYmVkZGVkXShodHRwczovL21vbmdvb3NlanMuY29tL2RvY3Mvc2NoZW1hdHlwZXMuaHRtbCNzY2hlbWFzKVxuICogLSBbRG9jdW1lbnRBcnJheV0oaHR0cHM6Ly9tb25nb29zZWpzLmNvbS9kb2NzL2FwaS9kb2N1bWVudGFycmF5cGF0aC5odG1sKVxuICogLSBbRGVjaW1hbDEyOF0oaHR0cHM6Ly9tb25nb29zZWpzLmNvbS9kb2NzL2FwaS9tb25nb29zZS5odG1sI01vbmdvb3NlLnByb3RvdHlwZS5EZWNpbWFsMTI4KVxuICogLSBbT2JqZWN0SWRdKGh0dHBzOi8vbW9uZ29vc2Vqcy5jb20vZG9jcy9zY2hlbWF0eXBlcy5odG1sI29iamVjdGlkcylcbiAqIC0gW01hcF0oaHR0cHM6Ly9tb25nb29zZWpzLmNvbS9kb2NzL3NjaGVtYXR5cGVzLmh0bWwjbWFwcylcbiAqIC0gW1N1YmRvY3VtZW50XShodHRwczovL21vbmdvb3NlanMuY29tL2RvY3Mvc2NoZW1hdHlwZXMuaHRtbCNzY2hlbWFzKVxuICpcbiAqIFVzaW5nIHRoaXMgZXhwb3NlZCBhY2Nlc3MgdG8gdGhlIGBPYmplY3RJZGAgdHlwZSwgd2UgY2FuIGNvbnN0cnVjdCBpZHMgb24gZGVtYW5kLlxuICpcbiAqICAgICBjb25zdCBPYmplY3RJZCA9IG1vbmdvb3NlLlR5cGVzLk9iamVjdElkO1xuICogICAgIGNvbnN0IGlkMSA9IG5ldyBPYmplY3RJZDtcbiAqXG4gKiBAcHJvcGVydHkgVHlwZXNcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuTW9uZ29vc2UucHJvdG90eXBlLlR5cGVzID0gVHlwZXM7XG5cbi8qKlxuICogVGhlIE1vbmdvb3NlIFtRdWVyeV0oaHR0cHM6Ly9tb25nb29zZWpzLmNvbS9kb2NzL2FwaS9xdWVyeS5odG1sI1F1ZXJ5KCkpIGNvbnN0cnVjdG9yLlxuICpcbiAqIEBtZXRob2QgUXVlcnlcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuTW9uZ29vc2UucHJvdG90eXBlLlF1ZXJ5ID0gUXVlcnk7XG5cbi8qKlxuICogVGhlIE1vbmdvb3NlIFtNb2RlbF0oaHR0cHM6Ly9tb25nb29zZWpzLmNvbS9kb2NzL2FwaS9tb2RlbC5odG1sI01vZGVsKCkpIGNvbnN0cnVjdG9yLlxuICpcbiAqIEBtZXRob2QgTW9kZWxcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuTW9uZ29vc2UucHJvdG90eXBlLk1vZGVsID0gTW9kZWw7XG5cbi8qKlxuICogVGhlIE1vbmdvb3NlIFtEb2N1bWVudF0oaHR0cHM6Ly9tb25nb29zZWpzLmNvbS9kb2NzL2FwaS9kb2N1bWVudC5odG1sI0RvY3VtZW50KCkpIGNvbnN0cnVjdG9yLlxuICpcbiAqIEBtZXRob2QgRG9jdW1lbnRcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuTW9uZ29vc2UucHJvdG90eXBlLkRvY3VtZW50ID0gRG9jdW1lbnQ7XG5cbi8qKlxuICogVGhlIE1vbmdvb3NlIERvY3VtZW50UHJvdmlkZXIgY29uc3RydWN0b3IuIE1vbmdvb3NlIHVzZXJzIHNob3VsZCBub3QgaGF2ZSB0b1xuICogdXNlIHRoaXMgZGlyZWN0bHlcbiAqXG4gKiBAbWV0aG9kIERvY3VtZW50UHJvdmlkZXJcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuTW9uZ29vc2UucHJvdG90eXBlLkRvY3VtZW50UHJvdmlkZXIgPSByZXF1aXJlKCcuL2RvY3VtZW50UHJvdmlkZXInKTtcblxuLyoqXG4gKiBUaGUgTW9uZ29vc2UgT2JqZWN0SWQgW1NjaGVtYVR5cGVdKGh0dHBzOi8vbW9uZ29vc2Vqcy5jb20vZG9jcy9zY2hlbWF0eXBlcy5odG1sKS4gVXNlZCBmb3JcbiAqIGRlY2xhcmluZyBwYXRocyBpbiB5b3VyIHNjaGVtYSB0aGF0IHNob3VsZCBiZVxuICogW01vbmdvREIgT2JqZWN0SWRzXShodHRwczovL3d3dy5tb25nb2RiLmNvbS9kb2NzL21hbnVhbC9yZWZlcmVuY2UvbWV0aG9kL09iamVjdElkLykuXG4gKiBEbyBub3QgdXNlIHRoaXMgdG8gY3JlYXRlIGEgbmV3IE9iamVjdElkIGluc3RhbmNlLCB1c2UgYG1vbmdvb3NlLlR5cGVzLk9iamVjdElkYFxuICogaW5zdGVhZC5cbiAqXG4gKiAjIyMjIEV4YW1wbGU6XG4gKlxuICogICAgIGNvbnN0IGNoaWxkU2NoZW1hID0gbmV3IFNjaGVtYSh7IHBhcmVudElkOiBtb25nb29zZS5PYmplY3RJZCB9KTtcbiAqXG4gKiBAcHJvcGVydHkgT2JqZWN0SWRcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuTW9uZ29vc2UucHJvdG90eXBlLk9iamVjdElkID0gU2NoZW1hVHlwZXMuT2JqZWN0SWQ7XG5cbi8qKlxuICogUmV0dXJucyB0cnVlIGlmIE1vbmdvb3NlIGNhbiBjYXN0IHRoZSBnaXZlbiB2YWx1ZSB0byBhbiBPYmplY3RJZCwgb3JcbiAqIGZhbHNlIG90aGVyd2lzZS5cbiAqXG4gKiAjIyMjIEV4YW1wbGU6XG4gKlxuICogICAgIG1vbmdvb3NlLmlzVmFsaWRPYmplY3RJZChuZXcgbW9uZ29vc2UuVHlwZXMuT2JqZWN0SWQoKSk7IC8vIHRydWVcbiAqICAgICBtb25nb29zZS5pc1ZhbGlkT2JqZWN0SWQoJzAxMjM0NTY3ODlhYicpOyAvLyB0cnVlXG4gKiAgICAgbW9uZ29vc2UuaXNWYWxpZE9iamVjdElkKDYpOyAvLyB0cnVlXG4gKiAgICAgbW9uZ29vc2UuaXNWYWxpZE9iamVjdElkKG5ldyBVc2VyKHsgbmFtZTogJ3Rlc3QnIH0pKTsgLy8gdHJ1ZVxuICpcbiAqICAgICBtb25nb29zZS5pc1ZhbGlkT2JqZWN0SWQoeyB0ZXN0OiA0MiB9KTsgLy8gZmFsc2VcbiAqXG4gKiBAbWV0aG9kIGlzVmFsaWRPYmplY3RJZFxuICogQHBhcmFtIHtBbnl9IHZcbiAqIEByZXR1cm5zIHtib29sZWFufSB0cnVlIGlmIGB2YCBpcyBzb21ldGhpbmcgTW9uZ29vc2UgY2FuIGNvZXJjZSB0byBhbiBPYmplY3RJZFxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5Nb25nb29zZS5wcm90b3R5cGUuaXNWYWxpZE9iamVjdElkID0gZnVuY3Rpb24odikge1xuICBjb25zdCBfbW9uZ29vc2UgPSB0aGlzIGluc3RhbmNlb2YgTW9uZ29vc2UgPyB0aGlzIDogbW9uZ29vc2U7XG4gIHJldHVybiBfbW9uZ29vc2UuVHlwZXMuT2JqZWN0SWQuaXNWYWxpZCh2KTtcbn07XG5cbi8qKlxuICogUmV0dXJucyB0cnVlIGlmIHRoZSBnaXZlbiB2YWx1ZSBpcyBhIE1vbmdvb3NlIE9iamVjdElkICh1c2luZyBgaW5zdGFuY2VvZmApIG9yIGlmIHRoZVxuICogZ2l2ZW4gdmFsdWUgaXMgYSAyNCBjaGFyYWN0ZXIgaGV4IHN0cmluZywgd2hpY2ggaXMgdGhlIG1vc3QgY29tbW9ubHkgdXNlZCBzdHJpbmcgcmVwcmVzZW50YXRpb25cbiAqIG9mIGFuIE9iamVjdElkLlxuICpcbiAqIFRoaXMgZnVuY3Rpb24gaXMgc2ltaWxhciB0byBgaXNWYWxpZE9iamVjdElkKClgLCBidXQgY29uc2lkZXJhYmx5IG1vcmUgc3RyaWN0LCBiZWNhdXNlXG4gKiBgaXNWYWxpZE9iamVjdElkKClgIHdpbGwgcmV0dXJuIGB0cnVlYCBmb3IgX2FueV8gdmFsdWUgdGhhdCBNb25nb29zZSBjYW4gY29udmVydCB0byBhblxuICogT2JqZWN0SWQuIFRoYXQgaW5jbHVkZXMgTW9uZ29vc2UgZG9jdW1lbnRzLCBhbnkgc3RyaW5nIG9mIGxlbmd0aCAxMiwgYW5kIGFueSBudW1iZXIuXG4gKiBgaXNPYmplY3RJZE9ySGV4U3RyaW5nKClgIHJldHVybnMgdHJ1ZSBvbmx5IGZvciBgT2JqZWN0SWRgIGluc3RhbmNlcyBvciAyNCBjaGFyYWN0ZXIgaGV4XG4gKiBzdHJpbmdzLCBhbmQgd2lsbCByZXR1cm4gZmFsc2UgZm9yIG51bWJlcnMsIGRvY3VtZW50cywgYW5kIHN0cmluZ3Mgb2YgbGVuZ3RoIDEyLlxuICpcbiAqICMjIyMgRXhhbXBsZTpcbiAqXG4gKiAgICAgbW9uZ29vc2UuaXNPYmplY3RJZE9ySGV4U3RyaW5nKG5ldyBtb25nb29zZS5UeXBlcy5PYmplY3RJZCgpKTsgLy8gdHJ1ZVxuICogICAgIG1vbmdvb3NlLmlzT2JqZWN0SWRPckhleFN0cmluZygnNjIyNjFhNjVkNjZjNmJlMGE2M2MwNTFmJyk7IC8vIHRydWVcbiAqXG4gKiAgICAgbW9uZ29vc2UuaXNPYmplY3RJZE9ySGV4U3RyaW5nKCcwMTIzNDU2Nzg5YWInKTsgLy8gZmFsc2VcbiAqICAgICBtb25nb29zZS5pc09iamVjdElkT3JIZXhTdHJpbmcoNik7IC8vIGZhbHNlXG4gKiAgICAgbW9uZ29vc2UuaXNPYmplY3RJZE9ySGV4U3RyaW5nKG5ldyBVc2VyKHsgbmFtZTogJ3Rlc3QnIH0pKTsgLy8gZmFsc2VcbiAqICAgICBtb25nb29zZS5pc09iamVjdElkT3JIZXhTdHJpbmcoeyB0ZXN0OiA0MiB9KTsgLy8gZmFsc2VcbiAqXG4gKiBAbWV0aG9kIGlzT2JqZWN0SWRPckhleFN0cmluZ1xuICogQHBhcmFtIHtBbnl9IHZcbiAqIEByZXR1cm5zIHtib29sZWFufSB0cnVlIGlmIGB2YCBpcyBhbiBPYmplY3RJZCBpbnN0YW5jZSBfb3JfIGEgMjQgY2hhciBoZXggc3RyaW5nXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbk1vbmdvb3NlLnByb3RvdHlwZS5pc09iamVjdElkT3JIZXhTdHJpbmcgPSBmdW5jdGlvbih2KSB7XG4gIHJldHVybiBpc0Jzb25UeXBlKHYsICdPYmplY3RJZCcpIHx8ICh0eXBlb2YgdiA9PT0gJ3N0cmluZycgJiYgb2JqZWN0SWRIZXhSZWdleHAudGVzdCh2KSk7XG59O1xuXG4vKipcbiAqXG4gKiBTeW5jcyBhbGwgdGhlIGluZGV4ZXMgZm9yIHRoZSBtb2RlbHMgcmVnaXN0ZXJlZCB3aXRoIHRoaXMgY29ubmVjdGlvbi5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xuICogQHBhcmFtIHtCb29sZWFufSBvcHRpb25zLmNvbnRpbnVlT25FcnJvciBgZmFsc2VgIGJ5IGRlZmF1bHQuIElmIHNldCB0byBgdHJ1ZWAsIG1vbmdvb3NlIHdpbGwgbm90IHRocm93IGFuIGVycm9yIGlmIG9uZSBtb2RlbCBzeW5jaW5nIGZhaWxlZCwgYW5kIHdpbGwgcmV0dXJuIGFuIG9iamVjdCB3aGVyZSB0aGUga2V5cyBhcmUgdGhlIG5hbWVzIG9mIHRoZSBtb2RlbHMsIGFuZCB0aGUgdmFsdWVzIGFyZSB0aGUgcmVzdWx0cy9lcnJvcnMgZm9yIGVhY2ggbW9kZWwuXG4gKiBAcmV0dXJuIHtQcm9taXNlfSBSZXR1cm5zIGEgUHJvbWlzZSwgd2hlbiB0aGUgUHJvbWlzZSByZXNvbHZlcyB0aGUgdmFsdWUgaXMgYSBsaXN0IG9mIHRoZSBkcm9wcGVkIGluZGV4ZXMuXG4gKi9cbk1vbmdvb3NlLnByb3RvdHlwZS5zeW5jSW5kZXhlcyA9IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgY29uc3QgX21vbmdvb3NlID0gdGhpcyBpbnN0YW5jZW9mIE1vbmdvb3NlID8gdGhpcyA6IG1vbmdvb3NlO1xuICByZXR1cm4gX21vbmdvb3NlLmNvbm5lY3Rpb24uc3luY0luZGV4ZXMob3B0aW9ucyk7XG59O1xuXG4vKipcbiAqIFRoZSBNb25nb29zZSBEZWNpbWFsMTI4IFtTY2hlbWFUeXBlXShodHRwczovL21vbmdvb3NlanMuY29tL2RvY3Mvc2NoZW1hdHlwZXMuaHRtbCkuIFVzZWQgZm9yXG4gKiBkZWNsYXJpbmcgcGF0aHMgaW4geW91ciBzY2hlbWEgdGhhdCBzaG91bGQgYmVcbiAqIFsxMjgtYml0IGRlY2ltYWwgZmxvYXRpbmcgcG9pbnRzXShodHRwczovL3RoZWNvZGViYXJiYXJpYW4uY29tL2Etbm9kZWpzLXBlcnNwZWN0aXZlLW9uLW1vbmdvZGItMzQtZGVjaW1hbC5odG1sKS5cbiAqIERvIG5vdCB1c2UgdGhpcyB0byBjcmVhdGUgYSBuZXcgRGVjaW1hbDEyOCBpbnN0YW5jZSwgdXNlIGBtb25nb29zZS5UeXBlcy5EZWNpbWFsMTI4YFxuICogaW5zdGVhZC5cbiAqXG4gKiAjIyMjIEV4YW1wbGU6XG4gKlxuICogICAgIGNvbnN0IHZlaGljbGVTY2hlbWEgPSBuZXcgU2NoZW1hKHsgZnVlbExldmVsOiBtb25nb29zZS5EZWNpbWFsMTI4IH0pO1xuICpcbiAqIEBwcm9wZXJ0eSBEZWNpbWFsMTI4XG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbk1vbmdvb3NlLnByb3RvdHlwZS5EZWNpbWFsMTI4ID0gU2NoZW1hVHlwZXMuRGVjaW1hbDEyODtcblxuLyoqXG4gKiBUaGUgTW9uZ29vc2UgTWl4ZWQgW1NjaGVtYVR5cGVdKGh0dHBzOi8vbW9uZ29vc2Vqcy5jb20vZG9jcy9zY2hlbWF0eXBlcy5odG1sKS4gVXNlZCBmb3JcbiAqIGRlY2xhcmluZyBwYXRocyBpbiB5b3VyIHNjaGVtYSB0aGF0IE1vbmdvb3NlJ3MgY2hhbmdlIHRyYWNraW5nLCBjYXN0aW5nLFxuICogYW5kIHZhbGlkYXRpb24gc2hvdWxkIGlnbm9yZS5cbiAqXG4gKiAjIyMjIEV4YW1wbGU6XG4gKlxuICogICAgIGNvbnN0IHNjaGVtYSA9IG5ldyBTY2hlbWEoeyBhcmJpdHJhcnk6IG1vbmdvb3NlLk1peGVkIH0pO1xuICpcbiAqIEBwcm9wZXJ0eSBNaXhlZFxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5Nb25nb29zZS5wcm90b3R5cGUuTWl4ZWQgPSBTY2hlbWFUeXBlcy5NaXhlZDtcblxuLyoqXG4gKiBUaGUgTW9uZ29vc2UgRGF0ZSBbU2NoZW1hVHlwZV0oaHR0cHM6Ly9tb25nb29zZWpzLmNvbS9kb2NzL3NjaGVtYXR5cGVzLmh0bWwpLlxuICpcbiAqICMjIyMgRXhhbXBsZTpcbiAqXG4gKiAgICAgY29uc3Qgc2NoZW1hID0gbmV3IFNjaGVtYSh7IHRlc3Q6IERhdGUgfSk7XG4gKiAgICAgc2NoZW1hLnBhdGgoJ3Rlc3QnKSBpbnN0YW5jZW9mIG1vbmdvb3NlLkRhdGU7IC8vIHRydWVcbiAqXG4gKiBAcHJvcGVydHkgRGF0ZVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5Nb25nb29zZS5wcm90b3R5cGUuRGF0ZSA9IFNjaGVtYVR5cGVzLkRhdGU7XG5cbi8qKlxuICogVGhlIE1vbmdvb3NlIE51bWJlciBbU2NoZW1hVHlwZV0oaHR0cHM6Ly9tb25nb29zZWpzLmNvbS9kb2NzL3NjaGVtYXR5cGVzLmh0bWwpLiBVc2VkIGZvclxuICogZGVjbGFyaW5nIHBhdGhzIGluIHlvdXIgc2NoZW1hIHRoYXQgTW9uZ29vc2Ugc2hvdWxkIGNhc3QgdG8gbnVtYmVycy5cbiAqXG4gKiAjIyMjIEV4YW1wbGU6XG4gKlxuICogICAgIGNvbnN0IHNjaGVtYSA9IG5ldyBTY2hlbWEoeyBudW06IG1vbmdvb3NlLk51bWJlciB9KTtcbiAqICAgICAvLyBFcXVpdmFsZW50IHRvOlxuICogICAgIGNvbnN0IHNjaGVtYSA9IG5ldyBTY2hlbWEoeyBudW06ICdudW1iZXInIH0pO1xuICpcbiAqIEBwcm9wZXJ0eSBOdW1iZXJcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuTW9uZ29vc2UucHJvdG90eXBlLk51bWJlciA9IFNjaGVtYVR5cGVzLk51bWJlcjtcblxuLyoqXG4gKiBUaGUgW01vbmdvb3NlRXJyb3JdKGh0dHBzOi8vbW9uZ29vc2Vqcy5jb20vZG9jcy9hcGkvZXJyb3IuaHRtbCNFcnJvcigpKSBjb25zdHJ1Y3Rvci5cbiAqXG4gKiBAbWV0aG9kIEVycm9yXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbk1vbmdvb3NlLnByb3RvdHlwZS5FcnJvciA9IHJlcXVpcmUoJy4vZXJyb3IvaW5kZXgnKTtcbk1vbmdvb3NlLnByb3RvdHlwZS5Nb25nb29zZUVycm9yID0gcmVxdWlyZSgnLi9lcnJvci9tb25nb29zZUVycm9yJyk7XG5cbi8qKlxuICogTW9uZ29vc2UgdXNlcyB0aGlzIGZ1bmN0aW9uIHRvIGdldCB0aGUgY3VycmVudCB0aW1lIHdoZW4gc2V0dGluZ1xuICogW3RpbWVzdGFtcHNdKGh0dHBzOi8vbW9uZ29vc2Vqcy5jb20vZG9jcy9ndWlkZS5odG1sI3RpbWVzdGFtcHMpLiBZb3UgbWF5IHN0dWIgb3V0IHRoaXMgZnVuY3Rpb25cbiAqIHVzaW5nIGEgdG9vbCBsaWtlIFtTaW5vbl0oaHR0cHM6Ly93d3cubnBtanMuY29tL3BhY2thZ2Uvc2lub24pIGZvciB0ZXN0aW5nLlxuICpcbiAqIEBtZXRob2Qgbm93XG4gKiBAcmV0dXJucyBEYXRlIHRoZSBjdXJyZW50IHRpbWVcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuTW9uZ29vc2UucHJvdG90eXBlLm5vdyA9IGZ1bmN0aW9uIG5vdygpIHsgcmV0dXJuIG5ldyBEYXRlKCk7IH07XG5cbi8qKlxuICogVGhlIE1vbmdvb3NlIENhc3RFcnJvciBjb25zdHJ1Y3RvclxuICpcbiAqIEBtZXRob2QgQ2FzdEVycm9yXG4gKiBAcGFyYW0ge1N0cmluZ30gdHlwZSBUaGUgbmFtZSBvZiB0aGUgdHlwZVxuICogQHBhcmFtIHtBbnl9IHZhbHVlIFRoZSB2YWx1ZSB0aGF0IGZhaWxlZCB0byBjYXN0XG4gKiBAcGFyYW0ge1N0cmluZ30gcGF0aCBUaGUgcGF0aCBgYS5iLmNgIGluIHRoZSBkb2Mgd2hlcmUgdGhpcyBjYXN0IGVycm9yIG9jY3VycmVkXG4gKiBAcGFyYW0ge0Vycm9yfSBbcmVhc29uXSBUaGUgb3JpZ2luYWwgZXJyb3IgdGhhdCB3YXMgdGhyb3duXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbk1vbmdvb3NlLnByb3RvdHlwZS5DYXN0RXJyb3IgPSByZXF1aXJlKCcuL2Vycm9yL2Nhc3QnKTtcblxuLyoqXG4gKiBUaGUgY29uc3RydWN0b3IgdXNlZCBmb3Igc2NoZW1hdHlwZSBvcHRpb25zXG4gKlxuICogQG1ldGhvZCBTY2hlbWFUeXBlT3B0aW9uc1xuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5Nb25nb29zZS5wcm90b3R5cGUuU2NoZW1hVHlwZU9wdGlvbnMgPSByZXF1aXJlKCcuL29wdGlvbnMvc2NoZW1hVHlwZU9wdGlvbnMnKTtcblxuLyoqXG4gKiBUaGUgW21xdWVyeV0oaHR0cHM6Ly9naXRodWIuY29tL2FoZWNrbWFubi9tcXVlcnkpIHF1ZXJ5IGJ1aWxkZXIgTW9uZ29vc2UgdXNlcy5cbiAqXG4gKiBAcHJvcGVydHkgbXF1ZXJ5XG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbk1vbmdvb3NlLnByb3RvdHlwZS5tcXVlcnkgPSByZXF1aXJlKCdtcXVlcnknKTtcblxuLyoqXG4gKiBTYW5pdGl6ZXMgcXVlcnkgZmlsdGVycyBhZ2FpbnN0IFtxdWVyeSBzZWxlY3RvciBpbmplY3Rpb24gYXR0YWNrc10oaHR0cHM6Ly90aGVjb2RlYmFyYmFyaWFuLmNvbS8yMDE0LzA5LzA0L2RlZmVuZGluZy1hZ2FpbnN0LXF1ZXJ5LXNlbGVjdG9yLWluamVjdGlvbi1hdHRhY2tzLmh0bWwpXG4gKiBieSB3cmFwcGluZyBhbnkgbmVzdGVkIG9iamVjdHMgdGhhdCBoYXZlIGEgcHJvcGVydHkgd2hvc2UgbmFtZSBzdGFydHMgd2l0aCBgJGAgaW4gYSBgJGVxYC5cbiAqXG4gKiBgYGBqYXZhc2NyaXB0XG4gKiBjb25zdCBvYmogPSB7IHVzZXJuYW1lOiAndmFsJywgcHdkOiB7ICRuZTogbnVsbCB9IH07XG4gKiBzYW5pdGl6ZUZpbHRlcihvYmopO1xuICogb2JqOyAvLyB7IHVzZXJuYW1lOiAndmFsJywgcHdkOiB7ICRlcTogeyAkbmU6IG51bGwgfSB9IH0pO1xuICogYGBgXG4gKlxuICogQG1ldGhvZCBzYW5pdGl6ZUZpbHRlclxuICogQHBhcmFtIHtPYmplY3R9IGZpbHRlclxuICogQHJldHVybnMgT2JqZWN0IHRoZSBzYW5pdGl6ZWQgb2JqZWN0XG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbk1vbmdvb3NlLnByb3RvdHlwZS5zYW5pdGl6ZUZpbHRlciA9IHNhbml0aXplRmlsdGVyO1xuXG4vKipcbiAqIFRlbGxzIGBzYW5pdGl6ZUZpbHRlcigpYCB0byBza2lwIHRoZSBnaXZlbiBvYmplY3Qgd2hlbiBmaWx0ZXJpbmcgb3V0IHBvdGVudGlhbCBbcXVlcnkgc2VsZWN0b3IgaW5qZWN0aW9uIGF0dGFja3NdKGh0dHBzOi8vdGhlY29kZWJhcmJhcmlhbi5jb20vMjAxNC8wOS8wNC9kZWZlbmRpbmctYWdhaW5zdC1xdWVyeS1zZWxlY3Rvci1pbmplY3Rpb24tYXR0YWNrcy5odG1sKS5cbiAqIFVzZSB0aGlzIG1ldGhvZCB3aGVuIHlvdSBoYXZlIGEga25vd24gcXVlcnkgc2VsZWN0b3IgdGhhdCB5b3Ugd2FudCB0byB1c2UuXG4gKlxuICogYGBgamF2YXNjcmlwdFxuICogY29uc3Qgb2JqID0geyB1c2VybmFtZTogJ3ZhbCcsIHB3ZDogdHJ1c3RlZCh7ICR0eXBlOiAnc3RyaW5nJywgJGVxOiAnbXkgc2VjcmV0JyB9KSB9O1xuICogc2FuaXRpemVGaWx0ZXIob2JqKTtcbiAqXG4gKiAvLyBOb3RlIHRoYXQgYHNhbml0aXplRmlsdGVyKClgIGRpZCBub3QgYWRkIGAkZXFgIGFyb3VuZCBgJHR5cGVgLlxuICogb2JqOyAvLyB7IHVzZXJuYW1lOiAndmFsJywgcHdkOiB7ICR0eXBlOiAnc3RyaW5nJywgJGVxOiAnbXkgc2VjcmV0JyB9IH0pO1xuICogYGBgXG4gKlxuICogQG1ldGhvZCB0cnVzdGVkXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqXG4gKiBAcmV0dXJucyBPYmplY3QgdGhlIHBhc3NlZCBpbiBvYmplY3RcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuTW9uZ29vc2UucHJvdG90eXBlLnRydXN0ZWQgPSB0cnVzdGVkO1xuXG4vKipcbiAqIFVzZSB0aGlzIGZ1bmN0aW9uIGluIGBwcmUoKWAgbWlkZGxld2FyZSB0byBza2lwIGNhbGxpbmcgdGhlIHdyYXBwZWQgZnVuY3Rpb24uXG4gKlxuICogIyMjIyBFeGFtcGxlOlxuICpcbiAqICAgICBzY2hlbWEucHJlKCdzYXZlJywgZnVuY3Rpb24oKSB7XG4gKiAgICAgICAvLyBXaWxsIHNraXAgZXhlY3V0aW5nIGBzYXZlKClgLCBidXQgd2lsbCBleGVjdXRlIHBvc3QgaG9va3MgYXMgaWZcbiAqICAgICAgIC8vIGBzYXZlKClgIGhhZCBleGVjdXRlZCB3aXRoIHRoZSByZXN1bHQgYHsgbWF0Y2hlZENvdW50OiAwIH1gXG4gKiAgICAgICByZXR1cm4gbW9uZ29vc2Uuc2tpcE1pZGRsZXdhcmVGdW5jdGlvbih7IG1hdGNoZWRDb3VudDogMCB9KTtcbiAqICAgICB9KTtcbiAqXG4gKiBAbWV0aG9kIHNraXBNaWRkbGV3YXJlRnVuY3Rpb25cbiAqIEBwYXJhbSB7YW55fSByZXN1bHRcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuTW9uZ29vc2UucHJvdG90eXBlLnNraXBNaWRkbGV3YXJlRnVuY3Rpb24gPSBLYXJlZW0uc2tpcFdyYXBwZWRGdW5jdGlvbjtcblxuLyoqXG4gKiBVc2UgdGhpcyBmdW5jdGlvbiBpbiBgcG9zdCgpYCBtaWRkbGV3YXJlIHRvIHJlcGxhY2UgdGhlIHJlc3VsdFxuICpcbiAqICMjIyMgRXhhbXBsZTpcbiAqXG4gKiAgICAgc2NoZW1hLnBvc3QoJ2ZpbmQnLCBmdW5jdGlvbihyZXMpIHtcbiAqICAgICAgIC8vIE5vcm1hbGx5IHlvdSBoYXZlIHRvIG1vZGlmeSBgcmVzYCBpbiBwbGFjZS4gQnV0IHdpdGhcbiAqICAgICAgIC8vIGBvdmVyd3JpdGVNaWRkbGV3YXJSZXN1bHQoKWAsIHlvdSBjYW4gbWFrZSBgZmluZCgpYCByZXR1cm4gYVxuICogICAgICAgLy8gY29tcGxldGVseSBkaWZmZXJlbnQgdmFsdWUuXG4gKiAgICAgICByZXR1cm4gbW9uZ29vc2Uub3ZlcndyaXRlTWlkZGxld2FyZVJlc3VsdChyZXMuZmlsdGVyKGRvYyA9PiAhZG9jLmlzRGVsZXRlZCkpO1xuICogICAgIH0pO1xuICpcbiAqIEBtZXRob2Qgb3ZlcndyaXRlTWlkZGxld2FyZVJlc3VsdFxuICogQHBhcmFtIHthbnl9IHJlc3VsdFxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5Nb25nb29zZS5wcm90b3R5cGUub3ZlcndyaXRlTWlkZGxld2FyZVJlc3VsdCA9IEthcmVlbS5vdmVyd3JpdGVSZXN1bHQ7XG5cbi8qKlxuICogVGhlIGV4cG9ydHMgb2JqZWN0IGlzIGFuIGluc3RhbmNlIG9mIE1vbmdvb3NlLlxuICpcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmNvbnN0IG1vbmdvb3NlID0gbW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzID0gbmV3IE1vbmdvb3NlKHtcbiAgW2RlZmF1bHRNb25nb29zZVN5bWJvbF06IHRydWVcbn0pO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/mongoose/lib/mongoose.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/mongoose/lib/options.js":
/*!**********************************************!*\
  !*** ./node_modules/mongoose/lib/options.js ***!
  \**********************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\n\n/*!\n * ignore\n */\n\nexports.internalToObjectOptions = {\n  transform: false,\n  virtuals: false,\n  getters: false,\n  _skipDepopulateTopLevel: true,\n  depopulate: true,\n  flattenDecimals: false,\n  useProjection: false\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbW9uZ29vc2UvbGliL29wdGlvbnMuanMiLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWI7QUFDQTtBQUNBOztBQUVBLCtCQUErQjtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vYXBwMS8uL25vZGVfbW9kdWxlcy9tb25nb29zZS9saWIvb3B0aW9ucy5qcz9hOTM0Il0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxuLyohXG4gKiBpZ25vcmVcbiAqL1xuXG5leHBvcnRzLmludGVybmFsVG9PYmplY3RPcHRpb25zID0ge1xuICB0cmFuc2Zvcm06IGZhbHNlLFxuICB2aXJ0dWFsczogZmFsc2UsXG4gIGdldHRlcnM6IGZhbHNlLFxuICBfc2tpcERlcG9wdWxhdGVUb3BMZXZlbDogdHJ1ZSxcbiAgZGVwb3B1bGF0ZTogdHJ1ZSxcbiAgZmxhdHRlbkRlY2ltYWxzOiBmYWxzZSxcbiAgdXNlUHJvamVjdGlvbjogZmFsc2Vcbn07XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/mongoose/lib/options.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/mongoose/lib/options/populateOptions.js":
/*!**************************************************************!*\
  !*** ./node_modules/mongoose/lib/options/populateOptions.js ***!
  \**************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\n\nconst clone = __webpack_require__(/*! ../helpers/clone */ \"(ssr)/./node_modules/mongoose/lib/helpers/clone.js\");\n\nclass PopulateOptions {\n  constructor(obj) {\n    this._docs = {};\n    this._childDocs = [];\n\n    if (obj == null) {\n      return;\n    }\n    obj = clone(obj);\n    Object.assign(this, obj);\n    if (typeof obj.subPopulate === 'object') {\n      this.populate = obj.subPopulate;\n    }\n\n\n    if (obj.perDocumentLimit != null && obj.limit != null) {\n      throw new Error('Can not use `limit` and `perDocumentLimit` at the same time. Path: `' + obj.path + '`.');\n    }\n  }\n}\n\n/**\n * The connection used to look up models by name. If not specified, Mongoose\n * will default to using the connection associated with the model in\n * `PopulateOptions#model`.\n *\n * @memberOf PopulateOptions\n * @property {Connection} connection\n * @api public\n */\n\nmodule.exports = PopulateOptions;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbW9uZ29vc2UvbGliL29wdGlvbnMvcG9wdWxhdGVPcHRpb25zLmpzIiwibWFwcGluZ3MiOiJBQUFhOztBQUViLGNBQWMsbUJBQU8sQ0FBQyw0RUFBa0I7O0FBRXhDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxZQUFZO0FBQzFCO0FBQ0E7O0FBRUEiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9hcHAxLy4vbm9kZV9tb2R1bGVzL21vbmdvb3NlL2xpYi9vcHRpb25zL3BvcHVsYXRlT3B0aW9ucy5qcz85NGQxIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxuY29uc3QgY2xvbmUgPSByZXF1aXJlKCcuLi9oZWxwZXJzL2Nsb25lJyk7XG5cbmNsYXNzIFBvcHVsYXRlT3B0aW9ucyB7XG4gIGNvbnN0cnVjdG9yKG9iaikge1xuICAgIHRoaXMuX2RvY3MgPSB7fTtcbiAgICB0aGlzLl9jaGlsZERvY3MgPSBbXTtcblxuICAgIGlmIChvYmogPT0gbnVsbCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBvYmogPSBjbG9uZShvYmopO1xuICAgIE9iamVjdC5hc3NpZ24odGhpcywgb2JqKTtcbiAgICBpZiAodHlwZW9mIG9iai5zdWJQb3B1bGF0ZSA9PT0gJ29iamVjdCcpIHtcbiAgICAgIHRoaXMucG9wdWxhdGUgPSBvYmouc3ViUG9wdWxhdGU7XG4gICAgfVxuXG5cbiAgICBpZiAob2JqLnBlckRvY3VtZW50TGltaXQgIT0gbnVsbCAmJiBvYmoubGltaXQgIT0gbnVsbCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdDYW4gbm90IHVzZSBgbGltaXRgIGFuZCBgcGVyRG9jdW1lbnRMaW1pdGAgYXQgdGhlIHNhbWUgdGltZS4gUGF0aDogYCcgKyBvYmoucGF0aCArICdgLicpO1xuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIFRoZSBjb25uZWN0aW9uIHVzZWQgdG8gbG9vayB1cCBtb2RlbHMgYnkgbmFtZS4gSWYgbm90IHNwZWNpZmllZCwgTW9uZ29vc2VcbiAqIHdpbGwgZGVmYXVsdCB0byB1c2luZyB0aGUgY29ubmVjdGlvbiBhc3NvY2lhdGVkIHdpdGggdGhlIG1vZGVsIGluXG4gKiBgUG9wdWxhdGVPcHRpb25zI21vZGVsYC5cbiAqXG4gKiBAbWVtYmVyT2YgUG9wdWxhdGVPcHRpb25zXG4gKiBAcHJvcGVydHkge0Nvbm5lY3Rpb259IGNvbm5lY3Rpb25cbiAqIEBhcGkgcHVibGljXG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSBQb3B1bGF0ZU9wdGlvbnM7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/mongoose/lib/options/populateOptions.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/mongoose/lib/options/propertyOptions.js":
/*!**************************************************************!*\
  !*** ./node_modules/mongoose/lib/options/propertyOptions.js ***!
  \**************************************************************/
/***/ ((module) => {

eval("\n\nmodule.exports = Object.freeze({\n  enumerable: true,\n  configurable: true,\n  writable: true,\n  value: void 0\n});\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbW9uZ29vc2UvbGliL29wdGlvbnMvcHJvcGVydHlPcHRpb25zLmpzIiwibWFwcGluZ3MiOiJBQUFhOztBQUViO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vYXBwMS8uL25vZGVfbW9kdWxlcy9tb25nb29zZS9saWIvb3B0aW9ucy9wcm9wZXJ0eU9wdGlvbnMuanM/NTRiYiJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbm1vZHVsZS5leHBvcnRzID0gT2JqZWN0LmZyZWV6ZSh7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgd3JpdGFibGU6IHRydWUsXG4gIHZhbHVlOiB2b2lkIDBcbn0pO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/mongoose/lib/options/propertyOptions.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/mongoose/lib/options/saveOptions.js":
/*!**********************************************************!*\
  !*** ./node_modules/mongoose/lib/options/saveOptions.js ***!
  \**********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\n\nconst clone = __webpack_require__(/*! ../helpers/clone */ \"(ssr)/./node_modules/mongoose/lib/helpers/clone.js\");\n\nclass SaveOptions {\n  constructor(obj) {\n    if (obj == null) {\n      return;\n    }\n    Object.assign(this, clone(obj));\n  }\n}\n\nmodule.exports = SaveOptions;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbW9uZ29vc2UvbGliL29wdGlvbnMvc2F2ZU9wdGlvbnMuanMiLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWIsY0FBYyxtQkFBTyxDQUFDLDRFQUFrQjs7QUFFeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSIsInNvdXJjZXMiOlsid2VicGFjazovL2FwcDEvLi9ub2RlX21vZHVsZXMvbW9uZ29vc2UvbGliL29wdGlvbnMvc2F2ZU9wdGlvbnMuanM/NjczYyJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbmNvbnN0IGNsb25lID0gcmVxdWlyZSgnLi4vaGVscGVycy9jbG9uZScpO1xuXG5jbGFzcyBTYXZlT3B0aW9ucyB7XG4gIGNvbnN0cnVjdG9yKG9iaikge1xuICAgIGlmIChvYmogPT0gbnVsbCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBPYmplY3QuYXNzaWduKHRoaXMsIGNsb25lKG9iaikpO1xuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gU2F2ZU9wdGlvbnM7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/mongoose/lib/options/saveOptions.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/mongoose/lib/options/schemaArrayOptions.js":
/*!*****************************************************************!*\
  !*** ./node_modules/mongoose/lib/options/schemaArrayOptions.js ***!
  \*****************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\n\nconst SchemaTypeOptions = __webpack_require__(/*! ./schemaTypeOptions */ \"(ssr)/./node_modules/mongoose/lib/options/schemaTypeOptions.js\");\n\n/**\n * The options defined on an Array schematype.\n *\n * #### Example:\n *\n *     const schema = new Schema({ tags: [String] });\n *     schema.path('tags').options; // SchemaArrayOptions instance\n *\n * @api public\n * @inherits SchemaTypeOptions\n * @constructor SchemaArrayOptions\n */\n\nclass SchemaArrayOptions extends SchemaTypeOptions {}\n\nconst opts = __webpack_require__(/*! ./propertyOptions */ \"(ssr)/./node_modules/mongoose/lib/options/propertyOptions.js\");\n\n/**\n * If this is an array of strings, an array of allowed values for this path.\n * Throws an error if this array isn't an array of strings.\n *\n * @api public\n * @property enum\n * @memberOf SchemaArrayOptions\n * @type {Array}\n * @instance\n */\n\nObject.defineProperty(SchemaArrayOptions.prototype, 'enum', opts);\n\n/**\n * If set, specifies the type of this array's values. Equivalent to setting\n * `type` to an array whose first element is `of`.\n *\n * #### Example:\n *\n *     // `arr` is an array of numbers.\n *     new Schema({ arr: [Number] });\n *     // Equivalent way to define `arr` as an array of numbers\n *     new Schema({ arr: { type: Array, of: Number } });\n *\n * @api public\n * @property of\n * @memberOf SchemaArrayOptions\n * @type {Function|String}\n * @instance\n */\n\nObject.defineProperty(SchemaArrayOptions.prototype, 'of', opts);\n\n/**\n * If set to `false`, will always deactivate casting non-array values to arrays.\n * If set to `true`, will cast non-array values to arrays if `init` and `SchemaArray.options.castNonArrays` are also `true`\n *\n * #### Example:\n *\n *     const Model = db.model('Test', new Schema({ x1: { castNonArrays: false, type: [String] } }));\n *     const doc = new Model({ x1: \"some non-array value\" });\n *     await doc.validate(); // Errors with \"CastError\"\n *\n * @api public\n * @property castNonArrays\n * @memberOf SchemaArrayOptions\n * @type {Boolean}\n * @instance\n */\n\nObject.defineProperty(SchemaArrayOptions.prototype, 'castNonArrays', opts);\n\n/*!\n * ignore\n */\n\nmodule.exports = SchemaArrayOptions;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbW9uZ29vc2UvbGliL29wdGlvbnMvc2NoZW1hQXJyYXlPcHRpb25zLmpzIiwibWFwcGluZ3MiOiJBQUFhOztBQUViLDBCQUEwQixtQkFBTyxDQUFDLDJGQUFxQjs7QUFFdkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQyxnQkFBZ0I7QUFDbkQsb0NBQW9DO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsYUFBYSxtQkFBTyxDQUFDLHVGQUFtQjs7QUFFeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixlQUFlO0FBQ25DO0FBQ0Esb0JBQW9CLE9BQU8sMkJBQTJCO0FBQ3REO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbURBQW1ELE1BQU0sd0NBQXdDO0FBQ2pHLCtCQUErQiw0QkFBNEI7QUFDM0QsNkJBQTZCO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vYXBwMS8uL25vZGVfbW9kdWxlcy9tb25nb29zZS9saWIvb3B0aW9ucy9zY2hlbWFBcnJheU9wdGlvbnMuanM/N2IzNCJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbmNvbnN0IFNjaGVtYVR5cGVPcHRpb25zID0gcmVxdWlyZSgnLi9zY2hlbWFUeXBlT3B0aW9ucycpO1xuXG4vKipcbiAqIFRoZSBvcHRpb25zIGRlZmluZWQgb24gYW4gQXJyYXkgc2NoZW1hdHlwZS5cbiAqXG4gKiAjIyMjIEV4YW1wbGU6XG4gKlxuICogICAgIGNvbnN0IHNjaGVtYSA9IG5ldyBTY2hlbWEoeyB0YWdzOiBbU3RyaW5nXSB9KTtcbiAqICAgICBzY2hlbWEucGF0aCgndGFncycpLm9wdGlvbnM7IC8vIFNjaGVtYUFycmF5T3B0aW9ucyBpbnN0YW5jZVxuICpcbiAqIEBhcGkgcHVibGljXG4gKiBAaW5oZXJpdHMgU2NoZW1hVHlwZU9wdGlvbnNcbiAqIEBjb25zdHJ1Y3RvciBTY2hlbWFBcnJheU9wdGlvbnNcbiAqL1xuXG5jbGFzcyBTY2hlbWFBcnJheU9wdGlvbnMgZXh0ZW5kcyBTY2hlbWFUeXBlT3B0aW9ucyB7fVxuXG5jb25zdCBvcHRzID0gcmVxdWlyZSgnLi9wcm9wZXJ0eU9wdGlvbnMnKTtcblxuLyoqXG4gKiBJZiB0aGlzIGlzIGFuIGFycmF5IG9mIHN0cmluZ3MsIGFuIGFycmF5IG9mIGFsbG93ZWQgdmFsdWVzIGZvciB0aGlzIHBhdGguXG4gKiBUaHJvd3MgYW4gZXJyb3IgaWYgdGhpcyBhcnJheSBpc24ndCBhbiBhcnJheSBvZiBzdHJpbmdzLlxuICpcbiAqIEBhcGkgcHVibGljXG4gKiBAcHJvcGVydHkgZW51bVxuICogQG1lbWJlck9mIFNjaGVtYUFycmF5T3B0aW9uc1xuICogQHR5cGUge0FycmF5fVxuICogQGluc3RhbmNlXG4gKi9cblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KFNjaGVtYUFycmF5T3B0aW9ucy5wcm90b3R5cGUsICdlbnVtJywgb3B0cyk7XG5cbi8qKlxuICogSWYgc2V0LCBzcGVjaWZpZXMgdGhlIHR5cGUgb2YgdGhpcyBhcnJheSdzIHZhbHVlcy4gRXF1aXZhbGVudCB0byBzZXR0aW5nXG4gKiBgdHlwZWAgdG8gYW4gYXJyYXkgd2hvc2UgZmlyc3QgZWxlbWVudCBpcyBgb2ZgLlxuICpcbiAqICMjIyMgRXhhbXBsZTpcbiAqXG4gKiAgICAgLy8gYGFycmAgaXMgYW4gYXJyYXkgb2YgbnVtYmVycy5cbiAqICAgICBuZXcgU2NoZW1hKHsgYXJyOiBbTnVtYmVyXSB9KTtcbiAqICAgICAvLyBFcXVpdmFsZW50IHdheSB0byBkZWZpbmUgYGFycmAgYXMgYW4gYXJyYXkgb2YgbnVtYmVyc1xuICogICAgIG5ldyBTY2hlbWEoeyBhcnI6IHsgdHlwZTogQXJyYXksIG9mOiBOdW1iZXIgfSB9KTtcbiAqXG4gKiBAYXBpIHB1YmxpY1xuICogQHByb3BlcnR5IG9mXG4gKiBAbWVtYmVyT2YgU2NoZW1hQXJyYXlPcHRpb25zXG4gKiBAdHlwZSB7RnVuY3Rpb258U3RyaW5nfVxuICogQGluc3RhbmNlXG4gKi9cblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KFNjaGVtYUFycmF5T3B0aW9ucy5wcm90b3R5cGUsICdvZicsIG9wdHMpO1xuXG4vKipcbiAqIElmIHNldCB0byBgZmFsc2VgLCB3aWxsIGFsd2F5cyBkZWFjdGl2YXRlIGNhc3Rpbmcgbm9uLWFycmF5IHZhbHVlcyB0byBhcnJheXMuXG4gKiBJZiBzZXQgdG8gYHRydWVgLCB3aWxsIGNhc3Qgbm9uLWFycmF5IHZhbHVlcyB0byBhcnJheXMgaWYgYGluaXRgIGFuZCBgU2NoZW1hQXJyYXkub3B0aW9ucy5jYXN0Tm9uQXJyYXlzYCBhcmUgYWxzbyBgdHJ1ZWBcbiAqXG4gKiAjIyMjIEV4YW1wbGU6XG4gKlxuICogICAgIGNvbnN0IE1vZGVsID0gZGIubW9kZWwoJ1Rlc3QnLCBuZXcgU2NoZW1hKHsgeDE6IHsgY2FzdE5vbkFycmF5czogZmFsc2UsIHR5cGU6IFtTdHJpbmddIH0gfSkpO1xuICogICAgIGNvbnN0IGRvYyA9IG5ldyBNb2RlbCh7IHgxOiBcInNvbWUgbm9uLWFycmF5IHZhbHVlXCIgfSk7XG4gKiAgICAgYXdhaXQgZG9jLnZhbGlkYXRlKCk7IC8vIEVycm9ycyB3aXRoIFwiQ2FzdEVycm9yXCJcbiAqXG4gKiBAYXBpIHB1YmxpY1xuICogQHByb3BlcnR5IGNhc3ROb25BcnJheXNcbiAqIEBtZW1iZXJPZiBTY2hlbWFBcnJheU9wdGlvbnNcbiAqIEB0eXBlIHtCb29sZWFufVxuICogQGluc3RhbmNlXG4gKi9cblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KFNjaGVtYUFycmF5T3B0aW9ucy5wcm90b3R5cGUsICdjYXN0Tm9uQXJyYXlzJywgb3B0cyk7XG5cbi8qIVxuICogaWdub3JlXG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSBTY2hlbWFBcnJheU9wdGlvbnM7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/mongoose/lib/options/schemaArrayOptions.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/mongoose/lib/options/schemaBufferOptions.js":
/*!******************************************************************!*\
  !*** ./node_modules/mongoose/lib/options/schemaBufferOptions.js ***!
  \******************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\n\nconst SchemaTypeOptions = __webpack_require__(/*! ./schemaTypeOptions */ \"(ssr)/./node_modules/mongoose/lib/options/schemaTypeOptions.js\");\n\n/**\n * The options defined on a Buffer schematype.\n *\n * #### Example:\n *\n *     const schema = new Schema({ bitmap: Buffer });\n *     schema.path('bitmap').options; // SchemaBufferOptions instance\n *\n * @api public\n * @inherits SchemaTypeOptions\n * @constructor SchemaBufferOptions\n */\n\nclass SchemaBufferOptions extends SchemaTypeOptions {}\n\nconst opts = __webpack_require__(/*! ./propertyOptions */ \"(ssr)/./node_modules/mongoose/lib/options/propertyOptions.js\");\n\n/**\n * Set the default subtype for this buffer.\n *\n * @api public\n * @property subtype\n * @memberOf SchemaBufferOptions\n * @type {Number}\n * @instance\n */\n\nObject.defineProperty(SchemaBufferOptions.prototype, 'subtype', opts);\n\n/*!\n * ignore\n */\n\nmodule.exports = SchemaBufferOptions;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbW9uZ29vc2UvbGliL29wdGlvbnMvc2NoZW1hQnVmZmVyT3B0aW9ucy5qcyIsIm1hcHBpbmdzIjoiQUFBYTs7QUFFYiwwQkFBMEIsbUJBQU8sQ0FBQywyRkFBcUI7O0FBRXZEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUMsZ0JBQWdCO0FBQ25ELHNDQUFzQztBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBLGFBQWEsbUJBQU8sQ0FBQyx1RkFBbUI7O0FBRXhDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSIsInNvdXJjZXMiOlsid2VicGFjazovL2FwcDEvLi9ub2RlX21vZHVsZXMvbW9uZ29vc2UvbGliL29wdGlvbnMvc2NoZW1hQnVmZmVyT3B0aW9ucy5qcz9hODZkIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxuY29uc3QgU2NoZW1hVHlwZU9wdGlvbnMgPSByZXF1aXJlKCcuL3NjaGVtYVR5cGVPcHRpb25zJyk7XG5cbi8qKlxuICogVGhlIG9wdGlvbnMgZGVmaW5lZCBvbiBhIEJ1ZmZlciBzY2hlbWF0eXBlLlxuICpcbiAqICMjIyMgRXhhbXBsZTpcbiAqXG4gKiAgICAgY29uc3Qgc2NoZW1hID0gbmV3IFNjaGVtYSh7IGJpdG1hcDogQnVmZmVyIH0pO1xuICogICAgIHNjaGVtYS5wYXRoKCdiaXRtYXAnKS5vcHRpb25zOyAvLyBTY2hlbWFCdWZmZXJPcHRpb25zIGluc3RhbmNlXG4gKlxuICogQGFwaSBwdWJsaWNcbiAqIEBpbmhlcml0cyBTY2hlbWFUeXBlT3B0aW9uc1xuICogQGNvbnN0cnVjdG9yIFNjaGVtYUJ1ZmZlck9wdGlvbnNcbiAqL1xuXG5jbGFzcyBTY2hlbWFCdWZmZXJPcHRpb25zIGV4dGVuZHMgU2NoZW1hVHlwZU9wdGlvbnMge31cblxuY29uc3Qgb3B0cyA9IHJlcXVpcmUoJy4vcHJvcGVydHlPcHRpb25zJyk7XG5cbi8qKlxuICogU2V0IHRoZSBkZWZhdWx0IHN1YnR5cGUgZm9yIHRoaXMgYnVmZmVyLlxuICpcbiAqIEBhcGkgcHVibGljXG4gKiBAcHJvcGVydHkgc3VidHlwZVxuICogQG1lbWJlck9mIFNjaGVtYUJ1ZmZlck9wdGlvbnNcbiAqIEB0eXBlIHtOdW1iZXJ9XG4gKiBAaW5zdGFuY2VcbiAqL1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoU2NoZW1hQnVmZmVyT3B0aW9ucy5wcm90b3R5cGUsICdzdWJ0eXBlJywgb3B0cyk7XG5cbi8qIVxuICogaWdub3JlXG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSBTY2hlbWFCdWZmZXJPcHRpb25zO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/mongoose/lib/options/schemaBufferOptions.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/mongoose/lib/options/schemaDateOptions.js":
/*!****************************************************************!*\
  !*** ./node_modules/mongoose/lib/options/schemaDateOptions.js ***!
  \****************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\n\nconst SchemaTypeOptions = __webpack_require__(/*! ./schemaTypeOptions */ \"(ssr)/./node_modules/mongoose/lib/options/schemaTypeOptions.js\");\n\n/**\n * The options defined on a Date schematype.\n *\n * #### Example:\n *\n *     const schema = new Schema({ startedAt: Date });\n *     schema.path('startedAt').options; // SchemaDateOptions instance\n *\n * @api public\n * @inherits SchemaTypeOptions\n * @constructor SchemaDateOptions\n */\n\nclass SchemaDateOptions extends SchemaTypeOptions {}\n\nconst opts = __webpack_require__(/*! ./propertyOptions */ \"(ssr)/./node_modules/mongoose/lib/options/propertyOptions.js\");\n\n/**\n * If set, Mongoose adds a validator that checks that this path is after the\n * given `min`.\n *\n * @api public\n * @property min\n * @memberOf SchemaDateOptions\n * @type {Date}\n * @instance\n */\n\nObject.defineProperty(SchemaDateOptions.prototype, 'min', opts);\n\n/**\n * If set, Mongoose adds a validator that checks that this path is before the\n * given `max`.\n *\n * @api public\n * @property max\n * @memberOf SchemaDateOptions\n * @type {Date}\n * @instance\n */\n\nObject.defineProperty(SchemaDateOptions.prototype, 'max', opts);\n\n/**\n * If set, Mongoose creates a TTL index on this path.\n *\n * mongo TTL index `expireAfterSeconds` value will take 'expires' value expressed in seconds.\n *\n * #### Example:\n *\n *     const schema = new Schema({ \"expireAt\": { type: Date,  expires: 11 } });\n *     // if 'expireAt' is set, then document expires at expireAt + 11 seconds\n *\n * @api public\n * @property expires\n * @memberOf SchemaDateOptions\n * @type {Date}\n * @instance\n */\n\nObject.defineProperty(SchemaDateOptions.prototype, 'expires', opts);\n\n/*!\n * ignore\n */\n\nmodule.exports = SchemaDateOptions;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbW9uZ29vc2UvbGliL29wdGlvbnMvc2NoZW1hRGF0ZU9wdGlvbnMuanMiLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWIsMEJBQTBCLG1CQUFPLENBQUMsMkZBQXFCOztBQUV2RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DLGlCQUFpQjtBQUNwRCx5Q0FBeUM7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxhQUFhLG1CQUFPLENBQUMsdUZBQW1COztBQUV4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUMsY0FBYyw0QkFBNEI7QUFDN0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSIsInNvdXJjZXMiOlsid2VicGFjazovL2FwcDEvLi9ub2RlX21vZHVsZXMvbW9uZ29vc2UvbGliL29wdGlvbnMvc2NoZW1hRGF0ZU9wdGlvbnMuanM/MGNhNiJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbmNvbnN0IFNjaGVtYVR5cGVPcHRpb25zID0gcmVxdWlyZSgnLi9zY2hlbWFUeXBlT3B0aW9ucycpO1xuXG4vKipcbiAqIFRoZSBvcHRpb25zIGRlZmluZWQgb24gYSBEYXRlIHNjaGVtYXR5cGUuXG4gKlxuICogIyMjIyBFeGFtcGxlOlxuICpcbiAqICAgICBjb25zdCBzY2hlbWEgPSBuZXcgU2NoZW1hKHsgc3RhcnRlZEF0OiBEYXRlIH0pO1xuICogICAgIHNjaGVtYS5wYXRoKCdzdGFydGVkQXQnKS5vcHRpb25zOyAvLyBTY2hlbWFEYXRlT3B0aW9ucyBpbnN0YW5jZVxuICpcbiAqIEBhcGkgcHVibGljXG4gKiBAaW5oZXJpdHMgU2NoZW1hVHlwZU9wdGlvbnNcbiAqIEBjb25zdHJ1Y3RvciBTY2hlbWFEYXRlT3B0aW9uc1xuICovXG5cbmNsYXNzIFNjaGVtYURhdGVPcHRpb25zIGV4dGVuZHMgU2NoZW1hVHlwZU9wdGlvbnMge31cblxuY29uc3Qgb3B0cyA9IHJlcXVpcmUoJy4vcHJvcGVydHlPcHRpb25zJyk7XG5cbi8qKlxuICogSWYgc2V0LCBNb25nb29zZSBhZGRzIGEgdmFsaWRhdG9yIHRoYXQgY2hlY2tzIHRoYXQgdGhpcyBwYXRoIGlzIGFmdGVyIHRoZVxuICogZ2l2ZW4gYG1pbmAuXG4gKlxuICogQGFwaSBwdWJsaWNcbiAqIEBwcm9wZXJ0eSBtaW5cbiAqIEBtZW1iZXJPZiBTY2hlbWFEYXRlT3B0aW9uc1xuICogQHR5cGUge0RhdGV9XG4gKiBAaW5zdGFuY2VcbiAqL1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoU2NoZW1hRGF0ZU9wdGlvbnMucHJvdG90eXBlLCAnbWluJywgb3B0cyk7XG5cbi8qKlxuICogSWYgc2V0LCBNb25nb29zZSBhZGRzIGEgdmFsaWRhdG9yIHRoYXQgY2hlY2tzIHRoYXQgdGhpcyBwYXRoIGlzIGJlZm9yZSB0aGVcbiAqIGdpdmVuIGBtYXhgLlxuICpcbiAqIEBhcGkgcHVibGljXG4gKiBAcHJvcGVydHkgbWF4XG4gKiBAbWVtYmVyT2YgU2NoZW1hRGF0ZU9wdGlvbnNcbiAqIEB0eXBlIHtEYXRlfVxuICogQGluc3RhbmNlXG4gKi9cblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KFNjaGVtYURhdGVPcHRpb25zLnByb3RvdHlwZSwgJ21heCcsIG9wdHMpO1xuXG4vKipcbiAqIElmIHNldCwgTW9uZ29vc2UgY3JlYXRlcyBhIFRUTCBpbmRleCBvbiB0aGlzIHBhdGguXG4gKlxuICogbW9uZ28gVFRMIGluZGV4IGBleHBpcmVBZnRlclNlY29uZHNgIHZhbHVlIHdpbGwgdGFrZSAnZXhwaXJlcycgdmFsdWUgZXhwcmVzc2VkIGluIHNlY29uZHMuXG4gKlxuICogIyMjIyBFeGFtcGxlOlxuICpcbiAqICAgICBjb25zdCBzY2hlbWEgPSBuZXcgU2NoZW1hKHsgXCJleHBpcmVBdFwiOiB7IHR5cGU6IERhdGUsICBleHBpcmVzOiAxMSB9IH0pO1xuICogICAgIC8vIGlmICdleHBpcmVBdCcgaXMgc2V0LCB0aGVuIGRvY3VtZW50IGV4cGlyZXMgYXQgZXhwaXJlQXQgKyAxMSBzZWNvbmRzXG4gKlxuICogQGFwaSBwdWJsaWNcbiAqIEBwcm9wZXJ0eSBleHBpcmVzXG4gKiBAbWVtYmVyT2YgU2NoZW1hRGF0ZU9wdGlvbnNcbiAqIEB0eXBlIHtEYXRlfVxuICogQGluc3RhbmNlXG4gKi9cblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KFNjaGVtYURhdGVPcHRpb25zLnByb3RvdHlwZSwgJ2V4cGlyZXMnLCBvcHRzKTtcblxuLyohXG4gKiBpZ25vcmVcbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IFNjaGVtYURhdGVPcHRpb25zO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/mongoose/lib/options/schemaDateOptions.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/mongoose/lib/options/schemaDocumentArrayOptions.js":
/*!*************************************************************************!*\
  !*** ./node_modules/mongoose/lib/options/schemaDocumentArrayOptions.js ***!
  \*************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\n\nconst SchemaTypeOptions = __webpack_require__(/*! ./schemaTypeOptions */ \"(ssr)/./node_modules/mongoose/lib/options/schemaTypeOptions.js\");\n\n/**\n * The options defined on an Document Array schematype.\n *\n * #### Example:\n *\n *     const schema = new Schema({ users: [{ name: string }] });\n *     schema.path('users').options; // SchemaDocumentArrayOptions instance\n *\n * @api public\n * @inherits SchemaTypeOptions\n * @constructor SchemaDocumentOptions\n */\n\nclass SchemaDocumentArrayOptions extends SchemaTypeOptions {}\n\nconst opts = __webpack_require__(/*! ./propertyOptions */ \"(ssr)/./node_modules/mongoose/lib/options/propertyOptions.js\");\n\n/**\n * If `true`, Mongoose will skip building any indexes defined in this array's schema.\n * If not set, Mongoose will build all indexes defined in this array's schema.\n *\n * #### Example:\n *\n *     const childSchema = Schema({ name: { type: String, index: true } });\n *     // If `excludeIndexes` is `true`, Mongoose will skip building an index\n *     // on `arr.name`. Otherwise, Mongoose will build an index on `arr.name`.\n *     const parentSchema = Schema({\n *       arr: { type: [childSchema], excludeIndexes: true }\n *     });\n *\n * @api public\n * @property excludeIndexes\n * @memberOf SchemaDocumentArrayOptions\n * @type {Array}\n * @instance\n */\n\nObject.defineProperty(SchemaDocumentArrayOptions.prototype, 'excludeIndexes', opts);\n\n/**\n * If set, overwrites the child schema's `_id` option.\n *\n * #### Example:\n *\n *     const childSchema = Schema({ name: String });\n *     const parentSchema = Schema({\n *       child: { type: childSchema, _id: false }\n *     });\n *     parentSchema.path('child').schema.options._id; // false\n *\n * @api public\n * @property _id\n * @memberOf SchemaDocumentArrayOptions\n * @type {Array}\n * @instance\n */\n\nObject.defineProperty(SchemaDocumentArrayOptions.prototype, '_id', opts);\n\n/*!\n * ignore\n */\n\nmodule.exports = SchemaDocumentArrayOptions;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbW9uZ29vc2UvbGliL29wdGlvbnMvc2NoZW1hRG9jdW1lbnRBcnJheU9wdGlvbnMuanMiLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWIsMEJBQTBCLG1CQUFPLENBQUMsMkZBQXFCOztBQUV2RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DLFVBQVUsY0FBYyxHQUFHO0FBQzlELHFDQUFxQztBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBLGFBQWEsbUJBQU8sQ0FBQyx1RkFBbUI7O0FBRXhDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQyxRQUFRLDZCQUE2QjtBQUN6RTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEIsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQyxjQUFjO0FBQ2xEO0FBQ0Esa0JBQWtCO0FBQ2xCLFFBQVE7QUFDUixzREFBc0Q7QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9hcHAxLy4vbm9kZV9tb2R1bGVzL21vbmdvb3NlL2xpYi9vcHRpb25zL3NjaGVtYURvY3VtZW50QXJyYXlPcHRpb25zLmpzP2Y2MWIiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG5jb25zdCBTY2hlbWFUeXBlT3B0aW9ucyA9IHJlcXVpcmUoJy4vc2NoZW1hVHlwZU9wdGlvbnMnKTtcblxuLyoqXG4gKiBUaGUgb3B0aW9ucyBkZWZpbmVkIG9uIGFuIERvY3VtZW50IEFycmF5IHNjaGVtYXR5cGUuXG4gKlxuICogIyMjIyBFeGFtcGxlOlxuICpcbiAqICAgICBjb25zdCBzY2hlbWEgPSBuZXcgU2NoZW1hKHsgdXNlcnM6IFt7IG5hbWU6IHN0cmluZyB9XSB9KTtcbiAqICAgICBzY2hlbWEucGF0aCgndXNlcnMnKS5vcHRpb25zOyAvLyBTY2hlbWFEb2N1bWVudEFycmF5T3B0aW9ucyBpbnN0YW5jZVxuICpcbiAqIEBhcGkgcHVibGljXG4gKiBAaW5oZXJpdHMgU2NoZW1hVHlwZU9wdGlvbnNcbiAqIEBjb25zdHJ1Y3RvciBTY2hlbWFEb2N1bWVudE9wdGlvbnNcbiAqL1xuXG5jbGFzcyBTY2hlbWFEb2N1bWVudEFycmF5T3B0aW9ucyBleHRlbmRzIFNjaGVtYVR5cGVPcHRpb25zIHt9XG5cbmNvbnN0IG9wdHMgPSByZXF1aXJlKCcuL3Byb3BlcnR5T3B0aW9ucycpO1xuXG4vKipcbiAqIElmIGB0cnVlYCwgTW9uZ29vc2Ugd2lsbCBza2lwIGJ1aWxkaW5nIGFueSBpbmRleGVzIGRlZmluZWQgaW4gdGhpcyBhcnJheSdzIHNjaGVtYS5cbiAqIElmIG5vdCBzZXQsIE1vbmdvb3NlIHdpbGwgYnVpbGQgYWxsIGluZGV4ZXMgZGVmaW5lZCBpbiB0aGlzIGFycmF5J3Mgc2NoZW1hLlxuICpcbiAqICMjIyMgRXhhbXBsZTpcbiAqXG4gKiAgICAgY29uc3QgY2hpbGRTY2hlbWEgPSBTY2hlbWEoeyBuYW1lOiB7IHR5cGU6IFN0cmluZywgaW5kZXg6IHRydWUgfSB9KTtcbiAqICAgICAvLyBJZiBgZXhjbHVkZUluZGV4ZXNgIGlzIGB0cnVlYCwgTW9uZ29vc2Ugd2lsbCBza2lwIGJ1aWxkaW5nIGFuIGluZGV4XG4gKiAgICAgLy8gb24gYGFyci5uYW1lYC4gT3RoZXJ3aXNlLCBNb25nb29zZSB3aWxsIGJ1aWxkIGFuIGluZGV4IG9uIGBhcnIubmFtZWAuXG4gKiAgICAgY29uc3QgcGFyZW50U2NoZW1hID0gU2NoZW1hKHtcbiAqICAgICAgIGFycjogeyB0eXBlOiBbY2hpbGRTY2hlbWFdLCBleGNsdWRlSW5kZXhlczogdHJ1ZSB9XG4gKiAgICAgfSk7XG4gKlxuICogQGFwaSBwdWJsaWNcbiAqIEBwcm9wZXJ0eSBleGNsdWRlSW5kZXhlc1xuICogQG1lbWJlck9mIFNjaGVtYURvY3VtZW50QXJyYXlPcHRpb25zXG4gKiBAdHlwZSB7QXJyYXl9XG4gKiBAaW5zdGFuY2VcbiAqL1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoU2NoZW1hRG9jdW1lbnRBcnJheU9wdGlvbnMucHJvdG90eXBlLCAnZXhjbHVkZUluZGV4ZXMnLCBvcHRzKTtcblxuLyoqXG4gKiBJZiBzZXQsIG92ZXJ3cml0ZXMgdGhlIGNoaWxkIHNjaGVtYSdzIGBfaWRgIG9wdGlvbi5cbiAqXG4gKiAjIyMjIEV4YW1wbGU6XG4gKlxuICogICAgIGNvbnN0IGNoaWxkU2NoZW1hID0gU2NoZW1hKHsgbmFtZTogU3RyaW5nIH0pO1xuICogICAgIGNvbnN0IHBhcmVudFNjaGVtYSA9IFNjaGVtYSh7XG4gKiAgICAgICBjaGlsZDogeyB0eXBlOiBjaGlsZFNjaGVtYSwgX2lkOiBmYWxzZSB9XG4gKiAgICAgfSk7XG4gKiAgICAgcGFyZW50U2NoZW1hLnBhdGgoJ2NoaWxkJykuc2NoZW1hLm9wdGlvbnMuX2lkOyAvLyBmYWxzZVxuICpcbiAqIEBhcGkgcHVibGljXG4gKiBAcHJvcGVydHkgX2lkXG4gKiBAbWVtYmVyT2YgU2NoZW1hRG9jdW1lbnRBcnJheU9wdGlvbnNcbiAqIEB0eXBlIHtBcnJheX1cbiAqIEBpbnN0YW5jZVxuICovXG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShTY2hlbWFEb2N1bWVudEFycmF5T3B0aW9ucy5wcm90b3R5cGUsICdfaWQnLCBvcHRzKTtcblxuLyohXG4gKiBpZ25vcmVcbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IFNjaGVtYURvY3VtZW50QXJyYXlPcHRpb25zO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/mongoose/lib/options/schemaDocumentArrayOptions.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/mongoose/lib/options/schemaMapOptions.js":
/*!***************************************************************!*\
  !*** ./node_modules/mongoose/lib/options/schemaMapOptions.js ***!
  \***************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\n\nconst SchemaTypeOptions = __webpack_require__(/*! ./schemaTypeOptions */ \"(ssr)/./node_modules/mongoose/lib/options/schemaTypeOptions.js\");\n\n/**\n * The options defined on a Map schematype.\n *\n * #### Example:\n *\n *     const schema = new Schema({ socialMediaHandles: { type: Map, of: String } });\n *     schema.path('socialMediaHandles').options; // SchemaMapOptions instance\n *\n * @api public\n * @inherits SchemaTypeOptions\n * @constructor SchemaMapOptions\n */\n\nclass SchemaMapOptions extends SchemaTypeOptions {}\n\nconst opts = __webpack_require__(/*! ./propertyOptions */ \"(ssr)/./node_modules/mongoose/lib/options/propertyOptions.js\");\n\n/**\n * If set, specifies the type of this map's values. Mongoose will cast\n * this map's values to the given type.\n *\n * If not set, Mongoose will not cast the map's values.\n *\n * #### Example:\n *\n *     // Mongoose will cast `socialMediaHandles` values to strings\n *     const schema = new Schema({ socialMediaHandles: { type: Map, of: String } });\n *     schema.path('socialMediaHandles').options.of; // String\n *\n * @api public\n * @property of\n * @memberOf SchemaMapOptions\n * @type {Function|string}\n * @instance\n */\n\nObject.defineProperty(SchemaMapOptions.prototype, 'of', opts);\n\nmodule.exports = SchemaMapOptions;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbW9uZ29vc2UvbGliL29wdGlvbnMvc2NoZW1hTWFwT3B0aW9ucy5qcyIsIm1hcHBpbmdzIjoiQUFBYTs7QUFFYiwwQkFBMEIsbUJBQU8sQ0FBQywyRkFBcUI7O0FBRXZEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUMsc0JBQXNCLHlCQUF5QjtBQUNsRixrREFBa0Q7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxhQUFhLG1CQUFPLENBQUMsdUZBQW1COztBQUV4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUMsc0JBQXNCLHlCQUF5QjtBQUNsRixxREFBcUQ7QUFDckQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTs7QUFFQTs7QUFFQSIsInNvdXJjZXMiOlsid2VicGFjazovL2FwcDEvLi9ub2RlX21vZHVsZXMvbW9uZ29vc2UvbGliL29wdGlvbnMvc2NoZW1hTWFwT3B0aW9ucy5qcz9mNTliIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxuY29uc3QgU2NoZW1hVHlwZU9wdGlvbnMgPSByZXF1aXJlKCcuL3NjaGVtYVR5cGVPcHRpb25zJyk7XG5cbi8qKlxuICogVGhlIG9wdGlvbnMgZGVmaW5lZCBvbiBhIE1hcCBzY2hlbWF0eXBlLlxuICpcbiAqICMjIyMgRXhhbXBsZTpcbiAqXG4gKiAgICAgY29uc3Qgc2NoZW1hID0gbmV3IFNjaGVtYSh7IHNvY2lhbE1lZGlhSGFuZGxlczogeyB0eXBlOiBNYXAsIG9mOiBTdHJpbmcgfSB9KTtcbiAqICAgICBzY2hlbWEucGF0aCgnc29jaWFsTWVkaWFIYW5kbGVzJykub3B0aW9uczsgLy8gU2NoZW1hTWFwT3B0aW9ucyBpbnN0YW5jZVxuICpcbiAqIEBhcGkgcHVibGljXG4gKiBAaW5oZXJpdHMgU2NoZW1hVHlwZU9wdGlvbnNcbiAqIEBjb25zdHJ1Y3RvciBTY2hlbWFNYXBPcHRpb25zXG4gKi9cblxuY2xhc3MgU2NoZW1hTWFwT3B0aW9ucyBleHRlbmRzIFNjaGVtYVR5cGVPcHRpb25zIHt9XG5cbmNvbnN0IG9wdHMgPSByZXF1aXJlKCcuL3Byb3BlcnR5T3B0aW9ucycpO1xuXG4vKipcbiAqIElmIHNldCwgc3BlY2lmaWVzIHRoZSB0eXBlIG9mIHRoaXMgbWFwJ3MgdmFsdWVzLiBNb25nb29zZSB3aWxsIGNhc3RcbiAqIHRoaXMgbWFwJ3MgdmFsdWVzIHRvIHRoZSBnaXZlbiB0eXBlLlxuICpcbiAqIElmIG5vdCBzZXQsIE1vbmdvb3NlIHdpbGwgbm90IGNhc3QgdGhlIG1hcCdzIHZhbHVlcy5cbiAqXG4gKiAjIyMjIEV4YW1wbGU6XG4gKlxuICogICAgIC8vIE1vbmdvb3NlIHdpbGwgY2FzdCBgc29jaWFsTWVkaWFIYW5kbGVzYCB2YWx1ZXMgdG8gc3RyaW5nc1xuICogICAgIGNvbnN0IHNjaGVtYSA9IG5ldyBTY2hlbWEoeyBzb2NpYWxNZWRpYUhhbmRsZXM6IHsgdHlwZTogTWFwLCBvZjogU3RyaW5nIH0gfSk7XG4gKiAgICAgc2NoZW1hLnBhdGgoJ3NvY2lhbE1lZGlhSGFuZGxlcycpLm9wdGlvbnMub2Y7IC8vIFN0cmluZ1xuICpcbiAqIEBhcGkgcHVibGljXG4gKiBAcHJvcGVydHkgb2ZcbiAqIEBtZW1iZXJPZiBTY2hlbWFNYXBPcHRpb25zXG4gKiBAdHlwZSB7RnVuY3Rpb258c3RyaW5nfVxuICogQGluc3RhbmNlXG4gKi9cblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KFNjaGVtYU1hcE9wdGlvbnMucHJvdG90eXBlLCAnb2YnLCBvcHRzKTtcblxubW9kdWxlLmV4cG9ydHMgPSBTY2hlbWFNYXBPcHRpb25zO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/mongoose/lib/options/schemaMapOptions.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/mongoose/lib/options/schemaNumberOptions.js":
/*!******************************************************************!*\
  !*** ./node_modules/mongoose/lib/options/schemaNumberOptions.js ***!
  \******************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\n\nconst SchemaTypeOptions = __webpack_require__(/*! ./schemaTypeOptions */ \"(ssr)/./node_modules/mongoose/lib/options/schemaTypeOptions.js\");\n\n/**\n * The options defined on a Number schematype.\n *\n * #### Example:\n *\n *     const schema = new Schema({ count: Number });\n *     schema.path('count').options; // SchemaNumberOptions instance\n *\n * @api public\n * @inherits SchemaTypeOptions\n * @constructor SchemaNumberOptions\n */\n\nclass SchemaNumberOptions extends SchemaTypeOptions {}\n\nconst opts = __webpack_require__(/*! ./propertyOptions */ \"(ssr)/./node_modules/mongoose/lib/options/propertyOptions.js\");\n\n/**\n * If set, Mongoose adds a validator that checks that this path is at least the\n * given `min`.\n *\n * @api public\n * @property min\n * @memberOf SchemaNumberOptions\n * @type {Number}\n * @instance\n */\n\nObject.defineProperty(SchemaNumberOptions.prototype, 'min', opts);\n\n/**\n * If set, Mongoose adds a validator that checks that this path is less than the\n * given `max`.\n *\n * @api public\n * @property max\n * @memberOf SchemaNumberOptions\n * @type {Number}\n * @instance\n */\n\nObject.defineProperty(SchemaNumberOptions.prototype, 'max', opts);\n\n/**\n * If set, Mongoose adds a validator that checks that this path is strictly\n * equal to one of the given values.\n *\n * #### Example:\n *\n *     const schema = new Schema({\n *       favoritePrime: {\n *         type: Number,\n *         enum: [3, 5, 7]\n *       }\n *     });\n *     schema.path('favoritePrime').options.enum; // [3, 5, 7]\n *\n * @api public\n * @property enum\n * @memberOf SchemaNumberOptions\n * @type {Array}\n * @instance\n */\n\nObject.defineProperty(SchemaNumberOptions.prototype, 'enum', opts);\n\n/**\n * Sets default [populate options](https://mongoosejs.com/docs/populate.html#query-conditions).\n *\n * #### Example:\n *\n *     const schema = new Schema({\n *       child: {\n *         type: Number,\n *         ref: 'Child',\n *         populate: { select: 'name' }\n *       }\n *     });\n *     const Parent = mongoose.model('Parent', schema);\n *\n *     // Automatically adds `.select('name')`\n *     Parent.findOne().populate('child');\n *\n * @api public\n * @property populate\n * @memberOf SchemaNumberOptions\n * @type {Object}\n * @instance\n */\n\nObject.defineProperty(SchemaNumberOptions.prototype, 'populate', opts);\n\n/*!\n * ignore\n */\n\nmodule.exports = SchemaNumberOptions;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbW9uZ29vc2UvbGliL29wdGlvbnMvc2NoZW1hTnVtYmVyT3B0aW9ucy5qcyIsIm1hcHBpbmdzIjoiQUFBYTs7QUFFYiwwQkFBMEIsbUJBQU8sQ0FBQywyRkFBcUI7O0FBRXZEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUMsZUFBZTtBQUNsRCxxQ0FBcUM7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxhQUFhLG1CQUFPLENBQUMsdUZBQW1COztBQUV4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUixrREFBa0Q7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUI7QUFDdkI7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSIsInNvdXJjZXMiOlsid2VicGFjazovL2FwcDEvLi9ub2RlX21vZHVsZXMvbW9uZ29vc2UvbGliL29wdGlvbnMvc2NoZW1hTnVtYmVyT3B0aW9ucy5qcz9kMDY4Il0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxuY29uc3QgU2NoZW1hVHlwZU9wdGlvbnMgPSByZXF1aXJlKCcuL3NjaGVtYVR5cGVPcHRpb25zJyk7XG5cbi8qKlxuICogVGhlIG9wdGlvbnMgZGVmaW5lZCBvbiBhIE51bWJlciBzY2hlbWF0eXBlLlxuICpcbiAqICMjIyMgRXhhbXBsZTpcbiAqXG4gKiAgICAgY29uc3Qgc2NoZW1hID0gbmV3IFNjaGVtYSh7IGNvdW50OiBOdW1iZXIgfSk7XG4gKiAgICAgc2NoZW1hLnBhdGgoJ2NvdW50Jykub3B0aW9uczsgLy8gU2NoZW1hTnVtYmVyT3B0aW9ucyBpbnN0YW5jZVxuICpcbiAqIEBhcGkgcHVibGljXG4gKiBAaW5oZXJpdHMgU2NoZW1hVHlwZU9wdGlvbnNcbiAqIEBjb25zdHJ1Y3RvciBTY2hlbWFOdW1iZXJPcHRpb25zXG4gKi9cblxuY2xhc3MgU2NoZW1hTnVtYmVyT3B0aW9ucyBleHRlbmRzIFNjaGVtYVR5cGVPcHRpb25zIHt9XG5cbmNvbnN0IG9wdHMgPSByZXF1aXJlKCcuL3Byb3BlcnR5T3B0aW9ucycpO1xuXG4vKipcbiAqIElmIHNldCwgTW9uZ29vc2UgYWRkcyBhIHZhbGlkYXRvciB0aGF0IGNoZWNrcyB0aGF0IHRoaXMgcGF0aCBpcyBhdCBsZWFzdCB0aGVcbiAqIGdpdmVuIGBtaW5gLlxuICpcbiAqIEBhcGkgcHVibGljXG4gKiBAcHJvcGVydHkgbWluXG4gKiBAbWVtYmVyT2YgU2NoZW1hTnVtYmVyT3B0aW9uc1xuICogQHR5cGUge051bWJlcn1cbiAqIEBpbnN0YW5jZVxuICovXG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShTY2hlbWFOdW1iZXJPcHRpb25zLnByb3RvdHlwZSwgJ21pbicsIG9wdHMpO1xuXG4vKipcbiAqIElmIHNldCwgTW9uZ29vc2UgYWRkcyBhIHZhbGlkYXRvciB0aGF0IGNoZWNrcyB0aGF0IHRoaXMgcGF0aCBpcyBsZXNzIHRoYW4gdGhlXG4gKiBnaXZlbiBgbWF4YC5cbiAqXG4gKiBAYXBpIHB1YmxpY1xuICogQHByb3BlcnR5IG1heFxuICogQG1lbWJlck9mIFNjaGVtYU51bWJlck9wdGlvbnNcbiAqIEB0eXBlIHtOdW1iZXJ9XG4gKiBAaW5zdGFuY2VcbiAqL1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoU2NoZW1hTnVtYmVyT3B0aW9ucy5wcm90b3R5cGUsICdtYXgnLCBvcHRzKTtcblxuLyoqXG4gKiBJZiBzZXQsIE1vbmdvb3NlIGFkZHMgYSB2YWxpZGF0b3IgdGhhdCBjaGVja3MgdGhhdCB0aGlzIHBhdGggaXMgc3RyaWN0bHlcbiAqIGVxdWFsIHRvIG9uZSBvZiB0aGUgZ2l2ZW4gdmFsdWVzLlxuICpcbiAqICMjIyMgRXhhbXBsZTpcbiAqXG4gKiAgICAgY29uc3Qgc2NoZW1hID0gbmV3IFNjaGVtYSh7XG4gKiAgICAgICBmYXZvcml0ZVByaW1lOiB7XG4gKiAgICAgICAgIHR5cGU6IE51bWJlcixcbiAqICAgICAgICAgZW51bTogWzMsIDUsIDddXG4gKiAgICAgICB9XG4gKiAgICAgfSk7XG4gKiAgICAgc2NoZW1hLnBhdGgoJ2Zhdm9yaXRlUHJpbWUnKS5vcHRpb25zLmVudW07IC8vIFszLCA1LCA3XVxuICpcbiAqIEBhcGkgcHVibGljXG4gKiBAcHJvcGVydHkgZW51bVxuICogQG1lbWJlck9mIFNjaGVtYU51bWJlck9wdGlvbnNcbiAqIEB0eXBlIHtBcnJheX1cbiAqIEBpbnN0YW5jZVxuICovXG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShTY2hlbWFOdW1iZXJPcHRpb25zLnByb3RvdHlwZSwgJ2VudW0nLCBvcHRzKTtcblxuLyoqXG4gKiBTZXRzIGRlZmF1bHQgW3BvcHVsYXRlIG9wdGlvbnNdKGh0dHBzOi8vbW9uZ29vc2Vqcy5jb20vZG9jcy9wb3B1bGF0ZS5odG1sI3F1ZXJ5LWNvbmRpdGlvbnMpLlxuICpcbiAqICMjIyMgRXhhbXBsZTpcbiAqXG4gKiAgICAgY29uc3Qgc2NoZW1hID0gbmV3IFNjaGVtYSh7XG4gKiAgICAgICBjaGlsZDoge1xuICogICAgICAgICB0eXBlOiBOdW1iZXIsXG4gKiAgICAgICAgIHJlZjogJ0NoaWxkJyxcbiAqICAgICAgICAgcG9wdWxhdGU6IHsgc2VsZWN0OiAnbmFtZScgfVxuICogICAgICAgfVxuICogICAgIH0pO1xuICogICAgIGNvbnN0IFBhcmVudCA9IG1vbmdvb3NlLm1vZGVsKCdQYXJlbnQnLCBzY2hlbWEpO1xuICpcbiAqICAgICAvLyBBdXRvbWF0aWNhbGx5IGFkZHMgYC5zZWxlY3QoJ25hbWUnKWBcbiAqICAgICBQYXJlbnQuZmluZE9uZSgpLnBvcHVsYXRlKCdjaGlsZCcpO1xuICpcbiAqIEBhcGkgcHVibGljXG4gKiBAcHJvcGVydHkgcG9wdWxhdGVcbiAqIEBtZW1iZXJPZiBTY2hlbWFOdW1iZXJPcHRpb25zXG4gKiBAdHlwZSB7T2JqZWN0fVxuICogQGluc3RhbmNlXG4gKi9cblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KFNjaGVtYU51bWJlck9wdGlvbnMucHJvdG90eXBlLCAncG9wdWxhdGUnLCBvcHRzKTtcblxuLyohXG4gKiBpZ25vcmVcbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IFNjaGVtYU51bWJlck9wdGlvbnM7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/mongoose/lib/options/schemaNumberOptions.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/mongoose/lib/options/schemaObjectIdOptions.js":
/*!********************************************************************!*\
  !*** ./node_modules/mongoose/lib/options/schemaObjectIdOptions.js ***!
  \********************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\n\nconst SchemaTypeOptions = __webpack_require__(/*! ./schemaTypeOptions */ \"(ssr)/./node_modules/mongoose/lib/options/schemaTypeOptions.js\");\n\n/**\n * The options defined on an ObjectId schematype.\n *\n * #### Example:\n *\n *     const schema = new Schema({ testId: mongoose.ObjectId });\n *     schema.path('testId').options; // SchemaObjectIdOptions instance\n *\n * @api public\n * @inherits SchemaTypeOptions\n * @constructor SchemaObjectIdOptions\n */\n\nclass SchemaObjectIdOptions extends SchemaTypeOptions {}\n\nconst opts = __webpack_require__(/*! ./propertyOptions */ \"(ssr)/./node_modules/mongoose/lib/options/propertyOptions.js\");\n\n/**\n * If truthy, uses Mongoose's default built-in ObjectId path.\n *\n * @api public\n * @property auto\n * @memberOf SchemaObjectIdOptions\n * @type {Boolean}\n * @instance\n */\n\nObject.defineProperty(SchemaObjectIdOptions.prototype, 'auto', opts);\n\n/**\n * Sets default [populate options](https://mongoosejs.com/docs/populate.html#query-conditions).\n *\n * #### Example:\n *\n *     const schema = new Schema({\n *       child: {\n *         type: 'ObjectId',\n *         ref: 'Child',\n *         populate: { select: 'name' }\n *       }\n *     });\n *     const Parent = mongoose.model('Parent', schema);\n *\n *     // Automatically adds `.select('name')`\n *     Parent.findOne().populate('child');\n *\n * @api public\n * @property populate\n * @memberOf SchemaObjectIdOptions\n * @type {Object}\n * @instance\n */\n\nObject.defineProperty(SchemaObjectIdOptions.prototype, 'populate', opts);\n\n/*!\n * ignore\n */\n\nmodule.exports = SchemaObjectIdOptions;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbW9uZ29vc2UvbGliL29wdGlvbnMvc2NoZW1hT2JqZWN0SWRPcHRpb25zLmpzIiwibWFwcGluZ3MiOiJBQUFhOztBQUViLDBCQUEwQixtQkFBTyxDQUFDLDJGQUFxQjs7QUFFdkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQywyQkFBMkI7QUFDOUQsc0NBQXNDO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsYUFBYSxtQkFBTyxDQUFDLHVGQUFtQjs7QUFFeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCO0FBQ3ZCO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9hcHAxLy4vbm9kZV9tb2R1bGVzL21vbmdvb3NlL2xpYi9vcHRpb25zL3NjaGVtYU9iamVjdElkT3B0aW9ucy5qcz8wYTRlIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxuY29uc3QgU2NoZW1hVHlwZU9wdGlvbnMgPSByZXF1aXJlKCcuL3NjaGVtYVR5cGVPcHRpb25zJyk7XG5cbi8qKlxuICogVGhlIG9wdGlvbnMgZGVmaW5lZCBvbiBhbiBPYmplY3RJZCBzY2hlbWF0eXBlLlxuICpcbiAqICMjIyMgRXhhbXBsZTpcbiAqXG4gKiAgICAgY29uc3Qgc2NoZW1hID0gbmV3IFNjaGVtYSh7IHRlc3RJZDogbW9uZ29vc2UuT2JqZWN0SWQgfSk7XG4gKiAgICAgc2NoZW1hLnBhdGgoJ3Rlc3RJZCcpLm9wdGlvbnM7IC8vIFNjaGVtYU9iamVjdElkT3B0aW9ucyBpbnN0YW5jZVxuICpcbiAqIEBhcGkgcHVibGljXG4gKiBAaW5oZXJpdHMgU2NoZW1hVHlwZU9wdGlvbnNcbiAqIEBjb25zdHJ1Y3RvciBTY2hlbWFPYmplY3RJZE9wdGlvbnNcbiAqL1xuXG5jbGFzcyBTY2hlbWFPYmplY3RJZE9wdGlvbnMgZXh0ZW5kcyBTY2hlbWFUeXBlT3B0aW9ucyB7fVxuXG5jb25zdCBvcHRzID0gcmVxdWlyZSgnLi9wcm9wZXJ0eU9wdGlvbnMnKTtcblxuLyoqXG4gKiBJZiB0cnV0aHksIHVzZXMgTW9uZ29vc2UncyBkZWZhdWx0IGJ1aWx0LWluIE9iamVjdElkIHBhdGguXG4gKlxuICogQGFwaSBwdWJsaWNcbiAqIEBwcm9wZXJ0eSBhdXRvXG4gKiBAbWVtYmVyT2YgU2NoZW1hT2JqZWN0SWRPcHRpb25zXG4gKiBAdHlwZSB7Qm9vbGVhbn1cbiAqIEBpbnN0YW5jZVxuICovXG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShTY2hlbWFPYmplY3RJZE9wdGlvbnMucHJvdG90eXBlLCAnYXV0bycsIG9wdHMpO1xuXG4vKipcbiAqIFNldHMgZGVmYXVsdCBbcG9wdWxhdGUgb3B0aW9uc10oaHR0cHM6Ly9tb25nb29zZWpzLmNvbS9kb2NzL3BvcHVsYXRlLmh0bWwjcXVlcnktY29uZGl0aW9ucykuXG4gKlxuICogIyMjIyBFeGFtcGxlOlxuICpcbiAqICAgICBjb25zdCBzY2hlbWEgPSBuZXcgU2NoZW1hKHtcbiAqICAgICAgIGNoaWxkOiB7XG4gKiAgICAgICAgIHR5cGU6ICdPYmplY3RJZCcsXG4gKiAgICAgICAgIHJlZjogJ0NoaWxkJyxcbiAqICAgICAgICAgcG9wdWxhdGU6IHsgc2VsZWN0OiAnbmFtZScgfVxuICogICAgICAgfVxuICogICAgIH0pO1xuICogICAgIGNvbnN0IFBhcmVudCA9IG1vbmdvb3NlLm1vZGVsKCdQYXJlbnQnLCBzY2hlbWEpO1xuICpcbiAqICAgICAvLyBBdXRvbWF0aWNhbGx5IGFkZHMgYC5zZWxlY3QoJ25hbWUnKWBcbiAqICAgICBQYXJlbnQuZmluZE9uZSgpLnBvcHVsYXRlKCdjaGlsZCcpO1xuICpcbiAqIEBhcGkgcHVibGljXG4gKiBAcHJvcGVydHkgcG9wdWxhdGVcbiAqIEBtZW1iZXJPZiBTY2hlbWFPYmplY3RJZE9wdGlvbnNcbiAqIEB0eXBlIHtPYmplY3R9XG4gKiBAaW5zdGFuY2VcbiAqL1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoU2NoZW1hT2JqZWN0SWRPcHRpb25zLnByb3RvdHlwZSwgJ3BvcHVsYXRlJywgb3B0cyk7XG5cbi8qIVxuICogaWdub3JlXG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSBTY2hlbWFPYmplY3RJZE9wdGlvbnM7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/mongoose/lib/options/schemaObjectIdOptions.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/mongoose/lib/options/schemaStringOptions.js":
/*!******************************************************************!*\
  !*** ./node_modules/mongoose/lib/options/schemaStringOptions.js ***!
  \******************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\n\nconst SchemaTypeOptions = __webpack_require__(/*! ./schemaTypeOptions */ \"(ssr)/./node_modules/mongoose/lib/options/schemaTypeOptions.js\");\n\n/**\n * The options defined on a string schematype.\n *\n * #### Example:\n *\n *     const schema = new Schema({ name: String });\n *     schema.path('name').options; // SchemaStringOptions instance\n *\n * @api public\n * @inherits SchemaTypeOptions\n * @constructor SchemaStringOptions\n */\n\nclass SchemaStringOptions extends SchemaTypeOptions {}\n\nconst opts = __webpack_require__(/*! ./propertyOptions */ \"(ssr)/./node_modules/mongoose/lib/options/propertyOptions.js\");\n\n/**\n * Array of allowed values for this path\n *\n * @api public\n * @property enum\n * @memberOf SchemaStringOptions\n * @type {Array}\n * @instance\n */\n\nObject.defineProperty(SchemaStringOptions.prototype, 'enum', opts);\n\n/**\n * Attach a validator that succeeds if the data string matches the given regular\n * expression, and fails otherwise.\n *\n * @api public\n * @property match\n * @memberOf SchemaStringOptions\n * @type {RegExp}\n * @instance\n */\n\nObject.defineProperty(SchemaStringOptions.prototype, 'match', opts);\n\n/**\n * If truthy, Mongoose will add a custom setter that lowercases this string\n * using JavaScript's built-in `String#toLowerCase()`.\n *\n * @api public\n * @property lowercase\n * @memberOf SchemaStringOptions\n * @type {Boolean}\n * @instance\n */\n\nObject.defineProperty(SchemaStringOptions.prototype, 'lowercase', opts);\n\n/**\n * If truthy, Mongoose will add a custom setter that removes leading and trailing\n * whitespace using [JavaScript's built-in `String#trim()`](https://masteringjs.io/tutorials/fundamentals/trim-string).\n *\n * @api public\n * @property trim\n * @memberOf SchemaStringOptions\n * @type {Boolean}\n * @instance\n */\n\nObject.defineProperty(SchemaStringOptions.prototype, 'trim', opts);\n\n/**\n * If truthy, Mongoose will add a custom setter that uppercases this string\n * using JavaScript's built-in [`String#toUpperCase()`](https://masteringjs.io/tutorials/fundamentals/uppercase).\n *\n * @api public\n * @property uppercase\n * @memberOf SchemaStringOptions\n * @type {Boolean}\n * @instance\n */\n\nObject.defineProperty(SchemaStringOptions.prototype, 'uppercase', opts);\n\n/**\n * If set, Mongoose will add a custom validator that ensures the given\n * string's `length` is at least the given number.\n *\n * Mongoose supports two different spellings for this option: `minLength` and `minlength`.\n * `minLength` is the recommended way to specify this option, but Mongoose also supports\n * `minlength` (lowercase \"l\").\n *\n * @api public\n * @property minLength\n * @memberOf SchemaStringOptions\n * @type {Number}\n * @instance\n */\n\nObject.defineProperty(SchemaStringOptions.prototype, 'minLength', opts);\nObject.defineProperty(SchemaStringOptions.prototype, 'minlength', opts);\n\n/**\n * If set, Mongoose will add a custom validator that ensures the given\n * string's `length` is at most the given number.\n *\n * Mongoose supports two different spellings for this option: `maxLength` and `maxlength`.\n * `maxLength` is the recommended way to specify this option, but Mongoose also supports\n * `maxlength` (lowercase \"l\").\n *\n * @api public\n * @property maxLength\n * @memberOf SchemaStringOptions\n * @type {Number}\n * @instance\n */\n\nObject.defineProperty(SchemaStringOptions.prototype, 'maxLength', opts);\nObject.defineProperty(SchemaStringOptions.prototype, 'maxlength', opts);\n\n/**\n * Sets default [populate options](https://mongoosejs.com/docs/populate.html#query-conditions).\n *\n * @api public\n * @property populate\n * @memberOf SchemaStringOptions\n * @type {Object}\n * @instance\n */\n\nObject.defineProperty(SchemaStringOptions.prototype, 'populate', opts);\n\n/*!\n * ignore\n */\n\nmodule.exports = SchemaStringOptions;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbW9uZ29vc2UvbGliL29wdGlvbnMvc2NoZW1hU3RyaW5nT3B0aW9ucy5qcyIsIm1hcHBpbmdzIjoiQUFBYTs7QUFFYiwwQkFBMEIsbUJBQU8sQ0FBQywyRkFBcUI7O0FBRXZEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUMsY0FBYztBQUNqRCxvQ0FBb0M7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxhQUFhLG1CQUFPLENBQUMsdUZBQW1COztBQUV4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSIsInNvdXJjZXMiOlsid2VicGFjazovL2FwcDEvLi9ub2RlX21vZHVsZXMvbW9uZ29vc2UvbGliL29wdGlvbnMvc2NoZW1hU3RyaW5nT3B0aW9ucy5qcz9iZDRmIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxuY29uc3QgU2NoZW1hVHlwZU9wdGlvbnMgPSByZXF1aXJlKCcuL3NjaGVtYVR5cGVPcHRpb25zJyk7XG5cbi8qKlxuICogVGhlIG9wdGlvbnMgZGVmaW5lZCBvbiBhIHN0cmluZyBzY2hlbWF0eXBlLlxuICpcbiAqICMjIyMgRXhhbXBsZTpcbiAqXG4gKiAgICAgY29uc3Qgc2NoZW1hID0gbmV3IFNjaGVtYSh7IG5hbWU6IFN0cmluZyB9KTtcbiAqICAgICBzY2hlbWEucGF0aCgnbmFtZScpLm9wdGlvbnM7IC8vIFNjaGVtYVN0cmluZ09wdGlvbnMgaW5zdGFuY2VcbiAqXG4gKiBAYXBpIHB1YmxpY1xuICogQGluaGVyaXRzIFNjaGVtYVR5cGVPcHRpb25zXG4gKiBAY29uc3RydWN0b3IgU2NoZW1hU3RyaW5nT3B0aW9uc1xuICovXG5cbmNsYXNzIFNjaGVtYVN0cmluZ09wdGlvbnMgZXh0ZW5kcyBTY2hlbWFUeXBlT3B0aW9ucyB7fVxuXG5jb25zdCBvcHRzID0gcmVxdWlyZSgnLi9wcm9wZXJ0eU9wdGlvbnMnKTtcblxuLyoqXG4gKiBBcnJheSBvZiBhbGxvd2VkIHZhbHVlcyBmb3IgdGhpcyBwYXRoXG4gKlxuICogQGFwaSBwdWJsaWNcbiAqIEBwcm9wZXJ0eSBlbnVtXG4gKiBAbWVtYmVyT2YgU2NoZW1hU3RyaW5nT3B0aW9uc1xuICogQHR5cGUge0FycmF5fVxuICogQGluc3RhbmNlXG4gKi9cblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KFNjaGVtYVN0cmluZ09wdGlvbnMucHJvdG90eXBlLCAnZW51bScsIG9wdHMpO1xuXG4vKipcbiAqIEF0dGFjaCBhIHZhbGlkYXRvciB0aGF0IHN1Y2NlZWRzIGlmIHRoZSBkYXRhIHN0cmluZyBtYXRjaGVzIHRoZSBnaXZlbiByZWd1bGFyXG4gKiBleHByZXNzaW9uLCBhbmQgZmFpbHMgb3RoZXJ3aXNlLlxuICpcbiAqIEBhcGkgcHVibGljXG4gKiBAcHJvcGVydHkgbWF0Y2hcbiAqIEBtZW1iZXJPZiBTY2hlbWFTdHJpbmdPcHRpb25zXG4gKiBAdHlwZSB7UmVnRXhwfVxuICogQGluc3RhbmNlXG4gKi9cblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KFNjaGVtYVN0cmluZ09wdGlvbnMucHJvdG90eXBlLCAnbWF0Y2gnLCBvcHRzKTtcblxuLyoqXG4gKiBJZiB0cnV0aHksIE1vbmdvb3NlIHdpbGwgYWRkIGEgY3VzdG9tIHNldHRlciB0aGF0IGxvd2VyY2FzZXMgdGhpcyBzdHJpbmdcbiAqIHVzaW5nIEphdmFTY3JpcHQncyBidWlsdC1pbiBgU3RyaW5nI3RvTG93ZXJDYXNlKClgLlxuICpcbiAqIEBhcGkgcHVibGljXG4gKiBAcHJvcGVydHkgbG93ZXJjYXNlXG4gKiBAbWVtYmVyT2YgU2NoZW1hU3RyaW5nT3B0aW9uc1xuICogQHR5cGUge0Jvb2xlYW59XG4gKiBAaW5zdGFuY2VcbiAqL1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoU2NoZW1hU3RyaW5nT3B0aW9ucy5wcm90b3R5cGUsICdsb3dlcmNhc2UnLCBvcHRzKTtcblxuLyoqXG4gKiBJZiB0cnV0aHksIE1vbmdvb3NlIHdpbGwgYWRkIGEgY3VzdG9tIHNldHRlciB0aGF0IHJlbW92ZXMgbGVhZGluZyBhbmQgdHJhaWxpbmdcbiAqIHdoaXRlc3BhY2UgdXNpbmcgW0phdmFTY3JpcHQncyBidWlsdC1pbiBgU3RyaW5nI3RyaW0oKWBdKGh0dHBzOi8vbWFzdGVyaW5nanMuaW8vdHV0b3JpYWxzL2Z1bmRhbWVudGFscy90cmltLXN0cmluZykuXG4gKlxuICogQGFwaSBwdWJsaWNcbiAqIEBwcm9wZXJ0eSB0cmltXG4gKiBAbWVtYmVyT2YgU2NoZW1hU3RyaW5nT3B0aW9uc1xuICogQHR5cGUge0Jvb2xlYW59XG4gKiBAaW5zdGFuY2VcbiAqL1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoU2NoZW1hU3RyaW5nT3B0aW9ucy5wcm90b3R5cGUsICd0cmltJywgb3B0cyk7XG5cbi8qKlxuICogSWYgdHJ1dGh5LCBNb25nb29zZSB3aWxsIGFkZCBhIGN1c3RvbSBzZXR0ZXIgdGhhdCB1cHBlcmNhc2VzIHRoaXMgc3RyaW5nXG4gKiB1c2luZyBKYXZhU2NyaXB0J3MgYnVpbHQtaW4gW2BTdHJpbmcjdG9VcHBlckNhc2UoKWBdKGh0dHBzOi8vbWFzdGVyaW5nanMuaW8vdHV0b3JpYWxzL2Z1bmRhbWVudGFscy91cHBlcmNhc2UpLlxuICpcbiAqIEBhcGkgcHVibGljXG4gKiBAcHJvcGVydHkgdXBwZXJjYXNlXG4gKiBAbWVtYmVyT2YgU2NoZW1hU3RyaW5nT3B0aW9uc1xuICogQHR5cGUge0Jvb2xlYW59XG4gKiBAaW5zdGFuY2VcbiAqL1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoU2NoZW1hU3RyaW5nT3B0aW9ucy5wcm90b3R5cGUsICd1cHBlcmNhc2UnLCBvcHRzKTtcblxuLyoqXG4gKiBJZiBzZXQsIE1vbmdvb3NlIHdpbGwgYWRkIGEgY3VzdG9tIHZhbGlkYXRvciB0aGF0IGVuc3VyZXMgdGhlIGdpdmVuXG4gKiBzdHJpbmcncyBgbGVuZ3RoYCBpcyBhdCBsZWFzdCB0aGUgZ2l2ZW4gbnVtYmVyLlxuICpcbiAqIE1vbmdvb3NlIHN1cHBvcnRzIHR3byBkaWZmZXJlbnQgc3BlbGxpbmdzIGZvciB0aGlzIG9wdGlvbjogYG1pbkxlbmd0aGAgYW5kIGBtaW5sZW5ndGhgLlxuICogYG1pbkxlbmd0aGAgaXMgdGhlIHJlY29tbWVuZGVkIHdheSB0byBzcGVjaWZ5IHRoaXMgb3B0aW9uLCBidXQgTW9uZ29vc2UgYWxzbyBzdXBwb3J0c1xuICogYG1pbmxlbmd0aGAgKGxvd2VyY2FzZSBcImxcIikuXG4gKlxuICogQGFwaSBwdWJsaWNcbiAqIEBwcm9wZXJ0eSBtaW5MZW5ndGhcbiAqIEBtZW1iZXJPZiBTY2hlbWFTdHJpbmdPcHRpb25zXG4gKiBAdHlwZSB7TnVtYmVyfVxuICogQGluc3RhbmNlXG4gKi9cblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KFNjaGVtYVN0cmluZ09wdGlvbnMucHJvdG90eXBlLCAnbWluTGVuZ3RoJywgb3B0cyk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoU2NoZW1hU3RyaW5nT3B0aW9ucy5wcm90b3R5cGUsICdtaW5sZW5ndGgnLCBvcHRzKTtcblxuLyoqXG4gKiBJZiBzZXQsIE1vbmdvb3NlIHdpbGwgYWRkIGEgY3VzdG9tIHZhbGlkYXRvciB0aGF0IGVuc3VyZXMgdGhlIGdpdmVuXG4gKiBzdHJpbmcncyBgbGVuZ3RoYCBpcyBhdCBtb3N0IHRoZSBnaXZlbiBudW1iZXIuXG4gKlxuICogTW9uZ29vc2Ugc3VwcG9ydHMgdHdvIGRpZmZlcmVudCBzcGVsbGluZ3MgZm9yIHRoaXMgb3B0aW9uOiBgbWF4TGVuZ3RoYCBhbmQgYG1heGxlbmd0aGAuXG4gKiBgbWF4TGVuZ3RoYCBpcyB0aGUgcmVjb21tZW5kZWQgd2F5IHRvIHNwZWNpZnkgdGhpcyBvcHRpb24sIGJ1dCBNb25nb29zZSBhbHNvIHN1cHBvcnRzXG4gKiBgbWF4bGVuZ3RoYCAobG93ZXJjYXNlIFwibFwiKS5cbiAqXG4gKiBAYXBpIHB1YmxpY1xuICogQHByb3BlcnR5IG1heExlbmd0aFxuICogQG1lbWJlck9mIFNjaGVtYVN0cmluZ09wdGlvbnNcbiAqIEB0eXBlIHtOdW1iZXJ9XG4gKiBAaW5zdGFuY2VcbiAqL1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoU2NoZW1hU3RyaW5nT3B0aW9ucy5wcm90b3R5cGUsICdtYXhMZW5ndGgnLCBvcHRzKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShTY2hlbWFTdHJpbmdPcHRpb25zLnByb3RvdHlwZSwgJ21heGxlbmd0aCcsIG9wdHMpO1xuXG4vKipcbiAqIFNldHMgZGVmYXVsdCBbcG9wdWxhdGUgb3B0aW9uc10oaHR0cHM6Ly9tb25nb29zZWpzLmNvbS9kb2NzL3BvcHVsYXRlLmh0bWwjcXVlcnktY29uZGl0aW9ucykuXG4gKlxuICogQGFwaSBwdWJsaWNcbiAqIEBwcm9wZXJ0eSBwb3B1bGF0ZVxuICogQG1lbWJlck9mIFNjaGVtYVN0cmluZ09wdGlvbnNcbiAqIEB0eXBlIHtPYmplY3R9XG4gKiBAaW5zdGFuY2VcbiAqL1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoU2NoZW1hU3RyaW5nT3B0aW9ucy5wcm90b3R5cGUsICdwb3B1bGF0ZScsIG9wdHMpO1xuXG4vKiFcbiAqIGlnbm9yZVxuICovXG5cbm1vZHVsZS5leHBvcnRzID0gU2NoZW1hU3RyaW5nT3B0aW9ucztcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/mongoose/lib/options/schemaStringOptions.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/mongoose/lib/options/schemaSubdocumentOptions.js":
/*!***********************************************************************!*\
  !*** ./node_modules/mongoose/lib/options/schemaSubdocumentOptions.js ***!
  \***********************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\n\nconst SchemaTypeOptions = __webpack_require__(/*! ./schemaTypeOptions */ \"(ssr)/./node_modules/mongoose/lib/options/schemaTypeOptions.js\");\n\n/**\n * The options defined on a single nested schematype.\n *\n * #### Example:\n *\n *     const schema = Schema({ child: Schema({ name: String }) });\n *     schema.path('child').options; // SchemaSubdocumentOptions instance\n *\n * @api public\n * @inherits SchemaTypeOptions\n * @constructor SchemaSubdocumentOptions\n */\n\nclass SchemaSubdocumentOptions extends SchemaTypeOptions {}\n\nconst opts = __webpack_require__(/*! ./propertyOptions */ \"(ssr)/./node_modules/mongoose/lib/options/propertyOptions.js\");\n\n/**\n * If set, overwrites the child schema's `_id` option.\n *\n * #### Example:\n *\n *     const childSchema = Schema({ name: String });\n *     const parentSchema = Schema({\n *       child: { type: childSchema, _id: false }\n *     });\n *     parentSchema.path('child').schema.options._id; // false\n *\n * @api public\n * @property of\n * @memberOf SchemaSubdocumentOptions\n * @type {Function|string}\n * @instance\n */\n\nObject.defineProperty(SchemaSubdocumentOptions.prototype, '_id', opts);\n\nmodule.exports = SchemaSubdocumentOptions;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbW9uZ29vc2UvbGliL29wdGlvbnMvc2NoZW1hU3ViZG9jdW1lbnRPcHRpb25zLmpzIiwibWFwcGluZ3MiOiJBQUFhOztBQUViLDBCQUEwQixtQkFBTyxDQUFDLDJGQUFxQjs7QUFFdkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQixnQkFBZ0IsY0FBYyxHQUFHO0FBQ2hFLHFDQUFxQztBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBLGFBQWEsbUJBQU8sQ0FBQyx1RkFBbUI7O0FBRXhDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0MsY0FBYztBQUNsRDtBQUNBLGtCQUFrQjtBQUNsQixRQUFRO0FBQ1Isc0RBQXNEO0FBQ3REO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7O0FBRUE7O0FBRUEiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9hcHAxLy4vbm9kZV9tb2R1bGVzL21vbmdvb3NlL2xpYi9vcHRpb25zL3NjaGVtYVN1YmRvY3VtZW50T3B0aW9ucy5qcz9iMzVkIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxuY29uc3QgU2NoZW1hVHlwZU9wdGlvbnMgPSByZXF1aXJlKCcuL3NjaGVtYVR5cGVPcHRpb25zJyk7XG5cbi8qKlxuICogVGhlIG9wdGlvbnMgZGVmaW5lZCBvbiBhIHNpbmdsZSBuZXN0ZWQgc2NoZW1hdHlwZS5cbiAqXG4gKiAjIyMjIEV4YW1wbGU6XG4gKlxuICogICAgIGNvbnN0IHNjaGVtYSA9IFNjaGVtYSh7IGNoaWxkOiBTY2hlbWEoeyBuYW1lOiBTdHJpbmcgfSkgfSk7XG4gKiAgICAgc2NoZW1hLnBhdGgoJ2NoaWxkJykub3B0aW9uczsgLy8gU2NoZW1hU3ViZG9jdW1lbnRPcHRpb25zIGluc3RhbmNlXG4gKlxuICogQGFwaSBwdWJsaWNcbiAqIEBpbmhlcml0cyBTY2hlbWFUeXBlT3B0aW9uc1xuICogQGNvbnN0cnVjdG9yIFNjaGVtYVN1YmRvY3VtZW50T3B0aW9uc1xuICovXG5cbmNsYXNzIFNjaGVtYVN1YmRvY3VtZW50T3B0aW9ucyBleHRlbmRzIFNjaGVtYVR5cGVPcHRpb25zIHt9XG5cbmNvbnN0IG9wdHMgPSByZXF1aXJlKCcuL3Byb3BlcnR5T3B0aW9ucycpO1xuXG4vKipcbiAqIElmIHNldCwgb3ZlcndyaXRlcyB0aGUgY2hpbGQgc2NoZW1hJ3MgYF9pZGAgb3B0aW9uLlxuICpcbiAqICMjIyMgRXhhbXBsZTpcbiAqXG4gKiAgICAgY29uc3QgY2hpbGRTY2hlbWEgPSBTY2hlbWEoeyBuYW1lOiBTdHJpbmcgfSk7XG4gKiAgICAgY29uc3QgcGFyZW50U2NoZW1hID0gU2NoZW1hKHtcbiAqICAgICAgIGNoaWxkOiB7IHR5cGU6IGNoaWxkU2NoZW1hLCBfaWQ6IGZhbHNlIH1cbiAqICAgICB9KTtcbiAqICAgICBwYXJlbnRTY2hlbWEucGF0aCgnY2hpbGQnKS5zY2hlbWEub3B0aW9ucy5faWQ7IC8vIGZhbHNlXG4gKlxuICogQGFwaSBwdWJsaWNcbiAqIEBwcm9wZXJ0eSBvZlxuICogQG1lbWJlck9mIFNjaGVtYVN1YmRvY3VtZW50T3B0aW9uc1xuICogQHR5cGUge0Z1bmN0aW9ufHN0cmluZ31cbiAqIEBpbnN0YW5jZVxuICovXG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShTY2hlbWFTdWJkb2N1bWVudE9wdGlvbnMucHJvdG90eXBlLCAnX2lkJywgb3B0cyk7XG5cbm1vZHVsZS5leHBvcnRzID0gU2NoZW1hU3ViZG9jdW1lbnRPcHRpb25zO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/mongoose/lib/options/schemaSubdocumentOptions.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/mongoose/lib/options/schemaTypeOptions.js":
/*!****************************************************************!*\
  !*** ./node_modules/mongoose/lib/options/schemaTypeOptions.js ***!
  \****************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\n\nconst clone = __webpack_require__(/*! ../helpers/clone */ \"(ssr)/./node_modules/mongoose/lib/helpers/clone.js\");\n\n/**\n * The options defined on a schematype.\n *\n * #### Example:\n *\n *     const schema = new Schema({ name: String });\n *     schema.path('name').options instanceof mongoose.SchemaTypeOptions; // true\n *\n * @api public\n * @constructor SchemaTypeOptions\n */\n\nclass SchemaTypeOptions {\n  constructor(obj) {\n    if (obj == null) {\n      return this;\n    }\n    Object.assign(this, clone(obj));\n  }\n}\n\nconst opts = __webpack_require__(/*! ./propertyOptions */ \"(ssr)/./node_modules/mongoose/lib/options/propertyOptions.js\");\n\n/**\n * The type to cast this path to.\n *\n * @api public\n * @property type\n * @memberOf SchemaTypeOptions\n * @type {Function|String|Object}\n * @instance\n */\n\nObject.defineProperty(SchemaTypeOptions.prototype, 'type', opts);\n\n/**\n * Function or object describing how to validate this schematype.\n *\n * @api public\n * @property validate\n * @memberOf SchemaTypeOptions\n * @type {Function|Object}\n * @instance\n */\n\nObject.defineProperty(SchemaTypeOptions.prototype, 'validate', opts);\n\n/**\n * Allows overriding casting logic for this individual path. If a string, the\n * given string overwrites Mongoose's default cast error message.\n *\n * #### Example:\n *\n *     const schema = new Schema({\n *       num: {\n *         type: Number,\n *         cast: '{VALUE} is not a valid number'\n *       }\n *     });\n *\n *     // Throws 'CastError: \"bad\" is not a valid number'\n *     schema.path('num').cast('bad');\n *\n *     const Model = mongoose.model('Test', schema);\n *     const doc = new Model({ num: 'fail' });\n *     const err = doc.validateSync();\n *\n *     err.errors['num']; // 'CastError: \"fail\" is not a valid number'\n *\n * @api public\n * @property cast\n * @memberOf SchemaTypeOptions\n * @type {String}\n * @instance\n */\n\nObject.defineProperty(SchemaTypeOptions.prototype, 'cast', opts);\n\n/**\n * If true, attach a required validator to this path, which ensures this path\n * cannot be set to a nullish value. If a function, Mongoose calls the\n * function and only checks for nullish values if the function returns a truthy value.\n *\n * @api public\n * @property required\n * @memberOf SchemaTypeOptions\n * @type {Function|Boolean}\n * @instance\n */\n\nObject.defineProperty(SchemaTypeOptions.prototype, 'required', opts);\n\n/**\n * The default value for this path. If a function, Mongoose executes the function\n * and uses the return value as the default.\n *\n * @api public\n * @property default\n * @memberOf SchemaTypeOptions\n * @type {Function|Any}\n * @instance\n */\n\nObject.defineProperty(SchemaTypeOptions.prototype, 'default', opts);\n\n/**\n * The model that `populate()` should use if populating this path.\n *\n * @api public\n * @property ref\n * @memberOf SchemaTypeOptions\n * @type {Function|String}\n * @instance\n */\n\nObject.defineProperty(SchemaTypeOptions.prototype, 'ref', opts);\n\n/**\n * The path in the document that `populate()` should use to find the model\n * to use.\n *\n * @api public\n * @property ref\n * @memberOf SchemaTypeOptions\n * @type {Function|String}\n * @instance\n */\n\nObject.defineProperty(SchemaTypeOptions.prototype, 'refPath', opts);\n\n/**\n * Whether to include or exclude this path by default when loading documents\n * using `find()`, `findOne()`, etc.\n *\n * @api public\n * @property select\n * @memberOf SchemaTypeOptions\n * @type {Boolean|Number}\n * @instance\n */\n\nObject.defineProperty(SchemaTypeOptions.prototype, 'select', opts);\n\n/**\n * If [truthy](https://masteringjs.io/tutorials/fundamentals/truthy), Mongoose will\n * build an index on this path when the model is compiled.\n *\n * @api public\n * @property index\n * @memberOf SchemaTypeOptions\n * @type {Boolean|Number|Object}\n * @instance\n */\n\nObject.defineProperty(SchemaTypeOptions.prototype, 'index', opts);\n\n/**\n * If [truthy](https://masteringjs.io/tutorials/fundamentals/truthy), Mongoose\n * will build a unique index on this path when the\n * model is compiled. [The `unique` option is **not** a validator](https://mongoosejs.com/docs/validation.html#the-unique-option-is-not-a-validator).\n *\n * @api public\n * @property unique\n * @memberOf SchemaTypeOptions\n * @type {Boolean|Number}\n * @instance\n */\n\nObject.defineProperty(SchemaTypeOptions.prototype, 'unique', opts);\n\n/**\n * If [truthy](https://masteringjs.io/tutorials/fundamentals/truthy), Mongoose will\n * disallow changes to this path once the document\n * is saved to the database for the first time. Read more about [immutability in Mongoose here](https://thecodebarbarian.com/whats-new-in-mongoose-5-6-immutable-properties.html).\n *\n * @api public\n * @property immutable\n * @memberOf SchemaTypeOptions\n * @type {Function|Boolean}\n * @instance\n */\n\nObject.defineProperty(SchemaTypeOptions.prototype, 'immutable', opts);\n\n/**\n * If [truthy](https://masteringjs.io/tutorials/fundamentals/truthy), Mongoose will\n * build a sparse index on this path.\n *\n * @api public\n * @property sparse\n * @memberOf SchemaTypeOptions\n * @type {Boolean|Number}\n * @instance\n */\n\nObject.defineProperty(SchemaTypeOptions.prototype, 'sparse', opts);\n\n/**\n * If [truthy](https://masteringjs.io/tutorials/fundamentals/truthy), Mongoose\n * will build a text index on this path.\n *\n * @api public\n * @property text\n * @memberOf SchemaTypeOptions\n * @type {Boolean|Number|Object}\n * @instance\n */\n\nObject.defineProperty(SchemaTypeOptions.prototype, 'text', opts);\n\n/**\n * Define a transform function for this individual schema type.\n * Only called when calling `toJSON()` or `toObject()`.\n *\n * #### Example:\n *\n *     const schema = Schema({\n *       myDate: {\n *         type: Date,\n *         transform: v => v.getFullYear()\n *       }\n *     });\n *     const Model = mongoose.model('Test', schema);\n *\n *     const doc = new Model({ myDate: new Date('2019/06/01') });\n *     doc.myDate instanceof Date; // true\n *\n *     const res = doc.toObject({ transform: true });\n *     res.myDate; // 2019\n *\n * @api public\n * @property transform\n * @memberOf SchemaTypeOptions\n * @type {Function}\n * @instance\n */\n\nObject.defineProperty(SchemaTypeOptions.prototype, 'transform', opts);\n\nmodule.exports = SchemaTypeOptions;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbW9uZ29vc2UvbGliL29wdGlvbnMvc2NoZW1hVHlwZU9wdGlvbnMuanMiLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWIsY0FBYyxtQkFBTyxDQUFDLDRFQUFrQjs7QUFFeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQyxjQUFjO0FBQ2pELDBFQUEwRTtBQUMxRTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGFBQWEsbUJBQU8sQ0FBQyx1RkFBbUI7O0FBRXhDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixPQUFPO0FBQzFCO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0IsYUFBYTtBQUM1QztBQUNBO0FBQ0EsMEJBQTBCO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsK0JBQStCLGdDQUFnQztBQUMvRCxtQ0FBbUM7QUFDbkM7QUFDQSxrQ0FBa0MsaUJBQWlCO0FBQ25ELG1CQUFtQjtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBOztBQUVBOztBQUVBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vYXBwMS8uL25vZGVfbW9kdWxlcy9tb25nb29zZS9saWIvb3B0aW9ucy9zY2hlbWFUeXBlT3B0aW9ucy5qcz80NDVkIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxuY29uc3QgY2xvbmUgPSByZXF1aXJlKCcuLi9oZWxwZXJzL2Nsb25lJyk7XG5cbi8qKlxuICogVGhlIG9wdGlvbnMgZGVmaW5lZCBvbiBhIHNjaGVtYXR5cGUuXG4gKlxuICogIyMjIyBFeGFtcGxlOlxuICpcbiAqICAgICBjb25zdCBzY2hlbWEgPSBuZXcgU2NoZW1hKHsgbmFtZTogU3RyaW5nIH0pO1xuICogICAgIHNjaGVtYS5wYXRoKCduYW1lJykub3B0aW9ucyBpbnN0YW5jZW9mIG1vbmdvb3NlLlNjaGVtYVR5cGVPcHRpb25zOyAvLyB0cnVlXG4gKlxuICogQGFwaSBwdWJsaWNcbiAqIEBjb25zdHJ1Y3RvciBTY2hlbWFUeXBlT3B0aW9uc1xuICovXG5cbmNsYXNzIFNjaGVtYVR5cGVPcHRpb25zIHtcbiAgY29uc3RydWN0b3Iob2JqKSB7XG4gICAgaWYgKG9iaiA9PSBudWxsKSB7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgT2JqZWN0LmFzc2lnbih0aGlzLCBjbG9uZShvYmopKTtcbiAgfVxufVxuXG5jb25zdCBvcHRzID0gcmVxdWlyZSgnLi9wcm9wZXJ0eU9wdGlvbnMnKTtcblxuLyoqXG4gKiBUaGUgdHlwZSB0byBjYXN0IHRoaXMgcGF0aCB0by5cbiAqXG4gKiBAYXBpIHB1YmxpY1xuICogQHByb3BlcnR5IHR5cGVcbiAqIEBtZW1iZXJPZiBTY2hlbWFUeXBlT3B0aW9uc1xuICogQHR5cGUge0Z1bmN0aW9ufFN0cmluZ3xPYmplY3R9XG4gKiBAaW5zdGFuY2VcbiAqL1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoU2NoZW1hVHlwZU9wdGlvbnMucHJvdG90eXBlLCAndHlwZScsIG9wdHMpO1xuXG4vKipcbiAqIEZ1bmN0aW9uIG9yIG9iamVjdCBkZXNjcmliaW5nIGhvdyB0byB2YWxpZGF0ZSB0aGlzIHNjaGVtYXR5cGUuXG4gKlxuICogQGFwaSBwdWJsaWNcbiAqIEBwcm9wZXJ0eSB2YWxpZGF0ZVxuICogQG1lbWJlck9mIFNjaGVtYVR5cGVPcHRpb25zXG4gKiBAdHlwZSB7RnVuY3Rpb258T2JqZWN0fVxuICogQGluc3RhbmNlXG4gKi9cblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KFNjaGVtYVR5cGVPcHRpb25zLnByb3RvdHlwZSwgJ3ZhbGlkYXRlJywgb3B0cyk7XG5cbi8qKlxuICogQWxsb3dzIG92ZXJyaWRpbmcgY2FzdGluZyBsb2dpYyBmb3IgdGhpcyBpbmRpdmlkdWFsIHBhdGguIElmIGEgc3RyaW5nLCB0aGVcbiAqIGdpdmVuIHN0cmluZyBvdmVyd3JpdGVzIE1vbmdvb3NlJ3MgZGVmYXVsdCBjYXN0IGVycm9yIG1lc3NhZ2UuXG4gKlxuICogIyMjIyBFeGFtcGxlOlxuICpcbiAqICAgICBjb25zdCBzY2hlbWEgPSBuZXcgU2NoZW1hKHtcbiAqICAgICAgIG51bToge1xuICogICAgICAgICB0eXBlOiBOdW1iZXIsXG4gKiAgICAgICAgIGNhc3Q6ICd7VkFMVUV9IGlzIG5vdCBhIHZhbGlkIG51bWJlcidcbiAqICAgICAgIH1cbiAqICAgICB9KTtcbiAqXG4gKiAgICAgLy8gVGhyb3dzICdDYXN0RXJyb3I6IFwiYmFkXCIgaXMgbm90IGEgdmFsaWQgbnVtYmVyJ1xuICogICAgIHNjaGVtYS5wYXRoKCdudW0nKS5jYXN0KCdiYWQnKTtcbiAqXG4gKiAgICAgY29uc3QgTW9kZWwgPSBtb25nb29zZS5tb2RlbCgnVGVzdCcsIHNjaGVtYSk7XG4gKiAgICAgY29uc3QgZG9jID0gbmV3IE1vZGVsKHsgbnVtOiAnZmFpbCcgfSk7XG4gKiAgICAgY29uc3QgZXJyID0gZG9jLnZhbGlkYXRlU3luYygpO1xuICpcbiAqICAgICBlcnIuZXJyb3JzWydudW0nXTsgLy8gJ0Nhc3RFcnJvcjogXCJmYWlsXCIgaXMgbm90IGEgdmFsaWQgbnVtYmVyJ1xuICpcbiAqIEBhcGkgcHVibGljXG4gKiBAcHJvcGVydHkgY2FzdFxuICogQG1lbWJlck9mIFNjaGVtYVR5cGVPcHRpb25zXG4gKiBAdHlwZSB7U3RyaW5nfVxuICogQGluc3RhbmNlXG4gKi9cblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KFNjaGVtYVR5cGVPcHRpb25zLnByb3RvdHlwZSwgJ2Nhc3QnLCBvcHRzKTtcblxuLyoqXG4gKiBJZiB0cnVlLCBhdHRhY2ggYSByZXF1aXJlZCB2YWxpZGF0b3IgdG8gdGhpcyBwYXRoLCB3aGljaCBlbnN1cmVzIHRoaXMgcGF0aFxuICogY2Fubm90IGJlIHNldCB0byBhIG51bGxpc2ggdmFsdWUuIElmIGEgZnVuY3Rpb24sIE1vbmdvb3NlIGNhbGxzIHRoZVxuICogZnVuY3Rpb24gYW5kIG9ubHkgY2hlY2tzIGZvciBudWxsaXNoIHZhbHVlcyBpZiB0aGUgZnVuY3Rpb24gcmV0dXJucyBhIHRydXRoeSB2YWx1ZS5cbiAqXG4gKiBAYXBpIHB1YmxpY1xuICogQHByb3BlcnR5IHJlcXVpcmVkXG4gKiBAbWVtYmVyT2YgU2NoZW1hVHlwZU9wdGlvbnNcbiAqIEB0eXBlIHtGdW5jdGlvbnxCb29sZWFufVxuICogQGluc3RhbmNlXG4gKi9cblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KFNjaGVtYVR5cGVPcHRpb25zLnByb3RvdHlwZSwgJ3JlcXVpcmVkJywgb3B0cyk7XG5cbi8qKlxuICogVGhlIGRlZmF1bHQgdmFsdWUgZm9yIHRoaXMgcGF0aC4gSWYgYSBmdW5jdGlvbiwgTW9uZ29vc2UgZXhlY3V0ZXMgdGhlIGZ1bmN0aW9uXG4gKiBhbmQgdXNlcyB0aGUgcmV0dXJuIHZhbHVlIGFzIHRoZSBkZWZhdWx0LlxuICpcbiAqIEBhcGkgcHVibGljXG4gKiBAcHJvcGVydHkgZGVmYXVsdFxuICogQG1lbWJlck9mIFNjaGVtYVR5cGVPcHRpb25zXG4gKiBAdHlwZSB7RnVuY3Rpb258QW55fVxuICogQGluc3RhbmNlXG4gKi9cblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KFNjaGVtYVR5cGVPcHRpb25zLnByb3RvdHlwZSwgJ2RlZmF1bHQnLCBvcHRzKTtcblxuLyoqXG4gKiBUaGUgbW9kZWwgdGhhdCBgcG9wdWxhdGUoKWAgc2hvdWxkIHVzZSBpZiBwb3B1bGF0aW5nIHRoaXMgcGF0aC5cbiAqXG4gKiBAYXBpIHB1YmxpY1xuICogQHByb3BlcnR5IHJlZlxuICogQG1lbWJlck9mIFNjaGVtYVR5cGVPcHRpb25zXG4gKiBAdHlwZSB7RnVuY3Rpb258U3RyaW5nfVxuICogQGluc3RhbmNlXG4gKi9cblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KFNjaGVtYVR5cGVPcHRpb25zLnByb3RvdHlwZSwgJ3JlZicsIG9wdHMpO1xuXG4vKipcbiAqIFRoZSBwYXRoIGluIHRoZSBkb2N1bWVudCB0aGF0IGBwb3B1bGF0ZSgpYCBzaG91bGQgdXNlIHRvIGZpbmQgdGhlIG1vZGVsXG4gKiB0byB1c2UuXG4gKlxuICogQGFwaSBwdWJsaWNcbiAqIEBwcm9wZXJ0eSByZWZcbiAqIEBtZW1iZXJPZiBTY2hlbWFUeXBlT3B0aW9uc1xuICogQHR5cGUge0Z1bmN0aW9ufFN0cmluZ31cbiAqIEBpbnN0YW5jZVxuICovXG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShTY2hlbWFUeXBlT3B0aW9ucy5wcm90b3R5cGUsICdyZWZQYXRoJywgb3B0cyk7XG5cbi8qKlxuICogV2hldGhlciB0byBpbmNsdWRlIG9yIGV4Y2x1ZGUgdGhpcyBwYXRoIGJ5IGRlZmF1bHQgd2hlbiBsb2FkaW5nIGRvY3VtZW50c1xuICogdXNpbmcgYGZpbmQoKWAsIGBmaW5kT25lKClgLCBldGMuXG4gKlxuICogQGFwaSBwdWJsaWNcbiAqIEBwcm9wZXJ0eSBzZWxlY3RcbiAqIEBtZW1iZXJPZiBTY2hlbWFUeXBlT3B0aW9uc1xuICogQHR5cGUge0Jvb2xlYW58TnVtYmVyfVxuICogQGluc3RhbmNlXG4gKi9cblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KFNjaGVtYVR5cGVPcHRpb25zLnByb3RvdHlwZSwgJ3NlbGVjdCcsIG9wdHMpO1xuXG4vKipcbiAqIElmIFt0cnV0aHldKGh0dHBzOi8vbWFzdGVyaW5nanMuaW8vdHV0b3JpYWxzL2Z1bmRhbWVudGFscy90cnV0aHkpLCBNb25nb29zZSB3aWxsXG4gKiBidWlsZCBhbiBpbmRleCBvbiB0aGlzIHBhdGggd2hlbiB0aGUgbW9kZWwgaXMgY29tcGlsZWQuXG4gKlxuICogQGFwaSBwdWJsaWNcbiAqIEBwcm9wZXJ0eSBpbmRleFxuICogQG1lbWJlck9mIFNjaGVtYVR5cGVPcHRpb25zXG4gKiBAdHlwZSB7Qm9vbGVhbnxOdW1iZXJ8T2JqZWN0fVxuICogQGluc3RhbmNlXG4gKi9cblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KFNjaGVtYVR5cGVPcHRpb25zLnByb3RvdHlwZSwgJ2luZGV4Jywgb3B0cyk7XG5cbi8qKlxuICogSWYgW3RydXRoeV0oaHR0cHM6Ly9tYXN0ZXJpbmdqcy5pby90dXRvcmlhbHMvZnVuZGFtZW50YWxzL3RydXRoeSksIE1vbmdvb3NlXG4gKiB3aWxsIGJ1aWxkIGEgdW5pcXVlIGluZGV4IG9uIHRoaXMgcGF0aCB3aGVuIHRoZVxuICogbW9kZWwgaXMgY29tcGlsZWQuIFtUaGUgYHVuaXF1ZWAgb3B0aW9uIGlzICoqbm90KiogYSB2YWxpZGF0b3JdKGh0dHBzOi8vbW9uZ29vc2Vqcy5jb20vZG9jcy92YWxpZGF0aW9uLmh0bWwjdGhlLXVuaXF1ZS1vcHRpb24taXMtbm90LWEtdmFsaWRhdG9yKS5cbiAqXG4gKiBAYXBpIHB1YmxpY1xuICogQHByb3BlcnR5IHVuaXF1ZVxuICogQG1lbWJlck9mIFNjaGVtYVR5cGVPcHRpb25zXG4gKiBAdHlwZSB7Qm9vbGVhbnxOdW1iZXJ9XG4gKiBAaW5zdGFuY2VcbiAqL1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoU2NoZW1hVHlwZU9wdGlvbnMucHJvdG90eXBlLCAndW5pcXVlJywgb3B0cyk7XG5cbi8qKlxuICogSWYgW3RydXRoeV0oaHR0cHM6Ly9tYXN0ZXJpbmdqcy5pby90dXRvcmlhbHMvZnVuZGFtZW50YWxzL3RydXRoeSksIE1vbmdvb3NlIHdpbGxcbiAqIGRpc2FsbG93IGNoYW5nZXMgdG8gdGhpcyBwYXRoIG9uY2UgdGhlIGRvY3VtZW50XG4gKiBpcyBzYXZlZCB0byB0aGUgZGF0YWJhc2UgZm9yIHRoZSBmaXJzdCB0aW1lLiBSZWFkIG1vcmUgYWJvdXQgW2ltbXV0YWJpbGl0eSBpbiBNb25nb29zZSBoZXJlXShodHRwczovL3RoZWNvZGViYXJiYXJpYW4uY29tL3doYXRzLW5ldy1pbi1tb25nb29zZS01LTYtaW1tdXRhYmxlLXByb3BlcnRpZXMuaHRtbCkuXG4gKlxuICogQGFwaSBwdWJsaWNcbiAqIEBwcm9wZXJ0eSBpbW11dGFibGVcbiAqIEBtZW1iZXJPZiBTY2hlbWFUeXBlT3B0aW9uc1xuICogQHR5cGUge0Z1bmN0aW9ufEJvb2xlYW59XG4gKiBAaW5zdGFuY2VcbiAqL1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoU2NoZW1hVHlwZU9wdGlvbnMucHJvdG90eXBlLCAnaW1tdXRhYmxlJywgb3B0cyk7XG5cbi8qKlxuICogSWYgW3RydXRoeV0oaHR0cHM6Ly9tYXN0ZXJpbmdqcy5pby90dXRvcmlhbHMvZnVuZGFtZW50YWxzL3RydXRoeSksIE1vbmdvb3NlIHdpbGxcbiAqIGJ1aWxkIGEgc3BhcnNlIGluZGV4IG9uIHRoaXMgcGF0aC5cbiAqXG4gKiBAYXBpIHB1YmxpY1xuICogQHByb3BlcnR5IHNwYXJzZVxuICogQG1lbWJlck9mIFNjaGVtYVR5cGVPcHRpb25zXG4gKiBAdHlwZSB7Qm9vbGVhbnxOdW1iZXJ9XG4gKiBAaW5zdGFuY2VcbiAqL1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoU2NoZW1hVHlwZU9wdGlvbnMucHJvdG90eXBlLCAnc3BhcnNlJywgb3B0cyk7XG5cbi8qKlxuICogSWYgW3RydXRoeV0oaHR0cHM6Ly9tYXN0ZXJpbmdqcy5pby90dXRvcmlhbHMvZnVuZGFtZW50YWxzL3RydXRoeSksIE1vbmdvb3NlXG4gKiB3aWxsIGJ1aWxkIGEgdGV4dCBpbmRleCBvbiB0aGlzIHBhdGguXG4gKlxuICogQGFwaSBwdWJsaWNcbiAqIEBwcm9wZXJ0eSB0ZXh0XG4gKiBAbWVtYmVyT2YgU2NoZW1hVHlwZU9wdGlvbnNcbiAqIEB0eXBlIHtCb29sZWFufE51bWJlcnxPYmplY3R9XG4gKiBAaW5zdGFuY2VcbiAqL1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoU2NoZW1hVHlwZU9wdGlvbnMucHJvdG90eXBlLCAndGV4dCcsIG9wdHMpO1xuXG4vKipcbiAqIERlZmluZSBhIHRyYW5zZm9ybSBmdW5jdGlvbiBmb3IgdGhpcyBpbmRpdmlkdWFsIHNjaGVtYSB0eXBlLlxuICogT25seSBjYWxsZWQgd2hlbiBjYWxsaW5nIGB0b0pTT04oKWAgb3IgYHRvT2JqZWN0KClgLlxuICpcbiAqICMjIyMgRXhhbXBsZTpcbiAqXG4gKiAgICAgY29uc3Qgc2NoZW1hID0gU2NoZW1hKHtcbiAqICAgICAgIG15RGF0ZToge1xuICogICAgICAgICB0eXBlOiBEYXRlLFxuICogICAgICAgICB0cmFuc2Zvcm06IHYgPT4gdi5nZXRGdWxsWWVhcigpXG4gKiAgICAgICB9XG4gKiAgICAgfSk7XG4gKiAgICAgY29uc3QgTW9kZWwgPSBtb25nb29zZS5tb2RlbCgnVGVzdCcsIHNjaGVtYSk7XG4gKlxuICogICAgIGNvbnN0IGRvYyA9IG5ldyBNb2RlbCh7IG15RGF0ZTogbmV3IERhdGUoJzIwMTkvMDYvMDEnKSB9KTtcbiAqICAgICBkb2MubXlEYXRlIGluc3RhbmNlb2YgRGF0ZTsgLy8gdHJ1ZVxuICpcbiAqICAgICBjb25zdCByZXMgPSBkb2MudG9PYmplY3QoeyB0cmFuc2Zvcm06IHRydWUgfSk7XG4gKiAgICAgcmVzLm15RGF0ZTsgLy8gMjAxOVxuICpcbiAqIEBhcGkgcHVibGljXG4gKiBAcHJvcGVydHkgdHJhbnNmb3JtXG4gKiBAbWVtYmVyT2YgU2NoZW1hVHlwZU9wdGlvbnNcbiAqIEB0eXBlIHtGdW5jdGlvbn1cbiAqIEBpbnN0YW5jZVxuICovXG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShTY2hlbWFUeXBlT3B0aW9ucy5wcm90b3R5cGUsICd0cmFuc2Zvcm0nLCBvcHRzKTtcblxubW9kdWxlLmV4cG9ydHMgPSBTY2hlbWFUeXBlT3B0aW9ucztcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/mongoose/lib/options/schemaTypeOptions.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/mongoose/lib/options/virtualOptions.js":
/*!*************************************************************!*\
  !*** ./node_modules/mongoose/lib/options/virtualOptions.js ***!
  \*************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\n\nconst opts = __webpack_require__(/*! ./propertyOptions */ \"(ssr)/./node_modules/mongoose/lib/options/propertyOptions.js\");\n\nclass VirtualOptions {\n  constructor(obj) {\n    Object.assign(this, obj);\n\n    if (obj != null && obj.options != null) {\n      this.options = Object.assign({}, obj.options);\n    }\n  }\n}\n\n/**\n * Marks this virtual as a populate virtual, and specifies the model to\n * use for populate.\n *\n * @api public\n * @property ref\n * @memberOf VirtualOptions\n * @type {String|Model|Function}\n * @instance\n */\n\nObject.defineProperty(VirtualOptions.prototype, 'ref', opts);\n\n/**\n * Marks this virtual as a populate virtual, and specifies the path that\n * contains the name of the model to populate\n *\n * @api public\n * @property refPath\n * @memberOf VirtualOptions\n * @type {String|Function}\n * @instance\n */\n\nObject.defineProperty(VirtualOptions.prototype, 'refPath', opts);\n\n/**\n * The name of the property in the local model to match to `foreignField`\n * in the foreign model.\n *\n * @api public\n * @property localField\n * @memberOf VirtualOptions\n * @type {String|Function}\n * @instance\n */\n\nObject.defineProperty(VirtualOptions.prototype, 'localField', opts);\n\n/**\n * The name of the property in the foreign model to match to `localField`\n * in the local model.\n *\n * @api public\n * @property foreignField\n * @memberOf VirtualOptions\n * @type {String|Function}\n * @instance\n */\n\nObject.defineProperty(VirtualOptions.prototype, 'foreignField', opts);\n\n/**\n * Whether to populate this virtual as a single document (true) or an\n * array of documents (false).\n *\n * @api public\n * @property justOne\n * @memberOf VirtualOptions\n * @type {Boolean}\n * @instance\n */\n\nObject.defineProperty(VirtualOptions.prototype, 'justOne', opts);\n\n/**\n * If true, populate just the number of documents where `localField`\n * matches `foreignField`, as opposed to the documents themselves.\n *\n * If `count` is set, it overrides `justOne`.\n *\n * @api public\n * @property count\n * @memberOf VirtualOptions\n * @type {Boolean}\n * @instance\n */\n\nObject.defineProperty(VirtualOptions.prototype, 'count', opts);\n\n/**\n * Add an additional filter to populate, in addition to `localField`\n * matches `foreignField`.\n *\n * @api public\n * @property match\n * @memberOf VirtualOptions\n * @type {Object|Function}\n * @instance\n */\n\nObject.defineProperty(VirtualOptions.prototype, 'match', opts);\n\n/**\n * Additional options to pass to the query used to `populate()`:\n *\n * - `sort`\n * - `skip`\n * - `limit`\n *\n * @api public\n * @property options\n * @memberOf VirtualOptions\n * @type {Object}\n * @instance\n */\n\nObject.defineProperty(VirtualOptions.prototype, 'options', opts);\n\n/**\n * If true, add a `skip` to the query used to `populate()`.\n *\n * @api public\n * @property skip\n * @memberOf VirtualOptions\n * @type {Number}\n * @instance\n */\n\nObject.defineProperty(VirtualOptions.prototype, 'skip', opts);\n\n/**\n * If true, add a `limit` to the query used to `populate()`.\n *\n * @api public\n * @property limit\n * @memberOf VirtualOptions\n * @type {Number}\n * @instance\n */\n\nObject.defineProperty(VirtualOptions.prototype, 'limit', opts);\n\n/**\n * The `limit` option for `populate()` has [some unfortunate edge cases](https://mongoosejs.com/docs/populate.html#query-conditions)\n * when working with multiple documents, like `.find().populate()`. The\n * `perDocumentLimit` option makes `populate()` execute a separate query\n * for each document returned from `find()` to ensure each document\n * gets up to `perDocumentLimit` populated docs if possible.\n *\n * @api public\n * @property perDocumentLimit\n * @memberOf VirtualOptions\n * @type {Number}\n * @instance\n */\n\nObject.defineProperty(VirtualOptions.prototype, 'perDocumentLimit', opts);\n\nmodule.exports = VirtualOptions;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbW9uZ29vc2UvbGliL29wdGlvbnMvdmlydHVhbE9wdGlvbnMuanMiLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWIsYUFBYSxtQkFBTyxDQUFDLHVGQUFtQjs7QUFFeEM7QUFDQTtBQUNBOztBQUVBO0FBQ0EscUNBQXFDO0FBQ3JDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7O0FBRUE7O0FBRUEiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9hcHAxLy4vbm9kZV9tb2R1bGVzL21vbmdvb3NlL2xpYi9vcHRpb25zL3ZpcnR1YWxPcHRpb25zLmpzPzVkMzEiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG5jb25zdCBvcHRzID0gcmVxdWlyZSgnLi9wcm9wZXJ0eU9wdGlvbnMnKTtcblxuY2xhc3MgVmlydHVhbE9wdGlvbnMge1xuICBjb25zdHJ1Y3RvcihvYmopIHtcbiAgICBPYmplY3QuYXNzaWduKHRoaXMsIG9iaik7XG5cbiAgICBpZiAob2JqICE9IG51bGwgJiYgb2JqLm9wdGlvbnMgIT0gbnVsbCkge1xuICAgICAgdGhpcy5vcHRpb25zID0gT2JqZWN0LmFzc2lnbih7fSwgb2JqLm9wdGlvbnMpO1xuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIE1hcmtzIHRoaXMgdmlydHVhbCBhcyBhIHBvcHVsYXRlIHZpcnR1YWwsIGFuZCBzcGVjaWZpZXMgdGhlIG1vZGVsIHRvXG4gKiB1c2UgZm9yIHBvcHVsYXRlLlxuICpcbiAqIEBhcGkgcHVibGljXG4gKiBAcHJvcGVydHkgcmVmXG4gKiBAbWVtYmVyT2YgVmlydHVhbE9wdGlvbnNcbiAqIEB0eXBlIHtTdHJpbmd8TW9kZWx8RnVuY3Rpb259XG4gKiBAaW5zdGFuY2VcbiAqL1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoVmlydHVhbE9wdGlvbnMucHJvdG90eXBlLCAncmVmJywgb3B0cyk7XG5cbi8qKlxuICogTWFya3MgdGhpcyB2aXJ0dWFsIGFzIGEgcG9wdWxhdGUgdmlydHVhbCwgYW5kIHNwZWNpZmllcyB0aGUgcGF0aCB0aGF0XG4gKiBjb250YWlucyB0aGUgbmFtZSBvZiB0aGUgbW9kZWwgdG8gcG9wdWxhdGVcbiAqXG4gKiBAYXBpIHB1YmxpY1xuICogQHByb3BlcnR5IHJlZlBhdGhcbiAqIEBtZW1iZXJPZiBWaXJ0dWFsT3B0aW9uc1xuICogQHR5cGUge1N0cmluZ3xGdW5jdGlvbn1cbiAqIEBpbnN0YW5jZVxuICovXG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShWaXJ0dWFsT3B0aW9ucy5wcm90b3R5cGUsICdyZWZQYXRoJywgb3B0cyk7XG5cbi8qKlxuICogVGhlIG5hbWUgb2YgdGhlIHByb3BlcnR5IGluIHRoZSBsb2NhbCBtb2RlbCB0byBtYXRjaCB0byBgZm9yZWlnbkZpZWxkYFxuICogaW4gdGhlIGZvcmVpZ24gbW9kZWwuXG4gKlxuICogQGFwaSBwdWJsaWNcbiAqIEBwcm9wZXJ0eSBsb2NhbEZpZWxkXG4gKiBAbWVtYmVyT2YgVmlydHVhbE9wdGlvbnNcbiAqIEB0eXBlIHtTdHJpbmd8RnVuY3Rpb259XG4gKiBAaW5zdGFuY2VcbiAqL1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoVmlydHVhbE9wdGlvbnMucHJvdG90eXBlLCAnbG9jYWxGaWVsZCcsIG9wdHMpO1xuXG4vKipcbiAqIFRoZSBuYW1lIG9mIHRoZSBwcm9wZXJ0eSBpbiB0aGUgZm9yZWlnbiBtb2RlbCB0byBtYXRjaCB0byBgbG9jYWxGaWVsZGBcbiAqIGluIHRoZSBsb2NhbCBtb2RlbC5cbiAqXG4gKiBAYXBpIHB1YmxpY1xuICogQHByb3BlcnR5IGZvcmVpZ25GaWVsZFxuICogQG1lbWJlck9mIFZpcnR1YWxPcHRpb25zXG4gKiBAdHlwZSB7U3RyaW5nfEZ1bmN0aW9ufVxuICogQGluc3RhbmNlXG4gKi9cblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KFZpcnR1YWxPcHRpb25zLnByb3RvdHlwZSwgJ2ZvcmVpZ25GaWVsZCcsIG9wdHMpO1xuXG4vKipcbiAqIFdoZXRoZXIgdG8gcG9wdWxhdGUgdGhpcyB2aXJ0dWFsIGFzIGEgc2luZ2xlIGRvY3VtZW50ICh0cnVlKSBvciBhblxuICogYXJyYXkgb2YgZG9jdW1lbnRzIChmYWxzZSkuXG4gKlxuICogQGFwaSBwdWJsaWNcbiAqIEBwcm9wZXJ0eSBqdXN0T25lXG4gKiBAbWVtYmVyT2YgVmlydHVhbE9wdGlvbnNcbiAqIEB0eXBlIHtCb29sZWFufVxuICogQGluc3RhbmNlXG4gKi9cblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KFZpcnR1YWxPcHRpb25zLnByb3RvdHlwZSwgJ2p1c3RPbmUnLCBvcHRzKTtcblxuLyoqXG4gKiBJZiB0cnVlLCBwb3B1bGF0ZSBqdXN0IHRoZSBudW1iZXIgb2YgZG9jdW1lbnRzIHdoZXJlIGBsb2NhbEZpZWxkYFxuICogbWF0Y2hlcyBgZm9yZWlnbkZpZWxkYCwgYXMgb3Bwb3NlZCB0byB0aGUgZG9jdW1lbnRzIHRoZW1zZWx2ZXMuXG4gKlxuICogSWYgYGNvdW50YCBpcyBzZXQsIGl0IG92ZXJyaWRlcyBganVzdE9uZWAuXG4gKlxuICogQGFwaSBwdWJsaWNcbiAqIEBwcm9wZXJ0eSBjb3VudFxuICogQG1lbWJlck9mIFZpcnR1YWxPcHRpb25zXG4gKiBAdHlwZSB7Qm9vbGVhbn1cbiAqIEBpbnN0YW5jZVxuICovXG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShWaXJ0dWFsT3B0aW9ucy5wcm90b3R5cGUsICdjb3VudCcsIG9wdHMpO1xuXG4vKipcbiAqIEFkZCBhbiBhZGRpdGlvbmFsIGZpbHRlciB0byBwb3B1bGF0ZSwgaW4gYWRkaXRpb24gdG8gYGxvY2FsRmllbGRgXG4gKiBtYXRjaGVzIGBmb3JlaWduRmllbGRgLlxuICpcbiAqIEBhcGkgcHVibGljXG4gKiBAcHJvcGVydHkgbWF0Y2hcbiAqIEBtZW1iZXJPZiBWaXJ0dWFsT3B0aW9uc1xuICogQHR5cGUge09iamVjdHxGdW5jdGlvbn1cbiAqIEBpbnN0YW5jZVxuICovXG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShWaXJ0dWFsT3B0aW9ucy5wcm90b3R5cGUsICdtYXRjaCcsIG9wdHMpO1xuXG4vKipcbiAqIEFkZGl0aW9uYWwgb3B0aW9ucyB0byBwYXNzIHRvIHRoZSBxdWVyeSB1c2VkIHRvIGBwb3B1bGF0ZSgpYDpcbiAqXG4gKiAtIGBzb3J0YFxuICogLSBgc2tpcGBcbiAqIC0gYGxpbWl0YFxuICpcbiAqIEBhcGkgcHVibGljXG4gKiBAcHJvcGVydHkgb3B0aW9uc1xuICogQG1lbWJlck9mIFZpcnR1YWxPcHRpb25zXG4gKiBAdHlwZSB7T2JqZWN0fVxuICogQGluc3RhbmNlXG4gKi9cblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KFZpcnR1YWxPcHRpb25zLnByb3RvdHlwZSwgJ29wdGlvbnMnLCBvcHRzKTtcblxuLyoqXG4gKiBJZiB0cnVlLCBhZGQgYSBgc2tpcGAgdG8gdGhlIHF1ZXJ5IHVzZWQgdG8gYHBvcHVsYXRlKClgLlxuICpcbiAqIEBhcGkgcHVibGljXG4gKiBAcHJvcGVydHkgc2tpcFxuICogQG1lbWJlck9mIFZpcnR1YWxPcHRpb25zXG4gKiBAdHlwZSB7TnVtYmVyfVxuICogQGluc3RhbmNlXG4gKi9cblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KFZpcnR1YWxPcHRpb25zLnByb3RvdHlwZSwgJ3NraXAnLCBvcHRzKTtcblxuLyoqXG4gKiBJZiB0cnVlLCBhZGQgYSBgbGltaXRgIHRvIHRoZSBxdWVyeSB1c2VkIHRvIGBwb3B1bGF0ZSgpYC5cbiAqXG4gKiBAYXBpIHB1YmxpY1xuICogQHByb3BlcnR5IGxpbWl0XG4gKiBAbWVtYmVyT2YgVmlydHVhbE9wdGlvbnNcbiAqIEB0eXBlIHtOdW1iZXJ9XG4gKiBAaW5zdGFuY2VcbiAqL1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoVmlydHVhbE9wdGlvbnMucHJvdG90eXBlLCAnbGltaXQnLCBvcHRzKTtcblxuLyoqXG4gKiBUaGUgYGxpbWl0YCBvcHRpb24gZm9yIGBwb3B1bGF0ZSgpYCBoYXMgW3NvbWUgdW5mb3J0dW5hdGUgZWRnZSBjYXNlc10oaHR0cHM6Ly9tb25nb29zZWpzLmNvbS9kb2NzL3BvcHVsYXRlLmh0bWwjcXVlcnktY29uZGl0aW9ucylcbiAqIHdoZW4gd29ya2luZyB3aXRoIG11bHRpcGxlIGRvY3VtZW50cywgbGlrZSBgLmZpbmQoKS5wb3B1bGF0ZSgpYC4gVGhlXG4gKiBgcGVyRG9jdW1lbnRMaW1pdGAgb3B0aW9uIG1ha2VzIGBwb3B1bGF0ZSgpYCBleGVjdXRlIGEgc2VwYXJhdGUgcXVlcnlcbiAqIGZvciBlYWNoIGRvY3VtZW50IHJldHVybmVkIGZyb20gYGZpbmQoKWAgdG8gZW5zdXJlIGVhY2ggZG9jdW1lbnRcbiAqIGdldHMgdXAgdG8gYHBlckRvY3VtZW50TGltaXRgIHBvcHVsYXRlZCBkb2NzIGlmIHBvc3NpYmxlLlxuICpcbiAqIEBhcGkgcHVibGljXG4gKiBAcHJvcGVydHkgcGVyRG9jdW1lbnRMaW1pdFxuICogQG1lbWJlck9mIFZpcnR1YWxPcHRpb25zXG4gKiBAdHlwZSB7TnVtYmVyfVxuICogQGluc3RhbmNlXG4gKi9cblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KFZpcnR1YWxPcHRpb25zLnByb3RvdHlwZSwgJ3BlckRvY3VtZW50TGltaXQnLCBvcHRzKTtcblxubW9kdWxlLmV4cG9ydHMgPSBWaXJ0dWFsT3B0aW9ucztcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/mongoose/lib/options/virtualOptions.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/mongoose/lib/plugins/index.js":
/*!****************************************************!*\
  !*** ./node_modules/mongoose/lib/plugins/index.js ***!
  \****************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n\nexports.saveSubdocs = __webpack_require__(/*! ./saveSubdocs */ \"(ssr)/./node_modules/mongoose/lib/plugins/saveSubdocs.js\");\nexports.sharding = __webpack_require__(/*! ./sharding */ \"(ssr)/./node_modules/mongoose/lib/plugins/sharding.js\");\nexports.trackTransaction = __webpack_require__(/*! ./trackTransaction */ \"(ssr)/./node_modules/mongoose/lib/plugins/trackTransaction.js\");\nexports.validateBeforeSave = __webpack_require__(/*! ./validateBeforeSave */ \"(ssr)/./node_modules/mongoose/lib/plugins/validateBeforeSave.js\");\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbW9uZ29vc2UvbGliL3BsdWdpbnMvaW5kZXguanMiLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWIsMEhBQThDO0FBQzlDLGlIQUF3QztBQUN4Qyx5SUFBd0Q7QUFDeEQsK0lBQTREIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vYXBwMS8uL25vZGVfbW9kdWxlcy9tb25nb29zZS9saWIvcGx1Z2lucy9pbmRleC5qcz9hMTBlIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxuZXhwb3J0cy5zYXZlU3ViZG9jcyA9IHJlcXVpcmUoJy4vc2F2ZVN1YmRvY3MnKTtcbmV4cG9ydHMuc2hhcmRpbmcgPSByZXF1aXJlKCcuL3NoYXJkaW5nJyk7XG5leHBvcnRzLnRyYWNrVHJhbnNhY3Rpb24gPSByZXF1aXJlKCcuL3RyYWNrVHJhbnNhY3Rpb24nKTtcbmV4cG9ydHMudmFsaWRhdGVCZWZvcmVTYXZlID0gcmVxdWlyZSgnLi92YWxpZGF0ZUJlZm9yZVNhdmUnKTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/mongoose/lib/plugins/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/mongoose/lib/plugins/saveSubdocs.js":
/*!**********************************************************!*\
  !*** ./node_modules/mongoose/lib/plugins/saveSubdocs.js ***!
  \**********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\n\nconst each = __webpack_require__(/*! ../helpers/each */ \"(ssr)/./node_modules/mongoose/lib/helpers/each.js\");\n\n/*!\n * ignore\n */\n\nmodule.exports = function saveSubdocs(schema) {\n  const unshift = true;\n  schema.s.hooks.pre('save', false, function saveSubdocsPreSave(next) {\n    if (this.$isSubdocument) {\n      next();\n      return;\n    }\n\n    const _this = this;\n    const subdocs = this.$getAllSubdocs();\n\n    if (!subdocs.length) {\n      next();\n      return;\n    }\n\n    each(subdocs, function(subdoc, cb) {\n      subdoc.$__schema.s.hooks.execPre('save', subdoc, function(err) {\n        cb(err);\n      });\n    }, function(error) {\n      if (error) {\n        return _this.$__schema.s.hooks.execPost('save:error', _this, [_this], { error: error }, function(error) {\n          next(error);\n        });\n      }\n      next();\n    });\n  }, null, unshift);\n\n  schema.s.hooks.post('save', function saveSubdocsPostSave(doc, next) {\n    if (this.$isSubdocument) {\n      next();\n      return;\n    }\n\n    const _this = this;\n    const subdocs = this.$getAllSubdocs();\n\n    if (!subdocs.length) {\n      next();\n      return;\n    }\n\n    each(subdocs, function(subdoc, cb) {\n      subdoc.$__schema.s.hooks.execPost('save', subdoc, [subdoc], function(err) {\n        cb(err);\n      });\n    }, function(error) {\n      if (error) {\n        return _this.$__schema.s.hooks.execPost('save:error', _this, [_this], { error: error }, function(error) {\n          next(error);\n        });\n      }\n      next();\n    });\n  }, null, unshift);\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbW9uZ29vc2UvbGliL3BsdWdpbnMvc2F2ZVN1YmRvY3MuanMiLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWIsYUFBYSxtQkFBTyxDQUFDLDBFQUFpQjs7QUFFdEM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTDtBQUNBLGdGQUFnRixjQUFjO0FBQzlGO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTDtBQUNBLGdGQUFnRixjQUFjO0FBQzlGO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNIIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vYXBwMS8uL25vZGVfbW9kdWxlcy9tb25nb29zZS9saWIvcGx1Z2lucy9zYXZlU3ViZG9jcy5qcz9lZmNmIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxuY29uc3QgZWFjaCA9IHJlcXVpcmUoJy4uL2hlbHBlcnMvZWFjaCcpO1xuXG4vKiFcbiAqIGlnbm9yZVxuICovXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gc2F2ZVN1YmRvY3Moc2NoZW1hKSB7XG4gIGNvbnN0IHVuc2hpZnQgPSB0cnVlO1xuICBzY2hlbWEucy5ob29rcy5wcmUoJ3NhdmUnLCBmYWxzZSwgZnVuY3Rpb24gc2F2ZVN1YmRvY3NQcmVTYXZlKG5leHQpIHtcbiAgICBpZiAodGhpcy4kaXNTdWJkb2N1bWVudCkge1xuICAgICAgbmV4dCgpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGNvbnN0IF90aGlzID0gdGhpcztcbiAgICBjb25zdCBzdWJkb2NzID0gdGhpcy4kZ2V0QWxsU3ViZG9jcygpO1xuXG4gICAgaWYgKCFzdWJkb2NzLmxlbmd0aCkge1xuICAgICAgbmV4dCgpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGVhY2goc3ViZG9jcywgZnVuY3Rpb24oc3ViZG9jLCBjYikge1xuICAgICAgc3ViZG9jLiRfX3NjaGVtYS5zLmhvb2tzLmV4ZWNQcmUoJ3NhdmUnLCBzdWJkb2MsIGZ1bmN0aW9uKGVycikge1xuICAgICAgICBjYihlcnIpO1xuICAgICAgfSk7XG4gICAgfSwgZnVuY3Rpb24oZXJyb3IpIHtcbiAgICAgIGlmIChlcnJvcikge1xuICAgICAgICByZXR1cm4gX3RoaXMuJF9fc2NoZW1hLnMuaG9va3MuZXhlY1Bvc3QoJ3NhdmU6ZXJyb3InLCBfdGhpcywgW190aGlzXSwgeyBlcnJvcjogZXJyb3IgfSwgZnVuY3Rpb24oZXJyb3IpIHtcbiAgICAgICAgICBuZXh0KGVycm9yKTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICBuZXh0KCk7XG4gICAgfSk7XG4gIH0sIG51bGwsIHVuc2hpZnQpO1xuXG4gIHNjaGVtYS5zLmhvb2tzLnBvc3QoJ3NhdmUnLCBmdW5jdGlvbiBzYXZlU3ViZG9jc1Bvc3RTYXZlKGRvYywgbmV4dCkge1xuICAgIGlmICh0aGlzLiRpc1N1YmRvY3VtZW50KSB7XG4gICAgICBuZXh0KCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgY29uc3QgX3RoaXMgPSB0aGlzO1xuICAgIGNvbnN0IHN1YmRvY3MgPSB0aGlzLiRnZXRBbGxTdWJkb2NzKCk7XG5cbiAgICBpZiAoIXN1YmRvY3MubGVuZ3RoKSB7XG4gICAgICBuZXh0KCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgZWFjaChzdWJkb2NzLCBmdW5jdGlvbihzdWJkb2MsIGNiKSB7XG4gICAgICBzdWJkb2MuJF9fc2NoZW1hLnMuaG9va3MuZXhlY1Bvc3QoJ3NhdmUnLCBzdWJkb2MsIFtzdWJkb2NdLCBmdW5jdGlvbihlcnIpIHtcbiAgICAgICAgY2IoZXJyKTtcbiAgICAgIH0pO1xuICAgIH0sIGZ1bmN0aW9uKGVycm9yKSB7XG4gICAgICBpZiAoZXJyb3IpIHtcbiAgICAgICAgcmV0dXJuIF90aGlzLiRfX3NjaGVtYS5zLmhvb2tzLmV4ZWNQb3N0KCdzYXZlOmVycm9yJywgX3RoaXMsIFtfdGhpc10sIHsgZXJyb3I6IGVycm9yIH0sIGZ1bmN0aW9uKGVycm9yKSB7XG4gICAgICAgICAgbmV4dChlcnJvcik7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgbmV4dCgpO1xuICAgIH0pO1xuICB9LCBudWxsLCB1bnNoaWZ0KTtcbn07XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/mongoose/lib/plugins/saveSubdocs.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/mongoose/lib/plugins/sharding.js":
/*!*******************************************************!*\
  !*** ./node_modules/mongoose/lib/plugins/sharding.js ***!
  \*******************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\n\nconst objectIdSymbol = (__webpack_require__(/*! ../helpers/symbols */ \"(ssr)/./node_modules/mongoose/lib/helpers/symbols.js\").objectIdSymbol);\nconst utils = __webpack_require__(/*! ../utils */ \"(ssr)/./node_modules/mongoose/lib/utils.js\");\n\n/*!\n * ignore\n */\n\nmodule.exports = function shardingPlugin(schema) {\n  schema.post('init', function shardingPluginPostInit() {\n    storeShard.call(this);\n    return this;\n  });\n  schema.pre('save', function shardingPluginPreSave(next) {\n    applyWhere.call(this);\n    next();\n  });\n  schema.pre('remove', function shardingPluginPreRemove(next) {\n    applyWhere.call(this);\n    next();\n  });\n  schema.post('save', function shardingPluginPostSave() {\n    storeShard.call(this);\n  });\n};\n\n/*!\n * ignore\n */\n\nfunction applyWhere() {\n  let paths;\n  let len;\n\n  if (this.$__.shardval) {\n    paths = Object.keys(this.$__.shardval);\n    len = paths.length;\n\n    this.$where = this.$where || {};\n    for (let i = 0; i < len; ++i) {\n      this.$where[paths[i]] = this.$__.shardval[paths[i]];\n    }\n  }\n}\n\n/*!\n * ignore\n */\n\nmodule.exports.storeShard = storeShard;\n\n/*!\n * ignore\n */\n\nfunction storeShard() {\n  // backwards compat\n  const key = this.$__schema.options.shardKey || this.$__schema.options.shardkey;\n  if (!utils.isPOJO(key)) {\n    return;\n  }\n\n  const orig = this.$__.shardval = {};\n  const paths = Object.keys(key);\n  const len = paths.length;\n  let val;\n\n  for (let i = 0; i < len; ++i) {\n    val = this.$__getValue(paths[i]);\n    if (val == null) {\n      orig[paths[i]] = val;\n    } else if (utils.isMongooseObject(val)) {\n      orig[paths[i]] = val.toObject({ depopulate: true, _isNested: true });\n    } else if (val instanceof Date || val[objectIdSymbol]) {\n      orig[paths[i]] = val;\n    } else if (typeof val.valueOf === 'function') {\n      orig[paths[i]] = val.valueOf();\n    } else {\n      orig[paths[i]] = val;\n    }\n  }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbW9uZ29vc2UvbGliL3BsdWdpbnMvc2hhcmRpbmcuanMiLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWIsdUJBQXVCLHNIQUE0QztBQUNuRSxjQUFjLG1CQUFPLENBQUMsNERBQVU7O0FBRWhDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxvQkFBb0IsU0FBUztBQUM3QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEseUJBQXlCOztBQUV6QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGtCQUFrQixTQUFTO0FBQzNCO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTixzQ0FBc0MsbUNBQW1DO0FBQ3pFLE1BQU07QUFDTjtBQUNBLE1BQU07QUFDTjtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL2FwcDEvLi9ub2RlX21vZHVsZXMvbW9uZ29vc2UvbGliL3BsdWdpbnMvc2hhcmRpbmcuanM/MDI5ZiJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbmNvbnN0IG9iamVjdElkU3ltYm9sID0gcmVxdWlyZSgnLi4vaGVscGVycy9zeW1ib2xzJykub2JqZWN0SWRTeW1ib2w7XG5jb25zdCB1dGlscyA9IHJlcXVpcmUoJy4uL3V0aWxzJyk7XG5cbi8qIVxuICogaWdub3JlXG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBzaGFyZGluZ1BsdWdpbihzY2hlbWEpIHtcbiAgc2NoZW1hLnBvc3QoJ2luaXQnLCBmdW5jdGlvbiBzaGFyZGluZ1BsdWdpblBvc3RJbml0KCkge1xuICAgIHN0b3JlU2hhcmQuY2FsbCh0aGlzKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfSk7XG4gIHNjaGVtYS5wcmUoJ3NhdmUnLCBmdW5jdGlvbiBzaGFyZGluZ1BsdWdpblByZVNhdmUobmV4dCkge1xuICAgIGFwcGx5V2hlcmUuY2FsbCh0aGlzKTtcbiAgICBuZXh0KCk7XG4gIH0pO1xuICBzY2hlbWEucHJlKCdyZW1vdmUnLCBmdW5jdGlvbiBzaGFyZGluZ1BsdWdpblByZVJlbW92ZShuZXh0KSB7XG4gICAgYXBwbHlXaGVyZS5jYWxsKHRoaXMpO1xuICAgIG5leHQoKTtcbiAgfSk7XG4gIHNjaGVtYS5wb3N0KCdzYXZlJywgZnVuY3Rpb24gc2hhcmRpbmdQbHVnaW5Qb3N0U2F2ZSgpIHtcbiAgICBzdG9yZVNoYXJkLmNhbGwodGhpcyk7XG4gIH0pO1xufTtcblxuLyohXG4gKiBpZ25vcmVcbiAqL1xuXG5mdW5jdGlvbiBhcHBseVdoZXJlKCkge1xuICBsZXQgcGF0aHM7XG4gIGxldCBsZW47XG5cbiAgaWYgKHRoaXMuJF9fLnNoYXJkdmFsKSB7XG4gICAgcGF0aHMgPSBPYmplY3Qua2V5cyh0aGlzLiRfXy5zaGFyZHZhbCk7XG4gICAgbGVuID0gcGF0aHMubGVuZ3RoO1xuXG4gICAgdGhpcy4kd2hlcmUgPSB0aGlzLiR3aGVyZSB8fCB7fTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbjsgKytpKSB7XG4gICAgICB0aGlzLiR3aGVyZVtwYXRoc1tpXV0gPSB0aGlzLiRfXy5zaGFyZHZhbFtwYXRoc1tpXV07XG4gICAgfVxuICB9XG59XG5cbi8qIVxuICogaWdub3JlXG4gKi9cblxubW9kdWxlLmV4cG9ydHMuc3RvcmVTaGFyZCA9IHN0b3JlU2hhcmQ7XG5cbi8qIVxuICogaWdub3JlXG4gKi9cblxuZnVuY3Rpb24gc3RvcmVTaGFyZCgpIHtcbiAgLy8gYmFja3dhcmRzIGNvbXBhdFxuICBjb25zdCBrZXkgPSB0aGlzLiRfX3NjaGVtYS5vcHRpb25zLnNoYXJkS2V5IHx8IHRoaXMuJF9fc2NoZW1hLm9wdGlvbnMuc2hhcmRrZXk7XG4gIGlmICghdXRpbHMuaXNQT0pPKGtleSkpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICBjb25zdCBvcmlnID0gdGhpcy4kX18uc2hhcmR2YWwgPSB7fTtcbiAgY29uc3QgcGF0aHMgPSBPYmplY3Qua2V5cyhrZXkpO1xuICBjb25zdCBsZW4gPSBwYXRocy5sZW5ndGg7XG4gIGxldCB2YWw7XG5cbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZW47ICsraSkge1xuICAgIHZhbCA9IHRoaXMuJF9fZ2V0VmFsdWUocGF0aHNbaV0pO1xuICAgIGlmICh2YWwgPT0gbnVsbCkge1xuICAgICAgb3JpZ1twYXRoc1tpXV0gPSB2YWw7XG4gICAgfSBlbHNlIGlmICh1dGlscy5pc01vbmdvb3NlT2JqZWN0KHZhbCkpIHtcbiAgICAgIG9yaWdbcGF0aHNbaV1dID0gdmFsLnRvT2JqZWN0KHsgZGVwb3B1bGF0ZTogdHJ1ZSwgX2lzTmVzdGVkOiB0cnVlIH0pO1xuICAgIH0gZWxzZSBpZiAodmFsIGluc3RhbmNlb2YgRGF0ZSB8fCB2YWxbb2JqZWN0SWRTeW1ib2xdKSB7XG4gICAgICBvcmlnW3BhdGhzW2ldXSA9IHZhbDtcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiB2YWwudmFsdWVPZiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgb3JpZ1twYXRoc1tpXV0gPSB2YWwudmFsdWVPZigpO1xuICAgIH0gZWxzZSB7XG4gICAgICBvcmlnW3BhdGhzW2ldXSA9IHZhbDtcbiAgICB9XG4gIH1cbn1cbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/mongoose/lib/plugins/sharding.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/mongoose/lib/plugins/trackTransaction.js":
/*!***************************************************************!*\
  !*** ./node_modules/mongoose/lib/plugins/trackTransaction.js ***!
  \***************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\n\nconst arrayAtomicsSymbol = (__webpack_require__(/*! ../helpers/symbols */ \"(ssr)/./node_modules/mongoose/lib/helpers/symbols.js\").arrayAtomicsSymbol);\nconst sessionNewDocuments = (__webpack_require__(/*! ../helpers/symbols */ \"(ssr)/./node_modules/mongoose/lib/helpers/symbols.js\").sessionNewDocuments);\nconst utils = __webpack_require__(/*! ../utils */ \"(ssr)/./node_modules/mongoose/lib/utils.js\");\n\nmodule.exports = function trackTransaction(schema) {\n  schema.pre('save', function trackTransactionPreSave() {\n    const session = this.$session();\n    if (session == null) {\n      return;\n    }\n    if (session.transaction == null || session[sessionNewDocuments] == null) {\n      return;\n    }\n\n    if (!session[sessionNewDocuments].has(this)) {\n      const initialState = {};\n      if (this.isNew) {\n        initialState.isNew = true;\n      }\n      if (this.$__schema.options.versionKey) {\n        initialState.versionKey = this.get(this.$__schema.options.versionKey);\n      }\n\n      initialState.modifiedPaths = new Set(Object.keys(this.$__.activePaths.getStatePaths('modify')));\n      initialState.atomics = _getAtomics(this);\n\n      session[sessionNewDocuments].set(this, initialState);\n    } else {\n      const state = session[sessionNewDocuments].get(this);\n\n      for (const path of Object.keys(this.$__.activePaths.getStatePaths('modify'))) {\n        state.modifiedPaths.add(path);\n      }\n      state.atomics = _getAtomics(this, state.atomics);\n    }\n  });\n};\n\nfunction _getAtomics(doc, previous) {\n  const pathToAtomics = new Map();\n  previous = previous || new Map();\n\n  const pathsToCheck = Object.keys(doc.$__.activePaths.init).concat(Object.keys(doc.$__.activePaths.modify));\n\n  for (const path of pathsToCheck) {\n    const val = doc.$__getValue(path);\n    if (val != null &&\n        Array.isArray(val) &&\n        utils.isMongooseDocumentArray(val) &&\n        val.length &&\n        val[arrayAtomicsSymbol] != null &&\n        Object.keys(val[arrayAtomicsSymbol]).length !== 0) {\n      const existing = previous.get(path) || {};\n      pathToAtomics.set(path, mergeAtomics(existing, val[arrayAtomicsSymbol]));\n    }\n  }\n\n  const dirty = doc.$__dirty();\n  for (const dirt of dirty) {\n    const path = dirt.path;\n\n    const val = dirt.value;\n    if (val != null && val[arrayAtomicsSymbol] != null && Object.keys(val[arrayAtomicsSymbol]).length !== 0) {\n      const existing = previous.get(path) || {};\n      pathToAtomics.set(path, mergeAtomics(existing, val[arrayAtomicsSymbol]));\n    }\n  }\n\n  return pathToAtomics;\n}\n\nfunction mergeAtomics(destination, source) {\n  destination = destination || {};\n\n  if (source.$pullAll != null) {\n    destination.$pullAll = (destination.$pullAll || []).concat(source.$pullAll);\n  }\n  if (source.$push != null) {\n    destination.$push = destination.$push || {};\n    destination.$push.$each = (destination.$push.$each || []).concat(source.$push.$each);\n  }\n  if (source.$addToSet != null) {\n    destination.$addToSet = (destination.$addToSet || []).concat(source.$addToSet);\n  }\n  if (source.$set != null) {\n    destination.$set = Object.assign(destination.$set || {}, source.$set);\n  }\n\n  return destination;\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbW9uZ29vc2UvbGliL3BsdWdpbnMvdHJhY2tUcmFuc2FjdGlvbi5qcyIsIm1hcHBpbmdzIjoiQUFBYTs7QUFFYiwyQkFBMkIsMEhBQWdEO0FBQzNFLDRCQUE0QiwySEFBaUQ7QUFDN0UsY0FBYyxtQkFBTyxDQUFDLDREQUFVOztBQUVoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsTUFBTTtBQUNOOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkRBQTJEO0FBQzNEOztBQUVBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9hcHAxLy4vbm9kZV9tb2R1bGVzL21vbmdvb3NlL2xpYi9wbHVnaW5zL3RyYWNrVHJhbnNhY3Rpb24uanM/YjAxNiJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbmNvbnN0IGFycmF5QXRvbWljc1N5bWJvbCA9IHJlcXVpcmUoJy4uL2hlbHBlcnMvc3ltYm9scycpLmFycmF5QXRvbWljc1N5bWJvbDtcbmNvbnN0IHNlc3Npb25OZXdEb2N1bWVudHMgPSByZXF1aXJlKCcuLi9oZWxwZXJzL3N5bWJvbHMnKS5zZXNzaW9uTmV3RG9jdW1lbnRzO1xuY29uc3QgdXRpbHMgPSByZXF1aXJlKCcuLi91dGlscycpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIHRyYWNrVHJhbnNhY3Rpb24oc2NoZW1hKSB7XG4gIHNjaGVtYS5wcmUoJ3NhdmUnLCBmdW5jdGlvbiB0cmFja1RyYW5zYWN0aW9uUHJlU2F2ZSgpIHtcbiAgICBjb25zdCBzZXNzaW9uID0gdGhpcy4kc2Vzc2lvbigpO1xuICAgIGlmIChzZXNzaW9uID09IG51bGwpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKHNlc3Npb24udHJhbnNhY3Rpb24gPT0gbnVsbCB8fCBzZXNzaW9uW3Nlc3Npb25OZXdEb2N1bWVudHNdID09IG51bGwpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAoIXNlc3Npb25bc2Vzc2lvbk5ld0RvY3VtZW50c10uaGFzKHRoaXMpKSB7XG4gICAgICBjb25zdCBpbml0aWFsU3RhdGUgPSB7fTtcbiAgICAgIGlmICh0aGlzLmlzTmV3KSB7XG4gICAgICAgIGluaXRpYWxTdGF0ZS5pc05ldyA9IHRydWU7XG4gICAgICB9XG4gICAgICBpZiAodGhpcy4kX19zY2hlbWEub3B0aW9ucy52ZXJzaW9uS2V5KSB7XG4gICAgICAgIGluaXRpYWxTdGF0ZS52ZXJzaW9uS2V5ID0gdGhpcy5nZXQodGhpcy4kX19zY2hlbWEub3B0aW9ucy52ZXJzaW9uS2V5KTtcbiAgICAgIH1cblxuICAgICAgaW5pdGlhbFN0YXRlLm1vZGlmaWVkUGF0aHMgPSBuZXcgU2V0KE9iamVjdC5rZXlzKHRoaXMuJF9fLmFjdGl2ZVBhdGhzLmdldFN0YXRlUGF0aHMoJ21vZGlmeScpKSk7XG4gICAgICBpbml0aWFsU3RhdGUuYXRvbWljcyA9IF9nZXRBdG9taWNzKHRoaXMpO1xuXG4gICAgICBzZXNzaW9uW3Nlc3Npb25OZXdEb2N1bWVudHNdLnNldCh0aGlzLCBpbml0aWFsU3RhdGUpO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCBzdGF0ZSA9IHNlc3Npb25bc2Vzc2lvbk5ld0RvY3VtZW50c10uZ2V0KHRoaXMpO1xuXG4gICAgICBmb3IgKGNvbnN0IHBhdGggb2YgT2JqZWN0LmtleXModGhpcy4kX18uYWN0aXZlUGF0aHMuZ2V0U3RhdGVQYXRocygnbW9kaWZ5JykpKSB7XG4gICAgICAgIHN0YXRlLm1vZGlmaWVkUGF0aHMuYWRkKHBhdGgpO1xuICAgICAgfVxuICAgICAgc3RhdGUuYXRvbWljcyA9IF9nZXRBdG9taWNzKHRoaXMsIHN0YXRlLmF0b21pY3MpO1xuICAgIH1cbiAgfSk7XG59O1xuXG5mdW5jdGlvbiBfZ2V0QXRvbWljcyhkb2MsIHByZXZpb3VzKSB7XG4gIGNvbnN0IHBhdGhUb0F0b21pY3MgPSBuZXcgTWFwKCk7XG4gIHByZXZpb3VzID0gcHJldmlvdXMgfHwgbmV3IE1hcCgpO1xuXG4gIGNvbnN0IHBhdGhzVG9DaGVjayA9IE9iamVjdC5rZXlzKGRvYy4kX18uYWN0aXZlUGF0aHMuaW5pdCkuY29uY2F0KE9iamVjdC5rZXlzKGRvYy4kX18uYWN0aXZlUGF0aHMubW9kaWZ5KSk7XG5cbiAgZm9yIChjb25zdCBwYXRoIG9mIHBhdGhzVG9DaGVjaykge1xuICAgIGNvbnN0IHZhbCA9IGRvYy4kX19nZXRWYWx1ZShwYXRoKTtcbiAgICBpZiAodmFsICE9IG51bGwgJiZcbiAgICAgICAgQXJyYXkuaXNBcnJheSh2YWwpICYmXG4gICAgICAgIHV0aWxzLmlzTW9uZ29vc2VEb2N1bWVudEFycmF5KHZhbCkgJiZcbiAgICAgICAgdmFsLmxlbmd0aCAmJlxuICAgICAgICB2YWxbYXJyYXlBdG9taWNzU3ltYm9sXSAhPSBudWxsICYmXG4gICAgICAgIE9iamVjdC5rZXlzKHZhbFthcnJheUF0b21pY3NTeW1ib2xdKS5sZW5ndGggIT09IDApIHtcbiAgICAgIGNvbnN0IGV4aXN0aW5nID0gcHJldmlvdXMuZ2V0KHBhdGgpIHx8IHt9O1xuICAgICAgcGF0aFRvQXRvbWljcy5zZXQocGF0aCwgbWVyZ2VBdG9taWNzKGV4aXN0aW5nLCB2YWxbYXJyYXlBdG9taWNzU3ltYm9sXSkpO1xuICAgIH1cbiAgfVxuXG4gIGNvbnN0IGRpcnR5ID0gZG9jLiRfX2RpcnR5KCk7XG4gIGZvciAoY29uc3QgZGlydCBvZiBkaXJ0eSkge1xuICAgIGNvbnN0IHBhdGggPSBkaXJ0LnBhdGg7XG5cbiAgICBjb25zdCB2YWwgPSBkaXJ0LnZhbHVlO1xuICAgIGlmICh2YWwgIT0gbnVsbCAmJiB2YWxbYXJyYXlBdG9taWNzU3ltYm9sXSAhPSBudWxsICYmIE9iamVjdC5rZXlzKHZhbFthcnJheUF0b21pY3NTeW1ib2xdKS5sZW5ndGggIT09IDApIHtcbiAgICAgIGNvbnN0IGV4aXN0aW5nID0gcHJldmlvdXMuZ2V0KHBhdGgpIHx8IHt9O1xuICAgICAgcGF0aFRvQXRvbWljcy5zZXQocGF0aCwgbWVyZ2VBdG9taWNzKGV4aXN0aW5nLCB2YWxbYXJyYXlBdG9taWNzU3ltYm9sXSkpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBwYXRoVG9BdG9taWNzO1xufVxuXG5mdW5jdGlvbiBtZXJnZUF0b21pY3MoZGVzdGluYXRpb24sIHNvdXJjZSkge1xuICBkZXN0aW5hdGlvbiA9IGRlc3RpbmF0aW9uIHx8IHt9O1xuXG4gIGlmIChzb3VyY2UuJHB1bGxBbGwgIT0gbnVsbCkge1xuICAgIGRlc3RpbmF0aW9uLiRwdWxsQWxsID0gKGRlc3RpbmF0aW9uLiRwdWxsQWxsIHx8IFtdKS5jb25jYXQoc291cmNlLiRwdWxsQWxsKTtcbiAgfVxuICBpZiAoc291cmNlLiRwdXNoICE9IG51bGwpIHtcbiAgICBkZXN0aW5hdGlvbi4kcHVzaCA9IGRlc3RpbmF0aW9uLiRwdXNoIHx8IHt9O1xuICAgIGRlc3RpbmF0aW9uLiRwdXNoLiRlYWNoID0gKGRlc3RpbmF0aW9uLiRwdXNoLiRlYWNoIHx8IFtdKS5jb25jYXQoc291cmNlLiRwdXNoLiRlYWNoKTtcbiAgfVxuICBpZiAoc291cmNlLiRhZGRUb1NldCAhPSBudWxsKSB7XG4gICAgZGVzdGluYXRpb24uJGFkZFRvU2V0ID0gKGRlc3RpbmF0aW9uLiRhZGRUb1NldCB8fCBbXSkuY29uY2F0KHNvdXJjZS4kYWRkVG9TZXQpO1xuICB9XG4gIGlmIChzb3VyY2UuJHNldCAhPSBudWxsKSB7XG4gICAgZGVzdGluYXRpb24uJHNldCA9IE9iamVjdC5hc3NpZ24oZGVzdGluYXRpb24uJHNldCB8fCB7fSwgc291cmNlLiRzZXQpO1xuICB9XG5cbiAgcmV0dXJuIGRlc3RpbmF0aW9uO1xufVxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/mongoose/lib/plugins/trackTransaction.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/mongoose/lib/plugins/validateBeforeSave.js":
/*!*****************************************************************!*\
  !*** ./node_modules/mongoose/lib/plugins/validateBeforeSave.js ***!
  \*****************************************************************/
/***/ ((module) => {

eval("\n\n/*!\n * ignore\n */\n\nmodule.exports = function validateBeforeSave(schema) {\n  const unshift = true;\n  schema.pre('save', false, function validateBeforeSave(next, options) {\n    const _this = this;\n    // Nested docs have their own presave\n    if (this.$isSubdocument) {\n      return next();\n    }\n\n    const hasValidateBeforeSaveOption = options &&\n        (typeof options === 'object') &&\n        ('validateBeforeSave' in options);\n\n    let shouldValidate;\n    if (hasValidateBeforeSaveOption) {\n      shouldValidate = !!options.validateBeforeSave;\n    } else {\n      shouldValidate = this.$__schema.options.validateBeforeSave;\n    }\n\n    // Validate\n    if (shouldValidate) {\n      const hasValidateModifiedOnlyOption = options &&\n          (typeof options === 'object') &&\n          ('validateModifiedOnly' in options);\n      const validateOptions = hasValidateModifiedOnlyOption ?\n        { validateModifiedOnly: options.validateModifiedOnly } :\n        null;\n      this.$validate(validateOptions).then(\n        () => {\n          this.$op = 'save';\n          next();\n        },\n        error => {\n          _this.$__schema.s.hooks.execPost('save:error', _this, [_this], { error: error }, function(error) {\n            _this.$op = 'save';\n            next(error);\n          });\n        }\n      );\n    } else {\n      next();\n    }\n  }, null, unshift);\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbW9uZ29vc2UvbGliL3BsdWdpbnMvdmFsaWRhdGVCZWZvcmVTYXZlLmpzIiwibWFwcGluZ3MiOiJBQUFhOztBQUViO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVLHFEQUFxRDtBQUMvRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsMkVBQTJFLGNBQWM7QUFDekY7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxHQUFHO0FBQ0giLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9hcHAxLy4vbm9kZV9tb2R1bGVzL21vbmdvb3NlL2xpYi9wbHVnaW5zL3ZhbGlkYXRlQmVmb3JlU2F2ZS5qcz9lNTg5Il0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxuLyohXG4gKiBpZ25vcmVcbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIHZhbGlkYXRlQmVmb3JlU2F2ZShzY2hlbWEpIHtcbiAgY29uc3QgdW5zaGlmdCA9IHRydWU7XG4gIHNjaGVtYS5wcmUoJ3NhdmUnLCBmYWxzZSwgZnVuY3Rpb24gdmFsaWRhdGVCZWZvcmVTYXZlKG5leHQsIG9wdGlvbnMpIHtcbiAgICBjb25zdCBfdGhpcyA9IHRoaXM7XG4gICAgLy8gTmVzdGVkIGRvY3MgaGF2ZSB0aGVpciBvd24gcHJlc2F2ZVxuICAgIGlmICh0aGlzLiRpc1N1YmRvY3VtZW50KSB7XG4gICAgICByZXR1cm4gbmV4dCgpO1xuICAgIH1cblxuICAgIGNvbnN0IGhhc1ZhbGlkYXRlQmVmb3JlU2F2ZU9wdGlvbiA9IG9wdGlvbnMgJiZcbiAgICAgICAgKHR5cGVvZiBvcHRpb25zID09PSAnb2JqZWN0JykgJiZcbiAgICAgICAgKCd2YWxpZGF0ZUJlZm9yZVNhdmUnIGluIG9wdGlvbnMpO1xuXG4gICAgbGV0IHNob3VsZFZhbGlkYXRlO1xuICAgIGlmIChoYXNWYWxpZGF0ZUJlZm9yZVNhdmVPcHRpb24pIHtcbiAgICAgIHNob3VsZFZhbGlkYXRlID0gISFvcHRpb25zLnZhbGlkYXRlQmVmb3JlU2F2ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgc2hvdWxkVmFsaWRhdGUgPSB0aGlzLiRfX3NjaGVtYS5vcHRpb25zLnZhbGlkYXRlQmVmb3JlU2F2ZTtcbiAgICB9XG5cbiAgICAvLyBWYWxpZGF0ZVxuICAgIGlmIChzaG91bGRWYWxpZGF0ZSkge1xuICAgICAgY29uc3QgaGFzVmFsaWRhdGVNb2RpZmllZE9ubHlPcHRpb24gPSBvcHRpb25zICYmXG4gICAgICAgICAgKHR5cGVvZiBvcHRpb25zID09PSAnb2JqZWN0JykgJiZcbiAgICAgICAgICAoJ3ZhbGlkYXRlTW9kaWZpZWRPbmx5JyBpbiBvcHRpb25zKTtcbiAgICAgIGNvbnN0IHZhbGlkYXRlT3B0aW9ucyA9IGhhc1ZhbGlkYXRlTW9kaWZpZWRPbmx5T3B0aW9uID9cbiAgICAgICAgeyB2YWxpZGF0ZU1vZGlmaWVkT25seTogb3B0aW9ucy52YWxpZGF0ZU1vZGlmaWVkT25seSB9IDpcbiAgICAgICAgbnVsbDtcbiAgICAgIHRoaXMuJHZhbGlkYXRlKHZhbGlkYXRlT3B0aW9ucykudGhlbihcbiAgICAgICAgKCkgPT4ge1xuICAgICAgICAgIHRoaXMuJG9wID0gJ3NhdmUnO1xuICAgICAgICAgIG5leHQoKTtcbiAgICAgICAgfSxcbiAgICAgICAgZXJyb3IgPT4ge1xuICAgICAgICAgIF90aGlzLiRfX3NjaGVtYS5zLmhvb2tzLmV4ZWNQb3N0KCdzYXZlOmVycm9yJywgX3RoaXMsIFtfdGhpc10sIHsgZXJyb3I6IGVycm9yIH0sIGZ1bmN0aW9uKGVycm9yKSB7XG4gICAgICAgICAgICBfdGhpcy4kb3AgPSAnc2F2ZSc7XG4gICAgICAgICAgICBuZXh0KGVycm9yKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgKTtcbiAgICB9IGVsc2Uge1xuICAgICAgbmV4dCgpO1xuICAgIH1cbiAgfSwgbnVsbCwgdW5zaGlmdCk7XG59O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/mongoose/lib/plugins/validateBeforeSave.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/mongoose/lib/query.js":
/*!********************************************!*\
  !*** ./node_modules/mongoose/lib/query.js ***!
  \********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\n\n/*!\n * Module dependencies.\n */\n\nconst CastError = __webpack_require__(/*! ./error/cast */ \"(ssr)/./node_modules/mongoose/lib/error/cast.js\");\nconst DocumentNotFoundError = __webpack_require__(/*! ./error/notFound */ \"(ssr)/./node_modules/mongoose/lib/error/notFound.js\");\nconst Kareem = __webpack_require__(/*! kareem */ \"(ssr)/./node_modules/kareem/index.js\");\nconst MongooseError = __webpack_require__(/*! ./error/mongooseError */ \"(ssr)/./node_modules/mongoose/lib/error/mongooseError.js\");\nconst ObjectParameterError = __webpack_require__(/*! ./error/objectParameter */ \"(ssr)/./node_modules/mongoose/lib/error/objectParameter.js\");\nconst QueryCursor = __webpack_require__(/*! ./cursor/queryCursor */ \"(ssr)/./node_modules/mongoose/lib/cursor/queryCursor.js\");\nconst ValidationError = __webpack_require__(/*! ./error/validation */ \"(ssr)/./node_modules/mongoose/lib/error/validation.js\");\nconst { applyGlobalMaxTimeMS, applyGlobalDiskUse } = __webpack_require__(/*! ./helpers/query/applyGlobalOption */ \"(ssr)/./node_modules/mongoose/lib/helpers/query/applyGlobalOption.js\");\nconst handleReadPreferenceAliases = __webpack_require__(/*! ./helpers/query/handleReadPreferenceAliases */ \"(ssr)/./node_modules/mongoose/lib/helpers/query/handleReadPreferenceAliases.js\");\nconst applyWriteConcern = __webpack_require__(/*! ./helpers/schema/applyWriteConcern */ \"(ssr)/./node_modules/mongoose/lib/helpers/schema/applyWriteConcern.js\");\nconst cast = __webpack_require__(/*! ./cast */ \"(ssr)/./node_modules/mongoose/lib/cast.js\");\nconst castArrayFilters = __webpack_require__(/*! ./helpers/update/castArrayFilters */ \"(ssr)/./node_modules/mongoose/lib/helpers/update/castArrayFilters.js\");\nconst castNumber = __webpack_require__(/*! ./cast/number */ \"(ssr)/./node_modules/mongoose/lib/cast/number.js\");\nconst castUpdate = __webpack_require__(/*! ./helpers/query/castUpdate */ \"(ssr)/./node_modules/mongoose/lib/helpers/query/castUpdate.js\");\nconst clone = __webpack_require__(/*! ./helpers/clone */ \"(ssr)/./node_modules/mongoose/lib/helpers/clone.js\");\nconst completeMany = __webpack_require__(/*! ./helpers/query/completeMany */ \"(ssr)/./node_modules/mongoose/lib/helpers/query/completeMany.js\");\nconst getDiscriminatorByValue = __webpack_require__(/*! ./helpers/discriminator/getDiscriminatorByValue */ \"(ssr)/./node_modules/mongoose/lib/helpers/discriminator/getDiscriminatorByValue.js\");\nconst helpers = __webpack_require__(/*! ./queryHelpers */ \"(ssr)/./node_modules/mongoose/lib/queryHelpers.js\");\nconst immediate = __webpack_require__(/*! ./helpers/immediate */ \"(ssr)/./node_modules/mongoose/lib/helpers/immediate.js\");\nconst internalToObjectOptions = (__webpack_require__(/*! ./options */ \"(ssr)/./node_modules/mongoose/lib/options.js\").internalToObjectOptions);\nconst isExclusive = __webpack_require__(/*! ./helpers/projection/isExclusive */ \"(ssr)/./node_modules/mongoose/lib/helpers/projection/isExclusive.js\");\nconst isInclusive = __webpack_require__(/*! ./helpers/projection/isInclusive */ \"(ssr)/./node_modules/mongoose/lib/helpers/projection/isInclusive.js\");\nconst isPathSelectedInclusive = __webpack_require__(/*! ./helpers/projection/isPathSelectedInclusive */ \"(ssr)/./node_modules/mongoose/lib/helpers/projection/isPathSelectedInclusive.js\");\nconst isSubpath = __webpack_require__(/*! ./helpers/projection/isSubpath */ \"(ssr)/./node_modules/mongoose/lib/helpers/projection/isSubpath.js\");\nconst mpath = __webpack_require__(/*! mpath */ \"(ssr)/./node_modules/mpath/index.js\");\nconst mquery = __webpack_require__(/*! mquery */ \"(ssr)/./node_modules/mquery/lib/mquery.js\");\nconst parseProjection = __webpack_require__(/*! ./helpers/projection/parseProjection */ \"(ssr)/./node_modules/mongoose/lib/helpers/projection/parseProjection.js\");\nconst removeUnusedArrayFilters = __webpack_require__(/*! ./helpers/update/removeUnusedArrayFilters */ \"(ssr)/./node_modules/mongoose/lib/helpers/update/removeUnusedArrayFilters.js\");\nconst sanitizeFilter = __webpack_require__(/*! ./helpers/query/sanitizeFilter */ \"(ssr)/./node_modules/mongoose/lib/helpers/query/sanitizeFilter.js\");\nconst sanitizeProjection = __webpack_require__(/*! ./helpers/query/sanitizeProjection */ \"(ssr)/./node_modules/mongoose/lib/helpers/query/sanitizeProjection.js\");\nconst selectPopulatedFields = __webpack_require__(/*! ./helpers/query/selectPopulatedFields */ \"(ssr)/./node_modules/mongoose/lib/helpers/query/selectPopulatedFields.js\");\nconst setDefaultsOnInsert = __webpack_require__(/*! ./helpers/setDefaultsOnInsert */ \"(ssr)/./node_modules/mongoose/lib/helpers/setDefaultsOnInsert.js\");\nconst specialProperties = __webpack_require__(/*! ./helpers/specialProperties */ \"(ssr)/./node_modules/mongoose/lib/helpers/specialProperties.js\");\nconst updateValidators = __webpack_require__(/*! ./helpers/updateValidators */ \"(ssr)/./node_modules/mongoose/lib/helpers/updateValidators.js\");\nconst util = __webpack_require__(/*! util */ \"util\");\nconst utils = __webpack_require__(/*! ./utils */ \"(ssr)/./node_modules/mongoose/lib/utils.js\");\nconst validOps = __webpack_require__(/*! ./helpers/query/validOps */ \"(ssr)/./node_modules/mongoose/lib/helpers/query/validOps.js\");\n\nconst queryOptionMethods = new Set([\n  'allowDiskUse',\n  'batchSize',\n  'collation',\n  'comment',\n  'explain',\n  'hint',\n  'j',\n  'lean',\n  'limit',\n  'maxTimeMS',\n  'populate',\n  'projection',\n  'read',\n  'select',\n  'skip',\n  'slice',\n  'sort',\n  'tailable',\n  'w',\n  'writeConcern',\n  'wtimeout'\n]);\n\n/**\n * Query constructor used for building queries. You do not need\n * to instantiate a `Query` directly. Instead use Model functions like\n * [`Model.find()`](https://mongoosejs.com/docs/api/model.html#Model.find()).\n *\n * #### Example:\n *\n *     const query = MyModel.find(); // `query` is an instance of `Query`\n *     query.setOptions({ lean : true });\n *     query.collection(MyModel.collection);\n *     query.where('age').gte(21).exec(callback);\n *\n *     // You can instantiate a query directly. There is no need to do\n *     // this unless you're an advanced user with a very good reason to.\n *     const query = new mongoose.Query();\n *\n * @param {Object} [options]\n * @param {Object} [model]\n * @param {Object} [conditions]\n * @param {Object} [collection] Mongoose collection\n * @api public\n */\n\nfunction Query(conditions, options, model, collection) {\n  // this stuff is for dealing with custom queries created by #toConstructor\n  if (!this._mongooseOptions) {\n    this._mongooseOptions = {};\n  }\n  options = options || {};\n\n  this._transforms = [];\n  this._hooks = new Kareem();\n  this._executionStack = null;\n\n  // this is the case where we have a CustomQuery, we need to check if we got\n  // options passed in, and if we did, merge them in\n  const keys = Object.keys(options);\n  for (const key of keys) {\n    this._mongooseOptions[key] = options[key];\n  }\n\n  if (collection) {\n    this.mongooseCollection = collection;\n  }\n\n  if (model) {\n    this.model = model;\n    this.schema = model.schema;\n  }\n\n  // this is needed because map reduce returns a model that can be queried, but\n  // all of the queries on said model should be lean\n  if (this.model && this.model._mapreduce) {\n    this.lean();\n  }\n\n  // inherit mquery\n  mquery.call(this, null, options);\n  if (collection) {\n    this.collection(collection);\n  }\n\n  if (conditions) {\n    this.find(conditions);\n  }\n\n  this.options = this.options || {};\n\n  // For gh-6880. mquery still needs to support `fields` by default for old\n  // versions of MongoDB\n  this.$useProjection = true;\n\n  const collation = this &&\n    this.schema &&\n    this.schema.options &&\n    this.schema.options.collation || null;\n  if (collation != null) {\n    this.options.collation = collation;\n  }\n}\n\n/*!\n * inherit mquery\n */\n\nQuery.prototype = new mquery();\nQuery.prototype.constructor = Query;\nQuery.base = mquery.prototype;\n\n/*!\n * Overwrite mquery's `_distinct`, because Mongoose uses that name\n * to store the field to apply distinct on.\n */\n\nObject.defineProperty(Query.prototype, '_distinct', {\n  configurable: true,\n  writable: true,\n  enumerable: true,\n  value: undefined\n});\n\n/**\n * Flag to opt out of using `$geoWithin`.\n *\n * ```javascript\n * mongoose.Query.use$geoWithin = false;\n * ```\n *\n * MongoDB 2.4 deprecated the use of `$within`, replacing it with `$geoWithin`. Mongoose uses `$geoWithin` by default (which is 100% backward compatible with `$within`). If you are running an older version of MongoDB, set this flag to `false` so your `within()` queries continue to work.\n *\n * @see geoWithin https://www.mongodb.com/docs/manual/reference/operator/geoWithin/\n * @default true\n * @property use$geoWithin\n * @memberOf Query\n * @static\n * @api public\n */\n\nQuery.use$geoWithin = mquery.use$geoWithin;\n\n/**\n * Converts this query to a customized, reusable query constructor with all arguments and options retained.\n *\n * #### Example:\n *\n *     // Create a query for adventure movies and read from the primary\n *     // node in the replica-set unless it is down, in which case we'll\n *     // read from a secondary node.\n *     const query = Movie.find({ tags: 'adventure' }).read('primaryPreferred');\n *\n *     // create a custom Query constructor based off these settings\n *     const Adventure = query.toConstructor();\n *\n *     // further narrow down our query results while still using the previous settings\n *     await Adventure().where({ name: /^Life/ }).exec();\n *\n *     // since Adventure is a stand-alone constructor we can also add our own\n *     // helper methods and getters without impacting global queries\n *     Adventure.prototype.startsWith = function (prefix) {\n *       this.where({ name: new RegExp('^' + prefix) })\n *       return this;\n *     }\n *     Object.defineProperty(Adventure.prototype, 'highlyRated', {\n *       get: function () {\n *         this.where({ rating: { $gt: 4.5 }});\n *         return this;\n *       }\n *     })\n *     await Adventure().highlyRated.startsWith('Life').exec();\n *\n * @return {Query} subclass-of-Query\n * @api public\n */\n\nQuery.prototype.toConstructor = function toConstructor() {\n  const model = this.model;\n  const coll = this.mongooseCollection;\n\n  const CustomQuery = function(criteria, options) {\n    if (!(this instanceof CustomQuery)) {\n      return new CustomQuery(criteria, options);\n    }\n    this._mongooseOptions = clone(p._mongooseOptions);\n    Query.call(this, criteria, options || null, model, coll);\n  };\n\n  util.inherits(CustomQuery, model.Query);\n\n  // set inherited defaults\n  const p = CustomQuery.prototype;\n\n  p.options = {};\n\n  // Need to handle `sort()` separately because entries-style `sort()` syntax\n  // `sort([['prop1', 1]])` confuses mquery into losing the outer nested array.\n  // See gh-8159\n  const options = Object.assign({}, this.options);\n  if (options.sort != null) {\n    p.sort(options.sort);\n    delete options.sort;\n  }\n  p.setOptions(options);\n\n  p.op = this.op;\n  p._validateOp();\n  p._conditions = clone(this._conditions);\n  p._fields = clone(this._fields);\n  p._update = clone(this._update, {\n    flattenDecimals: false\n  });\n  p._path = this._path;\n  p._distinct = this._distinct;\n  p._collection = this._collection;\n  p._mongooseOptions = this._mongooseOptions;\n\n  return CustomQuery;\n};\n\n/**\n * Make a copy of this query so you can re-execute it.\n *\n * #### Example:\n *\n *     const q = Book.findOne({ title: 'Casino Royale' });\n *     await q.exec();\n *     await q.exec(); // Throws an error because you can't execute a query twice\n *\n *     await q.clone().exec(); // Works\n *\n * @method clone\n * @return {Query} copy\n * @memberOf Query\n * @instance\n * @api public\n */\n\nQuery.prototype.clone = function() {\n  const model = this.model;\n  const collection = this.mongooseCollection;\n\n  const q = new this.model.Query({}, {}, model, collection);\n\n  // Need to handle `sort()` separately because entries-style `sort()` syntax\n  // `sort([['prop1', 1]])` confuses mquery into losing the outer nested array.\n  // See gh-8159\n  const options = Object.assign({}, this.options);\n  if (options.sort != null) {\n    q.sort(options.sort);\n    delete options.sort;\n  }\n  q.setOptions(options);\n\n  q.op = this.op;\n  q._validateOp();\n  q._conditions = clone(this._conditions);\n  q._fields = clone(this._fields);\n  q._update = clone(this._update, {\n    flattenDecimals: false\n  });\n  q._path = this._path;\n  q._distinct = this._distinct;\n  q._collection = this._collection;\n  q._mongooseOptions = this._mongooseOptions;\n\n  return q;\n};\n\n/**\n * Specifies a javascript function or expression to pass to MongoDBs query system.\n *\n * #### Example:\n *\n *     query.$where('this.comments.length === 10 || this.name.length === 5')\n *\n *     // or\n *\n *     query.$where(function () {\n *       return this.comments.length === 10 || this.name.length === 5;\n *     })\n *\n * #### Note:\n *\n * Only use `$where` when you have a condition that cannot be met using other MongoDB operators like `$lt`.\n * **Be sure to read about all of [its caveats](https://www.mongodb.com/docs/manual/reference/operator/where/) before using.**\n *\n * @see $where https://www.mongodb.com/docs/manual/reference/operator/where/\n * @method $where\n * @param {String|Function} js javascript string or function\n * @return {Query} this\n * @memberOf Query\n * @instance\n * @method $where\n * @api public\n */\n\n/**\n * Specifies a `path` for use with chaining.\n *\n * #### Example:\n *\n *     // instead of writing:\n *     User.find({age: {$gte: 21, $lte: 65}});\n *\n *     // we can instead write:\n *     User.where('age').gte(21).lte(65);\n *\n *     // passing query conditions is permitted\n *     User.find().where({ name: 'vonderful' })\n *\n *     // chaining\n *     User\n *     .where('age').gte(21).lte(65)\n *     .where('name', /^vonderful/i)\n *     .where('friends').slice(10)\n *     .exec()\n *\n * @method where\n * @memberOf Query\n * @instance\n * @param {String|Object} [path]\n * @param {any} [val]\n * @return {Query} this\n * @api public\n */\n\n/**\n * Specifies a `$slice` projection for an array.\n *\n * #### Example:\n *\n *     query.slice('comments', 5); // Returns the first 5 comments\n *     query.slice('comments', -5); // Returns the last 5 comments\n *     query.slice('comments', [10, 5]); // Returns the first 5 comments after the 10-th\n *     query.where('comments').slice(5); // Returns the first 5 comments\n *     query.where('comments').slice([-10, 5]); // Returns the first 5 comments after the 10-th to last\n *\n * **Note:** If the absolute value of the number of elements to be sliced is greater than the number of elements in the array, all array elements will be returned.\n *\n *      // Given `arr`: [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\n *      query.slice('arr', 20); // Returns [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\n *      query.slice('arr', -20); // Returns [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\n *\n * **Note:** If the number of elements to skip is positive and greater than the number of elements in the array, an empty array will be returned.\n *\n *      // Given `arr`: [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\n *      query.slice('arr', [20, 5]); // Returns []\n *\n * **Note:** If the number of elements to skip is negative and its absolute value is greater than the number of elements in the array, the starting position is the start of the array.\n *\n *      // Given `arr`: [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\n *      query.slice('arr', [-20, 5]); // Returns [1, 2, 3, 4, 5]\n *\n * @method slice\n * @memberOf Query\n * @instance\n * @param {String} [path]\n * @param {Number|Array} val number of elements to slice or array with number of elements to skip and number of elements to slice\n * @return {Query} this\n * @see mongodb https://www.mongodb.com/docs/manual/tutorial/query-documents/#projection\n * @see $slice https://www.mongodb.com/docs/manual/reference/projection/slice/#prj._S_slice\n * @api public\n */\n\nQuery.prototype.slice = function() {\n  if (arguments.length === 0) {\n    return this;\n  }\n\n  this._validate('slice');\n\n  let path;\n  let val;\n\n  if (arguments.length === 1) {\n    const arg = arguments[0];\n    if (typeof arg === 'object' && !Array.isArray(arg)) {\n      const keys = Object.keys(arg);\n      const numKeys = keys.length;\n      for (let i = 0; i < numKeys; ++i) {\n        this.slice(keys[i], arg[keys[i]]);\n      }\n      return this;\n    }\n    this._ensurePath('slice');\n    path = this._path;\n    val = arguments[0];\n  } else if (arguments.length === 2) {\n    if ('number' === typeof arguments[0]) {\n      this._ensurePath('slice');\n      path = this._path;\n      val = [arguments[0], arguments[1]];\n    } else {\n      path = arguments[0];\n      val = arguments[1];\n    }\n  } else if (arguments.length === 3) {\n    path = arguments[0];\n    val = [arguments[1], arguments[2]];\n  }\n\n  const p = {};\n  p[path] = { $slice: val };\n  this.select(p);\n\n  return this;\n};\n\n/*!\n * ignore\n */\n\nconst validOpsSet = new Set(validOps);\n\nQuery.prototype._validateOp = function() {\n  if (this.op != null && !validOpsSet.has(this.op)) {\n    this.error(new Error('Query has invalid `op`: \"' + this.op + '\"'));\n  }\n};\n\n/**\n * Specifies the complementary comparison value for paths specified with `where()`\n *\n * #### Example:\n *\n *     User.where('age').equals(49);\n *\n *     // is the same as\n *\n *     User.where('age', 49);\n *\n * @method equals\n * @memberOf Query\n * @instance\n * @param {Object} val\n * @return {Query} this\n * @api public\n */\n\n/**\n * Specifies arguments for an `$or` condition.\n *\n * #### Example:\n *\n *     query.or([{ color: 'red' }, { status: 'emergency' }]);\n *\n * @see $or https://www.mongodb.com/docs/manual/reference/operator/or/\n * @method or\n * @memberOf Query\n * @instance\n * @param {Array} array array of conditions\n * @return {Query} this\n * @api public\n */\n\n/**\n * Specifies arguments for a `$nor` condition.\n *\n * #### Example:\n *\n *     query.nor([{ color: 'green' }, { status: 'ok' }]);\n *\n * @see $nor https://www.mongodb.com/docs/manual/reference/operator/nor/\n * @method nor\n * @memberOf Query\n * @instance\n * @param {Array} array array of conditions\n * @return {Query} this\n * @api public\n */\n\n/**\n * Specifies arguments for a `$and` condition.\n *\n * #### Example:\n *\n *     query.and([{ color: 'green' }, { status: 'ok' }])\n *\n * @method and\n * @memberOf Query\n * @instance\n * @see $and https://www.mongodb.com/docs/manual/reference/operator/and/\n * @param {Array} array array of conditions\n * @return {Query} this\n * @api public\n */\n\n/**\n * Specifies a `$gt` query condition.\n *\n * When called with one argument, the most recent path passed to `where()` is used.\n *\n * #### Example:\n *\n *     Thing.find().where('age').gt(21);\n *\n *     // or\n *     Thing.find().gt('age', 21);\n *\n * @method gt\n * @memberOf Query\n * @instance\n * @param {String} [path]\n * @param {Number} val\n * @see $gt https://www.mongodb.com/docs/manual/reference/operator/gt/\n * @api public\n */\n\n/**\n * Specifies a `$gte` query condition.\n *\n * When called with one argument, the most recent path passed to `where()` is used.\n *\n * @method gte\n * @memberOf Query\n * @instance\n * @param {String} [path]\n * @param {Number} val\n * @see $gte https://www.mongodb.com/docs/manual/reference/operator/gte/\n * @api public\n */\n\n/**\n * Specifies a `$lt` query condition.\n *\n * When called with one argument, the most recent path passed to `where()` is used.\n *\n * @method lt\n * @memberOf Query\n * @instance\n * @param {String} [path]\n * @param {Number} val\n * @see $lt https://www.mongodb.com/docs/manual/reference/operator/lt/\n * @api public\n */\n\n/**\n * Specifies a `$lte` query condition.\n *\n * When called with one argument, the most recent path passed to `where()` is used.\n *\n * @method lte\n * @see $lte https://www.mongodb.com/docs/manual/reference/operator/lte/\n * @memberOf Query\n * @instance\n * @param {String} [path]\n * @param {Number} val\n * @api public\n */\n\n/**\n * Specifies a `$ne` query condition.\n *\n * When called with one argument, the most recent path passed to `where()` is used.\n *\n * @see $ne https://www.mongodb.com/docs/manual/reference/operator/ne/\n * @method ne\n * @memberOf Query\n * @instance\n * @param {String} [path]\n * @param {any} val\n * @api public\n */\n\n/**\n * Specifies an `$in` query condition.\n *\n * When called with one argument, the most recent path passed to `where()` is used.\n *\n * @see $in https://www.mongodb.com/docs/manual/reference/operator/in/\n * @method in\n * @memberOf Query\n * @instance\n * @param {String} [path]\n * @param {Array} val\n * @api public\n */\n\n/**\n * Specifies an `$nin` query condition.\n *\n * When called with one argument, the most recent path passed to `where()` is used.\n *\n * @see $nin https://www.mongodb.com/docs/manual/reference/operator/nin/\n * @method nin\n * @memberOf Query\n * @instance\n * @param {String} [path]\n * @param {Array} val\n * @api public\n */\n\n/**\n * Specifies an `$all` query condition.\n *\n * When called with one argument, the most recent path passed to `where()` is used.\n *\n * #### Example:\n *\n *     MyModel.find().where('pets').all(['dog', 'cat', 'ferret']);\n *     // Equivalent:\n *     MyModel.find().all('pets', ['dog', 'cat', 'ferret']);\n *\n * @see $all https://www.mongodb.com/docs/manual/reference/operator/all/\n * @method all\n * @memberOf Query\n * @instance\n * @param {String} [path]\n * @param {Array} val\n * @api public\n */\n\n/**\n * Specifies a `$size` query condition.\n *\n * When called with one argument, the most recent path passed to `where()` is used.\n *\n * #### Example:\n *\n *     const docs = await MyModel.where('tags').size(0).exec();\n *     assert(Array.isArray(docs));\n *     console.log('documents with 0 tags', docs);\n *\n * @see $size https://www.mongodb.com/docs/manual/reference/operator/size/\n * @method size\n * @memberOf Query\n * @instance\n * @param {String} [path]\n * @param {Number} val\n * @api public\n */\n\n/**\n * Specifies a `$regex` query condition.\n *\n * When called with one argument, the most recent path passed to `where()` is used.\n *\n * @see $regex https://www.mongodb.com/docs/manual/reference/operator/regex/\n * @method regex\n * @memberOf Query\n * @instance\n * @param {String} [path]\n * @param {String|RegExp} val\n * @api public\n */\n\n/**\n * Specifies a `maxDistance` query condition.\n *\n * When called with one argument, the most recent path passed to `where()` is used.\n *\n * @see $maxDistance https://www.mongodb.com/docs/manual/reference/operator/maxDistance/\n * @method maxDistance\n * @memberOf Query\n * @instance\n * @param {String} [path]\n * @param {Number} val\n * @api public\n */\n\n/**\n * Specifies a `$mod` condition, filters documents for documents whose\n * `path` property is a number that is equal to `remainder` modulo `divisor`.\n *\n * #### Example:\n *\n *     // All find products whose inventory is odd\n *     Product.find().mod('inventory', [2, 1]);\n *     Product.find().where('inventory').mod([2, 1]);\n *     // This syntax is a little strange, but supported.\n *     Product.find().where('inventory').mod(2, 1);\n *\n * @method mod\n * @memberOf Query\n * @instance\n * @param {String} [path]\n * @param {Array} val must be of length 2, first element is `divisor`, 2nd element is `remainder`.\n * @return {Query} this\n * @see $mod https://www.mongodb.com/docs/manual/reference/operator/mod/\n * @api public\n */\n\nQuery.prototype.mod = function() {\n  let val;\n  let path;\n\n  if (arguments.length === 1) {\n    this._ensurePath('mod');\n    val = arguments[0];\n    path = this._path;\n  } else if (arguments.length === 2 && !Array.isArray(arguments[1])) {\n    this._ensurePath('mod');\n    val = [arguments[0], arguments[1]];\n    path = this._path;\n  } else if (arguments.length === 3) {\n    val = [arguments[1], arguments[2]];\n    path = arguments[0];\n  } else {\n    val = arguments[1];\n    path = arguments[0];\n  }\n\n  const conds = this._conditions[path] || (this._conditions[path] = {});\n  conds.$mod = val;\n  return this;\n};\n\n/**\n * Specifies an `$exists` condition\n *\n * #### Example:\n *\n *     // { name: { $exists: true }}\n *     Thing.where('name').exists()\n *     Thing.where('name').exists(true)\n *     Thing.find().exists('name')\n *\n *     // { name: { $exists: false }}\n *     Thing.where('name').exists(false);\n *     Thing.find().exists('name', false);\n *\n * @method exists\n * @memberOf Query\n * @instance\n * @param {String} [path]\n * @param {Boolean} val\n * @return {Query} this\n * @see $exists https://www.mongodb.com/docs/manual/reference/operator/exists/\n * @api public\n */\n\n/**\n * Specifies an `$elemMatch` condition\n *\n * #### Example:\n *\n *     query.elemMatch('comment', { author: 'autobot', votes: {$gte: 5}})\n *\n *     query.where('comment').elemMatch({ author: 'autobot', votes: {$gte: 5}})\n *\n *     query.elemMatch('comment', function (elem) {\n *       elem.where('author').equals('autobot');\n *       elem.where('votes').gte(5);\n *     })\n *\n *     query.where('comment').elemMatch(function (elem) {\n *       elem.where({ author: 'autobot' });\n *       elem.where('votes').gte(5);\n *     })\n *\n * @method elemMatch\n * @memberOf Query\n * @instance\n * @param {String|Object|Function} path\n * @param {Object|Function} filter\n * @return {Query} this\n * @see $elemMatch https://www.mongodb.com/docs/manual/reference/operator/elemMatch/\n * @api public\n */\n\n/**\n * Defines a `$within` or `$geoWithin` argument for geo-spatial queries.\n *\n * #### Example:\n *\n *     query.where(path).within().box()\n *     query.where(path).within().circle()\n *     query.where(path).within().geometry()\n *\n *     query.where('loc').within({ center: [50,50], radius: 10, unique: true, spherical: true });\n *     query.where('loc').within({ box: [[40.73, -73.9], [40.7, -73.988]] });\n *     query.where('loc').within({ polygon: [[],[],[],[]] });\n *\n *     query.where('loc').within([], [], []) // polygon\n *     query.where('loc').within([], []) // box\n *     query.where('loc').within({ type: 'LineString', coordinates: [...] }); // geometry\n *\n * **MUST** be used after `where()`.\n *\n * #### Note:\n *\n * As of Mongoose 3.7, `$geoWithin` is always used for queries. To change this behavior, see [Query.use$geoWithin](https://mongoosejs.com/docs/api/query.html#Query.prototype.use$geoWithin).\n *\n * #### Note:\n *\n * In Mongoose 3.7, `within` changed from a getter to a function. If you need the old syntax, use [this](https://github.com/ebensing/mongoose-within).\n *\n * @method within\n * @see $polygon https://www.mongodb.com/docs/manual/reference/operator/polygon/\n * @see $box https://www.mongodb.com/docs/manual/reference/operator/box/\n * @see $geometry https://www.mongodb.com/docs/manual/reference/operator/geometry/\n * @see $center https://www.mongodb.com/docs/manual/reference/operator/center/\n * @see $centerSphere https://www.mongodb.com/docs/manual/reference/operator/centerSphere/\n * @memberOf Query\n * @instance\n * @return {Query} this\n * @api public\n */\n\n/**\n * Specifies the maximum number of documents the query will return.\n *\n * #### Example:\n *\n *     query.limit(20);\n *\n * #### Note:\n *\n * Cannot be used with `distinct()`\n *\n * @method limit\n * @memberOf Query\n * @instance\n * @param {Number} val\n * @api public\n */\n\nQuery.prototype.limit = function limit(v) {\n  this._validate('limit');\n\n  if (typeof v === 'string') {\n    try {\n      v = castNumber(v);\n    } catch (err) {\n      throw new CastError('Number', v, 'limit');\n    }\n  }\n\n  this.options.limit = v;\n  return this;\n};\n\n/**\n * Specifies the number of documents to skip.\n *\n * #### Example:\n *\n *     query.skip(100).limit(20);\n *\n * #### Note:\n *\n * Cannot be used with `distinct()`\n *\n * @method skip\n * @memberOf Query\n * @instance\n * @param {Number} val\n * @see cursor.skip https://www.mongodb.com/docs/manual/reference/method/cursor.skip/\n * @api public\n */\n\nQuery.prototype.skip = function skip(v) {\n  this._validate('skip');\n\n  if (typeof v === 'string') {\n    try {\n      v = castNumber(v);\n    } catch (err) {\n      throw new CastError('Number', v, 'skip');\n    }\n  }\n\n  this.options.skip = v;\n  return this;\n};\n\n/**\n * Specifies the batchSize option.\n *\n * #### Example:\n *\n *     query.batchSize(100)\n *\n * #### Note:\n *\n * Cannot be used with `distinct()`\n *\n * @method batchSize\n * @memberOf Query\n * @instance\n * @param {Number} val\n * @see batchSize https://www.mongodb.com/docs/manual/reference/method/cursor.batchSize/\n * @api public\n */\n\n/**\n * Specifies the `comment` option.\n *\n * #### Example:\n *\n *     query.comment('login query')\n *\n * #### Note:\n *\n * Cannot be used with `distinct()`\n *\n * @method comment\n * @memberOf Query\n * @instance\n * @param {String} val\n * @see comment https://www.mongodb.com/docs/manual/reference/operator/comment/\n * @api public\n */\n\n/**\n * Sets query hints.\n *\n * #### Example:\n *\n *     query.hint({ indexA: 1, indexB: -1 });\n *\n * #### Note:\n *\n * Cannot be used with `distinct()`\n *\n * @method hint\n * @memberOf Query\n * @instance\n * @param {Object} val a hint object\n * @return {Query} this\n * @see $hint https://www.mongodb.com/docs/manual/reference/operator/hint/\n * @api public\n */\n\n/**\n * Get/set the current projection (AKA fields). Pass `null` to remove the\n * current projection.\n *\n * Unlike `projection()`, the `select()` function modifies the current\n * projection in place. This function overwrites the existing projection.\n *\n * #### Example:\n *\n *     const q = Model.find();\n *     q.projection(); // null\n *\n *     q.select('a b');\n *     q.projection(); // { a: 1, b: 1 }\n *\n *     q.projection({ c: 1 });\n *     q.projection(); // { c: 1 }\n *\n *     q.projection(null);\n *     q.projection(); // null\n *\n *\n * @method projection\n * @memberOf Query\n * @instance\n * @param {Object|null} arg\n * @return {Object} the current projection\n * @api public\n */\n\nQuery.prototype.projection = function(arg) {\n  if (arguments.length === 0) {\n    return this._fields;\n  }\n\n  this._fields = {};\n  this._userProvidedFields = {};\n  this.select(arg);\n  return this._fields;\n};\n\n/**\n * Specifies which document fields to include or exclude (also known as the query \"projection\")\n *\n * When using string syntax, prefixing a path with `-` will flag that path as excluded. When a path does not have the `-` prefix, it is included. Lastly, if a path is prefixed with `+`, it forces inclusion of the path, which is useful for paths excluded at the [schema level](https://mongoosejs.com/docs/api/schematype.html#SchemaType.prototype.select()).\n *\n * A projection _must_ be either inclusive or exclusive. In other words, you must\n * either list the fields to include (which excludes all others), or list the fields\n * to exclude (which implies all other fields are included). The [`_id` field is the only exception because MongoDB includes it by default](https://www.mongodb.com/docs/manual/tutorial/project-fields-from-query-results/#suppress-id-field).\n *\n * #### Example:\n *\n *     // include a and b, exclude other fields\n *     query.select('a b');\n *     // Equivalent syntaxes:\n *     query.select(['a', 'b']);\n *     query.select({ a: 1, b: 1 });\n *\n *     // exclude c and d, include other fields\n *     query.select('-c -d');\n *\n *     // Use `+` to override schema-level `select: false` without making the\n *     // projection inclusive.\n *     const schema = new Schema({\n *       foo: { type: String, select: false },\n *       bar: String\n *     });\n *     // ...\n *     query.select('+foo'); // Override foo's `select: false` without excluding `bar`\n *\n *     // or you may use object notation, useful when\n *     // you have keys already prefixed with a \"-\"\n *     query.select({ a: 1, b: 1 });\n *     query.select({ c: 0, d: 0 });\n *\n *     Additional calls to select can override the previous selection:\n *     query.select({ a: 1, b: 1 }).select({ b: 0 }); // selection is now { a: 1 }\n *     query.select({ a: 0, b: 0 }).select({ b: 1 }); // selection is now { a: 0 }\n *\n *\n * @method select\n * @memberOf Query\n * @instance\n * @param {Object|String|String[]} arg\n * @return {Query} this\n * @see SchemaType https://mongoosejs.com/docs/api/schematype.html\n * @api public\n */\n\nQuery.prototype.select = function select() {\n  let arg = arguments[0];\n  if (!arg) return this;\n\n  if (arguments.length !== 1) {\n    throw new Error('Invalid select: select only takes 1 argument');\n  }\n\n  this._validate('select');\n\n  const fields = this._fields || (this._fields = {});\n  const userProvidedFields = this._userProvidedFields || (this._userProvidedFields = {});\n  let sanitizeProjection = undefined;\n  if (this.model != null && utils.hasUserDefinedProperty(this.model.db.options, 'sanitizeProjection')) {\n    sanitizeProjection = this.model.db.options.sanitizeProjection;\n  } else if (this.model != null && utils.hasUserDefinedProperty(this.model.base.options, 'sanitizeProjection')) {\n    sanitizeProjection = this.model.base.options.sanitizeProjection;\n  } else {\n    sanitizeProjection = this._mongooseOptions.sanitizeProjection;\n  }\n\n  function sanitizeValue(value) {\n    return typeof value === 'string' && sanitizeProjection ? value = 1 : value;\n  }\n  arg = parseProjection(arg, true); // we want to keep the minus and pluses, so add boolean arg.\n  if (utils.isObject(arg)) {\n    if (this.selectedInclusively()) {\n      Object.entries(arg).forEach(([key, value]) => {\n        if (value) {\n          // Add the field to the projection\n          if (fields['-' + key] != null) {\n            delete fields['-' + key];\n          }\n          fields[key] = userProvidedFields[key] = sanitizeValue(value);\n        } else {\n          // Remove the field from the projection\n          Object.keys(userProvidedFields).forEach(field => {\n            if (isSubpath(key, field)) {\n              delete fields[field];\n              delete userProvidedFields[field];\n            }\n          });\n        }\n      });\n    } else if (this.selectedExclusively()) {\n      Object.entries(arg).forEach(([key, value]) => {\n        if (!value) {\n          // Add the field to the projection\n          if (fields['+' + key] != null) {\n            delete fields['+' + key];\n          }\n          fields[key] = userProvidedFields[key] = sanitizeValue(value);\n        } else {\n          // Remove the field from the projection\n          Object.keys(userProvidedFields).forEach(field => {\n            if (isSubpath(key, field)) {\n              delete fields[field];\n              delete userProvidedFields[field];\n            }\n          });\n        }\n      });\n    } else {\n      const keys = Object.keys(arg);\n      for (let i = 0; i < keys.length; ++i) {\n        const value = arg[keys[i]];\n        const key = keys[i];\n        fields[key] = sanitizeValue(value);\n        userProvidedFields[key] = sanitizeValue(value);\n      }\n    }\n\n    return this;\n  }\n\n  throw new TypeError('Invalid select() argument. Must be string or object.');\n};\n\n/**\n * Determines the MongoDB nodes from which to read.\n *\n * #### Preferences:\n *\n * ```\n * primary - (default) Read from primary only. Operations will produce an error if primary is unavailable. Cannot be combined with tags.\n * secondary            Read from secondary if available, otherwise error.\n * primaryPreferred     Read from primary if available, otherwise a secondary.\n * secondaryPreferred   Read from a secondary if available, otherwise read from the primary.\n * nearest              All operations read from among the nearest candidates, but unlike other modes, this option will include both the primary and all secondaries in the random selection.\n * ```\n *\n * Aliases\n *\n * ```\n * p   primary\n * pp  primaryPreferred\n * s   secondary\n * sp  secondaryPreferred\n * n   nearest\n * ```\n *\n * #### Example:\n *\n *     new Query().read('primary')\n *     new Query().read('p')  // same as primary\n *\n *     new Query().read('primaryPreferred')\n *     new Query().read('pp') // same as primaryPreferred\n *\n *     new Query().read('secondary')\n *     new Query().read('s')  // same as secondary\n *\n *     new Query().read('secondaryPreferred')\n *     new Query().read('sp') // same as secondaryPreferred\n *\n *     new Query().read('nearest')\n *     new Query().read('n')  // same as nearest\n *\n *     // read from secondaries with matching tags\n *     new Query().read('s', [{ dc:'sf', s: 1 },{ dc:'ma', s: 2 }])\n *\n * Read more about how to use read preferences [here](https://www.mongodb.com/docs/manual/applications/replication/#read-preference).\n *\n * @method read\n * @memberOf Query\n * @instance\n * @param {String} mode one of the listed preference options or aliases\n * @param {Array} [tags] optional tags for this query\n * @see mongodb https://www.mongodb.com/docs/manual/applications/replication/#read-preference\n * @return {Query} this\n * @api public\n */\n\nQuery.prototype.read = function read(mode, tags) {\n  if (typeof mode === 'string') {\n    mode = handleReadPreferenceAliases(mode);\n    this.options.readPreference = { mode, tags };\n  } else {\n    this.options.readPreference = mode;\n  }\n  return this;\n};\n\n/**\n * Overwrite default `.toString` to make logging more useful\n *\n * @memberOf Query\n * @instance\n * @method toString\n * @api private\n */\n\nQuery.prototype.toString = function toString() {\n  if (this.op === 'count' ||\n      this.op === 'countDocuments' ||\n      this.op === 'find' ||\n      this.op === 'findOne' ||\n      this.op === 'deleteMany' ||\n      this.op === 'deleteOne' ||\n      this.op === 'findOneAndDelete' ||\n      this.op === 'remove') {\n    return `${this.model.modelName}.${this.op}(${util.inspect(this._conditions)})`;\n  }\n  if (this.op === 'distinct') {\n    return `${this.model.modelName}.distinct('${this._distinct}', ${util.inspect(this._conditions)})`;\n  }\n  if (this.op === 'findOneAndReplace' ||\n      this.op === 'findOneAndUpdate' ||\n      this.op === 'replaceOne' ||\n      this.op === 'update' ||\n      this.op === 'updateMany' ||\n      this.op === 'updateOne') {\n    return `${this.model.modelName}.${this.op}(${util.inspect(this._conditions)}, ${util.inspect(this._update)})`;\n  }\n\n  // 'estimatedDocumentCount' or any others\n  return `${this.model.modelName}.${this.op}()`;\n};\n\n/**\n * Sets the [MongoDB session](https://www.mongodb.com/docs/manual/reference/server-sessions/)\n * associated with this query. Sessions are how you mark a query as part of a\n * [transaction](https://mongoosejs.com/docs/transactions.html).\n *\n * Calling `session(null)` removes the session from this query.\n *\n * #### Example:\n *\n *     const s = await mongoose.startSession();\n *     await mongoose.model('Person').findOne({ name: 'Axl Rose' }).session(s);\n *\n * @method session\n * @memberOf Query\n * @instance\n * @param {ClientSession} [session] from `await conn.startSession()`\n * @see Connection.prototype.startSession() https://mongoosejs.com/docs/api/connection.html#Connection.prototype.startSession()\n * @see mongoose.startSession() https://mongoosejs.com/docs/api/mongoose.html#Mongoose.prototype.startSession()\n * @return {Query} this\n * @api public\n */\n\nQuery.prototype.session = function session(v) {\n  if (v == null) {\n    delete this.options.session;\n  }\n  this.options.session = v;\n  return this;\n};\n\n/**\n * Sets the 3 write concern parameters for this query:\n *\n * - `w`: Sets the specified number of `mongod` servers, or tag set of `mongod` servers, that must acknowledge this write before this write is considered successful.\n * - `j`: Boolean, set to `true` to request acknowledgement that this operation has been persisted to MongoDB's on-disk journal.\n * - `wtimeout`: If [`w > 1`](https://mongoosejs.com/docs/api/query.html#Query.prototype.w()), the maximum amount of time to wait for this write to propagate through the replica set before this operation fails. The default is `0`, which means no timeout.\n *\n * This option is only valid for operations that write to the database:\n *\n * - `deleteOne()`\n * - `deleteMany()`\n * - `findOneAndDelete()`\n * - `findOneAndReplace()`\n * - `findOneAndUpdate()`\n * - `updateOne()`\n * - `updateMany()`\n *\n * Defaults to the schema's [`writeConcern` option](https://mongoosejs.com/docs/guide.html#writeConcern)\n *\n * #### Example:\n *\n *     // The 'majority' option means the `deleteOne()` promise won't resolve\n *     // until the `deleteOne()` has propagated to the majority of the replica set\n *     await mongoose.model('Person').\n *       deleteOne({ name: 'Ned Stark' }).\n *       writeConcern({ w: 'majority' });\n *\n * @method writeConcern\n * @memberOf Query\n * @instance\n * @param {Object} writeConcern the write concern value to set\n * @see WriteConcernSettings https://mongodb.github.io/node-mongodb-native/4.9/interfaces/WriteConcernSettings.html\n * @return {Query} this\n * @api public\n */\n\nQuery.prototype.writeConcern = function writeConcern(val) {\n  if (val == null) {\n    delete this.options.writeConcern;\n    return this;\n  }\n  this.options.writeConcern = val;\n  return this;\n};\n\n/**\n * Sets the specified number of `mongod` servers, or tag set of `mongod` servers,\n * that must acknowledge this write before this write is considered successful.\n * This option is only valid for operations that write to the database:\n *\n * - `deleteOne()`\n * - `deleteMany()`\n * - `findOneAndDelete()`\n * - `findOneAndReplace()`\n * - `findOneAndUpdate()`\n * - `updateOne()`\n * - `updateMany()`\n *\n * Defaults to the schema's [`writeConcern.w` option](https://mongoosejs.com/docs/guide.html#writeConcern)\n *\n * #### Example:\n *\n *     // The 'majority' option means the `deleteOne()` promise won't resolve\n *     // until the `deleteOne()` has propagated to the majority of the replica set\n *     await mongoose.model('Person').\n *       deleteOne({ name: 'Ned Stark' }).\n *       w('majority');\n *\n * @method w\n * @memberOf Query\n * @instance\n * @param {String|number} val 0 for fire-and-forget, 1 for acknowledged by one server, 'majority' for majority of the replica set, or [any of the more advanced options](https://www.mongodb.com/docs/manual/reference/write-concern/#w-option).\n * @see mongodb https://www.mongodb.com/docs/manual/reference/write-concern/#w-option\n * @return {Query} this\n * @api public\n */\n\nQuery.prototype.w = function w(val) {\n  if (val == null) {\n    delete this.options.w;\n  }\n  if (this.options.writeConcern != null) {\n    this.options.writeConcern.w = val;\n  } else {\n    this.options.w = val;\n  }\n  return this;\n};\n\n/**\n * Requests acknowledgement that this operation has been persisted to MongoDB's\n * on-disk journal.\n * This option is only valid for operations that write to the database:\n *\n * - `deleteOne()`\n * - `deleteMany()`\n * - `findOneAndDelete()`\n * - `findOneAndReplace()`\n * - `findOneAndUpdate()`\n * - `updateOne()`\n * - `updateMany()`\n *\n * Defaults to the schema's [`writeConcern.j` option](https://mongoosejs.com/docs/guide.html#writeConcern)\n *\n * #### Example:\n *\n *     await mongoose.model('Person').deleteOne({ name: 'Ned Stark' }).j(true);\n *\n * @method j\n * @memberOf Query\n * @instance\n * @param {boolean} val\n * @see mongodb https://www.mongodb.com/docs/manual/reference/write-concern/#j-option\n * @return {Query} this\n * @api public\n */\n\nQuery.prototype.j = function j(val) {\n  if (val == null) {\n    delete this.options.j;\n  }\n  if (this.options.writeConcern != null) {\n    this.options.writeConcern.j = val;\n  } else {\n    this.options.j = val;\n  }\n  return this;\n};\n\n/**\n * If [`w > 1`](https://mongoosejs.com/docs/api/query.html#Query.prototype.w()), the maximum amount of time to\n * wait for this write to propagate through the replica set before this\n * operation fails. The default is `0`, which means no timeout.\n *\n * This option is only valid for operations that write to the database:\n *\n * - `deleteOne()`\n * - `deleteMany()`\n * - `findOneAndDelete()`\n * - `findOneAndReplace()`\n * - `findOneAndUpdate()`\n * - `updateOne()`\n * - `updateMany()`\n *\n * Defaults to the schema's [`writeConcern.wtimeout` option](https://mongoosejs.com/docs/guide.html#writeConcern)\n *\n * #### Example:\n *\n *     // The `deleteOne()` promise won't resolve until this `deleteOne()` has\n *     // propagated to at least `w = 2` members of the replica set. If it takes\n *     // longer than 1 second, this `deleteOne()` will fail.\n *     await mongoose.model('Person').\n *       deleteOne({ name: 'Ned Stark' }).\n *       w(2).\n *       wtimeout(1000);\n *\n * @method wtimeout\n * @memberOf Query\n * @instance\n * @param {number} ms number of milliseconds to wait\n * @see mongodb https://www.mongodb.com/docs/manual/reference/write-concern/#wtimeout\n * @return {Query} this\n * @api public\n */\n\nQuery.prototype.wtimeout = function wtimeout(ms) {\n  if (ms == null) {\n    delete this.options.wtimeout;\n  }\n  if (this.options.writeConcern != null) {\n    this.options.writeConcern.wtimeout = ms;\n  } else {\n    this.options.wtimeout = ms;\n  }\n  return this;\n};\n\n/**\n * Sets the readConcern option for the query.\n *\n * #### Example:\n *\n *     new Query().readConcern('local')\n *     new Query().readConcern('l')  // same as local\n *\n *     new Query().readConcern('available')\n *     new Query().readConcern('a')  // same as available\n *\n *     new Query().readConcern('majority')\n *     new Query().readConcern('m')  // same as majority\n *\n *     new Query().readConcern('linearizable')\n *     new Query().readConcern('lz') // same as linearizable\n *\n *     new Query().readConcern('snapshot')\n *     new Query().readConcern('s')  // same as snapshot\n *\n *\n * #### Read Concern Level:\n *\n * ```\n * local         MongoDB 3.2+ The query returns from the instance with no guarantee guarantee that the data has been written to a majority of the replica set members (i.e. may be rolled back).\n * available     MongoDB 3.6+ The query returns from the instance with no guarantee guarantee that the data has been written to a majority of the replica set members (i.e. may be rolled back).\n * majority      MongoDB 3.2+ The query returns the data that has been acknowledged by a majority of the replica set members. The documents returned by the read operation are durable, even in the event of failure.\n * linearizable  MongoDB 3.4+ The query returns data that reflects all successful majority-acknowledged writes that completed prior to the start of the read operation. The query may wait for concurrently executing writes to propagate to a majority of replica set members before returning results.\n * snapshot      MongoDB 4.0+ Only available for operations within multi-document transactions. Upon transaction commit with write concern \"majority\", the transaction operations are guaranteed to have read from a snapshot of majority-committed data.\n * ```\n *\n * Aliases\n *\n * ```\n * l   local\n * a   available\n * m   majority\n * lz  linearizable\n * s   snapshot\n * ```\n *\n * Read more about how to use read concern [here](https://www.mongodb.com/docs/manual/reference/read-concern/).\n *\n * @memberOf Query\n * @method readConcern\n * @param {String} level one of the listed read concern level or their aliases\n * @see mongodb https://www.mongodb.com/docs/manual/reference/read-concern/\n * @return {Query} this\n * @api public\n */\n\n/**\n * Gets query options.\n *\n * #### Example:\n *\n *     const query = new Query();\n *     query.limit(10);\n *     query.setOptions({ maxTimeMS: 1000 });\n *     query.getOptions(); // { limit: 10, maxTimeMS: 1000 }\n *\n * @return {Object} the options\n * @api public\n */\n\nQuery.prototype.getOptions = function() {\n  return this.options;\n};\n\n/**\n * Sets query options. Some options only make sense for certain operations.\n *\n * #### Options:\n *\n * The following options are only for `find()`:\n *\n * - [tailable](https://www.mongodb.com/docs/manual/core/tailable-cursors/)\n * - [limit](https://www.mongodb.com/docs/manual/reference/method/cursor.limit/)\n * - [skip](https://www.mongodb.com/docs/manual/reference/method/cursor.skip/)\n * - [allowDiskUse](https://www.mongodb.com/docs/manual/reference/method/cursor.allowDiskUse/)\n * - [batchSize](https://www.mongodb.com/docs/manual/reference/method/cursor.batchSize/)\n * - [readPreference](https://www.mongodb.com/docs/manual/applications/replication/#read-preference)\n * - [hint](https://www.mongodb.com/docs/manual/reference/method/cursor.hint/)\n * - [comment](https://www.mongodb.com/docs/manual/reference/method/cursor.comment/)\n *\n * The following options are only for write operations: `updateOne()`, `updateMany()`, `replaceOne()`, `findOneAndUpdate()`, and `findByIdAndUpdate()`:\n *\n * - [upsert](https://www.mongodb.com/docs/manual/reference/method/db.collection.update/)\n * - [writeConcern](https://www.mongodb.com/docs/manual/reference/method/db.collection.update/)\n * - [timestamps](https://mongoosejs.com/docs/guide.html#timestamps): If `timestamps` is set in the schema, set this option to `false` to skip timestamps for that particular update. Has no effect if `timestamps` is not enabled in the schema options.\n * - overwriteDiscriminatorKey: allow setting the discriminator key in the update. Will use the correct discriminator schema if the update changes the discriminator key.\n *\n * The following options are only for `find()`, `findOne()`, `findById()`, `findOneAndUpdate()`, `findOneAndReplace()`, `findOneAndDelete()`, and `findByIdAndUpdate()`:\n *\n * - [lean](https://mongoosejs.com/docs/api/query.html#Query.prototype.lean())\n * - [populate](https://mongoosejs.com/docs/populate.html)\n * - [projection](https://mongoosejs.com/docs/api/query.html#Query.prototype.projection())\n * - sanitizeProjection\n * - useBigInt64\n *\n * The following options are only for all operations **except** `updateOne()`, `updateMany()`, `deleteOne()`, and `deleteMany()`:\n *\n * - [maxTimeMS](https://www.mongodb.com/docs/manual/reference/operator/meta/maxTimeMS/)\n *\n * The following options are for `find()`, `findOne()`, `findOneAndUpdate()`, `findOneAndDelete()`, `updateOne()`, and `deleteOne()`:\n *\n * - [sort](https://www.mongodb.com/docs/manual/reference/method/cursor.sort/)\n *\n * The following options are for `findOneAndUpdate()` and `findOneAndDelete()`\n *\n * - includeResultMetadata\n *\n * The following options are for all operations:\n *\n * - [strict](https://mongoosejs.com/docs/guide.html#strict)\n * - [collation](https://www.mongodb.com/docs/manual/reference/collation/)\n * - [session](https://www.mongodb.com/docs/manual/reference/server-sessions/)\n * - [explain](https://www.mongodb.com/docs/manual/reference/method/cursor.explain/)\n *\n * @param {Object} options\n * @return {Query} this\n * @api public\n */\n\nQuery.prototype.setOptions = function(options, overwrite) {\n  // overwrite is only for internal use\n  if (overwrite) {\n    // ensure that _mongooseOptions & options are two different objects\n    this._mongooseOptions = (options && clone(options)) || {};\n    this.options = options || {};\n\n    if ('populate' in options) {\n      this.populate(this._mongooseOptions);\n    }\n    return this;\n  }\n  if (options == null) {\n    return this;\n  }\n  if (typeof options !== 'object') {\n    throw new Error('Options must be an object, got \"' + options + '\"');\n  }\n\n  options = Object.assign({}, options);\n\n  if (Array.isArray(options.populate)) {\n    const populate = options.populate;\n    delete options.populate;\n    const _numPopulate = populate.length;\n    for (let i = 0; i < _numPopulate; ++i) {\n      this.populate(populate[i]);\n    }\n  }\n\n  if ('setDefaultsOnInsert' in options) {\n    this._mongooseOptions.setDefaultsOnInsert = options.setDefaultsOnInsert;\n    delete options.setDefaultsOnInsert;\n  }\n  if ('overwriteDiscriminatorKey' in options) {\n    this._mongooseOptions.overwriteDiscriminatorKey = options.overwriteDiscriminatorKey;\n    delete options.overwriteDiscriminatorKey;\n  }\n  if ('sanitizeProjection' in options) {\n    if (options.sanitizeProjection && !this._mongooseOptions.sanitizeProjection) {\n      sanitizeProjection(this._fields);\n    }\n\n    this._mongooseOptions.sanitizeProjection = options.sanitizeProjection;\n    delete options.sanitizeProjection;\n  }\n  if ('sanitizeFilter' in options) {\n    this._mongooseOptions.sanitizeFilter = options.sanitizeFilter;\n    delete options.sanitizeFilter;\n  }\n  if ('timestamps' in options) {\n    this._mongooseOptions.timestamps = options.timestamps;\n    delete options.timestamps;\n  }\n  if ('defaults' in options) {\n    this._mongooseOptions.defaults = options.defaults;\n    // deleting options.defaults will cause 7287 to fail\n  }\n  if ('translateAliases' in options) {\n    this._mongooseOptions.translateAliases = options.translateAliases;\n    delete options.translateAliases;\n  }\n\n  if (options.lean == null && this.schema && 'lean' in this.schema.options) {\n    this._mongooseOptions.lean = this.schema.options.lean;\n  }\n\n  if (typeof options.limit === 'string') {\n    try {\n      options.limit = castNumber(options.limit);\n    } catch (err) {\n      throw new CastError('Number', options.limit, 'limit');\n    }\n  }\n  if (typeof options.skip === 'string') {\n    try {\n      options.skip = castNumber(options.skip);\n    } catch (err) {\n      throw new CastError('Number', options.skip, 'skip');\n    }\n  }\n\n  // set arbitrary options\n  for (const key of Object.keys(options)) {\n    if (queryOptionMethods.has(key)) {\n      const args = Array.isArray(options[key]) ?\n        options[key] :\n        [options[key]];\n      this[key].apply(this, args);\n    } else {\n      this.options[key] = options[key];\n    }\n  }\n\n  return this;\n};\n\n/**\n * Sets the [`explain` option](https://www.mongodb.com/docs/manual/reference/method/cursor.explain/),\n * which makes this query return detailed execution stats instead of the actual\n * query result. This method is useful for determining what index your queries\n * use.\n *\n * Calling `query.explain(v)` is equivalent to `query.setOptions({ explain: v })`\n *\n * #### Example:\n *\n *     const query = new Query();\n *     const res = await query.find({ a: 1 }).explain('queryPlanner');\n *     console.log(res);\n *\n * @param {String} [verbose] The verbosity mode. Either 'queryPlanner', 'executionStats', or 'allPlansExecution'. The default is 'queryPlanner'\n * @return {Query} this\n * @api public\n */\n\nQuery.prototype.explain = function explain(verbose) {\n  if (arguments.length === 0) {\n    this.options.explain = true;\n  } else if (verbose === false) {\n    delete this.options.explain;\n  } else {\n    this.options.explain = verbose;\n  }\n  return this;\n};\n\n/**\n * Sets the [`allowDiskUse` option](https://www.mongodb.com/docs/manual/reference/method/cursor.allowDiskUse/),\n * which allows the MongoDB server to use more than 100 MB for this query's `sort()`. This option can\n * let you work around `QueryExceededMemoryLimitNoDiskUseAllowed` errors from the MongoDB server.\n *\n * Note that this option requires MongoDB server >= 4.4. Setting this option is a no-op for MongoDB 4.2\n * and earlier.\n *\n * Calling `query.allowDiskUse(v)` is equivalent to `query.setOptions({ allowDiskUse: v })`\n *\n * #### Example:\n *\n *     await query.find().sort({ name: 1 }).allowDiskUse(true);\n *     // Equivalent:\n *     await query.find().sort({ name: 1 }).allowDiskUse();\n *\n * @param {Boolean} [v] Enable/disable `allowDiskUse`. If called with 0 arguments, sets `allowDiskUse: true`\n * @return {Query} this\n * @api public\n */\n\nQuery.prototype.allowDiskUse = function(v) {\n  if (arguments.length === 0) {\n    this.options.allowDiskUse = true;\n  } else if (v === false) {\n    delete this.options.allowDiskUse;\n  } else {\n    this.options.allowDiskUse = v;\n  }\n  return this;\n};\n\n/**\n * Sets the [maxTimeMS](https://www.mongodb.com/docs/manual/reference/method/cursor.maxTimeMS/)\n * option. This will tell the MongoDB server to abort if the query or write op\n * has been running for more than `ms` milliseconds.\n *\n * Calling `query.maxTimeMS(v)` is equivalent to `query.setOptions({ maxTimeMS: v })`\n *\n * #### Example:\n *\n *     const query = new Query();\n *     // Throws an error 'operation exceeded time limit' as long as there's\n *     // >= 1 doc in the queried collection\n *     const res = await query.find({ $where: 'sleep(1000) || true' }).maxTimeMS(100);\n *\n * @param {Number} [ms] The number of milliseconds\n * @return {Query} this\n * @api public\n */\n\nQuery.prototype.maxTimeMS = function(ms) {\n  this.options.maxTimeMS = ms;\n  return this;\n};\n\n/**\n * Returns the current query filter (also known as conditions) as a [POJO](https://masteringjs.io/tutorials/fundamentals/pojo).\n *\n * #### Example:\n *\n *     const query = new Query();\n *     query.find({ a: 1 }).where('b').gt(2);\n *     query.getFilter(); // { a: 1, b: { $gt: 2 } }\n *\n * @return {Object} current query filter\n * @api public\n */\n\nQuery.prototype.getFilter = function() {\n  return this._conditions;\n};\n\n/**\n * Returns the current query filter. Equivalent to `getFilter()`.\n *\n * You should use `getFilter()` instead of `getQuery()` where possible. `getQuery()`\n * will likely be deprecated in a future release.\n *\n * #### Example:\n *\n *     const query = new Query();\n *     query.find({ a: 1 }).where('b').gt(2);\n *     query.getQuery(); // { a: 1, b: { $gt: 2 } }\n *\n * @return {Object} current query filter\n * @api public\n */\n\nQuery.prototype.getQuery = function() {\n  return this._conditions;\n};\n\n/**\n * Sets the query conditions to the provided JSON object.\n *\n * #### Example:\n *\n *     const query = new Query();\n *     query.find({ a: 1 })\n *     query.setQuery({ a: 2 });\n *     query.getQuery(); // { a: 2 }\n *\n * @param {Object} new query conditions\n * @return {undefined}\n * @api public\n */\n\nQuery.prototype.setQuery = function(val) {\n  this._conditions = val;\n};\n\n/**\n * Returns the current update operations as a JSON object.\n *\n * #### Example:\n *\n *     const query = new Query();\n *     query.updateOne({}, { $set: { a: 5 } });\n *     query.getUpdate(); // { $set: { a: 5 } }\n *\n * @return {Object} current update operations\n * @api public\n */\n\nQuery.prototype.getUpdate = function() {\n  return this._update;\n};\n\n/**\n * Sets the current update operation to new value.\n *\n * #### Example:\n *\n *     const query = new Query();\n *     query.updateOne({}, { $set: { a: 5 } });\n *     query.setUpdate({ $set: { b: 6 } });\n *     query.getUpdate(); // { $set: { b: 6 } }\n *\n * @param {Object} new update operation\n * @return {undefined}\n * @api public\n */\n\nQuery.prototype.setUpdate = function(val) {\n  this._update = val;\n};\n\n/**\n * Returns fields selection for this query.\n *\n * @method _fieldsForExec\n * @return {Object}\n * @api private\n * @memberOf Query\n */\n\nQuery.prototype._fieldsForExec = function() {\n  if (this._fields == null) {\n    return null;\n  }\n  if (Object.keys(this._fields).length === 0) {\n    return null;\n  }\n  return clone(this._fields);\n};\n\n\n/**\n * Return an update document with corrected `$set` operations.\n *\n * @method _updateForExec\n * @return {Object}\n * @api private\n * @memberOf Query\n */\n\nQuery.prototype._updateForExec = function() {\n  const update = clone(this._update, {\n    transform: false,\n    depopulate: true\n  });\n  const ops = Object.keys(update);\n  let i = ops.length;\n  const ret = {};\n\n  while (i--) {\n    const op = ops[i];\n\n    if ('$' !== op[0]) {\n      // fix up $set sugar\n      if (!ret.$set) {\n        if (update.$set) {\n          ret.$set = update.$set;\n        } else {\n          ret.$set = {};\n        }\n      }\n      ret.$set[op] = update[op];\n      ops.splice(i, 1);\n      if (!~ops.indexOf('$set')) ops.push('$set');\n    } else if ('$set' === op) {\n      if (!ret.$set) {\n        ret[op] = update[op];\n      }\n    } else {\n      ret[op] = update[op];\n    }\n  }\n\n  return ret;\n};\n\n/**\n * Makes sure _path is set.\n *\n * This method is inherited by `mquery`\n *\n * @method _ensurePath\n * @param {String} method\n * @api private\n * @memberOf Query\n */\n\n/**\n * Determines if `conds` can be merged using `mquery().merge()`\n *\n * @method canMerge\n * @memberOf Query\n * @instance\n * @param {Object} conds\n * @return {Boolean}\n * @api private\n */\n\n/**\n * Returns default options for this query.\n *\n * @param {Model} model\n * @api private\n */\n\nQuery.prototype._optionsForExec = function(model) {\n  const options = clone(this.options);\n  delete options.populate;\n  model = model || this.model;\n\n  if (!model) {\n    return options;\n  }\n  // Apply schema-level `writeConcern` option\n  applyWriteConcern(model.schema, options);\n\n  const readPreference = model &&\n  model.schema &&\n  model.schema.options &&\n  model.schema.options.read;\n  if (!('readPreference' in options) && readPreference) {\n    options.readPreference = readPreference;\n  }\n\n  if (options.upsert !== void 0) {\n    options.upsert = !!options.upsert;\n  }\n  if (options.writeConcern) {\n    if (options.j) {\n      options.writeConcern.j = options.j;\n      delete options.j;\n    }\n    if (options.w) {\n      options.writeConcern.w = options.w;\n      delete options.w;\n    }\n    if (options.wtimeout) {\n      options.writeConcern.wtimeout = options.wtimeout;\n      delete options.wtimeout;\n    }\n  }\n\n  this._applyPaths();\n  if (this._fields != null) {\n    this._fields = this._castFields(this._fields);\n    const projection = this._fieldsForExec();\n    if (projection != null) {\n      options.projection = projection;\n    }\n  }\n\n  return options;\n};\n\n/**\n * Sets the lean option.\n *\n * Documents returned from queries with the `lean` option enabled are plain\n * javascript objects, not [Mongoose Documents](https://mongoosejs.com/docs/api/document.html). They have no\n * `save` method, getters/setters, virtuals, or other Mongoose features.\n *\n * #### Example:\n *\n *     new Query().lean() // true\n *     new Query().lean(true)\n *     new Query().lean(false)\n *\n *     const docs = await Model.find().lean();\n *     docs[0] instanceof mongoose.Document; // false\n *\n * [Lean is great for high-performance, read-only cases](https://mongoosejs.com/docs/tutorials/lean.html),\n * especially when combined\n * with [cursors](https://mongoosejs.com/docs/queries.html#streaming).\n *\n * If you need virtuals, getters/setters, or defaults with `lean()`, you need\n * to use a plugin. See:\n *\n * - [mongoose-lean-virtuals](https://plugins.mongoosejs.io/plugins/lean-virtuals)\n * - [mongoose-lean-getters](https://plugins.mongoosejs.io/plugins/lean-getters)\n * - [mongoose-lean-defaults](https://www.npmjs.com/package/mongoose-lean-defaults)\n *\n * @param {Boolean|Object} bool defaults to true\n * @return {Query} this\n * @api public\n */\n\nQuery.prototype.lean = function(v) {\n  this._mongooseOptions.lean = arguments.length ? v : true;\n  return this;\n};\n\n/**\n * Adds a `$set` to this query's update without changing the operation.\n * This is useful for query middleware so you can add an update regardless\n * of whether you use `updateOne()`, `updateMany()`, `findOneAndUpdate()`, etc.\n *\n * #### Example:\n *\n *     // Updates `{ $set: { updatedAt: new Date() } }`\n *     new Query().updateOne({}, {}).set('updatedAt', new Date());\n *     new Query().updateMany({}, {}).set({ updatedAt: new Date() });\n *\n * @param {String|Object} path path or object of key/value pairs to set\n * @param {Any} [val] the value to set\n * @return {Query} this\n * @api public\n */\n\nQuery.prototype.set = function(path, val) {\n  if (typeof path === 'object') {\n    const keys = Object.keys(path);\n    for (const key of keys) {\n      this.set(key, path[key]);\n    }\n    return this;\n  }\n\n  this._update = this._update || {};\n  if (path in this._update) {\n    delete this._update[path];\n  }\n  this._update.$set = this._update.$set || {};\n  this._update.$set[path] = val;\n  return this;\n};\n\n/**\n * For update operations, returns the value of a path in the update's `$set`.\n * Useful for writing getters/setters that can work with both update operations\n * and `save()`.\n *\n * #### Example:\n *\n *     const query = Model.updateOne({}, { $set: { name: 'Jean-Luc Picard' } });\n *     query.get('name'); // 'Jean-Luc Picard'\n *\n * @param {String|Object} path path or object of key/value pairs to get\n * @return {Query} this\n * @api public\n */\n\nQuery.prototype.get = function get(path) {\n  const update = this._update;\n  if (update == null) {\n    return void 0;\n  }\n  const $set = update.$set;\n  if ($set == null) {\n    return update[path];\n  }\n\n  if (utils.hasUserDefinedProperty(update, path)) {\n    return update[path];\n  }\n  if (utils.hasUserDefinedProperty($set, path)) {\n    return $set[path];\n  }\n\n  return void 0;\n};\n\n/**\n * Gets/sets the error flag on this query. If this flag is not null or\n * undefined, the `exec()` promise will reject without executing.\n *\n * #### Example:\n *\n *     Query().error(); // Get current error value\n *     Query().error(null); // Unset the current error\n *     Query().error(new Error('test')); // `exec()` will resolve with test\n *     Schema.pre('find', function() {\n *       if (!this.getQuery().userId) {\n *         this.error(new Error('Not allowed to query without setting userId'));\n *       }\n *     });\n *\n * Note that query casting runs **after** hooks, so cast errors will override\n * custom errors.\n *\n * #### Example:\n *\n *     const TestSchema = new Schema({ num: Number });\n *     const TestModel = db.model('Test', TestSchema);\n *     TestModel.find({ num: 'not a number' }).error(new Error('woops')).exec(function(error) {\n *       // `error` will be a cast error because `num` failed to cast\n *     });\n *\n * @param {Error|null} err if set, `exec()` will fail fast before sending the query to MongoDB\n * @return {Query} this\n * @api public\n */\n\nQuery.prototype.error = function error(err) {\n  if (arguments.length === 0) {\n    return this._error;\n  }\n\n  this._error = err;\n  return this;\n};\n\n/**\n * ignore\n * @method _unsetCastError\n * @instance\n * @memberOf Query\n * @api private\n */\n\nQuery.prototype._unsetCastError = function _unsetCastError() {\n  if (this._error != null && !(this._error instanceof CastError)) {\n    return;\n  }\n  return this.error(null);\n};\n\n/**\n * Getter/setter around the current mongoose-specific options for this query\n * Below are the current Mongoose-specific options.\n *\n * - `populate`: an array representing what paths will be populated. Should have one entry for each call to [`Query.prototype.populate()`](https://mongoosejs.com/docs/api/query.html#Query.prototype.populate())\n * - `lean`: if truthy, Mongoose will not [hydrate](https://mongoosejs.com/docs/api/model.html#Model.hydrate()) any documents that are returned from this query. See [`Query.prototype.lean()`](https://mongoosejs.com/docs/api/query.html#Query.prototype.lean()) for more information.\n * - `strict`: controls how Mongoose handles keys that aren't in the schema for updates. This option is `true` by default, which means Mongoose will silently strip any paths in the update that aren't in the schema. See the [`strict` mode docs](https://mongoosejs.com/docs/guide.html#strict) for more information.\n * - `strictQuery`: controls how Mongoose handles keys that aren't in the schema for the query `filter`. This option is `false` by default, which means Mongoose will allow `Model.find({ foo: 'bar' })` even if `foo` is not in the schema. See the [`strictQuery` docs](https://mongoosejs.com/docs/guide.html#strictQuery) for more information.\n * - `nearSphere`: use `$nearSphere` instead of `near()`. See the [`Query.prototype.nearSphere()` docs](https://mongoosejs.com/docs/api/query.html#Query.prototype.nearSphere())\n *\n * Mongoose maintains a separate object for internal options because\n * Mongoose sends `Query.prototype.options` to the MongoDB server, and the\n * above options are not relevant for the MongoDB server.\n *\n * @param {Object} options if specified, overwrites the current options\n * @return {Object} the options\n * @api public\n */\n\nQuery.prototype.mongooseOptions = function(v) {\n  if (arguments.length > 0) {\n    this._mongooseOptions = v;\n  }\n  return this._mongooseOptions;\n};\n\n/**\n * ignore\n * @method _castConditions\n * @memberOf Query\n * @api private\n * @instance\n */\n\nQuery.prototype._castConditions = function() {\n  let sanitizeFilterOpt = undefined;\n  if (this.model != null && utils.hasUserDefinedProperty(this.model.db.options, 'sanitizeFilter')) {\n    sanitizeFilterOpt = this.model.db.options.sanitizeFilter;\n  } else if (this.model != null && utils.hasUserDefinedProperty(this.model.base.options, 'sanitizeFilter')) {\n    sanitizeFilterOpt = this.model.base.options.sanitizeFilter;\n  } else {\n    sanitizeFilterOpt = this._mongooseOptions.sanitizeFilter;\n  }\n\n  if (sanitizeFilterOpt) {\n    sanitizeFilter(this._conditions);\n  }\n\n  try {\n    this.cast(this.model);\n    this._unsetCastError();\n  } catch (err) {\n    this.error(err);\n  }\n};\n\n/*!\n * ignore\n */\n\nfunction _castArrayFilters(query) {\n  try {\n    castArrayFilters(query);\n  } catch (err) {\n    query.error(err);\n  }\n}\n\n/**\n * Execute a `find()`\n *\n * @return {Query} this\n * @api private\n */\nQuery.prototype._find = async function _find() {\n  this._castConditions();\n\n  if (this.error() != null) {\n    throw this.error();\n  }\n\n  const mongooseOptions = this._mongooseOptions;\n  const _this = this;\n  const userProvidedFields = _this._userProvidedFields || {};\n\n  applyGlobalMaxTimeMS(this.options, this.model);\n  applyGlobalDiskUse(this.options, this.model);\n\n  // Separate options to pass down to `completeMany()` in case we need to\n  // set a session on the document\n  const completeManyOptions = Object.assign({}, {\n    session: this && this.options && this.options.session || null,\n    lean: mongooseOptions.lean || null\n  });\n\n  const options = this._optionsForExec();\n\n  this._applyTranslateAliases(options);\n\n  const filter = this._conditions;\n  const fields = options.projection;\n\n  const cursor = await this.mongooseCollection.find(filter, options);\n  if (options.explain) {\n    return cursor.explain();\n  }\n\n  let docs = await cursor.toArray();\n  if (docs.length === 0) {\n    return docs;\n  }\n\n  if (!mongooseOptions.populate) {\n    const versionKey = _this.schema.options.versionKey;\n    if (mongooseOptions.lean && mongooseOptions.lean.versionKey === false && versionKey) {\n      docs.forEach((doc) => {\n        if (versionKey in doc) {\n          delete doc[versionKey];\n        }\n      });\n    }\n    return mongooseOptions.lean ?\n      _completeManyLean(_this.model.schema, docs, null, completeManyOptions) :\n      completeMany(_this.model, docs, fields, userProvidedFields, completeManyOptions);\n  }\n  const pop = helpers.preparePopulationOptionsMQ(_this, mongooseOptions);\n\n  if (mongooseOptions.lean) {\n    return _this.model.populate(docs, pop);\n  }\n\n  docs = await completeMany(_this.model, docs, fields, userProvidedFields, completeManyOptions);\n  await this.model.populate(docs, pop);\n\n  return docs;\n};\n\n/**\n * Find all documents that match `selector`. The result will be an array of documents.\n *\n * If there are too many documents in the result to fit in memory, use\n * [`Query.prototype.cursor()`](https://mongoosejs.com/docs/api/query.html#Query.prototype.cursor())\n *\n * #### Example:\n *\n *     const arr = await Movie.find({ year: { $gte: 1980, $lte: 1989 } });\n *\n * @param {Object|ObjectId} [filter] mongodb filter. If not specified, returns all documents.\n * @return {Query} this\n * @api public\n */\n\nQuery.prototype.find = function(conditions) {\n  if (typeof conditions === 'function' ||\n      typeof arguments[1] === 'function') {\n    throw new MongooseError('Query.prototype.find() no longer accepts a callback');\n  }\n\n  this.op = 'find';\n\n  if (mquery.canMerge(conditions)) {\n    this.merge(conditions);\n\n    prepareDiscriminatorCriteria(this);\n  } else if (conditions != null) {\n    this.error(new ObjectParameterError(conditions, 'filter', 'find'));\n  }\n\n  return this;\n};\n\n/**\n * Merges another Query or conditions object into this one.\n *\n * When a Query is passed, conditions, field selection and options are merged.\n *\n * @param {Query|Object} source\n * @return {Query} this\n */\n\nQuery.prototype.merge = function(source) {\n  if (!source) {\n    return this;\n  }\n\n  const opts = { overwrite: true };\n\n  if (source instanceof Query) {\n    // if source has a feature, apply it to ourselves\n\n    if (source._conditions) {\n      opts.omit = {};\n      if (this._conditions && this._conditions.$and && source._conditions.$and) {\n        opts.omit['$and'] = true;\n        this._conditions.$and = this._conditions.$and.concat(source._conditions.$and);\n      }\n      if (this._conditions && this._conditions.$or && source._conditions.$or) {\n        opts.omit['$or'] = true;\n        this._conditions.$or = this._conditions.$or.concat(source._conditions.$or);\n      }\n      utils.merge(this._conditions, source._conditions, opts);\n    }\n\n    if (source._fields) {\n      this._fields || (this._fields = {});\n      utils.merge(this._fields, source._fields, opts);\n    }\n\n    if (source.options) {\n      this.options || (this.options = {});\n      utils.merge(this.options, source.options, opts);\n    }\n\n    if (source._update) {\n      this._update || (this._update = {});\n      utils.mergeClone(this._update, source._update);\n    }\n\n    if (source._distinct) {\n      this._distinct = source._distinct;\n    }\n\n    utils.merge(this._mongooseOptions, source._mongooseOptions);\n\n    return this;\n  } else if (this.model != null && source instanceof this.model.base.Types.ObjectId) {\n    utils.merge(this._conditions, { _id: source }, opts);\n\n    return this;\n  } else if (source && source.$__) {\n    source = source.toObject(internalToObjectOptions);\n  }\n\n  opts.omit = {};\n  if (this._conditions && this._conditions.$and && source.$and) {\n    opts.omit['$and'] = true;\n    this._conditions.$and = this._conditions.$and.concat(source.$and);\n  }\n  if (this._conditions && this._conditions.$or && source.$or) {\n    opts.omit['$or'] = true;\n    this._conditions.$or = this._conditions.$or.concat(source.$or);\n  }\n\n  // plain object\n  utils.merge(this._conditions, source, opts);\n\n  return this;\n};\n\n/**\n * Adds a collation to this op (MongoDB 3.4 and up)\n *\n * @param {Object} value\n * @return {Query} this\n * @see MongoDB docs https://www.mongodb.com/docs/manual/reference/method/cursor.collation/#cursor.collation\n * @api public\n */\n\nQuery.prototype.collation = function(value) {\n  if (this.options == null) {\n    this.options = {};\n  }\n  this.options.collation = value;\n  return this;\n};\n\n/**\n * Hydrate a single doc from `findOne()`, `findOneAndUpdate()`, etc.\n *\n * @api private\n */\n\nQuery.prototype._completeOne = function(doc, res, callback) {\n  if (!doc && !this.options.includeResultMetadata) {\n    return callback(null, null);\n  }\n\n  const model = this.model;\n  const projection = clone(this._fields);\n  const userProvidedFields = this._userProvidedFields || {};\n  // `populate`, `lean`\n  const mongooseOptions = this._mongooseOptions;\n\n  const options = this.options;\n  if (!options.lean && mongooseOptions.lean) {\n    options.lean = mongooseOptions.lean;\n  }\n\n  if (options.explain) {\n    return callback(null, doc);\n  }\n\n  if (!mongooseOptions.populate) {\n    const versionKey = this.schema.options.versionKey;\n    if (mongooseOptions.lean && mongooseOptions.lean.versionKey === false && versionKey) {\n      if (versionKey in doc) {\n        delete doc[versionKey];\n      }\n    }\n    return mongooseOptions.lean ?\n      _completeOneLean(model.schema, doc, null, res, options, callback) :\n      completeOne(model, doc, res, options, projection, userProvidedFields,\n        null, callback);\n  }\n\n  const pop = helpers.preparePopulationOptionsMQ(this, this._mongooseOptions);\n  if (mongooseOptions.lean) {\n    return model.populate(doc, pop).then(\n      doc => {\n        _completeOneLean(model.schema, doc, null, res, options, callback);\n      },\n      error => {\n        callback(error);\n      }\n    );\n  }\n\n  completeOne(model, doc, res, options, projection, userProvidedFields, [], (err, doc) => {\n    if (err != null) {\n      return callback(err);\n    }\n    model.populate(doc, pop).then(res => { callback(null, res); }, err => { callback(err); });\n  });\n};\n\n/**\n * Internal helper to execute a findOne() operation\n *\n * @see findOne https://www.mongodb.com/docs/manual/reference/method/db.collection.findOne/\n * @api private\n */\n\nQuery.prototype._findOne = async function _findOne() {\n  this._castConditions();\n\n  if (this.error()) {\n    const err = this.error();\n    throw err;\n  }\n\n  applyGlobalMaxTimeMS(this.options, this.model);\n  applyGlobalDiskUse(this.options, this.model);\n\n  const options = this._optionsForExec();\n\n  this._applyTranslateAliases(options);\n\n  // don't pass in the conditions because we already merged them in\n  const doc = await this.mongooseCollection.findOne(this._conditions, options);\n  return new Promise((resolve, reject) => {\n    this._completeOne(doc, null, _wrapThunkCallback(this, (err, res) => {\n      if (err) {\n        return reject(err);\n      }\n      resolve(res);\n    }));\n  });\n};\n\n/**\n * Declares the query a findOne operation. When executed, the first found document is passed to the callback.\n *\n * The result of the query is a single document, or `null` if no document was found.\n *\n * * *Note:* `conditions` is optional, and if `conditions` is null or undefined,\n * mongoose will send an empty `findOne` command to MongoDB, which will return\n * an arbitrary document. If you're querying by `_id`, use `Model.findById()`\n * instead.\n *\n * This function triggers the following middleware.\n *\n * - `findOne()`\n *\n * #### Example:\n *\n *     const query = Kitten.where({ color: 'white' });\n *     const kitten = await query.findOne();\n *\n * @param {Object} [filter] mongodb selector\n * @param {Object} [projection] optional fields to return\n * @param {Object} [options] see [`setOptions()`](https://mongoosejs.com/docs/api/query.html#Query.prototype.setOptions())\n * @param {Boolean} [options.translateAliases=null] If set to `true`, translates any schema-defined aliases in `filter`, `projection`, `update`, and `distinct`. Throws an error if there are any conflicts where both alias and raw property are defined on the same object.\n * @return {Query} this\n * @see findOne https://www.mongodb.com/docs/manual/reference/method/db.collection.findOne/\n * @see Query.select https://mongoosejs.com/docs/api/query.html#Query.prototype.select()\n * @api public\n */\n\nQuery.prototype.findOne = function(conditions, projection, options) {\n  if (typeof conditions === 'function' ||\n      typeof projection === 'function' ||\n      typeof options === 'function' ||\n      typeof arguments[3] === 'function') {\n    throw new MongooseError('Query.prototype.findOne() no longer accepts a callback');\n  }\n\n  this.op = 'findOne';\n  this._validateOp();\n\n  if (options) {\n    this.setOptions(options);\n  }\n\n  if (projection) {\n    this.select(projection);\n  }\n\n  if (mquery.canMerge(conditions)) {\n    this.merge(conditions);\n\n    prepareDiscriminatorCriteria(this);\n  } else if (conditions != null) {\n    this.error(new ObjectParameterError(conditions, 'filter', 'findOne'));\n  }\n\n  return this;\n};\n\n\n/**\n * Execute a countDocuments query\n *\n * @see countDocuments https://mongodb.github.io/node-mongodb-native/4.9/classes/Collection.html#countDocuments\n * @api private\n */\n\nQuery.prototype._countDocuments = async function _countDocuments() {\n  try {\n    this.cast(this.model);\n  } catch (err) {\n    this.error(err);\n  }\n\n  if (this.error()) {\n    throw this.error();\n  }\n\n  applyGlobalMaxTimeMS(this.options, this.model);\n  applyGlobalDiskUse(this.options, this.model);\n\n  const options = this._optionsForExec();\n\n  this._applyTranslateAliases(options);\n\n  const conds = this._conditions;\n\n  return this.mongooseCollection.countDocuments(conds, options);\n};\n\n/*!\n * If `translateAliases` option is set, call `Model.translateAliases()`\n * on the following query properties: filter, projection, update, distinct.\n */\n\nQuery.prototype._applyTranslateAliases = function _applyTranslateAliases(options) {\n  let applyTranslateAliases = false;\n  if ('translateAliases' in this._mongooseOptions) {\n    applyTranslateAliases = this._mongooseOptions.translateAliases;\n  } else if (this.model?.schema?._userProvidedOptions?.translateAliases != null) {\n    applyTranslateAliases = this.model.schema._userProvidedOptions.translateAliases;\n  } else if (this.model?.base?.options?.translateAliases != null) {\n    applyTranslateAliases = this.model.base.options.translateAliases;\n  }\n  if (!applyTranslateAliases) {\n    return;\n  }\n\n  if (this.model?.schema?.aliases && Object.keys(this.model.schema.aliases).length > 0) {\n    this.model.translateAliases(this._conditions, true);\n    this.model.translateAliases(options.projection, true);\n    this.model.translateAliases(this._update, true);\n    if (this._distinct != null && this.model.schema.aliases[this._distinct] != null) {\n      this._distinct = this.model.schema.aliases[this._distinct];\n    }\n  }\n};\n\n/**\n * Execute a estimatedDocumentCount() query\n *\n * @see estimatedDocumentCount https://mongodb.github.io/node-mongodb-native/4.9/classes/Collection.html#estimatedDocumentCount\n * @api private\n */\n\nQuery.prototype._estimatedDocumentCount = async function _estimatedDocumentCount() {\n  if (this.error()) {\n    throw this.error();\n  }\n\n  const options = this._optionsForExec();\n\n  return this.mongooseCollection.estimatedDocumentCount(options);\n};\n\n/**\n * Specifies this query as a `estimatedDocumentCount()` query. Faster than\n * using `countDocuments()` for large collections because\n * `estimatedDocumentCount()` uses collection metadata rather than scanning\n * the entire collection.\n *\n * `estimatedDocumentCount()` does **not** accept a filter. `Model.find({ foo: bar }).estimatedDocumentCount()`\n * is equivalent to `Model.find().estimatedDocumentCount()`\n *\n * This function triggers the following middleware.\n *\n * - `estimatedDocumentCount()`\n *\n * #### Example:\n *\n *     await Model.find().estimatedDocumentCount();\n *\n * @param {Object} [options] passed transparently to the [MongoDB driver](https://mongodb.github.io/node-mongodb-native/4.9/interfaces/EstimatedDocumentCountOptions.html)\n * @return {Query} this\n * @see estimatedDocumentCount https://mongodb.github.io/node-mongodb-native/4.9/classes/Collection.html#estimatedDocumentCount\n * @api public\n */\n\nQuery.prototype.estimatedDocumentCount = function(options) {\n  if (typeof options === 'function' ||\n      typeof arguments[1] === 'function') {\n    throw new MongooseError('Query.prototype.estimatedDocumentCount() no longer accepts a callback');\n  }\n\n  this.op = 'estimatedDocumentCount';\n  this._validateOp();\n\n  if (typeof options === 'object' && options != null) {\n    this.setOptions(options);\n  }\n\n  return this;\n};\n\n/**\n * Specifies this query as a `countDocuments()` query. Behaves like `count()`,\n * except it always does a full collection scan when passed an empty filter `{}`.\n *\n * There are also minor differences in how `countDocuments()` handles\n * [`$where` and a couple geospatial operators](https://mongodb.github.io/node-mongodb-native/4.9/classes/Collection.html#countDocuments).\n * versus `count()`.\n *\n * This function triggers the following middleware.\n *\n * - `countDocuments()`\n *\n * #### Example:\n *\n *     const countQuery = model.where({ 'color': 'black' }).countDocuments();\n *\n *     query.countDocuments({ color: 'black' }).count().exec();\n *\n *     await query.countDocuments({ color: 'black' });\n *\n *     query.where('color', 'black').countDocuments().exec();\n *\n * The `countDocuments()` function is similar to `count()`, but there are a\n * [few operators that `countDocuments()` does not support](https://mongodb.github.io/node-mongodb-native/4.9/classes/Collection.html#countDocuments).\n * Below are the operators that `count()` supports but `countDocuments()` does not,\n * and the suggested replacement:\n *\n * - `$where`: [`$expr`](https://www.mongodb.com/docs/manual/reference/operator/query/expr/)\n * - `$near`: [`$geoWithin`](https://www.mongodb.com/docs/manual/reference/operator/query/geoWithin/) with [`$center`](https://www.mongodb.com/docs/manual/reference/operator/query/center/#op._S_center)\n * - `$nearSphere`: [`$geoWithin`](https://www.mongodb.com/docs/manual/reference/operator/query/geoWithin/) with [`$centerSphere`](https://www.mongodb.com/docs/manual/reference/operator/query/centerSphere/#op._S_centerSphere)\n *\n * @param {Object} [filter] mongodb selector\n * @param {Object} [options]\n * @return {Query} this\n * @see countDocuments https://mongodb.github.io/node-mongodb-native/4.9/classes/Collection.html#countDocuments\n * @api public\n */\n\nQuery.prototype.countDocuments = function(conditions, options) {\n  if (typeof conditions === 'function' ||\n      typeof options === 'function' ||\n      typeof arguments[2] === 'function') {\n    throw new MongooseError('Query.prototype.countDocuments() no longer accepts a callback');\n  }\n\n  this.op = 'countDocuments';\n  this._validateOp();\n\n  if (mquery.canMerge(conditions)) {\n    this.merge(conditions);\n  }\n\n  if (typeof options === 'object' && options != null) {\n    this.setOptions(options);\n  }\n\n  return this;\n};\n\n/**\n * Execute a `distinct()` query\n *\n * @see distinct https://www.mongodb.com/docs/manual/reference/method/db.collection.distinct/\n * @api private\n */\n\nQuery.prototype.__distinct = async function __distinct() {\n  this._castConditions();\n\n  if (this.error()) {\n    throw this.error();\n  }\n\n  applyGlobalMaxTimeMS(this.options, this.model);\n  applyGlobalDiskUse(this.options, this.model);\n\n  const options = this._optionsForExec();\n  this._applyTranslateAliases(options);\n\n  return this.mongooseCollection.\n    distinct(this._distinct, this._conditions, options);\n};\n\n/**\n * Declares or executes a distinct() operation.\n *\n * This function does not trigger any middleware.\n *\n * #### Example:\n *\n *     distinct(field, conditions)\n *     distinct(field)\n *     distinct()\n *\n * @param {String} [field]\n * @param {Object|Query} [filter]\n * @return {Query} this\n * @see distinct https://www.mongodb.com/docs/manual/reference/method/db.collection.distinct/\n * @api public\n */\n\nQuery.prototype.distinct = function(field, conditions) {\n  if (typeof field === 'function' ||\n      typeof conditions === 'function' ||\n      typeof arguments[2] === 'function') {\n    throw new MongooseError('Query.prototype.distinct() no longer accepts a callback');\n  }\n\n  this.op = 'distinct';\n  this._validateOp();\n\n  if (mquery.canMerge(conditions)) {\n    this.merge(conditions);\n\n    prepareDiscriminatorCriteria(this);\n  } else if (conditions != null) {\n    this.error(new ObjectParameterError(conditions, 'filter', 'distinct'));\n  }\n\n  if (field != null) {\n    this._distinct = field;\n  }\n\n  return this;\n};\n\n/**\n * Sets the sort order\n *\n * If an object is passed, values allowed are `asc`, `desc`, `ascending`, `descending`, `1`, and `-1`.\n *\n * If a string is passed, it must be a space delimited list of path names. The\n * sort order of each path is ascending unless the path name is prefixed with `-`\n * which will be treated as descending.\n *\n * #### Example:\n *\n *     // sort by \"field\" ascending and \"test\" descending\n *     query.sort({ field: 'asc', test: -1 });\n *\n *     // equivalent\n *     query.sort('field -test');\n *\n *     // also possible is to use a array with array key-value pairs\n *     query.sort([['field', 'asc']]);\n *\n * #### Note:\n *\n * Cannot be used with `distinct()`\n *\n * @param {Object|String|Array<Array<(string | number)>>} arg\n * @return {Query} this\n * @see cursor.sort https://www.mongodb.com/docs/manual/reference/method/cursor.sort/\n * @api public\n */\n\nQuery.prototype.sort = function(arg) {\n  if (arguments.length > 1) {\n    throw new Error('sort() only takes 1 Argument');\n  }\n\n  if (this.options.sort == null) {\n    this.options.sort = {};\n  }\n  const sort = this.options.sort;\n  if (typeof arg === 'string') {\n    const properties = arg.indexOf(' ') === -1 ? [arg] : arg.split(' ');\n    for (let property of properties) {\n      const ascend = '-' == property[0] ? -1 : 1;\n      if (ascend === -1) {\n        property = property.slice(1);\n      }\n      if (specialProperties.has(property)) {\n        continue;\n      }\n      sort[property] = ascend;\n    }\n  } else if (Array.isArray(arg)) {\n    for (const pair of arg) {\n      if (!Array.isArray(pair)) {\n        throw new TypeError('Invalid sort() argument, must be array of arrays');\n      }\n      const key = '' + pair[0];\n      if (specialProperties.has(key)) {\n        continue;\n      }\n      sort[key] = _handleSortValue(pair[1], key);\n    }\n  } else if (typeof arg === 'object' && arg != null && !(arg instanceof Map)) {\n    for (const key of Object.keys(arg)) {\n      if (specialProperties.has(key)) {\n        continue;\n      }\n      sort[key] = _handleSortValue(arg[key], key);\n    }\n  } else if (arg instanceof Map) {\n    for (let key of arg.keys()) {\n      key = '' + key;\n      if (specialProperties.has(key)) {\n        continue;\n      }\n      sort[key] = _handleSortValue(arg.get(key), key);\n    }\n  } else if (arg != null) {\n    throw new TypeError('Invalid sort() argument. Must be a string, object, array, or map.');\n  }\n\n  return this;\n};\n\n/*!\n * Convert sort values\n */\n\nfunction _handleSortValue(val, key) {\n  if (val === 1 || val === 'asc' || val === 'ascending') {\n    return 1;\n  }\n  if (val === -1 || val === 'desc' || val === 'descending') {\n    return -1;\n  }\n  if (val?.$meta != null) {\n    return { $meta: val.$meta };\n  }\n  throw new TypeError('Invalid sort value: { ' + key + ': ' + val + ' }');\n}\n\n/**\n * Declare and/or execute this query as a `deleteOne()` operation. Works like\n * remove, except it deletes at most one document regardless of the `single`\n * option.\n *\n * This function triggers `deleteOne` middleware.\n *\n * #### Example:\n *\n *     await Character.deleteOne({ name: 'Eddard Stark' });\n *\n * This function calls the MongoDB driver's [`Collection#deleteOne()` function](https://mongodb.github.io/node-mongodb-native/4.9/classes/Collection.html#deleteOne).\n * The returned [promise](https://mongoosejs.com/docs/queries.html) resolves to an\n * object that contains 3 properties:\n *\n * - `ok`: `1` if no errors occurred\n * - `deletedCount`: the number of documents deleted\n * - `n`: the number of documents deleted. Equal to `deletedCount`.\n *\n * #### Example:\n *\n *     const res = await Character.deleteOne({ name: 'Eddard Stark' });\n *     // `1` if MongoDB deleted a doc, `0` if no docs matched the filter `{ name: ... }`\n *     res.deletedCount;\n *\n * @param {Object|Query} [filter] mongodb selector\n * @param {Object} [options] optional see [`Query.prototype.setOptions()`](https://mongoosejs.com/docs/api/query.html#Query.prototype.setOptions())\n * @return {Query} this\n * @see DeleteResult https://mongodb.github.io/node-mongodb-native/4.9/interfaces/DeleteResult.html\n * @see deleteOne https://mongodb.github.io/node-mongodb-native/4.9/classes/Collection.html#deleteOne\n * @api public\n */\n\nQuery.prototype.deleteOne = function deleteOne(filter, options) {\n  if (typeof filter === 'function' || typeof options === 'function' || typeof arguments[2] === 'function') {\n    throw new MongooseError('Query.prototype.deleteOne() no longer accepts a callback');\n  }\n  this.op = 'deleteOne';\n  this.setOptions(options);\n\n  if (mquery.canMerge(filter)) {\n    this.merge(filter);\n\n    prepareDiscriminatorCriteria(this);\n  } else if (filter != null) {\n    this.error(new ObjectParameterError(filter, 'filter', 'deleteOne'));\n  }\n\n  return this;\n};\n\n/**\n * Internal thunk for `deleteOne()`\n *\n * @method _deleteOne\n * @instance\n * @memberOf Query\n * @api private\n */\n\nQuery.prototype._deleteOne = async function _deleteOne() {\n  this._castConditions();\n\n  if (this.error() != null) {\n    throw this.error();\n  }\n\n  const options = this._optionsForExec();\n  this._applyTranslateAliases(options);\n\n  return this.mongooseCollection.deleteOne(this._conditions, options);\n};\n\n/**\n * Declare and/or execute this query as a `deleteMany()` operation. Works like\n * remove, except it deletes _every_ document that matches `filter` in the\n * collection, regardless of the value of `single`.\n *\n * This function triggers `deleteMany` middleware.\n *\n * #### Example:\n *\n *     await Character.deleteMany({ name: /Stark/, age: { $gte: 18 } });\n *\n * This function calls the MongoDB driver's [`Collection#deleteMany()` function](https://mongodb.github.io/node-mongodb-native/4.9/classes/Collection.html#deleteMany).\n * The returned [promise](https://mongoosejs.com/docs/queries.html) resolves to an\n * object that contains 3 properties:\n *\n * - `ok`: `1` if no errors occurred\n * - `deletedCount`: the number of documents deleted\n * - `n`: the number of documents deleted. Equal to `deletedCount`.\n *\n * #### Example:\n *\n *     const res = await Character.deleteMany({ name: /Stark/, age: { $gte: 18 } });\n *     // `0` if no docs matched the filter, number of docs deleted otherwise\n *     res.deletedCount;\n *\n * @param {Object|Query} [filter] mongodb selector\n * @param {Object} [options] optional see [`Query.prototype.setOptions()`](https://mongoosejs.com/docs/api/query.html#Query.prototype.setOptions())\n * @return {Query} this\n * @see DeleteResult https://mongodb.github.io/node-mongodb-native/4.9/interfaces/DeleteResult.html\n * @see deleteMany https://mongodb.github.io/node-mongodb-native/4.9/classes/Collection.html#deleteMany\n * @api public\n */\n\nQuery.prototype.deleteMany = function(filter, options) {\n  if (typeof filter === 'function' || typeof options === 'function' || typeof arguments[2] === 'function') {\n    throw new MongooseError('Query.prototype.deleteMany() no longer accepts a callback');\n  }\n  this.setOptions(options);\n  this.op = 'deleteMany';\n\n  if (mquery.canMerge(filter)) {\n    this.merge(filter);\n\n    prepareDiscriminatorCriteria(this);\n  } else if (filter != null) {\n    this.error(new ObjectParameterError(filter, 'filter', 'deleteMany'));\n  }\n\n  return this;\n};\n\n/**\n * Execute a `deleteMany()` query\n *\n * @param {Function} callback\n * @method _deleteMany\n * @instance\n * @memberOf Query\n * @api private\n */\n\nQuery.prototype._deleteMany = async function _deleteMany() {\n  this._castConditions();\n\n  if (this.error() != null) {\n    throw this.error();\n  }\n\n  const options = this._optionsForExec();\n  this._applyTranslateAliases(options);\n\n  return this.mongooseCollection.deleteMany(this._conditions, options);\n};\n\n/**\n * hydrates a document\n *\n * @param {Model} model\n * @param {Document} doc\n * @param {Object} res 3rd parameter to callback\n * @param {Object} fields\n * @param {Query} self\n * @param {Array} [pop] array of paths used in population\n * @param {Function} callback\n * @api private\n */\n\nfunction completeOne(model, doc, res, options, fields, userProvidedFields, pop, callback) {\n  if (options.includeResultMetadata && doc == null) {\n    _init(null);\n    return null;\n  }\n\n  helpers.createModelAndInit(model, doc, fields, userProvidedFields, options, pop, _init);\n\n  function _init(err, casted) {\n    if (err) {\n      return immediate(() => callback(err));\n    }\n\n\n    if (options.includeResultMetadata) {\n      if (doc && casted) {\n        if (options.session != null) {\n          casted.$session(options.session);\n        }\n        res.value = casted;\n      } else {\n        res.value = null;\n      }\n      return immediate(() => callback(null, res));\n    }\n    if (options.session != null) {\n      casted.$session(options.session);\n    }\n    immediate(() => callback(null, casted));\n  }\n}\n\n/**\n * If the model is a discriminator type and not root, then add the key & value to the criteria.\n * @param {Query} query\n * @api private\n */\n\nfunction prepareDiscriminatorCriteria(query) {\n  if (!query || !query.model || !query.model.schema) {\n    return;\n  }\n\n  const schema = query.model.schema;\n\n  if (schema && schema.discriminatorMapping && !schema.discriminatorMapping.isRoot) {\n    query._conditions[schema.discriminatorMapping.key] = schema.discriminatorMapping.value;\n  }\n}\n\n/**\n * Issues a mongodb `findOneAndUpdate()` command.\n *\n * Finds a matching document, updates it according to the `update` arg, passing any `options`, and returns the found\n * document (if any).\n *\n * This function triggers the following middleware.\n *\n * - `findOneAndUpdate()`\n *\n * #### Available options\n *\n * - `new`: bool - if true, return the modified document rather than the original. defaults to false (changed in 4.0)\n * - `upsert`: bool - creates the object if it doesn't exist. defaults to false.\n * - `fields`: {Object|String} - Field selection. Equivalent to `.select(fields).findOneAndUpdate()`\n * - `sort`: if multiple docs are found by the conditions, sets the sort order to choose which doc to update\n * - `maxTimeMS`: puts a time limit on the query - requires mongodb >= 2.6.0\n * - `runValidators`: if true, runs [update validators](https://mongoosejs.com/docs/validation.html#update-validators) on this command. Update validators validate the update operation against the model's schema.\n * - `setDefaultsOnInsert`: `true` by default. If `setDefaultsOnInsert` and `upsert` are true, mongoose will apply the [defaults](https://mongoosejs.com/docs/defaults.html) specified in the model's schema if a new document is created.\n *\n * #### Example:\n *\n *     query.findOneAndUpdate(conditions, update, options)  // returns Query\n *     query.findOneAndUpdate(conditions, update)           // returns Query\n *     query.findOneAndUpdate(update)                       // returns Query\n *     query.findOneAndUpdate()                             // returns Query\n *\n * @method findOneAndUpdate\n * @memberOf Query\n * @instance\n * @param {Object|Query} [filter]\n * @param {Object} [doc]\n * @param {Object} [options]\n * @param {Boolean} [options.includeResultMetadata] if true, returns the full [ModifyResult from the MongoDB driver](https://mongodb.github.io/node-mongodb-native/4.9/interfaces/ModifyResult.html) rather than just the document\n * @param {Boolean|String} [options.strict] overwrites the schema's [strict mode option](https://mongoosejs.com/docs/guide.html#strict)\n * @param {ClientSession} [options.session=null] The session associated with this query. See [transactions docs](https://mongoosejs.com/docs/transactions.html).\n * @param {Boolean} [options.multipleCastError] by default, mongoose only returns the first error that occurred in casting the query. Turn on this option to aggregate all the cast errors.\n * @param {Boolean} [options.new=false] By default, `findOneAndUpdate()` returns the document as it was **before** `update` was applied. If you set `new: true`, `findOneAndUpdate()` will instead give you the object after `update` was applied.\n * @param {Object} [options.lean] if truthy, mongoose will return the document as a plain JavaScript object rather than a mongoose document. See [`Query.lean()`](https://mongoosejs.com/docs/api/query.html#Query.prototype.lean()) and [the Mongoose lean tutorial](https://mongoosejs.com/docs/tutorials/lean.html).\n * @param {ClientSession} [options.session=null] The session associated with this query. See [transactions docs](https://mongoosejs.com/docs/transactions.html).\n * @param {Boolean|String} [options.strict] overwrites the schema's [strict mode option](https://mongoosejs.com/docs/guide.html#strict)\n * @param {Boolean} [options.timestamps=null] If set to `false` and [schema-level timestamps](https://mongoosejs.com/docs/guide.html#timestamps) are enabled, skip timestamps for this update. Note that this allows you to overwrite timestamps. Does nothing if schema-level timestamps are not set.\n * @param {Boolean} [options.returnOriginal=null] An alias for the `new` option. `returnOriginal: false` is equivalent to `new: true`.\n * @param {Boolean} [options.translateAliases=null] If set to `true`, translates any schema-defined aliases in `filter`, `projection`, `update`, and `distinct`. Throws an error if there are any conflicts where both alias and raw property are defined on the same object.\n * @see Tutorial https://mongoosejs.com/docs/tutorials/findoneandupdate.html\n * @see findAndModify command https://www.mongodb.com/docs/manual/reference/command/findAndModify/\n * @see ModifyResult https://mongodb.github.io/node-mongodb-native/4.9/interfaces/ModifyResult.html\n * @see findOneAndUpdate https://mongodb.github.io/node-mongodb-native/4.9/classes/Collection.html#findOneAndUpdate\n * @return {Query} this\n * @api public\n */\n\nQuery.prototype.findOneAndUpdate = function(filter, doc, options) {\n  if (typeof filter === 'function' ||\n      typeof doc === 'function' ||\n      typeof options === 'function' ||\n      typeof arguments[3] === 'function') {\n    throw new MongooseError('Query.prototype.findOneAndUpdate() no longer accepts a callback');\n  }\n\n  this.op = 'findOneAndUpdate';\n  this._validateOp();\n  this._validate();\n\n  switch (arguments.length) {\n    case 2:\n      options = undefined;\n      break;\n    case 1:\n      doc = filter;\n      filter = options = undefined;\n      break;\n  }\n\n  if (mquery.canMerge(filter)) {\n    this.merge(filter);\n  } else if (filter != null) {\n    this.error(\n      new ObjectParameterError(filter, 'filter', 'findOneAndUpdate')\n    );\n  }\n\n  // apply doc\n  if (doc) {\n    this._mergeUpdate(doc);\n  }\n\n  options = options ? clone(options) : {};\n\n  if (options.projection) {\n    this.select(options.projection);\n    delete options.projection;\n  }\n  if (options.fields) {\n    this.select(options.fields);\n    delete options.fields;\n  }\n\n  const returnOriginal = this &&\n    this.model &&\n    this.model.base &&\n    this.model.base.options &&\n    this.model.base.options.returnOriginal;\n  if (options.new == null && options.returnDocument == null && options.returnOriginal == null && returnOriginal != null) {\n    options.returnOriginal = returnOriginal;\n  }\n\n  this.setOptions(options);\n\n  return this;\n};\n\n/**\n * Execute a findOneAndUpdate operation\n *\n * @method _findOneAndUpdate\n * @memberOf Query\n * @api private\n */\n\nQuery.prototype._findOneAndUpdate = async function _findOneAndUpdate() {\n  this._castConditions();\n\n  _castArrayFilters(this);\n\n  if (this.error()) {\n    throw this.error();\n  }\n\n  applyGlobalMaxTimeMS(this.options, this.model);\n  applyGlobalDiskUse(this.options, this.model);\n\n  if ('strict' in this.options) {\n    this._mongooseOptions.strict = this.options.strict;\n  }\n  const options = this._optionsForExec(this.model);\n  convertNewToReturnDocument(options);\n  this._applyTranslateAliases(options);\n\n  this._update = this._castUpdate(this._update);\n\n  const _opts = Object.assign({}, options, {\n    setDefaultsOnInsert: this._mongooseOptions.setDefaultsOnInsert\n  });\n  this._update = setDefaultsOnInsert(this._conditions, this.model.schema,\n    this._update, _opts);\n\n  if (!this._update || Object.keys(this._update).length === 0) {\n    if (options.upsert) {\n      // still need to do the upsert to empty doc\n      const doc = clone(this._update);\n      delete doc._id;\n      this._update = { $set: doc };\n    } else {\n      this._executionStack = null;\n      const res = await this._findOne();\n      return res;\n    }\n  } else if (this._update instanceof Error) {\n    throw this._update;\n  } else {\n    // In order to make MongoDB 2.6 happy (see\n    // https://jira.mongodb.org/browse/SERVER-12266 and related issues)\n    // if we have an actual update document but $set is empty, junk the $set.\n    if (this._update.$set && Object.keys(this._update.$set).length === 0) {\n      delete this._update.$set;\n    }\n  }\n\n  const runValidators = _getOption(this, 'runValidators', false);\n  if (runValidators) {\n    await this.validate(this._update, options, false);\n  }\n\n  if (this._update.toBSON) {\n    this._update = this._update.toBSON();\n  }\n\n  let res = await this.mongooseCollection.findOneAndUpdate(this._conditions, this._update, options);\n  for (const fn of this._transforms) {\n    res = fn(res);\n  }\n  const doc = !options.includeResultMetadata ? res : res.value;\n\n  return new Promise((resolve, reject) => {\n    this._completeOne(doc, res, _wrapThunkCallback(this, (err, res) => {\n      if (err) {\n        return reject(err);\n      }\n      resolve(res);\n    }));\n  });\n};\n\n/**\n * Issues a MongoDB [findOneAndDelete](https://www.mongodb.com/docs/manual/reference/method/db.collection.findOneAndDelete/) command.\n *\n * Finds a matching document, removes it, and returns the found document (if any).\n *\n * This function triggers the following middleware.\n *\n * - `findOneAndDelete()`\n *\n * #### Available options\n *\n * - `sort`: if multiple docs are found by the conditions, sets the sort order to choose which doc to update\n * - `maxTimeMS`: puts a time limit on the query - requires mongodb >= 2.6.0\n *\n * #### Callback Signature\n *\n *     function(error, doc) {\n *       // error: any errors that occurred\n *       // doc: the document before updates are applied if `new: false`, or after updates if `new = true`\n *     }\n *\n * #### Example:\n *\n *     A.where().findOneAndDelete(conditions, options)  // return Query\n *     A.where().findOneAndDelete(conditions) // returns Query\n *     A.where().findOneAndDelete()           // returns Query\n *\n * @method findOneAndDelete\n * @memberOf Query\n * @param {Object} [filter]\n * @param {Object} [options]\n * @param {Boolean} [options.includeResultMetadata] if true, returns the full [ModifyResult from the MongoDB driver](https://mongodb.github.io/node-mongodb-native/4.9/interfaces/ModifyResult.html) rather than just the document\n * @param {ClientSession} [options.session=null] The session associated with this query. See [transactions docs](https://mongoosejs.com/docs/transactions.html).\n * @param {Boolean|String} [options.strict] overwrites the schema's [strict mode option](https://mongoosejs.com/docs/guide.html#strict)\n * @return {Query} this\n * @see findAndModify command https://www.mongodb.com/docs/manual/reference/command/findAndModify/\n * @api public\n */\n\nQuery.prototype.findOneAndDelete = function(filter, options) {\n  if (typeof filter === 'function' ||\n      typeof options === 'function' ||\n      typeof arguments[2] === 'function') {\n    throw new MongooseError('Query.prototype.findOneAndDelete() no longer accepts a callback');\n  }\n\n  this.op = 'findOneAndDelete';\n  this._validateOp();\n  this._validate();\n\n  if (mquery.canMerge(filter)) {\n    this.merge(filter);\n  }\n\n  options && this.setOptions(options);\n\n  return this;\n};\n\n/**\n * Execute a `findOneAndDelete()` query\n *\n * @return {Query} this\n * @method _findOneAndDelete\n * @memberOf Query\n * @api private\n */\nQuery.prototype._findOneAndDelete = async function _findOneAndDelete() {\n  this._castConditions();\n\n  if (this.error() != null) {\n    throw this.error();\n  }\n\n  const includeResultMetadata = this.options.includeResultMetadata;\n\n  const filter = this._conditions;\n  const options = this._optionsForExec(this.model);\n  this._applyTranslateAliases(options);\n\n  let res = await this.mongooseCollection.findOneAndDelete(filter, options);\n  for (const fn of this._transforms) {\n    res = fn(res);\n  }\n  const doc = !includeResultMetadata ? res : res.value;\n\n  return new Promise((resolve, reject) => {\n    this._completeOne(doc, res, _wrapThunkCallback(this, (err, res) => {\n      if (err) {\n        return reject(err);\n      }\n      resolve(res);\n    }));\n  });\n};\n\n/**\n * Issues a MongoDB [findOneAndReplace](https://www.mongodb.com/docs/manual/reference/method/db.collection.findOneAndReplace/) command.\n *\n * Finds a matching document, removes it, and returns the found document (if any).\n *\n * This function triggers the following middleware.\n *\n * - `findOneAndReplace()`\n *\n * #### Available options\n *\n * - `sort`: if multiple docs are found by the conditions, sets the sort order to choose which doc to update\n * - `maxTimeMS`: puts a time limit on the query - requires mongodb >= 2.6.0\n * - `includeResultMetadata`: if true, returns the full [ModifyResult from the MongoDB driver](https://mongodb.github.io/node-mongodb-native/4.9/interfaces/ModifyResult.html) rather than just the document\n *\n * #### Callback Signature\n *\n *     function(error, doc) {\n *       // error: any errors that occurred\n *       // doc: the document before updates are applied if `new: false`, or after updates if `new = true`\n *     }\n *\n * #### Example:\n *\n *     A.where().findOneAndReplace(filter, replacement, options); // return Query\n *     A.where().findOneAndReplace(filter); // returns Query\n *     A.where().findOneAndReplace(); // returns Query\n *\n * @method findOneAndReplace\n * @memberOf Query\n * @param {Object} [filter]\n * @param {Object} [replacement]\n * @param {Object} [options]\n * @param {Boolean} [options.includeResultMetadata] if true, returns the full [ModifyResult from the MongoDB driver](https://mongodb.github.io/node-mongodb-native/4.9/interfaces/ModifyResult.html) rather than just the document\n * @param {ClientSession} [options.session=null] The session associated with this query. See [transactions docs](https://mongoosejs.com/docs/transactions.html).\n * @param {Boolean|String} [options.strict] overwrites the schema's [strict mode option](https://mongoosejs.com/docs/guide.html#strict)\n * @param {Boolean} [options.new=false] By default, `findOneAndUpdate()` returns the document as it was **before** `update` was applied. If you set `new: true`, `findOneAndUpdate()` will instead give you the object after `update` was applied.\n * @param {Object} [options.lean] if truthy, mongoose will return the document as a plain JavaScript object rather than a mongoose document. See [`Query.lean()`](https://mongoosejs.com/docs/api/query.html#Query.prototype.lean()) and [the Mongoose lean tutorial](https://mongoosejs.com/docs/tutorials/lean.html).\n * @param {ClientSession} [options.session=null] The session associated with this query. See [transactions docs](https://mongoosejs.com/docs/transactions.html).\n * @param {Boolean|String} [options.strict] overwrites the schema's [strict mode option](https://mongoosejs.com/docs/guide.html#strict)\n * @param {Boolean} [options.timestamps=null] If set to `false` and [schema-level timestamps](https://mongoosejs.com/docs/guide.html#timestamps) are enabled, skip timestamps for this update. Note that this allows you to overwrite timestamps. Does nothing if schema-level timestamps are not set.\n * @param {Boolean} [options.returnOriginal=null] An alias for the `new` option. `returnOriginal: false` is equivalent to `new: true`.\n * @param {Boolean} [options.translateAliases=null] If set to `true`, translates any schema-defined aliases in `filter`, `projection`, `update`, and `distinct`. Throws an error if there are any conflicts where both alias and raw property are defined on the same object.\n * @return {Query} this\n * @api public\n */\n\nQuery.prototype.findOneAndReplace = function(filter, replacement, options) {\n  if (typeof filter === 'function' ||\n      typeof replacement === 'function' ||\n      typeof options === 'function' ||\n      typeof arguments[4] === 'function') {\n    throw new MongooseError('Query.prototype.findOneAndReplace() no longer accepts a callback');\n  }\n\n  this.op = 'findOneAndReplace';\n  this._validateOp();\n  this._validate();\n\n  if (mquery.canMerge(filter)) {\n    this.merge(filter);\n  } else if (filter != null) {\n    this.error(\n      new ObjectParameterError(filter, 'filter', 'findOneAndReplace')\n    );\n  }\n\n  if (replacement != null) {\n    this._mergeUpdate(replacement);\n  }\n\n  options = options || {};\n\n  const returnOriginal = this &&\n  this.model &&\n  this.model.base &&\n  this.model.base.options &&\n  this.model.base.options.returnOriginal;\n  if (options.new == null && options.returnDocument == null && options.returnOriginal == null && returnOriginal != null) {\n    options.returnOriginal = returnOriginal;\n  }\n  this.setOptions(options);\n\n  return this;\n};\n\n/**\n * Execute a findOneAndReplace() query\n *\n * @return {Query} this\n * @method _findOneAndReplace\n * @instance\n * @memberOf Query\n * @api private\n */\nQuery.prototype._findOneAndReplace = async function _findOneAndReplace() {\n  this._castConditions();\n  if (this.error() != null) {\n    throw this.error();\n  }\n\n  if ('strict' in this.options) {\n    this._mongooseOptions.strict = this.options.strict;\n    delete this.options.strict;\n  }\n\n  const filter = this._conditions;\n  const options = this._optionsForExec();\n  this._applyTranslateAliases(options);\n  convertNewToReturnDocument(options);\n\n  const includeResultMetadata = this.options.includeResultMetadata;\n\n  const modelOpts = { skipId: true };\n  if ('strict' in this._mongooseOptions) {\n    modelOpts.strict = this._mongooseOptions.strict;\n  }\n\n  const runValidators = _getOption(this, 'runValidators', false);\n\n  try {\n    const update = new this.model(this._update, null, modelOpts);\n    if (runValidators) {\n      await update.validate();\n    } else if (update.$__.validationError) {\n      throw update.$__.validationError;\n    }\n    this._update = update.toBSON();\n  } catch (err) {\n    if (err instanceof ValidationError) {\n      throw err;\n    }\n    const validationError = new ValidationError();\n    validationError.errors[err.path] = err;\n    throw validationError;\n  }\n\n  let res = await this.mongooseCollection.findOneAndReplace(filter, this._update, options);\n\n  for (const fn of this._transforms) {\n    res = fn(res);\n  }\n\n  const doc = !includeResultMetadata ? res : res.value;\n  return new Promise((resolve, reject) => {\n    this._completeOne(doc, res, _wrapThunkCallback(this, (err, res) => {\n      if (err) {\n        return reject(err);\n      }\n      resolve(res);\n    }));\n  });\n};\n\n/**\n * Support the `new` option as an alternative to `returnOriginal` for backwards\n * compat.\n * @api private\n */\n\nfunction convertNewToReturnDocument(options) {\n  if ('new' in options) {\n    options.returnDocument = options['new'] ? 'after' : 'before';\n    delete options['new'];\n  }\n  if ('returnOriginal' in options) {\n    options.returnDocument = options['returnOriginal'] ? 'before' : 'after';\n    delete options['returnOriginal'];\n  }\n  // Temporary since driver 4.0.0-beta does not support `returnDocument`\n  if (typeof options.returnDocument === 'string') {\n    options.returnOriginal = options.returnDocument === 'before';\n  }\n}\n\n/**\n * Get options from query opts, falling back to the base mongoose object.\n * @param {Query} query\n * @param {Object} option\n * @param {Any} def\n * @api private\n */\n\nfunction _getOption(query, option, def) {\n  const opts = query._optionsForExec(query.model);\n\n  if (option in opts) {\n    return opts[option];\n  }\n  if (option in query.model.base.options) {\n    return query.model.base.options[option];\n  }\n  return def;\n}\n\n/*!\n * ignore\n */\n\nfunction _completeOneLean(schema, doc, path, res, opts, callback) {\n  if (opts.lean && typeof opts.lean.transform === 'function') {\n    opts.lean.transform(doc);\n\n    for (let i = 0; i < schema.childSchemas.length; i++) {\n      const childPath = path ? path + '.' + schema.childSchemas[i].model.path : schema.childSchemas[i].model.path;\n      const _schema = schema.childSchemas[i].schema;\n      const obj = mpath.get(childPath, doc);\n      if (obj == null) {\n        continue;\n      }\n      if (Array.isArray(obj)) {\n        for (let i = 0; i < obj.length; i++) {\n          opts.lean.transform(obj[i]);\n        }\n      } else {\n        opts.lean.transform(obj);\n      }\n      _completeOneLean(_schema, obj, childPath, res, opts);\n    }\n    if (callback) {\n      return callback(null, doc);\n    } else {\n      return;\n    }\n  }\n  if (opts.includeResultMetadata) {\n    return callback(null, res);\n  }\n  return callback(null, doc);\n}\n\n/*!\n * ignore\n */\n\nfunction _completeManyLean(schema, docs, path, opts) {\n  if (opts.lean && typeof opts.lean.transform === 'function') {\n    for (const doc of docs) {\n      opts.lean.transform(doc);\n    }\n\n    for (let i = 0; i < schema.childSchemas.length; i++) {\n      const childPath = path ? path + '.' + schema.childSchemas[i].model.path : schema.childSchemas[i].model.path;\n      const _schema = schema.childSchemas[i].schema;\n      let doc = mpath.get(childPath, docs);\n      if (doc == null) {\n        continue;\n      }\n      doc = doc.flat();\n      for (let i = 0; i < doc.length; i++) {\n        opts.lean.transform(doc[i]);\n      }\n      _completeManyLean(_schema, doc, childPath, opts);\n    }\n  }\n\n  return docs;\n}\n/**\n * Override mquery.prototype._mergeUpdate to handle mongoose objects in\n * updates.\n *\n * @param {Object} doc\n * @method _mergeUpdate\n * @memberOf Query\n * @instance\n * @api private\n */\n\nQuery.prototype._mergeUpdate = function(doc) {\n  if (!this._update) {\n    this._update = Array.isArray(doc) ? [] : {};\n  }\n\n  if (doc == null || (typeof doc === 'object' && Object.keys(doc).length === 0)) {\n    return;\n  }\n\n  if (doc instanceof Query) {\n    if (Array.isArray(this._update)) {\n      throw new Error('Cannot mix array and object updates');\n    }\n    if (doc._update) {\n      utils.mergeClone(this._update, doc._update);\n    }\n  } else if (Array.isArray(doc)) {\n    if (!Array.isArray(this._update)) {\n      throw new Error('Cannot mix array and object updates');\n    }\n    this._update = this._update.concat(doc);\n  } else {\n    if (Array.isArray(this._update)) {\n      throw new Error('Cannot mix array and object updates');\n    }\n    utils.mergeClone(this._update, doc);\n  }\n};\n\n/*!\n * ignore\n */\n\nasync function _updateThunk(op) {\n  this._castConditions();\n\n  _castArrayFilters(this);\n\n  if (this.error() != null) {\n    throw this.error();\n  }\n\n  const castedQuery = this._conditions;\n  const options = this._optionsForExec(this.model);\n  this._applyTranslateAliases(options);\n\n  this._update = clone(this._update, options);\n  const isOverwriting = op === 'replaceOne';\n  if (isOverwriting) {\n    this._update = new this.model(this._update, null, true);\n  } else {\n    this._update = this._castUpdate(this._update);\n\n    if (this._update == null || Object.keys(this._update).length === 0) {\n      return { acknowledged: false };\n    }\n\n    const _opts = Object.assign({}, options, {\n      setDefaultsOnInsert: this._mongooseOptions.setDefaultsOnInsert\n    });\n    this._update = setDefaultsOnInsert(this._conditions, this.model.schema,\n      this._update, _opts);\n  }\n\n  if (Array.isArray(options.arrayFilters)) {\n    options.arrayFilters = removeUnusedArrayFilters(this._update, options.arrayFilters);\n  }\n\n  const runValidators = _getOption(this, 'runValidators', false);\n  if (runValidators) {\n    await this.validate(this._update, options, isOverwriting);\n  }\n\n  if (this._update.toBSON) {\n    this._update = this._update.toBSON();\n  }\n\n  return this.mongooseCollection[op](castedQuery, this._update, options);\n}\n\n/**\n * Mongoose calls this function internally to validate the query if\n * `runValidators` is set\n *\n * @param {Object} castedDoc the update, after casting\n * @param {Object} options the options from `_optionsForExec()`\n * @param {Boolean} isOverwriting\n * @method validate\n * @memberOf Query\n * @instance\n * @api private\n */\n\nQuery.prototype.validate = async function validate(castedDoc, options, isOverwriting) {\n  if (typeof arguments[3] === 'function') {\n    throw new MongooseError('Query.prototype.validate() no longer accepts a callback');\n  }\n\n  await _executePreHooks(this, 'validate');\n\n  if (isOverwriting) {\n    await castedDoc.$validate();\n  } else {\n    await new Promise((resolve, reject) => {\n      updateValidators(this, this.model.schema, castedDoc, options, (err) => {\n        if (err != null) {\n          return reject(err);\n        }\n        resolve();\n      });\n    });\n  }\n\n  await _executePostHooks(this, null, null, 'validate');\n};\n\n/**\n * Execute an updateMany query\n *\n * @see Model.update https://mongoosejs.com/docs/api/model.html#Model.update()\n * @method _updateMany\n * @memberOf Query\n * @instance\n * @api private\n */\nQuery.prototype._updateMany = async function _updateMany() {\n  return _updateThunk.call(this, 'updateMany');\n};\n\n/**\n * Execute an updateOne query\n *\n * @see Model.update https://mongoosejs.com/docs/api/model.html#Model.update()\n * @method _updateOne\n * @memberOf Query\n * @instance\n * @api private\n */\nQuery.prototype._updateOne = async function _updateOne() {\n  return _updateThunk.call(this, 'updateOne');\n};\n\n/**\n * Execute a replaceOne query\n *\n * @see Model.replaceOne https://mongoosejs.com/docs/api/model.html#Model.replaceOne()\n * @method _replaceOne\n * @memberOf Query\n * @instance\n * @api private\n */\nQuery.prototype._replaceOne = async function _replaceOne() {\n  return _updateThunk.call(this, 'replaceOne');\n};\n\n/**\n * Declare and/or execute this query as an updateMany() operation.\n * MongoDB will update _all_ documents that match `filter` (as opposed to just the first one).\n *\n * **Note** updateMany will _not_ fire update middleware. Use `pre('updateMany')`\n * and `post('updateMany')` instead.\n *\n * #### Example:\n *\n *     const res = await Person.updateMany({ name: /Stark$/ }, { isDeleted: true });\n *     res.n; // Number of documents matched\n *     res.nModified; // Number of documents modified\n *\n * This function triggers the following middleware.\n *\n * - `updateMany()`\n *\n * @param {Object} [filter]\n * @param {Object|Array} [update] the update command\n * @param {Object} [options]\n * @param {Boolean} [options.multipleCastError] by default, mongoose only returns the first error that occurred in casting the query. Turn on this option to aggregate all the cast errors.\n * @param {Boolean|String} [options.strict] overwrites the schema's [strict mode option](https://mongoosejs.com/docs/guide.html#strict)\n * @param {Boolean} [options.upsert=false] if true, and no documents found, insert a new document\n * @param {Object} [options.writeConcern=null] sets the [write concern](https://www.mongodb.com/docs/manual/reference/write-concern/) for replica sets. Overrides the [schema-level write concern](https://mongoosejs.com/docs/guide.html#writeConcern)\n * @param {Boolean} [options.timestamps=null] If set to `false` and [schema-level timestamps](https://mongoosejs.com/docs/guide.html#timestamps) are enabled, skip timestamps for this update. Does nothing if schema-level timestamps are not set.\n * @param {Boolean} [options.translateAliases=null] If set to `true`, translates any schema-defined aliases in `filter`, `projection`, `update`, and `distinct`. Throws an error if there are any conflicts where both alias and raw property are defined on the same object.\n * @param {Function} [callback] params are (error, writeOpResult)\n * @return {Query} this\n * @see Model.update https://mongoosejs.com/docs/api/model.html#Model.update()\n * @see Query docs https://mongoosejs.com/docs/queries.html\n * @see update https://www.mongodb.com/docs/manual/reference/method/db.collection.update/\n * @see UpdateResult https://mongodb.github.io/node-mongodb-native/4.9/interfaces/UpdateResult.html\n * @see MongoDB docs https://www.mongodb.com/docs/manual/reference/command/update/#update-command-output\n * @api public\n */\n\nQuery.prototype.updateMany = function(conditions, doc, options, callback) {\n  if (typeof options === 'function') {\n    // .update(conditions, doc, callback)\n    callback = options;\n    options = null;\n  } else if (typeof doc === 'function') {\n    // .update(doc, callback);\n    callback = doc;\n    doc = conditions;\n    conditions = {};\n    options = null;\n  } else if (typeof conditions === 'function') {\n    // .update(callback)\n    callback = conditions;\n    conditions = undefined;\n    doc = undefined;\n    options = undefined;\n  } else if (typeof conditions === 'object' && !doc && !options && !callback) {\n    // .update(doc)\n    doc = conditions;\n    conditions = undefined;\n    options = undefined;\n    callback = undefined;\n  }\n\n  return _update(this, 'updateMany', conditions, doc, options, callback);\n};\n\n/**\n * Declare and/or execute this query as an updateOne() operation.\n * MongoDB will update _only_ the first document that matches `filter`.\n *\n * - Use `replaceOne()` if you want to overwrite an entire document rather than using [atomic operators](https://www.mongodb.com/docs/manual/tutorial/model-data-for-atomic-operations/#pattern) like `$set`.\n *\n * **Note** updateOne will _not_ fire update middleware. Use `pre('updateOne')`\n * and `post('updateOne')` instead.\n *\n * #### Example:\n *\n *     const res = await Person.updateOne({ name: 'Jean-Luc Picard' }, { ship: 'USS Enterprise' });\n *     res.acknowledged; // Indicates if this write result was acknowledged. If not, then all other members of this result will be undefined.\n *     res.matchedCount; // Number of documents that matched the filter\n *     res.modifiedCount; // Number of documents that were modified\n *     res.upsertedCount; // Number of documents that were upserted\n *     res.upsertedId; // Identifier of the inserted document (if an upsert took place)\n *\n * This function triggers the following middleware.\n *\n * - `updateOne()`\n *\n * @param {Object} [filter]\n * @param {Object|Array} [update] the update command\n * @param {Object} [options]\n * @param {Boolean} [options.multipleCastError] by default, mongoose only returns the first error that occurred in casting the query. Turn on this option to aggregate all the cast errors.\n * @param {Boolean|String} [options.strict] overwrites the schema's [strict mode option](https://mongoosejs.com/docs/guide.html#strict)\n * @param {Boolean} [options.upsert=false] if true, and no documents found, insert a new document\n * @param {Object} [options.writeConcern=null] sets the [write concern](https://www.mongodb.com/docs/manual/reference/write-concern/) for replica sets. Overrides the [schema-level write concern](https://mongoosejs.com/docs/guide.html#writeConcern)\n * @param {Boolean} [options.timestamps=null] If set to `false` and [schema-level timestamps](https://mongoosejs.com/docs/guide.html#timestamps) are enabled, skip timestamps for this update. Note that this allows you to overwrite timestamps. Does nothing if schema-level timestamps are not set.\n @param {Boolean} [options.translateAliases=null] If set to `true`, translates any schema-defined aliases in `filter`, `projection`, `update`, and `distinct`. Throws an error if there are any conflicts where both alias and raw property are defined on the same object.\n * @param {Function} [callback] params are (error, writeOpResult)\n * @return {Query} this\n * @see Model.update https://mongoosejs.com/docs/api/model.html#Model.update()\n * @see Query docs https://mongoosejs.com/docs/queries.html\n * @see update https://www.mongodb.com/docs/manual/reference/method/db.collection.update/\n * @see UpdateResult https://mongodb.github.io/node-mongodb-native/4.9/interfaces/UpdateResult.html\n * @see MongoDB docs https://www.mongodb.com/docs/manual/reference/command/update/#update-command-output\n * @api public\n */\n\nQuery.prototype.updateOne = function(conditions, doc, options, callback) {\n  if (typeof options === 'function') {\n    // .update(conditions, doc, callback)\n    callback = options;\n    options = null;\n  } else if (typeof doc === 'function') {\n    // .update(doc, callback);\n    callback = doc;\n    doc = conditions;\n    conditions = {};\n    options = null;\n  } else if (typeof conditions === 'function') {\n    // .update(callback)\n    callback = conditions;\n    conditions = undefined;\n    doc = undefined;\n    options = undefined;\n  } else if (typeof conditions === 'object' && !doc && !options && !callback) {\n    // .update(doc)\n    doc = conditions;\n    conditions = undefined;\n    options = undefined;\n    callback = undefined;\n  }\n\n  return _update(this, 'updateOne', conditions, doc, options, callback);\n};\n\n/**\n * Declare and/or execute this query as a replaceOne() operation.\n * MongoDB will replace the existing document and will not accept any [atomic operators](https://www.mongodb.com/docs/manual/tutorial/model-data-for-atomic-operations/#pattern) (`$set`, etc.)\n *\n * **Note** replaceOne will _not_ fire update middleware. Use `pre('replaceOne')`\n * and `post('replaceOne')` instead.\n *\n * #### Example:\n *\n *     const res = await Person.replaceOne({ _id: 24601 }, { name: 'Jean Valjean' });\n *     res.acknowledged; // Indicates if this write result was acknowledged. If not, then all other members of this result will be undefined.\n *     res.matchedCount; // Number of documents that matched the filter\n *     res.modifiedCount; // Number of documents that were modified\n *     res.upsertedCount; // Number of documents that were upserted\n *     res.upsertedId; // Identifier of the inserted document (if an upsert took place)\n *\n * This function triggers the following middleware.\n *\n * - `replaceOne()`\n *\n * @param {Object} [filter]\n * @param {Object} [doc] the update command\n * @param {Object} [options]\n * @param {Boolean} [options.multipleCastError] by default, mongoose only returns the first error that occurred in casting the query. Turn on this option to aggregate all the cast errors.\n * @param {Boolean|String} [options.strict] overwrites the schema's [strict mode option](https://mongoosejs.com/docs/guide.html#strict)\n * @param {Boolean} [options.upsert=false] if true, and no documents found, insert a new document\n * @param {Object} [options.writeConcern=null] sets the [write concern](https://www.mongodb.com/docs/manual/reference/write-concern/) for replica sets. Overrides the [schema-level write concern](https://mongoosejs.com/docs/guide.html#writeConcern)\n * @param {Boolean} [options.timestamps=null] If set to `false` and [schema-level timestamps](https://mongoosejs.com/docs/guide.html#timestamps) are enabled, skip timestamps for this update. Does nothing if schema-level timestamps are not set.\n * @param {Boolean} [options.translateAliases=null] If set to `true`, translates any schema-defined aliases in `filter`, `projection`, `update`, and `distinct`. Throws an error if there are any conflicts where both alias and raw property are defined on the same object.\n * @param {Function} [callback] params are (error, writeOpResult)\n * @return {Query} this\n * @see Model.update https://mongoosejs.com/docs/api/model.html#Model.update()\n * @see Query docs https://mongoosejs.com/docs/queries.html\n * @see update https://www.mongodb.com/docs/manual/reference/method/db.collection.update/\n * @see UpdateResult https://mongodb.github.io/node-mongodb-native/4.9/interfaces/UpdateResult.html\n * @see MongoDB docs https://www.mongodb.com/docs/manual/reference/command/update/#update-command-output\n * @api public\n */\n\nQuery.prototype.replaceOne = function(conditions, doc, options, callback) {\n  if (typeof options === 'function') {\n    // .update(conditions, doc, callback)\n    callback = options;\n    options = null;\n  } else if (typeof doc === 'function') {\n    // .update(doc, callback);\n    callback = doc;\n    doc = conditions;\n    conditions = {};\n    options = null;\n  } else if (typeof conditions === 'function') {\n    // .update(callback)\n    callback = conditions;\n    conditions = undefined;\n    doc = undefined;\n    options = undefined;\n  } else if (typeof conditions === 'object' && !doc && !options && !callback) {\n    // .update(doc)\n    doc = conditions;\n    conditions = undefined;\n    options = undefined;\n    callback = undefined;\n  }\n\n  return _update(this, 'replaceOne', conditions, doc, options, callback);\n};\n\n/**\n * Internal helper for update, updateMany, updateOne, replaceOne\n * @param {Query} query\n * @param {String} op\n * @param {Object} filter\n * @param {Document} [doc]\n * @param {Object} [options]\n * @param {Function} callback\n * @api private\n */\n\nfunction _update(query, op, filter, doc, options, callback) {\n  // make sure we don't send in the whole Document to merge()\n  query.op = op;\n  query._validateOp();\n  doc = doc || {};\n\n  // strict is an option used in the update checking, make sure it gets set\n  if (options != null) {\n    if ('strict' in options) {\n      query._mongooseOptions.strict = options.strict;\n    }\n  }\n\n  if (!(filter instanceof Query) &&\n      filter != null &&\n      filter.toString() !== '[object Object]') {\n    query.error(new ObjectParameterError(filter, 'filter', op));\n  } else {\n    query.merge(filter);\n  }\n\n  if (utils.isObject(options)) {\n    query.setOptions(options);\n  }\n\n  query._mergeUpdate(doc);\n\n  // Hooks\n  if (callback) {\n    query.exec(callback);\n\n    return query;\n  }\n\n  return query;\n}\n\n/**\n * Runs a function `fn` and treats the return value of `fn` as the new value\n * for the query to resolve to.\n *\n * Any functions you pass to `transform()` will run **after** any post hooks.\n *\n * #### Example:\n *\n *     const res = await MyModel.findOne().transform(res => {\n *       // Sets a `loadedAt` property on the doc that tells you the time the\n *       // document was loaded.\n *       return res == null ?\n *         res :\n *         Object.assign(res, { loadedAt: new Date() });\n *     });\n *\n * @method transform\n * @memberOf Query\n * @instance\n * @param {Function} fn function to run to transform the query result\n * @return {Query} this\n */\n\nQuery.prototype.transform = function(fn) {\n  this._transforms.push(fn);\n  return this;\n};\n\n/**\n * Make this query throw an error if no documents match the given `filter`.\n * This is handy for integrating with async/await, because `orFail()` saves you\n * an extra `if` statement to check if no document was found.\n *\n * #### Example:\n *\n *     // Throws if no doc returned\n *     await Model.findOne({ foo: 'bar' }).orFail();\n *\n *     // Throws if no document was updated. Note that `orFail()` will still\n *     // throw if the only document that matches is `{ foo: 'bar', name: 'test' }`,\n *     // because `orFail()` will throw if no document was _updated_, not\n *     // if no document was _found_.\n *     await Model.updateOne({ foo: 'bar' }, { name: 'test' }).orFail();\n *\n *     // Throws \"No docs found!\" error if no docs match `{ foo: 'bar' }`\n *     await Model.find({ foo: 'bar' }).orFail(new Error('No docs found!'));\n *\n *     // Throws \"Not found\" error if no document was found\n *     await Model.findOneAndUpdate({ foo: 'bar' }, { name: 'test' }).\n *       orFail(() => Error('Not found'));\n *\n * @method orFail\n * @memberOf Query\n * @instance\n * @param {Function|Error} [err] optional error to throw if no docs match `filter`. If not specified, `orFail()` will throw a `DocumentNotFoundError`\n * @return {Query} this\n */\n\nQuery.prototype.orFail = function(err) {\n  this.transform(res => {\n    switch (this.op) {\n      case 'find':\n        if (res.length === 0) {\n          throw _orFailError(err, this);\n        }\n        break;\n      case 'findOne':\n        if (res == null) {\n          throw _orFailError(err, this);\n        }\n        break;\n      case 'replaceOne':\n      case 'updateMany':\n      case 'updateOne':\n        if (res && res.matchedCount === 0) {\n          throw _orFailError(err, this);\n        }\n        break;\n      case 'findOneAndDelete':\n      case 'findOneAndUpdate':\n      case 'findOneAndReplace':\n        if (this.options.includeResultMetadata && res != null && res.value == null) {\n          throw _orFailError(err, this);\n        }\n        if (!this.options.includeResultMetadata && res == null) {\n          throw _orFailError(err, this);\n        }\n        break;\n      case 'deleteMany':\n      case 'deleteOne':\n        if (res.deletedCount === 0) {\n          throw _orFailError(err, this);\n        }\n        break;\n      default:\n        break;\n    }\n\n    return res;\n  });\n  return this;\n};\n\n/**\n * Get the error to throw for `orFail()`\n * @param {Error|undefined} err\n * @param {Query} query\n * @api private\n */\n\nfunction _orFailError(err, query) {\n  if (typeof err === 'function') {\n    err = err.call(query);\n  }\n\n  if (err == null) {\n    err = new DocumentNotFoundError(query.getQuery(), query.model.modelName);\n  }\n\n  return err;\n}\n\n/**\n * Wrapper function to call isPathSelectedInclusive on a query.\n * @param {String} path\n * @return {Boolean}\n * @api public\n */\n\nQuery.prototype.isPathSelectedInclusive = function(path) {\n  return isPathSelectedInclusive(this._fields, path);\n};\n\n/**\n * Executes the query\n *\n * #### Example:\n *\n *     const promise = query.exec();\n *     const promise = query.exec('update');\n *\n * @param {String|Function} [operation]\n * @return {Promise}\n * @api public\n */\n\nQuery.prototype.exec = async function exec(op) {\n  if (typeof op === 'function' || (arguments.length >= 2 && typeof arguments[1] === 'function')) {\n    throw new MongooseError('Query.prototype.exec() no longer accepts a callback');\n  }\n\n  if (typeof op === 'string') {\n    this.op = op;\n  }\n\n  if (this.op == null) {\n    throw new MongooseError('Query must have `op` before executing');\n  }\n  if (this.model == null) {\n    throw new MongooseError('Query must have an associated model before executing');\n  }\n  this._validateOp();\n\n  if (!this.op) {\n    return;\n  }\n\n  if (this.options && this.options.sort) {\n    const keys = Object.keys(this.options.sort);\n    if (keys.includes('')) {\n      throw new Error('Invalid field \"\" passed to sort()');\n    }\n  }\n\n  let thunk = '_' + this.op;\n  if (this.op === 'distinct') {\n    thunk = '__distinct';\n  }\n\n  if (this._executionStack != null) {\n    let str = this.toString();\n    if (str.length > 60) {\n      str = str.slice(0, 60) + '...';\n    }\n    const err = new MongooseError('Query was already executed: ' + str);\n    err.originalStack = this._executionStack.stack;\n    throw err;\n  } else {\n    this._executionStack = new Error();\n  }\n\n  let skipWrappedFunction = null;\n  try {\n    await _executePreExecHooks(this);\n  } catch (err) {\n    if (err instanceof Kareem.skipWrappedFunction) {\n      skipWrappedFunction = err;\n    } else {\n      throw err;\n    }\n  }\n\n  let res;\n\n  let error = null;\n  try {\n    await _executePreHooks(this);\n    res = skipWrappedFunction ? skipWrappedFunction.args[0] : await this[thunk]();\n\n    for (const fn of this._transforms) {\n      res = fn(res);\n    }\n  } catch (err) {\n    if (err instanceof Kareem.skipWrappedFunction) {\n      res = err.args[0];\n    } else {\n      error = err;\n    }\n  }\n\n  res = await _executePostHooks(this, res, error);\n\n  await _executePostExecHooks(this);\n\n  return res;\n};\n\n/*!\n * ignore\n */\n\nfunction _executePostExecHooks(query) {\n  return new Promise((resolve, reject) => {\n    query._hooks.execPost('exec', query, [], {}, (error) => {\n      if (error) {\n        return reject(error);\n      }\n\n      resolve();\n    });\n  });\n}\n\n/*!\n * ignore\n */\n\nfunction _executePostHooks(query, res, error, op) {\n  if (query._queryMiddleware == null) {\n    if (error != null) {\n      throw error;\n    }\n    return res;\n  }\n\n  return new Promise((resolve, reject) => {\n    const opts = error ? { error } : {};\n\n    query._queryMiddleware.execPost(op || query.op, query, [res], opts, (error, res) => {\n      if (error) {\n        return reject(error);\n      }\n\n      resolve(res);\n    });\n  });\n}\n\n/*!\n * ignore\n */\n\nfunction _executePreExecHooks(query) {\n  return new Promise((resolve, reject) => {\n    query._hooks.execPre('exec', query, [], (error) => {\n      if (error != null) {\n        return reject(error);\n      }\n      resolve();\n    });\n  });\n}\n\n/*!\n * ignore\n */\n\nfunction _executePreHooks(query, op) {\n  if (query._queryMiddleware == null) {\n    return;\n  }\n\n  return new Promise((resolve, reject) => {\n    query._queryMiddleware.execPre(op || query.op, query, [], (error) => {\n      if (error != null) {\n        return reject(error);\n      }\n      resolve();\n    });\n  });\n}\n\n/*!\n * ignore\n */\n\nfunction _wrapThunkCallback(query, cb) {\n  return function(error, res) {\n    if (error != null) {\n      return cb(error);\n    }\n\n    for (const fn of query._transforms) {\n      try {\n        res = fn(res);\n      } catch (error) {\n        return cb(error);\n      }\n    }\n\n    return cb(null, res);\n  };\n}\n\n/**\n * Executes the query returning a `Promise` which will be\n * resolved with either the doc(s) or rejected with the error.\n *\n * More about [`then()` in JavaScript](https://masteringjs.io/tutorials/fundamentals/then).\n *\n * @param {Function} [resolve]\n * @param {Function} [reject]\n * @return {Promise}\n * @api public\n */\n\nQuery.prototype.then = function(resolve, reject) {\n  return this.exec().then(resolve, reject);\n};\n\n/**\n * Executes the query returning a `Promise` which will be\n * resolved with either the doc(s) or rejected with the error.\n * Like `.then()`, but only takes a rejection handler.\n *\n * More about [Promise `catch()` in JavaScript](https://masteringjs.io/tutorials/fundamentals/catch).\n *\n * @param {Function} [reject]\n * @return {Promise}\n * @api public\n */\n\nQuery.prototype.catch = function(reject) {\n  return this.exec().then(null, reject);\n};\n\n/**\n * Executes the query returning a `Promise` which will be\n * resolved with `.finally()` chained.\n *\n * More about [Promise `finally()` in JavaScript](https://thecodebarbarian.com/using-promise-finally-in-node-js.html).\n *\n * @param {Function} [onFinally]\n * @return {Promise}\n * @api public\n */\n\nQuery.prototype.finally = function(onFinally) {\n  return this.exec().finally(onFinally);\n};\n\n/**\n * Returns a string representation of this query.\n *\n * More about [`toString()` in JavaScript](https://masteringjs.io/tutorials/fundamentals/tostring).\n *\n * #### Example:\n *     const q = Model.find();\n *     console.log(q); // Prints \"Query { find }\"\n *\n * @return {String}\n * @api public\n * @method [Symbol.toStringTag]\n * @memberOf Query\n */\n\nQuery.prototype[Symbol.toStringTag] = function toString() {\n  return `Query { ${this.op} }`;\n};\n\n/**\n * Add pre [middleware](https://mongoosejs.com/docs/middleware.html) to this query instance. Doesn't affect\n * other queries.\n *\n * #### Example:\n *\n *     const q1 = Question.find({ answer: 42 });\n *     q1.pre(function middleware() {\n *       console.log(this.getFilter());\n *     });\n *     await q1.exec(); // Prints \"{ answer: 42 }\"\n *\n *     // Doesn't print anything, because `middleware()` is only\n *     // registered on `q1`.\n *     await Question.find({ answer: 42 });\n *\n * @param {Function} fn\n * @return {Promise}\n * @api public\n */\n\nQuery.prototype.pre = function(fn) {\n  this._hooks.pre('exec', fn);\n  return this;\n};\n\n/**\n * Add post [middleware](https://mongoosejs.com/docs/middleware.html) to this query instance. Doesn't affect\n * other queries.\n *\n * #### Example:\n *\n *     const q1 = Question.find({ answer: 42 });\n *     q1.post(function middleware() {\n *       console.log(this.getFilter());\n *     });\n *     await q1.exec(); // Prints \"{ answer: 42 }\"\n *\n *     // Doesn't print anything, because `middleware()` is only\n *     // registered on `q1`.\n *     await Question.find({ answer: 42 });\n *\n * @param {Function} fn\n * @return {Promise}\n * @api public\n */\n\nQuery.prototype.post = function(fn) {\n  this._hooks.post('exec', fn);\n  return this;\n};\n\n/**\n * Casts obj for an update command.\n *\n * @param {Object} obj\n * @return {Object} obj after casting its values\n * @method _castUpdate\n * @memberOf Query\n * @instance\n * @api private\n */\n\nQuery.prototype._castUpdate = function _castUpdate(obj) {\n  let schema = this.schema;\n\n  const discriminatorKey = schema.options.discriminatorKey;\n  const baseSchema = schema._baseSchema ? schema._baseSchema : schema;\n  if (this._mongooseOptions.overwriteDiscriminatorKey &&\n      obj[discriminatorKey] != null &&\n      baseSchema.discriminators) {\n    const _schema = Object.values(baseSchema.discriminators).find(\n      discriminator => discriminator.discriminatorMapping.value === obj[discriminatorKey]\n    );\n    if (_schema != null) {\n      schema = _schema;\n    }\n  }\n\n  let upsert;\n  if ('upsert' in this.options) {\n    upsert = this.options.upsert;\n  }\n\n  const filter = this._conditions;\n  if (schema != null &&\n      utils.hasUserDefinedProperty(filter, schema.options.discriminatorKey) &&\n      typeof filter[schema.options.discriminatorKey] !== 'object' &&\n      schema.discriminators != null) {\n    const discriminatorValue = filter[schema.options.discriminatorKey];\n    const byValue = getDiscriminatorByValue(this.model.discriminators, discriminatorValue);\n    schema = schema.discriminators[discriminatorValue] ||\n      (byValue && byValue.schema) ||\n      schema;\n  }\n\n  return castUpdate(schema, obj, {\n    strict: this._mongooseOptions.strict,\n    upsert: upsert,\n    arrayFilters: this.options.arrayFilters,\n    overwriteDiscriminatorKey: this._mongooseOptions.overwriteDiscriminatorKey\n  }, this, this._conditions);\n};\n\n/**\n * Specifies paths which should be populated with other documents.\n *\n * #### Example:\n *\n *     let book = await Book.findOne().populate('authors');\n *     book.title; // 'Node.js in Action'\n *     book.authors[0].name; // 'TJ Holowaychuk'\n *     book.authors[1].name; // 'Nathan Rajlich'\n *\n *     let books = await Book.find().populate({\n *       path: 'authors',\n *       // `match` and `sort` apply to the Author model,\n *       // not the Book model. These options do not affect\n *       // which documents are in `books`, just the order and\n *       // contents of each book document's `authors`.\n *       match: { name: new RegExp('.*h.*', 'i') },\n *       sort: { name: -1 }\n *     });\n *     books[0].title; // 'Node.js in Action'\n *     // Each book's `authors` are sorted by name, descending.\n *     books[0].authors[0].name; // 'TJ Holowaychuk'\n *     books[0].authors[1].name; // 'Marc Harter'\n *\n *     books[1].title; // 'Professional AngularJS'\n *     // Empty array, no authors' name has the letter 'h'\n *     books[1].authors; // []\n *\n * Paths are populated after the query executes and a response is received. A\n * separate query is then executed for each path specified for population. After\n * a response for each query has also been returned, the results are passed to\n * the callback.\n *\n * @param {Object|String|String[]} path either the path(s) to populate or an object specifying all parameters\n * @param {Object|String} [select] Field selection for the population query\n * @param {Model} [model] The model you wish to use for population. If not specified, populate will look up the model by the name in the Schema's `ref` field.\n * @param {Object} [match] Conditions for the population query\n * @param {Object} [options] Options for the population query (sort, etc)\n * @param {String} [options.path=null] The path to populate.\n * @param {boolean} [options.retainNullValues=false] by default, Mongoose removes null and undefined values from populated arrays. Use this option to make `populate()` retain `null` and `undefined` array entries.\n * @param {boolean} [options.getters=false] if true, Mongoose will call any getters defined on the `localField`. By default, Mongoose gets the raw value of `localField`. For example, you would need to set this option to `true` if you wanted to [add a `lowercase` getter to your `localField`](https://mongoosejs.com/docs/schematypes.html#schematype-options).\n * @param {boolean} [options.clone=false] When you do `BlogPost.find().populate('author')`, blog posts with the same author will share 1 copy of an `author` doc. Enable this option to make Mongoose clone populated docs before assigning them.\n * @param {Object|Function} [options.match=null] Add an additional filter to the populate query. Can be a filter object containing [MongoDB query syntax](https://www.mongodb.com/docs/manual/tutorial/query-documents/), or a function that returns a filter object.\n * @param {Function} [options.transform=null] Function that Mongoose will call on every populated document that allows you to transform the populated document.\n * @param {Object} [options.options=null] Additional options like `limit` and `lean`.\n * @see population https://mongoosejs.com/docs/populate.html\n * @see Query#select https://mongoosejs.com/docs/api/query.html#Query.prototype.select()\n * @see Model.populate https://mongoosejs.com/docs/api/model.html#Model.populate()\n * @return {Query} this\n * @api public\n */\n\nQuery.prototype.populate = function() {\n  // Bail when given no truthy arguments\n  if (!Array.from(arguments).some(Boolean)) {\n    return this;\n  }\n\n  const res = utils.populate.apply(null, arguments);\n\n  // Propagate readConcern and readPreference and lean from parent query,\n  // unless one already specified\n  if (this.options != null) {\n    const readConcern = this.options.readConcern;\n    const readPref = this.options.readPreference;\n\n    for (const populateOptions of res) {\n      if (readConcern != null && (populateOptions && populateOptions.options && populateOptions.options.readConcern) == null) {\n        populateOptions.options = populateOptions.options || {};\n        populateOptions.options.readConcern = readConcern;\n      }\n      if (readPref != null && (populateOptions && populateOptions.options && populateOptions.options.readPreference) == null) {\n        populateOptions.options = populateOptions.options || {};\n        populateOptions.options.readPreference = readPref;\n      }\n    }\n  }\n\n  const opts = this._mongooseOptions;\n\n  if (opts.lean != null) {\n    const lean = opts.lean;\n    for (const populateOptions of res) {\n      if ((populateOptions && populateOptions.options && populateOptions.options.lean) == null) {\n        populateOptions.options = populateOptions.options || {};\n        populateOptions.options.lean = lean;\n      }\n    }\n  }\n\n  if (!utils.isObject(opts.populate)) {\n    opts.populate = {};\n  }\n\n  const pop = opts.populate;\n\n  for (const populateOptions of res) {\n    const path = populateOptions.path;\n    if (pop[path] && pop[path].populate && populateOptions.populate) {\n      populateOptions.populate = pop[path].populate.concat(populateOptions.populate);\n    }\n\n    pop[populateOptions.path] = populateOptions;\n  }\n  return this;\n};\n\n/**\n * Gets a list of paths to be populated by this query\n *\n * #### Example:\n *\n *      bookSchema.pre('findOne', function() {\n *        let keys = this.getPopulatedPaths(); // ['author']\n *      });\n *      ...\n *      Book.findOne({}).populate('author');\n *\n * #### Example:\n *\n *      // Deep populate\n *      const q = L1.find().populate({\n *        path: 'level2',\n *        populate: { path: 'level3' }\n *      });\n *      q.getPopulatedPaths(); // ['level2', 'level2.level3']\n *\n * @return {Array} an array of strings representing populated paths\n * @api public\n */\n\nQuery.prototype.getPopulatedPaths = function getPopulatedPaths() {\n  const obj = this._mongooseOptions.populate || {};\n  const ret = Object.keys(obj);\n  for (const path of Object.keys(obj)) {\n    const pop = obj[path];\n    if (!Array.isArray(pop.populate)) {\n      continue;\n    }\n    _getPopulatedPaths(ret, pop.populate, path + '.');\n  }\n  return ret;\n};\n\n/*!\n * ignore\n */\n\nfunction _getPopulatedPaths(list, arr, prefix) {\n  for (const pop of arr) {\n    list.push(prefix + pop.path);\n    if (!Array.isArray(pop.populate)) {\n      continue;\n    }\n    _getPopulatedPaths(list, pop.populate, prefix + pop.path + '.');\n  }\n}\n\n/**\n * Casts this query to the schema of `model`\n *\n * #### Note:\n *\n * If `obj` is present, it is cast instead of this query.\n *\n * @param {Model} [model] the model to cast to. If not set, defaults to `this.model`\n * @param {Object} [obj]\n * @return {Object}\n * @api public\n */\n\nQuery.prototype.cast = function(model, obj) {\n  obj || (obj = this._conditions);\n  model = model || this.model;\n  const discriminatorKey = model.schema.options.discriminatorKey;\n  if (obj != null &&\n      obj.hasOwnProperty(discriminatorKey)) {\n    model = getDiscriminatorByValue(model.discriminators, obj[discriminatorKey]) || model;\n  }\n\n  const opts = { upsert: this.options && this.options.upsert };\n  if (this.options) {\n    if ('strict' in this.options) {\n      opts.strict = this.options.strict;\n    }\n    if ('strictQuery' in this.options) {\n      opts.strictQuery = this.options.strictQuery;\n    }\n  }\n\n  try {\n    return cast(model.schema, obj, opts, this);\n  } catch (err) {\n    // CastError, assign model\n    if (typeof err.setModel === 'function') {\n      err.setModel(model);\n    }\n    throw err;\n  }\n};\n\n/**\n * Casts selected field arguments for field selection with mongo 2.2\n *\n *     query.select({ ids: { $elemMatch: { $in: [hexString] }})\n *\n * @param {Object} fields\n * @see https://github.com/Automattic/mongoose/issues/1091\n * @see https://www.mongodb.com/docs/manual/reference/projection/elemMatch/\n * @api private\n */\n\nQuery.prototype._castFields = function _castFields(fields) {\n  let selected,\n      elemMatchKeys,\n      keys,\n      key,\n      out,\n      i;\n\n  if (fields) {\n    keys = Object.keys(fields);\n    elemMatchKeys = [];\n    i = keys.length;\n\n    // collect $elemMatch args\n    while (i--) {\n      key = keys[i];\n      if (fields[key].$elemMatch) {\n        selected || (selected = {});\n        selected[key] = fields[key];\n        elemMatchKeys.push(key);\n      }\n    }\n  }\n\n  if (selected) {\n    // they passed $elemMatch, cast em\n    try {\n      out = this.cast(this.model, selected);\n    } catch (err) {\n      return err;\n    }\n\n    // apply the casted field args\n    i = elemMatchKeys.length;\n    while (i--) {\n      key = elemMatchKeys[i];\n      fields[key] = out[key];\n    }\n  }\n\n  return fields;\n};\n\n/**\n * Applies schematype selected options to this query.\n * @api private\n */\n\nQuery.prototype._applyPaths = function applyPaths() {\n  if (!this.model) {\n    return;\n  }\n  this._fields = this._fields || {};\n  helpers.applyPaths(this._fields, this.model.schema);\n\n  let _selectPopulatedPaths = true;\n\n  if ('selectPopulatedPaths' in this.model.base.options) {\n    _selectPopulatedPaths = this.model.base.options.selectPopulatedPaths;\n  }\n  if ('selectPopulatedPaths' in this.model.schema.options) {\n    _selectPopulatedPaths = this.model.schema.options.selectPopulatedPaths;\n  }\n\n  if (_selectPopulatedPaths) {\n    selectPopulatedFields(this._fields, this._userProvidedFields, this._mongooseOptions.populate);\n  }\n};\n\n/**\n * Returns a wrapper around a [mongodb driver cursor](https://mongodb.github.io/node-mongodb-native/4.9/classes/FindCursor.html).\n * A QueryCursor exposes a Streams3 interface, as well as a `.next()` function.\n *\n * The `.cursor()` function triggers pre find hooks, but **not** post find hooks.\n *\n * #### Example:\n *\n *     // There are 2 ways to use a cursor. First, as a stream:\n *     Thing.\n *       find({ name: /^hello/ }).\n *       cursor().\n *       on('data', function(doc) { console.log(doc); }).\n *       on('end', function() { console.log('Done!'); });\n *\n *     // Or you can use `.next()` to manually get the next doc in the stream.\n *     // `.next()` returns a promise, so you can use promises or callbacks.\n *     const cursor = Thing.find({ name: /^hello/ }).cursor();\n *     cursor.next(function(error, doc) {\n *       console.log(doc);\n *     });\n *\n *     // Because `.next()` returns a promise, you can use co\n *     // to easily iterate through all documents without loading them\n *     // all into memory.\n *     const cursor = Thing.find({ name: /^hello/ }).cursor();\n *     for (let doc = await cursor.next(); doc != null; doc = await cursor.next()) {\n *       console.log(doc);\n *     }\n *\n * #### Valid options\n *\n *   - `transform`: optional function which accepts a mongoose document. The return value of the function will be emitted on `data` and returned by `.next()`.\n *\n * @return {QueryCursor}\n * @param {Object} [options]\n * @see QueryCursor https://mongoosejs.com/docs/api/querycursor.html\n * @api public\n */\n\nQuery.prototype.cursor = function cursor(opts) {\n  if (opts) {\n    this.setOptions(opts);\n  }\n\n  try {\n    this.cast(this.model);\n  } catch (err) {\n    return (new QueryCursor(this))._markError(err);\n  }\n\n  return new QueryCursor(this);\n};\n\n// the rest of these are basically to support older Mongoose syntax with mquery\n\n/**\n * Sets the tailable option (for use with capped collections).\n *\n * #### Example:\n *\n *     query.tailable(); // true\n *     query.tailable(true);\n *     query.tailable(false);\n *\n *     // Set both `tailable` and `awaitData` options\n *     query.tailable({ awaitData: true });\n *\n * #### Note:\n *\n * Cannot be used with `distinct()`\n *\n * @param {Boolean} bool defaults to true\n * @param {Object} [opts] options to set\n * @param {Boolean} [opts.awaitData] false by default. Set to true to keep the cursor open even if there's no data.\n * @param {Number} [opts.maxAwaitTimeMS] the maximum amount of time for the server to wait on new documents to satisfy a tailable cursor query. Requires `tailable` and `awaitData` to be true\n * @see tailable https://www.mongodb.com/docs/manual/tutorial/create-tailable-cursor/\n * @api public\n */\n\nQuery.prototype.tailable = function(val, opts) {\n  // we need to support the tailable({ awaitData : true }) as well as the\n  // tailable(true, {awaitData :true}) syntax that mquery does not support\n  if (val != null && typeof val.constructor === 'function' && val.constructor.name === 'Object') {\n    opts = val;\n    val = true;\n  }\n\n  if (val === undefined) {\n    val = true;\n  }\n\n  if (opts && typeof opts === 'object') {\n    for (const key of Object.keys(opts)) {\n      if (key === 'awaitData' || key === 'awaitdata') { // backwards compat, see gh-10875\n        // For backwards compatibility\n        this.options['awaitData'] = !!opts[key];\n      } else {\n        this.options[key] = opts[key];\n      }\n    }\n  }\n\n  this.options.tailable = arguments.length ? !!val : true;\n\n  return this;\n};\n\n/**\n * Declares an intersects query for `geometry()`.\n *\n * #### Example:\n *\n *     query.where('path').intersects().geometry({\n *       type: 'LineString',\n *       coordinates: [[180.0, 11.0], [180, 9.0]]\n *     });\n *\n *     query.where('path').intersects({\n *       type: 'LineString',\n *       coordinates: [[180.0, 11.0], [180, 9.0]]\n *     });\n *\n * #### Note:\n *\n * **MUST** be used after `where()`.\n *\n * #### Note:\n *\n * In Mongoose 3.7, `intersects` changed from a getter to a function. If you need the old syntax, use [this](https://github.com/ebensing/mongoose-within).\n *\n * @method intersects\n * @memberOf Query\n * @instance\n * @param {Object} [arg]\n * @return {Query} this\n * @see $geometry https://www.mongodb.com/docs/manual/reference/operator/geometry/\n * @see geoIntersects https://www.mongodb.com/docs/manual/reference/operator/geoIntersects/\n * @api public\n */\n\n/**\n * Specifies a `$geometry` condition\n *\n * #### Example:\n *\n *     const polyA = [[[ 10, 20 ], [ 10, 40 ], [ 30, 40 ], [ 30, 20 ]]]\n *     query.where('loc').within().geometry({ type: 'Polygon', coordinates: polyA })\n *\n *     // or\n *     const polyB = [[ 0, 0 ], [ 1, 1 ]]\n *     query.where('loc').within().geometry({ type: 'LineString', coordinates: polyB })\n *\n *     // or\n *     const polyC = [ 0, 0 ]\n *     query.where('loc').within().geometry({ type: 'Point', coordinates: polyC })\n *\n *     // or\n *     query.where('loc').intersects().geometry({ type: 'Point', coordinates: polyC })\n *\n * The argument is assigned to the most recent path passed to `where()`.\n *\n * #### Note:\n *\n * `geometry()` **must** come after either `intersects()` or `within()`.\n *\n * The `object` argument must contain `type` and `coordinates` properties.\n * - type {String}\n * - coordinates {Array}\n *\n * @method geometry\n * @memberOf Query\n * @instance\n * @param {Object} object Must contain a `type` property which is a String and a `coordinates` property which is an Array. See the examples.\n * @return {Query} this\n * @see $geometry https://www.mongodb.com/docs/manual/reference/operator/geometry/\n * @see Geospatial Support Enhancements https://www.mongodb.com/docs/manual/release-notes/2.4/#geospatial-support-enhancements\n * @see MongoDB Geospatial Indexing https://www.mongodb.com/docs/manual/core/geospatial-indexes/\n * @api public\n */\n\n/**\n * Specifies a `$near` or `$nearSphere` condition\n *\n * These operators return documents sorted by distance.\n *\n * #### Example:\n *\n *     query.where('loc').near({ center: [10, 10] });\n *     query.where('loc').near({ center: [10, 10], maxDistance: 5 });\n *     query.where('loc').near({ center: [10, 10], maxDistance: 5, spherical: true });\n *     query.near('loc', { center: [10, 10], maxDistance: 5 });\n *\n * @method near\n * @memberOf Query\n * @instance\n * @param {String} [path]\n * @param {Object} val\n * @return {Query} this\n * @see $near https://www.mongodb.com/docs/manual/reference/operator/near/\n * @see $nearSphere https://www.mongodb.com/docs/manual/reference/operator/nearSphere/\n * @see $maxDistance https://www.mongodb.com/docs/manual/reference/operator/maxDistance/\n * @see MongoDB Geospatial Indexing https://www.mongodb.com/docs/manual/core/geospatial-indexes/\n * @api public\n */\n\n/**\n * Overwriting mquery is needed to support a couple different near() forms found in older\n * versions of mongoose\n * near([1,1])\n * near(1,1)\n * near(field, [1,2])\n * near(field, 1, 2)\n * In addition to all of the normal forms supported by mquery\n *\n * @method near\n * @memberOf Query\n * @instance\n * @api private\n */\n\nQuery.prototype.near = function() {\n  const params = [];\n  const sphere = this._mongooseOptions.nearSphere;\n\n  // TODO refactor\n\n  if (arguments.length === 1) {\n    if (Array.isArray(arguments[0])) {\n      params.push({ center: arguments[0], spherical: sphere });\n    } else if (typeof arguments[0] === 'string') {\n      // just passing a path\n      params.push(arguments[0]);\n    } else if (utils.isObject(arguments[0])) {\n      if (typeof arguments[0].spherical !== 'boolean') {\n        arguments[0].spherical = sphere;\n      }\n      params.push(arguments[0]);\n    } else {\n      throw new TypeError('invalid argument');\n    }\n  } else if (arguments.length === 2) {\n    if (typeof arguments[0] === 'number' && typeof arguments[1] === 'number') {\n      params.push({ center: [arguments[0], arguments[1]], spherical: sphere });\n    } else if (typeof arguments[0] === 'string' && Array.isArray(arguments[1])) {\n      params.push(arguments[0]);\n      params.push({ center: arguments[1], spherical: sphere });\n    } else if (typeof arguments[0] === 'string' && utils.isObject(arguments[1])) {\n      params.push(arguments[0]);\n      if (typeof arguments[1].spherical !== 'boolean') {\n        arguments[1].spherical = sphere;\n      }\n      params.push(arguments[1]);\n    } else {\n      throw new TypeError('invalid argument');\n    }\n  } else if (arguments.length === 3) {\n    if (typeof arguments[0] === 'string' && typeof arguments[1] === 'number'\n        && typeof arguments[2] === 'number') {\n      params.push(arguments[0]);\n      params.push({ center: [arguments[1], arguments[2]], spherical: sphere });\n    } else {\n      throw new TypeError('invalid argument');\n    }\n  } else {\n    throw new TypeError('invalid argument');\n  }\n\n  return Query.base.near.apply(this, params);\n};\n\n/**\n * _DEPRECATED_ Specifies a `$nearSphere` condition\n *\n * #### Example:\n *\n *     query.where('loc').nearSphere({ center: [10, 10], maxDistance: 5 });\n *\n * **Deprecated.** Use `query.near()` instead with the `spherical` option set to `true`.\n *\n * #### Example:\n *\n *     query.where('loc').near({ center: [10, 10], spherical: true });\n *\n * @deprecated\n * @see near() https://mongoosejs.com/docs/api/query.html#Query.prototype.near()\n * @see $near https://www.mongodb.com/docs/manual/reference/operator/near/\n * @see $nearSphere https://www.mongodb.com/docs/manual/reference/operator/nearSphere/\n * @see $maxDistance https://www.mongodb.com/docs/manual/reference/operator/maxDistance/\n */\n\nQuery.prototype.nearSphere = function() {\n  this._mongooseOptions.nearSphere = true;\n  this.near.apply(this, arguments);\n  return this;\n};\n\n/**\n * Returns an asyncIterator for use with [`for/await/of` loops](https://thecodebarbarian.com/getting-started-with-async-iterators-in-node-js)\n * This function *only* works for `find()` queries.\n * You do not need to call this function explicitly, the JavaScript runtime\n * will call it for you.\n *\n * #### Example:\n *\n *     for await (const doc of Model.aggregate([{ $sort: { name: 1 } }])) {\n *       console.log(doc.name);\n *     }\n *\n * Node.js 10.x supports async iterators natively without any flags. You can\n * enable async iterators in Node.js 8.x using the [`--harmony_async_iteration` flag](https://github.com/tc39/proposal-async-iteration/issues/117#issuecomment-346695187).\n *\n * **Note:** This function is not if `Symbol.asyncIterator` is undefined. If\n * `Symbol.asyncIterator` is undefined, that means your Node.js version does not\n * support async iterators.\n *\n * @method [Symbol.asyncIterator]\n * @memberOf Query\n * @instance\n * @api public\n */\n\nif (Symbol.asyncIterator != null) {\n  Query.prototype[Symbol.asyncIterator] = function() {\n    return this.cursor().transformNull()._transformForAsyncIterator();\n  };\n}\n\n/**\n * Specifies a `$polygon` condition\n *\n * #### Example:\n *\n *     query.where('loc').within().polygon([10, 20], [13, 25], [7, 15]);\n *     query.polygon('loc', [10, 20], [13, 25], [7, 15]);\n *\n * @method polygon\n * @memberOf Query\n * @instance\n * @param {String|Array} [path]\n * @param {...Array|Object} [coordinatePairs]\n * @return {Query} this\n * @see $polygon https://www.mongodb.com/docs/manual/reference/operator/polygon/\n * @see MongoDB Geospatial Indexing https://www.mongodb.com/docs/manual/core/geospatial-indexes/\n * @api public\n */\n\n/**\n * Specifies a `$box` condition\n *\n * #### Example:\n *\n *     const lowerLeft = [40.73083, -73.99756]\n *     const upperRight= [40.741404,  -73.988135]\n *\n *     query.where('loc').within().box(lowerLeft, upperRight)\n *     query.box({ ll : lowerLeft, ur : upperRight })\n *\n * @method box\n * @memberOf Query\n * @instance\n * @see $box https://www.mongodb.com/docs/manual/reference/operator/box/\n * @see within() Query#within https://mongoosejs.com/docs/api/query.html#Query.prototype.within()\n * @see MongoDB Geospatial Indexing https://www.mongodb.com/docs/manual/core/geospatial-indexes/\n * @param {Object|Array<Number>} val1 Lower Left Coordinates OR a object of lower-left(ll) and upper-right(ur) Coordinates\n * @param {Array<Number>} [val2] Upper Right Coordinates\n * @return {Query} this\n * @api public\n */\n\n/**\n * this is needed to support the mongoose syntax of:\n * box(field, { ll : [x,y], ur : [x2,y2] })\n * box({ ll : [x,y], ur : [x2,y2] })\n *\n * @method box\n * @memberOf Query\n * @instance\n * @api private\n */\n\nQuery.prototype.box = function(ll, ur) {\n  if (!Array.isArray(ll) && utils.isObject(ll)) {\n    ur = ll.ur;\n    ll = ll.ll;\n  }\n  return Query.base.box.call(this, ll, ur);\n};\n\n/**\n * Specifies a `$center` or `$centerSphere` condition.\n *\n * #### Example:\n *\n *     const area = { center: [50, 50], radius: 10, unique: true }\n *     query.where('loc').within().circle(area)\n *     // alternatively\n *     query.circle('loc', area);\n *\n *     // spherical calculations\n *     const area = { center: [50, 50], radius: 10, unique: true, spherical: true }\n *     query.where('loc').within().circle(area)\n *     // alternatively\n *     query.circle('loc', area);\n *\n * @method circle\n * @memberOf Query\n * @instance\n * @param {String} [path]\n * @param {Object} area\n * @return {Query} this\n * @see $center https://www.mongodb.com/docs/manual/reference/operator/center/\n * @see $centerSphere https://www.mongodb.com/docs/manual/reference/operator/centerSphere/\n * @see $geoWithin https://www.mongodb.com/docs/manual/reference/operator/geoWithin/\n * @see MongoDB Geospatial Indexing https://www.mongodb.com/docs/manual/core/geospatial-indexes/\n * @api public\n */\n\n/**\n * _DEPRECATED_ Alias for [circle](https://mongoosejs.com/docs/api/query.html#Query.prototype.circle())\n *\n * **Deprecated.** Use [circle](https://mongoosejs.com/docs/api/query.html#Query.prototype.circle()) instead.\n *\n * @deprecated\n * @method center\n * @memberOf Query\n * @instance\n * @api public\n */\n\nQuery.prototype.center = Query.base.circle;\n\n/**\n * _DEPRECATED_ Specifies a `$centerSphere` condition\n *\n * **Deprecated.** Use [circle](https://mongoosejs.com/docs/api/query.html#Query.prototype.circle()) instead.\n *\n * #### Example:\n *\n *     const area = { center: [50, 50], radius: 10 };\n *     query.where('loc').within().centerSphere(area);\n *\n * @deprecated\n * @param {String} [path]\n * @param {Object} val\n * @return {Query} this\n * @see MongoDB Geospatial Indexing https://www.mongodb.com/docs/manual/core/geospatial-indexes/\n * @see $centerSphere https://www.mongodb.com/docs/manual/reference/operator/centerSphere/\n * @api public\n */\n\nQuery.prototype.centerSphere = function() {\n  if (arguments[0] != null && typeof arguments[0].constructor === 'function' && arguments[0].constructor.name === 'Object') {\n    arguments[0].spherical = true;\n  }\n\n  if (arguments[1] != null && typeof arguments[1].constructor === 'function' && arguments[1].constructor.name === 'Object') {\n    arguments[1].spherical = true;\n  }\n\n  Query.base.circle.apply(this, arguments);\n};\n\n/**\n * Determines if field selection has been made.\n *\n * @method selected\n * @memberOf Query\n * @instance\n * @return {Boolean}\n * @api public\n */\n\n/**\n * Determines if inclusive field selection has been made.\n *\n *     query.selectedInclusively(); // false\n *     query.select('name');\n *     query.selectedInclusively(); // true\n *\n * @method selectedInclusively\n * @memberOf Query\n * @instance\n * @return {Boolean}\n * @api public\n */\n\nQuery.prototype.selectedInclusively = function selectedInclusively() {\n  return isInclusive(this._fields);\n};\n\n/**\n * Determines if exclusive field selection has been made.\n *\n *     query.selectedExclusively(); // false\n *     query.select('-name');\n *     query.selectedExclusively(); // true\n *     query.selectedInclusively(); // false\n *\n * @method selectedExclusively\n * @memberOf Query\n * @instance\n * @return {Boolean}\n * @api public\n */\n\nQuery.prototype.selectedExclusively = function selectedExclusively() {\n  return isExclusive(this._fields);\n};\n\n/**\n * The model this query is associated with.\n *\n * #### Example:\n *\n *     const q = MyModel.find();\n *     q.model === MyModel; // true\n *\n * @api public\n * @property model\n * @memberOf Query\n * @instance\n */\n\nQuery.prototype.model;\n\n/*!\n * Export\n */\n\nmodule.exports = Query;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbW9uZ29vc2UvbGliL3F1ZXJ5LmpzIiwibWFwcGluZ3MiOiJBQUFhOztBQUViO0FBQ0E7QUFDQTs7QUFFQSxrQkFBa0IsbUJBQU8sQ0FBQyxxRUFBYztBQUN4Qyw4QkFBOEIsbUJBQU8sQ0FBQyw2RUFBa0I7QUFDeEQsZUFBZSxtQkFBTyxDQUFDLG9EQUFRO0FBQy9CLHNCQUFzQixtQkFBTyxDQUFDLHVGQUF1QjtBQUNyRCw2QkFBNkIsbUJBQU8sQ0FBQywyRkFBeUI7QUFDOUQsb0JBQW9CLG1CQUFPLENBQUMscUZBQXNCO0FBQ2xELHdCQUF3QixtQkFBTyxDQUFDLGlGQUFvQjtBQUNwRCxRQUFRLDJDQUEyQyxFQUFFLG1CQUFPLENBQUMsK0dBQW1DO0FBQ2hHLG9DQUFvQyxtQkFBTyxDQUFDLG1JQUE2QztBQUN6RiwwQkFBMEIsbUJBQU8sQ0FBQyxpSEFBb0M7QUFDdEUsYUFBYSxtQkFBTyxDQUFDLHlEQUFRO0FBQzdCLHlCQUF5QixtQkFBTyxDQUFDLCtHQUFtQztBQUNwRSxtQkFBbUIsbUJBQU8sQ0FBQyx1RUFBZTtBQUMxQyxtQkFBbUIsbUJBQU8sQ0FBQyxpR0FBNEI7QUFDdkQsY0FBYyxtQkFBTyxDQUFDLDJFQUFpQjtBQUN2QyxxQkFBcUIsbUJBQU8sQ0FBQyxxR0FBOEI7QUFDM0QsZ0NBQWdDLG1CQUFPLENBQUMsMklBQWlEO0FBQ3pGLGdCQUFnQixtQkFBTyxDQUFDLHlFQUFnQjtBQUN4QyxrQkFBa0IsbUJBQU8sQ0FBQyxtRkFBcUI7QUFDL0MsZ0NBQWdDLDhHQUE0QztBQUM1RSxvQkFBb0IsbUJBQU8sQ0FBQyw2R0FBa0M7QUFDOUQsb0JBQW9CLG1CQUFPLENBQUMsNkdBQWtDO0FBQzlELGdDQUFnQyxtQkFBTyxDQUFDLHFJQUE4QztBQUN0RixrQkFBa0IsbUJBQU8sQ0FBQyx5R0FBZ0M7QUFDMUQsY0FBYyxtQkFBTyxDQUFDLGtEQUFPO0FBQzdCLGVBQWUsbUJBQU8sQ0FBQyx5REFBUTtBQUMvQix3QkFBd0Is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WTtBQUNaO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DO0FBQ3BDO0FBQ0Esb0NBQW9DO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQztBQUNwQztBQUNBLG9DQUFvQztBQUNwQyxvQ0FBb0M7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9hcHAxLy4vbm9kZV9tb2R1bGVzL21vbmdvb3NlL2xpYi9xdWVyeS5qcz9hN2E1Il0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxuLyohXG4gKiBNb2R1bGUgZGVwZW5kZW5jaWVzLlxuICovXG5cbmNvbnN0IENhc3RFcnJvciA9IHJlcXVpcmUoJy4vZXJyb3IvY2FzdCcpO1xuY29uc3QgRG9jdW1lbnROb3RGb3VuZEVycm9yID0gcmVxdWlyZSgnLi9lcnJvci9ub3RGb3VuZCcpO1xuY29uc3QgS2FyZWVtID0gcmVxdWlyZSgna2FyZWVtJyk7XG5jb25zdCBNb25nb29zZUVycm9yID0gcmVxdWlyZSgnLi9lcnJvci9tb25nb29zZUVycm9yJyk7XG5jb25zdCBPYmplY3RQYXJhbWV0ZXJFcnJvciA9IHJlcXVpcmUoJy4vZXJyb3Ivb2JqZWN0UGFyYW1ldGVyJyk7XG5jb25zdCBRdWVyeUN1cnNvciA9IHJlcXVpcmUoJy4vY3Vyc29yL3F1ZXJ5Q3Vyc29yJyk7XG5jb25zdCBWYWxpZGF0aW9uRXJyb3IgPSByZXF1aXJlKCcuL2Vycm9yL3ZhbGlkYXRpb24nKTtcbmNvbnN0IHsgYXBwbHlHbG9iYWxNYXhUaW1lTVMsIGFwcGx5R2xvYmFsRGlza1VzZSB9ID0gcmVxdWlyZSgnLi9oZWxwZXJzL3F1ZXJ5L2FwcGx5R2xvYmFsT3B0aW9uJyk7XG5jb25zdCBoYW5kbGVSZWFkUHJlZmVyZW5jZUFsaWFzZXMgPSByZXF1aXJlKCcuL2hlbHBlcnMvcXVlcnkvaGFuZGxlUmVhZFByZWZlcmVuY2VBbGlhc2VzJyk7XG5jb25zdCBhcHBseVdyaXRlQ29uY2VybiA9IHJlcXVpcmUoJy4vaGVscGVycy9zY2hlbWEvYXBwbHlXcml0ZUNvbmNlcm4nKTtcbmNvbnN0IGNhc3QgPSByZXF1aXJlKCcuL2Nhc3QnKTtcbmNvbnN0IGNhc3RBcnJheUZpbHRlcnMgPSByZXF1aXJlKCcuL2hlbHBlcnMvdXBkYXRlL2Nhc3RBcnJheUZpbHRlcnMnKTtcbmNvbnN0IGNhc3ROdW1iZXIgPSByZXF1aXJlKCcuL2Nhc3QvbnVtYmVyJyk7XG5jb25zdCBjYXN0VXBkYXRlID0gcmVxdWlyZSgnLi9oZWxwZXJzL3F1ZXJ5L2Nhc3RVcGRhdGUnKTtcbmNvbnN0IGNsb25lID0gcmVxdWlyZSgnLi9oZWxwZXJzL2Nsb25lJyk7XG5jb25zdCBjb21wbGV0ZU1hbnkgPSByZXF1aXJlKCcuL2hlbHBlcnMvcXVlcnkvY29tcGxldGVNYW55Jyk7XG5jb25zdCBnZXREaXNjcmltaW5hdG9yQnlWYWx1ZSA9IHJlcXVpcmUoJy4vaGVscGVycy9kaXNjcmltaW5hdG9yL2dldERpc2NyaW1pbmF0b3JCeVZhbHVlJyk7XG5jb25zdCBoZWxwZXJzID0gcmVxdWlyZSgnLi9xdWVyeUhlbHBlcnMnKTtcbmNvbnN0IGltbWVkaWF0ZSA9IHJlcXVpcmUoJy4vaGVscGVycy9pbW1lZGlhdGUnKTtcbmNvbnN0IGludGVybmFsVG9PYmplY3RPcHRpb25zID0gcmVxdWlyZSgnLi9vcHRpb25zJykuaW50ZXJuYWxUb09iamVjdE9wdGlvbnM7XG5jb25zdCBpc0V4Y2x1c2l2ZSA9IHJlcXVpcmUoJy4vaGVscGVycy9wcm9qZWN0aW9uL2lzRXhjbHVzaXZlJyk7XG5jb25zdCBpc0luY2x1c2l2ZSA9IHJlcXVpcmUoJy4vaGVscGVycy9wcm9qZWN0aW9uL2lzSW5jbHVzaXZlJyk7XG5jb25zdCBpc1BhdGhTZWxlY3RlZEluY2x1c2l2ZSA9IHJlcXVpcmUoJy4vaGVscGVycy9wcm9qZWN0aW9uL2lzUGF0aFNlbGVjdGVkSW5jbHVzaXZlJyk7XG5jb25zdCBpc1N1YnBhdGggPSByZXF1aXJlKCcuL2hlbHBlcnMvcHJvamVjdGlvbi9pc1N1YnBhdGgnKTtcbmNvbnN0IG1wYXRoID0gcmVxdWlyZSgnbXBhdGgnKTtcbmNvbnN0IG1xdWVyeSA9IHJlcXVpcmUoJ21xdWVyeScpO1xuY29uc3QgcGFyc2VQcm9qZWN0aW9uID0gcmVxdWlyZSgnLi9oZWxwZXJzL3Byb2plY3Rpb24vcGFyc2VQcm9qZWN0aW9uJyk7XG5jb25zdCByZW1vdmVVbnVzZWRBcnJheUZpbHRlcnMgPSByZXF1aXJlKCcuL2hlbHBlcnMvdXBkYXRlL3JlbW92ZVVudXNlZEFycmF5RmlsdGVycycpO1xuY29uc3Qgc2FuaXRpemVGaWx0ZXIgPSByZXF1aXJlKCcuL2hlbHBlcnMvcXVlcnkvc2FuaXRpemVGaWx0ZXInKTtcbmNvbnN0IHNhbml0aXplUHJvamVjdGlvbiA9IHJlcXVpcmUoJy4vaGVscGVycy9xdWVyeS9zYW5pdGl6ZVByb2plY3Rpb24nKTtcbmNvbnN0IHNlbGVjdFBvcHVsYXRlZEZpZWxkcyA9IHJlcXVpcmUoJy4vaGVscGVycy9xdWVyeS9zZWxlY3RQb3B1bGF0ZWRGaWVsZHMnKTtcbmNvbnN0IHNldERlZmF1bHRzT25JbnNlcnQgPSByZXF1aXJlKCcuL2hlbHBlcnMvc2V0RGVmYXVsdHNPbkluc2VydCcpO1xuY29uc3Qgc3BlY2lhbFByb3BlcnRpZXMgPSByZXF1aXJlKCcuL2hlbHBlcnMvc3BlY2lhbFByb3BlcnRpZXMnKTtcbmNvbnN0IHVwZGF0ZVZhbGlkYXRvcnMgPSByZXF1aXJlKCcuL2hlbHBlcnMvdXBkYXRlVmFsaWRhdG9ycycpO1xuY29uc3QgdXRpbCA9IHJlcXVpcmUoJ3V0aWwnKTtcbmNvbnN0IHV0aWxzID0gcmVxdWlyZSgnLi91dGlscycpO1xuY29uc3QgdmFsaWRPcHMgPSByZXF1aXJlKCcuL2hlbHBlcnMvcXVlcnkvdmFsaWRPcHMnKTtcblxuY29uc3QgcXVlcnlPcHRpb25NZXRob2RzID0gbmV3IFNldChbXG4gICdhbGxvd0Rpc2tVc2UnLFxuICAnYmF0Y2hTaXplJyxcbiAgJ2NvbGxhdGlvbicsXG4gICdjb21tZW50JyxcbiAgJ2V4cGxhaW4nLFxuICAnaGludCcsXG4gICdqJyxcbiAgJ2xlYW4nLFxuICAnbGltaXQnLFxuICAnbWF4VGltZU1TJyxcbiAgJ3BvcHVsYXRlJyxcbiAgJ3Byb2plY3Rpb24nLFxuICAncmVhZCcsXG4gICdzZWxlY3QnLFxuICAnc2tpcCcsXG4gICdzbGljZScsXG4gICdzb3J0JyxcbiAgJ3RhaWxhYmxlJyxcbiAgJ3cnLFxuICAnd3JpdGVDb25jZXJuJyxcbiAgJ3d0aW1lb3V0J1xuXSk7XG5cbi8qKlxuICogUXVlcnkgY29uc3RydWN0b3IgdXNlZCBmb3IgYnVpbGRpbmcgcXVlcmllcy4gWW91IGRvIG5vdCBuZWVkXG4gKiB0byBpbnN0YW50aWF0ZSBhIGBRdWVyeWAgZGlyZWN0bHkuIEluc3RlYWQgdXNlIE1vZGVsIGZ1bmN0aW9ucyBsaWtlXG4gKiBbYE1vZGVsLmZpbmQoKWBdKGh0dHBzOi8vbW9uZ29vc2Vqcy5jb20vZG9jcy9hcGkvbW9kZWwuaHRtbCNNb2RlbC5maW5kKCkpLlxuICpcbiAqICMjIyMgRXhhbXBsZTpcbiAqXG4gKiAgICAgY29uc3QgcXVlcnkgPSBNeU1vZGVsLmZpbmQoKTsgLy8gYHF1ZXJ5YCBpcyBhbiBpbnN0YW5jZSBvZiBgUXVlcnlgXG4gKiAgICAgcXVlcnkuc2V0T3B0aW9ucyh7IGxlYW4gOiB0cnVlIH0pO1xuICogICAgIHF1ZXJ5LmNvbGxlY3Rpb24oTXlNb2RlbC5jb2xsZWN0aW9uKTtcbiAqICAgICBxdWVyeS53aGVyZSgnYWdlJykuZ3RlKDIxKS5leGVjKGNhbGxiYWNrKTtcbiAqXG4gKiAgICAgLy8gWW91IGNhbiBpbnN0YW50aWF0ZSBhIHF1ZXJ5IGRpcmVjdGx5LiBUaGVyZSBpcyBubyBuZWVkIHRvIGRvXG4gKiAgICAgLy8gdGhpcyB1bmxlc3MgeW91J3JlIGFuIGFkdmFuY2VkIHVzZXIgd2l0aCBhIHZlcnkgZ29vZCByZWFzb24gdG8uXG4gKiAgICAgY29uc3QgcXVlcnkgPSBuZXcgbW9uZ29vc2UuUXVlcnkoKTtcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdXG4gKiBAcGFyYW0ge09iamVjdH0gW21vZGVsXVxuICogQHBhcmFtIHtPYmplY3R9IFtjb25kaXRpb25zXVxuICogQHBhcmFtIHtPYmplY3R9IFtjb2xsZWN0aW9uXSBNb25nb29zZSBjb2xsZWN0aW9uXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmZ1bmN0aW9uIFF1ZXJ5KGNvbmRpdGlvbnMsIG9wdGlvbnMsIG1vZGVsLCBjb2xsZWN0aW9uKSB7XG4gIC8vIHRoaXMgc3R1ZmYgaXMgZm9yIGRlYWxpbmcgd2l0aCBjdXN0b20gcXVlcmllcyBjcmVhdGVkIGJ5ICN0b0NvbnN0cnVjdG9yXG4gIGlmICghdGhpcy5fbW9uZ29vc2VPcHRpb25zKSB7XG4gICAgdGhpcy5fbW9uZ29vc2VPcHRpb25zID0ge307XG4gIH1cbiAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG5cbiAgdGhpcy5fdHJhbnNmb3JtcyA9IFtdO1xuICB0aGlzLl9ob29rcyA9IG5ldyBLYXJlZW0oKTtcbiAgdGhpcy5fZXhlY3V0aW9uU3RhY2sgPSBudWxsO1xuXG4gIC8vIHRoaXMgaXMgdGhlIGNhc2Ugd2hlcmUgd2UgaGF2ZSBhIEN1c3RvbVF1ZXJ5LCB3ZSBuZWVkIHRvIGNoZWNrIGlmIHdlIGdvdFxuICAvLyBvcHRpb25zIHBhc3NlZCBpbiwgYW5kIGlmIHdlIGRpZCwgbWVyZ2UgdGhlbSBpblxuICBjb25zdCBrZXlzID0gT2JqZWN0LmtleXMob3B0aW9ucyk7XG4gIGZvciAoY29uc3Qga2V5IG9mIGtleXMpIHtcbiAgICB0aGlzLl9tb25nb29zZU9wdGlvbnNba2V5XSA9IG9wdGlvbnNba2V5XTtcbiAgfVxuXG4gIGlmIChjb2xsZWN0aW9uKSB7XG4gICAgdGhpcy5tb25nb29zZUNvbGxlY3Rpb24gPSBjb2xsZWN0aW9uO1xuICB9XG5cbiAgaWYgKG1vZGVsKSB7XG4gICAgdGhpcy5tb2RlbCA9IG1vZGVsO1xuICAgIHRoaXMuc2NoZW1hID0gbW9kZWwuc2NoZW1hO1xuICB9XG5cbiAgLy8gdGhpcyBpcyBuZWVkZWQgYmVjYXVzZSBtYXAgcmVkdWNlIHJldHVybnMgYSBtb2RlbCB0aGF0IGNhbiBiZSBxdWVyaWVkLCBidXRcbiAgLy8gYWxsIG9mIHRoZSBxdWVyaWVzIG9uIHNhaWQgbW9kZWwgc2hvdWxkIGJlIGxlYW5cbiAgaWYgKHRoaXMubW9kZWwgJiYgdGhpcy5tb2RlbC5fbWFwcmVkdWNlKSB7XG4gICAgdGhpcy5sZWFuKCk7XG4gIH1cblxuICAvLyBpbmhlcml0IG1xdWVyeVxuICBtcXVlcnkuY2FsbCh0aGlzLCBudWxsLCBvcHRpb25zKTtcbiAgaWYgKGNvbGxlY3Rpb24pIHtcbiAgICB0aGlzLmNvbGxlY3Rpb24oY29sbGVjdGlvbik7XG4gIH1cblxuICBpZiAoY29uZGl0aW9ucykge1xuICAgIHRoaXMuZmluZChjb25kaXRpb25zKTtcbiAgfVxuXG4gIHRoaXMub3B0aW9ucyA9IHRoaXMub3B0aW9ucyB8fCB7fTtcblxuICAvLyBGb3IgZ2gtNjg4MC4gbXF1ZXJ5IHN0aWxsIG5lZWRzIHRvIHN1cHBvcnQgYGZpZWxkc2AgYnkgZGVmYXVsdCBmb3Igb2xkXG4gIC8vIHZlcnNpb25zIG9mIE1vbmdvREJcbiAgdGhpcy4kdXNlUHJvamVjdGlvbiA9IHRydWU7XG5cbiAgY29uc3QgY29sbGF0aW9uID0gdGhpcyAmJlxuICAgIHRoaXMuc2NoZW1hICYmXG4gICAgdGhpcy5zY2hlbWEub3B0aW9ucyAmJlxuICAgIHRoaXMuc2NoZW1hLm9wdGlvbnMuY29sbGF0aW9uIHx8IG51bGw7XG4gIGlmIChjb2xsYXRpb24gIT0gbnVsbCkge1xuICAgIHRoaXMub3B0aW9ucy5jb2xsYXRpb24gPSBjb2xsYXRpb247XG4gIH1cbn1cblxuLyohXG4gKiBpbmhlcml0IG1xdWVyeVxuICovXG5cblF1ZXJ5LnByb3RvdHlwZSA9IG5ldyBtcXVlcnkoKTtcblF1ZXJ5LnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFF1ZXJ5O1xuUXVlcnkuYmFzZSA9IG1xdWVyeS5wcm90b3R5cGU7XG5cbi8qIVxuICogT3ZlcndyaXRlIG1xdWVyeSdzIGBfZGlzdGluY3RgLCBiZWNhdXNlIE1vbmdvb3NlIHVzZXMgdGhhdCBuYW1lXG4gKiB0byBzdG9yZSB0aGUgZmllbGQgdG8gYXBwbHkgZGlzdGluY3Qgb24uXG4gKi9cblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KFF1ZXJ5LnByb3RvdHlwZSwgJ19kaXN0aW5jdCcsIHtcbiAgY29uZmlndXJhYmxlOiB0cnVlLFxuICB3cml0YWJsZTogdHJ1ZSxcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgdmFsdWU6IHVuZGVmaW5lZFxufSk7XG5cbi8qKlxuICogRmxhZyB0byBvcHQgb3V0IG9mIHVzaW5nIGAkZ2VvV2l0aGluYC5cbiAqXG4gKiBgYGBqYXZhc2NyaXB0XG4gKiBtb25nb29zZS5RdWVyeS51c2UkZ2VvV2l0aGluID0gZmFsc2U7XG4gKiBgYGBcbiAqXG4gKiBNb25nb0RCIDIuNCBkZXByZWNhdGVkIHRoZSB1c2Ugb2YgYCR3aXRoaW5gLCByZXBsYWNpbmcgaXQgd2l0aCBgJGdlb1dpdGhpbmAuIE1vbmdvb3NlIHVzZXMgYCRnZW9XaXRoaW5gIGJ5IGRlZmF1bHQgKHdoaWNoIGlzIDEwMCUgYmFja3dhcmQgY29tcGF0aWJsZSB3aXRoIGAkd2l0aGluYCkuIElmIHlvdSBhcmUgcnVubmluZyBhbiBvbGRlciB2ZXJzaW9uIG9mIE1vbmdvREIsIHNldCB0aGlzIGZsYWcgdG8gYGZhbHNlYCBzbyB5b3VyIGB3aXRoaW4oKWAgcXVlcmllcyBjb250aW51ZSB0byB3b3JrLlxuICpcbiAqIEBzZWUgZ2VvV2l0aGluIGh0dHBzOi8vd3d3Lm1vbmdvZGIuY29tL2RvY3MvbWFudWFsL3JlZmVyZW5jZS9vcGVyYXRvci9nZW9XaXRoaW4vXG4gKiBAZGVmYXVsdCB0cnVlXG4gKiBAcHJvcGVydHkgdXNlJGdlb1dpdGhpblxuICogQG1lbWJlck9mIFF1ZXJ5XG4gKiBAc3RhdGljXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cblF1ZXJ5LnVzZSRnZW9XaXRoaW4gPSBtcXVlcnkudXNlJGdlb1dpdGhpbjtcblxuLyoqXG4gKiBDb252ZXJ0cyB0aGlzIHF1ZXJ5IHRvIGEgY3VzdG9taXplZCwgcmV1c2FibGUgcXVlcnkgY29uc3RydWN0b3Igd2l0aCBhbGwgYXJndW1lbnRzIGFuZCBvcHRpb25zIHJldGFpbmVkLlxuICpcbiAqICMjIyMgRXhhbXBsZTpcbiAqXG4gKiAgICAgLy8gQ3JlYXRlIGEgcXVlcnkgZm9yIGFkdmVudHVyZSBtb3ZpZXMgYW5kIHJlYWQgZnJvbSB0aGUgcHJpbWFyeVxuICogICAgIC8vIG5vZGUgaW4gdGhlIHJlcGxpY2Etc2V0IHVubGVzcyBpdCBpcyBkb3duLCBpbiB3aGljaCBjYXNlIHdlJ2xsXG4gKiAgICAgLy8gcmVhZCBmcm9tIGEgc2Vjb25kYXJ5IG5vZGUuXG4gKiAgICAgY29uc3QgcXVlcnkgPSBNb3ZpZS5maW5kKHsgdGFnczogJ2FkdmVudHVyZScgfSkucmVhZCgncHJpbWFyeVByZWZlcnJlZCcpO1xuICpcbiAqICAgICAvLyBjcmVhdGUgYSBjdXN0b20gUXVlcnkgY29uc3RydWN0b3IgYmFzZWQgb2ZmIHRoZXNlIHNldHRpbmdzXG4gKiAgICAgY29uc3QgQWR2ZW50dXJlID0gcXVlcnkudG9Db25zdHJ1Y3RvcigpO1xuICpcbiAqICAgICAvLyBmdXJ0aGVyIG5hcnJvdyBkb3duIG91ciBxdWVyeSByZXN1bHRzIHdoaWxlIHN0aWxsIHVzaW5nIHRoZSBwcmV2aW91cyBzZXR0aW5nc1xuICogICAgIGF3YWl0IEFkdmVudHVyZSgpLndoZXJlKHsgbmFtZTogL15MaWZlLyB9KS5leGVjKCk7XG4gKlxuICogICAgIC8vIHNpbmNlIEFkdmVudHVyZSBpcyBhIHN0YW5kLWFsb25lIGNvbnN0cnVjdG9yIHdlIGNhbiBhbHNvIGFkZCBvdXIgb3duXG4gKiAgICAgLy8gaGVscGVyIG1ldGhvZHMgYW5kIGdldHRlcnMgd2l0aG91dCBpbXBhY3RpbmcgZ2xvYmFsIHF1ZXJpZXNcbiAqICAgICBBZHZlbnR1cmUucHJvdG90eXBlLnN0YXJ0c1dpdGggPSBmdW5jdGlvbiAocHJlZml4KSB7XG4gKiAgICAgICB0aGlzLndoZXJlKHsgbmFtZTogbmV3IFJlZ0V4cCgnXicgKyBwcmVmaXgpIH0pXG4gKiAgICAgICByZXR1cm4gdGhpcztcbiAqICAgICB9XG4gKiAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEFkdmVudHVyZS5wcm90b3R5cGUsICdoaWdobHlSYXRlZCcsIHtcbiAqICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICogICAgICAgICB0aGlzLndoZXJlKHsgcmF0aW5nOiB7ICRndDogNC41IH19KTtcbiAqICAgICAgICAgcmV0dXJuIHRoaXM7XG4gKiAgICAgICB9XG4gKiAgICAgfSlcbiAqICAgICBhd2FpdCBBZHZlbnR1cmUoKS5oaWdobHlSYXRlZC5zdGFydHNXaXRoKCdMaWZlJykuZXhlYygpO1xuICpcbiAqIEByZXR1cm4ge1F1ZXJ5fSBzdWJjbGFzcy1vZi1RdWVyeVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5RdWVyeS5wcm90b3R5cGUudG9Db25zdHJ1Y3RvciA9IGZ1bmN0aW9uIHRvQ29uc3RydWN0b3IoKSB7XG4gIGNvbnN0IG1vZGVsID0gdGhpcy5tb2RlbDtcbiAgY29uc3QgY29sbCA9IHRoaXMubW9uZ29vc2VDb2xsZWN0aW9uO1xuXG4gIGNvbnN0IEN1c3RvbVF1ZXJ5ID0gZnVuY3Rpb24oY3JpdGVyaWEsIG9wdGlvbnMpIHtcbiAgICBpZiAoISh0aGlzIGluc3RhbmNlb2YgQ3VzdG9tUXVlcnkpKSB7XG4gICAgICByZXR1cm4gbmV3IEN1c3RvbVF1ZXJ5KGNyaXRlcmlhLCBvcHRpb25zKTtcbiAgICB9XG4gICAgdGhpcy5fbW9uZ29vc2VPcHRpb25zID0gY2xvbmUocC5fbW9uZ29vc2VPcHRpb25zKTtcbiAgICBRdWVyeS5jYWxsKHRoaXMsIGNyaXRlcmlhLCBvcHRpb25zIHx8IG51bGwsIG1vZGVsLCBjb2xsKTtcbiAgfTtcblxuICB1dGlsLmluaGVyaXRzKEN1c3RvbVF1ZXJ5LCBtb2RlbC5RdWVyeSk7XG5cbiAgLy8gc2V0IGluaGVyaXRlZCBkZWZhdWx0c1xuICBjb25zdCBwID0gQ3VzdG9tUXVlcnkucHJvdG90eXBlO1xuXG4gIHAub3B0aW9ucyA9IHt9O1xuXG4gIC8vIE5lZWQgdG8gaGFuZGxlIGBzb3J0KClgIHNlcGFyYXRlbHkgYmVjYXVzZSBlbnRyaWVzLXN0eWxlIGBzb3J0KClgIHN5bnRheFxuICAvLyBgc29ydChbWydwcm9wMScsIDFdXSlgIGNvbmZ1c2VzIG1xdWVyeSBpbnRvIGxvc2luZyB0aGUgb3V0ZXIgbmVzdGVkIGFycmF5LlxuICAvLyBTZWUgZ2gtODE1OVxuICBjb25zdCBvcHRpb25zID0gT2JqZWN0LmFzc2lnbih7fSwgdGhpcy5vcHRpb25zKTtcbiAgaWYgKG9wdGlvbnMuc29ydCAhPSBudWxsKSB7XG4gICAgcC5zb3J0KG9wdGlvbnMuc29ydCk7XG4gICAgZGVsZXRlIG9wdGlvbnMuc29ydDtcbiAgfVxuICBwLnNldE9wdGlvbnMob3B0aW9ucyk7XG5cbiAgcC5vcCA9IHRoaXMub3A7XG4gIHAuX3ZhbGlkYXRlT3AoKTtcbiAgcC5fY29uZGl0aW9ucyA9IGNsb25lKHRoaXMuX2NvbmRpdGlvbnMpO1xuICBwLl9maWVsZHMgPSBjbG9uZSh0aGlzLl9maWVsZHMpO1xuICBwLl91cGRhdGUgPSBjbG9uZSh0aGlzLl91cGRhdGUsIHtcbiAgICBmbGF0dGVuRGVjaW1hbHM6IGZhbHNlXG4gIH0pO1xuICBwLl9wYXRoID0gdGhpcy5fcGF0aDtcbiAgcC5fZGlzdGluY3QgPSB0aGlzLl9kaXN0aW5jdDtcbiAgcC5fY29sbGVjdGlvbiA9IHRoaXMuX2NvbGxlY3Rpb247XG4gIHAuX21vbmdvb3NlT3B0aW9ucyA9IHRoaXMuX21vbmdvb3NlT3B0aW9ucztcblxuICByZXR1cm4gQ3VzdG9tUXVlcnk7XG59O1xuXG4vKipcbiAqIE1ha2UgYSBjb3B5IG9mIHRoaXMgcXVlcnkgc28geW91IGNhbiByZS1leGVjdXRlIGl0LlxuICpcbiAqICMjIyMgRXhhbXBsZTpcbiAqXG4gKiAgICAgY29uc3QgcSA9IEJvb2suZmluZE9uZSh7IHRpdGxlOiAnQ2FzaW5vIFJveWFsZScgfSk7XG4gKiAgICAgYXdhaXQgcS5leGVjKCk7XG4gKiAgICAgYXdhaXQgcS5leGVjKCk7IC8vIFRocm93cyBhbiBlcnJvciBiZWNhdXNlIHlvdSBjYW4ndCBleGVjdXRlIGEgcXVlcnkgdHdpY2VcbiAqXG4gKiAgICAgYXdhaXQgcS5jbG9uZSgpLmV4ZWMoKTsgLy8gV29ya3NcbiAqXG4gKiBAbWV0aG9kIGNsb25lXG4gKiBAcmV0dXJuIHtRdWVyeX0gY29weVxuICogQG1lbWJlck9mIFF1ZXJ5XG4gKiBAaW5zdGFuY2VcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuUXVlcnkucHJvdG90eXBlLmNsb25lID0gZnVuY3Rpb24oKSB7XG4gIGNvbnN0IG1vZGVsID0gdGhpcy5tb2RlbDtcbiAgY29uc3QgY29sbGVjdGlvbiA9IHRoaXMubW9uZ29vc2VDb2xsZWN0aW9uO1xuXG4gIGNvbnN0IHEgPSBuZXcgdGhpcy5tb2RlbC5RdWVyeSh7fSwge30sIG1vZGVsLCBjb2xsZWN0aW9uKTtcblxuICAvLyBOZWVkIHRvIGhhbmRsZSBgc29ydCgpYCBzZXBhcmF0ZWx5IGJlY2F1c2UgZW50cmllcy1zdHlsZSBgc29ydCgpYCBzeW50YXhcbiAgLy8gYHNvcnQoW1sncHJvcDEnLCAxXV0pYCBjb25mdXNlcyBtcXVlcnkgaW50byBsb3NpbmcgdGhlIG91dGVyIG5lc3RlZCBhcnJheS5cbiAgLy8gU2VlIGdoLTgxNTlcbiAgY29uc3Qgb3B0aW9ucyA9IE9iamVjdC5hc3NpZ24oe30sIHRoaXMub3B0aW9ucyk7XG4gIGlmIChvcHRpb25zLnNvcnQgIT0gbnVsbCkge1xuICAgIHEuc29ydChvcHRpb25zLnNvcnQpO1xuICAgIGRlbGV0ZSBvcHRpb25zLnNvcnQ7XG4gIH1cbiAgcS5zZXRPcHRpb25zKG9wdGlvbnMpO1xuXG4gIHEub3AgPSB0aGlzLm9wO1xuICBxLl92YWxpZGF0ZU9wKCk7XG4gIHEuX2NvbmRpdGlvbnMgPSBjbG9uZSh0aGlzLl9jb25kaXRpb25zKTtcbiAgcS5fZmllbGRzID0gY2xvbmUodGhpcy5fZmllbGRzKTtcbiAgcS5fdXBkYXRlID0gY2xvbmUodGhpcy5fdXBkYXRlLCB7XG4gICAgZmxhdHRlbkRlY2ltYWxzOiBmYWxzZVxuICB9KTtcbiAgcS5fcGF0aCA9IHRoaXMuX3BhdGg7XG4gIHEuX2Rpc3RpbmN0ID0gdGhpcy5fZGlzdGluY3Q7XG4gIHEuX2NvbGxlY3Rpb24gPSB0aGlzLl9jb2xsZWN0aW9uO1xuICBxLl9tb25nb29zZU9wdGlvbnMgPSB0aGlzLl9tb25nb29zZU9wdGlvbnM7XG5cbiAgcmV0dXJuIHE7XG59O1xuXG4vKipcbiAqIFNwZWNpZmllcyBhIGphdmFzY3JpcHQgZnVuY3Rpb24gb3IgZXhwcmVzc2lvbiB0byBwYXNzIHRvIE1vbmdvREJzIHF1ZXJ5IHN5c3RlbS5cbiAqXG4gKiAjIyMjIEV4YW1wbGU6XG4gKlxuICogICAgIHF1ZXJ5LiR3aGVyZSgndGhpcy5jb21tZW50cy5sZW5ndGggPT09IDEwIHx8IHRoaXMubmFtZS5sZW5ndGggPT09IDUnKVxuICpcbiAqICAgICAvLyBvclxuICpcbiAqICAgICBxdWVyeS4kd2hlcmUoZnVuY3Rpb24gKCkge1xuICogICAgICAgcmV0dXJuIHRoaXMuY29tbWVudHMubGVuZ3RoID09PSAxMCB8fCB0aGlzLm5hbWUubGVuZ3RoID09PSA1O1xuICogICAgIH0pXG4gKlxuICogIyMjIyBOb3RlOlxuICpcbiAqIE9ubHkgdXNlIGAkd2hlcmVgIHdoZW4geW91IGhhdmUgYSBjb25kaXRpb24gdGhhdCBjYW5ub3QgYmUgbWV0IHVzaW5nIG90aGVyIE1vbmdvREIgb3BlcmF0b3JzIGxpa2UgYCRsdGAuXG4gKiAqKkJlIHN1cmUgdG8gcmVhZCBhYm91dCBhbGwgb2YgW2l0cyBjYXZlYXRzXShodHRwczovL3d3dy5tb25nb2RiLmNvbS9kb2NzL21hbnVhbC9yZWZlcmVuY2Uvb3BlcmF0b3Ivd2hlcmUvKSBiZWZvcmUgdXNpbmcuKipcbiAqXG4gKiBAc2VlICR3aGVyZSBodHRwczovL3d3dy5tb25nb2RiLmNvbS9kb2NzL21hbnVhbC9yZWZlcmVuY2Uvb3BlcmF0b3Ivd2hlcmUvXG4gKiBAbWV0aG9kICR3aGVyZVxuICogQHBhcmFtIHtTdHJpbmd8RnVuY3Rpb259IGpzIGphdmFzY3JpcHQgc3RyaW5nIG9yIGZ1bmN0aW9uXG4gKiBAcmV0dXJuIHtRdWVyeX0gdGhpc1xuICogQG1lbWJlck9mIFF1ZXJ5XG4gKiBAaW5zdGFuY2VcbiAqIEBtZXRob2QgJHdoZXJlXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbi8qKlxuICogU3BlY2lmaWVzIGEgYHBhdGhgIGZvciB1c2Ugd2l0aCBjaGFpbmluZy5cbiAqXG4gKiAjIyMjIEV4YW1wbGU6XG4gKlxuICogICAgIC8vIGluc3RlYWQgb2Ygd3JpdGluZzpcbiAqICAgICBVc2VyLmZpbmQoe2FnZTogeyRndGU6IDIxLCAkbHRlOiA2NX19KTtcbiAqXG4gKiAgICAgLy8gd2UgY2FuIGluc3RlYWQgd3JpdGU6XG4gKiAgICAgVXNlci53aGVyZSgnYWdlJykuZ3RlKDIxKS5sdGUoNjUpO1xuICpcbiAqICAgICAvLyBwYXNzaW5nIHF1ZXJ5IGNvbmRpdGlvbnMgaXMgcGVybWl0dGVkXG4gKiAgICAgVXNlci5maW5kKCkud2hlcmUoeyBuYW1lOiAndm9uZGVyZnVsJyB9KVxuICpcbiAqICAgICAvLyBjaGFpbmluZ1xuICogICAgIFVzZXJcbiAqICAgICAud2hlcmUoJ2FnZScpLmd0ZSgyMSkubHRlKDY1KVxuICogICAgIC53aGVyZSgnbmFtZScsIC9edm9uZGVyZnVsL2kpXG4gKiAgICAgLndoZXJlKCdmcmllbmRzJykuc2xpY2UoMTApXG4gKiAgICAgLmV4ZWMoKVxuICpcbiAqIEBtZXRob2Qgd2hlcmVcbiAqIEBtZW1iZXJPZiBRdWVyeVxuICogQGluc3RhbmNlXG4gKiBAcGFyYW0ge1N0cmluZ3xPYmplY3R9IFtwYXRoXVxuICogQHBhcmFtIHthbnl9IFt2YWxdXG4gKiBAcmV0dXJuIHtRdWVyeX0gdGhpc1xuICogQGFwaSBwdWJsaWNcbiAqL1xuXG4vKipcbiAqIFNwZWNpZmllcyBhIGAkc2xpY2VgIHByb2plY3Rpb24gZm9yIGFuIGFycmF5LlxuICpcbiAqICMjIyMgRXhhbXBsZTpcbiAqXG4gKiAgICAgcXVlcnkuc2xpY2UoJ2NvbW1lbnRzJywgNSk7IC8vIFJldHVybnMgdGhlIGZpcnN0IDUgY29tbWVudHNcbiAqICAgICBxdWVyeS5zbGljZSgnY29tbWVudHMnLCAtNSk7IC8vIFJldHVybnMgdGhlIGxhc3QgNSBjb21tZW50c1xuICogICAgIHF1ZXJ5LnNsaWNlKCdjb21tZW50cycsIFsxMCwgNV0pOyAvLyBSZXR1cm5zIHRoZSBmaXJzdCA1IGNvbW1lbnRzIGFmdGVyIHRoZSAxMC10aFxuICogICAgIHF1ZXJ5LndoZXJlKCdjb21tZW50cycpLnNsaWNlKDUpOyAvLyBSZXR1cm5zIHRoZSBmaXJzdCA1IGNvbW1lbnRzXG4gKiAgICAgcXVlcnkud2hlcmUoJ2NvbW1lbnRzJykuc2xpY2UoWy0xMCwgNV0pOyAvLyBSZXR1cm5zIHRoZSBmaXJzdCA1IGNvbW1lbnRzIGFmdGVyIHRoZSAxMC10aCB0byBsYXN0XG4gKlxuICogKipOb3RlOioqIElmIHRoZSBhYnNvbHV0ZSB2YWx1ZSBvZiB0aGUgbnVtYmVyIG9mIGVsZW1lbnRzIHRvIGJlIHNsaWNlZCBpcyBncmVhdGVyIHRoYW4gdGhlIG51bWJlciBvZiBlbGVtZW50cyBpbiB0aGUgYXJyYXksIGFsbCBhcnJheSBlbGVtZW50cyB3aWxsIGJlIHJldHVybmVkLlxuICpcbiAqICAgICAgLy8gR2l2ZW4gYGFycmA6IFsxLCAyLCAzLCA0LCA1LCA2LCA3LCA4LCA5LCAxMF1cbiAqICAgICAgcXVlcnkuc2xpY2UoJ2FycicsIDIwKTsgLy8gUmV0dXJucyBbMSwgMiwgMywgNCwgNSwgNiwgNywgOCwgOSwgMTBdXG4gKiAgICAgIHF1ZXJ5LnNsaWNlKCdhcnInLCAtMjApOyAvLyBSZXR1cm5zIFsxLCAyLCAzLCA0LCA1LCA2LCA3LCA4LCA5LCAxMF1cbiAqXG4gKiAqKk5vdGU6KiogSWYgdGhlIG51bWJlciBvZiBlbGVtZW50cyB0byBza2lwIGlzIHBvc2l0aXZlIGFuZCBncmVhdGVyIHRoYW4gdGhlIG51bWJlciBvZiBlbGVtZW50cyBpbiB0aGUgYXJyYXksIGFuIGVtcHR5IGFycmF5IHdpbGwgYmUgcmV0dXJuZWQuXG4gKlxuICogICAgICAvLyBHaXZlbiBgYXJyYDogWzEsIDIsIDMsIDQsIDUsIDYsIDcsIDgsIDksIDEwXVxuICogICAgICBxdWVyeS5zbGljZSgnYXJyJywgWzIwLCA1XSk7IC8vIFJldHVybnMgW11cbiAqXG4gKiAqKk5vdGU6KiogSWYgdGhlIG51bWJlciBvZiBlbGVtZW50cyB0byBza2lwIGlzIG5lZ2F0aXZlIGFuZCBpdHMgYWJzb2x1dGUgdmFsdWUgaXMgZ3JlYXRlciB0aGFuIHRoZSBudW1iZXIgb2YgZWxlbWVudHMgaW4gdGhlIGFycmF5LCB0aGUgc3RhcnRpbmcgcG9zaXRpb24gaXMgdGhlIHN0YXJ0IG9mIHRoZSBhcnJheS5cbiAqXG4gKiAgICAgIC8vIEdpdmVuIGBhcnJgOiBbMSwgMiwgMywgNCwgNSwgNiwgNywgOCwgOSwgMTBdXG4gKiAgICAgIHF1ZXJ5LnNsaWNlKCdhcnInLCBbLTIwLCA1XSk7IC8vIFJldHVybnMgWzEsIDIsIDMsIDQsIDVdXG4gKlxuICogQG1ldGhvZCBzbGljZVxuICogQG1lbWJlck9mIFF1ZXJ5XG4gKiBAaW5zdGFuY2VcbiAqIEBwYXJhbSB7U3RyaW5nfSBbcGF0aF1cbiAqIEBwYXJhbSB7TnVtYmVyfEFycmF5fSB2YWwgbnVtYmVyIG9mIGVsZW1lbnRzIHRvIHNsaWNlIG9yIGFycmF5IHdpdGggbnVtYmVyIG9mIGVsZW1lbnRzIHRvIHNraXAgYW5kIG51bWJlciBvZiBlbGVtZW50cyB0byBzbGljZVxuICogQHJldHVybiB7UXVlcnl9IHRoaXNcbiAqIEBzZWUgbW9uZ29kYiBodHRwczovL3d3dy5tb25nb2RiLmNvbS9kb2NzL21hbnVhbC90dXRvcmlhbC9xdWVyeS1kb2N1bWVudHMvI3Byb2plY3Rpb25cbiAqIEBzZWUgJHNsaWNlIGh0dHBzOi8vd3d3Lm1vbmdvZGIuY29tL2RvY3MvbWFudWFsL3JlZmVyZW5jZS9wcm9qZWN0aW9uL3NsaWNlLyNwcmouX1Nfc2xpY2VcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuUXVlcnkucHJvdG90eXBlLnNsaWNlID0gZnVuY3Rpb24oKSB7XG4gIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAwKSB7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICB0aGlzLl92YWxpZGF0ZSgnc2xpY2UnKTtcblxuICBsZXQgcGF0aDtcbiAgbGV0IHZhbDtcblxuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMSkge1xuICAgIGNvbnN0IGFyZyA9IGFyZ3VtZW50c1swXTtcbiAgICBpZiAodHlwZW9mIGFyZyA9PT0gJ29iamVjdCcgJiYgIUFycmF5LmlzQXJyYXkoYXJnKSkge1xuICAgICAgY29uc3Qga2V5cyA9IE9iamVjdC5rZXlzKGFyZyk7XG4gICAgICBjb25zdCBudW1LZXlzID0ga2V5cy5sZW5ndGg7XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG51bUtleXM7ICsraSkge1xuICAgICAgICB0aGlzLnNsaWNlKGtleXNbaV0sIGFyZ1trZXlzW2ldXSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgdGhpcy5fZW5zdXJlUGF0aCgnc2xpY2UnKTtcbiAgICBwYXRoID0gdGhpcy5fcGF0aDtcbiAgICB2YWwgPSBhcmd1bWVudHNbMF07XG4gIH0gZWxzZSBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMikge1xuICAgIGlmICgnbnVtYmVyJyA9PT0gdHlwZW9mIGFyZ3VtZW50c1swXSkge1xuICAgICAgdGhpcy5fZW5zdXJlUGF0aCgnc2xpY2UnKTtcbiAgICAgIHBhdGggPSB0aGlzLl9wYXRoO1xuICAgICAgdmFsID0gW2FyZ3VtZW50c1swXSwgYXJndW1lbnRzWzFdXTtcbiAgICB9IGVsc2Uge1xuICAgICAgcGF0aCA9IGFyZ3VtZW50c1swXTtcbiAgICAgIHZhbCA9IGFyZ3VtZW50c1sxXTtcbiAgICB9XG4gIH0gZWxzZSBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMykge1xuICAgIHBhdGggPSBhcmd1bWVudHNbMF07XG4gICAgdmFsID0gW2FyZ3VtZW50c1sxXSwgYXJndW1lbnRzWzJdXTtcbiAgfVxuXG4gIGNvbnN0IHAgPSB7fTtcbiAgcFtwYXRoXSA9IHsgJHNsaWNlOiB2YWwgfTtcbiAgdGhpcy5zZWxlY3QocCk7XG5cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKiFcbiAqIGlnbm9yZVxuICovXG5cbmNvbnN0IHZhbGlkT3BzU2V0ID0gbmV3IFNldCh2YWxpZE9wcyk7XG5cblF1ZXJ5LnByb3RvdHlwZS5fdmFsaWRhdGVPcCA9IGZ1bmN0aW9uKCkge1xuICBpZiAodGhpcy5vcCAhPSBudWxsICYmICF2YWxpZE9wc1NldC5oYXModGhpcy5vcCkpIHtcbiAgICB0aGlzLmVycm9yKG5ldyBFcnJvcignUXVlcnkgaGFzIGludmFsaWQgYG9wYDogXCInICsgdGhpcy5vcCArICdcIicpKTtcbiAgfVxufTtcblxuLyoqXG4gKiBTcGVjaWZpZXMgdGhlIGNvbXBsZW1lbnRhcnkgY29tcGFyaXNvbiB2YWx1ZSBmb3IgcGF0aHMgc3BlY2lmaWVkIHdpdGggYHdoZXJlKClgXG4gKlxuICogIyMjIyBFeGFtcGxlOlxuICpcbiAqICAgICBVc2VyLndoZXJlKCdhZ2UnKS5lcXVhbHMoNDkpO1xuICpcbiAqICAgICAvLyBpcyB0aGUgc2FtZSBhc1xuICpcbiAqICAgICBVc2VyLndoZXJlKCdhZ2UnLCA0OSk7XG4gKlxuICogQG1ldGhvZCBlcXVhbHNcbiAqIEBtZW1iZXJPZiBRdWVyeVxuICogQGluc3RhbmNlXG4gKiBAcGFyYW0ge09iamVjdH0gdmFsXG4gKiBAcmV0dXJuIHtRdWVyeX0gdGhpc1xuICogQGFwaSBwdWJsaWNcbiAqL1xuXG4vKipcbiAqIFNwZWNpZmllcyBhcmd1bWVudHMgZm9yIGFuIGAkb3JgIGNvbmRpdGlvbi5cbiAqXG4gKiAjIyMjIEV4YW1wbGU6XG4gKlxuICogICAgIHF1ZXJ5Lm9yKFt7IGNvbG9yOiAncmVkJyB9LCB7IHN0YXR1czogJ2VtZXJnZW5jeScgfV0pO1xuICpcbiAqIEBzZWUgJG9yIGh0dHBzOi8vd3d3Lm1vbmdvZGIuY29tL2RvY3MvbWFudWFsL3JlZmVyZW5jZS9vcGVyYXRvci9vci9cbiAqIEBtZXRob2Qgb3JcbiAqIEBtZW1iZXJPZiBRdWVyeVxuICogQGluc3RhbmNlXG4gKiBAcGFyYW0ge0FycmF5fSBhcnJheSBhcnJheSBvZiBjb25kaXRpb25zXG4gKiBAcmV0dXJuIHtRdWVyeX0gdGhpc1xuICogQGFwaSBwdWJsaWNcbiAqL1xuXG4vKipcbiAqIFNwZWNpZmllcyBhcmd1bWVudHMgZm9yIGEgYCRub3JgIGNvbmRpdGlvbi5cbiAqXG4gKiAjIyMjIEV4YW1wbGU6XG4gKlxuICogICAgIHF1ZXJ5Lm5vcihbeyBjb2xvcjogJ2dyZWVuJyB9LCB7IHN0YXR1czogJ29rJyB9XSk7XG4gKlxuICogQHNlZSAkbm9yIGh0dHBzOi8vd3d3Lm1vbmdvZGIuY29tL2RvY3MvbWFudWFsL3JlZmVyZW5jZS9vcGVyYXRvci9ub3IvXG4gKiBAbWV0aG9kIG5vclxuICogQG1lbWJlck9mIFF1ZXJ5XG4gKiBAaW5zdGFuY2VcbiAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IGFycmF5IG9mIGNvbmRpdGlvbnNcbiAqIEByZXR1cm4ge1F1ZXJ5fSB0aGlzXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbi8qKlxuICogU3BlY2lmaWVzIGFyZ3VtZW50cyBmb3IgYSBgJGFuZGAgY29uZGl0aW9uLlxuICpcbiAqICMjIyMgRXhhbXBsZTpcbiAqXG4gKiAgICAgcXVlcnkuYW5kKFt7IGNvbG9yOiAnZ3JlZW4nIH0sIHsgc3RhdHVzOiAnb2snIH1dKVxuICpcbiAqIEBtZXRob2QgYW5kXG4gKiBAbWVtYmVyT2YgUXVlcnlcbiAqIEBpbnN0YW5jZVxuICogQHNlZSAkYW5kIGh0dHBzOi8vd3d3Lm1vbmdvZGIuY29tL2RvY3MvbWFudWFsL3JlZmVyZW5jZS9vcGVyYXRvci9hbmQvXG4gKiBAcGFyYW0ge0FycmF5fSBhcnJheSBhcnJheSBvZiBjb25kaXRpb25zXG4gKiBAcmV0dXJuIHtRdWVyeX0gdGhpc1xuICogQGFwaSBwdWJsaWNcbiAqL1xuXG4vKipcbiAqIFNwZWNpZmllcyBhIGAkZ3RgIHF1ZXJ5IGNvbmRpdGlvbi5cbiAqXG4gKiBXaGVuIGNhbGxlZCB3aXRoIG9uZSBhcmd1bWVudCwgdGhlIG1vc3QgcmVjZW50IHBhdGggcGFzc2VkIHRvIGB3aGVyZSgpYCBpcyB1c2VkLlxuICpcbiAqICMjIyMgRXhhbXBsZTpcbiAqXG4gKiAgICAgVGhpbmcuZmluZCgpLndoZXJlKCdhZ2UnKS5ndCgyMSk7XG4gKlxuICogICAgIC8vIG9yXG4gKiAgICAgVGhpbmcuZmluZCgpLmd0KCdhZ2UnLCAyMSk7XG4gKlxuICogQG1ldGhvZCBndFxuICogQG1lbWJlck9mIFF1ZXJ5XG4gKiBAaW5zdGFuY2VcbiAqIEBwYXJhbSB7U3RyaW5nfSBbcGF0aF1cbiAqIEBwYXJhbSB7TnVtYmVyfSB2YWxcbiAqIEBzZWUgJGd0IGh0dHBzOi8vd3d3Lm1vbmdvZGIuY29tL2RvY3MvbWFudWFsL3JlZmVyZW5jZS9vcGVyYXRvci9ndC9cbiAqIEBhcGkgcHVibGljXG4gKi9cblxuLyoqXG4gKiBTcGVjaWZpZXMgYSBgJGd0ZWAgcXVlcnkgY29uZGl0aW9uLlxuICpcbiAqIFdoZW4gY2FsbGVkIHdpdGggb25lIGFyZ3VtZW50LCB0aGUgbW9zdCByZWNlbnQgcGF0aCBwYXNzZWQgdG8gYHdoZXJlKClgIGlzIHVzZWQuXG4gKlxuICogQG1ldGhvZCBndGVcbiAqIEBtZW1iZXJPZiBRdWVyeVxuICogQGluc3RhbmNlXG4gKiBAcGFyYW0ge1N0cmluZ30gW3BhdGhdXG4gKiBAcGFyYW0ge051bWJlcn0gdmFsXG4gKiBAc2VlICRndGUgaHR0cHM6Ly93d3cubW9uZ29kYi5jb20vZG9jcy9tYW51YWwvcmVmZXJlbmNlL29wZXJhdG9yL2d0ZS9cbiAqIEBhcGkgcHVibGljXG4gKi9cblxuLyoqXG4gKiBTcGVjaWZpZXMgYSBgJGx0YCBxdWVyeSBjb25kaXRpb24uXG4gKlxuICogV2hlbiBjYWxsZWQgd2l0aCBvbmUgYXJndW1lbnQsIHRoZSBtb3N0IHJlY2VudCBwYXRoIHBhc3NlZCB0byBgd2hlcmUoKWAgaXMgdXNlZC5cbiAqXG4gKiBAbWV0aG9kIGx0XG4gKiBAbWVtYmVyT2YgUXVlcnlcbiAqIEBpbnN0YW5jZVxuICogQHBhcmFtIHtTdHJpbmd9IFtwYXRoXVxuICogQHBhcmFtIHtOdW1iZXJ9IHZhbFxuICogQHNlZSAkbHQgaHR0cHM6Ly93d3cubW9uZ29kYi5jb20vZG9jcy9tYW51YWwvcmVmZXJlbmNlL29wZXJhdG9yL2x0L1xuICogQGFwaSBwdWJsaWNcbiAqL1xuXG4vKipcbiAqIFNwZWNpZmllcyBhIGAkbHRlYCBxdWVyeSBjb25kaXRpb24uXG4gKlxuICogV2hlbiBjYWxsZWQgd2l0aCBvbmUgYXJndW1lbnQsIHRoZSBtb3N0IHJlY2VudCBwYXRoIHBhc3NlZCB0byBgd2hlcmUoKWAgaXMgdXNlZC5cbiAqXG4gKiBAbWV0aG9kIGx0ZVxuICogQHNlZSAkbHRlIGh0dHBzOi8vd3d3Lm1vbmdvZGIuY29tL2RvY3MvbWFudWFsL3JlZmVyZW5jZS9vcGVyYXRvci9sdGUvXG4gKiBAbWVtYmVyT2YgUXVlcnlcbiAqIEBpbnN0YW5jZVxuICogQHBhcmFtIHtTdHJpbmd9IFtwYXRoXVxuICogQHBhcmFtIHtOdW1iZXJ9IHZhbFxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG4vKipcbiAqIFNwZWNpZmllcyBhIGAkbmVgIHF1ZXJ5IGNvbmRpdGlvbi5cbiAqXG4gKiBXaGVuIGNhbGxlZCB3aXRoIG9uZSBhcmd1bWVudCwgdGhlIG1vc3QgcmVjZW50IHBhdGggcGFzc2VkIHRvIGB3aGVyZSgpYCBpcyB1c2VkLlxuICpcbiAqIEBzZWUgJG5lIGh0dHBzOi8vd3d3Lm1vbmdvZGIuY29tL2RvY3MvbWFudWFsL3JlZmVyZW5jZS9vcGVyYXRvci9uZS9cbiAqIEBtZXRob2QgbmVcbiAqIEBtZW1iZXJPZiBRdWVyeVxuICogQGluc3RhbmNlXG4gKiBAcGFyYW0ge1N0cmluZ30gW3BhdGhdXG4gKiBAcGFyYW0ge2FueX0gdmFsXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbi8qKlxuICogU3BlY2lmaWVzIGFuIGAkaW5gIHF1ZXJ5IGNvbmRpdGlvbi5cbiAqXG4gKiBXaGVuIGNhbGxlZCB3aXRoIG9uZSBhcmd1bWVudCwgdGhlIG1vc3QgcmVjZW50IHBhdGggcGFzc2VkIHRvIGB3aGVyZSgpYCBpcyB1c2VkLlxuICpcbiAqIEBzZWUgJGluIGh0dHBzOi8vd3d3Lm1vbmdvZGIuY29tL2RvY3MvbWFudWFsL3JlZmVyZW5jZS9vcGVyYXRvci9pbi9cbiAqIEBtZXRob2QgaW5cbiAqIEBtZW1iZXJPZiBRdWVyeVxuICogQGluc3RhbmNlXG4gKiBAcGFyYW0ge1N0cmluZ30gW3BhdGhdXG4gKiBAcGFyYW0ge0FycmF5fSB2YWxcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuLyoqXG4gKiBTcGVjaWZpZXMgYW4gYCRuaW5gIHF1ZXJ5IGNvbmRpdGlvbi5cbiAqXG4gKiBXaGVuIGNhbGxlZCB3aXRoIG9uZSBhcmd1bWVudCwgdGhlIG1vc3QgcmVjZW50IHBhdGggcGFzc2VkIHRvIGB3aGVyZSgpYCBpcyB1c2VkLlxuICpcbiAqIEBzZWUgJG5pbiBodHRwczovL3d3dy5tb25nb2RiLmNvbS9kb2NzL21hbnVhbC9yZWZlcmVuY2Uvb3BlcmF0b3IvbmluL1xuICogQG1ldGhvZCBuaW5cbiAqIEBtZW1iZXJPZiBRdWVyeVxuICogQGluc3RhbmNlXG4gKiBAcGFyYW0ge1N0cmluZ30gW3BhdGhdXG4gKiBAcGFyYW0ge0FycmF5fSB2YWxcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuLyoqXG4gKiBTcGVjaWZpZXMgYW4gYCRhbGxgIHF1ZXJ5IGNvbmRpdGlvbi5cbiAqXG4gKiBXaGVuIGNhbGxlZCB3aXRoIG9uZSBhcmd1bWVudCwgdGhlIG1vc3QgcmVjZW50IHBhdGggcGFzc2VkIHRvIGB3aGVyZSgpYCBpcyB1c2VkLlxuICpcbiAqICMjIyMgRXhhbXBsZTpcbiAqXG4gKiAgICAgTXlNb2RlbC5maW5kKCkud2hlcmUoJ3BldHMnKS5hbGwoWydkb2cnLCAnY2F0JywgJ2ZlcnJldCddKTtcbiAqICAgICAvLyBFcXVpdmFsZW50OlxuICogICAgIE15TW9kZWwuZmluZCgpLmFsbCgncGV0cycsIFsnZG9nJywgJ2NhdCcsICdmZXJyZXQnXSk7XG4gKlxuICogQHNlZSAkYWxsIGh0dHBzOi8vd3d3Lm1vbmdvZGIuY29tL2RvY3MvbWFudWFsL3JlZmVyZW5jZS9vcGVyYXRvci9hbGwvXG4gKiBAbWV0aG9kIGFsbFxuICogQG1lbWJlck9mIFF1ZXJ5XG4gKiBAaW5zdGFuY2VcbiAqIEBwYXJhbSB7U3RyaW5nfSBbcGF0aF1cbiAqIEBwYXJhbSB7QXJyYXl9IHZhbFxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG4vKipcbiAqIFNwZWNpZmllcyBhIGAkc2l6ZWAgcXVlcnkgY29uZGl0aW9uLlxuICpcbiAqIFdoZW4gY2FsbGVkIHdpdGggb25lIGFyZ3VtZW50LCB0aGUgbW9zdCByZWNlbnQgcGF0aCBwYXNzZWQgdG8gYHdoZXJlKClgIGlzIHVzZWQuXG4gKlxuICogIyMjIyBFeGFtcGxlOlxuICpcbiAqICAgICBjb25zdCBkb2NzID0gYXdhaXQgTXlNb2RlbC53aGVyZSgndGFncycpLnNpemUoMCkuZXhlYygpO1xuICogICAgIGFzc2VydChBcnJheS5pc0FycmF5KGRvY3MpKTtcbiAqICAgICBjb25zb2xlLmxvZygnZG9jdW1lbnRzIHdpdGggMCB0YWdzJywgZG9jcyk7XG4gKlxuICogQHNlZSAkc2l6ZSBodHRwczovL3d3dy5tb25nb2RiLmNvbS9kb2NzL21hbnVhbC9yZWZlcmVuY2Uvb3BlcmF0b3Ivc2l6ZS9cbiAqIEBtZXRob2Qgc2l6ZVxuICogQG1lbWJlck9mIFF1ZXJ5XG4gKiBAaW5zdGFuY2VcbiAqIEBwYXJhbSB7U3RyaW5nfSBbcGF0aF1cbiAqIEBwYXJhbSB7TnVtYmVyfSB2YWxcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuLyoqXG4gKiBTcGVjaWZpZXMgYSBgJHJlZ2V4YCBxdWVyeSBjb25kaXRpb24uXG4gKlxuICogV2hlbiBjYWxsZWQgd2l0aCBvbmUgYXJndW1lbnQsIHRoZSBtb3N0IHJlY2VudCBwYXRoIHBhc3NlZCB0byBgd2hlcmUoKWAgaXMgdXNlZC5cbiAqXG4gKiBAc2VlICRyZWdleCBodHRwczovL3d3dy5tb25nb2RiLmNvbS9kb2NzL21hbnVhbC9yZWZlcmVuY2Uvb3BlcmF0b3IvcmVnZXgvXG4gKiBAbWV0aG9kIHJlZ2V4XG4gKiBAbWVtYmVyT2YgUXVlcnlcbiAqIEBpbnN0YW5jZVxuICogQHBhcmFtIHtTdHJpbmd9IFtwYXRoXVxuICogQHBhcmFtIHtTdHJpbmd8UmVnRXhwfSB2YWxcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuLyoqXG4gKiBTcGVjaWZpZXMgYSBgbWF4RGlzdGFuY2VgIHF1ZXJ5IGNvbmRpdGlvbi5cbiAqXG4gKiBXaGVuIGNhbGxlZCB3aXRoIG9uZSBhcmd1bWVudCwgdGhlIG1vc3QgcmVjZW50IHBhdGggcGFzc2VkIHRvIGB3aGVyZSgpYCBpcyB1c2VkLlxuICpcbiAqIEBzZWUgJG1heERpc3RhbmNlIGh0dHBzOi8vd3d3Lm1vbmdvZGIuY29tL2RvY3MvbWFudWFsL3JlZmVyZW5jZS9vcGVyYXRvci9tYXhEaXN0YW5jZS9cbiAqIEBtZXRob2QgbWF4RGlzdGFuY2VcbiAqIEBtZW1iZXJPZiBRdWVyeVxuICogQGluc3RhbmNlXG4gKiBAcGFyYW0ge1N0cmluZ30gW3BhdGhdXG4gKiBAcGFyYW0ge051bWJlcn0gdmFsXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbi8qKlxuICogU3BlY2lmaWVzIGEgYCRtb2RgIGNvbmRpdGlvbiwgZmlsdGVycyBkb2N1bWVudHMgZm9yIGRvY3VtZW50cyB3aG9zZVxuICogYHBhdGhgIHByb3BlcnR5IGlzIGEgbnVtYmVyIHRoYXQgaXMgZXF1YWwgdG8gYHJlbWFpbmRlcmAgbW9kdWxvIGBkaXZpc29yYC5cbiAqXG4gKiAjIyMjIEV4YW1wbGU6XG4gKlxuICogICAgIC8vIEFsbCBmaW5kIHByb2R1Y3RzIHdob3NlIGludmVudG9yeSBpcyBvZGRcbiAqICAgICBQcm9kdWN0LmZpbmQoKS5tb2QoJ2ludmVudG9yeScsIFsyLCAxXSk7XG4gKiAgICAgUHJvZHVjdC5maW5kKCkud2hlcmUoJ2ludmVudG9yeScpLm1vZChbMiwgMV0pO1xuICogICAgIC8vIFRoaXMgc3ludGF4IGlzIGEgbGl0dGxlIHN0cmFuZ2UsIGJ1dCBzdXBwb3J0ZWQuXG4gKiAgICAgUHJvZHVjdC5maW5kKCkud2hlcmUoJ2ludmVudG9yeScpLm1vZCgyLCAxKTtcbiAqXG4gKiBAbWV0aG9kIG1vZFxuICogQG1lbWJlck9mIFF1ZXJ5XG4gKiBAaW5zdGFuY2VcbiAqIEBwYXJhbSB7U3RyaW5nfSBbcGF0aF1cbiAqIEBwYXJhbSB7QXJyYXl9IHZhbCBtdXN0IGJlIG9mIGxlbmd0aCAyLCBmaXJzdCBlbGVtZW50IGlzIGBkaXZpc29yYCwgMm5kIGVsZW1lbnQgaXMgYHJlbWFpbmRlcmAuXG4gKiBAcmV0dXJuIHtRdWVyeX0gdGhpc1xuICogQHNlZSAkbW9kIGh0dHBzOi8vd3d3Lm1vbmdvZGIuY29tL2RvY3MvbWFudWFsL3JlZmVyZW5jZS9vcGVyYXRvci9tb2QvXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cblF1ZXJ5LnByb3RvdHlwZS5tb2QgPSBmdW5jdGlvbigpIHtcbiAgbGV0IHZhbDtcbiAgbGV0IHBhdGg7XG5cbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDEpIHtcbiAgICB0aGlzLl9lbnN1cmVQYXRoKCdtb2QnKTtcbiAgICB2YWwgPSBhcmd1bWVudHNbMF07XG4gICAgcGF0aCA9IHRoaXMuX3BhdGg7XG4gIH0gZWxzZSBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMiAmJiAhQXJyYXkuaXNBcnJheShhcmd1bWVudHNbMV0pKSB7XG4gICAgdGhpcy5fZW5zdXJlUGF0aCgnbW9kJyk7XG4gICAgdmFsID0gW2FyZ3VtZW50c1swXSwgYXJndW1lbnRzWzFdXTtcbiAgICBwYXRoID0gdGhpcy5fcGF0aDtcbiAgfSBlbHNlIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAzKSB7XG4gICAgdmFsID0gW2FyZ3VtZW50c1sxXSwgYXJndW1lbnRzWzJdXTtcbiAgICBwYXRoID0gYXJndW1lbnRzWzBdO1xuICB9IGVsc2Uge1xuICAgIHZhbCA9IGFyZ3VtZW50c1sxXTtcbiAgICBwYXRoID0gYXJndW1lbnRzWzBdO1xuICB9XG5cbiAgY29uc3QgY29uZHMgPSB0aGlzLl9jb25kaXRpb25zW3BhdGhdIHx8ICh0aGlzLl9jb25kaXRpb25zW3BhdGhdID0ge30pO1xuICBjb25kcy4kbW9kID0gdmFsO1xuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogU3BlY2lmaWVzIGFuIGAkZXhpc3RzYCBjb25kaXRpb25cbiAqXG4gKiAjIyMjIEV4YW1wbGU6XG4gKlxuICogICAgIC8vIHsgbmFtZTogeyAkZXhpc3RzOiB0cnVlIH19XG4gKiAgICAgVGhpbmcud2hlcmUoJ25hbWUnKS5leGlzdHMoKVxuICogICAgIFRoaW5nLndoZXJlKCduYW1lJykuZXhpc3RzKHRydWUpXG4gKiAgICAgVGhpbmcuZmluZCgpLmV4aXN0cygnbmFtZScpXG4gKlxuICogICAgIC8vIHsgbmFtZTogeyAkZXhpc3RzOiBmYWxzZSB9fVxuICogICAgIFRoaW5nLndoZXJlKCduYW1lJykuZXhpc3RzKGZhbHNlKTtcbiAqICAgICBUaGluZy5maW5kKCkuZXhpc3RzKCduYW1lJywgZmFsc2UpO1xuICpcbiAqIEBtZXRob2QgZXhpc3RzXG4gKiBAbWVtYmVyT2YgUXVlcnlcbiAqIEBpbnN0YW5jZVxuICogQHBhcmFtIHtTdHJpbmd9IFtwYXRoXVxuICogQHBhcmFtIHtCb29sZWFufSB2YWxcbiAqIEByZXR1cm4ge1F1ZXJ5fSB0aGlzXG4gKiBAc2VlICRleGlzdHMgaHR0cHM6Ly93d3cubW9uZ29kYi5jb20vZG9jcy9tYW51YWwvcmVmZXJlbmNlL29wZXJhdG9yL2V4aXN0cy9cbiAqIEBhcGkgcHVibGljXG4gKi9cblxuLyoqXG4gKiBTcGVjaWZpZXMgYW4gYCRlbGVtTWF0Y2hgIGNvbmRpdGlvblxuICpcbiAqICMjIyMgRXhhbXBsZTpcbiAqXG4gKiAgICAgcXVlcnkuZWxlbU1hdGNoKCdjb21tZW50JywgeyBhdXRob3I6ICdhdXRvYm90Jywgdm90ZXM6IHskZ3RlOiA1fX0pXG4gKlxuICogICAgIHF1ZXJ5LndoZXJlKCdjb21tZW50JykuZWxlbU1hdGNoKHsgYXV0aG9yOiAnYXV0b2JvdCcsIHZvdGVzOiB7JGd0ZTogNX19KVxuICpcbiAqICAgICBxdWVyeS5lbGVtTWF0Y2goJ2NvbW1lbnQnLCBmdW5jdGlvbiAoZWxlbSkge1xuICogICAgICAgZWxlbS53aGVyZSgnYXV0aG9yJykuZXF1YWxzKCdhdXRvYm90Jyk7XG4gKiAgICAgICBlbGVtLndoZXJlKCd2b3RlcycpLmd0ZSg1KTtcbiAqICAgICB9KVxuICpcbiAqICAgICBxdWVyeS53aGVyZSgnY29tbWVudCcpLmVsZW1NYXRjaChmdW5jdGlvbiAoZWxlbSkge1xuICogICAgICAgZWxlbS53aGVyZSh7IGF1dGhvcjogJ2F1dG9ib3QnIH0pO1xuICogICAgICAgZWxlbS53aGVyZSgndm90ZXMnKS5ndGUoNSk7XG4gKiAgICAgfSlcbiAqXG4gKiBAbWV0aG9kIGVsZW1NYXRjaFxuICogQG1lbWJlck9mIFF1ZXJ5XG4gKiBAaW5zdGFuY2VcbiAqIEBwYXJhbSB7U3RyaW5nfE9iamVjdHxGdW5jdGlvbn0gcGF0aFxuICogQHBhcmFtIHtPYmplY3R8RnVuY3Rpb259IGZpbHRlclxuICogQHJldHVybiB7UXVlcnl9IHRoaXNcbiAqIEBzZWUgJGVsZW1NYXRjaCBodHRwczovL3d3dy5tb25nb2RiLmNvbS9kb2NzL21hbnVhbC9yZWZlcmVuY2Uvb3BlcmF0b3IvZWxlbU1hdGNoL1xuICogQGFwaSBwdWJsaWNcbiAqL1xuXG4vKipcbiAqIERlZmluZXMgYSBgJHdpdGhpbmAgb3IgYCRnZW9XaXRoaW5gIGFyZ3VtZW50IGZvciBnZW8tc3BhdGlhbCBxdWVyaWVzLlxuICpcbiAqICMjIyMgRXhhbXBsZTpcbiAqXG4gKiAgICAgcXVlcnkud2hlcmUocGF0aCkud2l0aGluKCkuYm94KClcbiAqICAgICBxdWVyeS53aGVyZShwYXRoKS53aXRoaW4oKS5jaXJjbGUoKVxuICogICAgIHF1ZXJ5LndoZXJlKHBhdGgpLndpdGhpbigpLmdlb21ldHJ5KClcbiAqXG4gKiAgICAgcXVlcnkud2hlcmUoJ2xvYycpLndpdGhpbih7IGNlbnRlcjogWzUwLDUwXSwgcmFkaXVzOiAxMCwgdW5pcXVlOiB0cnVlLCBzcGhlcmljYWw6IHRydWUgfSk7XG4gKiAgICAgcXVlcnkud2hlcmUoJ2xvYycpLndpdGhpbih7IGJveDogW1s0MC43MywgLTczLjldLCBbNDAuNywgLTczLjk4OF1dIH0pO1xuICogICAgIHF1ZXJ5LndoZXJlKCdsb2MnKS53aXRoaW4oeyBwb2x5Z29uOiBbW10sW10sW10sW11dIH0pO1xuICpcbiAqICAgICBxdWVyeS53aGVyZSgnbG9jJykud2l0aGluKFtdLCBbXSwgW10pIC8vIHBvbHlnb25cbiAqICAgICBxdWVyeS53aGVyZSgnbG9jJykud2l0aGluKFtdLCBbXSkgLy8gYm94XG4gKiAgICAgcXVlcnkud2hlcmUoJ2xvYycpLndpdGhpbih7IHR5cGU6ICdMaW5lU3RyaW5nJywgY29vcmRpbmF0ZXM6IFsuLi5dIH0pOyAvLyBnZW9tZXRyeVxuICpcbiAqICoqTVVTVCoqIGJlIHVzZWQgYWZ0ZXIgYHdoZXJlKClgLlxuICpcbiAqICMjIyMgTm90ZTpcbiAqXG4gKiBBcyBvZiBNb25nb29zZSAzLjcsIGAkZ2VvV2l0aGluYCBpcyBhbHdheXMgdXNlZCBmb3IgcXVlcmllcy4gVG8gY2hhbmdlIHRoaXMgYmVoYXZpb3IsIHNlZSBbUXVlcnkudXNlJGdlb1dpdGhpbl0oaHR0cHM6Ly9tb25nb29zZWpzLmNvbS9kb2NzL2FwaS9xdWVyeS5odG1sI1F1ZXJ5LnByb3RvdHlwZS51c2UkZ2VvV2l0aGluKS5cbiAqXG4gKiAjIyMjIE5vdGU6XG4gKlxuICogSW4gTW9uZ29vc2UgMy43LCBgd2l0aGluYCBjaGFuZ2VkIGZyb20gYSBnZXR0ZXIgdG8gYSBmdW5jdGlvbi4gSWYgeW91IG5lZWQgdGhlIG9sZCBzeW50YXgsIHVzZSBbdGhpc10oaHR0cHM6Ly9naXRodWIuY29tL2ViZW5zaW5nL21vbmdvb3NlLXdpdGhpbikuXG4gKlxuICogQG1ldGhvZCB3aXRoaW5cbiAqIEBzZWUgJHBvbHlnb24gaHR0cHM6Ly93d3cubW9uZ29kYi5jb20vZG9jcy9tYW51YWwvcmVmZXJlbmNlL29wZXJhdG9yL3BvbHlnb24vXG4gKiBAc2VlICRib3ggaHR0cHM6Ly93d3cubW9uZ29kYi5jb20vZG9jcy9tYW51YWwvcmVmZXJlbmNlL29wZXJhdG9yL2JveC9cbiAqIEBzZWUgJGdlb21ldHJ5IGh0dHBzOi8vd3d3Lm1vbmdvZGIuY29tL2RvY3MvbWFudWFsL3JlZmVyZW5jZS9vcGVyYXRvci9nZW9tZXRyeS9cbiAqIEBzZWUgJGNlbnRlciBodHRwczovL3d3dy5tb25nb2RiLmNvbS9kb2NzL21hbnVhbC9yZWZlcmVuY2Uvb3BlcmF0b3IvY2VudGVyL1xuICogQHNlZSAkY2VudGVyU3BoZXJlIGh0dHBzOi8vd3d3Lm1vbmdvZGIuY29tL2RvY3MvbWFudWFsL3JlZmVyZW5jZS9vcGVyYXRvci9jZW50ZXJTcGhlcmUvXG4gKiBAbWVtYmVyT2YgUXVlcnlcbiAqIEBpbnN0YW5jZVxuICogQHJldHVybiB7UXVlcnl9IHRoaXNcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuLyoqXG4gKiBTcGVjaWZpZXMgdGhlIG1heGltdW0gbnVtYmVyIG9mIGRvY3VtZW50cyB0aGUgcXVlcnkgd2lsbCByZXR1cm4uXG4gKlxuICogIyMjIyBFeGFtcGxlOlxuICpcbiAqICAgICBxdWVyeS5saW1pdCgyMCk7XG4gKlxuICogIyMjIyBOb3RlOlxuICpcbiAqIENhbm5vdCBiZSB1c2VkIHdpdGggYGRpc3RpbmN0KClgXG4gKlxuICogQG1ldGhvZCBsaW1pdFxuICogQG1lbWJlck9mIFF1ZXJ5XG4gKiBAaW5zdGFuY2VcbiAqIEBwYXJhbSB7TnVtYmVyfSB2YWxcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuUXVlcnkucHJvdG90eXBlLmxpbWl0ID0gZnVuY3Rpb24gbGltaXQodikge1xuICB0aGlzLl92YWxpZGF0ZSgnbGltaXQnKTtcblxuICBpZiAodHlwZW9mIHYgPT09ICdzdHJpbmcnKSB7XG4gICAgdHJ5IHtcbiAgICAgIHYgPSBjYXN0TnVtYmVyKHYpO1xuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgdGhyb3cgbmV3IENhc3RFcnJvcignTnVtYmVyJywgdiwgJ2xpbWl0Jyk7XG4gICAgfVxuICB9XG5cbiAgdGhpcy5vcHRpb25zLmxpbWl0ID0gdjtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIFNwZWNpZmllcyB0aGUgbnVtYmVyIG9mIGRvY3VtZW50cyB0byBza2lwLlxuICpcbiAqICMjIyMgRXhhbXBsZTpcbiAqXG4gKiAgICAgcXVlcnkuc2tpcCgxMDApLmxpbWl0KDIwKTtcbiAqXG4gKiAjIyMjIE5vdGU6XG4gKlxuICogQ2Fubm90IGJlIHVzZWQgd2l0aCBgZGlzdGluY3QoKWBcbiAqXG4gKiBAbWV0aG9kIHNraXBcbiAqIEBtZW1iZXJPZiBRdWVyeVxuICogQGluc3RhbmNlXG4gKiBAcGFyYW0ge051bWJlcn0gdmFsXG4gKiBAc2VlIGN1cnNvci5za2lwIGh0dHBzOi8vd3d3Lm1vbmdvZGIuY29tL2RvY3MvbWFudWFsL3JlZmVyZW5jZS9tZXRob2QvY3Vyc29yLnNraXAvXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cblF1ZXJ5LnByb3RvdHlwZS5za2lwID0gZnVuY3Rpb24gc2tpcCh2KSB7XG4gIHRoaXMuX3ZhbGlkYXRlKCdza2lwJyk7XG5cbiAgaWYgKHR5cGVvZiB2ID09PSAnc3RyaW5nJykge1xuICAgIHRyeSB7XG4gICAgICB2ID0gY2FzdE51bWJlcih2KTtcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIHRocm93IG5ldyBDYXN0RXJyb3IoJ051bWJlcicsIHYsICdza2lwJyk7XG4gICAgfVxuICB9XG5cbiAgdGhpcy5vcHRpb25zLnNraXAgPSB2O1xuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogU3BlY2lmaWVzIHRoZSBiYXRjaFNpemUgb3B0aW9uLlxuICpcbiAqICMjIyMgRXhhbXBsZTpcbiAqXG4gKiAgICAgcXVlcnkuYmF0Y2hTaXplKDEwMClcbiAqXG4gKiAjIyMjIE5vdGU6XG4gKlxuICogQ2Fubm90IGJlIHVzZWQgd2l0aCBgZGlzdGluY3QoKWBcbiAqXG4gKiBAbWV0aG9kIGJhdGNoU2l6ZVxuICogQG1lbWJlck9mIFF1ZXJ5XG4gKiBAaW5zdGFuY2VcbiAqIEBwYXJhbSB7TnVtYmVyfSB2YWxcbiAqIEBzZWUgYmF0Y2hTaXplIGh0dHBzOi8vd3d3Lm1vbmdvZGIuY29tL2RvY3MvbWFudWFsL3JlZmVyZW5jZS9tZXRob2QvY3Vyc29yLmJhdGNoU2l6ZS9cbiAqIEBhcGkgcHVibGljXG4gKi9cblxuLyoqXG4gKiBTcGVjaWZpZXMgdGhlIGBjb21tZW50YCBvcHRpb24uXG4gKlxuICogIyMjIyBFeGFtcGxlOlxuICpcbiAqICAgICBxdWVyeS5jb21tZW50KCdsb2dpbiBxdWVyeScpXG4gKlxuICogIyMjIyBOb3RlOlxuICpcbiAqIENhbm5vdCBiZSB1c2VkIHdpdGggYGRpc3RpbmN0KClgXG4gKlxuICogQG1ldGhvZCBjb21tZW50XG4gKiBAbWVtYmVyT2YgUXVlcnlcbiAqIEBpbnN0YW5jZVxuICogQHBhcmFtIHtTdHJpbmd9IHZhbFxuICogQHNlZSBjb21tZW50IGh0dHBzOi8vd3d3Lm1vbmdvZGIuY29tL2RvY3MvbWFudWFsL3JlZmVyZW5jZS9vcGVyYXRvci9jb21tZW50L1xuICogQGFwaSBwdWJsaWNcbiAqL1xuXG4vKipcbiAqIFNldHMgcXVlcnkgaGludHMuXG4gKlxuICogIyMjIyBFeGFtcGxlOlxuICpcbiAqICAgICBxdWVyeS5oaW50KHsgaW5kZXhBOiAxLCBpbmRleEI6IC0xIH0pO1xuICpcbiAqICMjIyMgTm90ZTpcbiAqXG4gKiBDYW5ub3QgYmUgdXNlZCB3aXRoIGBkaXN0aW5jdCgpYFxuICpcbiAqIEBtZXRob2QgaGludFxuICogQG1lbWJlck9mIFF1ZXJ5XG4gKiBAaW5zdGFuY2VcbiAqIEBwYXJhbSB7T2JqZWN0fSB2YWwgYSBoaW50IG9iamVjdFxuICogQHJldHVybiB7UXVlcnl9IHRoaXNcbiAqIEBzZWUgJGhpbnQgaHR0cHM6Ly93d3cubW9uZ29kYi5jb20vZG9jcy9tYW51YWwvcmVmZXJlbmNlL29wZXJhdG9yL2hpbnQvXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbi8qKlxuICogR2V0L3NldCB0aGUgY3VycmVudCBwcm9qZWN0aW9uIChBS0EgZmllbGRzKS4gUGFzcyBgbnVsbGAgdG8gcmVtb3ZlIHRoZVxuICogY3VycmVudCBwcm9qZWN0aW9uLlxuICpcbiAqIFVubGlrZSBgcHJvamVjdGlvbigpYCwgdGhlIGBzZWxlY3QoKWAgZnVuY3Rpb24gbW9kaWZpZXMgdGhlIGN1cnJlbnRcbiAqIHByb2plY3Rpb24gaW4gcGxhY2UuIFRoaXMgZnVuY3Rpb24gb3ZlcndyaXRlcyB0aGUgZXhpc3RpbmcgcHJvamVjdGlvbi5cbiAqXG4gKiAjIyMjIEV4YW1wbGU6XG4gKlxuICogICAgIGNvbnN0IHEgPSBNb2RlbC5maW5kKCk7XG4gKiAgICAgcS5wcm9qZWN0aW9uKCk7IC8vIG51bGxcbiAqXG4gKiAgICAgcS5zZWxlY3QoJ2EgYicpO1xuICogICAgIHEucHJvamVjdGlvbigpOyAvLyB7IGE6IDEsIGI6IDEgfVxuICpcbiAqICAgICBxLnByb2plY3Rpb24oeyBjOiAxIH0pO1xuICogICAgIHEucHJvamVjdGlvbigpOyAvLyB7IGM6IDEgfVxuICpcbiAqICAgICBxLnByb2plY3Rpb24obnVsbCk7XG4gKiAgICAgcS5wcm9qZWN0aW9uKCk7IC8vIG51bGxcbiAqXG4gKlxuICogQG1ldGhvZCBwcm9qZWN0aW9uXG4gKiBAbWVtYmVyT2YgUXVlcnlcbiAqIEBpbnN0YW5jZVxuICogQHBhcmFtIHtPYmplY3R8bnVsbH0gYXJnXG4gKiBAcmV0dXJuIHtPYmplY3R9IHRoZSBjdXJyZW50IHByb2plY3Rpb25cbiAqIEBhcGkgcHVibGljXG4gKi9cblxuUXVlcnkucHJvdG90eXBlLnByb2plY3Rpb24gPSBmdW5jdGlvbihhcmcpIHtcbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDApIHtcbiAgICByZXR1cm4gdGhpcy5fZmllbGRzO1xuICB9XG5cbiAgdGhpcy5fZmllbGRzID0ge307XG4gIHRoaXMuX3VzZXJQcm92aWRlZEZpZWxkcyA9IHt9O1xuICB0aGlzLnNlbGVjdChhcmcpO1xuICByZXR1cm4gdGhpcy5fZmllbGRzO1xufTtcblxuLyoqXG4gKiBTcGVjaWZpZXMgd2hpY2ggZG9jdW1lbnQgZmllbGRzIHRvIGluY2x1ZGUgb3IgZXhjbHVkZSAoYWxzbyBrbm93biBhcyB0aGUgcXVlcnkgXCJwcm9qZWN0aW9uXCIpXG4gKlxuICogV2hlbiB1c2luZyBzdHJpbmcgc3ludGF4LCBwcmVmaXhpbmcgYSBwYXRoIHdpdGggYC1gIHdpbGwgZmxhZyB0aGF0IHBhdGggYXMgZXhjbHVkZWQuIFdoZW4gYSBwYXRoIGRvZXMgbm90IGhhdmUgdGhlIGAtYCBwcmVmaXgsIGl0IGlzIGluY2x1ZGVkLiBMYXN0bHksIGlmIGEgcGF0aCBpcyBwcmVmaXhlZCB3aXRoIGArYCwgaXQgZm9yY2VzIGluY2x1c2lvbiBvZiB0aGUgcGF0aCwgd2hpY2ggaXMgdXNlZnVsIGZvciBwYXRocyBleGNsdWRlZCBhdCB0aGUgW3NjaGVtYSBsZXZlbF0oaHR0cHM6Ly9tb25nb29zZWpzLmNvbS9kb2NzL2FwaS9zY2hlbWF0eXBlLmh0bWwjU2NoZW1hVHlwZS5wcm90b3R5cGUuc2VsZWN0KCkpLlxuICpcbiAqIEEgcHJvamVjdGlvbiBfbXVzdF8gYmUgZWl0aGVyIGluY2x1c2l2ZSBvciBleGNsdXNpdmUuIEluIG90aGVyIHdvcmRzLCB5b3UgbXVzdFxuICogZWl0aGVyIGxpc3QgdGhlIGZpZWxkcyB0byBpbmNsdWRlICh3aGljaCBleGNsdWRlcyBhbGwgb3RoZXJzKSwgb3IgbGlzdCB0aGUgZmllbGRzXG4gKiB0byBleGNsdWRlICh3aGljaCBpbXBsaWVzIGFsbCBvdGhlciBmaWVsZHMgYXJlIGluY2x1ZGVkKS4gVGhlIFtgX2lkYCBmaWVsZCBpcyB0aGUgb25seSBleGNlcHRpb24gYmVjYXVzZSBNb25nb0RCIGluY2x1ZGVzIGl0IGJ5IGRlZmF1bHRdKGh0dHBzOi8vd3d3Lm1vbmdvZGIuY29tL2RvY3MvbWFudWFsL3R1dG9yaWFsL3Byb2plY3QtZmllbGRzLWZyb20tcXVlcnktcmVzdWx0cy8jc3VwcHJlc3MtaWQtZmllbGQpLlxuICpcbiAqICMjIyMgRXhhbXBsZTpcbiAqXG4gKiAgICAgLy8gaW5jbHVkZSBhIGFuZCBiLCBleGNsdWRlIG90aGVyIGZpZWxkc1xuICogICAgIHF1ZXJ5LnNlbGVjdCgnYSBiJyk7XG4gKiAgICAgLy8gRXF1aXZhbGVudCBzeW50YXhlczpcbiAqICAgICBxdWVyeS5zZWxlY3QoWydhJywgJ2InXSk7XG4gKiAgICAgcXVlcnkuc2VsZWN0KHsgYTogMSwgYjogMSB9KTtcbiAqXG4gKiAgICAgLy8gZXhjbHVkZSBjIGFuZCBkLCBpbmNsdWRlIG90aGVyIGZpZWxkc1xuICogICAgIHF1ZXJ5LnNlbGVjdCgnLWMgLWQnKTtcbiAqXG4gKiAgICAgLy8gVXNlIGArYCB0byBvdmVycmlkZSBzY2hlbWEtbGV2ZWwgYHNlbGVjdDogZmFsc2VgIHdpdGhvdXQgbWFraW5nIHRoZVxuICogICAgIC8vIHByb2plY3Rpb24gaW5jbHVzaXZlLlxuICogICAgIGNvbnN0IHNjaGVtYSA9IG5ldyBTY2hlbWEoe1xuICogICAgICAgZm9vOiB7IHR5cGU6IFN0cmluZywgc2VsZWN0OiBmYWxzZSB9LFxuICogICAgICAgYmFyOiBTdHJpbmdcbiAqICAgICB9KTtcbiAqICAgICAvLyAuLi5cbiAqICAgICBxdWVyeS5zZWxlY3QoJytmb28nKTsgLy8gT3ZlcnJpZGUgZm9vJ3MgYHNlbGVjdDogZmFsc2VgIHdpdGhvdXQgZXhjbHVkaW5nIGBiYXJgXG4gKlxuICogICAgIC8vIG9yIHlvdSBtYXkgdXNlIG9iamVjdCBub3RhdGlvbiwgdXNlZnVsIHdoZW5cbiAqICAgICAvLyB5b3UgaGF2ZSBrZXlzIGFscmVhZHkgcHJlZml4ZWQgd2l0aCBhIFwiLVwiXG4gKiAgICAgcXVlcnkuc2VsZWN0KHsgYTogMSwgYjogMSB9KTtcbiAqICAgICBxdWVyeS5zZWxlY3QoeyBjOiAwLCBkOiAwIH0pO1xuICpcbiAqICAgICBBZGRpdGlvbmFsIGNhbGxzIHRvIHNlbGVjdCBjYW4gb3ZlcnJpZGUgdGhlIHByZXZpb3VzIHNlbGVjdGlvbjpcbiAqICAgICBxdWVyeS5zZWxlY3QoeyBhOiAxLCBiOiAxIH0pLnNlbGVjdCh7IGI6IDAgfSk7IC8vIHNlbGVjdGlvbiBpcyBub3cgeyBhOiAxIH1cbiAqICAgICBxdWVyeS5zZWxlY3QoeyBhOiAwLCBiOiAwIH0pLnNlbGVjdCh7IGI6IDEgfSk7IC8vIHNlbGVjdGlvbiBpcyBub3cgeyBhOiAwIH1cbiAqXG4gKlxuICogQG1ldGhvZCBzZWxlY3RcbiAqIEBtZW1iZXJPZiBRdWVyeVxuICogQGluc3RhbmNlXG4gKiBAcGFyYW0ge09iamVjdHxTdHJpbmd8U3RyaW5nW119IGFyZ1xuICogQHJldHVybiB7UXVlcnl9IHRoaXNcbiAqIEBzZWUgU2NoZW1hVHlwZSBodHRwczovL21vbmdvb3NlanMuY29tL2RvY3MvYXBpL3NjaGVtYXR5cGUuaHRtbFxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5RdWVyeS5wcm90b3R5cGUuc2VsZWN0ID0gZnVuY3Rpb24gc2VsZWN0KCkge1xuICBsZXQgYXJnID0gYXJndW1lbnRzWzBdO1xuICBpZiAoIWFyZykgcmV0dXJuIHRoaXM7XG5cbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggIT09IDEpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgc2VsZWN0OiBzZWxlY3Qgb25seSB0YWtlcyAxIGFyZ3VtZW50Jyk7XG4gIH1cblxuICB0aGlzLl92YWxpZGF0ZSgnc2VsZWN0Jyk7XG5cbiAgY29uc3QgZmllbGRzID0gdGhpcy5fZmllbGRzIHx8ICh0aGlzLl9maWVsZHMgPSB7fSk7XG4gIGNvbnN0IHVzZXJQcm92aWRlZEZpZWxkcyA9IHRoaXMuX3VzZXJQcm92aWRlZEZpZWxkcyB8fCAodGhpcy5fdXNlclByb3ZpZGVkRmllbGRzID0ge30pO1xuICBsZXQgc2FuaXRpemVQcm9qZWN0aW9uID0gdW5kZWZpbmVkO1xuICBpZiAodGhpcy5tb2RlbCAhPSBudWxsICYmIHV0aWxzLmhhc1VzZXJEZWZpbmVkUHJvcGVydHkodGhpcy5tb2RlbC5kYi5vcHRpb25zLCAnc2FuaXRpemVQcm9qZWN0aW9uJykpIHtcbiAgICBzYW5pdGl6ZVByb2plY3Rpb24gPSB0aGlzLm1vZGVsLmRiLm9wdGlvbnMuc2FuaXRpemVQcm9qZWN0aW9uO1xuICB9IGVsc2UgaWYgKHRoaXMubW9kZWwgIT0gbnVsbCAmJiB1dGlscy5oYXNVc2VyRGVmaW5lZFByb3BlcnR5KHRoaXMubW9kZWwuYmFzZS5vcHRpb25zLCAnc2FuaXRpemVQcm9qZWN0aW9uJykpIHtcbiAgICBzYW5pdGl6ZVByb2plY3Rpb24gPSB0aGlzLm1vZGVsLmJhc2Uub3B0aW9ucy5zYW5pdGl6ZVByb2plY3Rpb247XG4gIH0gZWxzZSB7XG4gICAgc2FuaXRpemVQcm9qZWN0aW9uID0gdGhpcy5fbW9uZ29vc2VPcHRpb25zLnNhbml0aXplUHJvamVjdGlvbjtcbiAgfVxuXG4gIGZ1bmN0aW9uIHNhbml0aXplVmFsdWUodmFsdWUpIHtcbiAgICByZXR1cm4gdHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJyAmJiBzYW5pdGl6ZVByb2plY3Rpb24gPyB2YWx1ZSA9IDEgOiB2YWx1ZTtcbiAgfVxuICBhcmcgPSBwYXJzZVByb2plY3Rpb24oYXJnLCB0cnVlKTsgLy8gd2Ugd2FudCB0byBrZWVwIHRoZSBtaW51cyBhbmQgcGx1c2VzLCBzbyBhZGQgYm9vbGVhbiBhcmcuXG4gIGlmICh1dGlscy5pc09iamVjdChhcmcpKSB7XG4gICAgaWYgKHRoaXMuc2VsZWN0ZWRJbmNsdXNpdmVseSgpKSB7XG4gICAgICBPYmplY3QuZW50cmllcyhhcmcpLmZvckVhY2goKFtrZXksIHZhbHVlXSkgPT4ge1xuICAgICAgICBpZiAodmFsdWUpIHtcbiAgICAgICAgICAvLyBBZGQgdGhlIGZpZWxkIHRvIHRoZSBwcm9qZWN0aW9uXG4gICAgICAgICAgaWYgKGZpZWxkc1snLScgKyBrZXldICE9IG51bGwpIHtcbiAgICAgICAgICAgIGRlbGV0ZSBmaWVsZHNbJy0nICsga2V5XTtcbiAgICAgICAgICB9XG4gICAgICAgICAgZmllbGRzW2tleV0gPSB1c2VyUHJvdmlkZWRGaWVsZHNba2V5XSA9IHNhbml0aXplVmFsdWUodmFsdWUpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIFJlbW92ZSB0aGUgZmllbGQgZnJvbSB0aGUgcHJvamVjdGlvblxuICAgICAgICAgIE9iamVjdC5rZXlzKHVzZXJQcm92aWRlZEZpZWxkcykuZm9yRWFjaChmaWVsZCA9PiB7XG4gICAgICAgICAgICBpZiAoaXNTdWJwYXRoKGtleSwgZmllbGQpKSB7XG4gICAgICAgICAgICAgIGRlbGV0ZSBmaWVsZHNbZmllbGRdO1xuICAgICAgICAgICAgICBkZWxldGUgdXNlclByb3ZpZGVkRmllbGRzW2ZpZWxkXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfSBlbHNlIGlmICh0aGlzLnNlbGVjdGVkRXhjbHVzaXZlbHkoKSkge1xuICAgICAgT2JqZWN0LmVudHJpZXMoYXJnKS5mb3JFYWNoKChba2V5LCB2YWx1ZV0pID0+IHtcbiAgICAgICAgaWYgKCF2YWx1ZSkge1xuICAgICAgICAgIC8vIEFkZCB0aGUgZmllbGQgdG8gdGhlIHByb2plY3Rpb25cbiAgICAgICAgICBpZiAoZmllbGRzWycrJyArIGtleV0gIT0gbnVsbCkge1xuICAgICAgICAgICAgZGVsZXRlIGZpZWxkc1snKycgKyBrZXldO1xuICAgICAgICAgIH1cbiAgICAgICAgICBmaWVsZHNba2V5XSA9IHVzZXJQcm92aWRlZEZpZWxkc1trZXldID0gc2FuaXRpemVWYWx1ZSh2YWx1ZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gUmVtb3ZlIHRoZSBmaWVsZCBmcm9tIHRoZSBwcm9qZWN0aW9uXG4gICAgICAgICAgT2JqZWN0LmtleXModXNlclByb3ZpZGVkRmllbGRzKS5mb3JFYWNoKGZpZWxkID0+IHtcbiAgICAgICAgICAgIGlmIChpc1N1YnBhdGgoa2V5LCBmaWVsZCkpIHtcbiAgICAgICAgICAgICAgZGVsZXRlIGZpZWxkc1tmaWVsZF07XG4gICAgICAgICAgICAgIGRlbGV0ZSB1c2VyUHJvdmlkZWRGaWVsZHNbZmllbGRdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3Qga2V5cyA9IE9iamVjdC5rZXlzKGFyZyk7XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGtleXMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgY29uc3QgdmFsdWUgPSBhcmdba2V5c1tpXV07XG4gICAgICAgIGNvbnN0IGtleSA9IGtleXNbaV07XG4gICAgICAgIGZpZWxkc1trZXldID0gc2FuaXRpemVWYWx1ZSh2YWx1ZSk7XG4gICAgICAgIHVzZXJQcm92aWRlZEZpZWxkc1trZXldID0gc2FuaXRpemVWYWx1ZSh2YWx1ZSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICB0aHJvdyBuZXcgVHlwZUVycm9yKCdJbnZhbGlkIHNlbGVjdCgpIGFyZ3VtZW50LiBNdXN0IGJlIHN0cmluZyBvciBvYmplY3QuJyk7XG59O1xuXG4vKipcbiAqIERldGVybWluZXMgdGhlIE1vbmdvREIgbm9kZXMgZnJvbSB3aGljaCB0byByZWFkLlxuICpcbiAqICMjIyMgUHJlZmVyZW5jZXM6XG4gKlxuICogYGBgXG4gKiBwcmltYXJ5IC0gKGRlZmF1bHQpIFJlYWQgZnJvbSBwcmltYXJ5IG9ubHkuIE9wZXJhdGlvbnMgd2lsbCBwcm9kdWNlIGFuIGVycm9yIGlmIHByaW1hcnkgaXMgdW5hdmFpbGFibGUuIENhbm5vdCBiZSBjb21iaW5lZCB3aXRoIHRhZ3MuXG4gKiBzZWNvbmRhcnkgICAgICAgICAgICBSZWFkIGZyb20gc2Vjb25kYXJ5IGlmIGF2YWlsYWJsZSwgb3RoZXJ3aXNlIGVycm9yLlxuICogcHJpbWFyeVByZWZlcnJlZCAgICAgUmVhZCBmcm9tIHByaW1hcnkgaWYgYXZhaWxhYmxlLCBvdGhlcndpc2UgYSBzZWNvbmRhcnkuXG4gKiBzZWNvbmRhcnlQcmVmZXJyZWQgICBSZWFkIGZyb20gYSBzZWNvbmRhcnkgaWYgYXZhaWxhYmxlLCBvdGhlcndpc2UgcmVhZCBmcm9tIHRoZSBwcmltYXJ5LlxuICogbmVhcmVzdCAgICAgICAgICAgICAgQWxsIG9wZXJhdGlvbnMgcmVhZCBmcm9tIGFtb25nIHRoZSBuZWFyZXN0IGNhbmRpZGF0ZXMsIGJ1dCB1bmxpa2Ugb3RoZXIgbW9kZXMsIHRoaXMgb3B0aW9uIHdpbGwgaW5jbHVkZSBib3RoIHRoZSBwcmltYXJ5IGFuZCBhbGwgc2Vjb25kYXJpZXMgaW4gdGhlIHJhbmRvbSBzZWxlY3Rpb24uXG4gKiBgYGBcbiAqXG4gKiBBbGlhc2VzXG4gKlxuICogYGBgXG4gKiBwICAgcHJpbWFyeVxuICogcHAgIHByaW1hcnlQcmVmZXJyZWRcbiAqIHMgICBzZWNvbmRhcnlcbiAqIHNwICBzZWNvbmRhcnlQcmVmZXJyZWRcbiAqIG4gICBuZWFyZXN0XG4gKiBgYGBcbiAqXG4gKiAjIyMjIEV4YW1wbGU6XG4gKlxuICogICAgIG5ldyBRdWVyeSgpLnJlYWQoJ3ByaW1hcnknKVxuICogICAgIG5ldyBRdWVyeSgpLnJlYWQoJ3AnKSAgLy8gc2FtZSBhcyBwcmltYXJ5XG4gKlxuICogICAgIG5ldyBRdWVyeSgpLnJlYWQoJ3ByaW1hcnlQcmVmZXJyZWQnKVxuICogICAgIG5ldyBRdWVyeSgpLnJlYWQoJ3BwJykgLy8gc2FtZSBhcyBwcmltYXJ5UHJlZmVycmVkXG4gKlxuICogICAgIG5ldyBRdWVyeSgpLnJlYWQoJ3NlY29uZGFyeScpXG4gKiAgICAgbmV3IFF1ZXJ5KCkucmVhZCgncycpICAvLyBzYW1lIGFzIHNlY29uZGFyeVxuICpcbiAqICAgICBuZXcgUXVlcnkoKS5yZWFkKCdzZWNvbmRhcnlQcmVmZXJyZWQnKVxuICogICAgIG5ldyBRdWVyeSgpLnJlYWQoJ3NwJykgLy8gc2FtZSBhcyBzZWNvbmRhcnlQcmVmZXJyZWRcbiAqXG4gKiAgICAgbmV3IFF1ZXJ5KCkucmVhZCgnbmVhcmVzdCcpXG4gKiAgICAgbmV3IFF1ZXJ5KCkucmVhZCgnbicpICAvLyBzYW1lIGFzIG5lYXJlc3RcbiAqXG4gKiAgICAgLy8gcmVhZCBmcm9tIHNlY29uZGFyaWVzIHdpdGggbWF0Y2hpbmcgdGFnc1xuICogICAgIG5ldyBRdWVyeSgpLnJlYWQoJ3MnLCBbeyBkYzonc2YnLCBzOiAxIH0seyBkYzonbWEnLCBzOiAyIH1dKVxuICpcbiAqIFJlYWQgbW9yZSBhYm91dCBob3cgdG8gdXNlIHJlYWQgcHJlZmVyZW5jZXMgW2hlcmVdKGh0dHBzOi8vd3d3Lm1vbmdvZGIuY29tL2RvY3MvbWFudWFsL2FwcGxpY2F0aW9ucy9yZXBsaWNhdGlvbi8jcmVhZC1wcmVmZXJlbmNlKS5cbiAqXG4gKiBAbWV0aG9kIHJlYWRcbiAqIEBtZW1iZXJPZiBRdWVyeVxuICogQGluc3RhbmNlXG4gKiBAcGFyYW0ge1N0cmluZ30gbW9kZSBvbmUgb2YgdGhlIGxpc3RlZCBwcmVmZXJlbmNlIG9wdGlvbnMgb3IgYWxpYXNlc1xuICogQHBhcmFtIHtBcnJheX0gW3RhZ3NdIG9wdGlvbmFsIHRhZ3MgZm9yIHRoaXMgcXVlcnlcbiAqIEBzZWUgbW9uZ29kYiBodHRwczovL3d3dy5tb25nb2RiLmNvbS9kb2NzL21hbnVhbC9hcHBsaWNhdGlvbnMvcmVwbGljYXRpb24vI3JlYWQtcHJlZmVyZW5jZVxuICogQHJldHVybiB7UXVlcnl9IHRoaXNcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuUXVlcnkucHJvdG90eXBlLnJlYWQgPSBmdW5jdGlvbiByZWFkKG1vZGUsIHRhZ3MpIHtcbiAgaWYgKHR5cGVvZiBtb2RlID09PSAnc3RyaW5nJykge1xuICAgIG1vZGUgPSBoYW5kbGVSZWFkUHJlZmVyZW5jZUFsaWFzZXMobW9kZSk7XG4gICAgdGhpcy5vcHRpb25zLnJlYWRQcmVmZXJlbmNlID0geyBtb2RlLCB0YWdzIH07XG4gIH0gZWxzZSB7XG4gICAgdGhpcy5vcHRpb25zLnJlYWRQcmVmZXJlbmNlID0gbW9kZTtcbiAgfVxuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogT3ZlcndyaXRlIGRlZmF1bHQgYC50b1N0cmluZ2AgdG8gbWFrZSBsb2dnaW5nIG1vcmUgdXNlZnVsXG4gKlxuICogQG1lbWJlck9mIFF1ZXJ5XG4gKiBAaW5zdGFuY2VcbiAqIEBtZXRob2QgdG9TdHJpbmdcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cblF1ZXJ5LnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uIHRvU3RyaW5nKCkge1xuICBpZiAodGhpcy5vcCA9PT0gJ2NvdW50JyB8fFxuICAgICAgdGhpcy5vcCA9PT0gJ2NvdW50RG9jdW1lbnRzJyB8fFxuICAgICAgdGhpcy5vcCA9PT0gJ2ZpbmQnIHx8XG4gICAgICB0aGlzLm9wID09PSAnZmluZE9uZScgfHxcbiAgICAgIHRoaXMub3AgPT09ICdkZWxldGVNYW55JyB8fFxuICAgICAgdGhpcy5vcCA9PT0gJ2RlbGV0ZU9uZScgfHxcbiAgICAgIHRoaXMub3AgPT09ICdmaW5kT25lQW5kRGVsZXRlJyB8fFxuICAgICAgdGhpcy5vcCA9PT0gJ3JlbW92ZScpIHtcbiAgICByZXR1cm4gYCR7dGhpcy5tb2RlbC5tb2RlbE5hbWV9LiR7dGhpcy5vcH0oJHt1dGlsLmluc3BlY3QodGhpcy5fY29uZGl0aW9ucyl9KWA7XG4gIH1cbiAgaWYgKHRoaXMub3AgPT09ICdkaXN0aW5jdCcpIHtcbiAgICByZXR1cm4gYCR7dGhpcy5tb2RlbC5tb2RlbE5hbWV9LmRpc3RpbmN0KCcke3RoaXMuX2Rpc3RpbmN0fScsICR7dXRpbC5pbnNwZWN0KHRoaXMuX2NvbmRpdGlvbnMpfSlgO1xuICB9XG4gIGlmICh0aGlzLm9wID09PSAnZmluZE9uZUFuZFJlcGxhY2UnIHx8XG4gICAgICB0aGlzLm9wID09PSAnZmluZE9uZUFuZFVwZGF0ZScgfHxcbiAgICAgIHRoaXMub3AgPT09ICdyZXBsYWNlT25lJyB8fFxuICAgICAgdGhpcy5vcCA9PT0gJ3VwZGF0ZScgfHxcbiAgICAgIHRoaXMub3AgPT09ICd1cGRhdGVNYW55JyB8fFxuICAgICAgdGhpcy5vcCA9PT0gJ3VwZGF0ZU9uZScpIHtcbiAgICByZXR1cm4gYCR7dGhpcy5tb2RlbC5tb2RlbE5hbWV9LiR7dGhpcy5vcH0oJHt1dGlsLmluc3BlY3QodGhpcy5fY29uZGl0aW9ucyl9LCAke3V0aWwuaW5zcGVjdCh0aGlzLl91cGRhdGUpfSlgO1xuICB9XG5cbiAgLy8gJ2VzdGltYXRlZERvY3VtZW50Q291bnQnIG9yIGFueSBvdGhlcnNcbiAgcmV0dXJuIGAke3RoaXMubW9kZWwubW9kZWxOYW1lfS4ke3RoaXMub3B9KClgO1xufTtcblxuLyoqXG4gKiBTZXRzIHRoZSBbTW9uZ29EQiBzZXNzaW9uXShodHRwczovL3d3dy5tb25nb2RiLmNvbS9kb2NzL21hbnVhbC9yZWZlcmVuY2Uvc2VydmVyLXNlc3Npb25zLylcbiAqIGFzc29jaWF0ZWQgd2l0aCB0aGlzIHF1ZXJ5LiBTZXNzaW9ucyBhcmUgaG93IHlvdSBtYXJrIGEgcXVlcnkgYXMgcGFydCBvZiBhXG4gKiBbdHJhbnNhY3Rpb25dKGh0dHBzOi8vbW9uZ29vc2Vqcy5jb20vZG9jcy90cmFuc2FjdGlvbnMuaHRtbCkuXG4gKlxuICogQ2FsbGluZyBgc2Vzc2lvbihudWxsKWAgcmVtb3ZlcyB0aGUgc2Vzc2lvbiBmcm9tIHRoaXMgcXVlcnkuXG4gKlxuICogIyMjIyBFeGFtcGxlOlxuICpcbiAqICAgICBjb25zdCBzID0gYXdhaXQgbW9uZ29vc2Uuc3RhcnRTZXNzaW9uKCk7XG4gKiAgICAgYXdhaXQgbW9uZ29vc2UubW9kZWwoJ1BlcnNvbicpLmZpbmRPbmUoeyBuYW1lOiAnQXhsIFJvc2UnIH0pLnNlc3Npb24ocyk7XG4gKlxuICogQG1ldGhvZCBzZXNzaW9uXG4gKiBAbWVtYmVyT2YgUXVlcnlcbiAqIEBpbnN0YW5jZVxuICogQHBhcmFtIHtDbGllbnRTZXNzaW9ufSBbc2Vzc2lvbl0gZnJvbSBgYXdhaXQgY29ubi5zdGFydFNlc3Npb24oKWBcbiAqIEBzZWUgQ29ubmVjdGlvbi5wcm90b3R5cGUuc3RhcnRTZXNzaW9uKCkgaHR0cHM6Ly9tb25nb29zZWpzLmNvbS9kb2NzL2FwaS9jb25uZWN0aW9uLmh0bWwjQ29ubmVjdGlvbi5wcm90b3R5cGUuc3RhcnRTZXNzaW9uKClcbiAqIEBzZWUgbW9uZ29vc2Uuc3RhcnRTZXNzaW9uKCkgaHR0cHM6Ly9tb25nb29zZWpzLmNvbS9kb2NzL2FwaS9tb25nb29zZS5odG1sI01vbmdvb3NlLnByb3RvdHlwZS5zdGFydFNlc3Npb24oKVxuICogQHJldHVybiB7UXVlcnl9IHRoaXNcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuUXVlcnkucHJvdG90eXBlLnNlc3Npb24gPSBmdW5jdGlvbiBzZXNzaW9uKHYpIHtcbiAgaWYgKHYgPT0gbnVsbCkge1xuICAgIGRlbGV0ZSB0aGlzLm9wdGlvbnMuc2Vzc2lvbjtcbiAgfVxuICB0aGlzLm9wdGlvbnMuc2Vzc2lvbiA9IHY7XG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBTZXRzIHRoZSAzIHdyaXRlIGNvbmNlcm4gcGFyYW1ldGVycyBmb3IgdGhpcyBxdWVyeTpcbiAqXG4gKiAtIGB3YDogU2V0cyB0aGUgc3BlY2lmaWVkIG51bWJlciBvZiBgbW9uZ29kYCBzZXJ2ZXJzLCBvciB0YWcgc2V0IG9mIGBtb25nb2RgIHNlcnZlcnMsIHRoYXQgbXVzdCBhY2tub3dsZWRnZSB0aGlzIHdyaXRlIGJlZm9yZSB0aGlzIHdyaXRlIGlzIGNvbnNpZGVyZWQgc3VjY2Vzc2Z1bC5cbiAqIC0gYGpgOiBCb29sZWFuLCBzZXQgdG8gYHRydWVgIHRvIHJlcXVlc3QgYWNrbm93bGVkZ2VtZW50IHRoYXQgdGhpcyBvcGVyYXRpb24gaGFzIGJlZW4gcGVyc2lzdGVkIHRvIE1vbmdvREIncyBvbi1kaXNrIGpvdXJuYWwuXG4gKiAtIGB3dGltZW91dGA6IElmIFtgdyA+IDFgXShodHRwczovL21vbmdvb3NlanMuY29tL2RvY3MvYXBpL3F1ZXJ5Lmh0bWwjUXVlcnkucHJvdG90eXBlLncoKSksIHRoZSBtYXhpbXVtIGFtb3VudCBvZiB0aW1lIHRvIHdhaXQgZm9yIHRoaXMgd3JpdGUgdG8gcHJvcGFnYXRlIHRocm91Z2ggdGhlIHJlcGxpY2Egc2V0IGJlZm9yZSB0aGlzIG9wZXJhdGlvbiBmYWlscy4gVGhlIGRlZmF1bHQgaXMgYDBgLCB3aGljaCBtZWFucyBubyB0aW1lb3V0LlxuICpcbiAqIFRoaXMgb3B0aW9uIGlzIG9ubHkgdmFsaWQgZm9yIG9wZXJhdGlvbnMgdGhhdCB3cml0ZSB0byB0aGUgZGF0YWJhc2U6XG4gKlxuICogLSBgZGVsZXRlT25lKClgXG4gKiAtIGBkZWxldGVNYW55KClgXG4gKiAtIGBmaW5kT25lQW5kRGVsZXRlKClgXG4gKiAtIGBmaW5kT25lQW5kUmVwbGFjZSgpYFxuICogLSBgZmluZE9uZUFuZFVwZGF0ZSgpYFxuICogLSBgdXBkYXRlT25lKClgXG4gKiAtIGB1cGRhdGVNYW55KClgXG4gKlxuICogRGVmYXVsdHMgdG8gdGhlIHNjaGVtYSdzIFtgd3JpdGVDb25jZXJuYCBvcHRpb25dKGh0dHBzOi8vbW9uZ29vc2Vqcy5jb20vZG9jcy9ndWlkZS5odG1sI3dyaXRlQ29uY2VybilcbiAqXG4gKiAjIyMjIEV4YW1wbGU6XG4gKlxuICogICAgIC8vIFRoZSAnbWFqb3JpdHknIG9wdGlvbiBtZWFucyB0aGUgYGRlbGV0ZU9uZSgpYCBwcm9taXNlIHdvbid0IHJlc29sdmVcbiAqICAgICAvLyB1bnRpbCB0aGUgYGRlbGV0ZU9uZSgpYCBoYXMgcHJvcGFnYXRlZCB0byB0aGUgbWFqb3JpdHkgb2YgdGhlIHJlcGxpY2Egc2V0XG4gKiAgICAgYXdhaXQgbW9uZ29vc2UubW9kZWwoJ1BlcnNvbicpLlxuICogICAgICAgZGVsZXRlT25lKHsgbmFtZTogJ05lZCBTdGFyaycgfSkuXG4gKiAgICAgICB3cml0ZUNvbmNlcm4oeyB3OiAnbWFqb3JpdHknIH0pO1xuICpcbiAqIEBtZXRob2Qgd3JpdGVDb25jZXJuXG4gKiBAbWVtYmVyT2YgUXVlcnlcbiAqIEBpbnN0YW5jZVxuICogQHBhcmFtIHtPYmplY3R9IHdyaXRlQ29uY2VybiB0aGUgd3JpdGUgY29uY2VybiB2YWx1ZSB0byBzZXRcbiAqIEBzZWUgV3JpdGVDb25jZXJuU2V0dGluZ3MgaHR0cHM6Ly9tb25nb2RiLmdpdGh1Yi5pby9ub2RlLW1vbmdvZGItbmF0aXZlLzQuOS9pbnRlcmZhY2VzL1dyaXRlQ29uY2VyblNldHRpbmdzLmh0bWxcbiAqIEByZXR1cm4ge1F1ZXJ5fSB0aGlzXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cblF1ZXJ5LnByb3RvdHlwZS53cml0ZUNvbmNlcm4gPSBmdW5jdGlvbiB3cml0ZUNvbmNlcm4odmFsKSB7XG4gIGlmICh2YWwgPT0gbnVsbCkge1xuICAgIGRlbGV0ZSB0aGlzLm9wdGlvbnMud3JpdGVDb25jZXJuO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIHRoaXMub3B0aW9ucy53cml0ZUNvbmNlcm4gPSB2YWw7XG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBTZXRzIHRoZSBzcGVjaWZpZWQgbnVtYmVyIG9mIGBtb25nb2RgIHNlcnZlcnMsIG9yIHRhZyBzZXQgb2YgYG1vbmdvZGAgc2VydmVycyxcbiAqIHRoYXQgbXVzdCBhY2tub3dsZWRnZSB0aGlzIHdyaXRlIGJlZm9yZSB0aGlzIHdyaXRlIGlzIGNvbnNpZGVyZWQgc3VjY2Vzc2Z1bC5cbiAqIFRoaXMgb3B0aW9uIGlzIG9ubHkgdmFsaWQgZm9yIG9wZXJhdGlvbnMgdGhhdCB3cml0ZSB0byB0aGUgZGF0YWJhc2U6XG4gKlxuICogLSBgZGVsZXRlT25lKClgXG4gKiAtIGBkZWxldGVNYW55KClgXG4gKiAtIGBmaW5kT25lQW5kRGVsZXRlKClgXG4gKiAtIGBmaW5kT25lQW5kUmVwbGFjZSgpYFxuICogLSBgZmluZE9uZUFuZFVwZGF0ZSgpYFxuICogLSBgdXBkYXRlT25lKClgXG4gKiAtIGB1cGRhdGVNYW55KClgXG4gKlxuICogRGVmYXVsdHMgdG8gdGhlIHNjaGVtYSdzIFtgd3JpdGVDb25jZXJuLndgIG9wdGlvbl0oaHR0cHM6Ly9tb25nb29zZWpzLmNvbS9kb2NzL2d1aWRlLmh0bWwjd3JpdGVDb25jZXJuKVxuICpcbiAqICMjIyMgRXhhbXBsZTpcbiAqXG4gKiAgICAgLy8gVGhlICdtYWpvcml0eScgb3B0aW9uIG1lYW5zIHRoZSBgZGVsZXRlT25lKClgIHByb21pc2Ugd29uJ3QgcmVzb2x2ZVxuICogICAgIC8vIHVudGlsIHRoZSBgZGVsZXRlT25lKClgIGhhcyBwcm9wYWdhdGVkIHRvIHRoZSBtYWpvcml0eSBvZiB0aGUgcmVwbGljYSBzZXRcbiAqICAgICBhd2FpdCBtb25nb29zZS5tb2RlbCgnUGVyc29uJykuXG4gKiAgICAgICBkZWxldGVPbmUoeyBuYW1lOiAnTmVkIFN0YXJrJyB9KS5cbiAqICAgICAgIHcoJ21ham9yaXR5Jyk7XG4gKlxuICogQG1ldGhvZCB3XG4gKiBAbWVtYmVyT2YgUXVlcnlcbiAqIEBpbnN0YW5jZVxuICogQHBhcmFtIHtTdHJpbmd8bnVtYmVyfSB2YWwgMCBmb3IgZmlyZS1hbmQtZm9yZ2V0LCAxIGZvciBhY2tub3dsZWRnZWQgYnkgb25lIHNlcnZlciwgJ21ham9yaXR5JyBmb3IgbWFqb3JpdHkgb2YgdGhlIHJlcGxpY2Egc2V0LCBvciBbYW55IG9mIHRoZSBtb3JlIGFkdmFuY2VkIG9wdGlvbnNdKGh0dHBzOi8vd3d3Lm1vbmdvZGIuY29tL2RvY3MvbWFudWFsL3JlZmVyZW5jZS93cml0ZS1jb25jZXJuLyN3LW9wdGlvbikuXG4gKiBAc2VlIG1vbmdvZGIgaHR0cHM6Ly93d3cubW9uZ29kYi5jb20vZG9jcy9tYW51YWwvcmVmZXJlbmNlL3dyaXRlLWNvbmNlcm4vI3ctb3B0aW9uXG4gKiBAcmV0dXJuIHtRdWVyeX0gdGhpc1xuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5RdWVyeS5wcm90b3R5cGUudyA9IGZ1bmN0aW9uIHcodmFsKSB7XG4gIGlmICh2YWwgPT0gbnVsbCkge1xuICAgIGRlbGV0ZSB0aGlzLm9wdGlvbnMudztcbiAgfVxuICBpZiAodGhpcy5vcHRpb25zLndyaXRlQ29uY2VybiAhPSBudWxsKSB7XG4gICAgdGhpcy5vcHRpb25zLndyaXRlQ29uY2Vybi53ID0gdmFsO1xuICB9IGVsc2Uge1xuICAgIHRoaXMub3B0aW9ucy53ID0gdmFsO1xuICB9XG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBSZXF1ZXN0cyBhY2tub3dsZWRnZW1lbnQgdGhhdCB0aGlzIG9wZXJhdGlvbiBoYXMgYmVlbiBwZXJzaXN0ZWQgdG8gTW9uZ29EQidzXG4gKiBvbi1kaXNrIGpvdXJuYWwuXG4gKiBUaGlzIG9wdGlvbiBpcyBvbmx5IHZhbGlkIGZvciBvcGVyYXRpb25zIHRoYXQgd3JpdGUgdG8gdGhlIGRhdGFiYXNlOlxuICpcbiAqIC0gYGRlbGV0ZU9uZSgpYFxuICogLSBgZGVsZXRlTWFueSgpYFxuICogLSBgZmluZE9uZUFuZERlbGV0ZSgpYFxuICogLSBgZmluZE9uZUFuZFJlcGxhY2UoKWBcbiAqIC0gYGZpbmRPbmVBbmRVcGRhdGUoKWBcbiAqIC0gYHVwZGF0ZU9uZSgpYFxuICogLSBgdXBkYXRlTWFueSgpYFxuICpcbiAqIERlZmF1bHRzIHRvIHRoZSBzY2hlbWEncyBbYHdyaXRlQ29uY2Vybi5qYCBvcHRpb25dKGh0dHBzOi8vbW9uZ29vc2Vqcy5jb20vZG9jcy9ndWlkZS5odG1sI3dyaXRlQ29uY2VybilcbiAqXG4gKiAjIyMjIEV4YW1wbGU6XG4gKlxuICogICAgIGF3YWl0IG1vbmdvb3NlLm1vZGVsKCdQZXJzb24nKS5kZWxldGVPbmUoeyBuYW1lOiAnTmVkIFN0YXJrJyB9KS5qKHRydWUpO1xuICpcbiAqIEBtZXRob2QgalxuICogQG1lbWJlck9mIFF1ZXJ5XG4gKiBAaW5zdGFuY2VcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gdmFsXG4gKiBAc2VlIG1vbmdvZGIgaHR0cHM6Ly93d3cubW9uZ29kYi5jb20vZG9jcy9tYW51YWwvcmVmZXJlbmNlL3dyaXRlLWNvbmNlcm4vI2otb3B0aW9uXG4gKiBAcmV0dXJuIHtRdWVyeX0gdGhpc1xuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5RdWVyeS5wcm90b3R5cGUuaiA9IGZ1bmN0aW9uIGoodmFsKSB7XG4gIGlmICh2YWwgPT0gbnVsbCkge1xuICAgIGRlbGV0ZSB0aGlzLm9wdGlvbnMuajtcbiAgfVxuICBpZiAodGhpcy5vcHRpb25zLndyaXRlQ29uY2VybiAhPSBudWxsKSB7XG4gICAgdGhpcy5vcHRpb25zLndyaXRlQ29uY2Vybi5qID0gdmFsO1xuICB9IGVsc2Uge1xuICAgIHRoaXMub3B0aW9ucy5qID0gdmFsO1xuICB9XG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBJZiBbYHcgPiAxYF0oaHR0cHM6Ly9tb25nb29zZWpzLmNvbS9kb2NzL2FwaS9xdWVyeS5odG1sI1F1ZXJ5LnByb3RvdHlwZS53KCkpLCB0aGUgbWF4aW11bSBhbW91bnQgb2YgdGltZSB0b1xuICogd2FpdCBmb3IgdGhpcyB3cml0ZSB0byBwcm9wYWdhdGUgdGhyb3VnaCB0aGUgcmVwbGljYSBzZXQgYmVmb3JlIHRoaXNcbiAqIG9wZXJhdGlvbiBmYWlscy4gVGhlIGRlZmF1bHQgaXMgYDBgLCB3aGljaCBtZWFucyBubyB0aW1lb3V0LlxuICpcbiAqIFRoaXMgb3B0aW9uIGlzIG9ubHkgdmFsaWQgZm9yIG9wZXJhdGlvbnMgdGhhdCB3cml0ZSB0byB0aGUgZGF0YWJhc2U6XG4gKlxuICogLSBgZGVsZXRlT25lKClgXG4gKiAtIGBkZWxldGVNYW55KClgXG4gKiAtIGBmaW5kT25lQW5kRGVsZXRlKClgXG4gKiAtIGBmaW5kT25lQW5kUmVwbGFjZSgpYFxuICogLSBgZmluZE9uZUFuZFVwZGF0ZSgpYFxuICogLSBgdXBkYXRlT25lKClgXG4gKiAtIGB1cGRhdGVNYW55KClgXG4gKlxuICogRGVmYXVsdHMgdG8gdGhlIHNjaGVtYSdzIFtgd3JpdGVDb25jZXJuLnd0aW1lb3V0YCBvcHRpb25dKGh0dHBzOi8vbW9uZ29vc2Vqcy5jb20vZG9jcy9ndWlkZS5odG1sI3dyaXRlQ29uY2VybilcbiAqXG4gKiAjIyMjIEV4YW1wbGU6XG4gKlxuICogICAgIC8vIFRoZSBgZGVsZXRlT25lKClgIHByb21pc2Ugd29uJ3QgcmVzb2x2ZSB1bnRpbCB0aGlzIGBkZWxldGVPbmUoKWAgaGFzXG4gKiAgICAgLy8gcHJvcGFnYXRlZCB0byBhdCBsZWFzdCBgdyA9IDJgIG1lbWJlcnMgb2YgdGhlIHJlcGxpY2Egc2V0LiBJZiBpdCB0YWtlc1xuICogICAgIC8vIGxvbmdlciB0aGFuIDEgc2Vjb25kLCB0aGlzIGBkZWxldGVPbmUoKWAgd2lsbCBmYWlsLlxuICogICAgIGF3YWl0IG1vbmdvb3NlLm1vZGVsKCdQZXJzb24nKS5cbiAqICAgICAgIGRlbGV0ZU9uZSh7IG5hbWU6ICdOZWQgU3RhcmsnIH0pLlxuICogICAgICAgdygyKS5cbiAqICAgICAgIHd0aW1lb3V0KDEwMDApO1xuICpcbiAqIEBtZXRob2Qgd3RpbWVvdXRcbiAqIEBtZW1iZXJPZiBRdWVyeVxuICogQGluc3RhbmNlXG4gKiBAcGFyYW0ge251bWJlcn0gbXMgbnVtYmVyIG9mIG1pbGxpc2Vjb25kcyB0byB3YWl0XG4gKiBAc2VlIG1vbmdvZGIgaHR0cHM6Ly93d3cubW9uZ29kYi5jb20vZG9jcy9tYW51YWwvcmVmZXJlbmNlL3dyaXRlLWNvbmNlcm4vI3d0aW1lb3V0XG4gKiBAcmV0dXJuIHtRdWVyeX0gdGhpc1xuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5RdWVyeS5wcm90b3R5cGUud3RpbWVvdXQgPSBmdW5jdGlvbiB3dGltZW91dChtcykge1xuICBpZiAobXMgPT0gbnVsbCkge1xuICAgIGRlbGV0ZSB0aGlzLm9wdGlvbnMud3RpbWVvdXQ7XG4gIH1cbiAgaWYgKHRoaXMub3B0aW9ucy53cml0ZUNvbmNlcm4gIT0gbnVsbCkge1xuICAgIHRoaXMub3B0aW9ucy53cml0ZUNvbmNlcm4ud3RpbWVvdXQgPSBtcztcbiAgfSBlbHNlIHtcbiAgICB0aGlzLm9wdGlvbnMud3RpbWVvdXQgPSBtcztcbiAgfVxuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogU2V0cyB0aGUgcmVhZENvbmNlcm4gb3B0aW9uIGZvciB0aGUgcXVlcnkuXG4gKlxuICogIyMjIyBFeGFtcGxlOlxuICpcbiAqICAgICBuZXcgUXVlcnkoKS5yZWFkQ29uY2VybignbG9jYWwnKVxuICogICAgIG5ldyBRdWVyeSgpLnJlYWRDb25jZXJuKCdsJykgIC8vIHNhbWUgYXMgbG9jYWxcbiAqXG4gKiAgICAgbmV3IFF1ZXJ5KCkucmVhZENvbmNlcm4oJ2F2YWlsYWJsZScpXG4gKiAgICAgbmV3IFF1ZXJ5KCkucmVhZENvbmNlcm4oJ2EnKSAgLy8gc2FtZSBhcyBhdmFpbGFibGVcbiAqXG4gKiAgICAgbmV3IFF1ZXJ5KCkucmVhZENvbmNlcm4oJ21ham9yaXR5JylcbiAqICAgICBuZXcgUXVlcnkoKS5yZWFkQ29uY2VybignbScpICAvLyBzYW1lIGFzIG1ham9yaXR5XG4gKlxuICogICAgIG5ldyBRdWVyeSgpLnJlYWRDb25jZXJuKCdsaW5lYXJpemFibGUnKVxuICogICAgIG5ldyBRdWVyeSgpLnJlYWRDb25jZXJuKCdseicpIC8vIHNhbWUgYXMgbGluZWFyaXphYmxlXG4gKlxuICogICAgIG5ldyBRdWVyeSgpLnJlYWRDb25jZXJuKCdzbmFwc2hvdCcpXG4gKiAgICAgbmV3IFF1ZXJ5KCkucmVhZENvbmNlcm4oJ3MnKSAgLy8gc2FtZSBhcyBzbmFwc2hvdFxuICpcbiAqXG4gKiAjIyMjIFJlYWQgQ29uY2VybiBMZXZlbDpcbiAqXG4gKiBgYGBcbiAqIGxvY2FsICAgICAgICAgTW9uZ29EQiAzLjIrIFRoZSBxdWVyeSByZXR1cm5zIGZyb20gdGhlIGluc3RhbmNlIHdpdGggbm8gZ3VhcmFudGVlIGd1YXJhbnRlZSB0aGF0IHRoZSBkYXRhIGhhcyBiZWVuIHdyaXR0ZW4gdG8gYSBtYWpvcml0eSBvZiB0aGUgcmVwbGljYSBzZXQgbWVtYmVycyAoaS5lLiBtYXkgYmUgcm9sbGVkIGJhY2spLlxuICogYXZhaWxhYmxlICAgICBNb25nb0RCIDMuNisgVGhlIHF1ZXJ5IHJldHVybnMgZnJvbSB0aGUgaW5zdGFuY2Ugd2l0aCBubyBndWFyYW50ZWUgZ3VhcmFudGVlIHRoYXQgdGhlIGRhdGEgaGFzIGJlZW4gd3JpdHRlbiB0byBhIG1ham9yaXR5IG9mIHRoZSByZXBsaWNhIHNldCBtZW1iZXJzIChpLmUuIG1heSBiZSByb2xsZWQgYmFjaykuXG4gKiBtYWpvcml0eSAgICAgIE1vbmdvREIgMy4yKyBUaGUgcXVlcnkgcmV0dXJucyB0aGUgZGF0YSB0aGF0IGhhcyBiZWVuIGFja25vd2xlZGdlZCBieSBhIG1ham9yaXR5IG9mIHRoZSByZXBsaWNhIHNldCBtZW1iZXJzLiBUaGUgZG9jdW1lbnRzIHJldHVybmVkIGJ5IHRoZSByZWFkIG9wZXJhdGlvbiBhcmUgZHVyYWJsZSwgZXZlbiBpbiB0aGUgZXZlbnQgb2YgZmFpbHVyZS5cbiAqIGxpbmVhcml6YWJsZSAgTW9uZ29EQiAzLjQrIFRoZSBxdWVyeSByZXR1cm5zIGRhdGEgdGhhdCByZWZsZWN0cyBhbGwgc3VjY2Vzc2Z1bCBtYWpvcml0eS1hY2tub3dsZWRnZWQgd3JpdGVzIHRoYXQgY29tcGxldGVkIHByaW9yIHRvIHRoZSBzdGFydCBvZiB0aGUgcmVhZCBvcGVyYXRpb24uIFRoZSBxdWVyeSBtYXkgd2FpdCBmb3IgY29uY3VycmVudGx5IGV4ZWN1dGluZyB3cml0ZXMgdG8gcHJvcGFnYXRlIHRvIGEgbWFqb3JpdHkgb2YgcmVwbGljYSBzZXQgbWVtYmVycyBiZWZvcmUgcmV0dXJuaW5nIHJlc3VsdHMuXG4gKiBzbmFwc2hvdCAgICAgIE1vbmdvREIgNC4wKyBPbmx5IGF2YWlsYWJsZSBmb3Igb3BlcmF0aW9ucyB3aXRoaW4gbXVsdGktZG9jdW1lbnQgdHJhbnNhY3Rpb25zLiBVcG9uIHRyYW5zYWN0aW9uIGNvbW1pdCB3aXRoIHdyaXRlIGNvbmNlcm4gXCJtYWpvcml0eVwiLCB0aGUgdHJhbnNhY3Rpb24gb3BlcmF0aW9ucyBhcmUgZ3VhcmFudGVlZCB0byBoYXZlIHJlYWQgZnJvbSBhIHNuYXBzaG90IG9mIG1ham9yaXR5LWNvbW1pdHRlZCBkYXRhLlxuICogYGBgXG4gKlxuICogQWxpYXNlc1xuICpcbiAqIGBgYFxuICogbCAgIGxvY2FsXG4gKiBhICAgYXZhaWxhYmxlXG4gKiBtICAgbWFqb3JpdHlcbiAqIGx6ICBsaW5lYXJpemFibGVcbiAqIHMgICBzbmFwc2hvdFxuICogYGBgXG4gKlxuICogUmVhZCBtb3JlIGFib3V0IGhvdyB0byB1c2UgcmVhZCBjb25jZXJuIFtoZXJlXShodHRwczovL3d3dy5tb25nb2RiLmNvbS9kb2NzL21hbnVhbC9yZWZlcmVuY2UvcmVhZC1jb25jZXJuLykuXG4gKlxuICogQG1lbWJlck9mIFF1ZXJ5XG4gKiBAbWV0aG9kIHJlYWRDb25jZXJuXG4gKiBAcGFyYW0ge1N0cmluZ30gbGV2ZWwgb25lIG9mIHRoZSBsaXN0ZWQgcmVhZCBjb25jZXJuIGxldmVsIG9yIHRoZWlyIGFsaWFzZXNcbiAqIEBzZWUgbW9uZ29kYiBodHRwczovL3d3dy5tb25nb2RiLmNvbS9kb2NzL21hbnVhbC9yZWZlcmVuY2UvcmVhZC1jb25jZXJuL1xuICogQHJldHVybiB7UXVlcnl9IHRoaXNcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuLyoqXG4gKiBHZXRzIHF1ZXJ5IG9wdGlvbnMuXG4gKlxuICogIyMjIyBFeGFtcGxlOlxuICpcbiAqICAgICBjb25zdCBxdWVyeSA9IG5ldyBRdWVyeSgpO1xuICogICAgIHF1ZXJ5LmxpbWl0KDEwKTtcbiAqICAgICBxdWVyeS5zZXRPcHRpb25zKHsgbWF4VGltZU1TOiAxMDAwIH0pO1xuICogICAgIHF1ZXJ5LmdldE9wdGlvbnMoKTsgLy8geyBsaW1pdDogMTAsIG1heFRpbWVNUzogMTAwMCB9XG4gKlxuICogQHJldHVybiB7T2JqZWN0fSB0aGUgb3B0aW9uc1xuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5RdWVyeS5wcm90b3R5cGUuZ2V0T3B0aW9ucyA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gdGhpcy5vcHRpb25zO1xufTtcblxuLyoqXG4gKiBTZXRzIHF1ZXJ5IG9wdGlvbnMuIFNvbWUgb3B0aW9ucyBvbmx5IG1ha2Ugc2Vuc2UgZm9yIGNlcnRhaW4gb3BlcmF0aW9ucy5cbiAqXG4gKiAjIyMjIE9wdGlvbnM6XG4gKlxuICogVGhlIGZvbGxvd2luZyBvcHRpb25zIGFyZSBvbmx5IGZvciBgZmluZCgpYDpcbiAqXG4gKiAtIFt0YWlsYWJsZV0oaHR0cHM6Ly93d3cubW9uZ29kYi5jb20vZG9jcy9tYW51YWwvY29yZS90YWlsYWJsZS1jdXJzb3JzLylcbiAqIC0gW2xpbWl0XShodHRwczovL3d3dy5tb25nb2RiLmNvbS9kb2NzL21hbnVhbC9yZWZlcmVuY2UvbWV0aG9kL2N1cnNvci5saW1pdC8pXG4gKiAtIFtza2lwXShodHRwczovL3d3dy5tb25nb2RiLmNvbS9kb2NzL21hbnVhbC9yZWZlcmVuY2UvbWV0aG9kL2N1cnNvci5za2lwLylcbiAqIC0gW2FsbG93RGlza1VzZV0oaHR0cHM6Ly93d3cubW9uZ29kYi5jb20vZG9jcy9tYW51YWwvcmVmZXJlbmNlL21ldGhvZC9jdXJzb3IuYWxsb3dEaXNrVXNlLylcbiAqIC0gW2JhdGNoU2l6ZV0oaHR0cHM6Ly93d3cubW9uZ29kYi5jb20vZG9jcy9tYW51YWwvcmVmZXJlbmNlL21ldGhvZC9jdXJzb3IuYmF0Y2hTaXplLylcbiAqIC0gW3JlYWRQcmVmZXJlbmNlXShodHRwczovL3d3dy5tb25nb2RiLmNvbS9kb2NzL21hbnVhbC9hcHBsaWNhdGlvbnMvcmVwbGljYXRpb24vI3JlYWQtcHJlZmVyZW5jZSlcbiAqIC0gW2hpbnRdKGh0dHBzOi8vd3d3Lm1vbmdvZGIuY29tL2RvY3MvbWFudWFsL3JlZmVyZW5jZS9tZXRob2QvY3Vyc29yLmhpbnQvKVxuICogLSBbY29tbWVudF0oaHR0cHM6Ly93d3cubW9uZ29kYi5jb20vZG9jcy9tYW51YWwvcmVmZXJlbmNlL21ldGhvZC9jdXJzb3IuY29tbWVudC8pXG4gKlxuICogVGhlIGZvbGxvd2luZyBvcHRpb25zIGFyZSBvbmx5IGZvciB3cml0ZSBvcGVyYXRpb25zOiBgdXBkYXRlT25lKClgLCBgdXBkYXRlTWFueSgpYCwgYHJlcGxhY2VPbmUoKWAsIGBmaW5kT25lQW5kVXBkYXRlKClgLCBhbmQgYGZpbmRCeUlkQW5kVXBkYXRlKClgOlxuICpcbiAqIC0gW3Vwc2VydF0oaHR0cHM6Ly93d3cubW9uZ29kYi5jb20vZG9jcy9tYW51YWwvcmVmZXJlbmNlL21ldGhvZC9kYi5jb2xsZWN0aW9uLnVwZGF0ZS8pXG4gKiAtIFt3cml0ZUNvbmNlcm5dKGh0dHBzOi8vd3d3Lm1vbmdvZGIuY29tL2RvY3MvbWFudWFsL3JlZmVyZW5jZS9tZXRob2QvZGIuY29sbGVjdGlvbi51cGRhdGUvKVxuICogLSBbdGltZXN0YW1wc10oaHR0cHM6Ly9tb25nb29zZWpzLmNvbS9kb2NzL2d1aWRlLmh0bWwjdGltZXN0YW1wcyk6IElmIGB0aW1lc3RhbXBzYCBpcyBzZXQgaW4gdGhlIHNjaGVtYSwgc2V0IHRoaXMgb3B0aW9uIHRvIGBmYWxzZWAgdG8gc2tpcCB0aW1lc3RhbXBzIGZvciB0aGF0IHBhcnRpY3VsYXIgdXBkYXRlLiBIYXMgbm8gZWZmZWN0IGlmIGB0aW1lc3RhbXBzYCBpcyBub3QgZW5hYmxlZCBpbiB0aGUgc2NoZW1hIG9wdGlvbnMuXG4gKiAtIG92ZXJ3cml0ZURpc2NyaW1pbmF0b3JLZXk6IGFsbG93IHNldHRpbmcgdGhlIGRpc2NyaW1pbmF0b3Iga2V5IGluIHRoZSB1cGRhdGUuIFdpbGwgdXNlIHRoZSBjb3JyZWN0IGRpc2NyaW1pbmF0b3Igc2NoZW1hIGlmIHRoZSB1cGRhdGUgY2hhbmdlcyB0aGUgZGlzY3JpbWluYXRvciBrZXkuXG4gKlxuICogVGhlIGZvbGxvd2luZyBvcHRpb25zIGFyZSBvbmx5IGZvciBgZmluZCgpYCwgYGZpbmRPbmUoKWAsIGBmaW5kQnlJZCgpYCwgYGZpbmRPbmVBbmRVcGRhdGUoKWAsIGBmaW5kT25lQW5kUmVwbGFjZSgpYCwgYGZpbmRPbmVBbmREZWxldGUoKWAsIGFuZCBgZmluZEJ5SWRBbmRVcGRhdGUoKWA6XG4gKlxuICogLSBbbGVhbl0oaHR0cHM6Ly9tb25nb29zZWpzLmNvbS9kb2NzL2FwaS9xdWVyeS5odG1sI1F1ZXJ5LnByb3RvdHlwZS5sZWFuKCkpXG4gKiAtIFtwb3B1bGF0ZV0oaHR0cHM6Ly9tb25nb29zZWpzLmNvbS9kb2NzL3BvcHVsYXRlLmh0bWwpXG4gKiAtIFtwcm9qZWN0aW9uXShodHRwczovL21vbmdvb3NlanMuY29tL2RvY3MvYXBpL3F1ZXJ5Lmh0bWwjUXVlcnkucHJvdG90eXBlLnByb2plY3Rpb24oKSlcbiAqIC0gc2FuaXRpemVQcm9qZWN0aW9uXG4gKiAtIHVzZUJpZ0ludDY0XG4gKlxuICogVGhlIGZvbGxvd2luZyBvcHRpb25zIGFyZSBvbmx5IGZvciBhbGwgb3BlcmF0aW9ucyAqKmV4Y2VwdCoqIGB1cGRhdGVPbmUoKWAsIGB1cGRhdGVNYW55KClgLCBgZGVsZXRlT25lKClgLCBhbmQgYGRlbGV0ZU1hbnkoKWA6XG4gKlxuICogLSBbbWF4VGltZU1TXShodHRwczovL3d3dy5tb25nb2RiLmNvbS9kb2NzL21hbnVhbC9yZWZlcmVuY2Uvb3BlcmF0b3IvbWV0YS9tYXhUaW1lTVMvKVxuICpcbiAqIFRoZSBmb2xsb3dpbmcgb3B0aW9ucyBhcmUgZm9yIGBmaW5kKClgLCBgZmluZE9uZSgpYCwgYGZpbmRPbmVBbmRVcGRhdGUoKWAsIGBmaW5kT25lQW5kRGVsZXRlKClgLCBgdXBkYXRlT25lKClgLCBhbmQgYGRlbGV0ZU9uZSgpYDpcbiAqXG4gKiAtIFtzb3J0XShodHRwczovL3d3dy5tb25nb2RiLmNvbS9kb2NzL21hbnVhbC9yZWZlcmVuY2UvbWV0aG9kL2N1cnNvci5zb3J0LylcbiAqXG4gKiBUaGUgZm9sbG93aW5nIG9wdGlvbnMgYXJlIGZvciBgZmluZE9uZUFuZFVwZGF0ZSgpYCBhbmQgYGZpbmRPbmVBbmREZWxldGUoKWBcbiAqXG4gKiAtIGluY2x1ZGVSZXN1bHRNZXRhZGF0YVxuICpcbiAqIFRoZSBmb2xsb3dpbmcgb3B0aW9ucyBhcmUgZm9yIGFsbCBvcGVyYXRpb25zOlxuICpcbiAqIC0gW3N0cmljdF0oaHR0cHM6Ly9tb25nb29zZWpzLmNvbS9kb2NzL2d1aWRlLmh0bWwjc3RyaWN0KVxuICogLSBbY29sbGF0aW9uXShodHRwczovL3d3dy5tb25nb2RiLmNvbS9kb2NzL21hbnVhbC9yZWZlcmVuY2UvY29sbGF0aW9uLylcbiAqIC0gW3Nlc3Npb25dKGh0dHBzOi8vd3d3Lm1vbmdvZGIuY29tL2RvY3MvbWFudWFsL3JlZmVyZW5jZS9zZXJ2ZXItc2Vzc2lvbnMvKVxuICogLSBbZXhwbGFpbl0oaHR0cHM6Ly93d3cubW9uZ29kYi5jb20vZG9jcy9tYW51YWwvcmVmZXJlbmNlL21ldGhvZC9jdXJzb3IuZXhwbGFpbi8pXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcbiAqIEByZXR1cm4ge1F1ZXJ5fSB0aGlzXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cblF1ZXJ5LnByb3RvdHlwZS5zZXRPcHRpb25zID0gZnVuY3Rpb24ob3B0aW9ucywgb3ZlcndyaXRlKSB7XG4gIC8vIG92ZXJ3cml0ZSBpcyBvbmx5IGZvciBpbnRlcm5hbCB1c2VcbiAgaWYgKG92ZXJ3cml0ZSkge1xuICAgIC8vIGVuc3VyZSB0aGF0IF9tb25nb29zZU9wdGlvbnMgJiBvcHRpb25zIGFyZSB0d28gZGlmZmVyZW50IG9iamVjdHNcbiAgICB0aGlzLl9tb25nb29zZU9wdGlvbnMgPSAob3B0aW9ucyAmJiBjbG9uZShvcHRpb25zKSkgfHwge307XG4gICAgdGhpcy5vcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcblxuICAgIGlmICgncG9wdWxhdGUnIGluIG9wdGlvbnMpIHtcbiAgICAgIHRoaXMucG9wdWxhdGUodGhpcy5fbW9uZ29vc2VPcHRpb25zKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgaWYgKG9wdGlvbnMgPT0gbnVsbCkge1xuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIGlmICh0eXBlb2Ygb3B0aW9ucyAhPT0gJ29iamVjdCcpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ09wdGlvbnMgbXVzdCBiZSBhbiBvYmplY3QsIGdvdCBcIicgKyBvcHRpb25zICsgJ1wiJyk7XG4gIH1cblxuICBvcHRpb25zID0gT2JqZWN0LmFzc2lnbih7fSwgb3B0aW9ucyk7XG5cbiAgaWYgKEFycmF5LmlzQXJyYXkob3B0aW9ucy5wb3B1bGF0ZSkpIHtcbiAgICBjb25zdCBwb3B1bGF0ZSA9IG9wdGlvbnMucG9wdWxhdGU7XG4gICAgZGVsZXRlIG9wdGlvbnMucG9wdWxhdGU7XG4gICAgY29uc3QgX251bVBvcHVsYXRlID0gcG9wdWxhdGUubGVuZ3RoO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgX251bVBvcHVsYXRlOyArK2kpIHtcbiAgICAgIHRoaXMucG9wdWxhdGUocG9wdWxhdGVbaV0pO1xuICAgIH1cbiAgfVxuXG4gIGlmICgnc2V0RGVmYXVsdHNPbkluc2VydCcgaW4gb3B0aW9ucykge1xuICAgIHRoaXMuX21vbmdvb3NlT3B0aW9ucy5zZXREZWZhdWx0c09uSW5zZXJ0ID0gb3B0aW9ucy5zZXREZWZhdWx0c09uSW5zZXJ0O1xuICAgIGRlbGV0ZSBvcHRpb25zLnNldERlZmF1bHRzT25JbnNlcnQ7XG4gIH1cbiAgaWYgKCdvdmVyd3JpdGVEaXNjcmltaW5hdG9yS2V5JyBpbiBvcHRpb25zKSB7XG4gICAgdGhpcy5fbW9uZ29vc2VPcHRpb25zLm92ZXJ3cml0ZURpc2NyaW1pbmF0b3JLZXkgPSBvcHRpb25zLm92ZXJ3cml0ZURpc2NyaW1pbmF0b3JLZXk7XG4gICAgZGVsZXRlIG9wdGlvbnMub3ZlcndyaXRlRGlzY3JpbWluYXRvcktleTtcbiAgfVxuICBpZiAoJ3Nhbml0aXplUHJvamVjdGlvbicgaW4gb3B0aW9ucykge1xuICAgIGlmIChvcHRpb25zLnNhbml0aXplUHJvamVjdGlvbiAmJiAhdGhpcy5fbW9uZ29vc2VPcHRpb25zLnNhbml0aXplUHJvamVjdGlvbikge1xuICAgICAgc2FuaXRpemVQcm9qZWN0aW9uKHRoaXMuX2ZpZWxkcyk7XG4gICAgfVxuXG4gICAgdGhpcy5fbW9uZ29vc2VPcHRpb25zLnNhbml0aXplUHJvamVjdGlvbiA9IG9wdGlvbnMuc2FuaXRpemVQcm9qZWN0aW9uO1xuICAgIGRlbGV0ZSBvcHRpb25zLnNhbml0aXplUHJvamVjdGlvbjtcbiAgfVxuICBpZiAoJ3Nhbml0aXplRmlsdGVyJyBpbiBvcHRpb25zKSB7XG4gICAgdGhpcy5fbW9uZ29vc2VPcHRpb25zLnNhbml0aXplRmlsdGVyID0gb3B0aW9ucy5zYW5pdGl6ZUZpbHRlcjtcbiAgICBkZWxldGUgb3B0aW9ucy5zYW5pdGl6ZUZpbHRlcjtcbiAgfVxuICBpZiAoJ3RpbWVzdGFtcHMnIGluIG9wdGlvbnMpIHtcbiAgICB0aGlzLl9tb25nb29zZU9wdGlvbnMudGltZXN0YW1wcyA9IG9wdGlvbnMudGltZXN0YW1wcztcbiAgICBkZWxldGUgb3B0aW9ucy50aW1lc3RhbXBzO1xuICB9XG4gIGlmICgnZGVmYXVsdHMnIGluIG9wdGlvbnMpIHtcbiAgICB0aGlzLl9tb25nb29zZU9wdGlvbnMuZGVmYXVsdHMgPSBvcHRpb25zLmRlZmF1bHRzO1xuICAgIC8vIGRlbGV0aW5nIG9wdGlvbnMuZGVmYXVsdHMgd2lsbCBjYXVzZSA3Mjg3IHRvIGZhaWxcbiAgfVxuICBpZiAoJ3RyYW5zbGF0ZUFsaWFzZXMnIGluIG9wdGlvbnMpIHtcbiAgICB0aGlzLl9tb25nb29zZU9wdGlvbnMudHJhbnNsYXRlQWxpYXNlcyA9IG9wdGlvbnMudHJhbnNsYXRlQWxpYXNlcztcbiAgICBkZWxldGUgb3B0aW9ucy50cmFuc2xhdGVBbGlhc2VzO1xuICB9XG5cbiAgaWYgKG9wdGlvbnMubGVhbiA9PSBudWxsICYmIHRoaXMuc2NoZW1hICYmICdsZWFuJyBpbiB0aGlzLnNjaGVtYS5vcHRpb25zKSB7XG4gICAgdGhpcy5fbW9uZ29vc2VPcHRpb25zLmxlYW4gPSB0aGlzLnNjaGVtYS5vcHRpb25zLmxlYW47XG4gIH1cblxuICBpZiAodHlwZW9mIG9wdGlvbnMubGltaXQgPT09ICdzdHJpbmcnKSB7XG4gICAgdHJ5IHtcbiAgICAgIG9wdGlvbnMubGltaXQgPSBjYXN0TnVtYmVyKG9wdGlvbnMubGltaXQpO1xuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgdGhyb3cgbmV3IENhc3RFcnJvcignTnVtYmVyJywgb3B0aW9ucy5saW1pdCwgJ2xpbWl0Jyk7XG4gICAgfVxuICB9XG4gIGlmICh0eXBlb2Ygb3B0aW9ucy5za2lwID09PSAnc3RyaW5nJykge1xuICAgIHRyeSB7XG4gICAgICBvcHRpb25zLnNraXAgPSBjYXN0TnVtYmVyKG9wdGlvbnMuc2tpcCk7XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICB0aHJvdyBuZXcgQ2FzdEVycm9yKCdOdW1iZXInLCBvcHRpb25zLnNraXAsICdza2lwJyk7XG4gICAgfVxuICB9XG5cbiAgLy8gc2V0IGFyYml0cmFyeSBvcHRpb25zXG4gIGZvciAoY29uc3Qga2V5IG9mIE9iamVjdC5rZXlzKG9wdGlvbnMpKSB7XG4gICAgaWYgKHF1ZXJ5T3B0aW9uTWV0aG9kcy5oYXMoa2V5KSkge1xuICAgICAgY29uc3QgYXJncyA9IEFycmF5LmlzQXJyYXkob3B0aW9uc1trZXldKSA/XG4gICAgICAgIG9wdGlvbnNba2V5XSA6XG4gICAgICAgIFtvcHRpb25zW2tleV1dO1xuICAgICAgdGhpc1trZXldLmFwcGx5KHRoaXMsIGFyZ3MpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLm9wdGlvbnNba2V5XSA9IG9wdGlvbnNba2V5XTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogU2V0cyB0aGUgW2BleHBsYWluYCBvcHRpb25dKGh0dHBzOi8vd3d3Lm1vbmdvZGIuY29tL2RvY3MvbWFudWFsL3JlZmVyZW5jZS9tZXRob2QvY3Vyc29yLmV4cGxhaW4vKSxcbiAqIHdoaWNoIG1ha2VzIHRoaXMgcXVlcnkgcmV0dXJuIGRldGFpbGVkIGV4ZWN1dGlvbiBzdGF0cyBpbnN0ZWFkIG9mIHRoZSBhY3R1YWxcbiAqIHF1ZXJ5IHJlc3VsdC4gVGhpcyBtZXRob2QgaXMgdXNlZnVsIGZvciBkZXRlcm1pbmluZyB3aGF0IGluZGV4IHlvdXIgcXVlcmllc1xuICogdXNlLlxuICpcbiAqIENhbGxpbmcgYHF1ZXJ5LmV4cGxhaW4odilgIGlzIGVxdWl2YWxlbnQgdG8gYHF1ZXJ5LnNldE9wdGlvbnMoeyBleHBsYWluOiB2IH0pYFxuICpcbiAqICMjIyMgRXhhbXBsZTpcbiAqXG4gKiAgICAgY29uc3QgcXVlcnkgPSBuZXcgUXVlcnkoKTtcbiAqICAgICBjb25zdCByZXMgPSBhd2FpdCBxdWVyeS5maW5kKHsgYTogMSB9KS5leHBsYWluKCdxdWVyeVBsYW5uZXInKTtcbiAqICAgICBjb25zb2xlLmxvZyhyZXMpO1xuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBbdmVyYm9zZV0gVGhlIHZlcmJvc2l0eSBtb2RlLiBFaXRoZXIgJ3F1ZXJ5UGxhbm5lcicsICdleGVjdXRpb25TdGF0cycsIG9yICdhbGxQbGFuc0V4ZWN1dGlvbicuIFRoZSBkZWZhdWx0IGlzICdxdWVyeVBsYW5uZXInXG4gKiBAcmV0dXJuIHtRdWVyeX0gdGhpc1xuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5RdWVyeS5wcm90b3R5cGUuZXhwbGFpbiA9IGZ1bmN0aW9uIGV4cGxhaW4odmVyYm9zZSkge1xuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMCkge1xuICAgIHRoaXMub3B0aW9ucy5leHBsYWluID0gdHJ1ZTtcbiAgfSBlbHNlIGlmICh2ZXJib3NlID09PSBmYWxzZSkge1xuICAgIGRlbGV0ZSB0aGlzLm9wdGlvbnMuZXhwbGFpbjtcbiAgfSBlbHNlIHtcbiAgICB0aGlzLm9wdGlvbnMuZXhwbGFpbiA9IHZlcmJvc2U7XG4gIH1cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIFNldHMgdGhlIFtgYWxsb3dEaXNrVXNlYCBvcHRpb25dKGh0dHBzOi8vd3d3Lm1vbmdvZGIuY29tL2RvY3MvbWFudWFsL3JlZmVyZW5jZS9tZXRob2QvY3Vyc29yLmFsbG93RGlza1VzZS8pLFxuICogd2hpY2ggYWxsb3dzIHRoZSBNb25nb0RCIHNlcnZlciB0byB1c2UgbW9yZSB0aGFuIDEwMCBNQiBmb3IgdGhpcyBxdWVyeSdzIGBzb3J0KClgLiBUaGlzIG9wdGlvbiBjYW5cbiAqIGxldCB5b3Ugd29yayBhcm91bmQgYFF1ZXJ5RXhjZWVkZWRNZW1vcnlMaW1pdE5vRGlza1VzZUFsbG93ZWRgIGVycm9ycyBmcm9tIHRoZSBNb25nb0RCIHNlcnZlci5cbiAqXG4gKiBOb3RlIHRoYXQgdGhpcyBvcHRpb24gcmVxdWlyZXMgTW9uZ29EQiBzZXJ2ZXIgPj0gNC40LiBTZXR0aW5nIHRoaXMgb3B0aW9uIGlzIGEgbm8tb3AgZm9yIE1vbmdvREIgNC4yXG4gKiBhbmQgZWFybGllci5cbiAqXG4gKiBDYWxsaW5nIGBxdWVyeS5hbGxvd0Rpc2tVc2UodilgIGlzIGVxdWl2YWxlbnQgdG8gYHF1ZXJ5LnNldE9wdGlvbnMoeyBhbGxvd0Rpc2tVc2U6IHYgfSlgXG4gKlxuICogIyMjIyBFeGFtcGxlOlxuICpcbiAqICAgICBhd2FpdCBxdWVyeS5maW5kKCkuc29ydCh7IG5hbWU6IDEgfSkuYWxsb3dEaXNrVXNlKHRydWUpO1xuICogICAgIC8vIEVxdWl2YWxlbnQ6XG4gKiAgICAgYXdhaXQgcXVlcnkuZmluZCgpLnNvcnQoeyBuYW1lOiAxIH0pLmFsbG93RGlza1VzZSgpO1xuICpcbiAqIEBwYXJhbSB7Qm9vbGVhbn0gW3ZdIEVuYWJsZS9kaXNhYmxlIGBhbGxvd0Rpc2tVc2VgLiBJZiBjYWxsZWQgd2l0aCAwIGFyZ3VtZW50cywgc2V0cyBgYWxsb3dEaXNrVXNlOiB0cnVlYFxuICogQHJldHVybiB7UXVlcnl9IHRoaXNcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuUXVlcnkucHJvdG90eXBlLmFsbG93RGlza1VzZSA9IGZ1bmN0aW9uKHYpIHtcbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDApIHtcbiAgICB0aGlzLm9wdGlvbnMuYWxsb3dEaXNrVXNlID0gdHJ1ZTtcbiAgfSBlbHNlIGlmICh2ID09PSBmYWxzZSkge1xuICAgIGRlbGV0ZSB0aGlzLm9wdGlvbnMuYWxsb3dEaXNrVXNlO1xuICB9IGVsc2Uge1xuICAgIHRoaXMub3B0aW9ucy5hbGxvd0Rpc2tVc2UgPSB2O1xuICB9XG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBTZXRzIHRoZSBbbWF4VGltZU1TXShodHRwczovL3d3dy5tb25nb2RiLmNvbS9kb2NzL21hbnVhbC9yZWZlcmVuY2UvbWV0aG9kL2N1cnNvci5tYXhUaW1lTVMvKVxuICogb3B0aW9uLiBUaGlzIHdpbGwgdGVsbCB0aGUgTW9uZ29EQiBzZXJ2ZXIgdG8gYWJvcnQgaWYgdGhlIHF1ZXJ5IG9yIHdyaXRlIG9wXG4gKiBoYXMgYmVlbiBydW5uaW5nIGZvciBtb3JlIHRoYW4gYG1zYCBtaWxsaXNlY29uZHMuXG4gKlxuICogQ2FsbGluZyBgcXVlcnkubWF4VGltZU1TKHYpYCBpcyBlcXVpdmFsZW50IHRvIGBxdWVyeS5zZXRPcHRpb25zKHsgbWF4VGltZU1TOiB2IH0pYFxuICpcbiAqICMjIyMgRXhhbXBsZTpcbiAqXG4gKiAgICAgY29uc3QgcXVlcnkgPSBuZXcgUXVlcnkoKTtcbiAqICAgICAvLyBUaHJvd3MgYW4gZXJyb3IgJ29wZXJhdGlvbiBleGNlZWRlZCB0aW1lIGxpbWl0JyBhcyBsb25nIGFzIHRoZXJlJ3NcbiAqICAgICAvLyA+PSAxIGRvYyBpbiB0aGUgcXVlcmllZCBjb2xsZWN0aW9uXG4gKiAgICAgY29uc3QgcmVzID0gYXdhaXQgcXVlcnkuZmluZCh7ICR3aGVyZTogJ3NsZWVwKDEwMDApIHx8IHRydWUnIH0pLm1heFRpbWVNUygxMDApO1xuICpcbiAqIEBwYXJhbSB7TnVtYmVyfSBbbXNdIFRoZSBudW1iZXIgb2YgbWlsbGlzZWNvbmRzXG4gKiBAcmV0dXJuIHtRdWVyeX0gdGhpc1xuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5RdWVyeS5wcm90b3R5cGUubWF4VGltZU1TID0gZnVuY3Rpb24obXMpIHtcbiAgdGhpcy5vcHRpb25zLm1heFRpbWVNUyA9IG1zO1xuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogUmV0dXJucyB0aGUgY3VycmVudCBxdWVyeSBmaWx0ZXIgKGFsc28ga25vd24gYXMgY29uZGl0aW9ucykgYXMgYSBbUE9KT10oaHR0cHM6Ly9tYXN0ZXJpbmdqcy5pby90dXRvcmlhbHMvZnVuZGFtZW50YWxzL3Bvam8pLlxuICpcbiAqICMjIyMgRXhhbXBsZTpcbiAqXG4gKiAgICAgY29uc3QgcXVlcnkgPSBuZXcgUXVlcnkoKTtcbiAqICAgICBxdWVyeS5maW5kKHsgYTogMSB9KS53aGVyZSgnYicpLmd0KDIpO1xuICogICAgIHF1ZXJ5LmdldEZpbHRlcigpOyAvLyB7IGE6IDEsIGI6IHsgJGd0OiAyIH0gfVxuICpcbiAqIEByZXR1cm4ge09iamVjdH0gY3VycmVudCBxdWVyeSBmaWx0ZXJcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuUXVlcnkucHJvdG90eXBlLmdldEZpbHRlciA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gdGhpcy5fY29uZGl0aW9ucztcbn07XG5cbi8qKlxuICogUmV0dXJucyB0aGUgY3VycmVudCBxdWVyeSBmaWx0ZXIuIEVxdWl2YWxlbnQgdG8gYGdldEZpbHRlcigpYC5cbiAqXG4gKiBZb3Ugc2hvdWxkIHVzZSBgZ2V0RmlsdGVyKClgIGluc3RlYWQgb2YgYGdldFF1ZXJ5KClgIHdoZXJlIHBvc3NpYmxlLiBgZ2V0UXVlcnkoKWBcbiAqIHdpbGwgbGlrZWx5IGJlIGRlcHJlY2F0ZWQgaW4gYSBmdXR1cmUgcmVsZWFzZS5cbiAqXG4gKiAjIyMjIEV4YW1wbGU6XG4gKlxuICogICAgIGNvbnN0IHF1ZXJ5ID0gbmV3IFF1ZXJ5KCk7XG4gKiAgICAgcXVlcnkuZmluZCh7IGE6IDEgfSkud2hlcmUoJ2InKS5ndCgyKTtcbiAqICAgICBxdWVyeS5nZXRRdWVyeSgpOyAvLyB7IGE6IDEsIGI6IHsgJGd0OiAyIH0gfVxuICpcbiAqIEByZXR1cm4ge09iamVjdH0gY3VycmVudCBxdWVyeSBmaWx0ZXJcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuUXVlcnkucHJvdG90eXBlLmdldFF1ZXJ5ID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiB0aGlzLl9jb25kaXRpb25zO1xufTtcblxuLyoqXG4gKiBTZXRzIHRoZSBxdWVyeSBjb25kaXRpb25zIHRvIHRoZSBwcm92aWRlZCBKU09OIG9iamVjdC5cbiAqXG4gKiAjIyMjIEV4YW1wbGU6XG4gKlxuICogICAgIGNvbnN0IHF1ZXJ5ID0gbmV3IFF1ZXJ5KCk7XG4gKiAgICAgcXVlcnkuZmluZCh7IGE6IDEgfSlcbiAqICAgICBxdWVyeS5zZXRRdWVyeSh7IGE6IDIgfSk7XG4gKiAgICAgcXVlcnkuZ2V0UXVlcnkoKTsgLy8geyBhOiAyIH1cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gbmV3IHF1ZXJ5IGNvbmRpdGlvbnNcbiAqIEByZXR1cm4ge3VuZGVmaW5lZH1cbiAqIEBhcGkgcHVibGljXG4gKi9cblxuUXVlcnkucHJvdG90eXBlLnNldFF1ZXJ5ID0gZnVuY3Rpb24odmFsKSB7XG4gIHRoaXMuX2NvbmRpdGlvbnMgPSB2YWw7XG59O1xuXG4vKipcbiAqIFJldHVybnMgdGhlIGN1cnJlbnQgdXBkYXRlIG9wZXJhdGlvbnMgYXMgYSBKU09OIG9iamVjdC5cbiAqXG4gKiAjIyMjIEV4YW1wbGU6XG4gKlxuICogICAgIGNvbnN0IHF1ZXJ5ID0gbmV3IFF1ZXJ5KCk7XG4gKiAgICAgcXVlcnkudXBkYXRlT25lKHt9LCB7ICRzZXQ6IHsgYTogNSB9IH0pO1xuICogICAgIHF1ZXJ5LmdldFVwZGF0ZSgpOyAvLyB7ICRzZXQ6IHsgYTogNSB9IH1cbiAqXG4gKiBAcmV0dXJuIHtPYmplY3R9IGN1cnJlbnQgdXBkYXRlIG9wZXJhdGlvbnNcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuUXVlcnkucHJvdG90eXBlLmdldFVwZGF0ZSA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gdGhpcy5fdXBkYXRlO1xufTtcblxuLyoqXG4gKiBTZXRzIHRoZSBjdXJyZW50IHVwZGF0ZSBvcGVyYXRpb24gdG8gbmV3IHZhbHVlLlxuICpcbiAqICMjIyMgRXhhbXBsZTpcbiAqXG4gKiAgICAgY29uc3QgcXVlcnkgPSBuZXcgUXVlcnkoKTtcbiAqICAgICBxdWVyeS51cGRhdGVPbmUoe30sIHsgJHNldDogeyBhOiA1IH0gfSk7XG4gKiAgICAgcXVlcnkuc2V0VXBkYXRlKHsgJHNldDogeyBiOiA2IH0gfSk7XG4gKiAgICAgcXVlcnkuZ2V0VXBkYXRlKCk7IC8vIHsgJHNldDogeyBiOiA2IH0gfVxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBuZXcgdXBkYXRlIG9wZXJhdGlvblxuICogQHJldHVybiB7dW5kZWZpbmVkfVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5RdWVyeS5wcm90b3R5cGUuc2V0VXBkYXRlID0gZnVuY3Rpb24odmFsKSB7XG4gIHRoaXMuX3VwZGF0ZSA9IHZhbDtcbn07XG5cbi8qKlxuICogUmV0dXJucyBmaWVsZHMgc2VsZWN0aW9uIGZvciB0aGlzIHF1ZXJ5LlxuICpcbiAqIEBtZXRob2QgX2ZpZWxkc0ZvckV4ZWNcbiAqIEByZXR1cm4ge09iamVjdH1cbiAqIEBhcGkgcHJpdmF0ZVxuICogQG1lbWJlck9mIFF1ZXJ5XG4gKi9cblxuUXVlcnkucHJvdG90eXBlLl9maWVsZHNGb3JFeGVjID0gZnVuY3Rpb24oKSB7XG4gIGlmICh0aGlzLl9maWVsZHMgPT0gbnVsbCkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIGlmIChPYmplY3Qua2V5cyh0aGlzLl9maWVsZHMpLmxlbmd0aCA9PT0gMCkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIHJldHVybiBjbG9uZSh0aGlzLl9maWVsZHMpO1xufTtcblxuXG4vKipcbiAqIFJldHVybiBhbiB1cGRhdGUgZG9jdW1lbnQgd2l0aCBjb3JyZWN0ZWQgYCRzZXRgIG9wZXJhdGlvbnMuXG4gKlxuICogQG1ldGhvZCBfdXBkYXRlRm9yRXhlY1xuICogQHJldHVybiB7T2JqZWN0fVxuICogQGFwaSBwcml2YXRlXG4gKiBAbWVtYmVyT2YgUXVlcnlcbiAqL1xuXG5RdWVyeS5wcm90b3R5cGUuX3VwZGF0ZUZvckV4ZWMgPSBmdW5jdGlvbigpIHtcbiAgY29uc3QgdXBkYXRlID0gY2xvbmUodGhpcy5fdXBkYXRlLCB7XG4gICAgdHJhbnNmb3JtOiBmYWxzZSxcbiAgICBkZXBvcHVsYXRlOiB0cnVlXG4gIH0pO1xuICBjb25zdCBvcHMgPSBPYmplY3Qua2V5cyh1cGRhdGUpO1xuICBsZXQgaSA9IG9wcy5sZW5ndGg7XG4gIGNvbnN0IHJldCA9IHt9O1xuXG4gIHdoaWxlIChpLS0pIHtcbiAgICBjb25zdCBvcCA9IG9wc1tpXTtcblxuICAgIGlmICgnJCcgIT09IG9wWzBdKSB7XG4gICAgICAvLyBmaXggdXAgJHNldCBzdWdhclxuICAgICAgaWYgKCFyZXQuJHNldCkge1xuICAgICAgICBpZiAodXBkYXRlLiRzZXQpIHtcbiAgICAgICAgICByZXQuJHNldCA9IHVwZGF0ZS4kc2V0O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldC4kc2V0ID0ge307XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldC4kc2V0W29wXSA9IHVwZGF0ZVtvcF07XG4gICAgICBvcHMuc3BsaWNlKGksIDEpO1xuICAgICAgaWYgKCF+b3BzLmluZGV4T2YoJyRzZXQnKSkgb3BzLnB1c2goJyRzZXQnKTtcbiAgICB9IGVsc2UgaWYgKCckc2V0JyA9PT0gb3ApIHtcbiAgICAgIGlmICghcmV0LiRzZXQpIHtcbiAgICAgICAgcmV0W29wXSA9IHVwZGF0ZVtvcF07XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldFtvcF0gPSB1cGRhdGVbb3BdO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiByZXQ7XG59O1xuXG4vKipcbiAqIE1ha2VzIHN1cmUgX3BhdGggaXMgc2V0LlxuICpcbiAqIFRoaXMgbWV0aG9kIGlzIGluaGVyaXRlZCBieSBgbXF1ZXJ5YFxuICpcbiAqIEBtZXRob2QgX2Vuc3VyZVBhdGhcbiAqIEBwYXJhbSB7U3RyaW5nfSBtZXRob2RcbiAqIEBhcGkgcHJpdmF0ZVxuICogQG1lbWJlck9mIFF1ZXJ5XG4gKi9cblxuLyoqXG4gKiBEZXRlcm1pbmVzIGlmIGBjb25kc2AgY2FuIGJlIG1lcmdlZCB1c2luZyBgbXF1ZXJ5KCkubWVyZ2UoKWBcbiAqXG4gKiBAbWV0aG9kIGNhbk1lcmdlXG4gKiBAbWVtYmVyT2YgUXVlcnlcbiAqIEBpbnN0YW5jZVxuICogQHBhcmFtIHtPYmplY3R9IGNvbmRzXG4gKiBAcmV0dXJuIHtCb29sZWFufVxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuLyoqXG4gKiBSZXR1cm5zIGRlZmF1bHQgb3B0aW9ucyBmb3IgdGhpcyBxdWVyeS5cbiAqXG4gKiBAcGFyYW0ge01vZGVsfSBtb2RlbFxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuUXVlcnkucHJvdG90eXBlLl9vcHRpb25zRm9yRXhlYyA9IGZ1bmN0aW9uKG1vZGVsKSB7XG4gIGNvbnN0IG9wdGlvbnMgPSBjbG9uZSh0aGlzLm9wdGlvbnMpO1xuICBkZWxldGUgb3B0aW9ucy5wb3B1bGF0ZTtcbiAgbW9kZWwgPSBtb2RlbCB8fCB0aGlzLm1vZGVsO1xuXG4gIGlmICghbW9kZWwpIHtcbiAgICByZXR1cm4gb3B0aW9ucztcbiAgfVxuICAvLyBBcHBseSBzY2hlbWEtbGV2ZWwgYHdyaXRlQ29uY2VybmAgb3B0aW9uXG4gIGFwcGx5V3JpdGVDb25jZXJuKG1vZGVsLnNjaGVtYSwgb3B0aW9ucyk7XG5cbiAgY29uc3QgcmVhZFByZWZlcmVuY2UgPSBtb2RlbCAmJlxuICBtb2RlbC5zY2hlbWEgJiZcbiAgbW9kZWwuc2NoZW1hLm9wdGlvbnMgJiZcbiAgbW9kZWwuc2NoZW1hLm9wdGlvbnMucmVhZDtcbiAgaWYgKCEoJ3JlYWRQcmVmZXJlbmNlJyBpbiBvcHRpb25zKSAmJiByZWFkUHJlZmVyZW5jZSkge1xuICAgIG9wdGlvbnMucmVhZFByZWZlcmVuY2UgPSByZWFkUHJlZmVyZW5jZTtcbiAgfVxuXG4gIGlmIChvcHRpb25zLnVwc2VydCAhPT0gdm9pZCAwKSB7XG4gICAgb3B0aW9ucy51cHNlcnQgPSAhIW9wdGlvbnMudXBzZXJ0O1xuICB9XG4gIGlmIChvcHRpb25zLndyaXRlQ29uY2Vybikge1xuICAgIGlmIChvcHRpb25zLmopIHtcbiAgICAgIG9wdGlvbnMud3JpdGVDb25jZXJuLmogPSBvcHRpb25zLmo7XG4gICAgICBkZWxldGUgb3B0aW9ucy5qO1xuICAgIH1cbiAgICBpZiAob3B0aW9ucy53KSB7XG4gICAgICBvcHRpb25zLndyaXRlQ29uY2Vybi53ID0gb3B0aW9ucy53O1xuICAgICAgZGVsZXRlIG9wdGlvbnMudztcbiAgICB9XG4gICAgaWYgKG9wdGlvbnMud3RpbWVvdXQpIHtcbiAgICAgIG9wdGlvbnMud3JpdGVDb25jZXJuLnd0aW1lb3V0ID0gb3B0aW9ucy53dGltZW91dDtcbiAgICAgIGRlbGV0ZSBvcHRpb25zLnd0aW1lb3V0O1xuICAgIH1cbiAgfVxuXG4gIHRoaXMuX2FwcGx5UGF0aHMoKTtcbiAgaWYgKHRoaXMuX2ZpZWxkcyAhPSBudWxsKSB7XG4gICAgdGhpcy5fZmllbGRzID0gdGhpcy5fY2FzdEZpZWxkcyh0aGlzLl9maWVsZHMpO1xuICAgIGNvbnN0IHByb2plY3Rpb24gPSB0aGlzLl9maWVsZHNGb3JFeGVjKCk7XG4gICAgaWYgKHByb2plY3Rpb24gIT0gbnVsbCkge1xuICAgICAgb3B0aW9ucy5wcm9qZWN0aW9uID0gcHJvamVjdGlvbjtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gb3B0aW9ucztcbn07XG5cbi8qKlxuICogU2V0cyB0aGUgbGVhbiBvcHRpb24uXG4gKlxuICogRG9jdW1lbnRzIHJldHVybmVkIGZyb20gcXVlcmllcyB3aXRoIHRoZSBgbGVhbmAgb3B0aW9uIGVuYWJsZWQgYXJlIHBsYWluXG4gKiBqYXZhc2NyaXB0IG9iamVjdHMsIG5vdCBbTW9uZ29vc2UgRG9jdW1lbnRzXShodHRwczovL21vbmdvb3NlanMuY29tL2RvY3MvYXBpL2RvY3VtZW50Lmh0bWwpLiBUaGV5IGhhdmUgbm9cbiAqIGBzYXZlYCBtZXRob2QsIGdldHRlcnMvc2V0dGVycywgdmlydHVhbHMsIG9yIG90aGVyIE1vbmdvb3NlIGZlYXR1cmVzLlxuICpcbiAqICMjIyMgRXhhbXBsZTpcbiAqXG4gKiAgICAgbmV3IFF1ZXJ5KCkubGVhbigpIC8vIHRydWVcbiAqICAgICBuZXcgUXVlcnkoKS5sZWFuKHRydWUpXG4gKiAgICAgbmV3IFF1ZXJ5KCkubGVhbihmYWxzZSlcbiAqXG4gKiAgICAgY29uc3QgZG9jcyA9IGF3YWl0IE1vZGVsLmZpbmQoKS5sZWFuKCk7XG4gKiAgICAgZG9jc1swXSBpbnN0YW5jZW9mIG1vbmdvb3NlLkRvY3VtZW50OyAvLyBmYWxzZVxuICpcbiAqIFtMZWFuIGlzIGdyZWF0IGZvciBoaWdoLXBlcmZvcm1hbmNlLCByZWFkLW9ubHkgY2FzZXNdKGh0dHBzOi8vbW9uZ29vc2Vqcy5jb20vZG9jcy90dXRvcmlhbHMvbGVhbi5odG1sKSxcbiAqIGVzcGVjaWFsbHkgd2hlbiBjb21iaW5lZFxuICogd2l0aCBbY3Vyc29yc10oaHR0cHM6Ly9tb25nb29zZWpzLmNvbS9kb2NzL3F1ZXJpZXMuaHRtbCNzdHJlYW1pbmcpLlxuICpcbiAqIElmIHlvdSBuZWVkIHZpcnR1YWxzLCBnZXR0ZXJzL3NldHRlcnMsIG9yIGRlZmF1bHRzIHdpdGggYGxlYW4oKWAsIHlvdSBuZWVkXG4gKiB0byB1c2UgYSBwbHVnaW4uIFNlZTpcbiAqXG4gKiAtIFttb25nb29zZS1sZWFuLXZpcnR1YWxzXShodHRwczovL3BsdWdpbnMubW9uZ29vc2Vqcy5pby9wbHVnaW5zL2xlYW4tdmlydHVhbHMpXG4gKiAtIFttb25nb29zZS1sZWFuLWdldHRlcnNdKGh0dHBzOi8vcGx1Z2lucy5tb25nb29zZWpzLmlvL3BsdWdpbnMvbGVhbi1nZXR0ZXJzKVxuICogLSBbbW9uZ29vc2UtbGVhbi1kZWZhdWx0c10oaHR0cHM6Ly93d3cubnBtanMuY29tL3BhY2thZ2UvbW9uZ29vc2UtbGVhbi1kZWZhdWx0cylcbiAqXG4gKiBAcGFyYW0ge0Jvb2xlYW58T2JqZWN0fSBib29sIGRlZmF1bHRzIHRvIHRydWVcbiAqIEByZXR1cm4ge1F1ZXJ5fSB0aGlzXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cblF1ZXJ5LnByb3RvdHlwZS5sZWFuID0gZnVuY3Rpb24odikge1xuICB0aGlzLl9tb25nb29zZU9wdGlvbnMubGVhbiA9IGFyZ3VtZW50cy5sZW5ndGggPyB2IDogdHJ1ZTtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIEFkZHMgYSBgJHNldGAgdG8gdGhpcyBxdWVyeSdzIHVwZGF0ZSB3aXRob3V0IGNoYW5naW5nIHRoZSBvcGVyYXRpb24uXG4gKiBUaGlzIGlzIHVzZWZ1bCBmb3IgcXVlcnkgbWlkZGxld2FyZSBzbyB5b3UgY2FuIGFkZCBhbiB1cGRhdGUgcmVnYXJkbGVzc1xuICogb2Ygd2hldGhlciB5b3UgdXNlIGB1cGRhdGVPbmUoKWAsIGB1cGRhdGVNYW55KClgLCBgZmluZE9uZUFuZFVwZGF0ZSgpYCwgZXRjLlxuICpcbiAqICMjIyMgRXhhbXBsZTpcbiAqXG4gKiAgICAgLy8gVXBkYXRlcyBgeyAkc2V0OiB7IHVwZGF0ZWRBdDogbmV3IERhdGUoKSB9IH1gXG4gKiAgICAgbmV3IFF1ZXJ5KCkudXBkYXRlT25lKHt9LCB7fSkuc2V0KCd1cGRhdGVkQXQnLCBuZXcgRGF0ZSgpKTtcbiAqICAgICBuZXcgUXVlcnkoKS51cGRhdGVNYW55KHt9LCB7fSkuc2V0KHsgdXBkYXRlZEF0OiBuZXcgRGF0ZSgpIH0pO1xuICpcbiAqIEBwYXJhbSB7U3RyaW5nfE9iamVjdH0gcGF0aCBwYXRoIG9yIG9iamVjdCBvZiBrZXkvdmFsdWUgcGFpcnMgdG8gc2V0XG4gKiBAcGFyYW0ge0FueX0gW3ZhbF0gdGhlIHZhbHVlIHRvIHNldFxuICogQHJldHVybiB7UXVlcnl9IHRoaXNcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuUXVlcnkucHJvdG90eXBlLnNldCA9IGZ1bmN0aW9uKHBhdGgsIHZhbCkge1xuICBpZiAodHlwZW9mIHBhdGggPT09ICdvYmplY3QnKSB7XG4gICAgY29uc3Qga2V5cyA9IE9iamVjdC5rZXlzKHBhdGgpO1xuICAgIGZvciAoY29uc3Qga2V5IG9mIGtleXMpIHtcbiAgICAgIHRoaXMuc2V0KGtleSwgcGF0aFtrZXldKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICB0aGlzLl91cGRhdGUgPSB0aGlzLl91cGRhdGUgfHwge307XG4gIGlmIChwYXRoIGluIHRoaXMuX3VwZGF0ZSkge1xuICAgIGRlbGV0ZSB0aGlzLl91cGRhdGVbcGF0aF07XG4gIH1cbiAgdGhpcy5fdXBkYXRlLiRzZXQgPSB0aGlzLl91cGRhdGUuJHNldCB8fCB7fTtcbiAgdGhpcy5fdXBkYXRlLiRzZXRbcGF0aF0gPSB2YWw7XG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBGb3IgdXBkYXRlIG9wZXJhdGlvbnMsIHJldHVybnMgdGhlIHZhbHVlIG9mIGEgcGF0aCBpbiB0aGUgdXBkYXRlJ3MgYCRzZXRgLlxuICogVXNlZnVsIGZvciB3cml0aW5nIGdldHRlcnMvc2V0dGVycyB0aGF0IGNhbiB3b3JrIHdpdGggYm90aCB1cGRhdGUgb3BlcmF0aW9uc1xuICogYW5kIGBzYXZlKClgLlxuICpcbiAqICMjIyMgRXhhbXBsZTpcbiAqXG4gKiAgICAgY29uc3QgcXVlcnkgPSBNb2RlbC51cGRhdGVPbmUoe30sIHsgJHNldDogeyBuYW1lOiAnSmVhbi1MdWMgUGljYXJkJyB9IH0pO1xuICogICAgIHF1ZXJ5LmdldCgnbmFtZScpOyAvLyAnSmVhbi1MdWMgUGljYXJkJ1xuICpcbiAqIEBwYXJhbSB7U3RyaW5nfE9iamVjdH0gcGF0aCBwYXRoIG9yIG9iamVjdCBvZiBrZXkvdmFsdWUgcGFpcnMgdG8gZ2V0XG4gKiBAcmV0dXJuIHtRdWVyeX0gdGhpc1xuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5RdWVyeS5wcm90b3R5cGUuZ2V0ID0gZnVuY3Rpb24gZ2V0KHBhdGgpIHtcbiAgY29uc3QgdXBkYXRlID0gdGhpcy5fdXBkYXRlO1xuICBpZiAodXBkYXRlID09IG51bGwpIHtcbiAgICByZXR1cm4gdm9pZCAwO1xuICB9XG4gIGNvbnN0ICRzZXQgPSB1cGRhdGUuJHNldDtcbiAgaWYgKCRzZXQgPT0gbnVsbCkge1xuICAgIHJldHVybiB1cGRhdGVbcGF0aF07XG4gIH1cblxuICBpZiAodXRpbHMuaGFzVXNlckRlZmluZWRQcm9wZXJ0eSh1cGRhdGUsIHBhdGgpKSB7XG4gICAgcmV0dXJuIHVwZGF0ZVtwYXRoXTtcbiAgfVxuICBpZiAodXRpbHMuaGFzVXNlckRlZmluZWRQcm9wZXJ0eSgkc2V0LCBwYXRoKSkge1xuICAgIHJldHVybiAkc2V0W3BhdGhdO1xuICB9XG5cbiAgcmV0dXJuIHZvaWQgMDtcbn07XG5cbi8qKlxuICogR2V0cy9zZXRzIHRoZSBlcnJvciBmbGFnIG9uIHRoaXMgcXVlcnkuIElmIHRoaXMgZmxhZyBpcyBub3QgbnVsbCBvclxuICogdW5kZWZpbmVkLCB0aGUgYGV4ZWMoKWAgcHJvbWlzZSB3aWxsIHJlamVjdCB3aXRob3V0IGV4ZWN1dGluZy5cbiAqXG4gKiAjIyMjIEV4YW1wbGU6XG4gKlxuICogICAgIFF1ZXJ5KCkuZXJyb3IoKTsgLy8gR2V0IGN1cnJlbnQgZXJyb3IgdmFsdWVcbiAqICAgICBRdWVyeSgpLmVycm9yKG51bGwpOyAvLyBVbnNldCB0aGUgY3VycmVudCBlcnJvclxuICogICAgIFF1ZXJ5KCkuZXJyb3IobmV3IEVycm9yKCd0ZXN0JykpOyAvLyBgZXhlYygpYCB3aWxsIHJlc29sdmUgd2l0aCB0ZXN0XG4gKiAgICAgU2NoZW1hLnByZSgnZmluZCcsIGZ1bmN0aW9uKCkge1xuICogICAgICAgaWYgKCF0aGlzLmdldFF1ZXJ5KCkudXNlcklkKSB7XG4gKiAgICAgICAgIHRoaXMuZXJyb3IobmV3IEVycm9yKCdOb3QgYWxsb3dlZCB0byBxdWVyeSB3aXRob3V0IHNldHRpbmcgdXNlcklkJykpO1xuICogICAgICAgfVxuICogICAgIH0pO1xuICpcbiAqIE5vdGUgdGhhdCBxdWVyeSBjYXN0aW5nIHJ1bnMgKiphZnRlcioqIGhvb2tzLCBzbyBjYXN0IGVycm9ycyB3aWxsIG92ZXJyaWRlXG4gKiBjdXN0b20gZXJyb3JzLlxuICpcbiAqICMjIyMgRXhhbXBsZTpcbiAqXG4gKiAgICAgY29uc3QgVGVzdFNjaGVtYSA9IG5ldyBTY2hlbWEoeyBudW06IE51bWJlciB9KTtcbiAqICAgICBjb25zdCBUZXN0TW9kZWwgPSBkYi5tb2RlbCgnVGVzdCcsIFRlc3RTY2hlbWEpO1xuICogICAgIFRlc3RNb2RlbC5maW5kKHsgbnVtOiAnbm90IGEgbnVtYmVyJyB9KS5lcnJvcihuZXcgRXJyb3IoJ3dvb3BzJykpLmV4ZWMoZnVuY3Rpb24oZXJyb3IpIHtcbiAqICAgICAgIC8vIGBlcnJvcmAgd2lsbCBiZSBhIGNhc3QgZXJyb3IgYmVjYXVzZSBgbnVtYCBmYWlsZWQgdG8gY2FzdFxuICogICAgIH0pO1xuICpcbiAqIEBwYXJhbSB7RXJyb3J8bnVsbH0gZXJyIGlmIHNldCwgYGV4ZWMoKWAgd2lsbCBmYWlsIGZhc3QgYmVmb3JlIHNlbmRpbmcgdGhlIHF1ZXJ5IHRvIE1vbmdvREJcbiAqIEByZXR1cm4ge1F1ZXJ5fSB0aGlzXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cblF1ZXJ5LnByb3RvdHlwZS5lcnJvciA9IGZ1bmN0aW9uIGVycm9yKGVycikge1xuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMCkge1xuICAgIHJldHVybiB0aGlzLl9lcnJvcjtcbiAgfVxuXG4gIHRoaXMuX2Vycm9yID0gZXJyO1xuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogaWdub3JlXG4gKiBAbWV0aG9kIF91bnNldENhc3RFcnJvclxuICogQGluc3RhbmNlXG4gKiBAbWVtYmVyT2YgUXVlcnlcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cblF1ZXJ5LnByb3RvdHlwZS5fdW5zZXRDYXN0RXJyb3IgPSBmdW5jdGlvbiBfdW5zZXRDYXN0RXJyb3IoKSB7XG4gIGlmICh0aGlzLl9lcnJvciAhPSBudWxsICYmICEodGhpcy5fZXJyb3IgaW5zdGFuY2VvZiBDYXN0RXJyb3IpKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIHJldHVybiB0aGlzLmVycm9yKG51bGwpO1xufTtcblxuLyoqXG4gKiBHZXR0ZXIvc2V0dGVyIGFyb3VuZCB0aGUgY3VycmVudCBtb25nb29zZS1zcGVjaWZpYyBvcHRpb25zIGZvciB0aGlzIHF1ZXJ5XG4gKiBCZWxvdyBhcmUgdGhlIGN1cnJlbnQgTW9uZ29vc2Utc3BlY2lmaWMgb3B0aW9ucy5cbiAqXG4gKiAtIGBwb3B1bGF0ZWA6IGFuIGFycmF5IHJlcHJlc2VudGluZyB3aGF0IHBhdGhzIHdpbGwgYmUgcG9wdWxhdGVkLiBTaG91bGQgaGF2ZSBvbmUgZW50cnkgZm9yIGVhY2ggY2FsbCB0byBbYFF1ZXJ5LnByb3RvdHlwZS5wb3B1bGF0ZSgpYF0oaHR0cHM6Ly9tb25nb29zZWpzLmNvbS9kb2NzL2FwaS9xdWVyeS5odG1sI1F1ZXJ5LnByb3RvdHlwZS5wb3B1bGF0ZSgpKVxuICogLSBgbGVhbmA6IGlmIHRydXRoeSwgTW9uZ29vc2Ugd2lsbCBub3QgW2h5ZHJhdGVdKGh0dHBzOi8vbW9uZ29vc2Vqcy5jb20vZG9jcy9hcGkvbW9kZWwuaHRtbCNNb2RlbC5oeWRyYXRlKCkpIGFueSBkb2N1bWVudHMgdGhhdCBhcmUgcmV0dXJuZWQgZnJvbSB0aGlzIHF1ZXJ5LiBTZWUgW2BRdWVyeS5wcm90b3R5cGUubGVhbigpYF0oaHR0cHM6Ly9tb25nb29zZWpzLmNvbS9kb2NzL2FwaS9xdWVyeS5odG1sI1F1ZXJ5LnByb3RvdHlwZS5sZWFuKCkpIGZvciBtb3JlIGluZm9ybWF0aW9uLlxuICogLSBgc3RyaWN0YDogY29udHJvbHMgaG93IE1vbmdvb3NlIGhhbmRsZXMga2V5cyB0aGF0IGFyZW4ndCBpbiB0aGUgc2NoZW1hIGZvciB1cGRhdGVzLiBUaGlzIG9wdGlvbiBpcyBgdHJ1ZWAgYnkgZGVmYXVsdCwgd2hpY2ggbWVhbnMgTW9uZ29vc2Ugd2lsbCBzaWxlbnRseSBzdHJpcCBhbnkgcGF0aHMgaW4gdGhlIHVwZGF0ZSB0aGF0IGFyZW4ndCBpbiB0aGUgc2NoZW1hLiBTZWUgdGhlIFtgc3RyaWN0YCBtb2RlIGRvY3NdKGh0dHBzOi8vbW9uZ29vc2Vqcy5jb20vZG9jcy9ndWlkZS5odG1sI3N0cmljdCkgZm9yIG1vcmUgaW5mb3JtYXRpb24uXG4gKiAtIGBzdHJpY3RRdWVyeWA6IGNvbnRyb2xzIGhvdyBNb25nb29zZSBoYW5kbGVzIGtleXMgdGhhdCBhcmVuJ3QgaW4gdGhlIHNjaGVtYSBmb3IgdGhlIHF1ZXJ5IGBmaWx0ZXJgLiBUaGlzIG9wdGlvbiBpcyBgZmFsc2VgIGJ5IGRlZmF1bHQsIHdoaWNoIG1lYW5zIE1vbmdvb3NlIHdpbGwgYWxsb3cgYE1vZGVsLmZpbmQoeyBmb286ICdiYXInIH0pYCBldmVuIGlmIGBmb29gIGlzIG5vdCBpbiB0aGUgc2NoZW1hLiBTZWUgdGhlIFtgc3RyaWN0UXVlcnlgIGRvY3NdKGh0dHBzOi8vbW9uZ29vc2Vqcy5jb20vZG9jcy9ndWlkZS5odG1sI3N0cmljdFF1ZXJ5KSBmb3IgbW9yZSBpbmZvcm1hdGlvbi5cbiAqIC0gYG5lYXJTcGhlcmVgOiB1c2UgYCRuZWFyU3BoZXJlYCBpbnN0ZWFkIG9mIGBuZWFyKClgLiBTZWUgdGhlIFtgUXVlcnkucHJvdG90eXBlLm5lYXJTcGhlcmUoKWAgZG9jc10oaHR0cHM6Ly9tb25nb29zZWpzLmNvbS9kb2NzL2FwaS9xdWVyeS5odG1sI1F1ZXJ5LnByb3RvdHlwZS5uZWFyU3BoZXJlKCkpXG4gKlxuICogTW9uZ29vc2UgbWFpbnRhaW5zIGEgc2VwYXJhdGUgb2JqZWN0IGZvciBpbnRlcm5hbCBvcHRpb25zIGJlY2F1c2VcbiAqIE1vbmdvb3NlIHNlbmRzIGBRdWVyeS5wcm90b3R5cGUub3B0aW9uc2AgdG8gdGhlIE1vbmdvREIgc2VydmVyLCBhbmQgdGhlXG4gKiBhYm92ZSBvcHRpb25zIGFyZSBub3QgcmVsZXZhbnQgZm9yIHRoZSBNb25nb0RCIHNlcnZlci5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyBpZiBzcGVjaWZpZWQsIG92ZXJ3cml0ZXMgdGhlIGN1cnJlbnQgb3B0aW9uc1xuICogQHJldHVybiB7T2JqZWN0fSB0aGUgb3B0aW9uc1xuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5RdWVyeS5wcm90b3R5cGUubW9uZ29vc2VPcHRpb25zID0gZnVuY3Rpb24odikge1xuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA+IDApIHtcbiAgICB0aGlzLl9tb25nb29zZU9wdGlvbnMgPSB2O1xuICB9XG4gIHJldHVybiB0aGlzLl9tb25nb29zZU9wdGlvbnM7XG59O1xuXG4vKipcbiAqIGlnbm9yZVxuICogQG1ldGhvZCBfY2FzdENvbmRpdGlvbnNcbiAqIEBtZW1iZXJPZiBRdWVyeVxuICogQGFwaSBwcml2YXRlXG4gKiBAaW5zdGFuY2VcbiAqL1xuXG5RdWVyeS5wcm90b3R5cGUuX2Nhc3RDb25kaXRpb25zID0gZnVuY3Rpb24oKSB7XG4gIGxldCBzYW5pdGl6ZUZpbHRlck9wdCA9IHVuZGVmaW5lZDtcbiAgaWYgKHRoaXMubW9kZWwgIT0gbnVsbCAmJiB1dGlscy5oYXNVc2VyRGVmaW5lZFByb3BlcnR5KHRoaXMubW9kZWwuZGIub3B0aW9ucywgJ3Nhbml0aXplRmlsdGVyJykpIHtcbiAgICBzYW5pdGl6ZUZpbHRlck9wdCA9IHRoaXMubW9kZWwuZGIub3B0aW9ucy5zYW5pdGl6ZUZpbHRlcjtcbiAgfSBlbHNlIGlmICh0aGlzLm1vZGVsICE9IG51bGwgJiYgdXRpbHMuaGFzVXNlckRlZmluZWRQcm9wZXJ0eSh0aGlzLm1vZGVsLmJhc2Uub3B0aW9ucywgJ3Nhbml0aXplRmlsdGVyJykpIHtcbiAgICBzYW5pdGl6ZUZpbHRlck9wdCA9IHRoaXMubW9kZWwuYmFzZS5vcHRpb25zLnNhbml0aXplRmlsdGVyO1xuICB9IGVsc2Uge1xuICAgIHNhbml0aXplRmlsdGVyT3B0ID0gdGhpcy5fbW9uZ29vc2VPcHRpb25zLnNhbml0aXplRmlsdGVyO1xuICB9XG5cbiAgaWYgKHNhbml0aXplRmlsdGVyT3B0KSB7XG4gICAgc2FuaXRpemVGaWx0ZXIodGhpcy5fY29uZGl0aW9ucyk7XG4gIH1cblxuICB0cnkge1xuICAgIHRoaXMuY2FzdCh0aGlzLm1vZGVsKTtcbiAgICB0aGlzLl91bnNldENhc3RFcnJvcigpO1xuICB9IGNhdGNoIChlcnIpIHtcbiAgICB0aGlzLmVycm9yKGVycik7XG4gIH1cbn07XG5cbi8qIVxuICogaWdub3JlXG4gKi9cblxuZnVuY3Rpb24gX2Nhc3RBcnJheUZpbHRlcnMocXVlcnkpIHtcbiAgdHJ5IHtcbiAgICBjYXN0QXJyYXlGaWx0ZXJzKHF1ZXJ5KTtcbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgcXVlcnkuZXJyb3IoZXJyKTtcbiAgfVxufVxuXG4vKipcbiAqIEV4ZWN1dGUgYSBgZmluZCgpYFxuICpcbiAqIEByZXR1cm4ge1F1ZXJ5fSB0aGlzXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuUXVlcnkucHJvdG90eXBlLl9maW5kID0gYXN5bmMgZnVuY3Rpb24gX2ZpbmQoKSB7XG4gIHRoaXMuX2Nhc3RDb25kaXRpb25zKCk7XG5cbiAgaWYgKHRoaXMuZXJyb3IoKSAhPSBudWxsKSB7XG4gICAgdGhyb3cgdGhpcy5lcnJvcigpO1xuICB9XG5cbiAgY29uc3QgbW9uZ29vc2VPcHRpb25zID0gdGhpcy5fbW9uZ29vc2VPcHRpb25zO1xuICBjb25zdCBfdGhpcyA9IHRoaXM7XG4gIGNvbnN0IHVzZXJQcm92aWRlZEZpZWxkcyA9IF90aGlzLl91c2VyUHJvdmlkZWRGaWVsZHMgfHwge307XG5cbiAgYXBwbHlHbG9iYWxNYXhUaW1lTVModGhpcy5vcHRpb25zLCB0aGlzLm1vZGVsKTtcbiAgYXBwbHlHbG9iYWxEaXNrVXNlKHRoaXMub3B0aW9ucywgdGhpcy5tb2RlbCk7XG5cbiAgLy8gU2VwYXJhdGUgb3B0aW9ucyB0byBwYXNzIGRvd24gdG8gYGNvbXBsZXRlTWFueSgpYCBpbiBjYXNlIHdlIG5lZWQgdG9cbiAgLy8gc2V0IGEgc2Vzc2lvbiBvbiB0aGUgZG9jdW1lbnRcbiAgY29uc3QgY29tcGxldGVNYW55T3B0aW9ucyA9IE9iamVjdC5hc3NpZ24oe30sIHtcbiAgICBzZXNzaW9uOiB0aGlzICYmIHRoaXMub3B0aW9ucyAmJiB0aGlzLm9wdGlvbnMuc2Vzc2lvbiB8fCBudWxsLFxuICAgIGxlYW46IG1vbmdvb3NlT3B0aW9ucy5sZWFuIHx8IG51bGxcbiAgfSk7XG5cbiAgY29uc3Qgb3B0aW9ucyA9IHRoaXMuX29wdGlvbnNGb3JFeGVjKCk7XG5cbiAgdGhpcy5fYXBwbHlUcmFuc2xhdGVBbGlhc2VzKG9wdGlvbnMpO1xuXG4gIGNvbnN0IGZpbHRlciA9IHRoaXMuX2NvbmRpdGlvbnM7XG4gIGNvbnN0IGZpZWxkcyA9IG9wdGlvbnMucHJvamVjdGlvbjtcblxuICBjb25zdCBjdXJzb3IgPSBhd2FpdCB0aGlzLm1vbmdvb3NlQ29sbGVjdGlvbi5maW5kKGZpbHRlciwgb3B0aW9ucyk7XG4gIGlmIChvcHRpb25zLmV4cGxhaW4pIHtcbiAgICByZXR1cm4gY3Vyc29yLmV4cGxhaW4oKTtcbiAgfVxuXG4gIGxldCBkb2NzID0gYXdhaXQgY3Vyc29yLnRvQXJyYXkoKTtcbiAgaWYgKGRvY3MubGVuZ3RoID09PSAwKSB7XG4gICAgcmV0dXJuIGRvY3M7XG4gIH1cblxuICBpZiAoIW1vbmdvb3NlT3B0aW9ucy5wb3B1bGF0ZSkge1xuICAgIGNvbnN0IHZlcnNpb25LZXkgPSBfdGhpcy5zY2hlbWEub3B0aW9ucy52ZXJzaW9uS2V5O1xuICAgIGlmIChtb25nb29zZU9wdGlvbnMubGVhbiAmJiBtb25nb29zZU9wdGlvbnMubGVhbi52ZXJzaW9uS2V5ID09PSBmYWxzZSAmJiB2ZXJzaW9uS2V5KSB7XG4gICAgICBkb2NzLmZvckVhY2goKGRvYykgPT4ge1xuICAgICAgICBpZiAodmVyc2lvbktleSBpbiBkb2MpIHtcbiAgICAgICAgICBkZWxldGUgZG9jW3ZlcnNpb25LZXldO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIG1vbmdvb3NlT3B0aW9ucy5sZWFuID9cbiAgICAgIF9jb21wbGV0ZU1hbnlMZWFuKF90aGlzLm1vZGVsLnNjaGVtYSwgZG9jcywgbnVsbCwgY29tcGxldGVNYW55T3B0aW9ucykgOlxuICAgICAgY29tcGxldGVNYW55KF90aGlzLm1vZGVsLCBkb2NzLCBmaWVsZHMsIHVzZXJQcm92aWRlZEZpZWxkcywgY29tcGxldGVNYW55T3B0aW9ucyk7XG4gIH1cbiAgY29uc3QgcG9wID0gaGVscGVycy5wcmVwYXJlUG9wdWxhdGlvbk9wdGlvbnNNUShfdGhpcywgbW9uZ29vc2VPcHRpb25zKTtcblxuICBpZiAobW9uZ29vc2VPcHRpb25zLmxlYW4pIHtcbiAgICByZXR1cm4gX3RoaXMubW9kZWwucG9wdWxhdGUoZG9jcywgcG9wKTtcbiAgfVxuXG4gIGRvY3MgPSBhd2FpdCBjb21wbGV0ZU1hbnkoX3RoaXMubW9kZWwsIGRvY3MsIGZpZWxkcywgdXNlclByb3ZpZGVkRmllbGRzLCBjb21wbGV0ZU1hbnlPcHRpb25zKTtcbiAgYXdhaXQgdGhpcy5tb2RlbC5wb3B1bGF0ZShkb2NzLCBwb3ApO1xuXG4gIHJldHVybiBkb2NzO1xufTtcblxuLyoqXG4gKiBGaW5kIGFsbCBkb2N1bWVudHMgdGhhdCBtYXRjaCBgc2VsZWN0b3JgLiBUaGUgcmVzdWx0IHdpbGwgYmUgYW4gYXJyYXkgb2YgZG9jdW1lbnRzLlxuICpcbiAqIElmIHRoZXJlIGFyZSB0b28gbWFueSBkb2N1bWVudHMgaW4gdGhlIHJlc3VsdCB0byBmaXQgaW4gbWVtb3J5LCB1c2VcbiAqIFtgUXVlcnkucHJvdG90eXBlLmN1cnNvcigpYF0oaHR0cHM6Ly9tb25nb29zZWpzLmNvbS9kb2NzL2FwaS9xdWVyeS5odG1sI1F1ZXJ5LnByb3RvdHlwZS5jdXJzb3IoKSlcbiAqXG4gKiAjIyMjIEV4YW1wbGU6XG4gKlxuICogICAgIGNvbnN0IGFyciA9IGF3YWl0IE1vdmllLmZpbmQoeyB5ZWFyOiB7ICRndGU6IDE5ODAsICRsdGU6IDE5ODkgfSB9KTtcbiAqXG4gKiBAcGFyYW0ge09iamVjdHxPYmplY3RJZH0gW2ZpbHRlcl0gbW9uZ29kYiBmaWx0ZXIuIElmIG5vdCBzcGVjaWZpZWQsIHJldHVybnMgYWxsIGRvY3VtZW50cy5cbiAqIEByZXR1cm4ge1F1ZXJ5fSB0aGlzXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cblF1ZXJ5LnByb3RvdHlwZS5maW5kID0gZnVuY3Rpb24oY29uZGl0aW9ucykge1xuICBpZiAodHlwZW9mIGNvbmRpdGlvbnMgPT09ICdmdW5jdGlvbicgfHxcbiAgICAgIHR5cGVvZiBhcmd1bWVudHNbMV0gPT09ICdmdW5jdGlvbicpIHtcbiAgICB0aHJvdyBuZXcgTW9uZ29vc2VFcnJvcignUXVlcnkucHJvdG90eXBlLmZpbmQoKSBubyBsb25nZXIgYWNjZXB0cyBhIGNhbGxiYWNrJyk7XG4gIH1cblxuICB0aGlzLm9wID0gJ2ZpbmQnO1xuXG4gIGlmIChtcXVlcnkuY2FuTWVyZ2UoY29uZGl0aW9ucykpIHtcbiAgICB0aGlzLm1lcmdlKGNvbmRpdGlvbnMpO1xuXG4gICAgcHJlcGFyZURpc2NyaW1pbmF0b3JDcml0ZXJpYSh0aGlzKTtcbiAgfSBlbHNlIGlmIChjb25kaXRpb25zICE9IG51bGwpIHtcbiAgICB0aGlzLmVycm9yKG5ldyBPYmplY3RQYXJhbWV0ZXJFcnJvcihjb25kaXRpb25zLCAnZmlsdGVyJywgJ2ZpbmQnKSk7XG4gIH1cblxuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogTWVyZ2VzIGFub3RoZXIgUXVlcnkgb3IgY29uZGl0aW9ucyBvYmplY3QgaW50byB0aGlzIG9uZS5cbiAqXG4gKiBXaGVuIGEgUXVlcnkgaXMgcGFzc2VkLCBjb25kaXRpb25zLCBmaWVsZCBzZWxlY3Rpb24gYW5kIG9wdGlvbnMgYXJlIG1lcmdlZC5cbiAqXG4gKiBAcGFyYW0ge1F1ZXJ5fE9iamVjdH0gc291cmNlXG4gKiBAcmV0dXJuIHtRdWVyeX0gdGhpc1xuICovXG5cblF1ZXJ5LnByb3RvdHlwZS5tZXJnZSA9IGZ1bmN0aW9uKHNvdXJjZSkge1xuICBpZiAoIXNvdXJjZSkge1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgY29uc3Qgb3B0cyA9IHsgb3ZlcndyaXRlOiB0cnVlIH07XG5cbiAgaWYgKHNvdXJjZSBpbnN0YW5jZW9mIFF1ZXJ5KSB7XG4gICAgLy8gaWYgc291cmNlIGhhcyBhIGZlYXR1cmUsIGFwcGx5IGl0IHRvIG91cnNlbHZlc1xuXG4gICAgaWYgKHNvdXJjZS5fY29uZGl0aW9ucykge1xuICAgICAgb3B0cy5vbWl0ID0ge307XG4gICAgICBpZiAodGhpcy5fY29uZGl0aW9ucyAmJiB0aGlzLl9jb25kaXRpb25zLiRhbmQgJiYgc291cmNlLl9jb25kaXRpb25zLiRhbmQpIHtcbiAgICAgICAgb3B0cy5vbWl0WyckYW5kJ10gPSB0cnVlO1xuICAgICAgICB0aGlzLl9jb25kaXRpb25zLiRhbmQgPSB0aGlzLl9jb25kaXRpb25zLiRhbmQuY29uY2F0KHNvdXJjZS5fY29uZGl0aW9ucy4kYW5kKTtcbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLl9jb25kaXRpb25zICYmIHRoaXMuX2NvbmRpdGlvbnMuJG9yICYmIHNvdXJjZS5fY29uZGl0aW9ucy4kb3IpIHtcbiAgICAgICAgb3B0cy5vbWl0Wyckb3InXSA9IHRydWU7XG4gICAgICAgIHRoaXMuX2NvbmRpdGlvbnMuJG9yID0gdGhpcy5fY29uZGl0aW9ucy4kb3IuY29uY2F0KHNvdXJjZS5fY29uZGl0aW9ucy4kb3IpO1xuICAgICAgfVxuICAgICAgdXRpbHMubWVyZ2UodGhpcy5fY29uZGl0aW9ucywgc291cmNlLl9jb25kaXRpb25zLCBvcHRzKTtcbiAgICB9XG5cbiAgICBpZiAoc291cmNlLl9maWVsZHMpIHtcbiAgICAgIHRoaXMuX2ZpZWxkcyB8fCAodGhpcy5fZmllbGRzID0ge30pO1xuICAgICAgdXRpbHMubWVyZ2UodGhpcy5fZmllbGRzLCBzb3VyY2UuX2ZpZWxkcywgb3B0cyk7XG4gICAgfVxuXG4gICAgaWYgKHNvdXJjZS5vcHRpb25zKSB7XG4gICAgICB0aGlzLm9wdGlvbnMgfHwgKHRoaXMub3B0aW9ucyA9IHt9KTtcbiAgICAgIHV0aWxzLm1lcmdlKHRoaXMub3B0aW9ucywgc291cmNlLm9wdGlvbnMsIG9wdHMpO1xuICAgIH1cblxuICAgIGlmIChzb3VyY2UuX3VwZGF0ZSkge1xuICAgICAgdGhpcy5fdXBkYXRlIHx8ICh0aGlzLl91cGRhdGUgPSB7fSk7XG4gICAgICB1dGlscy5tZXJnZUNsb25lKHRoaXMuX3VwZGF0ZSwgc291cmNlLl91cGRhdGUpO1xuICAgIH1cblxuICAgIGlmIChzb3VyY2UuX2Rpc3RpbmN0KSB7XG4gICAgICB0aGlzLl9kaXN0aW5jdCA9IHNvdXJjZS5fZGlzdGluY3Q7XG4gICAgfVxuXG4gICAgdXRpbHMubWVyZ2UodGhpcy5fbW9uZ29vc2VPcHRpb25zLCBzb3VyY2UuX21vbmdvb3NlT3B0aW9ucyk7XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfSBlbHNlIGlmICh0aGlzLm1vZGVsICE9IG51bGwgJiYgc291cmNlIGluc3RhbmNlb2YgdGhpcy5tb2RlbC5iYXNlLlR5cGVzLk9iamVjdElkKSB7XG4gICAgdXRpbHMubWVyZ2UodGhpcy5fY29uZGl0aW9ucywgeyBfaWQ6IHNvdXJjZSB9LCBvcHRzKTtcblxuICAgIHJldHVybiB0aGlzO1xuICB9IGVsc2UgaWYgKHNvdXJjZSAmJiBzb3VyY2UuJF9fKSB7XG4gICAgc291cmNlID0gc291cmNlLnRvT2JqZWN0KGludGVybmFsVG9PYmplY3RPcHRpb25zKTtcbiAgfVxuXG4gIG9wdHMub21pdCA9IHt9O1xuICBpZiAodGhpcy5fY29uZGl0aW9ucyAmJiB0aGlzLl9jb25kaXRpb25zLiRhbmQgJiYgc291cmNlLiRhbmQpIHtcbiAgICBvcHRzLm9taXRbJyRhbmQnXSA9IHRydWU7XG4gICAgdGhpcy5fY29uZGl0aW9ucy4kYW5kID0gdGhpcy5fY29uZGl0aW9ucy4kYW5kLmNvbmNhdChzb3VyY2UuJGFuZCk7XG4gIH1cbiAgaWYgKHRoaXMuX2NvbmRpdGlvbnMgJiYgdGhpcy5fY29uZGl0aW9ucy4kb3IgJiYgc291cmNlLiRvcikge1xuICAgIG9wdHMub21pdFsnJG9yJ10gPSB0cnVlO1xuICAgIHRoaXMuX2NvbmRpdGlvbnMuJG9yID0gdGhpcy5fY29uZGl0aW9ucy4kb3IuY29uY2F0KHNvdXJjZS4kb3IpO1xuICB9XG5cbiAgLy8gcGxhaW4gb2JqZWN0XG4gIHV0aWxzLm1lcmdlKHRoaXMuX2NvbmRpdGlvbnMsIHNvdXJjZSwgb3B0cyk7XG5cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIEFkZHMgYSBjb2xsYXRpb24gdG8gdGhpcyBvcCAoTW9uZ29EQiAzLjQgYW5kIHVwKVxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSB2YWx1ZVxuICogQHJldHVybiB7UXVlcnl9IHRoaXNcbiAqIEBzZWUgTW9uZ29EQiBkb2NzIGh0dHBzOi8vd3d3Lm1vbmdvZGIuY29tL2RvY3MvbWFudWFsL3JlZmVyZW5jZS9tZXRob2QvY3Vyc29yLmNvbGxhdGlvbi8jY3Vyc29yLmNvbGxhdGlvblxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5RdWVyeS5wcm90b3R5cGUuY29sbGF0aW9uID0gZnVuY3Rpb24odmFsdWUpIHtcbiAgaWYgKHRoaXMub3B0aW9ucyA9PSBudWxsKSB7XG4gICAgdGhpcy5vcHRpb25zID0ge307XG4gIH1cbiAgdGhpcy5vcHRpb25zLmNvbGxhdGlvbiA9IHZhbHVlO1xuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogSHlkcmF0ZSBhIHNpbmdsZSBkb2MgZnJvbSBgZmluZE9uZSgpYCwgYGZpbmRPbmVBbmRVcGRhdGUoKWAsIGV0Yy5cbiAqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5RdWVyeS5wcm90b3R5cGUuX2NvbXBsZXRlT25lID0gZnVuY3Rpb24oZG9jLCByZXMsIGNhbGxiYWNrKSB7XG4gIGlmICghZG9jICYmICF0aGlzLm9wdGlvbnMuaW5jbHVkZVJlc3VsdE1ldGFkYXRhKSB7XG4gICAgcmV0dXJuIGNhbGxiYWNrKG51bGwsIG51bGwpO1xuICB9XG5cbiAgY29uc3QgbW9kZWwgPSB0aGlzLm1vZGVsO1xuICBjb25zdCBwcm9qZWN0aW9uID0gY2xvbmUodGhpcy5fZmllbGRzKTtcbiAgY29uc3QgdXNlclByb3ZpZGVkRmllbGRzID0gdGhpcy5fdXNlclByb3ZpZGVkRmllbGRzIHx8IHt9O1xuICAvLyBgcG9wdWxhdGVgLCBgbGVhbmBcbiAgY29uc3QgbW9uZ29vc2VPcHRpb25zID0gdGhpcy5fbW9uZ29vc2VPcHRpb25zO1xuXG4gIGNvbnN0IG9wdGlvbnMgPSB0aGlzLm9wdGlvbnM7XG4gIGlmICghb3B0aW9ucy5sZWFuICYmIG1vbmdvb3NlT3B0aW9ucy5sZWFuKSB7XG4gICAgb3B0aW9ucy5sZWFuID0gbW9uZ29vc2VPcHRpb25zLmxlYW47XG4gIH1cblxuICBpZiAob3B0aW9ucy5leHBsYWluKSB7XG4gICAgcmV0dXJuIGNhbGxiYWNrKG51bGwsIGRvYyk7XG4gIH1cblxuICBpZiAoIW1vbmdvb3NlT3B0aW9ucy5wb3B1bGF0ZSkge1xuICAgIGNvbnN0IHZlcnNpb25LZXkgPSB0aGlzLnNjaGVtYS5vcHRpb25zLnZlcnNpb25LZXk7XG4gICAgaWYgKG1vbmdvb3NlT3B0aW9ucy5sZWFuICYmIG1vbmdvb3NlT3B0aW9ucy5sZWFuLnZlcnNpb25LZXkgPT09IGZhbHNlICYmIHZlcnNpb25LZXkpIHtcbiAgICAgIGlmICh2ZXJzaW9uS2V5IGluIGRvYykge1xuICAgICAgICBkZWxldGUgZG9jW3ZlcnNpb25LZXldO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbW9uZ29vc2VPcHRpb25zLmxlYW4gP1xuICAgICAgX2NvbXBsZXRlT25lTGVhbihtb2RlbC5zY2hlbWEsIGRvYywgbnVsbCwgcmVzLCBvcHRpb25zLCBjYWxsYmFjaykgOlxuICAgICAgY29tcGxldGVPbmUobW9kZWwsIGRvYywgcmVzLCBvcHRpb25zLCBwcm9qZWN0aW9uLCB1c2VyUHJvdmlkZWRGaWVsZHMsXG4gICAgICAgIG51bGwsIGNhbGxiYWNrKTtcbiAgfVxuXG4gIGNvbnN0IHBvcCA9IGhlbHBlcnMucHJlcGFyZVBvcHVsYXRpb25PcHRpb25zTVEodGhpcywgdGhpcy5fbW9uZ29vc2VPcHRpb25zKTtcbiAgaWYgKG1vbmdvb3NlT3B0aW9ucy5sZWFuKSB7XG4gICAgcmV0dXJuIG1vZGVsLnBvcHVsYXRlKGRvYywgcG9wKS50aGVuKFxuICAgICAgZG9jID0+IHtcbiAgICAgICAgX2NvbXBsZXRlT25lTGVhbihtb2RlbC5zY2hlbWEsIGRvYywgbnVsbCwgcmVzLCBvcHRpb25zLCBjYWxsYmFjayk7XG4gICAgICB9LFxuICAgICAgZXJyb3IgPT4ge1xuICAgICAgICBjYWxsYmFjayhlcnJvcik7XG4gICAgICB9XG4gICAgKTtcbiAgfVxuXG4gIGNvbXBsZXRlT25lKG1vZGVsLCBkb2MsIHJlcywgb3B0aW9ucywgcHJvamVjdGlvbiwgdXNlclByb3ZpZGVkRmllbGRzLCBbXSwgKGVyciwgZG9jKSA9PiB7XG4gICAgaWYgKGVyciAhPSBudWxsKSB7XG4gICAgICByZXR1cm4gY2FsbGJhY2soZXJyKTtcbiAgICB9XG4gICAgbW9kZWwucG9wdWxhdGUoZG9jLCBwb3ApLnRoZW4ocmVzID0+IHsgY2FsbGJhY2sobnVsbCwgcmVzKTsgfSwgZXJyID0+IHsgY2FsbGJhY2soZXJyKTsgfSk7XG4gIH0pO1xufTtcblxuLyoqXG4gKiBJbnRlcm5hbCBoZWxwZXIgdG8gZXhlY3V0ZSBhIGZpbmRPbmUoKSBvcGVyYXRpb25cbiAqXG4gKiBAc2VlIGZpbmRPbmUgaHR0cHM6Ly93d3cubW9uZ29kYi5jb20vZG9jcy9tYW51YWwvcmVmZXJlbmNlL21ldGhvZC9kYi5jb2xsZWN0aW9uLmZpbmRPbmUvXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5RdWVyeS5wcm90b3R5cGUuX2ZpbmRPbmUgPSBhc3luYyBmdW5jdGlvbiBfZmluZE9uZSgpIHtcbiAgdGhpcy5fY2FzdENvbmRpdGlvbnMoKTtcblxuICBpZiAodGhpcy5lcnJvcigpKSB7XG4gICAgY29uc3QgZXJyID0gdGhpcy5lcnJvcigpO1xuICAgIHRocm93IGVycjtcbiAgfVxuXG4gIGFwcGx5R2xvYmFsTWF4VGltZU1TKHRoaXMub3B0aW9ucywgdGhpcy5tb2RlbCk7XG4gIGFwcGx5R2xvYmFsRGlza1VzZSh0aGlzLm9wdGlvbnMsIHRoaXMubW9kZWwpO1xuXG4gIGNvbnN0IG9wdGlvbnMgPSB0aGlzLl9vcHRpb25zRm9yRXhlYygpO1xuXG4gIHRoaXMuX2FwcGx5VHJhbnNsYXRlQWxpYXNlcyhvcHRpb25zKTtcblxuICAvLyBkb24ndCBwYXNzIGluIHRoZSBjb25kaXRpb25zIGJlY2F1c2Ugd2UgYWxyZWFkeSBtZXJnZWQgdGhlbSBpblxuICBjb25zdCBkb2MgPSBhd2FpdCB0aGlzLm1vbmdvb3NlQ29sbGVjdGlvbi5maW5kT25lKHRoaXMuX2NvbmRpdGlvbnMsIG9wdGlvbnMpO1xuICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgIHRoaXMuX2NvbXBsZXRlT25lKGRvYywgbnVsbCwgX3dyYXBUaHVua0NhbGxiYWNrKHRoaXMsIChlcnIsIHJlcykgPT4ge1xuICAgICAgaWYgKGVycikge1xuICAgICAgICByZXR1cm4gcmVqZWN0KGVycik7XG4gICAgICB9XG4gICAgICByZXNvbHZlKHJlcyk7XG4gICAgfSkpO1xuICB9KTtcbn07XG5cbi8qKlxuICogRGVjbGFyZXMgdGhlIHF1ZXJ5IGEgZmluZE9uZSBvcGVyYXRpb24uIFdoZW4gZXhlY3V0ZWQsIHRoZSBmaXJzdCBmb3VuZCBkb2N1bWVudCBpcyBwYXNzZWQgdG8gdGhlIGNhbGxiYWNrLlxuICpcbiAqIFRoZSByZXN1bHQgb2YgdGhlIHF1ZXJ5IGlzIGEgc2luZ2xlIGRvY3VtZW50LCBvciBgbnVsbGAgaWYgbm8gZG9jdW1lbnQgd2FzIGZvdW5kLlxuICpcbiAqICogKk5vdGU6KiBgY29uZGl0aW9uc2AgaXMgb3B0aW9uYWwsIGFuZCBpZiBgY29uZGl0aW9uc2AgaXMgbnVsbCBvciB1bmRlZmluZWQsXG4gKiBtb25nb29zZSB3aWxsIHNlbmQgYW4gZW1wdHkgYGZpbmRPbmVgIGNvbW1hbmQgdG8gTW9uZ29EQiwgd2hpY2ggd2lsbCByZXR1cm5cbiAqIGFuIGFyYml0cmFyeSBkb2N1bWVudC4gSWYgeW91J3JlIHF1ZXJ5aW5nIGJ5IGBfaWRgLCB1c2UgYE1vZGVsLmZpbmRCeUlkKClgXG4gKiBpbnN0ZWFkLlxuICpcbiAqIFRoaXMgZnVuY3Rpb24gdHJpZ2dlcnMgdGhlIGZvbGxvd2luZyBtaWRkbGV3YXJlLlxuICpcbiAqIC0gYGZpbmRPbmUoKWBcbiAqXG4gKiAjIyMjIEV4YW1wbGU6XG4gKlxuICogICAgIGNvbnN0IHF1ZXJ5ID0gS2l0dGVuLndoZXJlKHsgY29sb3I6ICd3aGl0ZScgfSk7XG4gKiAgICAgY29uc3Qga2l0dGVuID0gYXdhaXQgcXVlcnkuZmluZE9uZSgpO1xuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBbZmlsdGVyXSBtb25nb2RiIHNlbGVjdG9yXG4gKiBAcGFyYW0ge09iamVjdH0gW3Byb2plY3Rpb25dIG9wdGlvbmFsIGZpZWxkcyB0byByZXR1cm5cbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gc2VlIFtgc2V0T3B0aW9ucygpYF0oaHR0cHM6Ly9tb25nb29zZWpzLmNvbS9kb2NzL2FwaS9xdWVyeS5odG1sI1F1ZXJ5LnByb3RvdHlwZS5zZXRPcHRpb25zKCkpXG4gKiBAcGFyYW0ge0Jvb2xlYW59IFtvcHRpb25zLnRyYW5zbGF0ZUFsaWFzZXM9bnVsbF0gSWYgc2V0IHRvIGB0cnVlYCwgdHJhbnNsYXRlcyBhbnkgc2NoZW1hLWRlZmluZWQgYWxpYXNlcyBpbiBgZmlsdGVyYCwgYHByb2plY3Rpb25gLCBgdXBkYXRlYCwgYW5kIGBkaXN0aW5jdGAuIFRocm93cyBhbiBlcnJvciBpZiB0aGVyZSBhcmUgYW55IGNvbmZsaWN0cyB3aGVyZSBib3RoIGFsaWFzIGFuZCByYXcgcHJvcGVydHkgYXJlIGRlZmluZWQgb24gdGhlIHNhbWUgb2JqZWN0LlxuICogQHJldHVybiB7UXVlcnl9IHRoaXNcbiAqIEBzZWUgZmluZE9uZSBodHRwczovL3d3dy5tb25nb2RiLmNvbS9kb2NzL21hbnVhbC9yZWZlcmVuY2UvbWV0aG9kL2RiLmNvbGxlY3Rpb24uZmluZE9uZS9cbiAqIEBzZWUgUXVlcnkuc2VsZWN0IGh0dHBzOi8vbW9uZ29vc2Vqcy5jb20vZG9jcy9hcGkvcXVlcnkuaHRtbCNRdWVyeS5wcm90b3R5cGUuc2VsZWN0KClcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuUXVlcnkucHJvdG90eXBlLmZpbmRPbmUgPSBmdW5jdGlvbihjb25kaXRpb25zLCBwcm9qZWN0aW9uLCBvcHRpb25zKSB7XG4gIGlmICh0eXBlb2YgY29uZGl0aW9ucyA9PT0gJ2Z1bmN0aW9uJyB8fFxuICAgICAgdHlwZW9mIHByb2plY3Rpb24gPT09ICdmdW5jdGlvbicgfHxcbiAgICAgIHR5cGVvZiBvcHRpb25zID09PSAnZnVuY3Rpb24nIHx8XG4gICAgICB0eXBlb2YgYXJndW1lbnRzWzNdID09PSAnZnVuY3Rpb24nKSB7XG4gICAgdGhyb3cgbmV3IE1vbmdvb3NlRXJyb3IoJ1F1ZXJ5LnByb3RvdHlwZS5maW5kT25lKCkgbm8gbG9uZ2VyIGFjY2VwdHMgYSBjYWxsYmFjaycpO1xuICB9XG5cbiAgdGhpcy5vcCA9ICdmaW5kT25lJztcbiAgdGhpcy5fdmFsaWRhdGVPcCgpO1xuXG4gIGlmIChvcHRpb25zKSB7XG4gICAgdGhpcy5zZXRPcHRpb25zKG9wdGlvbnMpO1xuICB9XG5cbiAgaWYgKHByb2plY3Rpb24pIHtcbiAgICB0aGlzLnNlbGVjdChwcm9qZWN0aW9uKTtcbiAgfVxuXG4gIGlmIChtcXVlcnkuY2FuTWVyZ2UoY29uZGl0aW9ucykpIHtcbiAgICB0aGlzLm1lcmdlKGNvbmRpdGlvbnMpO1xuXG4gICAgcHJlcGFyZURpc2NyaW1pbmF0b3JDcml0ZXJpYSh0aGlzKTtcbiAgfSBlbHNlIGlmIChjb25kaXRpb25zICE9IG51bGwpIHtcbiAgICB0aGlzLmVycm9yKG5ldyBPYmplY3RQYXJhbWV0ZXJFcnJvcihjb25kaXRpb25zLCAnZmlsdGVyJywgJ2ZpbmRPbmUnKSk7XG4gIH1cblxuICByZXR1cm4gdGhpcztcbn07XG5cblxuLyoqXG4gKiBFeGVjdXRlIGEgY291bnREb2N1bWVudHMgcXVlcnlcbiAqXG4gKiBAc2VlIGNvdW50RG9jdW1lbnRzIGh0dHBzOi8vbW9uZ29kYi5naXRodWIuaW8vbm9kZS1tb25nb2RiLW5hdGl2ZS80LjkvY2xhc3Nlcy9Db2xsZWN0aW9uLmh0bWwjY291bnREb2N1bWVudHNcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cblF1ZXJ5LnByb3RvdHlwZS5fY291bnREb2N1bWVudHMgPSBhc3luYyBmdW5jdGlvbiBfY291bnREb2N1bWVudHMoKSB7XG4gIHRyeSB7XG4gICAgdGhpcy5jYXN0KHRoaXMubW9kZWwpO1xuICB9IGNhdGNoIChlcnIpIHtcbiAgICB0aGlzLmVycm9yKGVycik7XG4gIH1cblxuICBpZiAodGhpcy5lcnJvcigpKSB7XG4gICAgdGhyb3cgdGhpcy5lcnJvcigpO1xuICB9XG5cbiAgYXBwbHlHbG9iYWxNYXhUaW1lTVModGhpcy5vcHRpb25zLCB0aGlzLm1vZGVsKTtcbiAgYXBwbHlHbG9iYWxEaXNrVXNlKHRoaXMub3B0aW9ucywgdGhpcy5tb2RlbCk7XG5cbiAgY29uc3Qgb3B0aW9ucyA9IHRoaXMuX29wdGlvbnNGb3JFeGVjKCk7XG5cbiAgdGhpcy5fYXBwbHlUcmFuc2xhdGVBbGlhc2VzKG9wdGlvbnMpO1xuXG4gIGNvbnN0IGNvbmRzID0gdGhpcy5fY29uZGl0aW9ucztcblxuICByZXR1cm4gdGhpcy5tb25nb29zZUNvbGxlY3Rpb24uY291bnREb2N1bWVudHMoY29uZHMsIG9wdGlvbnMpO1xufTtcblxuLyohXG4gKiBJZiBgdHJhbnNsYXRlQWxpYXNlc2Agb3B0aW9uIGlzIHNldCwgY2FsbCBgTW9kZWwudHJhbnNsYXRlQWxpYXNlcygpYFxuICogb24gdGhlIGZvbGxvd2luZyBxdWVyeSBwcm9wZXJ0aWVzOiBmaWx0ZXIsIHByb2plY3Rpb24sIHVwZGF0ZSwgZGlzdGluY3QuXG4gKi9cblxuUXVlcnkucHJvdG90eXBlLl9hcHBseVRyYW5zbGF0ZUFsaWFzZXMgPSBmdW5jdGlvbiBfYXBwbHlUcmFuc2xhdGVBbGlhc2VzKG9wdGlvbnMpIHtcbiAgbGV0IGFwcGx5VHJhbnNsYXRlQWxpYXNlcyA9IGZhbHNlO1xuICBpZiAoJ3RyYW5zbGF0ZUFsaWFzZXMnIGluIHRoaXMuX21vbmdvb3NlT3B0aW9ucykge1xuICAgIGFwcGx5VHJhbnNsYXRlQWxpYXNlcyA9IHRoaXMuX21vbmdvb3NlT3B0aW9ucy50cmFuc2xhdGVBbGlhc2VzO1xuICB9IGVsc2UgaWYgKHRoaXMubW9kZWw/LnNjaGVtYT8uX3VzZXJQcm92aWRlZE9wdGlvbnM/LnRyYW5zbGF0ZUFsaWFzZXMgIT0gbnVsbCkge1xuICAgIGFwcGx5VHJhbnNsYXRlQWxpYXNlcyA9IHRoaXMubW9kZWwuc2NoZW1hLl91c2VyUHJvdmlkZWRPcHRpb25zLnRyYW5zbGF0ZUFsaWFzZXM7XG4gIH0gZWxzZSBpZiAodGhpcy5tb2RlbD8uYmFzZT8ub3B0aW9ucz8udHJhbnNsYXRlQWxpYXNlcyAhPSBudWxsKSB7XG4gICAgYXBwbHlUcmFuc2xhdGVBbGlhc2VzID0gdGhpcy5tb2RlbC5iYXNlLm9wdGlvbnMudHJhbnNsYXRlQWxpYXNlcztcbiAgfVxuICBpZiAoIWFwcGx5VHJhbnNsYXRlQWxpYXNlcykge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIGlmICh0aGlzLm1vZGVsPy5zY2hlbWE/LmFsaWFzZXMgJiYgT2JqZWN0LmtleXModGhpcy5tb2RlbC5zY2hlbWEuYWxpYXNlcykubGVuZ3RoID4gMCkge1xuICAgIHRoaXMubW9kZWwudHJhbnNsYXRlQWxpYXNlcyh0aGlzLl9jb25kaXRpb25zLCB0cnVlKTtcbiAgICB0aGlzLm1vZGVsLnRyYW5zbGF0ZUFsaWFzZXMob3B0aW9ucy5wcm9qZWN0aW9uLCB0cnVlKTtcbiAgICB0aGlzLm1vZGVsLnRyYW5zbGF0ZUFsaWFzZXModGhpcy5fdXBkYXRlLCB0cnVlKTtcbiAgICBpZiAodGhpcy5fZGlzdGluY3QgIT0gbnVsbCAmJiB0aGlzLm1vZGVsLnNjaGVtYS5hbGlhc2VzW3RoaXMuX2Rpc3RpbmN0XSAhPSBudWxsKSB7XG4gICAgICB0aGlzLl9kaXN0aW5jdCA9IHRoaXMubW9kZWwuc2NoZW1hLmFsaWFzZXNbdGhpcy5fZGlzdGluY3RdO1xuICAgIH1cbiAgfVxufTtcblxuLyoqXG4gKiBFeGVjdXRlIGEgZXN0aW1hdGVkRG9jdW1lbnRDb3VudCgpIHF1ZXJ5XG4gKlxuICogQHNlZSBlc3RpbWF0ZWREb2N1bWVudENvdW50IGh0dHBzOi8vbW9uZ29kYi5naXRodWIuaW8vbm9kZS1tb25nb2RiLW5hdGl2ZS80LjkvY2xhc3Nlcy9Db2xsZWN0aW9uLmh0bWwjZXN0aW1hdGVkRG9jdW1lbnRDb3VudFxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuUXVlcnkucHJvdG90eXBlLl9lc3RpbWF0ZWREb2N1bWVudENvdW50ID0gYXN5bmMgZnVuY3Rpb24gX2VzdGltYXRlZERvY3VtZW50Q291bnQoKSB7XG4gIGlmICh0aGlzLmVycm9yKCkpIHtcbiAgICB0aHJvdyB0aGlzLmVycm9yKCk7XG4gIH1cblxuICBjb25zdCBvcHRpb25zID0gdGhpcy5fb3B0aW9uc0ZvckV4ZWMoKTtcblxuICByZXR1cm4gdGhpcy5tb25nb29zZUNvbGxlY3Rpb24uZXN0aW1hdGVkRG9jdW1lbnRDb3VudChvcHRpb25zKTtcbn07XG5cbi8qKlxuICogU3BlY2lmaWVzIHRoaXMgcXVlcnkgYXMgYSBgZXN0aW1hdGVkRG9jdW1lbnRDb3VudCgpYCBxdWVyeS4gRmFzdGVyIHRoYW5cbiAqIHVzaW5nIGBjb3VudERvY3VtZW50cygpYCBmb3IgbGFyZ2UgY29sbGVjdGlvbnMgYmVjYXVzZVxuICogYGVzdGltYXRlZERvY3VtZW50Q291bnQoKWAgdXNlcyBjb2xsZWN0aW9uIG1ldGFkYXRhIHJhdGhlciB0aGFuIHNjYW5uaW5nXG4gKiB0aGUgZW50aXJlIGNvbGxlY3Rpb24uXG4gKlxuICogYGVzdGltYXRlZERvY3VtZW50Q291bnQoKWAgZG9lcyAqKm5vdCoqIGFjY2VwdCBhIGZpbHRlci4gYE1vZGVsLmZpbmQoeyBmb286IGJhciB9KS5lc3RpbWF0ZWREb2N1bWVudENvdW50KClgXG4gKiBpcyBlcXVpdmFsZW50IHRvIGBNb2RlbC5maW5kKCkuZXN0aW1hdGVkRG9jdW1lbnRDb3VudCgpYFxuICpcbiAqIFRoaXMgZnVuY3Rpb24gdHJpZ2dlcnMgdGhlIGZvbGxvd2luZyBtaWRkbGV3YXJlLlxuICpcbiAqIC0gYGVzdGltYXRlZERvY3VtZW50Q291bnQoKWBcbiAqXG4gKiAjIyMjIEV4YW1wbGU6XG4gKlxuICogICAgIGF3YWl0IE1vZGVsLmZpbmQoKS5lc3RpbWF0ZWREb2N1bWVudENvdW50KCk7XG4gKlxuICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSBwYXNzZWQgdHJhbnNwYXJlbnRseSB0byB0aGUgW01vbmdvREIgZHJpdmVyXShodHRwczovL21vbmdvZGIuZ2l0aHViLmlvL25vZGUtbW9uZ29kYi1uYXRpdmUvNC45L2ludGVyZmFjZXMvRXN0aW1hdGVkRG9jdW1lbnRDb3VudE9wdGlvbnMuaHRtbClcbiAqIEByZXR1cm4ge1F1ZXJ5fSB0aGlzXG4gKiBAc2VlIGVzdGltYXRlZERvY3VtZW50Q291bnQgaHR0cHM6Ly9tb25nb2RiLmdpdGh1Yi5pby9ub2RlLW1vbmdvZGItbmF0aXZlLzQuOS9jbGFzc2VzL0NvbGxlY3Rpb24uaHRtbCNlc3RpbWF0ZWREb2N1bWVudENvdW50XG4gKiBAYXBpIHB1YmxpY1xuICovXG5cblF1ZXJ5LnByb3RvdHlwZS5lc3RpbWF0ZWREb2N1bWVudENvdW50ID0gZnVuY3Rpb24ob3B0aW9ucykge1xuICBpZiAodHlwZW9mIG9wdGlvbnMgPT09ICdmdW5jdGlvbicgfHxcbiAgICAgIHR5cGVvZiBhcmd1bWVudHNbMV0gPT09ICdmdW5jdGlvbicpIHtcbiAgICB0aHJvdyBuZXcgTW9uZ29vc2VFcnJvcignUXVlcnkucHJvdG90eXBlLmVzdGltYXRlZERvY3VtZW50Q291bnQoKSBubyBsb25nZXIgYWNjZXB0cyBhIGNhbGxiYWNrJyk7XG4gIH1cblxuICB0aGlzLm9wID0gJ2VzdGltYXRlZERvY3VtZW50Q291bnQnO1xuICB0aGlzLl92YWxpZGF0ZU9wKCk7XG5cbiAgaWYgKHR5cGVvZiBvcHRpb25zID09PSAnb2JqZWN0JyAmJiBvcHRpb25zICE9IG51bGwpIHtcbiAgICB0aGlzLnNldE9wdGlvbnMob3B0aW9ucyk7XG4gIH1cblxuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogU3BlY2lmaWVzIHRoaXMgcXVlcnkgYXMgYSBgY291bnREb2N1bWVudHMoKWAgcXVlcnkuIEJlaGF2ZXMgbGlrZSBgY291bnQoKWAsXG4gKiBleGNlcHQgaXQgYWx3YXlzIGRvZXMgYSBmdWxsIGNvbGxlY3Rpb24gc2NhbiB3aGVuIHBhc3NlZCBhbiBlbXB0eSBmaWx0ZXIgYHt9YC5cbiAqXG4gKiBUaGVyZSBhcmUgYWxzbyBtaW5vciBkaWZmZXJlbmNlcyBpbiBob3cgYGNvdW50RG9jdW1lbnRzKClgIGhhbmRsZXNcbiAqIFtgJHdoZXJlYCBhbmQgYSBjb3VwbGUgZ2Vvc3BhdGlhbCBvcGVyYXRvcnNdKGh0dHBzOi8vbW9uZ29kYi5naXRodWIuaW8vbm9kZS1tb25nb2RiLW5hdGl2ZS80LjkvY2xhc3Nlcy9Db2xsZWN0aW9uLmh0bWwjY291bnREb2N1bWVudHMpLlxuICogdmVyc3VzIGBjb3VudCgpYC5cbiAqXG4gKiBUaGlzIGZ1bmN0aW9uIHRyaWdnZXJzIHRoZSBmb2xsb3dpbmcgbWlkZGxld2FyZS5cbiAqXG4gKiAtIGBjb3VudERvY3VtZW50cygpYFxuICpcbiAqICMjIyMgRXhhbXBsZTpcbiAqXG4gKiAgICAgY29uc3QgY291bnRRdWVyeSA9IG1vZGVsLndoZXJlKHsgJ2NvbG9yJzogJ2JsYWNrJyB9KS5jb3VudERvY3VtZW50cygpO1xuICpcbiAqICAgICBxdWVyeS5jb3VudERvY3VtZW50cyh7IGNvbG9yOiAnYmxhY2snIH0pLmNvdW50KCkuZXhlYygpO1xuICpcbiAqICAgICBhd2FpdCBxdWVyeS5jb3VudERvY3VtZW50cyh7IGNvbG9yOiAnYmxhY2snIH0pO1xuICpcbiAqICAgICBxdWVyeS53aGVyZSgnY29sb3InLCAnYmxhY2snKS5jb3VudERvY3VtZW50cygpLmV4ZWMoKTtcbiAqXG4gKiBUaGUgYGNvdW50RG9jdW1lbnRzKClgIGZ1bmN0aW9uIGlzIHNpbWlsYXIgdG8gYGNvdW50KClgLCBidXQgdGhlcmUgYXJlIGFcbiAqIFtmZXcgb3BlcmF0b3JzIHRoYXQgYGNvdW50RG9jdW1lbnRzKClgIGRvZXMgbm90IHN1cHBvcnRdKGh0dHBzOi8vbW9uZ29kYi5naXRodWIuaW8vbm9kZS1tb25nb2RiLW5hdGl2ZS80LjkvY2xhc3Nlcy9Db2xsZWN0aW9uLmh0bWwjY291bnREb2N1bWVudHMpLlxuICogQmVsb3cgYXJlIHRoZSBvcGVyYXRvcnMgdGhhdCBgY291bnQoKWAgc3VwcG9ydHMgYnV0IGBjb3VudERvY3VtZW50cygpYCBkb2VzIG5vdCxcbiAqIGFuZCB0aGUgc3VnZ2VzdGVkIHJlcGxhY2VtZW50OlxuICpcbiAqIC0gYCR3aGVyZWA6IFtgJGV4cHJgXShodHRwczovL3d3dy5tb25nb2RiLmNvbS9kb2NzL21hbnVhbC9yZWZlcmVuY2Uvb3BlcmF0b3IvcXVlcnkvZXhwci8pXG4gKiAtIGAkbmVhcmA6IFtgJGdlb1dpdGhpbmBdKGh0dHBzOi8vd3d3Lm1vbmdvZGIuY29tL2RvY3MvbWFudWFsL3JlZmVyZW5jZS9vcGVyYXRvci9xdWVyeS9nZW9XaXRoaW4vKSB3aXRoIFtgJGNlbnRlcmBdKGh0dHBzOi8vd3d3Lm1vbmdvZGIuY29tL2RvY3MvbWFudWFsL3JlZmVyZW5jZS9vcGVyYXRvci9xdWVyeS9jZW50ZXIvI29wLl9TX2NlbnRlcilcbiAqIC0gYCRuZWFyU3BoZXJlYDogW2AkZ2VvV2l0aGluYF0oaHR0cHM6Ly93d3cubW9uZ29kYi5jb20vZG9jcy9tYW51YWwvcmVmZXJlbmNlL29wZXJhdG9yL3F1ZXJ5L2dlb1dpdGhpbi8pIHdpdGggW2AkY2VudGVyU3BoZXJlYF0oaHR0cHM6Ly93d3cubW9uZ29kYi5jb20vZG9jcy9tYW51YWwvcmVmZXJlbmNlL29wZXJhdG9yL3F1ZXJ5L2NlbnRlclNwaGVyZS8jb3AuX1NfY2VudGVyU3BoZXJlKVxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBbZmlsdGVyXSBtb25nb2RiIHNlbGVjdG9yXG4gKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdXG4gKiBAcmV0dXJuIHtRdWVyeX0gdGhpc1xuICogQHNlZSBjb3VudERvY3VtZW50cyBodHRwczovL21vbmdvZGIuZ2l0aHViLmlvL25vZGUtbW9uZ29kYi1uYXRpdmUvNC45L2NsYXNzZXMvQ29sbGVjdGlvbi5odG1sI2NvdW50RG9jdW1lbnRzXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cblF1ZXJ5LnByb3RvdHlwZS5jb3VudERvY3VtZW50cyA9IGZ1bmN0aW9uKGNvbmRpdGlvbnMsIG9wdGlvbnMpIHtcbiAgaWYgKHR5cGVvZiBjb25kaXRpb25zID09PSAnZnVuY3Rpb24nIHx8XG4gICAgICB0eXBlb2Ygb3B0aW9ucyA9PT0gJ2Z1bmN0aW9uJyB8fFxuICAgICAgdHlwZW9mIGFyZ3VtZW50c1syXSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHRocm93IG5ldyBNb25nb29zZUVycm9yKCdRdWVyeS5wcm90b3R5cGUuY291bnREb2N1bWVudHMoKSBubyBsb25nZXIgYWNjZXB0cyBhIGNhbGxiYWNrJyk7XG4gIH1cblxuICB0aGlzLm9wID0gJ2NvdW50RG9jdW1lbnRzJztcbiAgdGhpcy5fdmFsaWRhdGVPcCgpO1xuXG4gIGlmIChtcXVlcnkuY2FuTWVyZ2UoY29uZGl0aW9ucykpIHtcbiAgICB0aGlzLm1lcmdlKGNvbmRpdGlvbnMpO1xuICB9XG5cbiAgaWYgKHR5cGVvZiBvcHRpb25zID09PSAnb2JqZWN0JyAmJiBvcHRpb25zICE9IG51bGwpIHtcbiAgICB0aGlzLnNldE9wdGlvbnMob3B0aW9ucyk7XG4gIH1cblxuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogRXhlY3V0ZSBhIGBkaXN0aW5jdCgpYCBxdWVyeVxuICpcbiAqIEBzZWUgZGlzdGluY3QgaHR0cHM6Ly93d3cubW9uZ29kYi5jb20vZG9jcy9tYW51YWwvcmVmZXJlbmNlL21ldGhvZC9kYi5jb2xsZWN0aW9uLmRpc3RpbmN0L1xuICogQGFwaSBwcml2YXRlXG4gKi9cblxuUXVlcnkucHJvdG90eXBlLl9fZGlzdGluY3QgPSBhc3luYyBmdW5jdGlvbiBfX2Rpc3RpbmN0KCkge1xuICB0aGlzLl9jYXN0Q29uZGl0aW9ucygpO1xuXG4gIGlmICh0aGlzLmVycm9yKCkpIHtcbiAgICB0aHJvdyB0aGlzLmVycm9yKCk7XG4gIH1cblxuICBhcHBseUdsb2JhbE1heFRpbWVNUyh0aGlzLm9wdGlvbnMsIHRoaXMubW9kZWwpO1xuICBhcHBseUdsb2JhbERpc2tVc2UodGhpcy5vcHRpb25zLCB0aGlzLm1vZGVsKTtcblxuICBjb25zdCBvcHRpb25zID0gdGhpcy5fb3B0aW9uc0ZvckV4ZWMoKTtcbiAgdGhpcy5fYXBwbHlUcmFuc2xhdGVBbGlhc2VzKG9wdGlvbnMpO1xuXG4gIHJldHVybiB0aGlzLm1vbmdvb3NlQ29sbGVjdGlvbi5cbiAgICBkaXN0aW5jdCh0aGlzLl9kaXN0aW5jdCwgdGhpcy5fY29uZGl0aW9ucywgb3B0aW9ucyk7XG59O1xuXG4vKipcbiAqIERlY2xhcmVzIG9yIGV4ZWN1dGVzIGEgZGlzdGluY3QoKSBvcGVyYXRpb24uXG4gKlxuICogVGhpcyBmdW5jdGlvbiBkb2VzIG5vdCB0cmlnZ2VyIGFueSBtaWRkbGV3YXJlLlxuICpcbiAqICMjIyMgRXhhbXBsZTpcbiAqXG4gKiAgICAgZGlzdGluY3QoZmllbGQsIGNvbmRpdGlvbnMpXG4gKiAgICAgZGlzdGluY3QoZmllbGQpXG4gKiAgICAgZGlzdGluY3QoKVxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBbZmllbGRdXG4gKiBAcGFyYW0ge09iamVjdHxRdWVyeX0gW2ZpbHRlcl1cbiAqIEByZXR1cm4ge1F1ZXJ5fSB0aGlzXG4gKiBAc2VlIGRpc3RpbmN0IGh0dHBzOi8vd3d3Lm1vbmdvZGIuY29tL2RvY3MvbWFudWFsL3JlZmVyZW5jZS9tZXRob2QvZGIuY29sbGVjdGlvbi5kaXN0aW5jdC9cbiAqIEBhcGkgcHVibGljXG4gKi9cblxuUXVlcnkucHJvdG90eXBlLmRpc3RpbmN0ID0gZnVuY3Rpb24oZmllbGQsIGNvbmRpdGlvbnMpIHtcbiAgaWYgKHR5cGVvZiBmaWVsZCA9PT0gJ2Z1bmN0aW9uJyB8fFxuICAgICAgdHlwZW9mIGNvbmRpdGlvbnMgPT09ICdmdW5jdGlvbicgfHxcbiAgICAgIHR5cGVvZiBhcmd1bWVudHNbMl0gPT09ICdmdW5jdGlvbicpIHtcbiAgICB0aHJvdyBuZXcgTW9uZ29vc2VFcnJvcignUXVlcnkucHJvdG90eXBlLmRpc3RpbmN0KCkgbm8gbG9uZ2VyIGFjY2VwdHMgYSBjYWxsYmFjaycpO1xuICB9XG5cbiAgdGhpcy5vcCA9ICdkaXN0aW5jdCc7XG4gIHRoaXMuX3ZhbGlkYXRlT3AoKTtcblxuICBpZiAobXF1ZXJ5LmNhbk1lcmdlKGNvbmRpdGlvbnMpKSB7XG4gICAgdGhpcy5tZXJnZShjb25kaXRpb25zKTtcblxuICAgIHByZXBhcmVEaXNjcmltaW5hdG9yQ3JpdGVyaWEodGhpcyk7XG4gIH0gZWxzZSBpZiAoY29uZGl0aW9ucyAhPSBudWxsKSB7XG4gICAgdGhpcy5lcnJvcihuZXcgT2JqZWN0UGFyYW1ldGVyRXJyb3IoY29uZGl0aW9ucywgJ2ZpbHRlcicsICdkaXN0aW5jdCcpKTtcbiAgfVxuXG4gIGlmIChmaWVsZCAhPSBudWxsKSB7XG4gICAgdGhpcy5fZGlzdGluY3QgPSBmaWVsZDtcbiAgfVxuXG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBTZXRzIHRoZSBzb3J0IG9yZGVyXG4gKlxuICogSWYgYW4gb2JqZWN0IGlzIHBhc3NlZCwgdmFsdWVzIGFsbG93ZWQgYXJlIGBhc2NgLCBgZGVzY2AsIGBhc2NlbmRpbmdgLCBgZGVzY2VuZGluZ2AsIGAxYCwgYW5kIGAtMWAuXG4gKlxuICogSWYgYSBzdHJpbmcgaXMgcGFzc2VkLCBpdCBtdXN0IGJlIGEgc3BhY2UgZGVsaW1pdGVkIGxpc3Qgb2YgcGF0aCBuYW1lcy4gVGhlXG4gKiBzb3J0IG9yZGVyIG9mIGVhY2ggcGF0aCBpcyBhc2NlbmRpbmcgdW5sZXNzIHRoZSBwYXRoIG5hbWUgaXMgcHJlZml4ZWQgd2l0aCBgLWBcbiAqIHdoaWNoIHdpbGwgYmUgdHJlYXRlZCBhcyBkZXNjZW5kaW5nLlxuICpcbiAqICMjIyMgRXhhbXBsZTpcbiAqXG4gKiAgICAgLy8gc29ydCBieSBcImZpZWxkXCIgYXNjZW5kaW5nIGFuZCBcInRlc3RcIiBkZXNjZW5kaW5nXG4gKiAgICAgcXVlcnkuc29ydCh7IGZpZWxkOiAnYXNjJywgdGVzdDogLTEgfSk7XG4gKlxuICogICAgIC8vIGVxdWl2YWxlbnRcbiAqICAgICBxdWVyeS5zb3J0KCdmaWVsZCAtdGVzdCcpO1xuICpcbiAqICAgICAvLyBhbHNvIHBvc3NpYmxlIGlzIHRvIHVzZSBhIGFycmF5IHdpdGggYXJyYXkga2V5LXZhbHVlIHBhaXJzXG4gKiAgICAgcXVlcnkuc29ydChbWydmaWVsZCcsICdhc2MnXV0pO1xuICpcbiAqICMjIyMgTm90ZTpcbiAqXG4gKiBDYW5ub3QgYmUgdXNlZCB3aXRoIGBkaXN0aW5jdCgpYFxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fFN0cmluZ3xBcnJheTxBcnJheTwoc3RyaW5nIHwgbnVtYmVyKT4+fSBhcmdcbiAqIEByZXR1cm4ge1F1ZXJ5fSB0aGlzXG4gKiBAc2VlIGN1cnNvci5zb3J0IGh0dHBzOi8vd3d3Lm1vbmdvZGIuY29tL2RvY3MvbWFudWFsL3JlZmVyZW5jZS9tZXRob2QvY3Vyc29yLnNvcnQvXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cblF1ZXJ5LnByb3RvdHlwZS5zb3J0ID0gZnVuY3Rpb24oYXJnKSB7XG4gIGlmIChhcmd1bWVudHMubGVuZ3RoID4gMSkge1xuICAgIHRocm93IG5ldyBFcnJvcignc29ydCgpIG9ubHkgdGFrZXMgMSBBcmd1bWVudCcpO1xuICB9XG5cbiAgaWYgKHRoaXMub3B0aW9ucy5zb3J0ID09IG51bGwpIHtcbiAgICB0aGlzLm9wdGlvbnMuc29ydCA9IHt9O1xuICB9XG4gIGNvbnN0IHNvcnQgPSB0aGlzLm9wdGlvbnMuc29ydDtcbiAgaWYgKHR5cGVvZiBhcmcgPT09ICdzdHJpbmcnKSB7XG4gICAgY29uc3QgcHJvcGVydGllcyA9IGFyZy5pbmRleE9mKCcgJykgPT09IC0xID8gW2FyZ10gOiBhcmcuc3BsaXQoJyAnKTtcbiAgICBmb3IgKGxldCBwcm9wZXJ0eSBvZiBwcm9wZXJ0aWVzKSB7XG4gICAgICBjb25zdCBhc2NlbmQgPSAnLScgPT0gcHJvcGVydHlbMF0gPyAtMSA6IDE7XG4gICAgICBpZiAoYXNjZW5kID09PSAtMSkge1xuICAgICAgICBwcm9wZXJ0eSA9IHByb3BlcnR5LnNsaWNlKDEpO1xuICAgICAgfVxuICAgICAgaWYgKHNwZWNpYWxQcm9wZXJ0aWVzLmhhcyhwcm9wZXJ0eSkpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBzb3J0W3Byb3BlcnR5XSA9IGFzY2VuZDtcbiAgICB9XG4gIH0gZWxzZSBpZiAoQXJyYXkuaXNBcnJheShhcmcpKSB7XG4gICAgZm9yIChjb25zdCBwYWlyIG9mIGFyZykge1xuICAgICAgaWYgKCFBcnJheS5pc0FycmF5KHBhaXIpKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0ludmFsaWQgc29ydCgpIGFyZ3VtZW50LCBtdXN0IGJlIGFycmF5IG9mIGFycmF5cycpO1xuICAgICAgfVxuICAgICAgY29uc3Qga2V5ID0gJycgKyBwYWlyWzBdO1xuICAgICAgaWYgKHNwZWNpYWxQcm9wZXJ0aWVzLmhhcyhrZXkpKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgc29ydFtrZXldID0gX2hhbmRsZVNvcnRWYWx1ZShwYWlyWzFdLCBrZXkpO1xuICAgIH1cbiAgfSBlbHNlIGlmICh0eXBlb2YgYXJnID09PSAnb2JqZWN0JyAmJiBhcmcgIT0gbnVsbCAmJiAhKGFyZyBpbnN0YW5jZW9mIE1hcCkpIHtcbiAgICBmb3IgKGNvbnN0IGtleSBvZiBPYmplY3Qua2V5cyhhcmcpKSB7XG4gICAgICBpZiAoc3BlY2lhbFByb3BlcnRpZXMuaGFzKGtleSkpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBzb3J0W2tleV0gPSBfaGFuZGxlU29ydFZhbHVlKGFyZ1trZXldLCBrZXkpO1xuICAgIH1cbiAgfSBlbHNlIGlmIChhcmcgaW5zdGFuY2VvZiBNYXApIHtcbiAgICBmb3IgKGxldCBrZXkgb2YgYXJnLmtleXMoKSkge1xuICAgICAga2V5ID0gJycgKyBrZXk7XG4gICAgICBpZiAoc3BlY2lhbFByb3BlcnRpZXMuaGFzKGtleSkpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBzb3J0W2tleV0gPSBfaGFuZGxlU29ydFZhbHVlKGFyZy5nZXQoa2V5KSwga2V5KTtcbiAgICB9XG4gIH0gZWxzZSBpZiAoYXJnICE9IG51bGwpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdJbnZhbGlkIHNvcnQoKSBhcmd1bWVudC4gTXVzdCBiZSBhIHN0cmluZywgb2JqZWN0LCBhcnJheSwgb3IgbWFwLicpO1xuICB9XG5cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKiFcbiAqIENvbnZlcnQgc29ydCB2YWx1ZXNcbiAqL1xuXG5mdW5jdGlvbiBfaGFuZGxlU29ydFZhbHVlKHZhbCwga2V5KSB7XG4gIGlmICh2YWwgPT09IDEgfHwgdmFsID09PSAnYXNjJyB8fCB2YWwgPT09ICdhc2NlbmRpbmcnKSB7XG4gICAgcmV0dXJuIDE7XG4gIH1cbiAgaWYgKHZhbCA9PT0gLTEgfHwgdmFsID09PSAnZGVzYycgfHwgdmFsID09PSAnZGVzY2VuZGluZycpIHtcbiAgICByZXR1cm4gLTE7XG4gIH1cbiAgaWYgKHZhbD8uJG1ldGEgIT0gbnVsbCkge1xuICAgIHJldHVybiB7ICRtZXRhOiB2YWwuJG1ldGEgfTtcbiAgfVxuICB0aHJvdyBuZXcgVHlwZUVycm9yKCdJbnZhbGlkIHNvcnQgdmFsdWU6IHsgJyArIGtleSArICc6ICcgKyB2YWwgKyAnIH0nKTtcbn1cblxuLyoqXG4gKiBEZWNsYXJlIGFuZC9vciBleGVjdXRlIHRoaXMgcXVlcnkgYXMgYSBgZGVsZXRlT25lKClgIG9wZXJhdGlvbi4gV29ya3MgbGlrZVxuICogcmVtb3ZlLCBleGNlcHQgaXQgZGVsZXRlcyBhdCBtb3N0IG9uZSBkb2N1bWVudCByZWdhcmRsZXNzIG9mIHRoZSBgc2luZ2xlYFxuICogb3B0aW9uLlxuICpcbiAqIFRoaXMgZnVuY3Rpb24gdHJpZ2dlcnMgYGRlbGV0ZU9uZWAgbWlkZGxld2FyZS5cbiAqXG4gKiAjIyMjIEV4YW1wbGU6XG4gKlxuICogICAgIGF3YWl0IENoYXJhY3Rlci5kZWxldGVPbmUoeyBuYW1lOiAnRWRkYXJkIFN0YXJrJyB9KTtcbiAqXG4gKiBUaGlzIGZ1bmN0aW9uIGNhbGxzIHRoZSBNb25nb0RCIGRyaXZlcidzIFtgQ29sbGVjdGlvbiNkZWxldGVPbmUoKWAgZnVuY3Rpb25dKGh0dHBzOi8vbW9uZ29kYi5naXRodWIuaW8vbm9kZS1tb25nb2RiLW5hdGl2ZS80LjkvY2xhc3Nlcy9Db2xsZWN0aW9uLmh0bWwjZGVsZXRlT25lKS5cbiAqIFRoZSByZXR1cm5lZCBbcHJvbWlzZV0oaHR0cHM6Ly9tb25nb29zZWpzLmNvbS9kb2NzL3F1ZXJpZXMuaHRtbCkgcmVzb2x2ZXMgdG8gYW5cbiAqIG9iamVjdCB0aGF0IGNvbnRhaW5zIDMgcHJvcGVydGllczpcbiAqXG4gKiAtIGBva2A6IGAxYCBpZiBubyBlcnJvcnMgb2NjdXJyZWRcbiAqIC0gYGRlbGV0ZWRDb3VudGA6IHRoZSBudW1iZXIgb2YgZG9jdW1lbnRzIGRlbGV0ZWRcbiAqIC0gYG5gOiB0aGUgbnVtYmVyIG9mIGRvY3VtZW50cyBkZWxldGVkLiBFcXVhbCB0byBgZGVsZXRlZENvdW50YC5cbiAqXG4gKiAjIyMjIEV4YW1wbGU6XG4gKlxuICogICAgIGNvbnN0IHJlcyA9IGF3YWl0IENoYXJhY3Rlci5kZWxldGVPbmUoeyBuYW1lOiAnRWRkYXJkIFN0YXJrJyB9KTtcbiAqICAgICAvLyBgMWAgaWYgTW9uZ29EQiBkZWxldGVkIGEgZG9jLCBgMGAgaWYgbm8gZG9jcyBtYXRjaGVkIHRoZSBmaWx0ZXIgYHsgbmFtZTogLi4uIH1gXG4gKiAgICAgcmVzLmRlbGV0ZWRDb3VudDtcbiAqXG4gKiBAcGFyYW0ge09iamVjdHxRdWVyeX0gW2ZpbHRlcl0gbW9uZ29kYiBzZWxlY3RvclxuICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSBvcHRpb25hbCBzZWUgW2BRdWVyeS5wcm90b3R5cGUuc2V0T3B0aW9ucygpYF0oaHR0cHM6Ly9tb25nb29zZWpzLmNvbS9kb2NzL2FwaS9xdWVyeS5odG1sI1F1ZXJ5LnByb3RvdHlwZS5zZXRPcHRpb25zKCkpXG4gKiBAcmV0dXJuIHtRdWVyeX0gdGhpc1xuICogQHNlZSBEZWxldGVSZXN1bHQgaHR0cHM6Ly9tb25nb2RiLmdpdGh1Yi5pby9ub2RlLW1vbmdvZGItbmF0aXZlLzQuOS9pbnRlcmZhY2VzL0RlbGV0ZVJlc3VsdC5odG1sXG4gKiBAc2VlIGRlbGV0ZU9uZSBodHRwczovL21vbmdvZGIuZ2l0aHViLmlvL25vZGUtbW9uZ29kYi1uYXRpdmUvNC45L2NsYXNzZXMvQ29sbGVjdGlvbi5odG1sI2RlbGV0ZU9uZVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5RdWVyeS5wcm90b3R5cGUuZGVsZXRlT25lID0gZnVuY3Rpb24gZGVsZXRlT25lKGZpbHRlciwgb3B0aW9ucykge1xuICBpZiAodHlwZW9mIGZpbHRlciA9PT0gJ2Z1bmN0aW9uJyB8fCB0eXBlb2Ygb3B0aW9ucyA9PT0gJ2Z1bmN0aW9uJyB8fCB0eXBlb2YgYXJndW1lbnRzWzJdID09PSAnZnVuY3Rpb24nKSB7XG4gICAgdGhyb3cgbmV3IE1vbmdvb3NlRXJyb3IoJ1F1ZXJ5LnByb3RvdHlwZS5kZWxldGVPbmUoKSBubyBsb25nZXIgYWNjZXB0cyBhIGNhbGxiYWNrJyk7XG4gIH1cbiAgdGhpcy5vcCA9ICdkZWxldGVPbmUnO1xuICB0aGlzLnNldE9wdGlvbnMob3B0aW9ucyk7XG5cbiAgaWYgKG1xdWVyeS5jYW5NZXJnZShmaWx0ZXIpKSB7XG4gICAgdGhpcy5tZXJnZShmaWx0ZXIpO1xuXG4gICAgcHJlcGFyZURpc2NyaW1pbmF0b3JDcml0ZXJpYSh0aGlzKTtcbiAgfSBlbHNlIGlmIChmaWx0ZXIgIT0gbnVsbCkge1xuICAgIHRoaXMuZXJyb3IobmV3IE9iamVjdFBhcmFtZXRlckVycm9yKGZpbHRlciwgJ2ZpbHRlcicsICdkZWxldGVPbmUnKSk7XG4gIH1cblxuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogSW50ZXJuYWwgdGh1bmsgZm9yIGBkZWxldGVPbmUoKWBcbiAqXG4gKiBAbWV0aG9kIF9kZWxldGVPbmVcbiAqIEBpbnN0YW5jZVxuICogQG1lbWJlck9mIFF1ZXJ5XG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5RdWVyeS5wcm90b3R5cGUuX2RlbGV0ZU9uZSA9IGFzeW5jIGZ1bmN0aW9uIF9kZWxldGVPbmUoKSB7XG4gIHRoaXMuX2Nhc3RDb25kaXRpb25zKCk7XG5cbiAgaWYgKHRoaXMuZXJyb3IoKSAhPSBudWxsKSB7XG4gICAgdGhyb3cgdGhpcy5lcnJvcigpO1xuICB9XG5cbiAgY29uc3Qgb3B0aW9ucyA9IHRoaXMuX29wdGlvbnNGb3JFeGVjKCk7XG4gIHRoaXMuX2FwcGx5VHJhbnNsYXRlQWxpYXNlcyhvcHRpb25zKTtcblxuICByZXR1cm4gdGhpcy5tb25nb29zZUNvbGxlY3Rpb24uZGVsZXRlT25lKHRoaXMuX2NvbmRpdGlvbnMsIG9wdGlvbnMpO1xufTtcblxuLyoqXG4gKiBEZWNsYXJlIGFuZC9vciBleGVjdXRlIHRoaXMgcXVlcnkgYXMgYSBgZGVsZXRlTWFueSgpYCBvcGVyYXRpb24uIFdvcmtzIGxpa2VcbiAqIHJlbW92ZSwgZXhjZXB0IGl0IGRlbGV0ZXMgX2V2ZXJ5XyBkb2N1bWVudCB0aGF0IG1hdGNoZXMgYGZpbHRlcmAgaW4gdGhlXG4gKiBjb2xsZWN0aW9uLCByZWdhcmRsZXNzIG9mIHRoZSB2YWx1ZSBvZiBgc2luZ2xlYC5cbiAqXG4gKiBUaGlzIGZ1bmN0aW9uIHRyaWdnZXJzIGBkZWxldGVNYW55YCBtaWRkbGV3YXJlLlxuICpcbiAqICMjIyMgRXhhbXBsZTpcbiAqXG4gKiAgICAgYXdhaXQgQ2hhcmFjdGVyLmRlbGV0ZU1hbnkoeyBuYW1lOiAvU3RhcmsvLCBhZ2U6IHsgJGd0ZTogMTggfSB9KTtcbiAqXG4gKiBUaGlzIGZ1bmN0aW9uIGNhbGxzIHRoZSBNb25nb0RCIGRyaXZlcidzIFtgQ29sbGVjdGlvbiNkZWxldGVNYW55KClgIGZ1bmN0aW9uXShodHRwczovL21vbmdvZGIuZ2l0aHViLmlvL25vZGUtbW9uZ29kYi1uYXRpdmUvNC45L2NsYXNzZXMvQ29sbGVjdGlvbi5odG1sI2RlbGV0ZU1hbnkpLlxuICogVGhlIHJldHVybmVkIFtwcm9taXNlXShodHRwczovL21vbmdvb3NlanMuY29tL2RvY3MvcXVlcmllcy5odG1sKSByZXNvbHZlcyB0byBhblxuICogb2JqZWN0IHRoYXQgY29udGFpbnMgMyBwcm9wZXJ0aWVzOlxuICpcbiAqIC0gYG9rYDogYDFgIGlmIG5vIGVycm9ycyBvY2N1cnJlZFxuICogLSBgZGVsZXRlZENvdW50YDogdGhlIG51bWJlciBvZiBkb2N1bWVudHMgZGVsZXRlZFxuICogLSBgbmA6IHRoZSBudW1iZXIgb2YgZG9jdW1lbnRzIGRlbGV0ZWQuIEVxdWFsIHRvIGBkZWxldGVkQ291bnRgLlxuICpcbiAqICMjIyMgRXhhbXBsZTpcbiAqXG4gKiAgICAgY29uc3QgcmVzID0gYXdhaXQgQ2hhcmFjdGVyLmRlbGV0ZU1hbnkoeyBuYW1lOiAvU3RhcmsvLCBhZ2U6IHsgJGd0ZTogMTggfSB9KTtcbiAqICAgICAvLyBgMGAgaWYgbm8gZG9jcyBtYXRjaGVkIHRoZSBmaWx0ZXIsIG51bWJlciBvZiBkb2NzIGRlbGV0ZWQgb3RoZXJ3aXNlXG4gKiAgICAgcmVzLmRlbGV0ZWRDb3VudDtcbiAqXG4gKiBAcGFyYW0ge09iamVjdHxRdWVyeX0gW2ZpbHRlcl0gbW9uZ29kYiBzZWxlY3RvclxuICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSBvcHRpb25hbCBzZWUgW2BRdWVyeS5wcm90b3R5cGUuc2V0T3B0aW9ucygpYF0oaHR0cHM6Ly9tb25nb29zZWpzLmNvbS9kb2NzL2FwaS9xdWVyeS5odG1sI1F1ZXJ5LnByb3RvdHlwZS5zZXRPcHRpb25zKCkpXG4gKiBAcmV0dXJuIHtRdWVyeX0gdGhpc1xuICogQHNlZSBEZWxldGVSZXN1bHQgaHR0cHM6Ly9tb25nb2RiLmdpdGh1Yi5pby9ub2RlLW1vbmdvZGItbmF0aXZlLzQuOS9pbnRlcmZhY2VzL0RlbGV0ZVJlc3VsdC5odG1sXG4gKiBAc2VlIGRlbGV0ZU1hbnkgaHR0cHM6Ly9tb25nb2RiLmdpdGh1Yi5pby9ub2RlLW1vbmdvZGItbmF0aXZlLzQuOS9jbGFzc2VzL0NvbGxlY3Rpb24uaHRtbCNkZWxldGVNYW55XG4gKiBAYXBpIHB1YmxpY1xuICovXG5cblF1ZXJ5LnByb3RvdHlwZS5kZWxldGVNYW55ID0gZnVuY3Rpb24oZmlsdGVyLCBvcHRpb25zKSB7XG4gIGlmICh0eXBlb2YgZmlsdGVyID09PSAnZnVuY3Rpb24nIHx8IHR5cGVvZiBvcHRpb25zID09PSAnZnVuY3Rpb24nIHx8IHR5cGVvZiBhcmd1bWVudHNbMl0gPT09ICdmdW5jdGlvbicpIHtcbiAgICB0aHJvdyBuZXcgTW9uZ29vc2VFcnJvcignUXVlcnkucHJvdG90eXBlLmRlbGV0ZU1hbnkoKSBubyBsb25nZXIgYWNjZXB0cyBhIGNhbGxiYWNrJyk7XG4gIH1cbiAgdGhpcy5zZXRPcHRpb25zKG9wdGlvbnMpO1xuICB0aGlzLm9wID0gJ2RlbGV0ZU1hbnknO1xuXG4gIGlmIChtcXVlcnkuY2FuTWVyZ2UoZmlsdGVyKSkge1xuICAgIHRoaXMubWVyZ2UoZmlsdGVyKTtcblxuICAgIHByZXBhcmVEaXNjcmltaW5hdG9yQ3JpdGVyaWEodGhpcyk7XG4gIH0gZWxzZSBpZiAoZmlsdGVyICE9IG51bGwpIHtcbiAgICB0aGlzLmVycm9yKG5ldyBPYmplY3RQYXJhbWV0ZXJFcnJvcihmaWx0ZXIsICdmaWx0ZXInLCAnZGVsZXRlTWFueScpKTtcbiAgfVxuXG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBFeGVjdXRlIGEgYGRlbGV0ZU1hbnkoKWAgcXVlcnlcbiAqXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFja1xuICogQG1ldGhvZCBfZGVsZXRlTWFueVxuICogQGluc3RhbmNlXG4gKiBAbWVtYmVyT2YgUXVlcnlcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cblF1ZXJ5LnByb3RvdHlwZS5fZGVsZXRlTWFueSA9IGFzeW5jIGZ1bmN0aW9uIF9kZWxldGVNYW55KCkge1xuICB0aGlzLl9jYXN0Q29uZGl0aW9ucygpO1xuXG4gIGlmICh0aGlzLmVycm9yKCkgIT0gbnVsbCkge1xuICAgIHRocm93IHRoaXMuZXJyb3IoKTtcbiAgfVxuXG4gIGNvbnN0IG9wdGlvbnMgPSB0aGlzLl9vcHRpb25zRm9yRXhlYygpO1xuICB0aGlzLl9hcHBseVRyYW5zbGF0ZUFsaWFzZXMob3B0aW9ucyk7XG5cbiAgcmV0dXJuIHRoaXMubW9uZ29vc2VDb2xsZWN0aW9uLmRlbGV0ZU1hbnkodGhpcy5fY29uZGl0aW9ucywgb3B0aW9ucyk7XG59O1xuXG4vKipcbiAqIGh5ZHJhdGVzIGEgZG9jdW1lbnRcbiAqXG4gKiBAcGFyYW0ge01vZGVsfSBtb2RlbFxuICogQHBhcmFtIHtEb2N1bWVudH0gZG9jXG4gKiBAcGFyYW0ge09iamVjdH0gcmVzIDNyZCBwYXJhbWV0ZXIgdG8gY2FsbGJhY2tcbiAqIEBwYXJhbSB7T2JqZWN0fSBmaWVsZHNcbiAqIEBwYXJhbSB7UXVlcnl9IHNlbGZcbiAqIEBwYXJhbSB7QXJyYXl9IFtwb3BdIGFycmF5IG9mIHBhdGhzIHVzZWQgaW4gcG9wdWxhdGlvblxuICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2tcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmZ1bmN0aW9uIGNvbXBsZXRlT25lKG1vZGVsLCBkb2MsIHJlcywgb3B0aW9ucywgZmllbGRzLCB1c2VyUHJvdmlkZWRGaWVsZHMsIHBvcCwgY2FsbGJhY2spIHtcbiAgaWYgKG9wdGlvbnMuaW5jbHVkZVJlc3VsdE1ldGFkYXRhICYmIGRvYyA9PSBudWxsKSB7XG4gICAgX2luaXQobnVsbCk7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICBoZWxwZXJzLmNyZWF0ZU1vZGVsQW5kSW5pdChtb2RlbCwgZG9jLCBmaWVsZHMsIHVzZXJQcm92aWRlZEZpZWxkcywgb3B0aW9ucywgcG9wLCBfaW5pdCk7XG5cbiAgZnVuY3Rpb24gX2luaXQoZXJyLCBjYXN0ZWQpIHtcbiAgICBpZiAoZXJyKSB7XG4gICAgICByZXR1cm4gaW1tZWRpYXRlKCgpID0+IGNhbGxiYWNrKGVycikpO1xuICAgIH1cblxuXG4gICAgaWYgKG9wdGlvbnMuaW5jbHVkZVJlc3VsdE1ldGFkYXRhKSB7XG4gICAgICBpZiAoZG9jICYmIGNhc3RlZCkge1xuICAgICAgICBpZiAob3B0aW9ucy5zZXNzaW9uICE9IG51bGwpIHtcbiAgICAgICAgICBjYXN0ZWQuJHNlc3Npb24ob3B0aW9ucy5zZXNzaW9uKTtcbiAgICAgICAgfVxuICAgICAgICByZXMudmFsdWUgPSBjYXN0ZWQ7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXMudmFsdWUgPSBudWxsO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGltbWVkaWF0ZSgoKSA9PiBjYWxsYmFjayhudWxsLCByZXMpKTtcbiAgICB9XG4gICAgaWYgKG9wdGlvbnMuc2Vzc2lvbiAhPSBudWxsKSB7XG4gICAgICBjYXN0ZWQuJHNlc3Npb24ob3B0aW9ucy5zZXNzaW9uKTtcbiAgICB9XG4gICAgaW1tZWRpYXRlKCgpID0+IGNhbGxiYWNrKG51bGwsIGNhc3RlZCkpO1xuICB9XG59XG5cbi8qKlxuICogSWYgdGhlIG1vZGVsIGlzIGEgZGlzY3JpbWluYXRvciB0eXBlIGFuZCBub3Qgcm9vdCwgdGhlbiBhZGQgdGhlIGtleSAmIHZhbHVlIHRvIHRoZSBjcml0ZXJpYS5cbiAqIEBwYXJhbSB7UXVlcnl9IHF1ZXJ5XG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5mdW5jdGlvbiBwcmVwYXJlRGlzY3JpbWluYXRvckNyaXRlcmlhKHF1ZXJ5KSB7XG4gIGlmICghcXVlcnkgfHwgIXF1ZXJ5Lm1vZGVsIHx8ICFxdWVyeS5tb2RlbC5zY2hlbWEpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICBjb25zdCBzY2hlbWEgPSBxdWVyeS5tb2RlbC5zY2hlbWE7XG5cbiAgaWYgKHNjaGVtYSAmJiBzY2hlbWEuZGlzY3JpbWluYXRvck1hcHBpbmcgJiYgIXNjaGVtYS5kaXNjcmltaW5hdG9yTWFwcGluZy5pc1Jvb3QpIHtcbiAgICBxdWVyeS5fY29uZGl0aW9uc1tzY2hlbWEuZGlzY3JpbWluYXRvck1hcHBpbmcua2V5XSA9IHNjaGVtYS5kaXNjcmltaW5hdG9yTWFwcGluZy52YWx1ZTtcbiAgfVxufVxuXG4vKipcbiAqIElzc3VlcyBhIG1vbmdvZGIgYGZpbmRPbmVBbmRVcGRhdGUoKWAgY29tbWFuZC5cbiAqXG4gKiBGaW5kcyBhIG1hdGNoaW5nIGRvY3VtZW50LCB1cGRhdGVzIGl0IGFjY29yZGluZyB0byB0aGUgYHVwZGF0ZWAgYXJnLCBwYXNzaW5nIGFueSBgb3B0aW9uc2AsIGFuZCByZXR1cm5zIHRoZSBmb3VuZFxuICogZG9jdW1lbnQgKGlmIGFueSkuXG4gKlxuICogVGhpcyBmdW5jdGlvbiB0cmlnZ2VycyB0aGUgZm9sbG93aW5nIG1pZGRsZXdhcmUuXG4gKlxuICogLSBgZmluZE9uZUFuZFVwZGF0ZSgpYFxuICpcbiAqICMjIyMgQXZhaWxhYmxlIG9wdGlvbnNcbiAqXG4gKiAtIGBuZXdgOiBib29sIC0gaWYgdHJ1ZSwgcmV0dXJuIHRoZSBtb2RpZmllZCBkb2N1bWVudCByYXRoZXIgdGhhbiB0aGUgb3JpZ2luYWwuIGRlZmF1bHRzIHRvIGZhbHNlIChjaGFuZ2VkIGluIDQuMClcbiAqIC0gYHVwc2VydGA6IGJvb2wgLSBjcmVhdGVzIHRoZSBvYmplY3QgaWYgaXQgZG9lc24ndCBleGlzdC4gZGVmYXVsdHMgdG8gZmFsc2UuXG4gKiAtIGBmaWVsZHNgOiB7T2JqZWN0fFN0cmluZ30gLSBGaWVsZCBzZWxlY3Rpb24uIEVxdWl2YWxlbnQgdG8gYC5zZWxlY3QoZmllbGRzKS5maW5kT25lQW5kVXBkYXRlKClgXG4gKiAtIGBzb3J0YDogaWYgbXVsdGlwbGUgZG9jcyBhcmUgZm91bmQgYnkgdGhlIGNvbmRpdGlvbnMsIHNldHMgdGhlIHNvcnQgb3JkZXIgdG8gY2hvb3NlIHdoaWNoIGRvYyB0byB1cGRhdGVcbiAqIC0gYG1heFRpbWVNU2A6IHB1dHMgYSB0aW1lIGxpbWl0IG9uIHRoZSBxdWVyeSAtIHJlcXVpcmVzIG1vbmdvZGIgPj0gMi42LjBcbiAqIC0gYHJ1blZhbGlkYXRvcnNgOiBpZiB0cnVlLCBydW5zIFt1cGRhdGUgdmFsaWRhdG9yc10oaHR0cHM6Ly9tb25nb29zZWpzLmNvbS9kb2NzL3ZhbGlkYXRpb24uaHRtbCN1cGRhdGUtdmFsaWRhdG9ycykgb24gdGhpcyBjb21tYW5kLiBVcGRhdGUgdmFsaWRhdG9ycyB2YWxpZGF0ZSB0aGUgdXBkYXRlIG9wZXJhdGlvbiBhZ2FpbnN0IHRoZSBtb2RlbCdzIHNjaGVtYS5cbiAqIC0gYHNldERlZmF1bHRzT25JbnNlcnRgOiBgdHJ1ZWAgYnkgZGVmYXVsdC4gSWYgYHNldERlZmF1bHRzT25JbnNlcnRgIGFuZCBgdXBzZXJ0YCBhcmUgdHJ1ZSwgbW9uZ29vc2Ugd2lsbCBhcHBseSB0aGUgW2RlZmF1bHRzXShodHRwczovL21vbmdvb3NlanMuY29tL2RvY3MvZGVmYXVsdHMuaHRtbCkgc3BlY2lmaWVkIGluIHRoZSBtb2RlbCdzIHNjaGVtYSBpZiBhIG5ldyBkb2N1bWVudCBpcyBjcmVhdGVkLlxuICpcbiAqICMjIyMgRXhhbXBsZTpcbiAqXG4gKiAgICAgcXVlcnkuZmluZE9uZUFuZFVwZGF0ZShjb25kaXRpb25zLCB1cGRhdGUsIG9wdGlvbnMpICAvLyByZXR1cm5zIFF1ZXJ5XG4gKiAgICAgcXVlcnkuZmluZE9uZUFuZFVwZGF0ZShjb25kaXRpb25zLCB1cGRhdGUpICAgICAgICAgICAvLyByZXR1cm5zIFF1ZXJ5XG4gKiAgICAgcXVlcnkuZmluZE9uZUFuZFVwZGF0ZSh1cGRhdGUpICAgICAgICAgICAgICAgICAgICAgICAvLyByZXR1cm5zIFF1ZXJ5XG4gKiAgICAgcXVlcnkuZmluZE9uZUFuZFVwZGF0ZSgpICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyByZXR1cm5zIFF1ZXJ5XG4gKlxuICogQG1ldGhvZCBmaW5kT25lQW5kVXBkYXRlXG4gKiBAbWVtYmVyT2YgUXVlcnlcbiAqIEBpbnN0YW5jZVxuICogQHBhcmFtIHtPYmplY3R8UXVlcnl9IFtmaWx0ZXJdXG4gKiBAcGFyYW0ge09iamVjdH0gW2RvY11cbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc11cbiAqIEBwYXJhbSB7Qm9vbGVhbn0gW29wdGlvbnMuaW5jbHVkZVJlc3VsdE1ldGFkYXRhXSBpZiB0cnVlLCByZXR1cm5zIHRoZSBmdWxsIFtNb2RpZnlSZXN1bHQgZnJvbSB0aGUgTW9uZ29EQiBkcml2ZXJdKGh0dHBzOi8vbW9uZ29kYi5naXRodWIuaW8vbm9kZS1tb25nb2RiLW5hdGl2ZS80LjkvaW50ZXJmYWNlcy9Nb2RpZnlSZXN1bHQuaHRtbCkgcmF0aGVyIHRoYW4ganVzdCB0aGUgZG9jdW1lbnRcbiAqIEBwYXJhbSB7Qm9vbGVhbnxTdHJpbmd9IFtvcHRpb25zLnN0cmljdF0gb3ZlcndyaXRlcyB0aGUgc2NoZW1hJ3MgW3N0cmljdCBtb2RlIG9wdGlvbl0oaHR0cHM6Ly9tb25nb29zZWpzLmNvbS9kb2NzL2d1aWRlLmh0bWwjc3RyaWN0KVxuICogQHBhcmFtIHtDbGllbnRTZXNzaW9ufSBbb3B0aW9ucy5zZXNzaW9uPW51bGxdIFRoZSBzZXNzaW9uIGFzc29jaWF0ZWQgd2l0aCB0aGlzIHF1ZXJ5LiBTZWUgW3RyYW5zYWN0aW9ucyBkb2NzXShodHRwczovL21vbmdvb3NlanMuY29tL2RvY3MvdHJhbnNhY3Rpb25zLmh0bWwpLlxuICogQHBhcmFtIHtCb29sZWFufSBbb3B0aW9ucy5tdWx0aXBsZUNhc3RFcnJvcl0gYnkgZGVmYXVsdCwgbW9uZ29vc2Ugb25seSByZXR1cm5zIHRoZSBmaXJzdCBlcnJvciB0aGF0IG9jY3VycmVkIGluIGNhc3RpbmcgdGhlIHF1ZXJ5LiBUdXJuIG9uIHRoaXMgb3B0aW9uIHRvIGFnZ3JlZ2F0ZSBhbGwgdGhlIGNhc3QgZXJyb3JzLlxuICogQHBhcmFtIHtCb29sZWFufSBbb3B0aW9ucy5uZXc9ZmFsc2VdIEJ5IGRlZmF1bHQsIGBmaW5kT25lQW5kVXBkYXRlKClgIHJldHVybnMgdGhlIGRvY3VtZW50IGFzIGl0IHdhcyAqKmJlZm9yZSoqIGB1cGRhdGVgIHdhcyBhcHBsaWVkLiBJZiB5b3Ugc2V0IGBuZXc6IHRydWVgLCBgZmluZE9uZUFuZFVwZGF0ZSgpYCB3aWxsIGluc3RlYWQgZ2l2ZSB5b3UgdGhlIG9iamVjdCBhZnRlciBgdXBkYXRlYCB3YXMgYXBwbGllZC5cbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9ucy5sZWFuXSBpZiB0cnV0aHksIG1vbmdvb3NlIHdpbGwgcmV0dXJuIHRoZSBkb2N1bWVudCBhcyBhIHBsYWluIEphdmFTY3JpcHQgb2JqZWN0IHJhdGhlciB0aGFuIGEgbW9uZ29vc2UgZG9jdW1lbnQuIFNlZSBbYFF1ZXJ5LmxlYW4oKWBdKGh0dHBzOi8vbW9uZ29vc2Vqcy5jb20vZG9jcy9hcGkvcXVlcnkuaHRtbCNRdWVyeS5wcm90b3R5cGUubGVhbigpKSBhbmQgW3RoZSBNb25nb29zZSBsZWFuIHR1dG9yaWFsXShodHRwczovL21vbmdvb3NlanMuY29tL2RvY3MvdHV0b3JpYWxzL2xlYW4uaHRtbCkuXG4gKiBAcGFyYW0ge0NsaWVudFNlc3Npb259IFtvcHRpb25zLnNlc3Npb249bnVsbF0gVGhlIHNlc3Npb24gYXNzb2NpYXRlZCB3aXRoIHRoaXMgcXVlcnkuIFNlZSBbdHJhbnNhY3Rpb25zIGRvY3NdKGh0dHBzOi8vbW9uZ29vc2Vqcy5jb20vZG9jcy90cmFuc2FjdGlvbnMuaHRtbCkuXG4gKiBAcGFyYW0ge0Jvb2xlYW58U3RyaW5nfSBbb3B0aW9ucy5zdHJpY3RdIG92ZXJ3cml0ZXMgdGhlIHNjaGVtYSdzIFtzdHJpY3QgbW9kZSBvcHRpb25dKGh0dHBzOi8vbW9uZ29vc2Vqcy5jb20vZG9jcy9ndWlkZS5odG1sI3N0cmljdClcbiAqIEBwYXJhbSB7Qm9vbGVhbn0gW29wdGlvbnMudGltZXN0YW1wcz1udWxsXSBJZiBzZXQgdG8gYGZhbHNlYCBhbmQgW3NjaGVtYS1sZXZlbCB0aW1lc3RhbXBzXShodHRwczovL21vbmdvb3NlanMuY29tL2RvY3MvZ3VpZGUuaHRtbCN0aW1lc3RhbXBzKSBhcmUgZW5hYmxlZCwgc2tpcCB0aW1lc3RhbXBzIGZvciB0aGlzIHVwZGF0ZS4gTm90ZSB0aGF0IHRoaXMgYWxsb3dzIHlvdSB0byBvdmVyd3JpdGUgdGltZXN0YW1wcy4gRG9lcyBub3RoaW5nIGlmIHNjaGVtYS1sZXZlbCB0aW1lc3RhbXBzIGFyZSBub3Qgc2V0LlxuICogQHBhcmFtIHtCb29sZWFufSBbb3B0aW9ucy5yZXR1cm5PcmlnaW5hbD1udWxsXSBBbiBhbGlhcyBmb3IgdGhlIGBuZXdgIG9wdGlvbi4gYHJldHVybk9yaWdpbmFsOiBmYWxzZWAgaXMgZXF1aXZhbGVudCB0byBgbmV3OiB0cnVlYC5cbiAqIEBwYXJhbSB7Qm9vbGVhbn0gW29wdGlvbnMudHJhbnNsYXRlQWxpYXNlcz1udWxsXSBJZiBzZXQgdG8gYHRydWVgLCB0cmFuc2xhdGVzIGFueSBzY2hlbWEtZGVmaW5lZCBhbGlhc2VzIGluIGBmaWx0ZXJgLCBgcHJvamVjdGlvbmAsIGB1cGRhdGVgLCBhbmQgYGRpc3RpbmN0YC4gVGhyb3dzIGFuIGVycm9yIGlmIHRoZXJlIGFyZSBhbnkgY29uZmxpY3RzIHdoZXJlIGJvdGggYWxpYXMgYW5kIHJhdyBwcm9wZXJ0eSBhcmUgZGVmaW5lZCBvbiB0aGUgc2FtZSBvYmplY3QuXG4gKiBAc2VlIFR1dG9yaWFsIGh0dHBzOi8vbW9uZ29vc2Vqcy5jb20vZG9jcy90dXRvcmlhbHMvZmluZG9uZWFuZHVwZGF0ZS5odG1sXG4gKiBAc2VlIGZpbmRBbmRNb2RpZnkgY29tbWFuZCBodHRwczovL3d3dy5tb25nb2RiLmNvbS9kb2NzL21hbnVhbC9yZWZlcmVuY2UvY29tbWFuZC9maW5kQW5kTW9kaWZ5L1xuICogQHNlZSBNb2RpZnlSZXN1bHQgaHR0cHM6Ly9tb25nb2RiLmdpdGh1Yi5pby9ub2RlLW1vbmdvZGItbmF0aXZlLzQuOS9pbnRlcmZhY2VzL01vZGlmeVJlc3VsdC5odG1sXG4gKiBAc2VlIGZpbmRPbmVBbmRVcGRhdGUgaHR0cHM6Ly9tb25nb2RiLmdpdGh1Yi5pby9ub2RlLW1vbmdvZGItbmF0aXZlLzQuOS9jbGFzc2VzL0NvbGxlY3Rpb24uaHRtbCNmaW5kT25lQW5kVXBkYXRlXG4gKiBAcmV0dXJuIHtRdWVyeX0gdGhpc1xuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5RdWVyeS5wcm90b3R5cGUuZmluZE9uZUFuZFVwZGF0ZSA9IGZ1bmN0aW9uKGZpbHRlciwgZG9jLCBvcHRpb25zKSB7XG4gIGlmICh0eXBlb2YgZmlsdGVyID09PSAnZnVuY3Rpb24nIHx8XG4gICAgICB0eXBlb2YgZG9jID09PSAnZnVuY3Rpb24nIHx8XG4gICAgICB0eXBlb2Ygb3B0aW9ucyA9PT0gJ2Z1bmN0aW9uJyB8fFxuICAgICAgdHlwZW9mIGFyZ3VtZW50c1szXSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHRocm93IG5ldyBNb25nb29zZUVycm9yKCdRdWVyeS5wcm90b3R5cGUuZmluZE9uZUFuZFVwZGF0ZSgpIG5vIGxvbmdlciBhY2NlcHRzIGEgY2FsbGJhY2snKTtcbiAgfVxuXG4gIHRoaXMub3AgPSAnZmluZE9uZUFuZFVwZGF0ZSc7XG4gIHRoaXMuX3ZhbGlkYXRlT3AoKTtcbiAgdGhpcy5fdmFsaWRhdGUoKTtcblxuICBzd2l0Y2ggKGFyZ3VtZW50cy5sZW5ndGgpIHtcbiAgICBjYXNlIDI6XG4gICAgICBvcHRpb25zID0gdW5kZWZpbmVkO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAxOlxuICAgICAgZG9jID0gZmlsdGVyO1xuICAgICAgZmlsdGVyID0gb3B0aW9ucyA9IHVuZGVmaW5lZDtcbiAgICAgIGJyZWFrO1xuICB9XG5cbiAgaWYgKG1xdWVyeS5jYW5NZXJnZShmaWx0ZXIpKSB7XG4gICAgdGhpcy5tZXJnZShmaWx0ZXIpO1xuICB9IGVsc2UgaWYgKGZpbHRlciAhPSBudWxsKSB7XG4gICAgdGhpcy5lcnJvcihcbiAgICAgIG5ldyBPYmplY3RQYXJhbWV0ZXJFcnJvcihmaWx0ZXIsICdmaWx0ZXInLCAnZmluZE9uZUFuZFVwZGF0ZScpXG4gICAgKTtcbiAgfVxuXG4gIC8vIGFwcGx5IGRvY1xuICBpZiAoZG9jKSB7XG4gICAgdGhpcy5fbWVyZ2VVcGRhdGUoZG9jKTtcbiAgfVxuXG4gIG9wdGlvbnMgPSBvcHRpb25zID8gY2xvbmUob3B0aW9ucykgOiB7fTtcblxuICBpZiAob3B0aW9ucy5wcm9qZWN0aW9uKSB7XG4gICAgdGhpcy5zZWxlY3Qob3B0aW9ucy5wcm9qZWN0aW9uKTtcbiAgICBkZWxldGUgb3B0aW9ucy5wcm9qZWN0aW9uO1xuICB9XG4gIGlmIChvcHRpb25zLmZpZWxkcykge1xuICAgIHRoaXMuc2VsZWN0KG9wdGlvbnMuZmllbGRzKTtcbiAgICBkZWxldGUgb3B0aW9ucy5maWVsZHM7XG4gIH1cblxuICBjb25zdCByZXR1cm5PcmlnaW5hbCA9IHRoaXMgJiZcbiAgICB0aGlzLm1vZGVsICYmXG4gICAgdGhpcy5tb2RlbC5iYXNlICYmXG4gICAgdGhpcy5tb2RlbC5iYXNlLm9wdGlvbnMgJiZcbiAgICB0aGlzLm1vZGVsLmJhc2Uub3B0aW9ucy5yZXR1cm5PcmlnaW5hbDtcbiAgaWYgKG9wdGlvbnMubmV3ID09IG51bGwgJiYgb3B0aW9ucy5yZXR1cm5Eb2N1bWVudCA9PSBudWxsICYmIG9wdGlvbnMucmV0dXJuT3JpZ2luYWwgPT0gbnVsbCAmJiByZXR1cm5PcmlnaW5hbCAhPSBudWxsKSB7XG4gICAgb3B0aW9ucy5yZXR1cm5PcmlnaW5hbCA9IHJldHVybk9yaWdpbmFsO1xuICB9XG5cbiAgdGhpcy5zZXRPcHRpb25zKG9wdGlvbnMpO1xuXG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBFeGVjdXRlIGEgZmluZE9uZUFuZFVwZGF0ZSBvcGVyYXRpb25cbiAqXG4gKiBAbWV0aG9kIF9maW5kT25lQW5kVXBkYXRlXG4gKiBAbWVtYmVyT2YgUXVlcnlcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cblF1ZXJ5LnByb3RvdHlwZS5fZmluZE9uZUFuZFVwZGF0ZSA9IGFzeW5jIGZ1bmN0aW9uIF9maW5kT25lQW5kVXBkYXRlKCkge1xuICB0aGlzLl9jYXN0Q29uZGl0aW9ucygpO1xuXG4gIF9jYXN0QXJyYXlGaWx0ZXJzKHRoaXMpO1xuXG4gIGlmICh0aGlzLmVycm9yKCkpIHtcbiAgICB0aHJvdyB0aGlzLmVycm9yKCk7XG4gIH1cblxuICBhcHBseUdsb2JhbE1heFRpbWVNUyh0aGlzLm9wdGlvbnMsIHRoaXMubW9kZWwpO1xuICBhcHBseUdsb2JhbERpc2tVc2UodGhpcy5vcHRpb25zLCB0aGlzLm1vZGVsKTtcblxuICBpZiAoJ3N0cmljdCcgaW4gdGhpcy5vcHRpb25zKSB7XG4gICAgdGhpcy5fbW9uZ29vc2VPcHRpb25zLnN0cmljdCA9IHRoaXMub3B0aW9ucy5zdHJpY3Q7XG4gIH1cbiAgY29uc3Qgb3B0aW9ucyA9IHRoaXMuX29wdGlvbnNGb3JFeGVjKHRoaXMubW9kZWwpO1xuICBjb252ZXJ0TmV3VG9SZXR1cm5Eb2N1bWVudChvcHRpb25zKTtcbiAgdGhpcy5fYXBwbHlUcmFuc2xhdGVBbGlhc2VzKG9wdGlvbnMpO1xuXG4gIHRoaXMuX3VwZGF0ZSA9IHRoaXMuX2Nhc3RVcGRhdGUodGhpcy5fdXBkYXRlKTtcblxuICBjb25zdCBfb3B0cyA9IE9iamVjdC5hc3NpZ24oe30sIG9wdGlvbnMsIHtcbiAgICBzZXREZWZhdWx0c09uSW5zZXJ0OiB0aGlzLl9tb25nb29zZU9wdGlvbnMuc2V0RGVmYXVsdHNPbkluc2VydFxuICB9KTtcbiAgdGhpcy5fdXBkYXRlID0gc2V0RGVmYXVsdHNPbkluc2VydCh0aGlzLl9jb25kaXRpb25zLCB0aGlzLm1vZGVsLnNjaGVtYSxcbiAgICB0aGlzLl91cGRhdGUsIF9vcHRzKTtcblxuICBpZiAoIXRoaXMuX3VwZGF0ZSB8fCBPYmplY3Qua2V5cyh0aGlzLl91cGRhdGUpLmxlbmd0aCA9PT0gMCkge1xuICAgIGlmIChvcHRpb25zLnVwc2VydCkge1xuICAgICAgLy8gc3RpbGwgbmVlZCB0byBkbyB0aGUgdXBzZXJ0IHRvIGVtcHR5IGRvY1xuICAgICAgY29uc3QgZG9jID0gY2xvbmUodGhpcy5fdXBkYXRlKTtcbiAgICAgIGRlbGV0ZSBkb2MuX2lkO1xuICAgICAgdGhpcy5fdXBkYXRlID0geyAkc2V0OiBkb2MgfTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5fZXhlY3V0aW9uU3RhY2sgPSBudWxsO1xuICAgICAgY29uc3QgcmVzID0gYXdhaXQgdGhpcy5fZmluZE9uZSgpO1xuICAgICAgcmV0dXJuIHJlcztcbiAgICB9XG4gIH0gZWxzZSBpZiAodGhpcy5fdXBkYXRlIGluc3RhbmNlb2YgRXJyb3IpIHtcbiAgICB0aHJvdyB0aGlzLl91cGRhdGU7XG4gIH0gZWxzZSB7XG4gICAgLy8gSW4gb3JkZXIgdG8gbWFrZSBNb25nb0RCIDIuNiBoYXBweSAoc2VlXG4gICAgLy8gaHR0cHM6Ly9qaXJhLm1vbmdvZGIub3JnL2Jyb3dzZS9TRVJWRVItMTIyNjYgYW5kIHJlbGF0ZWQgaXNzdWVzKVxuICAgIC8vIGlmIHdlIGhhdmUgYW4gYWN0dWFsIHVwZGF0ZSBkb2N1bWVudCBidXQgJHNldCBpcyBlbXB0eSwganVuayB0aGUgJHNldC5cbiAgICBpZiAodGhpcy5fdXBkYXRlLiRzZXQgJiYgT2JqZWN0LmtleXModGhpcy5fdXBkYXRlLiRzZXQpLmxlbmd0aCA9PT0gMCkge1xuICAgICAgZGVsZXRlIHRoaXMuX3VwZGF0ZS4kc2V0O1xuICAgIH1cbiAgfVxuXG4gIGNvbnN0IHJ1blZhbGlkYXRvcnMgPSBfZ2V0T3B0aW9uKHRoaXMsICdydW5WYWxpZGF0b3JzJywgZmFsc2UpO1xuICBpZiAocnVuVmFsaWRhdG9ycykge1xuICAgIGF3YWl0IHRoaXMudmFsaWRhdGUodGhpcy5fdXBkYXRlLCBvcHRpb25zLCBmYWxzZSk7XG4gIH1cblxuICBpZiAodGhpcy5fdXBkYXRlLnRvQlNPTikge1xuICAgIHRoaXMuX3VwZGF0ZSA9IHRoaXMuX3VwZGF0ZS50b0JTT04oKTtcbiAgfVxuXG4gIGxldCByZXMgPSBhd2FpdCB0aGlzLm1vbmdvb3NlQ29sbGVjdGlvbi5maW5kT25lQW5kVXBkYXRlKHRoaXMuX2NvbmRpdGlvbnMsIHRoaXMuX3VwZGF0ZSwgb3B0aW9ucyk7XG4gIGZvciAoY29uc3QgZm4gb2YgdGhpcy5fdHJhbnNmb3Jtcykge1xuICAgIHJlcyA9IGZuKHJlcyk7XG4gIH1cbiAgY29uc3QgZG9jID0gIW9wdGlvbnMuaW5jbHVkZVJlc3VsdE1ldGFkYXRhID8gcmVzIDogcmVzLnZhbHVlO1xuXG4gIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgdGhpcy5fY29tcGxldGVPbmUoZG9jLCByZXMsIF93cmFwVGh1bmtDYWxsYmFjayh0aGlzLCAoZXJyLCByZXMpID0+IHtcbiAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgcmV0dXJuIHJlamVjdChlcnIpO1xuICAgICAgfVxuICAgICAgcmVzb2x2ZShyZXMpO1xuICAgIH0pKTtcbiAgfSk7XG59O1xuXG4vKipcbiAqIElzc3VlcyBhIE1vbmdvREIgW2ZpbmRPbmVBbmREZWxldGVdKGh0dHBzOi8vd3d3Lm1vbmdvZGIuY29tL2RvY3MvbWFudWFsL3JlZmVyZW5jZS9tZXRob2QvZGIuY29sbGVjdGlvbi5maW5kT25lQW5kRGVsZXRlLykgY29tbWFuZC5cbiAqXG4gKiBGaW5kcyBhIG1hdGNoaW5nIGRvY3VtZW50LCByZW1vdmVzIGl0LCBhbmQgcmV0dXJucyB0aGUgZm91bmQgZG9jdW1lbnQgKGlmIGFueSkuXG4gKlxuICogVGhpcyBmdW5jdGlvbiB0cmlnZ2VycyB0aGUgZm9sbG93aW5nIG1pZGRsZXdhcmUuXG4gKlxuICogLSBgZmluZE9uZUFuZERlbGV0ZSgpYFxuICpcbiAqICMjIyMgQXZhaWxhYmxlIG9wdGlvbnNcbiAqXG4gKiAtIGBzb3J0YDogaWYgbXVsdGlwbGUgZG9jcyBhcmUgZm91bmQgYnkgdGhlIGNvbmRpdGlvbnMsIHNldHMgdGhlIHNvcnQgb3JkZXIgdG8gY2hvb3NlIHdoaWNoIGRvYyB0byB1cGRhdGVcbiAqIC0gYG1heFRpbWVNU2A6IHB1dHMgYSB0aW1lIGxpbWl0IG9uIHRoZSBxdWVyeSAtIHJlcXVpcmVzIG1vbmdvZGIgPj0gMi42LjBcbiAqXG4gKiAjIyMjIENhbGxiYWNrIFNpZ25hdHVyZVxuICpcbiAqICAgICBmdW5jdGlvbihlcnJvciwgZG9jKSB7XG4gKiAgICAgICAvLyBlcnJvcjogYW55IGVycm9ycyB0aGF0IG9jY3VycmVkXG4gKiAgICAgICAvLyBkb2M6IHRoZSBkb2N1bWVudCBiZWZvcmUgdXBkYXRlcyBhcmUgYXBwbGllZCBpZiBgbmV3OiBmYWxzZWAsIG9yIGFmdGVyIHVwZGF0ZXMgaWYgYG5ldyA9IHRydWVgXG4gKiAgICAgfVxuICpcbiAqICMjIyMgRXhhbXBsZTpcbiAqXG4gKiAgICAgQS53aGVyZSgpLmZpbmRPbmVBbmREZWxldGUoY29uZGl0aW9ucywgb3B0aW9ucykgIC8vIHJldHVybiBRdWVyeVxuICogICAgIEEud2hlcmUoKS5maW5kT25lQW5kRGVsZXRlKGNvbmRpdGlvbnMpIC8vIHJldHVybnMgUXVlcnlcbiAqICAgICBBLndoZXJlKCkuZmluZE9uZUFuZERlbGV0ZSgpICAgICAgICAgICAvLyByZXR1cm5zIFF1ZXJ5XG4gKlxuICogQG1ldGhvZCBmaW5kT25lQW5kRGVsZXRlXG4gKiBAbWVtYmVyT2YgUXVlcnlcbiAqIEBwYXJhbSB7T2JqZWN0fSBbZmlsdGVyXVxuICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXVxuICogQHBhcmFtIHtCb29sZWFufSBbb3B0aW9ucy5pbmNsdWRlUmVzdWx0TWV0YWRhdGFdIGlmIHRydWUsIHJldHVybnMgdGhlIGZ1bGwgW01vZGlmeVJlc3VsdCBmcm9tIHRoZSBNb25nb0RCIGRyaXZlcl0oaHR0cHM6Ly9tb25nb2RiLmdpdGh1Yi5pby9ub2RlLW1vbmdvZGItbmF0aXZlLzQuOS9pbnRlcmZhY2VzL01vZGlmeVJlc3VsdC5odG1sKSByYXRoZXIgdGhhbiBqdXN0IHRoZSBkb2N1bWVudFxuICogQHBhcmFtIHtDbGllbnRTZXNzaW9ufSBbb3B0aW9ucy5zZXNzaW9uPW51bGxdIFRoZSBzZXNzaW9uIGFzc29jaWF0ZWQgd2l0aCB0aGlzIHF1ZXJ5LiBTZWUgW3RyYW5zYWN0aW9ucyBkb2NzXShodHRwczovL21vbmdvb3NlanMuY29tL2RvY3MvdHJhbnNhY3Rpb25zLmh0bWwpLlxuICogQHBhcmFtIHtCb29sZWFufFN0cmluZ30gW29wdGlvbnMuc3RyaWN0XSBvdmVyd3JpdGVzIHRoZSBzY2hlbWEncyBbc3RyaWN0IG1vZGUgb3B0aW9uXShodHRwczovL21vbmdvb3NlanMuY29tL2RvY3MvZ3VpZGUuaHRtbCNzdHJpY3QpXG4gKiBAcmV0dXJuIHtRdWVyeX0gdGhpc1xuICogQHNlZSBmaW5kQW5kTW9kaWZ5IGNvbW1hbmQgaHR0cHM6Ly93d3cubW9uZ29kYi5jb20vZG9jcy9tYW51YWwvcmVmZXJlbmNlL2NvbW1hbmQvZmluZEFuZE1vZGlmeS9cbiAqIEBhcGkgcHVibGljXG4gKi9cblxuUXVlcnkucHJvdG90eXBlLmZpbmRPbmVBbmREZWxldGUgPSBmdW5jdGlvbihmaWx0ZXIsIG9wdGlvbnMpIHtcbiAgaWYgKHR5cGVvZiBmaWx0ZXIgPT09ICdmdW5jdGlvbicgfHxcbiAgICAgIHR5cGVvZiBvcHRpb25zID09PSAnZnVuY3Rpb24nIHx8XG4gICAgICB0eXBlb2YgYXJndW1lbnRzWzJdID09PSAnZnVuY3Rpb24nKSB7XG4gICAgdGhyb3cgbmV3IE1vbmdvb3NlRXJyb3IoJ1F1ZXJ5LnByb3RvdHlwZS5maW5kT25lQW5kRGVsZXRlKCkgbm8gbG9uZ2VyIGFjY2VwdHMgYSBjYWxsYmFjaycpO1xuICB9XG5cbiAgdGhpcy5vcCA9ICdmaW5kT25lQW5kRGVsZXRlJztcbiAgdGhpcy5fdmFsaWRhdGVPcCgpO1xuICB0aGlzLl92YWxpZGF0ZSgpO1xuXG4gIGlmIChtcXVlcnkuY2FuTWVyZ2UoZmlsdGVyKSkge1xuICAgIHRoaXMubWVyZ2UoZmlsdGVyKTtcbiAgfVxuXG4gIG9wdGlvbnMgJiYgdGhpcy5zZXRPcHRpb25zKG9wdGlvbnMpO1xuXG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBFeGVjdXRlIGEgYGZpbmRPbmVBbmREZWxldGUoKWAgcXVlcnlcbiAqXG4gKiBAcmV0dXJuIHtRdWVyeX0gdGhpc1xuICogQG1ldGhvZCBfZmluZE9uZUFuZERlbGV0ZVxuICogQG1lbWJlck9mIFF1ZXJ5XG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuUXVlcnkucHJvdG90eXBlLl9maW5kT25lQW5kRGVsZXRlID0gYXN5bmMgZnVuY3Rpb24gX2ZpbmRPbmVBbmREZWxldGUoKSB7XG4gIHRoaXMuX2Nhc3RDb25kaXRpb25zKCk7XG5cbiAgaWYgKHRoaXMuZXJyb3IoKSAhPSBudWxsKSB7XG4gICAgdGhyb3cgdGhpcy5lcnJvcigpO1xuICB9XG5cbiAgY29uc3QgaW5jbHVkZVJlc3VsdE1ldGFkYXRhID0gdGhpcy5vcHRpb25zLmluY2x1ZGVSZXN1bHRNZXRhZGF0YTtcblxuICBjb25zdCBmaWx0ZXIgPSB0aGlzLl9jb25kaXRpb25zO1xuICBjb25zdCBvcHRpb25zID0gdGhpcy5fb3B0aW9uc0ZvckV4ZWModGhpcy5tb2RlbCk7XG4gIHRoaXMuX2FwcGx5VHJhbnNsYXRlQWxpYXNlcyhvcHRpb25zKTtcblxuICBsZXQgcmVzID0gYXdhaXQgdGhpcy5tb25nb29zZUNvbGxlY3Rpb24uZmluZE9uZUFuZERlbGV0ZShmaWx0ZXIsIG9wdGlvbnMpO1xuICBmb3IgKGNvbnN0IGZuIG9mIHRoaXMuX3RyYW5zZm9ybXMpIHtcbiAgICByZXMgPSBmbihyZXMpO1xuICB9XG4gIGNvbnN0IGRvYyA9ICFpbmNsdWRlUmVzdWx0TWV0YWRhdGEgPyByZXMgOiByZXMudmFsdWU7XG5cbiAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICB0aGlzLl9jb21wbGV0ZU9uZShkb2MsIHJlcywgX3dyYXBUaHVua0NhbGxiYWNrKHRoaXMsIChlcnIsIHJlcykgPT4ge1xuICAgICAgaWYgKGVycikge1xuICAgICAgICByZXR1cm4gcmVqZWN0KGVycik7XG4gICAgICB9XG4gICAgICByZXNvbHZlKHJlcyk7XG4gICAgfSkpO1xuICB9KTtcbn07XG5cbi8qKlxuICogSXNzdWVzIGEgTW9uZ29EQiBbZmluZE9uZUFuZFJlcGxhY2VdKGh0dHBzOi8vd3d3Lm1vbmdvZGIuY29tL2RvY3MvbWFudWFsL3JlZmVyZW5jZS9tZXRob2QvZGIuY29sbGVjdGlvbi5maW5kT25lQW5kUmVwbGFjZS8pIGNvbW1hbmQuXG4gKlxuICogRmluZHMgYSBtYXRjaGluZyBkb2N1bWVudCwgcmVtb3ZlcyBpdCwgYW5kIHJldHVybnMgdGhlIGZvdW5kIGRvY3VtZW50IChpZiBhbnkpLlxuICpcbiAqIFRoaXMgZnVuY3Rpb24gdHJpZ2dlcnMgdGhlIGZvbGxvd2luZyBtaWRkbGV3YXJlLlxuICpcbiAqIC0gYGZpbmRPbmVBbmRSZXBsYWNlKClgXG4gKlxuICogIyMjIyBBdmFpbGFibGUgb3B0aW9uc1xuICpcbiAqIC0gYHNvcnRgOiBpZiBtdWx0aXBsZSBkb2NzIGFyZSBmb3VuZCBieSB0aGUgY29uZGl0aW9ucywgc2V0cyB0aGUgc29ydCBvcmRlciB0byBjaG9vc2Ugd2hpY2ggZG9jIHRvIHVwZGF0ZVxuICogLSBgbWF4VGltZU1TYDogcHV0cyBhIHRpbWUgbGltaXQgb24gdGhlIHF1ZXJ5IC0gcmVxdWlyZXMgbW9uZ29kYiA+PSAyLjYuMFxuICogLSBgaW5jbHVkZVJlc3VsdE1ldGFkYXRhYDogaWYgdHJ1ZSwgcmV0dXJucyB0aGUgZnVsbCBbTW9kaWZ5UmVzdWx0IGZyb20gdGhlIE1vbmdvREIgZHJpdmVyXShodHRwczovL21vbmdvZGIuZ2l0aHViLmlvL25vZGUtbW9uZ29kYi1uYXRpdmUvNC45L2ludGVyZmFjZXMvTW9kaWZ5UmVzdWx0Lmh0bWwpIHJhdGhlciB0aGFuIGp1c3QgdGhlIGRvY3VtZW50XG4gKlxuICogIyMjIyBDYWxsYmFjayBTaWduYXR1cmVcbiAqXG4gKiAgICAgZnVuY3Rpb24oZXJyb3IsIGRvYykge1xuICogICAgICAgLy8gZXJyb3I6IGFueSBlcnJvcnMgdGhhdCBvY2N1cnJlZFxuICogICAgICAgLy8gZG9jOiB0aGUgZG9jdW1lbnQgYmVmb3JlIHVwZGF0ZXMgYXJlIGFwcGxpZWQgaWYgYG5ldzogZmFsc2VgLCBvciBhZnRlciB1cGRhdGVzIGlmIGBuZXcgPSB0cnVlYFxuICogICAgIH1cbiAqXG4gKiAjIyMjIEV4YW1wbGU6XG4gKlxuICogICAgIEEud2hlcmUoKS5maW5kT25lQW5kUmVwbGFjZShmaWx0ZXIsIHJlcGxhY2VtZW50LCBvcHRpb25zKTsgLy8gcmV0dXJuIFF1ZXJ5XG4gKiAgICAgQS53aGVyZSgpLmZpbmRPbmVBbmRSZXBsYWNlKGZpbHRlcik7IC8vIHJldHVybnMgUXVlcnlcbiAqICAgICBBLndoZXJlKCkuZmluZE9uZUFuZFJlcGxhY2UoKTsgLy8gcmV0dXJucyBRdWVyeVxuICpcbiAqIEBtZXRob2QgZmluZE9uZUFuZFJlcGxhY2VcbiAqIEBtZW1iZXJPZiBRdWVyeVxuICogQHBhcmFtIHtPYmplY3R9IFtmaWx0ZXJdXG4gKiBAcGFyYW0ge09iamVjdH0gW3JlcGxhY2VtZW50XVxuICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXVxuICogQHBhcmFtIHtCb29sZWFufSBbb3B0aW9ucy5pbmNsdWRlUmVzdWx0TWV0YWRhdGFdIGlmIHRydWUsIHJldHVybnMgdGhlIGZ1bGwgW01vZGlmeVJlc3VsdCBmcm9tIHRoZSBNb25nb0RCIGRyaXZlcl0oaHR0cHM6Ly9tb25nb2RiLmdpdGh1Yi5pby9ub2RlLW1vbmdvZGItbmF0aXZlLzQuOS9pbnRlcmZhY2VzL01vZGlmeVJlc3VsdC5odG1sKSByYXRoZXIgdGhhbiBqdXN0IHRoZSBkb2N1bWVudFxuICogQHBhcmFtIHtDbGllbnRTZXNzaW9ufSBbb3B0aW9ucy5zZXNzaW9uPW51bGxdIFRoZSBzZXNzaW9uIGFzc29jaWF0ZWQgd2l0aCB0aGlzIHF1ZXJ5LiBTZWUgW3RyYW5zYWN0aW9ucyBkb2NzXShodHRwczovL21vbmdvb3NlanMuY29tL2RvY3MvdHJhbnNhY3Rpb25zLmh0bWwpLlxuICogQHBhcmFtIHtCb29sZWFufFN0cmluZ30gW29wdGlvbnMuc3RyaWN0XSBvdmVyd3JpdGVzIHRoZSBzY2hlbWEncyBbc3RyaWN0IG1vZGUgb3B0aW9uXShodHRwczovL21vbmdvb3NlanMuY29tL2RvY3MvZ3VpZGUuaHRtbCNzdHJpY3QpXG4gKiBAcGFyYW0ge0Jvb2xlYW59IFtvcHRpb25zLm5ldz1mYWxzZV0gQnkgZGVmYXVsdCwgYGZpbmRPbmVBbmRVcGRhdGUoKWAgcmV0dXJucyB0aGUgZG9jdW1lbnQgYXMgaXQgd2FzICoqYmVmb3JlKiogYHVwZGF0ZWAgd2FzIGFwcGxpZWQuIElmIHlvdSBzZXQgYG5ldzogdHJ1ZWAsIGBmaW5kT25lQW5kVXBkYXRlKClgIHdpbGwgaW5zdGVhZCBnaXZlIHlvdSB0aGUgb2JqZWN0IGFmdGVyIGB1cGRhdGVgIHdhcyBhcHBsaWVkLlxuICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zLmxlYW5dIGlmIHRydXRoeSwgbW9uZ29vc2Ugd2lsbCByZXR1cm4gdGhlIGRvY3VtZW50IGFzIGEgcGxhaW4gSmF2YVNjcmlwdCBvYmplY3QgcmF0aGVyIHRoYW4gYSBtb25nb29zZSBkb2N1bWVudC4gU2VlIFtgUXVlcnkubGVhbigpYF0oaHR0cHM6Ly9tb25nb29zZWpzLmNvbS9kb2NzL2FwaS9xdWVyeS5odG1sI1F1ZXJ5LnByb3RvdHlwZS5sZWFuKCkpIGFuZCBbdGhlIE1vbmdvb3NlIGxlYW4gdHV0b3JpYWxdKGh0dHBzOi8vbW9uZ29vc2Vqcy5jb20vZG9jcy90dXRvcmlhbHMvbGVhbi5odG1sKS5cbiAqIEBwYXJhbSB7Q2xpZW50U2Vzc2lvbn0gW29wdGlvbnMuc2Vzc2lvbj1udWxsXSBUaGUgc2Vzc2lvbiBhc3NvY2lhdGVkIHdpdGggdGhpcyBxdWVyeS4gU2VlIFt0cmFuc2FjdGlvbnMgZG9jc10oaHR0cHM6Ly9tb25nb29zZWpzLmNvbS9kb2NzL3RyYW5zYWN0aW9ucy5odG1sKS5cbiAqIEBwYXJhbSB7Qm9vbGVhbnxTdHJpbmd9IFtvcHRpb25zLnN0cmljdF0gb3ZlcndyaXRlcyB0aGUgc2NoZW1hJ3MgW3N0cmljdCBtb2RlIG9wdGlvbl0oaHR0cHM6Ly9tb25nb29zZWpzLmNvbS9kb2NzL2d1aWRlLmh0bWwjc3RyaWN0KVxuICogQHBhcmFtIHtCb29sZWFufSBbb3B0aW9ucy50aW1lc3RhbXBzPW51bGxdIElmIHNldCB0byBgZmFsc2VgIGFuZCBbc2NoZW1hLWxldmVsIHRpbWVzdGFtcHNdKGh0dHBzOi8vbW9uZ29vc2Vqcy5jb20vZG9jcy9ndWlkZS5odG1sI3RpbWVzdGFtcHMpIGFyZSBlbmFibGVkLCBza2lwIHRpbWVzdGFtcHMgZm9yIHRoaXMgdXBkYXRlLiBOb3RlIHRoYXQgdGhpcyBhbGxvd3MgeW91IHRvIG92ZXJ3cml0ZSB0aW1lc3RhbXBzLiBEb2VzIG5vdGhpbmcgaWYgc2NoZW1hLWxldmVsIHRpbWVzdGFtcHMgYXJlIG5vdCBzZXQuXG4gKiBAcGFyYW0ge0Jvb2xlYW59IFtvcHRpb25zLnJldHVybk9yaWdpbmFsPW51bGxdIEFuIGFsaWFzIGZvciB0aGUgYG5ld2Agb3B0aW9uLiBgcmV0dXJuT3JpZ2luYWw6IGZhbHNlYCBpcyBlcXVpdmFsZW50IHRvIGBuZXc6IHRydWVgLlxuICogQHBhcmFtIHtCb29sZWFufSBbb3B0aW9ucy50cmFuc2xhdGVBbGlhc2VzPW51bGxdIElmIHNldCB0byBgdHJ1ZWAsIHRyYW5zbGF0ZXMgYW55IHNjaGVtYS1kZWZpbmVkIGFsaWFzZXMgaW4gYGZpbHRlcmAsIGBwcm9qZWN0aW9uYCwgYHVwZGF0ZWAsIGFuZCBgZGlzdGluY3RgLiBUaHJvd3MgYW4gZXJyb3IgaWYgdGhlcmUgYXJlIGFueSBjb25mbGljdHMgd2hlcmUgYm90aCBhbGlhcyBhbmQgcmF3IHByb3BlcnR5IGFyZSBkZWZpbmVkIG9uIHRoZSBzYW1lIG9iamVjdC5cbiAqIEByZXR1cm4ge1F1ZXJ5fSB0aGlzXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cblF1ZXJ5LnByb3RvdHlwZS5maW5kT25lQW5kUmVwbGFjZSA9IGZ1bmN0aW9uKGZpbHRlciwgcmVwbGFjZW1lbnQsIG9wdGlvbnMpIHtcbiAgaWYgKHR5cGVvZiBmaWx0ZXIgPT09ICdmdW5jdGlvbicgfHxcbiAgICAgIHR5cGVvZiByZXBsYWNlbWVudCA9PT0gJ2Z1bmN0aW9uJyB8fFxuICAgICAgdHlwZW9mIG9wdGlvbnMgPT09ICdmdW5jdGlvbicgfHxcbiAgICAgIHR5cGVvZiBhcmd1bWVudHNbNF0gPT09ICdmdW5jdGlvbicpIHtcbiAgICB0aHJvdyBuZXcgTW9uZ29vc2VFcnJvcignUXVlcnkucHJvdG90eXBlLmZpbmRPbmVBbmRSZXBsYWNlKCkgbm8gbG9uZ2VyIGFjY2VwdHMgYSBjYWxsYmFjaycpO1xuICB9XG5cbiAgdGhpcy5vcCA9ICdmaW5kT25lQW5kUmVwbGFjZSc7XG4gIHRoaXMuX3ZhbGlkYXRlT3AoKTtcbiAgdGhpcy5fdmFsaWRhdGUoKTtcblxuICBpZiAobXF1ZXJ5LmNhbk1lcmdlKGZpbHRlcikpIHtcbiAgICB0aGlzLm1lcmdlKGZpbHRlcik7XG4gIH0gZWxzZSBpZiAoZmlsdGVyICE9IG51bGwpIHtcbiAgICB0aGlzLmVycm9yKFxuICAgICAgbmV3IE9iamVjdFBhcmFtZXRlckVycm9yKGZpbHRlciwgJ2ZpbHRlcicsICdmaW5kT25lQW5kUmVwbGFjZScpXG4gICAgKTtcbiAgfVxuXG4gIGlmIChyZXBsYWNlbWVudCAhPSBudWxsKSB7XG4gICAgdGhpcy5fbWVyZ2VVcGRhdGUocmVwbGFjZW1lbnQpO1xuICB9XG5cbiAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG5cbiAgY29uc3QgcmV0dXJuT3JpZ2luYWwgPSB0aGlzICYmXG4gIHRoaXMubW9kZWwgJiZcbiAgdGhpcy5tb2RlbC5iYXNlICYmXG4gIHRoaXMubW9kZWwuYmFzZS5vcHRpb25zICYmXG4gIHRoaXMubW9kZWwuYmFzZS5vcHRpb25zLnJldHVybk9yaWdpbmFsO1xuICBpZiAob3B0aW9ucy5uZXcgPT0gbnVsbCAmJiBvcHRpb25zLnJldHVybkRvY3VtZW50ID09IG51bGwgJiYgb3B0aW9ucy5yZXR1cm5PcmlnaW5hbCA9PSBudWxsICYmIHJldHVybk9yaWdpbmFsICE9IG51bGwpIHtcbiAgICBvcHRpb25zLnJldHVybk9yaWdpbmFsID0gcmV0dXJuT3JpZ2luYWw7XG4gIH1cbiAgdGhpcy5zZXRPcHRpb25zKG9wdGlvbnMpO1xuXG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBFeGVjdXRlIGEgZmluZE9uZUFuZFJlcGxhY2UoKSBxdWVyeVxuICpcbiAqIEByZXR1cm4ge1F1ZXJ5fSB0aGlzXG4gKiBAbWV0aG9kIF9maW5kT25lQW5kUmVwbGFjZVxuICogQGluc3RhbmNlXG4gKiBAbWVtYmVyT2YgUXVlcnlcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5RdWVyeS5wcm90b3R5cGUuX2ZpbmRPbmVBbmRSZXBsYWNlID0gYXN5bmMgZnVuY3Rpb24gX2ZpbmRPbmVBbmRSZXBsYWNlKCkge1xuICB0aGlzLl9jYXN0Q29uZGl0aW9ucygpO1xuICBpZiAodGhpcy5lcnJvcigpICE9IG51bGwpIHtcbiAgICB0aHJvdyB0aGlzLmVycm9yKCk7XG4gIH1cblxuICBpZiAoJ3N0cmljdCcgaW4gdGhpcy5vcHRpb25zKSB7XG4gICAgdGhpcy5fbW9uZ29vc2VPcHRpb25zLnN0cmljdCA9IHRoaXMub3B0aW9ucy5zdHJpY3Q7XG4gICAgZGVsZXRlIHRoaXMub3B0aW9ucy5zdHJpY3Q7XG4gIH1cblxuICBjb25zdCBmaWx0ZXIgPSB0aGlzLl9jb25kaXRpb25zO1xuICBjb25zdCBvcHRpb25zID0gdGhpcy5fb3B0aW9uc0ZvckV4ZWMoKTtcbiAgdGhpcy5fYXBwbHlUcmFuc2xhdGVBbGlhc2VzKG9wdGlvbnMpO1xuICBjb252ZXJ0TmV3VG9SZXR1cm5Eb2N1bWVudChvcHRpb25zKTtcblxuICBjb25zdCBpbmNsdWRlUmVzdWx0TWV0YWRhdGEgPSB0aGlzLm9wdGlvbnMuaW5jbHVkZVJlc3VsdE1ldGFkYXRhO1xuXG4gIGNvbnN0IG1vZGVsT3B0cyA9IHsgc2tpcElkOiB0cnVlIH07XG4gIGlmICgnc3RyaWN0JyBpbiB0aGlzLl9tb25nb29zZU9wdGlvbnMpIHtcbiAgICBtb2RlbE9wdHMuc3RyaWN0ID0gdGhpcy5fbW9uZ29vc2VPcHRpb25zLnN0cmljdDtcbiAgfVxuXG4gIGNvbnN0IHJ1blZhbGlkYXRvcnMgPSBfZ2V0T3B0aW9uKHRoaXMsICdydW5WYWxpZGF0b3JzJywgZmFsc2UpO1xuXG4gIHRyeSB7XG4gICAgY29uc3QgdXBkYXRlID0gbmV3IHRoaXMubW9kZWwodGhpcy5fdXBkYXRlLCBudWxsLCBtb2RlbE9wdHMpO1xuICAgIGlmIChydW5WYWxpZGF0b3JzKSB7XG4gICAgICBhd2FpdCB1cGRhdGUudmFsaWRhdGUoKTtcbiAgICB9IGVsc2UgaWYgKHVwZGF0ZS4kX18udmFsaWRhdGlvbkVycm9yKSB7XG4gICAgICB0aHJvdyB1cGRhdGUuJF9fLnZhbGlkYXRpb25FcnJvcjtcbiAgICB9XG4gICAgdGhpcy5fdXBkYXRlID0gdXBkYXRlLnRvQlNPTigpO1xuICB9IGNhdGNoIChlcnIpIHtcbiAgICBpZiAoZXJyIGluc3RhbmNlb2YgVmFsaWRhdGlvbkVycm9yKSB7XG4gICAgICB0aHJvdyBlcnI7XG4gICAgfVxuICAgIGNvbnN0IHZhbGlkYXRpb25FcnJvciA9IG5ldyBWYWxpZGF0aW9uRXJyb3IoKTtcbiAgICB2YWxpZGF0aW9uRXJyb3IuZXJyb3JzW2Vyci5wYXRoXSA9IGVycjtcbiAgICB0aHJvdyB2YWxpZGF0aW9uRXJyb3I7XG4gIH1cblxuICBsZXQgcmVzID0gYXdhaXQgdGhpcy5tb25nb29zZUNvbGxlY3Rpb24uZmluZE9uZUFuZFJlcGxhY2UoZmlsdGVyLCB0aGlzLl91cGRhdGUsIG9wdGlvbnMpO1xuXG4gIGZvciAoY29uc3QgZm4gb2YgdGhpcy5fdHJhbnNmb3Jtcykge1xuICAgIHJlcyA9IGZuKHJlcyk7XG4gIH1cblxuICBjb25zdCBkb2MgPSAhaW5jbHVkZVJlc3VsdE1ldGFkYXRhID8gcmVzIDogcmVzLnZhbHVlO1xuICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgIHRoaXMuX2NvbXBsZXRlT25lKGRvYywgcmVzLCBfd3JhcFRodW5rQ2FsbGJhY2sodGhpcywgKGVyciwgcmVzKSA9PiB7XG4gICAgICBpZiAoZXJyKSB7XG4gICAgICAgIHJldHVybiByZWplY3QoZXJyKTtcbiAgICAgIH1cbiAgICAgIHJlc29sdmUocmVzKTtcbiAgICB9KSk7XG4gIH0pO1xufTtcblxuLyoqXG4gKiBTdXBwb3J0IHRoZSBgbmV3YCBvcHRpb24gYXMgYW4gYWx0ZXJuYXRpdmUgdG8gYHJldHVybk9yaWdpbmFsYCBmb3IgYmFja3dhcmRzXG4gKiBjb21wYXQuXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5mdW5jdGlvbiBjb252ZXJ0TmV3VG9SZXR1cm5Eb2N1bWVudChvcHRpb25zKSB7XG4gIGlmICgnbmV3JyBpbiBvcHRpb25zKSB7XG4gICAgb3B0aW9ucy5yZXR1cm5Eb2N1bWVudCA9IG9wdGlvbnNbJ25ldyddID8gJ2FmdGVyJyA6ICdiZWZvcmUnO1xuICAgIGRlbGV0ZSBvcHRpb25zWyduZXcnXTtcbiAgfVxuICBpZiAoJ3JldHVybk9yaWdpbmFsJyBpbiBvcHRpb25zKSB7XG4gICAgb3B0aW9ucy5yZXR1cm5Eb2N1bWVudCA9IG9wdGlvbnNbJ3JldHVybk9yaWdpbmFsJ10gPyAnYmVmb3JlJyA6ICdhZnRlcic7XG4gICAgZGVsZXRlIG9wdGlvbnNbJ3JldHVybk9yaWdpbmFsJ107XG4gIH1cbiAgLy8gVGVtcG9yYXJ5IHNpbmNlIGRyaXZlciA0LjAuMC1iZXRhIGRvZXMgbm90IHN1cHBvcnQgYHJldHVybkRvY3VtZW50YFxuICBpZiAodHlwZW9mIG9wdGlvbnMucmV0dXJuRG9jdW1lbnQgPT09ICdzdHJpbmcnKSB7XG4gICAgb3B0aW9ucy5yZXR1cm5PcmlnaW5hbCA9IG9wdGlvbnMucmV0dXJuRG9jdW1lbnQgPT09ICdiZWZvcmUnO1xuICB9XG59XG5cbi8qKlxuICogR2V0IG9wdGlvbnMgZnJvbSBxdWVyeSBvcHRzLCBmYWxsaW5nIGJhY2sgdG8gdGhlIGJhc2UgbW9uZ29vc2Ugb2JqZWN0LlxuICogQHBhcmFtIHtRdWVyeX0gcXVlcnlcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25cbiAqIEBwYXJhbSB7QW55fSBkZWZcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmZ1bmN0aW9uIF9nZXRPcHRpb24ocXVlcnksIG9wdGlvbiwgZGVmKSB7XG4gIGNvbnN0IG9wdHMgPSBxdWVyeS5fb3B0aW9uc0ZvckV4ZWMocXVlcnkubW9kZWwpO1xuXG4gIGlmIChvcHRpb24gaW4gb3B0cykge1xuICAgIHJldHVybiBvcHRzW29wdGlvbl07XG4gIH1cbiAgaWYgKG9wdGlvbiBpbiBxdWVyeS5tb2RlbC5iYXNlLm9wdGlvbnMpIHtcbiAgICByZXR1cm4gcXVlcnkubW9kZWwuYmFzZS5vcHRpb25zW29wdGlvbl07XG4gIH1cbiAgcmV0dXJuIGRlZjtcbn1cblxuLyohXG4gKiBpZ25vcmVcbiAqL1xuXG5mdW5jdGlvbiBfY29tcGxldGVPbmVMZWFuKHNjaGVtYSwgZG9jLCBwYXRoLCByZXMsIG9wdHMsIGNhbGxiYWNrKSB7XG4gIGlmIChvcHRzLmxlYW4gJiYgdHlwZW9mIG9wdHMubGVhbi50cmFuc2Zvcm0gPT09ICdmdW5jdGlvbicpIHtcbiAgICBvcHRzLmxlYW4udHJhbnNmb3JtKGRvYyk7XG5cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHNjaGVtYS5jaGlsZFNjaGVtYXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGNvbnN0IGNoaWxkUGF0aCA9IHBhdGggPyBwYXRoICsgJy4nICsgc2NoZW1hLmNoaWxkU2NoZW1hc1tpXS5tb2RlbC5wYXRoIDogc2NoZW1hLmNoaWxkU2NoZW1hc1tpXS5tb2RlbC5wYXRoO1xuICAgICAgY29uc3QgX3NjaGVtYSA9IHNjaGVtYS5jaGlsZFNjaGVtYXNbaV0uc2NoZW1hO1xuICAgICAgY29uc3Qgb2JqID0gbXBhdGguZ2V0KGNoaWxkUGF0aCwgZG9jKTtcbiAgICAgIGlmIChvYmogPT0gbnVsbCkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIGlmIChBcnJheS5pc0FycmF5KG9iaikpIHtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBvYmoubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICBvcHRzLmxlYW4udHJhbnNmb3JtKG9ialtpXSk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG9wdHMubGVhbi50cmFuc2Zvcm0ob2JqKTtcbiAgICAgIH1cbiAgICAgIF9jb21wbGV0ZU9uZUxlYW4oX3NjaGVtYSwgb2JqLCBjaGlsZFBhdGgsIHJlcywgb3B0cyk7XG4gICAgfVxuICAgIGlmIChjYWxsYmFjaykge1xuICAgICAgcmV0dXJuIGNhbGxiYWNrKG51bGwsIGRvYyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gIH1cbiAgaWYgKG9wdHMuaW5jbHVkZVJlc3VsdE1ldGFkYXRhKSB7XG4gICAgcmV0dXJuIGNhbGxiYWNrKG51bGwsIHJlcyk7XG4gIH1cbiAgcmV0dXJuIGNhbGxiYWNrKG51bGwsIGRvYyk7XG59XG5cbi8qIVxuICogaWdub3JlXG4gKi9cblxuZnVuY3Rpb24gX2NvbXBsZXRlTWFueUxlYW4oc2NoZW1hLCBkb2NzLCBwYXRoLCBvcHRzKSB7XG4gIGlmIChvcHRzLmxlYW4gJiYgdHlwZW9mIG9wdHMubGVhbi50cmFuc2Zvcm0gPT09ICdmdW5jdGlvbicpIHtcbiAgICBmb3IgKGNvbnN0IGRvYyBvZiBkb2NzKSB7XG4gICAgICBvcHRzLmxlYW4udHJhbnNmb3JtKGRvYyk7XG4gICAgfVxuXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzY2hlbWEuY2hpbGRTY2hlbWFzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBjb25zdCBjaGlsZFBhdGggPSBwYXRoID8gcGF0aCArICcuJyArIHNjaGVtYS5jaGlsZFNjaGVtYXNbaV0ubW9kZWwucGF0aCA6IHNjaGVtYS5jaGlsZFNjaGVtYXNbaV0ubW9kZWwucGF0aDtcbiAgICAgIGNvbnN0IF9zY2hlbWEgPSBzY2hlbWEuY2hpbGRTY2hlbWFzW2ldLnNjaGVtYTtcbiAgICAgIGxldCBkb2MgPSBtcGF0aC5nZXQoY2hpbGRQYXRoLCBkb2NzKTtcbiAgICAgIGlmIChkb2MgPT0gbnVsbCkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIGRvYyA9IGRvYy5mbGF0KCk7XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGRvYy5sZW5ndGg7IGkrKykge1xuICAgICAgICBvcHRzLmxlYW4udHJhbnNmb3JtKGRvY1tpXSk7XG4gICAgICB9XG4gICAgICBfY29tcGxldGVNYW55TGVhbihfc2NoZW1hLCBkb2MsIGNoaWxkUGF0aCwgb3B0cyk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGRvY3M7XG59XG4vKipcbiAqIE92ZXJyaWRlIG1xdWVyeS5wcm90b3R5cGUuX21lcmdlVXBkYXRlIHRvIGhhbmRsZSBtb25nb29zZSBvYmplY3RzIGluXG4gKiB1cGRhdGVzLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBkb2NcbiAqIEBtZXRob2QgX21lcmdlVXBkYXRlXG4gKiBAbWVtYmVyT2YgUXVlcnlcbiAqIEBpbnN0YW5jZVxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuUXVlcnkucHJvdG90eXBlLl9tZXJnZVVwZGF0ZSA9IGZ1bmN0aW9uKGRvYykge1xuICBpZiAoIXRoaXMuX3VwZGF0ZSkge1xuICAgIHRoaXMuX3VwZGF0ZSA9IEFycmF5LmlzQXJyYXkoZG9jKSA/IFtdIDoge307XG4gIH1cblxuICBpZiAoZG9jID09IG51bGwgfHwgKHR5cGVvZiBkb2MgPT09ICdvYmplY3QnICYmIE9iamVjdC5rZXlzKGRvYykubGVuZ3RoID09PSAwKSkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIGlmIChkb2MgaW5zdGFuY2VvZiBRdWVyeSkge1xuICAgIGlmIChBcnJheS5pc0FycmF5KHRoaXMuX3VwZGF0ZSkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignQ2Fubm90IG1peCBhcnJheSBhbmQgb2JqZWN0IHVwZGF0ZXMnKTtcbiAgICB9XG4gICAgaWYgKGRvYy5fdXBkYXRlKSB7XG4gICAgICB1dGlscy5tZXJnZUNsb25lKHRoaXMuX3VwZGF0ZSwgZG9jLl91cGRhdGUpO1xuICAgIH1cbiAgfSBlbHNlIGlmIChBcnJheS5pc0FycmF5KGRvYykpIHtcbiAgICBpZiAoIUFycmF5LmlzQXJyYXkodGhpcy5fdXBkYXRlKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdDYW5ub3QgbWl4IGFycmF5IGFuZCBvYmplY3QgdXBkYXRlcycpO1xuICAgIH1cbiAgICB0aGlzLl91cGRhdGUgPSB0aGlzLl91cGRhdGUuY29uY2F0KGRvYyk7XG4gIH0gZWxzZSB7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkodGhpcy5fdXBkYXRlKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdDYW5ub3QgbWl4IGFycmF5IGFuZCBvYmplY3QgdXBkYXRlcycpO1xuICAgIH1cbiAgICB1dGlscy5tZXJnZUNsb25lKHRoaXMuX3VwZGF0ZSwgZG9jKTtcbiAgfVxufTtcblxuLyohXG4gKiBpZ25vcmVcbiAqL1xuXG5hc3luYyBmdW5jdGlvbiBfdXBkYXRlVGh1bmsob3ApIHtcbiAgdGhpcy5fY2FzdENvbmRpdGlvbnMoKTtcblxuICBfY2FzdEFycmF5RmlsdGVycyh0aGlzKTtcblxuICBpZiAodGhpcy5lcnJvcigpICE9IG51bGwpIHtcbiAgICB0aHJvdyB0aGlzLmVycm9yKCk7XG4gIH1cblxuICBjb25zdCBjYXN0ZWRRdWVyeSA9IHRoaXMuX2NvbmRpdGlvbnM7XG4gIGNvbnN0IG9wdGlvbnMgPSB0aGlzLl9vcHRpb25zRm9yRXhlYyh0aGlzLm1vZGVsKTtcbiAgdGhpcy5fYXBwbHlUcmFuc2xhdGVBbGlhc2VzKG9wdGlvbnMpO1xuXG4gIHRoaXMuX3VwZGF0ZSA9IGNsb25lKHRoaXMuX3VwZGF0ZSwgb3B0aW9ucyk7XG4gIGNvbnN0IGlzT3ZlcndyaXRpbmcgPSBvcCA9PT0gJ3JlcGxhY2VPbmUnO1xuICBpZiAoaXNPdmVyd3JpdGluZykge1xuICAgIHRoaXMuX3VwZGF0ZSA9IG5ldyB0aGlzLm1vZGVsKHRoaXMuX3VwZGF0ZSwgbnVsbCwgdHJ1ZSk7XG4gIH0gZWxzZSB7XG4gICAgdGhpcy5fdXBkYXRlID0gdGhpcy5fY2FzdFVwZGF0ZSh0aGlzLl91cGRhdGUpO1xuXG4gICAgaWYgKHRoaXMuX3VwZGF0ZSA9PSBudWxsIHx8IE9iamVjdC5rZXlzKHRoaXMuX3VwZGF0ZSkubGVuZ3RoID09PSAwKSB7XG4gICAgICByZXR1cm4geyBhY2tub3dsZWRnZWQ6IGZhbHNlIH07XG4gICAgfVxuXG4gICAgY29uc3QgX29wdHMgPSBPYmplY3QuYXNzaWduKHt9LCBvcHRpb25zLCB7XG4gICAgICBzZXREZWZhdWx0c09uSW5zZXJ0OiB0aGlzLl9tb25nb29zZU9wdGlvbnMuc2V0RGVmYXVsdHNPbkluc2VydFxuICAgIH0pO1xuICAgIHRoaXMuX3VwZGF0ZSA9IHNldERlZmF1bHRzT25JbnNlcnQodGhpcy5fY29uZGl0aW9ucywgdGhpcy5tb2RlbC5zY2hlbWEsXG4gICAgICB0aGlzLl91cGRhdGUsIF9vcHRzKTtcbiAgfVxuXG4gIGlmIChBcnJheS5pc0FycmF5KG9wdGlvbnMuYXJyYXlGaWx0ZXJzKSkge1xuICAgIG9wdGlvbnMuYXJyYXlGaWx0ZXJzID0gcmVtb3ZlVW51c2VkQXJyYXlGaWx0ZXJzKHRoaXMuX3VwZGF0ZSwgb3B0aW9ucy5hcnJheUZpbHRlcnMpO1xuICB9XG5cbiAgY29uc3QgcnVuVmFsaWRhdG9ycyA9IF9nZXRPcHRpb24odGhpcywgJ3J1blZhbGlkYXRvcnMnLCBmYWxzZSk7XG4gIGlmIChydW5WYWxpZGF0b3JzKSB7XG4gICAgYXdhaXQgdGhpcy52YWxpZGF0ZSh0aGlzLl91cGRhdGUsIG9wdGlvbnMsIGlzT3ZlcndyaXRpbmcpO1xuICB9XG5cbiAgaWYgKHRoaXMuX3VwZGF0ZS50b0JTT04pIHtcbiAgICB0aGlzLl91cGRhdGUgPSB0aGlzLl91cGRhdGUudG9CU09OKCk7XG4gIH1cblxuICByZXR1cm4gdGhpcy5tb25nb29zZUNvbGxlY3Rpb25bb3BdKGNhc3RlZFF1ZXJ5LCB0aGlzLl91cGRhdGUsIG9wdGlvbnMpO1xufVxuXG4vKipcbiAqIE1vbmdvb3NlIGNhbGxzIHRoaXMgZnVuY3Rpb24gaW50ZXJuYWxseSB0byB2YWxpZGF0ZSB0aGUgcXVlcnkgaWZcbiAqIGBydW5WYWxpZGF0b3JzYCBpcyBzZXRcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gY2FzdGVkRG9jIHRoZSB1cGRhdGUsIGFmdGVyIGNhc3RpbmdcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIHRoZSBvcHRpb25zIGZyb20gYF9vcHRpb25zRm9yRXhlYygpYFxuICogQHBhcmFtIHtCb29sZWFufSBpc092ZXJ3cml0aW5nXG4gKiBAbWV0aG9kIHZhbGlkYXRlXG4gKiBAbWVtYmVyT2YgUXVlcnlcbiAqIEBpbnN0YW5jZVxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuUXVlcnkucHJvdG90eXBlLnZhbGlkYXRlID0gYXN5bmMgZnVuY3Rpb24gdmFsaWRhdGUoY2FzdGVkRG9jLCBvcHRpb25zLCBpc092ZXJ3cml0aW5nKSB7XG4gIGlmICh0eXBlb2YgYXJndW1lbnRzWzNdID09PSAnZnVuY3Rpb24nKSB7XG4gICAgdGhyb3cgbmV3IE1vbmdvb3NlRXJyb3IoJ1F1ZXJ5LnByb3RvdHlwZS52YWxpZGF0ZSgpIG5vIGxvbmdlciBhY2NlcHRzIGEgY2FsbGJhY2snKTtcbiAgfVxuXG4gIGF3YWl0IF9leGVjdXRlUHJlSG9va3ModGhpcywgJ3ZhbGlkYXRlJyk7XG5cbiAgaWYgKGlzT3ZlcndyaXRpbmcpIHtcbiAgICBhd2FpdCBjYXN0ZWREb2MuJHZhbGlkYXRlKCk7XG4gIH0gZWxzZSB7XG4gICAgYXdhaXQgbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgdXBkYXRlVmFsaWRhdG9ycyh0aGlzLCB0aGlzLm1vZGVsLnNjaGVtYSwgY2FzdGVkRG9jLCBvcHRpb25zLCAoZXJyKSA9PiB7XG4gICAgICAgIGlmIChlcnIgIT0gbnVsbCkge1xuICAgICAgICAgIHJldHVybiByZWplY3QoZXJyKTtcbiAgICAgICAgfVxuICAgICAgICByZXNvbHZlKCk7XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfVxuXG4gIGF3YWl0IF9leGVjdXRlUG9zdEhvb2tzKHRoaXMsIG51bGwsIG51bGwsICd2YWxpZGF0ZScpO1xufTtcblxuLyoqXG4gKiBFeGVjdXRlIGFuIHVwZGF0ZU1hbnkgcXVlcnlcbiAqXG4gKiBAc2VlIE1vZGVsLnVwZGF0ZSBodHRwczovL21vbmdvb3NlanMuY29tL2RvY3MvYXBpL21vZGVsLmh0bWwjTW9kZWwudXBkYXRlKClcbiAqIEBtZXRob2QgX3VwZGF0ZU1hbnlcbiAqIEBtZW1iZXJPZiBRdWVyeVxuICogQGluc3RhbmNlXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuUXVlcnkucHJvdG90eXBlLl91cGRhdGVNYW55ID0gYXN5bmMgZnVuY3Rpb24gX3VwZGF0ZU1hbnkoKSB7XG4gIHJldHVybiBfdXBkYXRlVGh1bmsuY2FsbCh0aGlzLCAndXBkYXRlTWFueScpO1xufTtcblxuLyoqXG4gKiBFeGVjdXRlIGFuIHVwZGF0ZU9uZSBxdWVyeVxuICpcbiAqIEBzZWUgTW9kZWwudXBkYXRlIGh0dHBzOi8vbW9uZ29vc2Vqcy5jb20vZG9jcy9hcGkvbW9kZWwuaHRtbCNNb2RlbC51cGRhdGUoKVxuICogQG1ldGhvZCBfdXBkYXRlT25lXG4gKiBAbWVtYmVyT2YgUXVlcnlcbiAqIEBpbnN0YW5jZVxuICogQGFwaSBwcml2YXRlXG4gKi9cblF1ZXJ5LnByb3RvdHlwZS5fdXBkYXRlT25lID0gYXN5bmMgZnVuY3Rpb24gX3VwZGF0ZU9uZSgpIHtcbiAgcmV0dXJuIF91cGRhdGVUaHVuay5jYWxsKHRoaXMsICd1cGRhdGVPbmUnKTtcbn07XG5cbi8qKlxuICogRXhlY3V0ZSBhIHJlcGxhY2VPbmUgcXVlcnlcbiAqXG4gKiBAc2VlIE1vZGVsLnJlcGxhY2VPbmUgaHR0cHM6Ly9tb25nb29zZWpzLmNvbS9kb2NzL2FwaS9tb2RlbC5odG1sI01vZGVsLnJlcGxhY2VPbmUoKVxuICogQG1ldGhvZCBfcmVwbGFjZU9uZVxuICogQG1lbWJlck9mIFF1ZXJ5XG4gKiBAaW5zdGFuY2VcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5RdWVyeS5wcm90b3R5cGUuX3JlcGxhY2VPbmUgPSBhc3luYyBmdW5jdGlvbiBfcmVwbGFjZU9uZSgpIHtcbiAgcmV0dXJuIF91cGRhdGVUaHVuay5jYWxsKHRoaXMsICdyZXBsYWNlT25lJyk7XG59O1xuXG4vKipcbiAqIERlY2xhcmUgYW5kL29yIGV4ZWN1dGUgdGhpcyBxdWVyeSBhcyBhbiB1cGRhdGVNYW55KCkgb3BlcmF0aW9uLlxuICogTW9uZ29EQiB3aWxsIHVwZGF0ZSBfYWxsXyBkb2N1bWVudHMgdGhhdCBtYXRjaCBgZmlsdGVyYCAoYXMgb3Bwb3NlZCB0byBqdXN0IHRoZSBmaXJzdCBvbmUpLlxuICpcbiAqICoqTm90ZSoqIHVwZGF0ZU1hbnkgd2lsbCBfbm90XyBmaXJlIHVwZGF0ZSBtaWRkbGV3YXJlLiBVc2UgYHByZSgndXBkYXRlTWFueScpYFxuICogYW5kIGBwb3N0KCd1cGRhdGVNYW55JylgIGluc3RlYWQuXG4gKlxuICogIyMjIyBFeGFtcGxlOlxuICpcbiAqICAgICBjb25zdCByZXMgPSBhd2FpdCBQZXJzb24udXBkYXRlTWFueSh7IG5hbWU6IC9TdGFyayQvIH0sIHsgaXNEZWxldGVkOiB0cnVlIH0pO1xuICogICAgIHJlcy5uOyAvLyBOdW1iZXIgb2YgZG9jdW1lbnRzIG1hdGNoZWRcbiAqICAgICByZXMubk1vZGlmaWVkOyAvLyBOdW1iZXIgb2YgZG9jdW1lbnRzIG1vZGlmaWVkXG4gKlxuICogVGhpcyBmdW5jdGlvbiB0cmlnZ2VycyB0aGUgZm9sbG93aW5nIG1pZGRsZXdhcmUuXG4gKlxuICogLSBgdXBkYXRlTWFueSgpYFxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBbZmlsdGVyXVxuICogQHBhcmFtIHtPYmplY3R8QXJyYXl9IFt1cGRhdGVdIHRoZSB1cGRhdGUgY29tbWFuZFxuICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXVxuICogQHBhcmFtIHtCb29sZWFufSBbb3B0aW9ucy5tdWx0aXBsZUNhc3RFcnJvcl0gYnkgZGVmYXVsdCwgbW9uZ29vc2Ugb25seSByZXR1cm5zIHRoZSBmaXJzdCBlcnJvciB0aGF0IG9jY3VycmVkIGluIGNhc3RpbmcgdGhlIHF1ZXJ5LiBUdXJuIG9uIHRoaXMgb3B0aW9uIHRvIGFnZ3JlZ2F0ZSBhbGwgdGhlIGNhc3QgZXJyb3JzLlxuICogQHBhcmFtIHtCb29sZWFufFN0cmluZ30gW29wdGlvbnMuc3RyaWN0XSBvdmVyd3JpdGVzIHRoZSBzY2hlbWEncyBbc3RyaWN0IG1vZGUgb3B0aW9uXShodHRwczovL21vbmdvb3NlanMuY29tL2RvY3MvZ3VpZGUuaHRtbCNzdHJpY3QpXG4gKiBAcGFyYW0ge0Jvb2xlYW59IFtvcHRpb25zLnVwc2VydD1mYWxzZV0gaWYgdHJ1ZSwgYW5kIG5vIGRvY3VtZW50cyBmb3VuZCwgaW5zZXJ0IGEgbmV3IGRvY3VtZW50XG4gKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnMud3JpdGVDb25jZXJuPW51bGxdIHNldHMgdGhlIFt3cml0ZSBjb25jZXJuXShodHRwczovL3d3dy5tb25nb2RiLmNvbS9kb2NzL21hbnVhbC9yZWZlcmVuY2Uvd3JpdGUtY29uY2Vybi8pIGZvciByZXBsaWNhIHNldHMuIE92ZXJyaWRlcyB0aGUgW3NjaGVtYS1sZXZlbCB3cml0ZSBjb25jZXJuXShodHRwczovL21vbmdvb3NlanMuY29tL2RvY3MvZ3VpZGUuaHRtbCN3cml0ZUNvbmNlcm4pXG4gKiBAcGFyYW0ge0Jvb2xlYW59IFtvcHRpb25zLnRpbWVzdGFtcHM9bnVsbF0gSWYgc2V0IHRvIGBmYWxzZWAgYW5kIFtzY2hlbWEtbGV2ZWwgdGltZXN0YW1wc10oaHR0cHM6Ly9tb25nb29zZWpzLmNvbS9kb2NzL2d1aWRlLmh0bWwjdGltZXN0YW1wcykgYXJlIGVuYWJsZWQsIHNraXAgdGltZXN0YW1wcyBmb3IgdGhpcyB1cGRhdGUuIERvZXMgbm90aGluZyBpZiBzY2hlbWEtbGV2ZWwgdGltZXN0YW1wcyBhcmUgbm90IHNldC5cbiAqIEBwYXJhbSB7Qm9vbGVhbn0gW29wdGlvbnMudHJhbnNsYXRlQWxpYXNlcz1udWxsXSBJZiBzZXQgdG8gYHRydWVgLCB0cmFuc2xhdGVzIGFueSBzY2hlbWEtZGVmaW5lZCBhbGlhc2VzIGluIGBmaWx0ZXJgLCBgcHJvamVjdGlvbmAsIGB1cGRhdGVgLCBhbmQgYGRpc3RpbmN0YC4gVGhyb3dzIGFuIGVycm9yIGlmIHRoZXJlIGFyZSBhbnkgY29uZmxpY3RzIHdoZXJlIGJvdGggYWxpYXMgYW5kIHJhdyBwcm9wZXJ0eSBhcmUgZGVmaW5lZCBvbiB0aGUgc2FtZSBvYmplY3QuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY2FsbGJhY2tdIHBhcmFtcyBhcmUgKGVycm9yLCB3cml0ZU9wUmVzdWx0KVxuICogQHJldHVybiB7UXVlcnl9IHRoaXNcbiAqIEBzZWUgTW9kZWwudXBkYXRlIGh0dHBzOi8vbW9uZ29vc2Vqcy5jb20vZG9jcy9hcGkvbW9kZWwuaHRtbCNNb2RlbC51cGRhdGUoKVxuICogQHNlZSBRdWVyeSBkb2NzIGh0dHBzOi8vbW9uZ29vc2Vqcy5jb20vZG9jcy9xdWVyaWVzLmh0bWxcbiAqIEBzZWUgdXBkYXRlIGh0dHBzOi8vd3d3Lm1vbmdvZGIuY29tL2RvY3MvbWFudWFsL3JlZmVyZW5jZS9tZXRob2QvZGIuY29sbGVjdGlvbi51cGRhdGUvXG4gKiBAc2VlIFVwZGF0ZVJlc3VsdCBodHRwczovL21vbmdvZGIuZ2l0aHViLmlvL25vZGUtbW9uZ29kYi1uYXRpdmUvNC45L2ludGVyZmFjZXMvVXBkYXRlUmVzdWx0Lmh0bWxcbiAqIEBzZWUgTW9uZ29EQiBkb2NzIGh0dHBzOi8vd3d3Lm1vbmdvZGIuY29tL2RvY3MvbWFudWFsL3JlZmVyZW5jZS9jb21tYW5kL3VwZGF0ZS8jdXBkYXRlLWNvbW1hbmQtb3V0cHV0XG4gKiBAYXBpIHB1YmxpY1xuICovXG5cblF1ZXJ5LnByb3RvdHlwZS51cGRhdGVNYW55ID0gZnVuY3Rpb24oY29uZGl0aW9ucywgZG9jLCBvcHRpb25zLCBjYWxsYmFjaykge1xuICBpZiAodHlwZW9mIG9wdGlvbnMgPT09ICdmdW5jdGlvbicpIHtcbiAgICAvLyAudXBkYXRlKGNvbmRpdGlvbnMsIGRvYywgY2FsbGJhY2spXG4gICAgY2FsbGJhY2sgPSBvcHRpb25zO1xuICAgIG9wdGlvbnMgPSBudWxsO1xuICB9IGVsc2UgaWYgKHR5cGVvZiBkb2MgPT09ICdmdW5jdGlvbicpIHtcbiAgICAvLyAudXBkYXRlKGRvYywgY2FsbGJhY2spO1xuICAgIGNhbGxiYWNrID0gZG9jO1xuICAgIGRvYyA9IGNvbmRpdGlvbnM7XG4gICAgY29uZGl0aW9ucyA9IHt9O1xuICAgIG9wdGlvbnMgPSBudWxsO1xuICB9IGVsc2UgaWYgKHR5cGVvZiBjb25kaXRpb25zID09PSAnZnVuY3Rpb24nKSB7XG4gICAgLy8gLnVwZGF0ZShjYWxsYmFjaylcbiAgICBjYWxsYmFjayA9IGNvbmRpdGlvbnM7XG4gICAgY29uZGl0aW9ucyA9IHVuZGVmaW5lZDtcbiAgICBkb2MgPSB1bmRlZmluZWQ7XG4gICAgb3B0aW9ucyA9IHVuZGVmaW5lZDtcbiAgfSBlbHNlIGlmICh0eXBlb2YgY29uZGl0aW9ucyA9PT0gJ29iamVjdCcgJiYgIWRvYyAmJiAhb3B0aW9ucyAmJiAhY2FsbGJhY2spIHtcbiAgICAvLyAudXBkYXRlKGRvYylcbiAgICBkb2MgPSBjb25kaXRpb25zO1xuICAgIGNvbmRpdGlvbnMgPSB1bmRlZmluZWQ7XG4gICAgb3B0aW9ucyA9IHVuZGVmaW5lZDtcbiAgICBjYWxsYmFjayA9IHVuZGVmaW5lZDtcbiAgfVxuXG4gIHJldHVybiBfdXBkYXRlKHRoaXMsICd1cGRhdGVNYW55JywgY29uZGl0aW9ucywgZG9jLCBvcHRpb25zLCBjYWxsYmFjayk7XG59O1xuXG4vKipcbiAqIERlY2xhcmUgYW5kL29yIGV4ZWN1dGUgdGhpcyBxdWVyeSBhcyBhbiB1cGRhdGVPbmUoKSBvcGVyYXRpb24uXG4gKiBNb25nb0RCIHdpbGwgdXBkYXRlIF9vbmx5XyB0aGUgZmlyc3QgZG9jdW1lbnQgdGhhdCBtYXRjaGVzIGBmaWx0ZXJgLlxuICpcbiAqIC0gVXNlIGByZXBsYWNlT25lKClgIGlmIHlvdSB3YW50IHRvIG92ZXJ3cml0ZSBhbiBlbnRpcmUgZG9jdW1lbnQgcmF0aGVyIHRoYW4gdXNpbmcgW2F0b21pYyBvcGVyYXRvcnNdKGh0dHBzOi8vd3d3Lm1vbmdvZGIuY29tL2RvY3MvbWFudWFsL3R1dG9yaWFsL21vZGVsLWRhdGEtZm9yLWF0b21pYy1vcGVyYXRpb25zLyNwYXR0ZXJuKSBsaWtlIGAkc2V0YC5cbiAqXG4gKiAqKk5vdGUqKiB1cGRhdGVPbmUgd2lsbCBfbm90XyBmaXJlIHVwZGF0ZSBtaWRkbGV3YXJlLiBVc2UgYHByZSgndXBkYXRlT25lJylgXG4gKiBhbmQgYHBvc3QoJ3VwZGF0ZU9uZScpYCBpbnN0ZWFkLlxuICpcbiAqICMjIyMgRXhhbXBsZTpcbiAqXG4gKiAgICAgY29uc3QgcmVzID0gYXdhaXQgUGVyc29uLnVwZGF0ZU9uZSh7IG5hbWU6ICdKZWFuLUx1YyBQaWNhcmQnIH0sIHsgc2hpcDogJ1VTUyBFbnRlcnByaXNlJyB9KTtcbiAqICAgICByZXMuYWNrbm93bGVkZ2VkOyAvLyBJbmRpY2F0ZXMgaWYgdGhpcyB3cml0ZSByZXN1bHQgd2FzIGFja25vd2xlZGdlZC4gSWYgbm90LCB0aGVuIGFsbCBvdGhlciBtZW1iZXJzIG9mIHRoaXMgcmVzdWx0IHdpbGwgYmUgdW5kZWZpbmVkLlxuICogICAgIHJlcy5tYXRjaGVkQ291bnQ7IC8vIE51bWJlciBvZiBkb2N1bWVudHMgdGhhdCBtYXRjaGVkIHRoZSBmaWx0ZXJcbiAqICAgICByZXMubW9kaWZpZWRDb3VudDsgLy8gTnVtYmVyIG9mIGRvY3VtZW50cyB0aGF0IHdlcmUgbW9kaWZpZWRcbiAqICAgICByZXMudXBzZXJ0ZWRDb3VudDsgLy8gTnVtYmVyIG9mIGRvY3VtZW50cyB0aGF0IHdlcmUgdXBzZXJ0ZWRcbiAqICAgICByZXMudXBzZXJ0ZWRJZDsgLy8gSWRlbnRpZmllciBvZiB0aGUgaW5zZXJ0ZWQgZG9jdW1lbnQgKGlmIGFuIHVwc2VydCB0b29rIHBsYWNlKVxuICpcbiAqIFRoaXMgZnVuY3Rpb24gdHJpZ2dlcnMgdGhlIGZvbGxvd2luZyBtaWRkbGV3YXJlLlxuICpcbiAqIC0gYHVwZGF0ZU9uZSgpYFxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBbZmlsdGVyXVxuICogQHBhcmFtIHtPYmplY3R8QXJyYXl9IFt1cGRhdGVdIHRoZSB1cGRhdGUgY29tbWFuZFxuICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXVxuICogQHBhcmFtIHtCb29sZWFufSBbb3B0aW9ucy5tdWx0aXBsZUNhc3RFcnJvcl0gYnkgZGVmYXVsdCwgbW9uZ29vc2Ugb25seSByZXR1cm5zIHRoZSBmaXJzdCBlcnJvciB0aGF0IG9jY3VycmVkIGluIGNhc3RpbmcgdGhlIHF1ZXJ5LiBUdXJuIG9uIHRoaXMgb3B0aW9uIHRvIGFnZ3JlZ2F0ZSBhbGwgdGhlIGNhc3QgZXJyb3JzLlxuICogQHBhcmFtIHtCb29sZWFufFN0cmluZ30gW29wdGlvbnMuc3RyaWN0XSBvdmVyd3JpdGVzIHRoZSBzY2hlbWEncyBbc3RyaWN0IG1vZGUgb3B0aW9uXShodHRwczovL21vbmdvb3NlanMuY29tL2RvY3MvZ3VpZGUuaHRtbCNzdHJpY3QpXG4gKiBAcGFyYW0ge0Jvb2xlYW59IFtvcHRpb25zLnVwc2VydD1mYWxzZV0gaWYgdHJ1ZSwgYW5kIG5vIGRvY3VtZW50cyBmb3VuZCwgaW5zZXJ0IGEgbmV3IGRvY3VtZW50XG4gKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnMud3JpdGVDb25jZXJuPW51bGxdIHNldHMgdGhlIFt3cml0ZSBjb25jZXJuXShodHRwczovL3d3dy5tb25nb2RiLmNvbS9kb2NzL21hbnVhbC9yZWZlcmVuY2Uvd3JpdGUtY29uY2Vybi8pIGZvciByZXBsaWNhIHNldHMuIE92ZXJyaWRlcyB0aGUgW3NjaGVtYS1sZXZlbCB3cml0ZSBjb25jZXJuXShodHRwczovL21vbmdvb3NlanMuY29tL2RvY3MvZ3VpZGUuaHRtbCN3cml0ZUNvbmNlcm4pXG4gKiBAcGFyYW0ge0Jvb2xlYW59IFtvcHRpb25zLnRpbWVzdGFtcHM9bnVsbF0gSWYgc2V0IHRvIGBmYWxzZWAgYW5kIFtzY2hlbWEtbGV2ZWwgdGltZXN0YW1wc10oaHR0cHM6Ly9tb25nb29zZWpzLmNvbS9kb2NzL2d1aWRlLmh0bWwjdGltZXN0YW1wcykgYXJlIGVuYWJsZWQsIHNraXAgdGltZXN0YW1wcyBmb3IgdGhpcyB1cGRhdGUuIE5vdGUgdGhhdCB0aGlzIGFsbG93cyB5b3UgdG8gb3ZlcndyaXRlIHRpbWVzdGFtcHMuIERvZXMgbm90aGluZyBpZiBzY2hlbWEtbGV2ZWwgdGltZXN0YW1wcyBhcmUgbm90IHNldC5cbiBAcGFyYW0ge0Jvb2xlYW59IFtvcHRpb25zLnRyYW5zbGF0ZUFsaWFzZXM9bnVsbF0gSWYgc2V0IHRvIGB0cnVlYCwgdHJhbnNsYXRlcyBhbnkgc2NoZW1hLWRlZmluZWQgYWxpYXNlcyBpbiBgZmlsdGVyYCwgYHByb2plY3Rpb25gLCBgdXBkYXRlYCwgYW5kIGBkaXN0aW5jdGAuIFRocm93cyBhbiBlcnJvciBpZiB0aGVyZSBhcmUgYW55IGNvbmZsaWN0cyB3aGVyZSBib3RoIGFsaWFzIGFuZCByYXcgcHJvcGVydHkgYXJlIGRlZmluZWQgb24gdGhlIHNhbWUgb2JqZWN0LlxuICogQHBhcmFtIHtGdW5jdGlvbn0gW2NhbGxiYWNrXSBwYXJhbXMgYXJlIChlcnJvciwgd3JpdGVPcFJlc3VsdClcbiAqIEByZXR1cm4ge1F1ZXJ5fSB0aGlzXG4gKiBAc2VlIE1vZGVsLnVwZGF0ZSBodHRwczovL21vbmdvb3NlanMuY29tL2RvY3MvYXBpL21vZGVsLmh0bWwjTW9kZWwudXBkYXRlKClcbiAqIEBzZWUgUXVlcnkgZG9jcyBodHRwczovL21vbmdvb3NlanMuY29tL2RvY3MvcXVlcmllcy5odG1sXG4gKiBAc2VlIHVwZGF0ZSBodHRwczovL3d3dy5tb25nb2RiLmNvbS9kb2NzL21hbnVhbC9yZWZlcmVuY2UvbWV0aG9kL2RiLmNvbGxlY3Rpb24udXBkYXRlL1xuICogQHNlZSBVcGRhdGVSZXN1bHQgaHR0cHM6Ly9tb25nb2RiLmdpdGh1Yi5pby9ub2RlLW1vbmdvZGItbmF0aXZlLzQuOS9pbnRlcmZhY2VzL1VwZGF0ZVJlc3VsdC5odG1sXG4gKiBAc2VlIE1vbmdvREIgZG9jcyBodHRwczovL3d3dy5tb25nb2RiLmNvbS9kb2NzL21hbnVhbC9yZWZlcmVuY2UvY29tbWFuZC91cGRhdGUvI3VwZGF0ZS1jb21tYW5kLW91dHB1dFxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5RdWVyeS5wcm90b3R5cGUudXBkYXRlT25lID0gZnVuY3Rpb24oY29uZGl0aW9ucywgZG9jLCBvcHRpb25zLCBjYWxsYmFjaykge1xuICBpZiAodHlwZW9mIG9wdGlvbnMgPT09ICdmdW5jdGlvbicpIHtcbiAgICAvLyAudXBkYXRlKGNvbmRpdGlvbnMsIGRvYywgY2FsbGJhY2spXG4gICAgY2FsbGJhY2sgPSBvcHRpb25zO1xuICAgIG9wdGlvbnMgPSBudWxsO1xuICB9IGVsc2UgaWYgKHR5cGVvZiBkb2MgPT09ICdmdW5jdGlvbicpIHtcbiAgICAvLyAudXBkYXRlKGRvYywgY2FsbGJhY2spO1xuICAgIGNhbGxiYWNrID0gZG9jO1xuICAgIGRvYyA9IGNvbmRpdGlvbnM7XG4gICAgY29uZGl0aW9ucyA9IHt9O1xuICAgIG9wdGlvbnMgPSBudWxsO1xuICB9IGVsc2UgaWYgKHR5cGVvZiBjb25kaXRpb25zID09PSAnZnVuY3Rpb24nKSB7XG4gICAgLy8gLnVwZGF0ZShjYWxsYmFjaylcbiAgICBjYWxsYmFjayA9IGNvbmRpdGlvbnM7XG4gICAgY29uZGl0aW9ucyA9IHVuZGVmaW5lZDtcbiAgICBkb2MgPSB1bmRlZmluZWQ7XG4gICAgb3B0aW9ucyA9IHVuZGVmaW5lZDtcbiAgfSBlbHNlIGlmICh0eXBlb2YgY29uZGl0aW9ucyA9PT0gJ29iamVjdCcgJiYgIWRvYyAmJiAhb3B0aW9ucyAmJiAhY2FsbGJhY2spIHtcbiAgICAvLyAudXBkYXRlKGRvYylcbiAgICBkb2MgPSBjb25kaXRpb25zO1xuICAgIGNvbmRpdGlvbnMgPSB1bmRlZmluZWQ7XG4gICAgb3B0aW9ucyA9IHVuZGVmaW5lZDtcbiAgICBjYWxsYmFjayA9IHVuZGVmaW5lZDtcbiAgfVxuXG4gIHJldHVybiBfdXBkYXRlKHRoaXMsICd1cGRhdGVPbmUnLCBjb25kaXRpb25zLCBkb2MsIG9wdGlvbnMsIGNhbGxiYWNrKTtcbn07XG5cbi8qKlxuICogRGVjbGFyZSBhbmQvb3IgZXhlY3V0ZSB0aGlzIHF1ZXJ5IGFzIGEgcmVwbGFjZU9uZSgpIG9wZXJhdGlvbi5cbiAqIE1vbmdvREIgd2lsbCByZXBsYWNlIHRoZSBleGlzdGluZyBkb2N1bWVudCBhbmQgd2lsbCBub3QgYWNjZXB0IGFueSBbYXRvbWljIG9wZXJhdG9yc10oaHR0cHM6Ly93d3cubW9uZ29kYi5jb20vZG9jcy9tYW51YWwvdHV0b3JpYWwvbW9kZWwtZGF0YS1mb3ItYXRvbWljLW9wZXJhdGlvbnMvI3BhdHRlcm4pIChgJHNldGAsIGV0Yy4pXG4gKlxuICogKipOb3RlKiogcmVwbGFjZU9uZSB3aWxsIF9ub3RfIGZpcmUgdXBkYXRlIG1pZGRsZXdhcmUuIFVzZSBgcHJlKCdyZXBsYWNlT25lJylgXG4gKiBhbmQgYHBvc3QoJ3JlcGxhY2VPbmUnKWAgaW5zdGVhZC5cbiAqXG4gKiAjIyMjIEV4YW1wbGU6XG4gKlxuICogICAgIGNvbnN0IHJlcyA9IGF3YWl0IFBlcnNvbi5yZXBsYWNlT25lKHsgX2lkOiAyNDYwMSB9LCB7IG5hbWU6ICdKZWFuIFZhbGplYW4nIH0pO1xuICogICAgIHJlcy5hY2tub3dsZWRnZWQ7IC8vIEluZGljYXRlcyBpZiB0aGlzIHdyaXRlIHJlc3VsdCB3YXMgYWNrbm93bGVkZ2VkLiBJZiBub3QsIHRoZW4gYWxsIG90aGVyIG1lbWJlcnMgb2YgdGhpcyByZXN1bHQgd2lsbCBiZSB1bmRlZmluZWQuXG4gKiAgICAgcmVzLm1hdGNoZWRDb3VudDsgLy8gTnVtYmVyIG9mIGRvY3VtZW50cyB0aGF0IG1hdGNoZWQgdGhlIGZpbHRlclxuICogICAgIHJlcy5tb2RpZmllZENvdW50OyAvLyBOdW1iZXIgb2YgZG9jdW1lbnRzIHRoYXQgd2VyZSBtb2RpZmllZFxuICogICAgIHJlcy51cHNlcnRlZENvdW50OyAvLyBOdW1iZXIgb2YgZG9jdW1lbnRzIHRoYXQgd2VyZSB1cHNlcnRlZFxuICogICAgIHJlcy51cHNlcnRlZElkOyAvLyBJZGVudGlmaWVyIG9mIHRoZSBpbnNlcnRlZCBkb2N1bWVudCAoaWYgYW4gdXBzZXJ0IHRvb2sgcGxhY2UpXG4gKlxuICogVGhpcyBmdW5jdGlvbiB0cmlnZ2VycyB0aGUgZm9sbG93aW5nIG1pZGRsZXdhcmUuXG4gKlxuICogLSBgcmVwbGFjZU9uZSgpYFxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBbZmlsdGVyXVxuICogQHBhcmFtIHtPYmplY3R9IFtkb2NdIHRoZSB1cGRhdGUgY29tbWFuZFxuICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXVxuICogQHBhcmFtIHtCb29sZWFufSBbb3B0aW9ucy5tdWx0aXBsZUNhc3RFcnJvcl0gYnkgZGVmYXVsdCwgbW9uZ29vc2Ugb25seSByZXR1cm5zIHRoZSBmaXJzdCBlcnJvciB0aGF0IG9jY3VycmVkIGluIGNhc3RpbmcgdGhlIHF1ZXJ5LiBUdXJuIG9uIHRoaXMgb3B0aW9uIHRvIGFnZ3JlZ2F0ZSBhbGwgdGhlIGNhc3QgZXJyb3JzLlxuICogQHBhcmFtIHtCb29sZWFufFN0cmluZ30gW29wdGlvbnMuc3RyaWN0XSBvdmVyd3JpdGVzIHRoZSBzY2hlbWEncyBbc3RyaWN0IG1vZGUgb3B0aW9uXShodHRwczovL21vbmdvb3NlanMuY29tL2RvY3MvZ3VpZGUuaHRtbCNzdHJpY3QpXG4gKiBAcGFyYW0ge0Jvb2xlYW59IFtvcHRpb25zLnVwc2VydD1mYWxzZV0gaWYgdHJ1ZSwgYW5kIG5vIGRvY3VtZW50cyBmb3VuZCwgaW5zZXJ0IGEgbmV3IGRvY3VtZW50XG4gKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnMud3JpdGVDb25jZXJuPW51bGxdIHNldHMgdGhlIFt3cml0ZSBjb25jZXJuXShodHRwczovL3d3dy5tb25nb2RiLmNvbS9kb2NzL21hbnVhbC9yZWZlcmVuY2Uvd3JpdGUtY29uY2Vybi8pIGZvciByZXBsaWNhIHNldHMuIE92ZXJyaWRlcyB0aGUgW3NjaGVtYS1sZXZlbCB3cml0ZSBjb25jZXJuXShodHRwczovL21vbmdvb3NlanMuY29tL2RvY3MvZ3VpZGUuaHRtbCN3cml0ZUNvbmNlcm4pXG4gKiBAcGFyYW0ge0Jvb2xlYW59IFtvcHRpb25zLnRpbWVzdGFtcHM9bnVsbF0gSWYgc2V0IHRvIGBmYWxzZWAgYW5kIFtzY2hlbWEtbGV2ZWwgdGltZXN0YW1wc10oaHR0cHM6Ly9tb25nb29zZWpzLmNvbS9kb2NzL2d1aWRlLmh0bWwjdGltZXN0YW1wcykgYXJlIGVuYWJsZWQsIHNraXAgdGltZXN0YW1wcyBmb3IgdGhpcyB1cGRhdGUuIERvZXMgbm90aGluZyBpZiBzY2hlbWEtbGV2ZWwgdGltZXN0YW1wcyBhcmUgbm90IHNldC5cbiAqIEBwYXJhbSB7Qm9vbGVhbn0gW29wdGlvbnMudHJhbnNsYXRlQWxpYXNlcz1udWxsXSBJZiBzZXQgdG8gYHRydWVgLCB0cmFuc2xhdGVzIGFueSBzY2hlbWEtZGVmaW5lZCBhbGlhc2VzIGluIGBmaWx0ZXJgLCBgcHJvamVjdGlvbmAsIGB1cGRhdGVgLCBhbmQgYGRpc3RpbmN0YC4gVGhyb3dzIGFuIGVycm9yIGlmIHRoZXJlIGFyZSBhbnkgY29uZmxpY3RzIHdoZXJlIGJvdGggYWxpYXMgYW5kIHJhdyBwcm9wZXJ0eSBhcmUgZGVmaW5lZCBvbiB0aGUgc2FtZSBvYmplY3QuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY2FsbGJhY2tdIHBhcmFtcyBhcmUgKGVycm9yLCB3cml0ZU9wUmVzdWx0KVxuICogQHJldHVybiB7UXVlcnl9IHRoaXNcbiAqIEBzZWUgTW9kZWwudXBkYXRlIGh0dHBzOi8vbW9uZ29vc2Vqcy5jb20vZG9jcy9hcGkvbW9kZWwuaHRtbCNNb2RlbC51cGRhdGUoKVxuICogQHNlZSBRdWVyeSBkb2NzIGh0dHBzOi8vbW9uZ29vc2Vqcy5jb20vZG9jcy9xdWVyaWVzLmh0bWxcbiAqIEBzZWUgdXBkYXRlIGh0dHBzOi8vd3d3Lm1vbmdvZGIuY29tL2RvY3MvbWFudWFsL3JlZmVyZW5jZS9tZXRob2QvZGIuY29sbGVjdGlvbi51cGRhdGUvXG4gKiBAc2VlIFVwZGF0ZVJlc3VsdCBodHRwczovL21vbmdvZGIuZ2l0aHViLmlvL25vZGUtbW9uZ29kYi1uYXRpdmUvNC45L2ludGVyZmFjZXMvVXBkYXRlUmVzdWx0Lmh0bWxcbiAqIEBzZWUgTW9uZ29EQiBkb2NzIGh0dHBzOi8vd3d3Lm1vbmdvZGIuY29tL2RvY3MvbWFudWFsL3JlZmVyZW5jZS9jb21tYW5kL3VwZGF0ZS8jdXBkYXRlLWNvbW1hbmQtb3V0cHV0XG4gKiBAYXBpIHB1YmxpY1xuICovXG5cblF1ZXJ5LnByb3RvdHlwZS5yZXBsYWNlT25lID0gZnVuY3Rpb24oY29uZGl0aW9ucywgZG9jLCBvcHRpb25zLCBjYWxsYmFjaykge1xuICBpZiAodHlwZW9mIG9wdGlvbnMgPT09ICdmdW5jdGlvbicpIHtcbiAgICAvLyAudXBkYXRlKGNvbmRpdGlvbnMsIGRvYywgY2FsbGJhY2spXG4gICAgY2FsbGJhY2sgPSBvcHRpb25zO1xuICAgIG9wdGlvbnMgPSBudWxsO1xuICB9IGVsc2UgaWYgKHR5cGVvZiBkb2MgPT09ICdmdW5jdGlvbicpIHtcbiAgICAvLyAudXBkYXRlKGRvYywgY2FsbGJhY2spO1xuICAgIGNhbGxiYWNrID0gZG9jO1xuICAgIGRvYyA9IGNvbmRpdGlvbnM7XG4gICAgY29uZGl0aW9ucyA9IHt9O1xuICAgIG9wdGlvbnMgPSBudWxsO1xuICB9IGVsc2UgaWYgKHR5cGVvZiBjb25kaXRpb25zID09PSAnZnVuY3Rpb24nKSB7XG4gICAgLy8gLnVwZGF0ZShjYWxsYmFjaylcbiAgICBjYWxsYmFjayA9IGNvbmRpdGlvbnM7XG4gICAgY29uZGl0aW9ucyA9IHVuZGVmaW5lZDtcbiAgICBkb2MgPSB1bmRlZmluZWQ7XG4gICAgb3B0aW9ucyA9IHVuZGVmaW5lZDtcbiAgfSBlbHNlIGlmICh0eXBlb2YgY29uZGl0aW9ucyA9PT0gJ29iamVjdCcgJiYgIWRvYyAmJiAhb3B0aW9ucyAmJiAhY2FsbGJhY2spIHtcbiAgICAvLyAudXBkYXRlKGRvYylcbiAgICBkb2MgPSBjb25kaXRpb25zO1xuICAgIGNvbmRpdGlvbnMgPSB1bmRlZmluZWQ7XG4gICAgb3B0aW9ucyA9IHVuZGVmaW5lZDtcbiAgICBjYWxsYmFjayA9IHVuZGVmaW5lZDtcbiAgfVxuXG4gIHJldHVybiBfdXBkYXRlKHRoaXMsICdyZXBsYWNlT25lJywgY29uZGl0aW9ucywgZG9jLCBvcHRpb25zLCBjYWxsYmFjayk7XG59O1xuXG4vKipcbiAqIEludGVybmFsIGhlbHBlciBmb3IgdXBkYXRlLCB1cGRhdGVNYW55LCB1cGRhdGVPbmUsIHJlcGxhY2VPbmVcbiAqIEBwYXJhbSB7UXVlcnl9IHF1ZXJ5XG4gKiBAcGFyYW0ge1N0cmluZ30gb3BcbiAqIEBwYXJhbSB7T2JqZWN0fSBmaWx0ZXJcbiAqIEBwYXJhbSB7RG9jdW1lbnR9IFtkb2NdXG4gKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFja1xuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZnVuY3Rpb24gX3VwZGF0ZShxdWVyeSwgb3AsIGZpbHRlciwgZG9jLCBvcHRpb25zLCBjYWxsYmFjaykge1xuICAvLyBtYWtlIHN1cmUgd2UgZG9uJ3Qgc2VuZCBpbiB0aGUgd2hvbGUgRG9jdW1lbnQgdG8gbWVyZ2UoKVxuICBxdWVyeS5vcCA9IG9wO1xuICBxdWVyeS5fdmFsaWRhdGVPcCgpO1xuICBkb2MgPSBkb2MgfHwge307XG5cbiAgLy8gc3RyaWN0IGlzIGFuIG9wdGlvbiB1c2VkIGluIHRoZSB1cGRhdGUgY2hlY2tpbmcsIG1ha2Ugc3VyZSBpdCBnZXRzIHNldFxuICBpZiAob3B0aW9ucyAhPSBudWxsKSB7XG4gICAgaWYgKCdzdHJpY3QnIGluIG9wdGlvbnMpIHtcbiAgICAgIHF1ZXJ5Ll9tb25nb29zZU9wdGlvbnMuc3RyaWN0ID0gb3B0aW9ucy5zdHJpY3Q7XG4gICAgfVxuICB9XG5cbiAgaWYgKCEoZmlsdGVyIGluc3RhbmNlb2YgUXVlcnkpICYmXG4gICAgICBmaWx0ZXIgIT0gbnVsbCAmJlxuICAgICAgZmlsdGVyLnRvU3RyaW5nKCkgIT09ICdbb2JqZWN0IE9iamVjdF0nKSB7XG4gICAgcXVlcnkuZXJyb3IobmV3IE9iamVjdFBhcmFtZXRlckVycm9yKGZpbHRlciwgJ2ZpbHRlcicsIG9wKSk7XG4gIH0gZWxzZSB7XG4gICAgcXVlcnkubWVyZ2UoZmlsdGVyKTtcbiAgfVxuXG4gIGlmICh1dGlscy5pc09iamVjdChvcHRpb25zKSkge1xuICAgIHF1ZXJ5LnNldE9wdGlvbnMob3B0aW9ucyk7XG4gIH1cblxuICBxdWVyeS5fbWVyZ2VVcGRhdGUoZG9jKTtcblxuICAvLyBIb29rc1xuICBpZiAoY2FsbGJhY2spIHtcbiAgICBxdWVyeS5leGVjKGNhbGxiYWNrKTtcblxuICAgIHJldHVybiBxdWVyeTtcbiAgfVxuXG4gIHJldHVybiBxdWVyeTtcbn1cblxuLyoqXG4gKiBSdW5zIGEgZnVuY3Rpb24gYGZuYCBhbmQgdHJlYXRzIHRoZSByZXR1cm4gdmFsdWUgb2YgYGZuYCBhcyB0aGUgbmV3IHZhbHVlXG4gKiBmb3IgdGhlIHF1ZXJ5IHRvIHJlc29sdmUgdG8uXG4gKlxuICogQW55IGZ1bmN0aW9ucyB5b3UgcGFzcyB0byBgdHJhbnNmb3JtKClgIHdpbGwgcnVuICoqYWZ0ZXIqKiBhbnkgcG9zdCBob29rcy5cbiAqXG4gKiAjIyMjIEV4YW1wbGU6XG4gKlxuICogICAgIGNvbnN0IHJlcyA9IGF3YWl0IE15TW9kZWwuZmluZE9uZSgpLnRyYW5zZm9ybShyZXMgPT4ge1xuICogICAgICAgLy8gU2V0cyBhIGBsb2FkZWRBdGAgcHJvcGVydHkgb24gdGhlIGRvYyB0aGF0IHRlbGxzIHlvdSB0aGUgdGltZSB0aGVcbiAqICAgICAgIC8vIGRvY3VtZW50IHdhcyBsb2FkZWQuXG4gKiAgICAgICByZXR1cm4gcmVzID09IG51bGwgP1xuICogICAgICAgICByZXMgOlxuICogICAgICAgICBPYmplY3QuYXNzaWduKHJlcywgeyBsb2FkZWRBdDogbmV3IERhdGUoKSB9KTtcbiAqICAgICB9KTtcbiAqXG4gKiBAbWV0aG9kIHRyYW5zZm9ybVxuICogQG1lbWJlck9mIFF1ZXJ5XG4gKiBAaW5zdGFuY2VcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuIGZ1bmN0aW9uIHRvIHJ1biB0byB0cmFuc2Zvcm0gdGhlIHF1ZXJ5IHJlc3VsdFxuICogQHJldHVybiB7UXVlcnl9IHRoaXNcbiAqL1xuXG5RdWVyeS5wcm90b3R5cGUudHJhbnNmb3JtID0gZnVuY3Rpb24oZm4pIHtcbiAgdGhpcy5fdHJhbnNmb3Jtcy5wdXNoKGZuKTtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIE1ha2UgdGhpcyBxdWVyeSB0aHJvdyBhbiBlcnJvciBpZiBubyBkb2N1bWVudHMgbWF0Y2ggdGhlIGdpdmVuIGBmaWx0ZXJgLlxuICogVGhpcyBpcyBoYW5keSBmb3IgaW50ZWdyYXRpbmcgd2l0aCBhc3luYy9hd2FpdCwgYmVjYXVzZSBgb3JGYWlsKClgIHNhdmVzIHlvdVxuICogYW4gZXh0cmEgYGlmYCBzdGF0ZW1lbnQgdG8gY2hlY2sgaWYgbm8gZG9jdW1lbnQgd2FzIGZvdW5kLlxuICpcbiAqICMjIyMgRXhhbXBsZTpcbiAqXG4gKiAgICAgLy8gVGhyb3dzIGlmIG5vIGRvYyByZXR1cm5lZFxuICogICAgIGF3YWl0IE1vZGVsLmZpbmRPbmUoeyBmb286ICdiYXInIH0pLm9yRmFpbCgpO1xuICpcbiAqICAgICAvLyBUaHJvd3MgaWYgbm8gZG9jdW1lbnQgd2FzIHVwZGF0ZWQuIE5vdGUgdGhhdCBgb3JGYWlsKClgIHdpbGwgc3RpbGxcbiAqICAgICAvLyB0aHJvdyBpZiB0aGUgb25seSBkb2N1bWVudCB0aGF0IG1hdGNoZXMgaXMgYHsgZm9vOiAnYmFyJywgbmFtZTogJ3Rlc3QnIH1gLFxuICogICAgIC8vIGJlY2F1c2UgYG9yRmFpbCgpYCB3aWxsIHRocm93IGlmIG5vIGRvY3VtZW50IHdhcyBfdXBkYXRlZF8sIG5vdFxuICogICAgIC8vIGlmIG5vIGRvY3VtZW50IHdhcyBfZm91bmRfLlxuICogICAgIGF3YWl0IE1vZGVsLnVwZGF0ZU9uZSh7IGZvbzogJ2JhcicgfSwgeyBuYW1lOiAndGVzdCcgfSkub3JGYWlsKCk7XG4gKlxuICogICAgIC8vIFRocm93cyBcIk5vIGRvY3MgZm91bmQhXCIgZXJyb3IgaWYgbm8gZG9jcyBtYXRjaCBgeyBmb286ICdiYXInIH1gXG4gKiAgICAgYXdhaXQgTW9kZWwuZmluZCh7IGZvbzogJ2JhcicgfSkub3JGYWlsKG5ldyBFcnJvcignTm8gZG9jcyBmb3VuZCEnKSk7XG4gKlxuICogICAgIC8vIFRocm93cyBcIk5vdCBmb3VuZFwiIGVycm9yIGlmIG5vIGRvY3VtZW50IHdhcyBmb3VuZFxuICogICAgIGF3YWl0IE1vZGVsLmZpbmRPbmVBbmRVcGRhdGUoeyBmb286ICdiYXInIH0sIHsgbmFtZTogJ3Rlc3QnIH0pLlxuICogICAgICAgb3JGYWlsKCgpID0+IEVycm9yKCdOb3QgZm91bmQnKSk7XG4gKlxuICogQG1ldGhvZCBvckZhaWxcbiAqIEBtZW1iZXJPZiBRdWVyeVxuICogQGluc3RhbmNlXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufEVycm9yfSBbZXJyXSBvcHRpb25hbCBlcnJvciB0byB0aHJvdyBpZiBubyBkb2NzIG1hdGNoIGBmaWx0ZXJgLiBJZiBub3Qgc3BlY2lmaWVkLCBgb3JGYWlsKClgIHdpbGwgdGhyb3cgYSBgRG9jdW1lbnROb3RGb3VuZEVycm9yYFxuICogQHJldHVybiB7UXVlcnl9IHRoaXNcbiAqL1xuXG5RdWVyeS5wcm90b3R5cGUub3JGYWlsID0gZnVuY3Rpb24oZXJyKSB7XG4gIHRoaXMudHJhbnNmb3JtKHJlcyA9PiB7XG4gICAgc3dpdGNoICh0aGlzLm9wKSB7XG4gICAgICBjYXNlICdmaW5kJzpcbiAgICAgICAgaWYgKHJlcy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICB0aHJvdyBfb3JGYWlsRXJyb3IoZXJyLCB0aGlzKTtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ2ZpbmRPbmUnOlxuICAgICAgICBpZiAocmVzID09IG51bGwpIHtcbiAgICAgICAgICB0aHJvdyBfb3JGYWlsRXJyb3IoZXJyLCB0aGlzKTtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ3JlcGxhY2VPbmUnOlxuICAgICAgY2FzZSAndXBkYXRlTWFueSc6XG4gICAgICBjYXNlICd1cGRhdGVPbmUnOlxuICAgICAgICBpZiAocmVzICYmIHJlcy5tYXRjaGVkQ291bnQgPT09IDApIHtcbiAgICAgICAgICB0aHJvdyBfb3JGYWlsRXJyb3IoZXJyLCB0aGlzKTtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ2ZpbmRPbmVBbmREZWxldGUnOlxuICAgICAgY2FzZSAnZmluZE9uZUFuZFVwZGF0ZSc6XG4gICAgICBjYXNlICdmaW5kT25lQW5kUmVwbGFjZSc6XG4gICAgICAgIGlmICh0aGlzLm9wdGlvbnMuaW5jbHVkZVJlc3VsdE1ldGFkYXRhICYmIHJlcyAhPSBudWxsICYmIHJlcy52YWx1ZSA9PSBudWxsKSB7XG4gICAgICAgICAgdGhyb3cgX29yRmFpbEVycm9yKGVyciwgdGhpcyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCF0aGlzLm9wdGlvbnMuaW5jbHVkZVJlc3VsdE1ldGFkYXRhICYmIHJlcyA9PSBudWxsKSB7XG4gICAgICAgICAgdGhyb3cgX29yRmFpbEVycm9yKGVyciwgdGhpcyk7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICdkZWxldGVNYW55JzpcbiAgICAgIGNhc2UgJ2RlbGV0ZU9uZSc6XG4gICAgICAgIGlmIChyZXMuZGVsZXRlZENvdW50ID09PSAwKSB7XG4gICAgICAgICAgdGhyb3cgX29yRmFpbEVycm9yKGVyciwgdGhpcyk7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICBicmVhaztcbiAgICB9XG5cbiAgICByZXR1cm4gcmVzO1xuICB9KTtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIEdldCB0aGUgZXJyb3IgdG8gdGhyb3cgZm9yIGBvckZhaWwoKWBcbiAqIEBwYXJhbSB7RXJyb3J8dW5kZWZpbmVkfSBlcnJcbiAqIEBwYXJhbSB7UXVlcnl9IHF1ZXJ5XG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5mdW5jdGlvbiBfb3JGYWlsRXJyb3IoZXJyLCBxdWVyeSkge1xuICBpZiAodHlwZW9mIGVyciA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIGVyciA9IGVyci5jYWxsKHF1ZXJ5KTtcbiAgfVxuXG4gIGlmIChlcnIgPT0gbnVsbCkge1xuICAgIGVyciA9IG5ldyBEb2N1bWVudE5vdEZvdW5kRXJyb3IocXVlcnkuZ2V0UXVlcnkoKSwgcXVlcnkubW9kZWwubW9kZWxOYW1lKTtcbiAgfVxuXG4gIHJldHVybiBlcnI7XG59XG5cbi8qKlxuICogV3JhcHBlciBmdW5jdGlvbiB0byBjYWxsIGlzUGF0aFNlbGVjdGVkSW5jbHVzaXZlIG9uIGEgcXVlcnkuXG4gKiBAcGFyYW0ge1N0cmluZ30gcGF0aFxuICogQHJldHVybiB7Qm9vbGVhbn1cbiAqIEBhcGkgcHVibGljXG4gKi9cblxuUXVlcnkucHJvdG90eXBlLmlzUGF0aFNlbGVjdGVkSW5jbHVzaXZlID0gZnVuY3Rpb24ocGF0aCkge1xuICByZXR1cm4gaXNQYXRoU2VsZWN0ZWRJbmNsdXNpdmUodGhpcy5fZmllbGRzLCBwYXRoKTtcbn07XG5cbi8qKlxuICogRXhlY3V0ZXMgdGhlIHF1ZXJ5XG4gKlxuICogIyMjIyBFeGFtcGxlOlxuICpcbiAqICAgICBjb25zdCBwcm9taXNlID0gcXVlcnkuZXhlYygpO1xuICogICAgIGNvbnN0IHByb21pc2UgPSBxdWVyeS5leGVjKCd1cGRhdGUnKTtcbiAqXG4gKiBAcGFyYW0ge1N0cmluZ3xGdW5jdGlvbn0gW29wZXJhdGlvbl1cbiAqIEByZXR1cm4ge1Byb21pc2V9XG4gKiBAYXBpIHB1YmxpY1xuICovXG5cblF1ZXJ5LnByb3RvdHlwZS5leGVjID0gYXN5bmMgZnVuY3Rpb24gZXhlYyhvcCkge1xuICBpZiAodHlwZW9mIG9wID09PSAnZnVuY3Rpb24nIHx8IChhcmd1bWVudHMubGVuZ3RoID49IDIgJiYgdHlwZW9mIGFyZ3VtZW50c1sxXSA9PT0gJ2Z1bmN0aW9uJykpIHtcbiAgICB0aHJvdyBuZXcgTW9uZ29vc2VFcnJvcignUXVlcnkucHJvdG90eXBlLmV4ZWMoKSBubyBsb25nZXIgYWNjZXB0cyBhIGNhbGxiYWNrJyk7XG4gIH1cblxuICBpZiAodHlwZW9mIG9wID09PSAnc3RyaW5nJykge1xuICAgIHRoaXMub3AgPSBvcDtcbiAgfVxuXG4gIGlmICh0aGlzLm9wID09IG51bGwpIHtcbiAgICB0aHJvdyBuZXcgTW9uZ29vc2VFcnJvcignUXVlcnkgbXVzdCBoYXZlIGBvcGAgYmVmb3JlIGV4ZWN1dGluZycpO1xuICB9XG4gIGlmICh0aGlzLm1vZGVsID09IG51bGwpIHtcbiAgICB0aHJvdyBuZXcgTW9uZ29vc2VFcnJvcignUXVlcnkgbXVzdCBoYXZlIGFuIGFzc29jaWF0ZWQgbW9kZWwgYmVmb3JlIGV4ZWN1dGluZycpO1xuICB9XG4gIHRoaXMuX3ZhbGlkYXRlT3AoKTtcblxuICBpZiAoIXRoaXMub3ApIHtcbiAgICByZXR1cm47XG4gIH1cblxuICBpZiAodGhpcy5vcHRpb25zICYmIHRoaXMub3B0aW9ucy5zb3J0KSB7XG4gICAgY29uc3Qga2V5cyA9IE9iamVjdC5rZXlzKHRoaXMub3B0aW9ucy5zb3J0KTtcbiAgICBpZiAoa2V5cy5pbmNsdWRlcygnJykpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBmaWVsZCBcIlwiIHBhc3NlZCB0byBzb3J0KCknKTtcbiAgICB9XG4gIH1cblxuICBsZXQgdGh1bmsgPSAnXycgKyB0aGlzLm9wO1xuICBpZiAodGhpcy5vcCA9PT0gJ2Rpc3RpbmN0Jykge1xuICAgIHRodW5rID0gJ19fZGlzdGluY3QnO1xuICB9XG5cbiAgaWYgKHRoaXMuX2V4ZWN1dGlvblN0YWNrICE9IG51bGwpIHtcbiAgICBsZXQgc3RyID0gdGhpcy50b1N0cmluZygpO1xuICAgIGlmIChzdHIubGVuZ3RoID4gNjApIHtcbiAgICAgIHN0ciA9IHN0ci5zbGljZSgwLCA2MCkgKyAnLi4uJztcbiAgICB9XG4gICAgY29uc3QgZXJyID0gbmV3IE1vbmdvb3NlRXJyb3IoJ1F1ZXJ5IHdhcyBhbHJlYWR5IGV4ZWN1dGVkOiAnICsgc3RyKTtcbiAgICBlcnIub3JpZ2luYWxTdGFjayA9IHRoaXMuX2V4ZWN1dGlvblN0YWNrLnN0YWNrO1xuICAgIHRocm93IGVycjtcbiAgfSBlbHNlIHtcbiAgICB0aGlzLl9leGVjdXRpb25TdGFjayA9IG5ldyBFcnJvcigpO1xuICB9XG5cbiAgbGV0IHNraXBXcmFwcGVkRnVuY3Rpb24gPSBudWxsO1xuICB0cnkge1xuICAgIGF3YWl0IF9leGVjdXRlUHJlRXhlY0hvb2tzKHRoaXMpO1xuICB9IGNhdGNoIChlcnIpIHtcbiAgICBpZiAoZXJyIGluc3RhbmNlb2YgS2FyZWVtLnNraXBXcmFwcGVkRnVuY3Rpb24pIHtcbiAgICAgIHNraXBXcmFwcGVkRnVuY3Rpb24gPSBlcnI7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93IGVycjtcbiAgICB9XG4gIH1cblxuICBsZXQgcmVzO1xuXG4gIGxldCBlcnJvciA9IG51bGw7XG4gIHRyeSB7XG4gICAgYXdhaXQgX2V4ZWN1dGVQcmVIb29rcyh0aGlzKTtcbiAgICByZXMgPSBza2lwV3JhcHBlZEZ1bmN0aW9uID8gc2tpcFdyYXBwZWRGdW5jdGlvbi5hcmdzWzBdIDogYXdhaXQgdGhpc1t0aHVua10oKTtcblxuICAgIGZvciAoY29uc3QgZm4gb2YgdGhpcy5fdHJhbnNmb3Jtcykge1xuICAgICAgcmVzID0gZm4ocmVzKTtcbiAgICB9XG4gIH0gY2F0Y2ggKGVycikge1xuICAgIGlmIChlcnIgaW5zdGFuY2VvZiBLYXJlZW0uc2tpcFdyYXBwZWRGdW5jdGlvbikge1xuICAgICAgcmVzID0gZXJyLmFyZ3NbMF07XG4gICAgfSBlbHNlIHtcbiAgICAgIGVycm9yID0gZXJyO1xuICAgIH1cbiAgfVxuXG4gIHJlcyA9IGF3YWl0IF9leGVjdXRlUG9zdEhvb2tzKHRoaXMsIHJlcywgZXJyb3IpO1xuXG4gIGF3YWl0IF9leGVjdXRlUG9zdEV4ZWNIb29rcyh0aGlzKTtcblxuICByZXR1cm4gcmVzO1xufTtcblxuLyohXG4gKiBpZ25vcmVcbiAqL1xuXG5mdW5jdGlvbiBfZXhlY3V0ZVBvc3RFeGVjSG9va3MocXVlcnkpIHtcbiAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICBxdWVyeS5faG9va3MuZXhlY1Bvc3QoJ2V4ZWMnLCBxdWVyeSwgW10sIHt9LCAoZXJyb3IpID0+IHtcbiAgICAgIGlmIChlcnJvcikge1xuICAgICAgICByZXR1cm4gcmVqZWN0KGVycm9yKTtcbiAgICAgIH1cblxuICAgICAgcmVzb2x2ZSgpO1xuICAgIH0pO1xuICB9KTtcbn1cblxuLyohXG4gKiBpZ25vcmVcbiAqL1xuXG5mdW5jdGlvbiBfZXhlY3V0ZVBvc3RIb29rcyhxdWVyeSwgcmVzLCBlcnJvciwgb3ApIHtcbiAgaWYgKHF1ZXJ5Ll9xdWVyeU1pZGRsZXdhcmUgPT0gbnVsbCkge1xuICAgIGlmIChlcnJvciAhPSBudWxsKSB7XG4gICAgICB0aHJvdyBlcnJvcjtcbiAgICB9XG4gICAgcmV0dXJuIHJlcztcbiAgfVxuXG4gIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgY29uc3Qgb3B0cyA9IGVycm9yID8geyBlcnJvciB9IDoge307XG5cbiAgICBxdWVyeS5fcXVlcnlNaWRkbGV3YXJlLmV4ZWNQb3N0KG9wIHx8IHF1ZXJ5Lm9wLCBxdWVyeSwgW3Jlc10sIG9wdHMsIChlcnJvciwgcmVzKSA9PiB7XG4gICAgICBpZiAoZXJyb3IpIHtcbiAgICAgICAgcmV0dXJuIHJlamVjdChlcnJvcik7XG4gICAgICB9XG5cbiAgICAgIHJlc29sdmUocmVzKTtcbiAgICB9KTtcbiAgfSk7XG59XG5cbi8qIVxuICogaWdub3JlXG4gKi9cblxuZnVuY3Rpb24gX2V4ZWN1dGVQcmVFeGVjSG9va3MocXVlcnkpIHtcbiAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICBxdWVyeS5faG9va3MuZXhlY1ByZSgnZXhlYycsIHF1ZXJ5LCBbXSwgKGVycm9yKSA9PiB7XG4gICAgICBpZiAoZXJyb3IgIT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gcmVqZWN0KGVycm9yKTtcbiAgICAgIH1cbiAgICAgIHJlc29sdmUoKTtcbiAgICB9KTtcbiAgfSk7XG59XG5cbi8qIVxuICogaWdub3JlXG4gKi9cblxuZnVuY3Rpb24gX2V4ZWN1dGVQcmVIb29rcyhxdWVyeSwgb3ApIHtcbiAgaWYgKHF1ZXJ5Ll9xdWVyeU1pZGRsZXdhcmUgPT0gbnVsbCkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgcXVlcnkuX3F1ZXJ5TWlkZGxld2FyZS5leGVjUHJlKG9wIHx8IHF1ZXJ5Lm9wLCBxdWVyeSwgW10sIChlcnJvcikgPT4ge1xuICAgICAgaWYgKGVycm9yICE9IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIHJlamVjdChlcnJvcik7XG4gICAgICB9XG4gICAgICByZXNvbHZlKCk7XG4gICAgfSk7XG4gIH0pO1xufVxuXG4vKiFcbiAqIGlnbm9yZVxuICovXG5cbmZ1bmN0aW9uIF93cmFwVGh1bmtDYWxsYmFjayhxdWVyeSwgY2IpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKGVycm9yLCByZXMpIHtcbiAgICBpZiAoZXJyb3IgIT0gbnVsbCkge1xuICAgICAgcmV0dXJuIGNiKGVycm9yKTtcbiAgICB9XG5cbiAgICBmb3IgKGNvbnN0IGZuIG9mIHF1ZXJ5Ll90cmFuc2Zvcm1zKSB7XG4gICAgICB0cnkge1xuICAgICAgICByZXMgPSBmbihyZXMpO1xuICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgcmV0dXJuIGNiKGVycm9yKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gY2IobnVsbCwgcmVzKTtcbiAgfTtcbn1cblxuLyoqXG4gKiBFeGVjdXRlcyB0aGUgcXVlcnkgcmV0dXJuaW5nIGEgYFByb21pc2VgIHdoaWNoIHdpbGwgYmVcbiAqIHJlc29sdmVkIHdpdGggZWl0aGVyIHRoZSBkb2Mocykgb3IgcmVqZWN0ZWQgd2l0aCB0aGUgZXJyb3IuXG4gKlxuICogTW9yZSBhYm91dCBbYHRoZW4oKWAgaW4gSmF2YVNjcmlwdF0oaHR0cHM6Ly9tYXN0ZXJpbmdqcy5pby90dXRvcmlhbHMvZnVuZGFtZW50YWxzL3RoZW4pLlxuICpcbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtyZXNvbHZlXVxuICogQHBhcmFtIHtGdW5jdGlvbn0gW3JlamVjdF1cbiAqIEByZXR1cm4ge1Byb21pc2V9XG4gKiBAYXBpIHB1YmxpY1xuICovXG5cblF1ZXJ5LnByb3RvdHlwZS50aGVuID0gZnVuY3Rpb24ocmVzb2x2ZSwgcmVqZWN0KSB7XG4gIHJldHVybiB0aGlzLmV4ZWMoKS50aGVuKHJlc29sdmUsIHJlamVjdCk7XG59O1xuXG4vKipcbiAqIEV4ZWN1dGVzIHRoZSBxdWVyeSByZXR1cm5pbmcgYSBgUHJvbWlzZWAgd2hpY2ggd2lsbCBiZVxuICogcmVzb2x2ZWQgd2l0aCBlaXRoZXIgdGhlIGRvYyhzKSBvciByZWplY3RlZCB3aXRoIHRoZSBlcnJvci5cbiAqIExpa2UgYC50aGVuKClgLCBidXQgb25seSB0YWtlcyBhIHJlamVjdGlvbiBoYW5kbGVyLlxuICpcbiAqIE1vcmUgYWJvdXQgW1Byb21pc2UgYGNhdGNoKClgIGluIEphdmFTY3JpcHRdKGh0dHBzOi8vbWFzdGVyaW5nanMuaW8vdHV0b3JpYWxzL2Z1bmRhbWVudGFscy9jYXRjaCkuXG4gKlxuICogQHBhcmFtIHtGdW5jdGlvbn0gW3JlamVjdF1cbiAqIEByZXR1cm4ge1Byb21pc2V9XG4gKiBAYXBpIHB1YmxpY1xuICovXG5cblF1ZXJ5LnByb3RvdHlwZS5jYXRjaCA9IGZ1bmN0aW9uKHJlamVjdCkge1xuICByZXR1cm4gdGhpcy5leGVjKCkudGhlbihudWxsLCByZWplY3QpO1xufTtcblxuLyoqXG4gKiBFeGVjdXRlcyB0aGUgcXVlcnkgcmV0dXJuaW5nIGEgYFByb21pc2VgIHdoaWNoIHdpbGwgYmVcbiAqIHJlc29sdmVkIHdpdGggYC5maW5hbGx5KClgIGNoYWluZWQuXG4gKlxuICogTW9yZSBhYm91dCBbUHJvbWlzZSBgZmluYWxseSgpYCBpbiBKYXZhU2NyaXB0XShodHRwczovL3RoZWNvZGViYXJiYXJpYW4uY29tL3VzaW5nLXByb21pc2UtZmluYWxseS1pbi1ub2RlLWpzLmh0bWwpLlxuICpcbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtvbkZpbmFsbHldXG4gKiBAcmV0dXJuIHtQcm9taXNlfVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5RdWVyeS5wcm90b3R5cGUuZmluYWxseSA9IGZ1bmN0aW9uKG9uRmluYWxseSkge1xuICByZXR1cm4gdGhpcy5leGVjKCkuZmluYWxseShvbkZpbmFsbHkpO1xufTtcblxuLyoqXG4gKiBSZXR1cm5zIGEgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoaXMgcXVlcnkuXG4gKlxuICogTW9yZSBhYm91dCBbYHRvU3RyaW5nKClgIGluIEphdmFTY3JpcHRdKGh0dHBzOi8vbWFzdGVyaW5nanMuaW8vdHV0b3JpYWxzL2Z1bmRhbWVudGFscy90b3N0cmluZykuXG4gKlxuICogIyMjIyBFeGFtcGxlOlxuICogICAgIGNvbnN0IHEgPSBNb2RlbC5maW5kKCk7XG4gKiAgICAgY29uc29sZS5sb2cocSk7IC8vIFByaW50cyBcIlF1ZXJ5IHsgZmluZCB9XCJcbiAqXG4gKiBAcmV0dXJuIHtTdHJpbmd9XG4gKiBAYXBpIHB1YmxpY1xuICogQG1ldGhvZCBbU3ltYm9sLnRvU3RyaW5nVGFnXVxuICogQG1lbWJlck9mIFF1ZXJ5XG4gKi9cblxuUXVlcnkucHJvdG90eXBlW1N5bWJvbC50b1N0cmluZ1RhZ10gPSBmdW5jdGlvbiB0b1N0cmluZygpIHtcbiAgcmV0dXJuIGBRdWVyeSB7ICR7dGhpcy5vcH0gfWA7XG59O1xuXG4vKipcbiAqIEFkZCBwcmUgW21pZGRsZXdhcmVdKGh0dHBzOi8vbW9uZ29vc2Vqcy5jb20vZG9jcy9taWRkbGV3YXJlLmh0bWwpIHRvIHRoaXMgcXVlcnkgaW5zdGFuY2UuIERvZXNuJ3QgYWZmZWN0XG4gKiBvdGhlciBxdWVyaWVzLlxuICpcbiAqICMjIyMgRXhhbXBsZTpcbiAqXG4gKiAgICAgY29uc3QgcTEgPSBRdWVzdGlvbi5maW5kKHsgYW5zd2VyOiA0MiB9KTtcbiAqICAgICBxMS5wcmUoZnVuY3Rpb24gbWlkZGxld2FyZSgpIHtcbiAqICAgICAgIGNvbnNvbGUubG9nKHRoaXMuZ2V0RmlsdGVyKCkpO1xuICogICAgIH0pO1xuICogICAgIGF3YWl0IHExLmV4ZWMoKTsgLy8gUHJpbnRzIFwieyBhbnN3ZXI6IDQyIH1cIlxuICpcbiAqICAgICAvLyBEb2Vzbid0IHByaW50IGFueXRoaW5nLCBiZWNhdXNlIGBtaWRkbGV3YXJlKClgIGlzIG9ubHlcbiAqICAgICAvLyByZWdpc3RlcmVkIG9uIGBxMWAuXG4gKiAgICAgYXdhaXQgUXVlc3Rpb24uZmluZCh7IGFuc3dlcjogNDIgfSk7XG4gKlxuICogQHBhcmFtIHtGdW5jdGlvbn0gZm5cbiAqIEByZXR1cm4ge1Byb21pc2V9XG4gKiBAYXBpIHB1YmxpY1xuICovXG5cblF1ZXJ5LnByb3RvdHlwZS5wcmUgPSBmdW5jdGlvbihmbikge1xuICB0aGlzLl9ob29rcy5wcmUoJ2V4ZWMnLCBmbik7XG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBBZGQgcG9zdCBbbWlkZGxld2FyZV0oaHR0cHM6Ly9tb25nb29zZWpzLmNvbS9kb2NzL21pZGRsZXdhcmUuaHRtbCkgdG8gdGhpcyBxdWVyeSBpbnN0YW5jZS4gRG9lc24ndCBhZmZlY3RcbiAqIG90aGVyIHF1ZXJpZXMuXG4gKlxuICogIyMjIyBFeGFtcGxlOlxuICpcbiAqICAgICBjb25zdCBxMSA9IFF1ZXN0aW9uLmZpbmQoeyBhbnN3ZXI6IDQyIH0pO1xuICogICAgIHExLnBvc3QoZnVuY3Rpb24gbWlkZGxld2FyZSgpIHtcbiAqICAgICAgIGNvbnNvbGUubG9nKHRoaXMuZ2V0RmlsdGVyKCkpO1xuICogICAgIH0pO1xuICogICAgIGF3YWl0IHExLmV4ZWMoKTsgLy8gUHJpbnRzIFwieyBhbnN3ZXI6IDQyIH1cIlxuICpcbiAqICAgICAvLyBEb2Vzbid0IHByaW50IGFueXRoaW5nLCBiZWNhdXNlIGBtaWRkbGV3YXJlKClgIGlzIG9ubHlcbiAqICAgICAvLyByZWdpc3RlcmVkIG9uIGBxMWAuXG4gKiAgICAgYXdhaXQgUXVlc3Rpb24uZmluZCh7IGFuc3dlcjogNDIgfSk7XG4gKlxuICogQHBhcmFtIHtGdW5jdGlvbn0gZm5cbiAqIEByZXR1cm4ge1Byb21pc2V9XG4gKiBAYXBpIHB1YmxpY1xuICovXG5cblF1ZXJ5LnByb3RvdHlwZS5wb3N0ID0gZnVuY3Rpb24oZm4pIHtcbiAgdGhpcy5faG9va3MucG9zdCgnZXhlYycsIGZuKTtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIENhc3RzIG9iaiBmb3IgYW4gdXBkYXRlIGNvbW1hbmQuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IG9ialxuICogQHJldHVybiB7T2JqZWN0fSBvYmogYWZ0ZXIgY2FzdGluZyBpdHMgdmFsdWVzXG4gKiBAbWV0aG9kIF9jYXN0VXBkYXRlXG4gKiBAbWVtYmVyT2YgUXVlcnlcbiAqIEBpbnN0YW5jZVxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuUXVlcnkucHJvdG90eXBlLl9jYXN0VXBkYXRlID0gZnVuY3Rpb24gX2Nhc3RVcGRhdGUob2JqKSB7XG4gIGxldCBzY2hlbWEgPSB0aGlzLnNjaGVtYTtcblxuICBjb25zdCBkaXNjcmltaW5hdG9yS2V5ID0gc2NoZW1hLm9wdGlvbnMuZGlzY3JpbWluYXRvcktleTtcbiAgY29uc3QgYmFzZVNjaGVtYSA9IHNjaGVtYS5fYmFzZVNjaGVtYSA/IHNjaGVtYS5fYmFzZVNjaGVtYSA6IHNjaGVtYTtcbiAgaWYgKHRoaXMuX21vbmdvb3NlT3B0aW9ucy5vdmVyd3JpdGVEaXNjcmltaW5hdG9yS2V5ICYmXG4gICAgICBvYmpbZGlzY3JpbWluYXRvcktleV0gIT0gbnVsbCAmJlxuICAgICAgYmFzZVNjaGVtYS5kaXNjcmltaW5hdG9ycykge1xuICAgIGNvbnN0IF9zY2hlbWEgPSBPYmplY3QudmFsdWVzKGJhc2VTY2hlbWEuZGlzY3JpbWluYXRvcnMpLmZpbmQoXG4gICAgICBkaXNjcmltaW5hdG9yID0+IGRpc2NyaW1pbmF0b3IuZGlzY3JpbWluYXRvck1hcHBpbmcudmFsdWUgPT09IG9ialtkaXNjcmltaW5hdG9yS2V5XVxuICAgICk7XG4gICAgaWYgKF9zY2hlbWEgIT0gbnVsbCkge1xuICAgICAgc2NoZW1hID0gX3NjaGVtYTtcbiAgICB9XG4gIH1cblxuICBsZXQgdXBzZXJ0O1xuICBpZiAoJ3Vwc2VydCcgaW4gdGhpcy5vcHRpb25zKSB7XG4gICAgdXBzZXJ0ID0gdGhpcy5vcHRpb25zLnVwc2VydDtcbiAgfVxuXG4gIGNvbnN0IGZpbHRlciA9IHRoaXMuX2NvbmRpdGlvbnM7XG4gIGlmIChzY2hlbWEgIT0gbnVsbCAmJlxuICAgICAgdXRpbHMuaGFzVXNlckRlZmluZWRQcm9wZXJ0eShmaWx0ZXIsIHNjaGVtYS5vcHRpb25zLmRpc2NyaW1pbmF0b3JLZXkpICYmXG4gICAgICB0eXBlb2YgZmlsdGVyW3NjaGVtYS5vcHRpb25zLmRpc2NyaW1pbmF0b3JLZXldICE9PSAnb2JqZWN0JyAmJlxuICAgICAgc2NoZW1hLmRpc2NyaW1pbmF0b3JzICE9IG51bGwpIHtcbiAgICBjb25zdCBkaXNjcmltaW5hdG9yVmFsdWUgPSBmaWx0ZXJbc2NoZW1hLm9wdGlvbnMuZGlzY3JpbWluYXRvcktleV07XG4gICAgY29uc3QgYnlWYWx1ZSA9IGdldERpc2NyaW1pbmF0b3JCeVZhbHVlKHRoaXMubW9kZWwuZGlzY3JpbWluYXRvcnMsIGRpc2NyaW1pbmF0b3JWYWx1ZSk7XG4gICAgc2NoZW1hID0gc2NoZW1hLmRpc2NyaW1pbmF0b3JzW2Rpc2NyaW1pbmF0b3JWYWx1ZV0gfHxcbiAgICAgIChieVZhbHVlICYmIGJ5VmFsdWUuc2NoZW1hKSB8fFxuICAgICAgc2NoZW1hO1xuICB9XG5cbiAgcmV0dXJuIGNhc3RVcGRhdGUoc2NoZW1hLCBvYmosIHtcbiAgICBzdHJpY3Q6IHRoaXMuX21vbmdvb3NlT3B0aW9ucy5zdHJpY3QsXG4gICAgdXBzZXJ0OiB1cHNlcnQsXG4gICAgYXJyYXlGaWx0ZXJzOiB0aGlzLm9wdGlvbnMuYXJyYXlGaWx0ZXJzLFxuICAgIG92ZXJ3cml0ZURpc2NyaW1pbmF0b3JLZXk6IHRoaXMuX21vbmdvb3NlT3B0aW9ucy5vdmVyd3JpdGVEaXNjcmltaW5hdG9yS2V5XG4gIH0sIHRoaXMsIHRoaXMuX2NvbmRpdGlvbnMpO1xufTtcblxuLyoqXG4gKiBTcGVjaWZpZXMgcGF0aHMgd2hpY2ggc2hvdWxkIGJlIHBvcHVsYXRlZCB3aXRoIG90aGVyIGRvY3VtZW50cy5cbiAqXG4gKiAjIyMjIEV4YW1wbGU6XG4gKlxuICogICAgIGxldCBib29rID0gYXdhaXQgQm9vay5maW5kT25lKCkucG9wdWxhdGUoJ2F1dGhvcnMnKTtcbiAqICAgICBib29rLnRpdGxlOyAvLyAnTm9kZS5qcyBpbiBBY3Rpb24nXG4gKiAgICAgYm9vay5hdXRob3JzWzBdLm5hbWU7IC8vICdUSiBIb2xvd2F5Y2h1aydcbiAqICAgICBib29rLmF1dGhvcnNbMV0ubmFtZTsgLy8gJ05hdGhhbiBSYWpsaWNoJ1xuICpcbiAqICAgICBsZXQgYm9va3MgPSBhd2FpdCBCb29rLmZpbmQoKS5wb3B1bGF0ZSh7XG4gKiAgICAgICBwYXRoOiAnYXV0aG9ycycsXG4gKiAgICAgICAvLyBgbWF0Y2hgIGFuZCBgc29ydGAgYXBwbHkgdG8gdGhlIEF1dGhvciBtb2RlbCxcbiAqICAgICAgIC8vIG5vdCB0aGUgQm9vayBtb2RlbC4gVGhlc2Ugb3B0aW9ucyBkbyBub3QgYWZmZWN0XG4gKiAgICAgICAvLyB3aGljaCBkb2N1bWVudHMgYXJlIGluIGBib29rc2AsIGp1c3QgdGhlIG9yZGVyIGFuZFxuICogICAgICAgLy8gY29udGVudHMgb2YgZWFjaCBib29rIGRvY3VtZW50J3MgYGF1dGhvcnNgLlxuICogICAgICAgbWF0Y2g6IHsgbmFtZTogbmV3IFJlZ0V4cCgnLipoLionLCAnaScpIH0sXG4gKiAgICAgICBzb3J0OiB7IG5hbWU6IC0xIH1cbiAqICAgICB9KTtcbiAqICAgICBib29rc1swXS50aXRsZTsgLy8gJ05vZGUuanMgaW4gQWN0aW9uJ1xuICogICAgIC8vIEVhY2ggYm9vaydzIGBhdXRob3JzYCBhcmUgc29ydGVkIGJ5IG5hbWUsIGRlc2NlbmRpbmcuXG4gKiAgICAgYm9va3NbMF0uYXV0aG9yc1swXS5uYW1lOyAvLyAnVEogSG9sb3dheWNodWsnXG4gKiAgICAgYm9va3NbMF0uYXV0aG9yc1sxXS5uYW1lOyAvLyAnTWFyYyBIYXJ0ZXInXG4gKlxuICogICAgIGJvb2tzWzFdLnRpdGxlOyAvLyAnUHJvZmVzc2lvbmFsIEFuZ3VsYXJKUydcbiAqICAgICAvLyBFbXB0eSBhcnJheSwgbm8gYXV0aG9ycycgbmFtZSBoYXMgdGhlIGxldHRlciAnaCdcbiAqICAgICBib29rc1sxXS5hdXRob3JzOyAvLyBbXVxuICpcbiAqIFBhdGhzIGFyZSBwb3B1bGF0ZWQgYWZ0ZXIgdGhlIHF1ZXJ5IGV4ZWN1dGVzIGFuZCBhIHJlc3BvbnNlIGlzIHJlY2VpdmVkLiBBXG4gKiBzZXBhcmF0ZSBxdWVyeSBpcyB0aGVuIGV4ZWN1dGVkIGZvciBlYWNoIHBhdGggc3BlY2lmaWVkIGZvciBwb3B1bGF0aW9uLiBBZnRlclxuICogYSByZXNwb25zZSBmb3IgZWFjaCBxdWVyeSBoYXMgYWxzbyBiZWVuIHJldHVybmVkLCB0aGUgcmVzdWx0cyBhcmUgcGFzc2VkIHRvXG4gKiB0aGUgY2FsbGJhY2suXG4gKlxuICogQHBhcmFtIHtPYmplY3R8U3RyaW5nfFN0cmluZ1tdfSBwYXRoIGVpdGhlciB0aGUgcGF0aChzKSB0byBwb3B1bGF0ZSBvciBhbiBvYmplY3Qgc3BlY2lmeWluZyBhbGwgcGFyYW1ldGVyc1xuICogQHBhcmFtIHtPYmplY3R8U3RyaW5nfSBbc2VsZWN0XSBGaWVsZCBzZWxlY3Rpb24gZm9yIHRoZSBwb3B1bGF0aW9uIHF1ZXJ5XG4gKiBAcGFyYW0ge01vZGVsfSBbbW9kZWxdIFRoZSBtb2RlbCB5b3Ugd2lzaCB0byB1c2UgZm9yIHBvcHVsYXRpb24uIElmIG5vdCBzcGVjaWZpZWQsIHBvcHVsYXRlIHdpbGwgbG9vayB1cCB0aGUgbW9kZWwgYnkgdGhlIG5hbWUgaW4gdGhlIFNjaGVtYSdzIGByZWZgIGZpZWxkLlxuICogQHBhcmFtIHtPYmplY3R9IFttYXRjaF0gQ29uZGl0aW9ucyBmb3IgdGhlIHBvcHVsYXRpb24gcXVlcnlcbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gT3B0aW9ucyBmb3IgdGhlIHBvcHVsYXRpb24gcXVlcnkgKHNvcnQsIGV0YylcbiAqIEBwYXJhbSB7U3RyaW5nfSBbb3B0aW9ucy5wYXRoPW51bGxdIFRoZSBwYXRoIHRvIHBvcHVsYXRlLlxuICogQHBhcmFtIHtib29sZWFufSBbb3B0aW9ucy5yZXRhaW5OdWxsVmFsdWVzPWZhbHNlXSBieSBkZWZhdWx0LCBNb25nb29zZSByZW1vdmVzIG51bGwgYW5kIHVuZGVmaW5lZCB2YWx1ZXMgZnJvbSBwb3B1bGF0ZWQgYXJyYXlzLiBVc2UgdGhpcyBvcHRpb24gdG8gbWFrZSBgcG9wdWxhdGUoKWAgcmV0YWluIGBudWxsYCBhbmQgYHVuZGVmaW5lZGAgYXJyYXkgZW50cmllcy5cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdGlvbnMuZ2V0dGVycz1mYWxzZV0gaWYgdHJ1ZSwgTW9uZ29vc2Ugd2lsbCBjYWxsIGFueSBnZXR0ZXJzIGRlZmluZWQgb24gdGhlIGBsb2NhbEZpZWxkYC4gQnkgZGVmYXVsdCwgTW9uZ29vc2UgZ2V0cyB0aGUgcmF3IHZhbHVlIG9mIGBsb2NhbEZpZWxkYC4gRm9yIGV4YW1wbGUsIHlvdSB3b3VsZCBuZWVkIHRvIHNldCB0aGlzIG9wdGlvbiB0byBgdHJ1ZWAgaWYgeW91IHdhbnRlZCB0byBbYWRkIGEgYGxvd2VyY2FzZWAgZ2V0dGVyIHRvIHlvdXIgYGxvY2FsRmllbGRgXShodHRwczovL21vbmdvb3NlanMuY29tL2RvY3Mvc2NoZW1hdHlwZXMuaHRtbCNzY2hlbWF0eXBlLW9wdGlvbnMpLlxuICogQHBhcmFtIHtib29sZWFufSBbb3B0aW9ucy5jbG9uZT1mYWxzZV0gV2hlbiB5b3UgZG8gYEJsb2dQb3N0LmZpbmQoKS5wb3B1bGF0ZSgnYXV0aG9yJylgLCBibG9nIHBvc3RzIHdpdGggdGhlIHNhbWUgYXV0aG9yIHdpbGwgc2hhcmUgMSBjb3B5IG9mIGFuIGBhdXRob3JgIGRvYy4gRW5hYmxlIHRoaXMgb3B0aW9uIHRvIG1ha2UgTW9uZ29vc2UgY2xvbmUgcG9wdWxhdGVkIGRvY3MgYmVmb3JlIGFzc2lnbmluZyB0aGVtLlxuICogQHBhcmFtIHtPYmplY3R8RnVuY3Rpb259IFtvcHRpb25zLm1hdGNoPW51bGxdIEFkZCBhbiBhZGRpdGlvbmFsIGZpbHRlciB0byB0aGUgcG9wdWxhdGUgcXVlcnkuIENhbiBiZSBhIGZpbHRlciBvYmplY3QgY29udGFpbmluZyBbTW9uZ29EQiBxdWVyeSBzeW50YXhdKGh0dHBzOi8vd3d3Lm1vbmdvZGIuY29tL2RvY3MvbWFudWFsL3R1dG9yaWFsL3F1ZXJ5LWRvY3VtZW50cy8pLCBvciBhIGZ1bmN0aW9uIHRoYXQgcmV0dXJucyBhIGZpbHRlciBvYmplY3QuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbb3B0aW9ucy50cmFuc2Zvcm09bnVsbF0gRnVuY3Rpb24gdGhhdCBNb25nb29zZSB3aWxsIGNhbGwgb24gZXZlcnkgcG9wdWxhdGVkIGRvY3VtZW50IHRoYXQgYWxsb3dzIHlvdSB0byB0cmFuc2Zvcm0gdGhlIHBvcHVsYXRlZCBkb2N1bWVudC5cbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9ucy5vcHRpb25zPW51bGxdIEFkZGl0aW9uYWwgb3B0aW9ucyBsaWtlIGBsaW1pdGAgYW5kIGBsZWFuYC5cbiAqIEBzZWUgcG9wdWxhdGlvbiBodHRwczovL21vbmdvb3NlanMuY29tL2RvY3MvcG9wdWxhdGUuaHRtbFxuICogQHNlZSBRdWVyeSNzZWxlY3QgaHR0cHM6Ly9tb25nb29zZWpzLmNvbS9kb2NzL2FwaS9xdWVyeS5odG1sI1F1ZXJ5LnByb3RvdHlwZS5zZWxlY3QoKVxuICogQHNlZSBNb2RlbC5wb3B1bGF0ZSBodHRwczovL21vbmdvb3NlanMuY29tL2RvY3MvYXBpL21vZGVsLmh0bWwjTW9kZWwucG9wdWxhdGUoKVxuICogQHJldHVybiB7UXVlcnl9IHRoaXNcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuUXVlcnkucHJvdG90eXBlLnBvcHVsYXRlID0gZnVuY3Rpb24oKSB7XG4gIC8vIEJhaWwgd2hlbiBnaXZlbiBubyB0cnV0aHkgYXJndW1lbnRzXG4gIGlmICghQXJyYXkuZnJvbShhcmd1bWVudHMpLnNvbWUoQm9vbGVhbikpIHtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIGNvbnN0IHJlcyA9IHV0aWxzLnBvcHVsYXRlLmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7XG5cbiAgLy8gUHJvcGFnYXRlIHJlYWRDb25jZXJuIGFuZCByZWFkUHJlZmVyZW5jZSBhbmQgbGVhbiBmcm9tIHBhcmVudCBxdWVyeSxcbiAgLy8gdW5sZXNzIG9uZSBhbHJlYWR5IHNwZWNpZmllZFxuICBpZiAodGhpcy5vcHRpb25zICE9IG51bGwpIHtcbiAgICBjb25zdCByZWFkQ29uY2VybiA9IHRoaXMub3B0aW9ucy5yZWFkQ29uY2VybjtcbiAgICBjb25zdCByZWFkUHJlZiA9IHRoaXMub3B0aW9ucy5yZWFkUHJlZmVyZW5jZTtcblxuICAgIGZvciAoY29uc3QgcG9wdWxhdGVPcHRpb25zIG9mIHJlcykge1xuICAgICAgaWYgKHJlYWRDb25jZXJuICE9IG51bGwgJiYgKHBvcHVsYXRlT3B0aW9ucyAmJiBwb3B1bGF0ZU9wdGlvbnMub3B0aW9ucyAmJiBwb3B1bGF0ZU9wdGlvbnMub3B0aW9ucy5yZWFkQ29uY2VybikgPT0gbnVsbCkge1xuICAgICAgICBwb3B1bGF0ZU9wdGlvbnMub3B0aW9ucyA9IHBvcHVsYXRlT3B0aW9ucy5vcHRpb25zIHx8IHt9O1xuICAgICAgICBwb3B1bGF0ZU9wdGlvbnMub3B0aW9ucy5yZWFkQ29uY2VybiA9IHJlYWRDb25jZXJuO1xuICAgICAgfVxuICAgICAgaWYgKHJlYWRQcmVmICE9IG51bGwgJiYgKHBvcHVsYXRlT3B0aW9ucyAmJiBwb3B1bGF0ZU9wdGlvbnMub3B0aW9ucyAmJiBwb3B1bGF0ZU9wdGlvbnMub3B0aW9ucy5yZWFkUHJlZmVyZW5jZSkgPT0gbnVsbCkge1xuICAgICAgICBwb3B1bGF0ZU9wdGlvbnMub3B0aW9ucyA9IHBvcHVsYXRlT3B0aW9ucy5vcHRpb25zIHx8IHt9O1xuICAgICAgICBwb3B1bGF0ZU9wdGlvbnMub3B0aW9ucy5yZWFkUHJlZmVyZW5jZSA9IHJlYWRQcmVmO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGNvbnN0IG9wdHMgPSB0aGlzLl9tb25nb29zZU9wdGlvbnM7XG5cbiAgaWYgKG9wdHMubGVhbiAhPSBudWxsKSB7XG4gICAgY29uc3QgbGVhbiA9IG9wdHMubGVhbjtcbiAgICBmb3IgKGNvbnN0IHBvcHVsYXRlT3B0aW9ucyBvZiByZXMpIHtcbiAgICAgIGlmICgocG9wdWxhdGVPcHRpb25zICYmIHBvcHVsYXRlT3B0aW9ucy5vcHRpb25zICYmIHBvcHVsYXRlT3B0aW9ucy5vcHRpb25zLmxlYW4pID09IG51bGwpIHtcbiAgICAgICAgcG9wdWxhdGVPcHRpb25zLm9wdGlvbnMgPSBwb3B1bGF0ZU9wdGlvbnMub3B0aW9ucyB8fCB7fTtcbiAgICAgICAgcG9wdWxhdGVPcHRpb25zLm9wdGlvbnMubGVhbiA9IGxlYW47XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgaWYgKCF1dGlscy5pc09iamVjdChvcHRzLnBvcHVsYXRlKSkge1xuICAgIG9wdHMucG9wdWxhdGUgPSB7fTtcbiAgfVxuXG4gIGNvbnN0IHBvcCA9IG9wdHMucG9wdWxhdGU7XG5cbiAgZm9yIChjb25zdCBwb3B1bGF0ZU9wdGlvbnMgb2YgcmVzKSB7XG4gICAgY29uc3QgcGF0aCA9IHBvcHVsYXRlT3B0aW9ucy5wYXRoO1xuICAgIGlmIChwb3BbcGF0aF0gJiYgcG9wW3BhdGhdLnBvcHVsYXRlICYmIHBvcHVsYXRlT3B0aW9ucy5wb3B1bGF0ZSkge1xuICAgICAgcG9wdWxhdGVPcHRpb25zLnBvcHVsYXRlID0gcG9wW3BhdGhdLnBvcHVsYXRlLmNvbmNhdChwb3B1bGF0ZU9wdGlvbnMucG9wdWxhdGUpO1xuICAgIH1cblxuICAgIHBvcFtwb3B1bGF0ZU9wdGlvbnMucGF0aF0gPSBwb3B1bGF0ZU9wdGlvbnM7XG4gIH1cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIEdldHMgYSBsaXN0IG9mIHBhdGhzIHRvIGJlIHBvcHVsYXRlZCBieSB0aGlzIHF1ZXJ5XG4gKlxuICogIyMjIyBFeGFtcGxlOlxuICpcbiAqICAgICAgYm9va1NjaGVtYS5wcmUoJ2ZpbmRPbmUnLCBmdW5jdGlvbigpIHtcbiAqICAgICAgICBsZXQga2V5cyA9IHRoaXMuZ2V0UG9wdWxhdGVkUGF0aHMoKTsgLy8gWydhdXRob3InXVxuICogICAgICB9KTtcbiAqICAgICAgLi4uXG4gKiAgICAgIEJvb2suZmluZE9uZSh7fSkucG9wdWxhdGUoJ2F1dGhvcicpO1xuICpcbiAqICMjIyMgRXhhbXBsZTpcbiAqXG4gKiAgICAgIC8vIERlZXAgcG9wdWxhdGVcbiAqICAgICAgY29uc3QgcSA9IEwxLmZpbmQoKS5wb3B1bGF0ZSh7XG4gKiAgICAgICAgcGF0aDogJ2xldmVsMicsXG4gKiAgICAgICAgcG9wdWxhdGU6IHsgcGF0aDogJ2xldmVsMycgfVxuICogICAgICB9KTtcbiAqICAgICAgcS5nZXRQb3B1bGF0ZWRQYXRocygpOyAvLyBbJ2xldmVsMicsICdsZXZlbDIubGV2ZWwzJ11cbiAqXG4gKiBAcmV0dXJuIHtBcnJheX0gYW4gYXJyYXkgb2Ygc3RyaW5ncyByZXByZXNlbnRpbmcgcG9wdWxhdGVkIHBhdGhzXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cblF1ZXJ5LnByb3RvdHlwZS5nZXRQb3B1bGF0ZWRQYXRocyA9IGZ1bmN0aW9uIGdldFBvcHVsYXRlZFBhdGhzKCkge1xuICBjb25zdCBvYmogPSB0aGlzLl9tb25nb29zZU9wdGlvbnMucG9wdWxhdGUgfHwge307XG4gIGNvbnN0IHJldCA9IE9iamVjdC5rZXlzKG9iaik7XG4gIGZvciAoY29uc3QgcGF0aCBvZiBPYmplY3Qua2V5cyhvYmopKSB7XG4gICAgY29uc3QgcG9wID0gb2JqW3BhdGhdO1xuICAgIGlmICghQXJyYXkuaXNBcnJheShwb3AucG9wdWxhdGUpKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgX2dldFBvcHVsYXRlZFBhdGhzKHJldCwgcG9wLnBvcHVsYXRlLCBwYXRoICsgJy4nKTtcbiAgfVxuICByZXR1cm4gcmV0O1xufTtcblxuLyohXG4gKiBpZ25vcmVcbiAqL1xuXG5mdW5jdGlvbiBfZ2V0UG9wdWxhdGVkUGF0aHMobGlzdCwgYXJyLCBwcmVmaXgpIHtcbiAgZm9yIChjb25zdCBwb3Agb2YgYXJyKSB7XG4gICAgbGlzdC5wdXNoKHByZWZpeCArIHBvcC5wYXRoKTtcbiAgICBpZiAoIUFycmF5LmlzQXJyYXkocG9wLnBvcHVsYXRlKSkge1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIF9nZXRQb3B1bGF0ZWRQYXRocyhsaXN0LCBwb3AucG9wdWxhdGUsIHByZWZpeCArIHBvcC5wYXRoICsgJy4nKTtcbiAgfVxufVxuXG4vKipcbiAqIENhc3RzIHRoaXMgcXVlcnkgdG8gdGhlIHNjaGVtYSBvZiBgbW9kZWxgXG4gKlxuICogIyMjIyBOb3RlOlxuICpcbiAqIElmIGBvYmpgIGlzIHByZXNlbnQsIGl0IGlzIGNhc3QgaW5zdGVhZCBvZiB0aGlzIHF1ZXJ5LlxuICpcbiAqIEBwYXJhbSB7TW9kZWx9IFttb2RlbF0gdGhlIG1vZGVsIHRvIGNhc3QgdG8uIElmIG5vdCBzZXQsIGRlZmF1bHRzIHRvIGB0aGlzLm1vZGVsYFxuICogQHBhcmFtIHtPYmplY3R9IFtvYmpdXG4gKiBAcmV0dXJuIHtPYmplY3R9XG4gKiBAYXBpIHB1YmxpY1xuICovXG5cblF1ZXJ5LnByb3RvdHlwZS5jYXN0ID0gZnVuY3Rpb24obW9kZWwsIG9iaikge1xuICBvYmogfHwgKG9iaiA9IHRoaXMuX2NvbmRpdGlvbnMpO1xuICBtb2RlbCA9IG1vZGVsIHx8IHRoaXMubW9kZWw7XG4gIGNvbnN0IGRpc2NyaW1pbmF0b3JLZXkgPSBtb2RlbC5zY2hlbWEub3B0aW9ucy5kaXNjcmltaW5hdG9yS2V5O1xuICBpZiAob2JqICE9IG51bGwgJiZcbiAgICAgIG9iai5oYXNPd25Qcm9wZXJ0eShkaXNjcmltaW5hdG9yS2V5KSkge1xuICAgIG1vZGVsID0gZ2V0RGlzY3JpbWluYXRvckJ5VmFsdWUobW9kZWwuZGlzY3JpbWluYXRvcnMsIG9ialtkaXNjcmltaW5hdG9yS2V5XSkgfHwgbW9kZWw7XG4gIH1cblxuICBjb25zdCBvcHRzID0geyB1cHNlcnQ6IHRoaXMub3B0aW9ucyAmJiB0aGlzLm9wdGlvbnMudXBzZXJ0IH07XG4gIGlmICh0aGlzLm9wdGlvbnMpIHtcbiAgICBpZiAoJ3N0cmljdCcgaW4gdGhpcy5vcHRpb25zKSB7XG4gICAgICBvcHRzLnN0cmljdCA9IHRoaXMub3B0aW9ucy5zdHJpY3Q7XG4gICAgfVxuICAgIGlmICgnc3RyaWN0UXVlcnknIGluIHRoaXMub3B0aW9ucykge1xuICAgICAgb3B0cy5zdHJpY3RRdWVyeSA9IHRoaXMub3B0aW9ucy5zdHJpY3RRdWVyeTtcbiAgICB9XG4gIH1cblxuICB0cnkge1xuICAgIHJldHVybiBjYXN0KG1vZGVsLnNjaGVtYSwgb2JqLCBvcHRzLCB0aGlzKTtcbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgLy8gQ2FzdEVycm9yLCBhc3NpZ24gbW9kZWxcbiAgICBpZiAodHlwZW9mIGVyci5zZXRNb2RlbCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgZXJyLnNldE1vZGVsKG1vZGVsKTtcbiAgICB9XG4gICAgdGhyb3cgZXJyO1xuICB9XG59O1xuXG4vKipcbiAqIENhc3RzIHNlbGVjdGVkIGZpZWxkIGFyZ3VtZW50cyBmb3IgZmllbGQgc2VsZWN0aW9uIHdpdGggbW9uZ28gMi4yXG4gKlxuICogICAgIHF1ZXJ5LnNlbGVjdCh7IGlkczogeyAkZWxlbU1hdGNoOiB7ICRpbjogW2hleFN0cmluZ10gfX0pXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IGZpZWxkc1xuICogQHNlZSBodHRwczovL2dpdGh1Yi5jb20vQXV0b21hdHRpYy9tb25nb29zZS9pc3N1ZXMvMTA5MVxuICogQHNlZSBodHRwczovL3d3dy5tb25nb2RiLmNvbS9kb2NzL21hbnVhbC9yZWZlcmVuY2UvcHJvamVjdGlvbi9lbGVtTWF0Y2gvXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5RdWVyeS5wcm90b3R5cGUuX2Nhc3RGaWVsZHMgPSBmdW5jdGlvbiBfY2FzdEZpZWxkcyhmaWVsZHMpIHtcbiAgbGV0IHNlbGVjdGVkLFxuICAgICAgZWxlbU1hdGNoS2V5cyxcbiAgICAgIGtleXMsXG4gICAgICBrZXksXG4gICAgICBvdXQsXG4gICAgICBpO1xuXG4gIGlmIChmaWVsZHMpIHtcbiAgICBrZXlzID0gT2JqZWN0LmtleXMoZmllbGRzKTtcbiAgICBlbGVtTWF0Y2hLZXlzID0gW107XG4gICAgaSA9IGtleXMubGVuZ3RoO1xuXG4gICAgLy8gY29sbGVjdCAkZWxlbU1hdGNoIGFyZ3NcbiAgICB3aGlsZSAoaS0tKSB7XG4gICAgICBrZXkgPSBrZXlzW2ldO1xuICAgICAgaWYgKGZpZWxkc1trZXldLiRlbGVtTWF0Y2gpIHtcbiAgICAgICAgc2VsZWN0ZWQgfHwgKHNlbGVjdGVkID0ge30pO1xuICAgICAgICBzZWxlY3RlZFtrZXldID0gZmllbGRzW2tleV07XG4gICAgICAgIGVsZW1NYXRjaEtleXMucHVzaChrZXkpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGlmIChzZWxlY3RlZCkge1xuICAgIC8vIHRoZXkgcGFzc2VkICRlbGVtTWF0Y2gsIGNhc3QgZW1cbiAgICB0cnkge1xuICAgICAgb3V0ID0gdGhpcy5jYXN0KHRoaXMubW9kZWwsIHNlbGVjdGVkKTtcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIHJldHVybiBlcnI7XG4gICAgfVxuXG4gICAgLy8gYXBwbHkgdGhlIGNhc3RlZCBmaWVsZCBhcmdzXG4gICAgaSA9IGVsZW1NYXRjaEtleXMubGVuZ3RoO1xuICAgIHdoaWxlIChpLS0pIHtcbiAgICAgIGtleSA9IGVsZW1NYXRjaEtleXNbaV07XG4gICAgICBmaWVsZHNba2V5XSA9IG91dFtrZXldO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBmaWVsZHM7XG59O1xuXG4vKipcbiAqIEFwcGxpZXMgc2NoZW1hdHlwZSBzZWxlY3RlZCBvcHRpb25zIHRvIHRoaXMgcXVlcnkuXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5RdWVyeS5wcm90b3R5cGUuX2FwcGx5UGF0aHMgPSBmdW5jdGlvbiBhcHBseVBhdGhzKCkge1xuICBpZiAoIXRoaXMubW9kZWwpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgdGhpcy5fZmllbGRzID0gdGhpcy5fZmllbGRzIHx8IHt9O1xuICBoZWxwZXJzLmFwcGx5UGF0aHModGhpcy5fZmllbGRzLCB0aGlzLm1vZGVsLnNjaGVtYSk7XG5cbiAgbGV0IF9zZWxlY3RQb3B1bGF0ZWRQYXRocyA9IHRydWU7XG5cbiAgaWYgKCdzZWxlY3RQb3B1bGF0ZWRQYXRocycgaW4gdGhpcy5tb2RlbC5iYXNlLm9wdGlvbnMpIHtcbiAgICBfc2VsZWN0UG9wdWxhdGVkUGF0aHMgPSB0aGlzLm1vZGVsLmJhc2Uub3B0aW9ucy5zZWxlY3RQb3B1bGF0ZWRQYXRocztcbiAgfVxuICBpZiAoJ3NlbGVjdFBvcHVsYXRlZFBhdGhzJyBpbiB0aGlzLm1vZGVsLnNjaGVtYS5vcHRpb25zKSB7XG4gICAgX3NlbGVjdFBvcHVsYXRlZFBhdGhzID0gdGhpcy5tb2RlbC5zY2hlbWEub3B0aW9ucy5zZWxlY3RQb3B1bGF0ZWRQYXRocztcbiAgfVxuXG4gIGlmIChfc2VsZWN0UG9wdWxhdGVkUGF0aHMpIHtcbiAgICBzZWxlY3RQb3B1bGF0ZWRGaWVsZHModGhpcy5fZmllbGRzLCB0aGlzLl91c2VyUHJvdmlkZWRGaWVsZHMsIHRoaXMuX21vbmdvb3NlT3B0aW9ucy5wb3B1bGF0ZSk7XG4gIH1cbn07XG5cbi8qKlxuICogUmV0dXJucyBhIHdyYXBwZXIgYXJvdW5kIGEgW21vbmdvZGIgZHJpdmVyIGN1cnNvcl0oaHR0cHM6Ly9tb25nb2RiLmdpdGh1Yi5pby9ub2RlLW1vbmdvZGItbmF0aXZlLzQuOS9jbGFzc2VzL0ZpbmRDdXJzb3IuaHRtbCkuXG4gKiBBIFF1ZXJ5Q3Vyc29yIGV4cG9zZXMgYSBTdHJlYW1zMyBpbnRlcmZhY2UsIGFzIHdlbGwgYXMgYSBgLm5leHQoKWAgZnVuY3Rpb24uXG4gKlxuICogVGhlIGAuY3Vyc29yKClgIGZ1bmN0aW9uIHRyaWdnZXJzIHByZSBmaW5kIGhvb2tzLCBidXQgKipub3QqKiBwb3N0IGZpbmQgaG9va3MuXG4gKlxuICogIyMjIyBFeGFtcGxlOlxuICpcbiAqICAgICAvLyBUaGVyZSBhcmUgMiB3YXlzIHRvIHVzZSBhIGN1cnNvci4gRmlyc3QsIGFzIGEgc3RyZWFtOlxuICogICAgIFRoaW5nLlxuICogICAgICAgZmluZCh7IG5hbWU6IC9eaGVsbG8vIH0pLlxuICogICAgICAgY3Vyc29yKCkuXG4gKiAgICAgICBvbignZGF0YScsIGZ1bmN0aW9uKGRvYykgeyBjb25zb2xlLmxvZyhkb2MpOyB9KS5cbiAqICAgICAgIG9uKCdlbmQnLCBmdW5jdGlvbigpIHsgY29uc29sZS5sb2coJ0RvbmUhJyk7IH0pO1xuICpcbiAqICAgICAvLyBPciB5b3UgY2FuIHVzZSBgLm5leHQoKWAgdG8gbWFudWFsbHkgZ2V0IHRoZSBuZXh0IGRvYyBpbiB0aGUgc3RyZWFtLlxuICogICAgIC8vIGAubmV4dCgpYCByZXR1cm5zIGEgcHJvbWlzZSwgc28geW91IGNhbiB1c2UgcHJvbWlzZXMgb3IgY2FsbGJhY2tzLlxuICogICAgIGNvbnN0IGN1cnNvciA9IFRoaW5nLmZpbmQoeyBuYW1lOiAvXmhlbGxvLyB9KS5jdXJzb3IoKTtcbiAqICAgICBjdXJzb3IubmV4dChmdW5jdGlvbihlcnJvciwgZG9jKSB7XG4gKiAgICAgICBjb25zb2xlLmxvZyhkb2MpO1xuICogICAgIH0pO1xuICpcbiAqICAgICAvLyBCZWNhdXNlIGAubmV4dCgpYCByZXR1cm5zIGEgcHJvbWlzZSwgeW91IGNhbiB1c2UgY29cbiAqICAgICAvLyB0byBlYXNpbHkgaXRlcmF0ZSB0aHJvdWdoIGFsbCBkb2N1bWVudHMgd2l0aG91dCBsb2FkaW5nIHRoZW1cbiAqICAgICAvLyBhbGwgaW50byBtZW1vcnkuXG4gKiAgICAgY29uc3QgY3Vyc29yID0gVGhpbmcuZmluZCh7IG5hbWU6IC9eaGVsbG8vIH0pLmN1cnNvcigpO1xuICogICAgIGZvciAobGV0IGRvYyA9IGF3YWl0IGN1cnNvci5uZXh0KCk7IGRvYyAhPSBudWxsOyBkb2MgPSBhd2FpdCBjdXJzb3IubmV4dCgpKSB7XG4gKiAgICAgICBjb25zb2xlLmxvZyhkb2MpO1xuICogICAgIH1cbiAqXG4gKiAjIyMjIFZhbGlkIG9wdGlvbnNcbiAqXG4gKiAgIC0gYHRyYW5zZm9ybWA6IG9wdGlvbmFsIGZ1bmN0aW9uIHdoaWNoIGFjY2VwdHMgYSBtb25nb29zZSBkb2N1bWVudC4gVGhlIHJldHVybiB2YWx1ZSBvZiB0aGUgZnVuY3Rpb24gd2lsbCBiZSBlbWl0dGVkIG9uIGBkYXRhYCBhbmQgcmV0dXJuZWQgYnkgYC5uZXh0KClgLlxuICpcbiAqIEByZXR1cm4ge1F1ZXJ5Q3Vyc29yfVxuICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXVxuICogQHNlZSBRdWVyeUN1cnNvciBodHRwczovL21vbmdvb3NlanMuY29tL2RvY3MvYXBpL3F1ZXJ5Y3Vyc29yLmh0bWxcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuUXVlcnkucHJvdG90eXBlLmN1cnNvciA9IGZ1bmN0aW9uIGN1cnNvcihvcHRzKSB7XG4gIGlmIChvcHRzKSB7XG4gICAgdGhpcy5zZXRPcHRpb25zKG9wdHMpO1xuICB9XG5cbiAgdHJ5IHtcbiAgICB0aGlzLmNhc3QodGhpcy5tb2RlbCk7XG4gIH0gY2F0Y2ggKGVycikge1xuICAgIHJldHVybiAobmV3IFF1ZXJ5Q3Vyc29yKHRoaXMpKS5fbWFya0Vycm9yKGVycik7XG4gIH1cblxuICByZXR1cm4gbmV3IFF1ZXJ5Q3Vyc29yKHRoaXMpO1xufTtcblxuLy8gdGhlIHJlc3Qgb2YgdGhlc2UgYXJlIGJhc2ljYWxseSB0byBzdXBwb3J0IG9sZGVyIE1vbmdvb3NlIHN5bnRheCB3aXRoIG1xdWVyeVxuXG4vKipcbiAqIFNldHMgdGhlIHRhaWxhYmxlIG9wdGlvbiAoZm9yIHVzZSB3aXRoIGNhcHBlZCBjb2xsZWN0aW9ucykuXG4gKlxuICogIyMjIyBFeGFtcGxlOlxuICpcbiAqICAgICBxdWVyeS50YWlsYWJsZSgpOyAvLyB0cnVlXG4gKiAgICAgcXVlcnkudGFpbGFibGUodHJ1ZSk7XG4gKiAgICAgcXVlcnkudGFpbGFibGUoZmFsc2UpO1xuICpcbiAqICAgICAvLyBTZXQgYm90aCBgdGFpbGFibGVgIGFuZCBgYXdhaXREYXRhYCBvcHRpb25zXG4gKiAgICAgcXVlcnkudGFpbGFibGUoeyBhd2FpdERhdGE6IHRydWUgfSk7XG4gKlxuICogIyMjIyBOb3RlOlxuICpcbiAqIENhbm5vdCBiZSB1c2VkIHdpdGggYGRpc3RpbmN0KClgXG4gKlxuICogQHBhcmFtIHtCb29sZWFufSBib29sIGRlZmF1bHRzIHRvIHRydWVcbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0c10gb3B0aW9ucyB0byBzZXRcbiAqIEBwYXJhbSB7Qm9vbGVhbn0gW29wdHMuYXdhaXREYXRhXSBmYWxzZSBieSBkZWZhdWx0LiBTZXQgdG8gdHJ1ZSB0byBrZWVwIHRoZSBjdXJzb3Igb3BlbiBldmVuIGlmIHRoZXJlJ3Mgbm8gZGF0YS5cbiAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0cy5tYXhBd2FpdFRpbWVNU10gdGhlIG1heGltdW0gYW1vdW50IG9mIHRpbWUgZm9yIHRoZSBzZXJ2ZXIgdG8gd2FpdCBvbiBuZXcgZG9jdW1lbnRzIHRvIHNhdGlzZnkgYSB0YWlsYWJsZSBjdXJzb3IgcXVlcnkuIFJlcXVpcmVzIGB0YWlsYWJsZWAgYW5kIGBhd2FpdERhdGFgIHRvIGJlIHRydWVcbiAqIEBzZWUgdGFpbGFibGUgaHR0cHM6Ly93d3cubW9uZ29kYi5jb20vZG9jcy9tYW51YWwvdHV0b3JpYWwvY3JlYXRlLXRhaWxhYmxlLWN1cnNvci9cbiAqIEBhcGkgcHVibGljXG4gKi9cblxuUXVlcnkucHJvdG90eXBlLnRhaWxhYmxlID0gZnVuY3Rpb24odmFsLCBvcHRzKSB7XG4gIC8vIHdlIG5lZWQgdG8gc3VwcG9ydCB0aGUgdGFpbGFibGUoeyBhd2FpdERhdGEgOiB0cnVlIH0pIGFzIHdlbGwgYXMgdGhlXG4gIC8vIHRhaWxhYmxlKHRydWUsIHthd2FpdERhdGEgOnRydWV9KSBzeW50YXggdGhhdCBtcXVlcnkgZG9lcyBub3Qgc3VwcG9ydFxuICBpZiAodmFsICE9IG51bGwgJiYgdHlwZW9mIHZhbC5jb25zdHJ1Y3RvciA9PT0gJ2Z1bmN0aW9uJyAmJiB2YWwuY29uc3RydWN0b3IubmFtZSA9PT0gJ09iamVjdCcpIHtcbiAgICBvcHRzID0gdmFsO1xuICAgIHZhbCA9IHRydWU7XG4gIH1cblxuICBpZiAodmFsID09PSB1bmRlZmluZWQpIHtcbiAgICB2YWwgPSB0cnVlO1xuICB9XG5cbiAgaWYgKG9wdHMgJiYgdHlwZW9mIG9wdHMgPT09ICdvYmplY3QnKSB7XG4gICAgZm9yIChjb25zdCBrZXkgb2YgT2JqZWN0LmtleXMob3B0cykpIHtcbiAgICAgIGlmIChrZXkgPT09ICdhd2FpdERhdGEnIHx8IGtleSA9PT0gJ2F3YWl0ZGF0YScpIHsgLy8gYmFja3dhcmRzIGNvbXBhdCwgc2VlIGdoLTEwODc1XG4gICAgICAgIC8vIEZvciBiYWNrd2FyZHMgY29tcGF0aWJpbGl0eVxuICAgICAgICB0aGlzLm9wdGlvbnNbJ2F3YWl0RGF0YSddID0gISFvcHRzW2tleV07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLm9wdGlvbnNba2V5XSA9IG9wdHNba2V5XTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICB0aGlzLm9wdGlvbnMudGFpbGFibGUgPSBhcmd1bWVudHMubGVuZ3RoID8gISF2YWwgOiB0cnVlO1xuXG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBEZWNsYXJlcyBhbiBpbnRlcnNlY3RzIHF1ZXJ5IGZvciBgZ2VvbWV0cnkoKWAuXG4gKlxuICogIyMjIyBFeGFtcGxlOlxuICpcbiAqICAgICBxdWVyeS53aGVyZSgncGF0aCcpLmludGVyc2VjdHMoKS5nZW9tZXRyeSh7XG4gKiAgICAgICB0eXBlOiAnTGluZVN0cmluZycsXG4gKiAgICAgICBjb29yZGluYXRlczogW1sxODAuMCwgMTEuMF0sIFsxODAsIDkuMF1dXG4gKiAgICAgfSk7XG4gKlxuICogICAgIHF1ZXJ5LndoZXJlKCdwYXRoJykuaW50ZXJzZWN0cyh7XG4gKiAgICAgICB0eXBlOiAnTGluZVN0cmluZycsXG4gKiAgICAgICBjb29yZGluYXRlczogW1sxODAuMCwgMTEuMF0sIFsxODAsIDkuMF1dXG4gKiAgICAgfSk7XG4gKlxuICogIyMjIyBOb3RlOlxuICpcbiAqICoqTVVTVCoqIGJlIHVzZWQgYWZ0ZXIgYHdoZXJlKClgLlxuICpcbiAqICMjIyMgTm90ZTpcbiAqXG4gKiBJbiBNb25nb29zZSAzLjcsIGBpbnRlcnNlY3RzYCBjaGFuZ2VkIGZyb20gYSBnZXR0ZXIgdG8gYSBmdW5jdGlvbi4gSWYgeW91IG5lZWQgdGhlIG9sZCBzeW50YXgsIHVzZSBbdGhpc10oaHR0cHM6Ly9naXRodWIuY29tL2ViZW5zaW5nL21vbmdvb3NlLXdpdGhpbikuXG4gKlxuICogQG1ldGhvZCBpbnRlcnNlY3RzXG4gKiBAbWVtYmVyT2YgUXVlcnlcbiAqIEBpbnN0YW5jZVxuICogQHBhcmFtIHtPYmplY3R9IFthcmddXG4gKiBAcmV0dXJuIHtRdWVyeX0gdGhpc1xuICogQHNlZSAkZ2VvbWV0cnkgaHR0cHM6Ly93d3cubW9uZ29kYi5jb20vZG9jcy9tYW51YWwvcmVmZXJlbmNlL29wZXJhdG9yL2dlb21ldHJ5L1xuICogQHNlZSBnZW9JbnRlcnNlY3RzIGh0dHBzOi8vd3d3Lm1vbmdvZGIuY29tL2RvY3MvbWFudWFsL3JlZmVyZW5jZS9vcGVyYXRvci9nZW9JbnRlcnNlY3RzL1xuICogQGFwaSBwdWJsaWNcbiAqL1xuXG4vKipcbiAqIFNwZWNpZmllcyBhIGAkZ2VvbWV0cnlgIGNvbmRpdGlvblxuICpcbiAqICMjIyMgRXhhbXBsZTpcbiAqXG4gKiAgICAgY29uc3QgcG9seUEgPSBbW1sgMTAsIDIwIF0sIFsgMTAsIDQwIF0sIFsgMzAsIDQwIF0sIFsgMzAsIDIwIF1dXVxuICogICAgIHF1ZXJ5LndoZXJlKCdsb2MnKS53aXRoaW4oKS5nZW9tZXRyeSh7IHR5cGU6ICdQb2x5Z29uJywgY29vcmRpbmF0ZXM6IHBvbHlBIH0pXG4gKlxuICogICAgIC8vIG9yXG4gKiAgICAgY29uc3QgcG9seUIgPSBbWyAwLCAwIF0sIFsgMSwgMSBdXVxuICogICAgIHF1ZXJ5LndoZXJlKCdsb2MnKS53aXRoaW4oKS5nZW9tZXRyeSh7IHR5cGU6ICdMaW5lU3RyaW5nJywgY29vcmRpbmF0ZXM6IHBvbHlCIH0pXG4gKlxuICogICAgIC8vIG9yXG4gKiAgICAgY29uc3QgcG9seUMgPSBbIDAsIDAgXVxuICogICAgIHF1ZXJ5LndoZXJlKCdsb2MnKS53aXRoaW4oKS5nZW9tZXRyeSh7IHR5cGU6ICdQb2ludCcsIGNvb3JkaW5hdGVzOiBwb2x5QyB9KVxuICpcbiAqICAgICAvLyBvclxuICogICAgIHF1ZXJ5LndoZXJlKCdsb2MnKS5pbnRlcnNlY3RzKCkuZ2VvbWV0cnkoeyB0eXBlOiAnUG9pbnQnLCBjb29yZGluYXRlczogcG9seUMgfSlcbiAqXG4gKiBUaGUgYXJndW1lbnQgaXMgYXNzaWduZWQgdG8gdGhlIG1vc3QgcmVjZW50IHBhdGggcGFzc2VkIHRvIGB3aGVyZSgpYC5cbiAqXG4gKiAjIyMjIE5vdGU6XG4gKlxuICogYGdlb21ldHJ5KClgICoqbXVzdCoqIGNvbWUgYWZ0ZXIgZWl0aGVyIGBpbnRlcnNlY3RzKClgIG9yIGB3aXRoaW4oKWAuXG4gKlxuICogVGhlIGBvYmplY3RgIGFyZ3VtZW50IG11c3QgY29udGFpbiBgdHlwZWAgYW5kIGBjb29yZGluYXRlc2AgcHJvcGVydGllcy5cbiAqIC0gdHlwZSB7U3RyaW5nfVxuICogLSBjb29yZGluYXRlcyB7QXJyYXl9XG4gKlxuICogQG1ldGhvZCBnZW9tZXRyeVxuICogQG1lbWJlck9mIFF1ZXJ5XG4gKiBAaW5zdGFuY2VcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgTXVzdCBjb250YWluIGEgYHR5cGVgIHByb3BlcnR5IHdoaWNoIGlzIGEgU3RyaW5nIGFuZCBhIGBjb29yZGluYXRlc2AgcHJvcGVydHkgd2hpY2ggaXMgYW4gQXJyYXkuIFNlZSB0aGUgZXhhbXBsZXMuXG4gKiBAcmV0dXJuIHtRdWVyeX0gdGhpc1xuICogQHNlZSAkZ2VvbWV0cnkgaHR0cHM6Ly93d3cubW9uZ29kYi5jb20vZG9jcy9tYW51YWwvcmVmZXJlbmNlL29wZXJhdG9yL2dlb21ldHJ5L1xuICogQHNlZSBHZW9zcGF0aWFsIFN1cHBvcnQgRW5oYW5jZW1lbnRzIGh0dHBzOi8vd3d3Lm1vbmdvZGIuY29tL2RvY3MvbWFudWFsL3JlbGVhc2Utbm90ZXMvMi40LyNnZW9zcGF0aWFsLXN1cHBvcnQtZW5oYW5jZW1lbnRzXG4gKiBAc2VlIE1vbmdvREIgR2Vvc3BhdGlhbCBJbmRleGluZyBodHRwczovL3d3dy5tb25nb2RiLmNvbS9kb2NzL21hbnVhbC9jb3JlL2dlb3NwYXRpYWwtaW5kZXhlcy9cbiAqIEBhcGkgcHVibGljXG4gKi9cblxuLyoqXG4gKiBTcGVjaWZpZXMgYSBgJG5lYXJgIG9yIGAkbmVhclNwaGVyZWAgY29uZGl0aW9uXG4gKlxuICogVGhlc2Ugb3BlcmF0b3JzIHJldHVybiBkb2N1bWVudHMgc29ydGVkIGJ5IGRpc3RhbmNlLlxuICpcbiAqICMjIyMgRXhhbXBsZTpcbiAqXG4gKiAgICAgcXVlcnkud2hlcmUoJ2xvYycpLm5lYXIoeyBjZW50ZXI6IFsxMCwgMTBdIH0pO1xuICogICAgIHF1ZXJ5LndoZXJlKCdsb2MnKS5uZWFyKHsgY2VudGVyOiBbMTAsIDEwXSwgbWF4RGlzdGFuY2U6IDUgfSk7XG4gKiAgICAgcXVlcnkud2hlcmUoJ2xvYycpLm5lYXIoeyBjZW50ZXI6IFsxMCwgMTBdLCBtYXhEaXN0YW5jZTogNSwgc3BoZXJpY2FsOiB0cnVlIH0pO1xuICogICAgIHF1ZXJ5Lm5lYXIoJ2xvYycsIHsgY2VudGVyOiBbMTAsIDEwXSwgbWF4RGlzdGFuY2U6IDUgfSk7XG4gKlxuICogQG1ldGhvZCBuZWFyXG4gKiBAbWVtYmVyT2YgUXVlcnlcbiAqIEBpbnN0YW5jZVxuICogQHBhcmFtIHtTdHJpbmd9IFtwYXRoXVxuICogQHBhcmFtIHtPYmplY3R9IHZhbFxuICogQHJldHVybiB7UXVlcnl9IHRoaXNcbiAqIEBzZWUgJG5lYXIgaHR0cHM6Ly93d3cubW9uZ29kYi5jb20vZG9jcy9tYW51YWwvcmVmZXJlbmNlL29wZXJhdG9yL25lYXIvXG4gKiBAc2VlICRuZWFyU3BoZXJlIGh0dHBzOi8vd3d3Lm1vbmdvZGIuY29tL2RvY3MvbWFudWFsL3JlZmVyZW5jZS9vcGVyYXRvci9uZWFyU3BoZXJlL1xuICogQHNlZSAkbWF4RGlzdGFuY2UgaHR0cHM6Ly93d3cubW9uZ29kYi5jb20vZG9jcy9tYW51YWwvcmVmZXJlbmNlL29wZXJhdG9yL21heERpc3RhbmNlL1xuICogQHNlZSBNb25nb0RCIEdlb3NwYXRpYWwgSW5kZXhpbmcgaHR0cHM6Ly93d3cubW9uZ29kYi5jb20vZG9jcy9tYW51YWwvY29yZS9nZW9zcGF0aWFsLWluZGV4ZXMvXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbi8qKlxuICogT3ZlcndyaXRpbmcgbXF1ZXJ5IGlzIG5lZWRlZCB0byBzdXBwb3J0IGEgY291cGxlIGRpZmZlcmVudCBuZWFyKCkgZm9ybXMgZm91bmQgaW4gb2xkZXJcbiAqIHZlcnNpb25zIG9mIG1vbmdvb3NlXG4gKiBuZWFyKFsxLDFdKVxuICogbmVhcigxLDEpXG4gKiBuZWFyKGZpZWxkLCBbMSwyXSlcbiAqIG5lYXIoZmllbGQsIDEsIDIpXG4gKiBJbiBhZGRpdGlvbiB0byBhbGwgb2YgdGhlIG5vcm1hbCBmb3JtcyBzdXBwb3J0ZWQgYnkgbXF1ZXJ5XG4gKlxuICogQG1ldGhvZCBuZWFyXG4gKiBAbWVtYmVyT2YgUXVlcnlcbiAqIEBpbnN0YW5jZVxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuUXVlcnkucHJvdG90eXBlLm5lYXIgPSBmdW5jdGlvbigpIHtcbiAgY29uc3QgcGFyYW1zID0gW107XG4gIGNvbnN0IHNwaGVyZSA9IHRoaXMuX21vbmdvb3NlT3B0aW9ucy5uZWFyU3BoZXJlO1xuXG4gIC8vIFRPRE8gcmVmYWN0b3JcblxuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMSkge1xuICAgIGlmIChBcnJheS5pc0FycmF5KGFyZ3VtZW50c1swXSkpIHtcbiAgICAgIHBhcmFtcy5wdXNoKHsgY2VudGVyOiBhcmd1bWVudHNbMF0sIHNwaGVyaWNhbDogc3BoZXJlIH0pO1xuICAgIH0gZWxzZSBpZiAodHlwZW9mIGFyZ3VtZW50c1swXSA9PT0gJ3N0cmluZycpIHtcbiAgICAgIC8vIGp1c3QgcGFzc2luZyBhIHBhdGhcbiAgICAgIHBhcmFtcy5wdXNoKGFyZ3VtZW50c1swXSk7XG4gICAgfSBlbHNlIGlmICh1dGlscy5pc09iamVjdChhcmd1bWVudHNbMF0pKSB7XG4gICAgICBpZiAodHlwZW9mIGFyZ3VtZW50c1swXS5zcGhlcmljYWwgIT09ICdib29sZWFuJykge1xuICAgICAgICBhcmd1bWVudHNbMF0uc3BoZXJpY2FsID0gc3BoZXJlO1xuICAgICAgfVxuICAgICAgcGFyYW1zLnB1c2goYXJndW1lbnRzWzBdKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignaW52YWxpZCBhcmd1bWVudCcpO1xuICAgIH1cbiAgfSBlbHNlIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAyKSB7XG4gICAgaWYgKHR5cGVvZiBhcmd1bWVudHNbMF0gPT09ICdudW1iZXInICYmIHR5cGVvZiBhcmd1bWVudHNbMV0gPT09ICdudW1iZXInKSB7XG4gICAgICBwYXJhbXMucHVzaCh7IGNlbnRlcjogW2FyZ3VtZW50c1swXSwgYXJndW1lbnRzWzFdXSwgc3BoZXJpY2FsOiBzcGhlcmUgfSk7XG4gICAgfSBlbHNlIGlmICh0eXBlb2YgYXJndW1lbnRzWzBdID09PSAnc3RyaW5nJyAmJiBBcnJheS5pc0FycmF5KGFyZ3VtZW50c1sxXSkpIHtcbiAgICAgIHBhcmFtcy5wdXNoKGFyZ3VtZW50c1swXSk7XG4gICAgICBwYXJhbXMucHVzaCh7IGNlbnRlcjogYXJndW1lbnRzWzFdLCBzcGhlcmljYWw6IHNwaGVyZSB9KTtcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBhcmd1bWVudHNbMF0gPT09ICdzdHJpbmcnICYmIHV0aWxzLmlzT2JqZWN0KGFyZ3VtZW50c1sxXSkpIHtcbiAgICAgIHBhcmFtcy5wdXNoKGFyZ3VtZW50c1swXSk7XG4gICAgICBpZiAodHlwZW9mIGFyZ3VtZW50c1sxXS5zcGhlcmljYWwgIT09ICdib29sZWFuJykge1xuICAgICAgICBhcmd1bWVudHNbMV0uc3BoZXJpY2FsID0gc3BoZXJlO1xuICAgICAgfVxuICAgICAgcGFyYW1zLnB1c2goYXJndW1lbnRzWzFdKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignaW52YWxpZCBhcmd1bWVudCcpO1xuICAgIH1cbiAgfSBlbHNlIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAzKSB7XG4gICAgaWYgKHR5cGVvZiBhcmd1bWVudHNbMF0gPT09ICdzdHJpbmcnICYmIHR5cGVvZiBhcmd1bWVudHNbMV0gPT09ICdudW1iZXInXG4gICAgICAgICYmIHR5cGVvZiBhcmd1bWVudHNbMl0gPT09ICdudW1iZXInKSB7XG4gICAgICBwYXJhbXMucHVzaChhcmd1bWVudHNbMF0pO1xuICAgICAgcGFyYW1zLnB1c2goeyBjZW50ZXI6IFthcmd1bWVudHNbMV0sIGFyZ3VtZW50c1syXV0sIHNwaGVyaWNhbDogc3BoZXJlIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdpbnZhbGlkIGFyZ3VtZW50Jyk7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2ludmFsaWQgYXJndW1lbnQnKTtcbiAgfVxuXG4gIHJldHVybiBRdWVyeS5iYXNlLm5lYXIuYXBwbHkodGhpcywgcGFyYW1zKTtcbn07XG5cbi8qKlxuICogX0RFUFJFQ0FURURfIFNwZWNpZmllcyBhIGAkbmVhclNwaGVyZWAgY29uZGl0aW9uXG4gKlxuICogIyMjIyBFeGFtcGxlOlxuICpcbiAqICAgICBxdWVyeS53aGVyZSgnbG9jJykubmVhclNwaGVyZSh7IGNlbnRlcjogWzEwLCAxMF0sIG1heERpc3RhbmNlOiA1IH0pO1xuICpcbiAqICoqRGVwcmVjYXRlZC4qKiBVc2UgYHF1ZXJ5Lm5lYXIoKWAgaW5zdGVhZCB3aXRoIHRoZSBgc3BoZXJpY2FsYCBvcHRpb24gc2V0IHRvIGB0cnVlYC5cbiAqXG4gKiAjIyMjIEV4YW1wbGU6XG4gKlxuICogICAgIHF1ZXJ5LndoZXJlKCdsb2MnKS5uZWFyKHsgY2VudGVyOiBbMTAsIDEwXSwgc3BoZXJpY2FsOiB0cnVlIH0pO1xuICpcbiAqIEBkZXByZWNhdGVkXG4gKiBAc2VlIG5lYXIoKSBodHRwczovL21vbmdvb3NlanMuY29tL2RvY3MvYXBpL3F1ZXJ5Lmh0bWwjUXVlcnkucHJvdG90eXBlLm5lYXIoKVxuICogQHNlZSAkbmVhciBodHRwczovL3d3dy5tb25nb2RiLmNvbS9kb2NzL21hbnVhbC9yZWZlcmVuY2Uvb3BlcmF0b3IvbmVhci9cbiAqIEBzZWUgJG5lYXJTcGhlcmUgaHR0cHM6Ly93d3cubW9uZ29kYi5jb20vZG9jcy9tYW51YWwvcmVmZXJlbmNlL29wZXJhdG9yL25lYXJTcGhlcmUvXG4gKiBAc2VlICRtYXhEaXN0YW5jZSBodHRwczovL3d3dy5tb25nb2RiLmNvbS9kb2NzL21hbnVhbC9yZWZlcmVuY2Uvb3BlcmF0b3IvbWF4RGlzdGFuY2UvXG4gKi9cblxuUXVlcnkucHJvdG90eXBlLm5lYXJTcGhlcmUgPSBmdW5jdGlvbigpIHtcbiAgdGhpcy5fbW9uZ29vc2VPcHRpb25zLm5lYXJTcGhlcmUgPSB0cnVlO1xuICB0aGlzLm5lYXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIFJldHVybnMgYW4gYXN5bmNJdGVyYXRvciBmb3IgdXNlIHdpdGggW2Bmb3IvYXdhaXQvb2ZgIGxvb3BzXShodHRwczovL3RoZWNvZGViYXJiYXJpYW4uY29tL2dldHRpbmctc3RhcnRlZC13aXRoLWFzeW5jLWl0ZXJhdG9ycy1pbi1ub2RlLWpzKVxuICogVGhpcyBmdW5jdGlvbiAqb25seSogd29ya3MgZm9yIGBmaW5kKClgIHF1ZXJpZXMuXG4gKiBZb3UgZG8gbm90IG5lZWQgdG8gY2FsbCB0aGlzIGZ1bmN0aW9uIGV4cGxpY2l0bHksIHRoZSBKYXZhU2NyaXB0IHJ1bnRpbWVcbiAqIHdpbGwgY2FsbCBpdCBmb3IgeW91LlxuICpcbiAqICMjIyMgRXhhbXBsZTpcbiAqXG4gKiAgICAgZm9yIGF3YWl0IChjb25zdCBkb2Mgb2YgTW9kZWwuYWdncmVnYXRlKFt7ICRzb3J0OiB7IG5hbWU6IDEgfSB9XSkpIHtcbiAqICAgICAgIGNvbnNvbGUubG9nKGRvYy5uYW1lKTtcbiAqICAgICB9XG4gKlxuICogTm9kZS5qcyAxMC54IHN1cHBvcnRzIGFzeW5jIGl0ZXJhdG9ycyBuYXRpdmVseSB3aXRob3V0IGFueSBmbGFncy4gWW91IGNhblxuICogZW5hYmxlIGFzeW5jIGl0ZXJhdG9ycyBpbiBOb2RlLmpzIDgueCB1c2luZyB0aGUgW2AtLWhhcm1vbnlfYXN5bmNfaXRlcmF0aW9uYCBmbGFnXShodHRwczovL2dpdGh1Yi5jb20vdGMzOS9wcm9wb3NhbC1hc3luYy1pdGVyYXRpb24vaXNzdWVzLzExNyNpc3N1ZWNvbW1lbnQtMzQ2Njk1MTg3KS5cbiAqXG4gKiAqKk5vdGU6KiogVGhpcyBmdW5jdGlvbiBpcyBub3QgaWYgYFN5bWJvbC5hc3luY0l0ZXJhdG9yYCBpcyB1bmRlZmluZWQuIElmXG4gKiBgU3ltYm9sLmFzeW5jSXRlcmF0b3JgIGlzIHVuZGVmaW5lZCwgdGhhdCBtZWFucyB5b3VyIE5vZGUuanMgdmVyc2lvbiBkb2VzIG5vdFxuICogc3VwcG9ydCBhc3luYyBpdGVyYXRvcnMuXG4gKlxuICogQG1ldGhvZCBbU3ltYm9sLmFzeW5jSXRlcmF0b3JdXG4gKiBAbWVtYmVyT2YgUXVlcnlcbiAqIEBpbnN0YW5jZVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5pZiAoU3ltYm9sLmFzeW5jSXRlcmF0b3IgIT0gbnVsbCkge1xuICBRdWVyeS5wcm90b3R5cGVbU3ltYm9sLmFzeW5jSXRlcmF0b3JdID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMuY3Vyc29yKCkudHJhbnNmb3JtTnVsbCgpLl90cmFuc2Zvcm1Gb3JBc3luY0l0ZXJhdG9yKCk7XG4gIH07XG59XG5cbi8qKlxuICogU3BlY2lmaWVzIGEgYCRwb2x5Z29uYCBjb25kaXRpb25cbiAqXG4gKiAjIyMjIEV4YW1wbGU6XG4gKlxuICogICAgIHF1ZXJ5LndoZXJlKCdsb2MnKS53aXRoaW4oKS5wb2x5Z29uKFsxMCwgMjBdLCBbMTMsIDI1XSwgWzcsIDE1XSk7XG4gKiAgICAgcXVlcnkucG9seWdvbignbG9jJywgWzEwLCAyMF0sIFsxMywgMjVdLCBbNywgMTVdKTtcbiAqXG4gKiBAbWV0aG9kIHBvbHlnb25cbiAqIEBtZW1iZXJPZiBRdWVyeVxuICogQGluc3RhbmNlXG4gKiBAcGFyYW0ge1N0cmluZ3xBcnJheX0gW3BhdGhdXG4gKiBAcGFyYW0gey4uLkFycmF5fE9iamVjdH0gW2Nvb3JkaW5hdGVQYWlyc11cbiAqIEByZXR1cm4ge1F1ZXJ5fSB0aGlzXG4gKiBAc2VlICRwb2x5Z29uIGh0dHBzOi8vd3d3Lm1vbmdvZGIuY29tL2RvY3MvbWFudWFsL3JlZmVyZW5jZS9vcGVyYXRvci9wb2x5Z29uL1xuICogQHNlZSBNb25nb0RCIEdlb3NwYXRpYWwgSW5kZXhpbmcgaHR0cHM6Ly93d3cubW9uZ29kYi5jb20vZG9jcy9tYW51YWwvY29yZS9nZW9zcGF0aWFsLWluZGV4ZXMvXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbi8qKlxuICogU3BlY2lmaWVzIGEgYCRib3hgIGNvbmRpdGlvblxuICpcbiAqICMjIyMgRXhhbXBsZTpcbiAqXG4gKiAgICAgY29uc3QgbG93ZXJMZWZ0ID0gWzQwLjczMDgzLCAtNzMuOTk3NTZdXG4gKiAgICAgY29uc3QgdXBwZXJSaWdodD0gWzQwLjc0MTQwNCwgIC03My45ODgxMzVdXG4gKlxuICogICAgIHF1ZXJ5LndoZXJlKCdsb2MnKS53aXRoaW4oKS5ib3gobG93ZXJMZWZ0LCB1cHBlclJpZ2h0KVxuICogICAgIHF1ZXJ5LmJveCh7IGxsIDogbG93ZXJMZWZ0LCB1ciA6IHVwcGVyUmlnaHQgfSlcbiAqXG4gKiBAbWV0aG9kIGJveFxuICogQG1lbWJlck9mIFF1ZXJ5XG4gKiBAaW5zdGFuY2VcbiAqIEBzZWUgJGJveCBodHRwczovL3d3dy5tb25nb2RiLmNvbS9kb2NzL21hbnVhbC9yZWZlcmVuY2Uvb3BlcmF0b3IvYm94L1xuICogQHNlZSB3aXRoaW4oKSBRdWVyeSN3aXRoaW4gaHR0cHM6Ly9tb25nb29zZWpzLmNvbS9kb2NzL2FwaS9xdWVyeS5odG1sI1F1ZXJ5LnByb3RvdHlwZS53aXRoaW4oKVxuICogQHNlZSBNb25nb0RCIEdlb3NwYXRpYWwgSW5kZXhpbmcgaHR0cHM6Ly93d3cubW9uZ29kYi5jb20vZG9jcy9tYW51YWwvY29yZS9nZW9zcGF0aWFsLWluZGV4ZXMvXG4gKiBAcGFyYW0ge09iamVjdHxBcnJheTxOdW1iZXI+fSB2YWwxIExvd2VyIExlZnQgQ29vcmRpbmF0ZXMgT1IgYSBvYmplY3Qgb2YgbG93ZXItbGVmdChsbCkgYW5kIHVwcGVyLXJpZ2h0KHVyKSBDb29yZGluYXRlc1xuICogQHBhcmFtIHtBcnJheTxOdW1iZXI+fSBbdmFsMl0gVXBwZXIgUmlnaHQgQ29vcmRpbmF0ZXNcbiAqIEByZXR1cm4ge1F1ZXJ5fSB0aGlzXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbi8qKlxuICogdGhpcyBpcyBuZWVkZWQgdG8gc3VwcG9ydCB0aGUgbW9uZ29vc2Ugc3ludGF4IG9mOlxuICogYm94KGZpZWxkLCB7IGxsIDogW3gseV0sIHVyIDogW3gyLHkyXSB9KVxuICogYm94KHsgbGwgOiBbeCx5XSwgdXIgOiBbeDIseTJdIH0pXG4gKlxuICogQG1ldGhvZCBib3hcbiAqIEBtZW1iZXJPZiBRdWVyeVxuICogQGluc3RhbmNlXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5RdWVyeS5wcm90b3R5cGUuYm94ID0gZnVuY3Rpb24obGwsIHVyKSB7XG4gIGlmICghQXJyYXkuaXNBcnJheShsbCkgJiYgdXRpbHMuaXNPYmplY3QobGwpKSB7XG4gICAgdXIgPSBsbC51cjtcbiAgICBsbCA9IGxsLmxsO1xuICB9XG4gIHJldHVybiBRdWVyeS5iYXNlLmJveC5jYWxsKHRoaXMsIGxsLCB1cik7XG59O1xuXG4vKipcbiAqIFNwZWNpZmllcyBhIGAkY2VudGVyYCBvciBgJGNlbnRlclNwaGVyZWAgY29uZGl0aW9uLlxuICpcbiAqICMjIyMgRXhhbXBsZTpcbiAqXG4gKiAgICAgY29uc3QgYXJlYSA9IHsgY2VudGVyOiBbNTAsIDUwXSwgcmFkaXVzOiAxMCwgdW5pcXVlOiB0cnVlIH1cbiAqICAgICBxdWVyeS53aGVyZSgnbG9jJykud2l0aGluKCkuY2lyY2xlKGFyZWEpXG4gKiAgICAgLy8gYWx0ZXJuYXRpdmVseVxuICogICAgIHF1ZXJ5LmNpcmNsZSgnbG9jJywgYXJlYSk7XG4gKlxuICogICAgIC8vIHNwaGVyaWNhbCBjYWxjdWxhdGlvbnNcbiAqICAgICBjb25zdCBhcmVhID0geyBjZW50ZXI6IFs1MCwgNTBdLCByYWRpdXM6IDEwLCB1bmlxdWU6IHRydWUsIHNwaGVyaWNhbDogdHJ1ZSB9XG4gKiAgICAgcXVlcnkud2hlcmUoJ2xvYycpLndpdGhpbigpLmNpcmNsZShhcmVhKVxuICogICAgIC8vIGFsdGVybmF0aXZlbHlcbiAqICAgICBxdWVyeS5jaXJjbGUoJ2xvYycsIGFyZWEpO1xuICpcbiAqIEBtZXRob2QgY2lyY2xlXG4gKiBAbWVtYmVyT2YgUXVlcnlcbiAqIEBpbnN0YW5jZVxuICogQHBhcmFtIHtTdHJpbmd9IFtwYXRoXVxuICogQHBhcmFtIHtPYmplY3R9IGFyZWFcbiAqIEByZXR1cm4ge1F1ZXJ5fSB0aGlzXG4gKiBAc2VlICRjZW50ZXIgaHR0cHM6Ly93d3cubW9uZ29kYi5jb20vZG9jcy9tYW51YWwvcmVmZXJlbmNlL29wZXJhdG9yL2NlbnRlci9cbiAqIEBzZWUgJGNlbnRlclNwaGVyZSBodHRwczovL3d3dy5tb25nb2RiLmNvbS9kb2NzL21hbnVhbC9yZWZlcmVuY2Uvb3BlcmF0b3IvY2VudGVyU3BoZXJlL1xuICogQHNlZSAkZ2VvV2l0aGluIGh0dHBzOi8vd3d3Lm1vbmdvZGIuY29tL2RvY3MvbWFudWFsL3JlZmVyZW5jZS9vcGVyYXRvci9nZW9XaXRoaW4vXG4gKiBAc2VlIE1vbmdvREIgR2Vvc3BhdGlhbCBJbmRleGluZyBodHRwczovL3d3dy5tb25nb2RiLmNvbS9kb2NzL21hbnVhbC9jb3JlL2dlb3NwYXRpYWwtaW5kZXhlcy9cbiAqIEBhcGkgcHVibGljXG4gKi9cblxuLyoqXG4gKiBfREVQUkVDQVRFRF8gQWxpYXMgZm9yIFtjaXJjbGVdKGh0dHBzOi8vbW9uZ29vc2Vqcy5jb20vZG9jcy9hcGkvcXVlcnkuaHRtbCNRdWVyeS5wcm90b3R5cGUuY2lyY2xlKCkpXG4gKlxuICogKipEZXByZWNhdGVkLioqIFVzZSBbY2lyY2xlXShodHRwczovL21vbmdvb3NlanMuY29tL2RvY3MvYXBpL3F1ZXJ5Lmh0bWwjUXVlcnkucHJvdG90eXBlLmNpcmNsZSgpKSBpbnN0ZWFkLlxuICpcbiAqIEBkZXByZWNhdGVkXG4gKiBAbWV0aG9kIGNlbnRlclxuICogQG1lbWJlck9mIFF1ZXJ5XG4gKiBAaW5zdGFuY2VcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuUXVlcnkucHJvdG90eXBlLmNlbnRlciA9IFF1ZXJ5LmJhc2UuY2lyY2xlO1xuXG4vKipcbiAqIF9ERVBSRUNBVEVEXyBTcGVjaWZpZXMgYSBgJGNlbnRlclNwaGVyZWAgY29uZGl0aW9uXG4gKlxuICogKipEZXByZWNhdGVkLioqIFVzZSBbY2lyY2xlXShodHRwczovL21vbmdvb3NlanMuY29tL2RvY3MvYXBpL3F1ZXJ5Lmh0bWwjUXVlcnkucHJvdG90eXBlLmNpcmNsZSgpKSBpbnN0ZWFkLlxuICpcbiAqICMjIyMgRXhhbXBsZTpcbiAqXG4gKiAgICAgY29uc3QgYXJlYSA9IHsgY2VudGVyOiBbNTAsIDUwXSwgcmFkaXVzOiAxMCB9O1xuICogICAgIHF1ZXJ5LndoZXJlKCdsb2MnKS53aXRoaW4oKS5jZW50ZXJTcGhlcmUoYXJlYSk7XG4gKlxuICogQGRlcHJlY2F0ZWRcbiAqIEBwYXJhbSB7U3RyaW5nfSBbcGF0aF1cbiAqIEBwYXJhbSB7T2JqZWN0fSB2YWxcbiAqIEByZXR1cm4ge1F1ZXJ5fSB0aGlzXG4gKiBAc2VlIE1vbmdvREIgR2Vvc3BhdGlhbCBJbmRleGluZyBodHRwczovL3d3dy5tb25nb2RiLmNvbS9kb2NzL21hbnVhbC9jb3JlL2dlb3NwYXRpYWwtaW5kZXhlcy9cbiAqIEBzZWUgJGNlbnRlclNwaGVyZSBodHRwczovL3d3dy5tb25nb2RiLmNvbS9kb2NzL21hbnVhbC9yZWZlcmVuY2Uvb3BlcmF0b3IvY2VudGVyU3BoZXJlL1xuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5RdWVyeS5wcm90b3R5cGUuY2VudGVyU3BoZXJlID0gZnVuY3Rpb24oKSB7XG4gIGlmIChhcmd1bWVudHNbMF0gIT0gbnVsbCAmJiB0eXBlb2YgYXJndW1lbnRzWzBdLmNvbnN0cnVjdG9yID09PSAnZnVuY3Rpb24nICYmIGFyZ3VtZW50c1swXS5jb25zdHJ1Y3Rvci5uYW1lID09PSAnT2JqZWN0Jykge1xuICAgIGFyZ3VtZW50c1swXS5zcGhlcmljYWwgPSB0cnVlO1xuICB9XG5cbiAgaWYgKGFyZ3VtZW50c1sxXSAhPSBudWxsICYmIHR5cGVvZiBhcmd1bWVudHNbMV0uY29uc3RydWN0b3IgPT09ICdmdW5jdGlvbicgJiYgYXJndW1lbnRzWzFdLmNvbnN0cnVjdG9yLm5hbWUgPT09ICdPYmplY3QnKSB7XG4gICAgYXJndW1lbnRzWzFdLnNwaGVyaWNhbCA9IHRydWU7XG4gIH1cblxuICBRdWVyeS5iYXNlLmNpcmNsZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xufTtcblxuLyoqXG4gKiBEZXRlcm1pbmVzIGlmIGZpZWxkIHNlbGVjdGlvbiBoYXMgYmVlbiBtYWRlLlxuICpcbiAqIEBtZXRob2Qgc2VsZWN0ZWRcbiAqIEBtZW1iZXJPZiBRdWVyeVxuICogQGluc3RhbmNlXG4gKiBAcmV0dXJuIHtCb29sZWFufVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG4vKipcbiAqIERldGVybWluZXMgaWYgaW5jbHVzaXZlIGZpZWxkIHNlbGVjdGlvbiBoYXMgYmVlbiBtYWRlLlxuICpcbiAqICAgICBxdWVyeS5zZWxlY3RlZEluY2x1c2l2ZWx5KCk7IC8vIGZhbHNlXG4gKiAgICAgcXVlcnkuc2VsZWN0KCduYW1lJyk7XG4gKiAgICAgcXVlcnkuc2VsZWN0ZWRJbmNsdXNpdmVseSgpOyAvLyB0cnVlXG4gKlxuICogQG1ldGhvZCBzZWxlY3RlZEluY2x1c2l2ZWx5XG4gKiBAbWVtYmVyT2YgUXVlcnlcbiAqIEBpbnN0YW5jZVxuICogQHJldHVybiB7Qm9vbGVhbn1cbiAqIEBhcGkgcHVibGljXG4gKi9cblxuUXVlcnkucHJvdG90eXBlLnNlbGVjdGVkSW5jbHVzaXZlbHkgPSBmdW5jdGlvbiBzZWxlY3RlZEluY2x1c2l2ZWx5KCkge1xuICByZXR1cm4gaXNJbmNsdXNpdmUodGhpcy5fZmllbGRzKTtcbn07XG5cbi8qKlxuICogRGV0ZXJtaW5lcyBpZiBleGNsdXNpdmUgZmllbGQgc2VsZWN0aW9uIGhhcyBiZWVuIG1hZGUuXG4gKlxuICogICAgIHF1ZXJ5LnNlbGVjdGVkRXhjbHVzaXZlbHkoKTsgLy8gZmFsc2VcbiAqICAgICBxdWVyeS5zZWxlY3QoJy1uYW1lJyk7XG4gKiAgICAgcXVlcnkuc2VsZWN0ZWRFeGNsdXNpdmVseSgpOyAvLyB0cnVlXG4gKiAgICAgcXVlcnkuc2VsZWN0ZWRJbmNsdXNpdmVseSgpOyAvLyBmYWxzZVxuICpcbiAqIEBtZXRob2Qgc2VsZWN0ZWRFeGNsdXNpdmVseVxuICogQG1lbWJlck9mIFF1ZXJ5XG4gKiBAaW5zdGFuY2VcbiAqIEByZXR1cm4ge0Jvb2xlYW59XG4gKiBAYXBpIHB1YmxpY1xuICovXG5cblF1ZXJ5LnByb3RvdHlwZS5zZWxlY3RlZEV4Y2x1c2l2ZWx5ID0gZnVuY3Rpb24gc2VsZWN0ZWRFeGNsdXNpdmVseSgpIHtcbiAgcmV0dXJuIGlzRXhjbHVzaXZlKHRoaXMuX2ZpZWxkcyk7XG59O1xuXG4vKipcbiAqIFRoZSBtb2RlbCB0aGlzIHF1ZXJ5IGlzIGFzc29jaWF0ZWQgd2l0aC5cbiAqXG4gKiAjIyMjIEV4YW1wbGU6XG4gKlxuICogICAgIGNvbnN0IHEgPSBNeU1vZGVsLmZpbmQoKTtcbiAqICAgICBxLm1vZGVsID09PSBNeU1vZGVsOyAvLyB0cnVlXG4gKlxuICogQGFwaSBwdWJsaWNcbiAqIEBwcm9wZXJ0eSBtb2RlbFxuICogQG1lbWJlck9mIFF1ZXJ5XG4gKiBAaW5zdGFuY2VcbiAqL1xuXG5RdWVyeS5wcm90b3R5cGUubW9kZWw7XG5cbi8qIVxuICogRXhwb3J0XG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSBRdWVyeTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/mongoose/lib/query.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/mongoose/lib/queryHelpers.js":
/*!***************************************************!*\
  !*** ./node_modules/mongoose/lib/queryHelpers.js ***!
  \***************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n\n/*!\n * Module dependencies\n */\n\nconst checkEmbeddedDiscriminatorKeyProjection =\n  __webpack_require__(/*! ./helpers/discriminator/checkEmbeddedDiscriminatorKeyProjection */ \"(ssr)/./node_modules/mongoose/lib/helpers/discriminator/checkEmbeddedDiscriminatorKeyProjection.js\");\nconst get = __webpack_require__(/*! ./helpers/get */ \"(ssr)/./node_modules/mongoose/lib/helpers/get.js\");\nconst getDiscriminatorByValue =\n  __webpack_require__(/*! ./helpers/discriminator/getDiscriminatorByValue */ \"(ssr)/./node_modules/mongoose/lib/helpers/discriminator/getDiscriminatorByValue.js\");\nconst isDefiningProjection = __webpack_require__(/*! ./helpers/projection/isDefiningProjection */ \"(ssr)/./node_modules/mongoose/lib/helpers/projection/isDefiningProjection.js\");\nconst clone = __webpack_require__(/*! ./helpers/clone */ \"(ssr)/./node_modules/mongoose/lib/helpers/clone.js\");\nconst isPathSelectedInclusive = __webpack_require__(/*! ./helpers/projection/isPathSelectedInclusive */ \"(ssr)/./node_modules/mongoose/lib/helpers/projection/isPathSelectedInclusive.js\");\n\n/**\n * Prepare a set of path options for query population.\n *\n * @param {Query} query\n * @param {Object} options\n * @return {Array}\n */\n\nexports.preparePopulationOptions = function preparePopulationOptions(query, options) {\n  const _populate = query.options.populate;\n  const pop = Object.keys(_populate).reduce((vals, key) => vals.concat([_populate[key]]), []);\n\n  // lean options should trickle through all queries\n  if (options.lean != null) {\n    pop\n      .filter(p => (p && p.options && p.options.lean) == null)\n      .forEach(makeLean(options.lean));\n  }\n\n  pop.forEach(opts => {\n    opts._localModel = query.model;\n  });\n\n  return pop;\n};\n\n/**\n * Prepare a set of path options for query population. This is the MongooseQuery\n * version\n *\n * @param {Query} query\n * @param {Object} options\n * @return {Array}\n */\n\nexports.preparePopulationOptionsMQ = function preparePopulationOptionsMQ(query, options) {\n  const _populate = query._mongooseOptions.populate;\n  const pop = Object.keys(_populate).reduce((vals, key) => vals.concat([_populate[key]]), []);\n\n  // lean options should trickle through all queries\n  if (options.lean != null) {\n    pop\n      .filter(p => (p && p.options && p.options.lean) == null)\n      .forEach(makeLean(options.lean));\n  }\n\n  const session = query && query.options && query.options.session || null;\n  if (session != null) {\n    pop.forEach(path => {\n      if (path.options == null) {\n        path.options = { session: session };\n        return;\n      }\n      if (!('session' in path.options)) {\n        path.options.session = session;\n      }\n    });\n  }\n\n  const projection = query._fieldsForExec();\n  pop.forEach(p => {\n    p._queryProjection = projection;\n  });\n  pop.forEach(opts => {\n    opts._localModel = query.model;\n  });\n\n  return pop;\n};\n\n/**\n * If the document is a mapped discriminator type, it returns a model instance for that type, otherwise,\n * it returns an instance of the given model.\n *\n * @param {Model}  model\n * @param {Object} doc\n * @param {Object} fields\n *\n * @return {Document}\n */\nexports.createModel = function createModel(model, doc, fields, userProvidedFields, options) {\n  model.hooks.execPreSync('createModel', doc);\n  const discriminatorMapping = model.schema ?\n    model.schema.discriminatorMapping :\n    null;\n\n  const key = discriminatorMapping && discriminatorMapping.isRoot ?\n    discriminatorMapping.key :\n    null;\n\n  const value = doc[key];\n  if (key && value && model.discriminators) {\n    const discriminator = model.discriminators[value] || getDiscriminatorByValue(model.discriminators, value);\n    if (discriminator) {\n      const _fields = clone(userProvidedFields);\n      exports.applyPaths(_fields, discriminator.schema);\n      return new discriminator(undefined, _fields, true);\n    }\n  }\n\n  const _opts = {\n    skipId: true,\n    isNew: false,\n    willInit: true\n  };\n  if (options != null && 'defaults' in options) {\n    _opts.defaults = options.defaults;\n  }\n  return new model(undefined, fields, _opts);\n};\n\n/*!\n * ignore\n */\n\nexports.createModelAndInit = function createModelAndInit(model, doc, fields, userProvidedFields, options, populatedIds, callback) {\n  const initOpts = populatedIds ?\n    { populated: populatedIds } :\n    undefined;\n\n  const casted = exports.createModel(model, doc, fields, userProvidedFields, options);\n  try {\n    casted.$init(doc, initOpts, callback);\n  } catch (error) {\n    callback(error, casted);\n  }\n};\n\n/*!\n * ignore\n */\n\nexports.applyPaths = function applyPaths(fields, schema) {\n  // determine if query is selecting or excluding fields\n  let exclude;\n  let keys;\n  const minusPathsToSkip = new Set();\n\n  if (fields) {\n    keys = Object.keys(fields);\n\n    // Collapse minus paths\n    const minusPaths = [];\n    for (let i = 0; i < keys.length; ++i) {\n      const key = keys[i];\n      if (keys[i][0] !== '-') {\n        continue;\n      }\n\n      delete fields[key];\n      if (key === '-_id') {\n        fields['_id'] = 0;\n      } else {\n        minusPaths.push(key.slice(1));\n      }\n    }\n\n    keys = Object.keys(fields);\n    for (let keyIndex = 0; keyIndex < keys.length; ++keyIndex) {\n      if (keys[keyIndex][0] === '+') {\n        continue;\n      }\n      const field = fields[keys[keyIndex]];\n      // Skip `$meta` and `$slice`\n      if (!isDefiningProjection(field)) {\n        continue;\n      }\n      // `_id: 1, name: 0` is a mixed inclusive/exclusive projection in\n      // MongoDB 4.0 and earlier, but not in later versions.\n      if (keys[keyIndex] === '_id' && keys.length > 1) {\n        continue;\n      }\n      exclude = !field;\n      break;\n    }\n\n    // Potentially add back minus paths based on schema-level path config\n    // and whether the projection is inclusive\n    for (const path of minusPaths) {\n      const type = schema.path(path);\n      // If the path isn't selected by default or the projection is not\n      // inclusive, minus path is treated as equivalent to `key: 0`.\n      // But we also allow using `-name` to remove `name` from an inclusive\n      // projection if `name` has schema-level `select: true`.\n      if ((!type || !type.selected) || exclude !== false) {\n        fields[path] = 0;\n        exclude = true;\n      } else if (type && type.selected && exclude === false) {\n        // Make a note of minus paths that are overwriting paths that are\n        // included by default.\n        minusPathsToSkip.add(path);\n      }\n    }\n  }\n\n  // if selecting, apply default schematype select:true fields\n  // if excluding, apply schematype select:false fields\n  const selected = [];\n  const excluded = [];\n  const stack = [];\n\n  analyzeSchema(schema);\n  switch (exclude) {\n    case true:\n      for (const fieldName of excluded) {\n        fields[fieldName] = 0;\n      }\n      break;\n    case false:\n      if (schema &&\n          schema.paths['_id'] &&\n          schema.paths['_id'].options &&\n          schema.paths['_id'].options.select === false) {\n        fields._id = 0;\n      }\n\n      for (const fieldName of selected) {\n        if (minusPathsToSkip.has(fieldName)) {\n          continue;\n        }\n        if (isPathSelectedInclusive(fields, fieldName)) {\n          continue;\n        }\n        fields[fieldName] = fields[fieldName] || 1;\n      }\n      break;\n    case undefined:\n      if (fields == null) {\n        break;\n      }\n      // Any leftover plus paths must in the schema, so delete them (gh-7017)\n      for (const key of Object.keys(fields || {})) {\n        if (key.startsWith('+')) {\n          delete fields[key];\n        }\n      }\n\n      // user didn't specify fields, implies returning all fields.\n      // only need to apply excluded fields and delete any plus paths\n      for (const fieldName of excluded) {\n        if (fields[fieldName] != null) {\n          // Skip applying default projections to fields with non-defining\n          // projections, like `$slice`\n          continue;\n        }\n        fields[fieldName] = 0;\n      }\n      break;\n  }\n\n  function analyzeSchema(schema, prefix) {\n    prefix || (prefix = '');\n\n    // avoid recursion\n    if (stack.indexOf(schema) !== -1) {\n      return [];\n    }\n    stack.push(schema);\n\n    const addedPaths = [];\n    schema.eachPath(function(path, type) {\n      if (prefix) path = prefix + '.' + path;\n      if (type.$isSchemaMap || path.endsWith('.$*')) {\n        const plusPath = '+' + path;\n        const hasPlusPath = fields && plusPath in fields;\n        if (type.options && type.options.select === false && !hasPlusPath) {\n          excluded.push(path);\n        }\n        return;\n      }\n      let addedPath = analyzePath(path, type);\n      // arrays\n      if (addedPath == null && !Array.isArray(type) && type.$isMongooseArray && !type.$isMongooseDocumentArray) {\n        addedPath = analyzePath(path, type.caster);\n      }\n      if (addedPath != null) {\n        addedPaths.push(addedPath);\n      }\n\n      // nested schemas\n      if (type.schema) {\n        const _addedPaths = analyzeSchema(type.schema, path);\n\n        // Special case: if discriminator key is the only field that would\n        // be projected in, remove it.\n        if (exclude === false) {\n          checkEmbeddedDiscriminatorKeyProjection(fields, path, type.schema,\n            selected, _addedPaths);\n        }\n      }\n    });\n    stack.pop();\n    return addedPaths;\n  }\n\n  function analyzePath(path, type) {\n    if (fields == null) {\n      return;\n    }\n\n    // If schema-level selected not set, nothing to do\n    if (typeof type.selected !== 'boolean') {\n      return;\n    }\n\n    // User overwriting default exclusion\n    if (type.selected === false && fields[path]) {\n      return;\n    }\n\n    // If set to 0, we're explicitly excluding the discriminator key. Can't do this for all fields,\n    // because we have tests that assert that using `-path` to exclude schema-level `select: true`\n    // fields counts as an exclusive projection. See gh-11546\n    if (!exclude && type.selected && path === schema.options.discriminatorKey && fields[path] != null && !fields[path]) {\n      delete fields[path];\n      return;\n    }\n\n    if (exclude === false && type.selected && fields[path] != null && !fields[path]) {\n      delete fields[path];\n      return;\n    }\n\n    const plusPath = '+' + path;\n    const hasPlusPath = fields && plusPath in fields;\n    if (hasPlusPath) {\n      // forced inclusion\n      delete fields[plusPath];\n\n      // if there are other fields being included, add this one\n      // if no other included fields, leave this out (implied inclusion)\n      if (exclude === false && keys.length > 1 && !~keys.indexOf(path)) {\n        fields[path] = 1;\n      }\n\n      return;\n    }\n\n    // check for parent exclusions\n    const pieces = path.split('.');\n    let cur = '';\n    for (let i = 0; i < pieces.length; ++i) {\n      cur += cur.length ? '.' + pieces[i] : pieces[i];\n      if (excluded.indexOf(cur) !== -1) {\n        return;\n      }\n    }\n\n    // Special case: if user has included a parent path of a discriminator key,\n    // don't explicitly project in the discriminator key because that will\n    // project out everything else under the parent path\n    if (!exclude && (type && type.options && type.options.$skipDiscriminatorCheck || false)) {\n      let cur = '';\n      for (let i = 0; i < pieces.length; ++i) {\n        cur += (cur.length === 0 ? '' : '.') + pieces[i];\n        const projection = get(fields, cur, false) || get(fields, cur + '.$', false);\n        if (projection && typeof projection !== 'object') {\n          return;\n        }\n      }\n    }\n\n    (type.selected ? selected : excluded).push(path);\n    return path;\n  }\n};\n\n/**\n * Set each path query option to lean\n *\n * @param {Object} option\n */\n\nfunction makeLean(val) {\n  return function(option) {\n    option.options || (option.options = {});\n\n    if (val != null && Array.isArray(val.virtuals)) {\n      val = Object.assign({}, val);\n      val.virtuals = val.virtuals.\n        filter(path => typeof path === 'string' && path.startsWith(option.path + '.')).\n        map(path => path.slice(option.path.length + 1));\n    }\n\n    option.options.lean = val;\n  };\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbW9uZ29vc2UvbGliL3F1ZXJ5SGVscGVycy5qcyIsIm1hcHBpbmdzIjoiQUFBYTs7QUFFYjtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxFQUFFLG1CQUFPLENBQUMsMktBQWlFO0FBQzNFLFlBQVksbUJBQU8sQ0FBQyx1RUFBZTtBQUNuQztBQUNBLEVBQUUsbUJBQU8sQ0FBQywySUFBaUQ7QUFDM0QsNkJBQTZCLG1CQUFPLENBQUMsK0hBQTJDO0FBQ2hGLGNBQWMsbUJBQU8sQ0FBQywyRUFBaUI7QUFDdkMsZ0NBQWdDLG1CQUFPLENBQUMscUlBQThDOztBQUV0RjtBQUNBO0FBQ0E7QUFDQSxXQUFXLE9BQU87QUFDbEIsV0FBVyxRQUFRO0FBQ25CLFlBQVk7QUFDWjs7QUFFQSxnQ0FBZ0M7QUFDaEM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQixXQUFXLFFBQVE7QUFDbkIsWUFBWTtBQUNaOztBQUVBLGtDQUFrQztBQUNsQztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkI7QUFDQSxZQUFZO0FBQ1o7QUFDQSxtQkFBbUI7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsMEJBQTBCO0FBQzFCO0FBQ0EsTUFBTSwwQkFBMEI7QUFDaEM7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLG9CQUFvQixpQkFBaUI7QUFDckM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDJCQUEyQix3QkFBd0I7QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdEQUFnRDtBQUNoRDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLG1CQUFtQjtBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsbUJBQW1CO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQjs7QUFFQTtBQUNBO0FBQ0EsMENBQTBDOztBQUUxQztBQUNBLDRCQUE0QjtBQUM1QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9hcHAxLy4vbm9kZV9tb2R1bGVzL21vbmdvb3NlL2xpYi9xdWVyeUhlbHBlcnMuanM/OWZiNyJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbi8qIVxuICogTW9kdWxlIGRlcGVuZGVuY2llc1xuICovXG5cbmNvbnN0IGNoZWNrRW1iZWRkZWREaXNjcmltaW5hdG9yS2V5UHJvamVjdGlvbiA9XG4gIHJlcXVpcmUoJy4vaGVscGVycy9kaXNjcmltaW5hdG9yL2NoZWNrRW1iZWRkZWREaXNjcmltaW5hdG9yS2V5UHJvamVjdGlvbicpO1xuY29uc3QgZ2V0ID0gcmVxdWlyZSgnLi9oZWxwZXJzL2dldCcpO1xuY29uc3QgZ2V0RGlzY3JpbWluYXRvckJ5VmFsdWUgPVxuICByZXF1aXJlKCcuL2hlbHBlcnMvZGlzY3JpbWluYXRvci9nZXREaXNjcmltaW5hdG9yQnlWYWx1ZScpO1xuY29uc3QgaXNEZWZpbmluZ1Byb2plY3Rpb24gPSByZXF1aXJlKCcuL2hlbHBlcnMvcHJvamVjdGlvbi9pc0RlZmluaW5nUHJvamVjdGlvbicpO1xuY29uc3QgY2xvbmUgPSByZXF1aXJlKCcuL2hlbHBlcnMvY2xvbmUnKTtcbmNvbnN0IGlzUGF0aFNlbGVjdGVkSW5jbHVzaXZlID0gcmVxdWlyZSgnLi9oZWxwZXJzL3Byb2plY3Rpb24vaXNQYXRoU2VsZWN0ZWRJbmNsdXNpdmUnKTtcblxuLyoqXG4gKiBQcmVwYXJlIGEgc2V0IG9mIHBhdGggb3B0aW9ucyBmb3IgcXVlcnkgcG9wdWxhdGlvbi5cbiAqXG4gKiBAcGFyYW0ge1F1ZXJ5fSBxdWVyeVxuICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcbiAqIEByZXR1cm4ge0FycmF5fVxuICovXG5cbmV4cG9ydHMucHJlcGFyZVBvcHVsYXRpb25PcHRpb25zID0gZnVuY3Rpb24gcHJlcGFyZVBvcHVsYXRpb25PcHRpb25zKHF1ZXJ5LCBvcHRpb25zKSB7XG4gIGNvbnN0IF9wb3B1bGF0ZSA9IHF1ZXJ5Lm9wdGlvbnMucG9wdWxhdGU7XG4gIGNvbnN0IHBvcCA9IE9iamVjdC5rZXlzKF9wb3B1bGF0ZSkucmVkdWNlKCh2YWxzLCBrZXkpID0+IHZhbHMuY29uY2F0KFtfcG9wdWxhdGVba2V5XV0pLCBbXSk7XG5cbiAgLy8gbGVhbiBvcHRpb25zIHNob3VsZCB0cmlja2xlIHRocm91Z2ggYWxsIHF1ZXJpZXNcbiAgaWYgKG9wdGlvbnMubGVhbiAhPSBudWxsKSB7XG4gICAgcG9wXG4gICAgICAuZmlsdGVyKHAgPT4gKHAgJiYgcC5vcHRpb25zICYmIHAub3B0aW9ucy5sZWFuKSA9PSBudWxsKVxuICAgICAgLmZvckVhY2gobWFrZUxlYW4ob3B0aW9ucy5sZWFuKSk7XG4gIH1cblxuICBwb3AuZm9yRWFjaChvcHRzID0+IHtcbiAgICBvcHRzLl9sb2NhbE1vZGVsID0gcXVlcnkubW9kZWw7XG4gIH0pO1xuXG4gIHJldHVybiBwb3A7XG59O1xuXG4vKipcbiAqIFByZXBhcmUgYSBzZXQgb2YgcGF0aCBvcHRpb25zIGZvciBxdWVyeSBwb3B1bGF0aW9uLiBUaGlzIGlzIHRoZSBNb25nb29zZVF1ZXJ5XG4gKiB2ZXJzaW9uXG4gKlxuICogQHBhcmFtIHtRdWVyeX0gcXVlcnlcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zXG4gKiBAcmV0dXJuIHtBcnJheX1cbiAqL1xuXG5leHBvcnRzLnByZXBhcmVQb3B1bGF0aW9uT3B0aW9uc01RID0gZnVuY3Rpb24gcHJlcGFyZVBvcHVsYXRpb25PcHRpb25zTVEocXVlcnksIG9wdGlvbnMpIHtcbiAgY29uc3QgX3BvcHVsYXRlID0gcXVlcnkuX21vbmdvb3NlT3B0aW9ucy5wb3B1bGF0ZTtcbiAgY29uc3QgcG9wID0gT2JqZWN0LmtleXMoX3BvcHVsYXRlKS5yZWR1Y2UoKHZhbHMsIGtleSkgPT4gdmFscy5jb25jYXQoW19wb3B1bGF0ZVtrZXldXSksIFtdKTtcblxuICAvLyBsZWFuIG9wdGlvbnMgc2hvdWxkIHRyaWNrbGUgdGhyb3VnaCBhbGwgcXVlcmllc1xuICBpZiAob3B0aW9ucy5sZWFuICE9IG51bGwpIHtcbiAgICBwb3BcbiAgICAgIC5maWx0ZXIocCA9PiAocCAmJiBwLm9wdGlvbnMgJiYgcC5vcHRpb25zLmxlYW4pID09IG51bGwpXG4gICAgICAuZm9yRWFjaChtYWtlTGVhbihvcHRpb25zLmxlYW4pKTtcbiAgfVxuXG4gIGNvbnN0IHNlc3Npb24gPSBxdWVyeSAmJiBxdWVyeS5vcHRpb25zICYmIHF1ZXJ5Lm9wdGlvbnMuc2Vzc2lvbiB8fCBudWxsO1xuICBpZiAoc2Vzc2lvbiAhPSBudWxsKSB7XG4gICAgcG9wLmZvckVhY2gocGF0aCA9PiB7XG4gICAgICBpZiAocGF0aC5vcHRpb25zID09IG51bGwpIHtcbiAgICAgICAgcGF0aC5vcHRpb25zID0geyBzZXNzaW9uOiBzZXNzaW9uIH07XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGlmICghKCdzZXNzaW9uJyBpbiBwYXRoLm9wdGlvbnMpKSB7XG4gICAgICAgIHBhdGgub3B0aW9ucy5zZXNzaW9uID0gc2Vzc2lvbjtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuXG4gIGNvbnN0IHByb2plY3Rpb24gPSBxdWVyeS5fZmllbGRzRm9yRXhlYygpO1xuICBwb3AuZm9yRWFjaChwID0+IHtcbiAgICBwLl9xdWVyeVByb2plY3Rpb24gPSBwcm9qZWN0aW9uO1xuICB9KTtcbiAgcG9wLmZvckVhY2gob3B0cyA9PiB7XG4gICAgb3B0cy5fbG9jYWxNb2RlbCA9IHF1ZXJ5Lm1vZGVsO1xuICB9KTtcblxuICByZXR1cm4gcG9wO1xufTtcblxuLyoqXG4gKiBJZiB0aGUgZG9jdW1lbnQgaXMgYSBtYXBwZWQgZGlzY3JpbWluYXRvciB0eXBlLCBpdCByZXR1cm5zIGEgbW9kZWwgaW5zdGFuY2UgZm9yIHRoYXQgdHlwZSwgb3RoZXJ3aXNlLFxuICogaXQgcmV0dXJucyBhbiBpbnN0YW5jZSBvZiB0aGUgZ2l2ZW4gbW9kZWwuXG4gKlxuICogQHBhcmFtIHtNb2RlbH0gIG1vZGVsXG4gKiBAcGFyYW0ge09iamVjdH0gZG9jXG4gKiBAcGFyYW0ge09iamVjdH0gZmllbGRzXG4gKlxuICogQHJldHVybiB7RG9jdW1lbnR9XG4gKi9cbmV4cG9ydHMuY3JlYXRlTW9kZWwgPSBmdW5jdGlvbiBjcmVhdGVNb2RlbChtb2RlbCwgZG9jLCBmaWVsZHMsIHVzZXJQcm92aWRlZEZpZWxkcywgb3B0aW9ucykge1xuICBtb2RlbC5ob29rcy5leGVjUHJlU3luYygnY3JlYXRlTW9kZWwnLCBkb2MpO1xuICBjb25zdCBkaXNjcmltaW5hdG9yTWFwcGluZyA9IG1vZGVsLnNjaGVtYSA/XG4gICAgbW9kZWwuc2NoZW1hLmRpc2NyaW1pbmF0b3JNYXBwaW5nIDpcbiAgICBudWxsO1xuXG4gIGNvbnN0IGtleSA9IGRpc2NyaW1pbmF0b3JNYXBwaW5nICYmIGRpc2NyaW1pbmF0b3JNYXBwaW5nLmlzUm9vdCA/XG4gICAgZGlzY3JpbWluYXRvck1hcHBpbmcua2V5IDpcbiAgICBudWxsO1xuXG4gIGNvbnN0IHZhbHVlID0gZG9jW2tleV07XG4gIGlmIChrZXkgJiYgdmFsdWUgJiYgbW9kZWwuZGlzY3JpbWluYXRvcnMpIHtcbiAgICBjb25zdCBkaXNjcmltaW5hdG9yID0gbW9kZWwuZGlzY3JpbWluYXRvcnNbdmFsdWVdIHx8IGdldERpc2NyaW1pbmF0b3JCeVZhbHVlKG1vZGVsLmRpc2NyaW1pbmF0b3JzLCB2YWx1ZSk7XG4gICAgaWYgKGRpc2NyaW1pbmF0b3IpIHtcbiAgICAgIGNvbnN0IF9maWVsZHMgPSBjbG9uZSh1c2VyUHJvdmlkZWRGaWVsZHMpO1xuICAgICAgZXhwb3J0cy5hcHBseVBhdGhzKF9maWVsZHMsIGRpc2NyaW1pbmF0b3Iuc2NoZW1hKTtcbiAgICAgIHJldHVybiBuZXcgZGlzY3JpbWluYXRvcih1bmRlZmluZWQsIF9maWVsZHMsIHRydWUpO1xuICAgIH1cbiAgfVxuXG4gIGNvbnN0IF9vcHRzID0ge1xuICAgIHNraXBJZDogdHJ1ZSxcbiAgICBpc05ldzogZmFsc2UsXG4gICAgd2lsbEluaXQ6IHRydWVcbiAgfTtcbiAgaWYgKG9wdGlvbnMgIT0gbnVsbCAmJiAnZGVmYXVsdHMnIGluIG9wdGlvbnMpIHtcbiAgICBfb3B0cy5kZWZhdWx0cyA9IG9wdGlvbnMuZGVmYXVsdHM7XG4gIH1cbiAgcmV0dXJuIG5ldyBtb2RlbCh1bmRlZmluZWQsIGZpZWxkcywgX29wdHMpO1xufTtcblxuLyohXG4gKiBpZ25vcmVcbiAqL1xuXG5leHBvcnRzLmNyZWF0ZU1vZGVsQW5kSW5pdCA9IGZ1bmN0aW9uIGNyZWF0ZU1vZGVsQW5kSW5pdChtb2RlbCwgZG9jLCBmaWVsZHMsIHVzZXJQcm92aWRlZEZpZWxkcywgb3B0aW9ucywgcG9wdWxhdGVkSWRzLCBjYWxsYmFjaykge1xuICBjb25zdCBpbml0T3B0cyA9IHBvcHVsYXRlZElkcyA/XG4gICAgeyBwb3B1bGF0ZWQ6IHBvcHVsYXRlZElkcyB9IDpcbiAgICB1bmRlZmluZWQ7XG5cbiAgY29uc3QgY2FzdGVkID0gZXhwb3J0cy5jcmVhdGVNb2RlbChtb2RlbCwgZG9jLCBmaWVsZHMsIHVzZXJQcm92aWRlZEZpZWxkcywgb3B0aW9ucyk7XG4gIHRyeSB7XG4gICAgY2FzdGVkLiRpbml0KGRvYywgaW5pdE9wdHMsIGNhbGxiYWNrKTtcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICBjYWxsYmFjayhlcnJvciwgY2FzdGVkKTtcbiAgfVxufTtcblxuLyohXG4gKiBpZ25vcmVcbiAqL1xuXG5leHBvcnRzLmFwcGx5UGF0aHMgPSBmdW5jdGlvbiBhcHBseVBhdGhzKGZpZWxkcywgc2NoZW1hKSB7XG4gIC8vIGRldGVybWluZSBpZiBxdWVyeSBpcyBzZWxlY3Rpbmcgb3IgZXhjbHVkaW5nIGZpZWxkc1xuICBsZXQgZXhjbHVkZTtcbiAgbGV0IGtleXM7XG4gIGNvbnN0IG1pbnVzUGF0aHNUb1NraXAgPSBuZXcgU2V0KCk7XG5cbiAgaWYgKGZpZWxkcykge1xuICAgIGtleXMgPSBPYmplY3Qua2V5cyhmaWVsZHMpO1xuXG4gICAgLy8gQ29sbGFwc2UgbWludXMgcGF0aHNcbiAgICBjb25zdCBtaW51c1BhdGhzID0gW107XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBrZXlzLmxlbmd0aDsgKytpKSB7XG4gICAgICBjb25zdCBrZXkgPSBrZXlzW2ldO1xuICAgICAgaWYgKGtleXNbaV1bMF0gIT09ICctJykge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgZGVsZXRlIGZpZWxkc1trZXldO1xuICAgICAgaWYgKGtleSA9PT0gJy1faWQnKSB7XG4gICAgICAgIGZpZWxkc1snX2lkJ10gPSAwO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbWludXNQYXRocy5wdXNoKGtleS5zbGljZSgxKSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAga2V5cyA9IE9iamVjdC5rZXlzKGZpZWxkcyk7XG4gICAgZm9yIChsZXQga2V5SW5kZXggPSAwOyBrZXlJbmRleCA8IGtleXMubGVuZ3RoOyArK2tleUluZGV4KSB7XG4gICAgICBpZiAoa2V5c1trZXlJbmRleF1bMF0gPT09ICcrJykge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGZpZWxkID0gZmllbGRzW2tleXNba2V5SW5kZXhdXTtcbiAgICAgIC8vIFNraXAgYCRtZXRhYCBhbmQgYCRzbGljZWBcbiAgICAgIGlmICghaXNEZWZpbmluZ1Byb2plY3Rpb24oZmllbGQpKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgLy8gYF9pZDogMSwgbmFtZTogMGAgaXMgYSBtaXhlZCBpbmNsdXNpdmUvZXhjbHVzaXZlIHByb2plY3Rpb24gaW5cbiAgICAgIC8vIE1vbmdvREIgNC4wIGFuZCBlYXJsaWVyLCBidXQgbm90IGluIGxhdGVyIHZlcnNpb25zLlxuICAgICAgaWYgKGtleXNba2V5SW5kZXhdID09PSAnX2lkJyAmJiBrZXlzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBleGNsdWRlID0gIWZpZWxkO1xuICAgICAgYnJlYWs7XG4gICAgfVxuXG4gICAgLy8gUG90ZW50aWFsbHkgYWRkIGJhY2sgbWludXMgcGF0aHMgYmFzZWQgb24gc2NoZW1hLWxldmVsIHBhdGggY29uZmlnXG4gICAgLy8gYW5kIHdoZXRoZXIgdGhlIHByb2plY3Rpb24gaXMgaW5jbHVzaXZlXG4gICAgZm9yIChjb25zdCBwYXRoIG9mIG1pbnVzUGF0aHMpIHtcbiAgICAgIGNvbnN0IHR5cGUgPSBzY2hlbWEucGF0aChwYXRoKTtcbiAgICAgIC8vIElmIHRoZSBwYXRoIGlzbid0IHNlbGVjdGVkIGJ5IGRlZmF1bHQgb3IgdGhlIHByb2plY3Rpb24gaXMgbm90XG4gICAgICAvLyBpbmNsdXNpdmUsIG1pbnVzIHBhdGggaXMgdHJlYXRlZCBhcyBlcXVpdmFsZW50IHRvIGBrZXk6IDBgLlxuICAgICAgLy8gQnV0IHdlIGFsc28gYWxsb3cgdXNpbmcgYC1uYW1lYCB0byByZW1vdmUgYG5hbWVgIGZyb20gYW4gaW5jbHVzaXZlXG4gICAgICAvLyBwcm9qZWN0aW9uIGlmIGBuYW1lYCBoYXMgc2NoZW1hLWxldmVsIGBzZWxlY3Q6IHRydWVgLlxuICAgICAgaWYgKCghdHlwZSB8fCAhdHlwZS5zZWxlY3RlZCkgfHwgZXhjbHVkZSAhPT0gZmFsc2UpIHtcbiAgICAgICAgZmllbGRzW3BhdGhdID0gMDtcbiAgICAgICAgZXhjbHVkZSA9IHRydWU7XG4gICAgICB9IGVsc2UgaWYgKHR5cGUgJiYgdHlwZS5zZWxlY3RlZCAmJiBleGNsdWRlID09PSBmYWxzZSkge1xuICAgICAgICAvLyBNYWtlIGEgbm90ZSBvZiBtaW51cyBwYXRocyB0aGF0IGFyZSBvdmVyd3JpdGluZyBwYXRocyB0aGF0IGFyZVxuICAgICAgICAvLyBpbmNsdWRlZCBieSBkZWZhdWx0LlxuICAgICAgICBtaW51c1BhdGhzVG9Ta2lwLmFkZChwYXRoKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvLyBpZiBzZWxlY3RpbmcsIGFwcGx5IGRlZmF1bHQgc2NoZW1hdHlwZSBzZWxlY3Q6dHJ1ZSBmaWVsZHNcbiAgLy8gaWYgZXhjbHVkaW5nLCBhcHBseSBzY2hlbWF0eXBlIHNlbGVjdDpmYWxzZSBmaWVsZHNcbiAgY29uc3Qgc2VsZWN0ZWQgPSBbXTtcbiAgY29uc3QgZXhjbHVkZWQgPSBbXTtcbiAgY29uc3Qgc3RhY2sgPSBbXTtcblxuICBhbmFseXplU2NoZW1hKHNjaGVtYSk7XG4gIHN3aXRjaCAoZXhjbHVkZSkge1xuICAgIGNhc2UgdHJ1ZTpcbiAgICAgIGZvciAoY29uc3QgZmllbGROYW1lIG9mIGV4Y2x1ZGVkKSB7XG4gICAgICAgIGZpZWxkc1tmaWVsZE5hbWVdID0gMDtcbiAgICAgIH1cbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgZmFsc2U6XG4gICAgICBpZiAoc2NoZW1hICYmXG4gICAgICAgICAgc2NoZW1hLnBhdGhzWydfaWQnXSAmJlxuICAgICAgICAgIHNjaGVtYS5wYXRoc1snX2lkJ10ub3B0aW9ucyAmJlxuICAgICAgICAgIHNjaGVtYS5wYXRoc1snX2lkJ10ub3B0aW9ucy5zZWxlY3QgPT09IGZhbHNlKSB7XG4gICAgICAgIGZpZWxkcy5faWQgPSAwO1xuICAgICAgfVxuXG4gICAgICBmb3IgKGNvbnN0IGZpZWxkTmFtZSBvZiBzZWxlY3RlZCkge1xuICAgICAgICBpZiAobWludXNQYXRoc1RvU2tpcC5oYXMoZmllbGROYW1lKSkge1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpc1BhdGhTZWxlY3RlZEluY2x1c2l2ZShmaWVsZHMsIGZpZWxkTmFtZSkpIHtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBmaWVsZHNbZmllbGROYW1lXSA9IGZpZWxkc1tmaWVsZE5hbWVdIHx8IDE7XG4gICAgICB9XG4gICAgICBicmVhaztcbiAgICBjYXNlIHVuZGVmaW5lZDpcbiAgICAgIGlmIChmaWVsZHMgPT0gbnVsbCkge1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIC8vIEFueSBsZWZ0b3ZlciBwbHVzIHBhdGhzIG11c3QgaW4gdGhlIHNjaGVtYSwgc28gZGVsZXRlIHRoZW0gKGdoLTcwMTcpXG4gICAgICBmb3IgKGNvbnN0IGtleSBvZiBPYmplY3Qua2V5cyhmaWVsZHMgfHwge30pKSB7XG4gICAgICAgIGlmIChrZXkuc3RhcnRzV2l0aCgnKycpKSB7XG4gICAgICAgICAgZGVsZXRlIGZpZWxkc1trZXldO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIHVzZXIgZGlkbid0IHNwZWNpZnkgZmllbGRzLCBpbXBsaWVzIHJldHVybmluZyBhbGwgZmllbGRzLlxuICAgICAgLy8gb25seSBuZWVkIHRvIGFwcGx5IGV4Y2x1ZGVkIGZpZWxkcyBhbmQgZGVsZXRlIGFueSBwbHVzIHBhdGhzXG4gICAgICBmb3IgKGNvbnN0IGZpZWxkTmFtZSBvZiBleGNsdWRlZCkge1xuICAgICAgICBpZiAoZmllbGRzW2ZpZWxkTmFtZV0gIT0gbnVsbCkge1xuICAgICAgICAgIC8vIFNraXAgYXBwbHlpbmcgZGVmYXVsdCBwcm9qZWN0aW9ucyB0byBmaWVsZHMgd2l0aCBub24tZGVmaW5pbmdcbiAgICAgICAgICAvLyBwcm9qZWN0aW9ucywgbGlrZSBgJHNsaWNlYFxuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIGZpZWxkc1tmaWVsZE5hbWVdID0gMDtcbiAgICAgIH1cbiAgICAgIGJyZWFrO1xuICB9XG5cbiAgZnVuY3Rpb24gYW5hbHl6ZVNjaGVtYShzY2hlbWEsIHByZWZpeCkge1xuICAgIHByZWZpeCB8fCAocHJlZml4ID0gJycpO1xuXG4gICAgLy8gYXZvaWQgcmVjdXJzaW9uXG4gICAgaWYgKHN0YWNrLmluZGV4T2Yoc2NoZW1hKSAhPT0gLTEpIHtcbiAgICAgIHJldHVybiBbXTtcbiAgICB9XG4gICAgc3RhY2sucHVzaChzY2hlbWEpO1xuXG4gICAgY29uc3QgYWRkZWRQYXRocyA9IFtdO1xuICAgIHNjaGVtYS5lYWNoUGF0aChmdW5jdGlvbihwYXRoLCB0eXBlKSB7XG4gICAgICBpZiAocHJlZml4KSBwYXRoID0gcHJlZml4ICsgJy4nICsgcGF0aDtcbiAgICAgIGlmICh0eXBlLiRpc1NjaGVtYU1hcCB8fCBwYXRoLmVuZHNXaXRoKCcuJConKSkge1xuICAgICAgICBjb25zdCBwbHVzUGF0aCA9ICcrJyArIHBhdGg7XG4gICAgICAgIGNvbnN0IGhhc1BsdXNQYXRoID0gZmllbGRzICYmIHBsdXNQYXRoIGluIGZpZWxkcztcbiAgICAgICAgaWYgKHR5cGUub3B0aW9ucyAmJiB0eXBlLm9wdGlvbnMuc2VsZWN0ID09PSBmYWxzZSAmJiAhaGFzUGx1c1BhdGgpIHtcbiAgICAgICAgICBleGNsdWRlZC5wdXNoKHBhdGgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGxldCBhZGRlZFBhdGggPSBhbmFseXplUGF0aChwYXRoLCB0eXBlKTtcbiAgICAgIC8vIGFycmF5c1xuICAgICAgaWYgKGFkZGVkUGF0aCA9PSBudWxsICYmICFBcnJheS5pc0FycmF5KHR5cGUpICYmIHR5cGUuJGlzTW9uZ29vc2VBcnJheSAmJiAhdHlwZS4kaXNNb25nb29zZURvY3VtZW50QXJyYXkpIHtcbiAgICAgICAgYWRkZWRQYXRoID0gYW5hbHl6ZVBhdGgocGF0aCwgdHlwZS5jYXN0ZXIpO1xuICAgICAgfVxuICAgICAgaWYgKGFkZGVkUGF0aCAhPSBudWxsKSB7XG4gICAgICAgIGFkZGVkUGF0aHMucHVzaChhZGRlZFBhdGgpO1xuICAgICAgfVxuXG4gICAgICAvLyBuZXN0ZWQgc2NoZW1hc1xuICAgICAgaWYgKHR5cGUuc2NoZW1hKSB7XG4gICAgICAgIGNvbnN0IF9hZGRlZFBhdGhzID0gYW5hbHl6ZVNjaGVtYSh0eXBlLnNjaGVtYSwgcGF0aCk7XG5cbiAgICAgICAgLy8gU3BlY2lhbCBjYXNlOiBpZiBkaXNjcmltaW5hdG9yIGtleSBpcyB0aGUgb25seSBmaWVsZCB0aGF0IHdvdWxkXG4gICAgICAgIC8vIGJlIHByb2plY3RlZCBpbiwgcmVtb3ZlIGl0LlxuICAgICAgICBpZiAoZXhjbHVkZSA9PT0gZmFsc2UpIHtcbiAgICAgICAgICBjaGVja0VtYmVkZGVkRGlzY3JpbWluYXRvcktleVByb2plY3Rpb24oZmllbGRzLCBwYXRoLCB0eXBlLnNjaGVtYSxcbiAgICAgICAgICAgIHNlbGVjdGVkLCBfYWRkZWRQYXRocyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KTtcbiAgICBzdGFjay5wb3AoKTtcbiAgICByZXR1cm4gYWRkZWRQYXRocztcbiAgfVxuXG4gIGZ1bmN0aW9uIGFuYWx5emVQYXRoKHBhdGgsIHR5cGUpIHtcbiAgICBpZiAoZmllbGRzID09IG51bGwpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyBJZiBzY2hlbWEtbGV2ZWwgc2VsZWN0ZWQgbm90IHNldCwgbm90aGluZyB0byBkb1xuICAgIGlmICh0eXBlb2YgdHlwZS5zZWxlY3RlZCAhPT0gJ2Jvb2xlYW4nKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gVXNlciBvdmVyd3JpdGluZyBkZWZhdWx0IGV4Y2x1c2lvblxuICAgIGlmICh0eXBlLnNlbGVjdGVkID09PSBmYWxzZSAmJiBmaWVsZHNbcGF0aF0pIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyBJZiBzZXQgdG8gMCwgd2UncmUgZXhwbGljaXRseSBleGNsdWRpbmcgdGhlIGRpc2NyaW1pbmF0b3Iga2V5LiBDYW4ndCBkbyB0aGlzIGZvciBhbGwgZmllbGRzLFxuICAgIC8vIGJlY2F1c2Ugd2UgaGF2ZSB0ZXN0cyB0aGF0IGFzc2VydCB0aGF0IHVzaW5nIGAtcGF0aGAgdG8gZXhjbHVkZSBzY2hlbWEtbGV2ZWwgYHNlbGVjdDogdHJ1ZWBcbiAgICAvLyBmaWVsZHMgY291bnRzIGFzIGFuIGV4Y2x1c2l2ZSBwcm9qZWN0aW9uLiBTZWUgZ2gtMTE1NDZcbiAgICBpZiAoIWV4Y2x1ZGUgJiYgdHlwZS5zZWxlY3RlZCAmJiBwYXRoID09PSBzY2hlbWEub3B0aW9ucy5kaXNjcmltaW5hdG9yS2V5ICYmIGZpZWxkc1twYXRoXSAhPSBudWxsICYmICFmaWVsZHNbcGF0aF0pIHtcbiAgICAgIGRlbGV0ZSBmaWVsZHNbcGF0aF07XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKGV4Y2x1ZGUgPT09IGZhbHNlICYmIHR5cGUuc2VsZWN0ZWQgJiYgZmllbGRzW3BhdGhdICE9IG51bGwgJiYgIWZpZWxkc1twYXRoXSkge1xuICAgICAgZGVsZXRlIGZpZWxkc1twYXRoXTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBjb25zdCBwbHVzUGF0aCA9ICcrJyArIHBhdGg7XG4gICAgY29uc3QgaGFzUGx1c1BhdGggPSBmaWVsZHMgJiYgcGx1c1BhdGggaW4gZmllbGRzO1xuICAgIGlmIChoYXNQbHVzUGF0aCkge1xuICAgICAgLy8gZm9yY2VkIGluY2x1c2lvblxuICAgICAgZGVsZXRlIGZpZWxkc1twbHVzUGF0aF07XG5cbiAgICAgIC8vIGlmIHRoZXJlIGFyZSBvdGhlciBmaWVsZHMgYmVpbmcgaW5jbHVkZWQsIGFkZCB0aGlzIG9uZVxuICAgICAgLy8gaWYgbm8gb3RoZXIgaW5jbHVkZWQgZmllbGRzLCBsZWF2ZSB0aGlzIG91dCAoaW1wbGllZCBpbmNsdXNpb24pXG4gICAgICBpZiAoZXhjbHVkZSA9PT0gZmFsc2UgJiYga2V5cy5sZW5ndGggPiAxICYmICF+a2V5cy5pbmRleE9mKHBhdGgpKSB7XG4gICAgICAgIGZpZWxkc1twYXRoXSA9IDE7XG4gICAgICB9XG5cbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyBjaGVjayBmb3IgcGFyZW50IGV4Y2x1c2lvbnNcbiAgICBjb25zdCBwaWVjZXMgPSBwYXRoLnNwbGl0KCcuJyk7XG4gICAgbGV0IGN1ciA9ICcnO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcGllY2VzLmxlbmd0aDsgKytpKSB7XG4gICAgICBjdXIgKz0gY3VyLmxlbmd0aCA/ICcuJyArIHBpZWNlc1tpXSA6IHBpZWNlc1tpXTtcbiAgICAgIGlmIChleGNsdWRlZC5pbmRleE9mKGN1cikgIT09IC0xKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBTcGVjaWFsIGNhc2U6IGlmIHVzZXIgaGFzIGluY2x1ZGVkIGEgcGFyZW50IHBhdGggb2YgYSBkaXNjcmltaW5hdG9yIGtleSxcbiAgICAvLyBkb24ndCBleHBsaWNpdGx5IHByb2plY3QgaW4gdGhlIGRpc2NyaW1pbmF0b3Iga2V5IGJlY2F1c2UgdGhhdCB3aWxsXG4gICAgLy8gcHJvamVjdCBvdXQgZXZlcnl0aGluZyBlbHNlIHVuZGVyIHRoZSBwYXJlbnQgcGF0aFxuICAgIGlmICghZXhjbHVkZSAmJiAodHlwZSAmJiB0eXBlLm9wdGlvbnMgJiYgdHlwZS5vcHRpb25zLiRza2lwRGlzY3JpbWluYXRvckNoZWNrIHx8IGZhbHNlKSkge1xuICAgICAgbGV0IGN1ciA9ICcnO1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBwaWVjZXMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgY3VyICs9IChjdXIubGVuZ3RoID09PSAwID8gJycgOiAnLicpICsgcGllY2VzW2ldO1xuICAgICAgICBjb25zdCBwcm9qZWN0aW9uID0gZ2V0KGZpZWxkcywgY3VyLCBmYWxzZSkgfHwgZ2V0KGZpZWxkcywgY3VyICsgJy4kJywgZmFsc2UpO1xuICAgICAgICBpZiAocHJvamVjdGlvbiAmJiB0eXBlb2YgcHJvamVjdGlvbiAhPT0gJ29iamVjdCcpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICAodHlwZS5zZWxlY3RlZCA/IHNlbGVjdGVkIDogZXhjbHVkZWQpLnB1c2gocGF0aCk7XG4gICAgcmV0dXJuIHBhdGg7XG4gIH1cbn07XG5cbi8qKlxuICogU2V0IGVhY2ggcGF0aCBxdWVyeSBvcHRpb24gdG8gbGVhblxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25cbiAqL1xuXG5mdW5jdGlvbiBtYWtlTGVhbih2YWwpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKG9wdGlvbikge1xuICAgIG9wdGlvbi5vcHRpb25zIHx8IChvcHRpb24ub3B0aW9ucyA9IHt9KTtcblxuICAgIGlmICh2YWwgIT0gbnVsbCAmJiBBcnJheS5pc0FycmF5KHZhbC52aXJ0dWFscykpIHtcbiAgICAgIHZhbCA9IE9iamVjdC5hc3NpZ24oe30sIHZhbCk7XG4gICAgICB2YWwudmlydHVhbHMgPSB2YWwudmlydHVhbHMuXG4gICAgICAgIGZpbHRlcihwYXRoID0+IHR5cGVvZiBwYXRoID09PSAnc3RyaW5nJyAmJiBwYXRoLnN0YXJ0c1dpdGgob3B0aW9uLnBhdGggKyAnLicpKS5cbiAgICAgICAgbWFwKHBhdGggPT4gcGF0aC5zbGljZShvcHRpb24ucGF0aC5sZW5ndGggKyAxKSk7XG4gICAgfVxuXG4gICAgb3B0aW9uLm9wdGlvbnMubGVhbiA9IHZhbDtcbiAgfTtcbn1cbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/mongoose/lib/queryHelpers.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/mongoose/lib/schema.js":
/*!*********************************************!*\
  !*** ./node_modules/mongoose/lib/schema.js ***!
  \*********************************************/
/***/ ((module, exports, __webpack_require__) => {

eval("\n\n/*!\n * Module dependencies.\n */\n\nconst EventEmitter = (__webpack_require__(/*! events */ \"events\").EventEmitter);\nconst Kareem = __webpack_require__(/*! kareem */ \"(ssr)/./node_modules/kareem/index.js\");\nconst MongooseError = __webpack_require__(/*! ./error/mongooseError */ \"(ssr)/./node_modules/mongoose/lib/error/mongooseError.js\");\nconst SchemaType = __webpack_require__(/*! ./schemaType */ \"(ssr)/./node_modules/mongoose/lib/schemaType.js\");\nconst SchemaTypeOptions = __webpack_require__(/*! ./options/schemaTypeOptions */ \"(ssr)/./node_modules/mongoose/lib/options/schemaTypeOptions.js\");\nconst VirtualOptions = __webpack_require__(/*! ./options/virtualOptions */ \"(ssr)/./node_modules/mongoose/lib/options/virtualOptions.js\");\nconst VirtualType = __webpack_require__(/*! ./virtualType */ \"(ssr)/./node_modules/mongoose/lib/virtualType.js\");\nconst addAutoId = __webpack_require__(/*! ./helpers/schema/addAutoId */ \"(ssr)/./node_modules/mongoose/lib/helpers/schema/addAutoId.js\");\nconst clone = __webpack_require__(/*! ./helpers/clone */ \"(ssr)/./node_modules/mongoose/lib/helpers/clone.js\");\nconst get = __webpack_require__(/*! ./helpers/get */ \"(ssr)/./node_modules/mongoose/lib/helpers/get.js\");\nconst getConstructorName = __webpack_require__(/*! ./helpers/getConstructorName */ \"(ssr)/./node_modules/mongoose/lib/helpers/getConstructorName.js\");\nconst getIndexes = __webpack_require__(/*! ./helpers/schema/getIndexes */ \"(ssr)/./node_modules/mongoose/lib/helpers/schema/getIndexes.js\");\nconst handleReadPreferenceAliases = __webpack_require__(/*! ./helpers/query/handleReadPreferenceAliases */ \"(ssr)/./node_modules/mongoose/lib/helpers/query/handleReadPreferenceAliases.js\");\nconst idGetter = __webpack_require__(/*! ./helpers/schema/idGetter */ \"(ssr)/./node_modules/mongoose/lib/helpers/schema/idGetter.js\");\nconst merge = __webpack_require__(/*! ./helpers/schema/merge */ \"(ssr)/./node_modules/mongoose/lib/helpers/schema/merge.js\");\nconst mpath = __webpack_require__(/*! mpath */ \"(ssr)/./node_modules/mpath/index.js\");\nconst setupTimestamps = __webpack_require__(/*! ./helpers/timestamps/setupTimestamps */ \"(ssr)/./node_modules/mongoose/lib/helpers/timestamps/setupTimestamps.js\");\nconst utils = __webpack_require__(/*! ./utils */ \"(ssr)/./node_modules/mongoose/lib/utils.js\");\nconst validateRef = __webpack_require__(/*! ./helpers/populate/validateRef */ \"(ssr)/./node_modules/mongoose/lib/helpers/populate/validateRef.js\");\nconst util = __webpack_require__(/*! util */ \"util\");\n\nlet MongooseTypes;\n\nconst queryHooks = (__webpack_require__(/*! ./helpers/query/applyQueryMiddleware */ \"(ssr)/./node_modules/mongoose/lib/helpers/query/applyQueryMiddleware.js\").middlewareFunctions);\nconst documentHooks = (__webpack_require__(/*! ./helpers/model/applyHooks */ \"(ssr)/./node_modules/mongoose/lib/helpers/model/applyHooks.js\").middlewareFunctions);\nconst hookNames = queryHooks.concat(documentHooks).\n  reduce((s, hook) => s.add(hook), new Set());\n\nconst isPOJO = utils.isPOJO;\n\nlet id = 0;\n\nconst numberRE = /^\\d+$/;\n\n/**\n * Schema constructor.\n *\n * #### Example:\n *\n *     const child = new Schema({ name: String });\n *     const schema = new Schema({ name: String, age: Number, children: [child] });\n *     const Tree = mongoose.model('Tree', schema);\n *\n *     // setting schema options\n *     new Schema({ name: String }, { _id: false, autoIndex: false })\n *\n * #### Options:\n *\n * - [autoIndex](https://mongoosejs.com/docs/guide.html#autoIndex): bool - defaults to null (which means use the connection's autoIndex option)\n * - [autoCreate](https://mongoosejs.com/docs/guide.html#autoCreate): bool - defaults to null (which means use the connection's autoCreate option)\n * - [bufferCommands](https://mongoosejs.com/docs/guide.html#bufferCommands): bool - defaults to true\n * - [bufferTimeoutMS](https://mongoosejs.com/docs/guide.html#bufferTimeoutMS): number - defaults to 10000 (10 seconds). If `bufferCommands` is enabled, the amount of time Mongoose will wait for connectivity to be restablished before erroring out.\n * - [capped](https://mongoosejs.com/docs/guide.html#capped): bool | number | object - defaults to false\n * - [collection](https://mongoosejs.com/docs/guide.html#collection): string - no default\n * - [discriminatorKey](https://mongoosejs.com/docs/guide.html#discriminatorKey): string - defaults to `__t`\n * - [id](https://mongoosejs.com/docs/guide.html#id): bool - defaults to true\n * - [_id](https://mongoosejs.com/docs/guide.html#_id): bool - defaults to true\n * - [minimize](https://mongoosejs.com/docs/guide.html#minimize): bool - controls [document#toObject](https://mongoosejs.com/docs/api/document.html#Document.prototype.toObject()) behavior when called manually - defaults to true\n * - [read](https://mongoosejs.com/docs/guide.html#read): string\n * - [writeConcern](https://mongoosejs.com/docs/guide.html#writeConcern): object - defaults to null, use to override [the MongoDB server's default write concern settings](https://www.mongodb.com/docs/manual/reference/write-concern/)\n * - [shardKey](https://mongoosejs.com/docs/guide.html#shardKey): object - defaults to `null`\n * - [strict](https://mongoosejs.com/docs/guide.html#strict): bool - defaults to true\n * - [strictQuery](https://mongoosejs.com/docs/guide.html#strictQuery): bool - defaults to false\n * - [toJSON](https://mongoosejs.com/docs/guide.html#toJSON) - object - no default\n * - [toObject](https://mongoosejs.com/docs/guide.html#toObject) - object - no default\n * - [typeKey](https://mongoosejs.com/docs/guide.html#typeKey) - string - defaults to 'type'\n * - [validateBeforeSave](https://mongoosejs.com/docs/guide.html#validateBeforeSave) - bool - defaults to `true`\n * - [validateModifiedOnly](https://mongoosejs.com/docs/api/document.html#Document.prototype.validate()) - bool - defaults to `false`\n * - [versionKey](https://mongoosejs.com/docs/guide.html#versionKey): string or object - defaults to \"__v\"\n * - [optimisticConcurrency](https://mongoosejs.com/docs/guide.html#optimisticConcurrency): bool - defaults to false. Set to true to enable [optimistic concurrency](https://thecodebarbarian.com/whats-new-in-mongoose-5-10-optimistic-concurrency.html).\n * - [collation](https://mongoosejs.com/docs/guide.html#collation): object - defaults to null (which means use no collation)\n * - [timeseries](https://mongoosejs.com/docs/guide.html#timeseries): object - defaults to null (which means this schema's collection won't be a timeseries collection)\n * - [selectPopulatedPaths](https://mongoosejs.com/docs/guide.html#selectPopulatedPaths): boolean - defaults to `true`\n * - [skipVersioning](https://mongoosejs.com/docs/guide.html#skipVersioning): object - paths to exclude from versioning\n * - [timestamps](https://mongoosejs.com/docs/guide.html#timestamps): object or boolean - defaults to `false`. If true, Mongoose adds `createdAt` and `updatedAt` properties to your schema and manages those properties for you.\n * - [pluginTags](https://mongoosejs.com/docs/guide.html#pluginTags): array of strings - defaults to `undefined`. If set and plugin called with `tags` option, will only apply that plugin to schemas with a matching tag.\n * - [virtuals](https://mongoosejs.com/docs/tutorials/virtuals.html#virtuals-via-schema-options): object - virtuals to define, alias for [`.virtual`](https://mongoosejs.com/docs/api/schema.html#Schema.prototype.virtual())\n * - [collectionOptions]: object with options passed to [`createCollection()`](https://www.mongodb.com/docs/manual/reference/method/db.createCollection/) when calling `Model.createCollection()` or `autoCreate` set to true.\n *\n * #### Options for Nested Schemas:\n *\n * - `excludeIndexes`: bool - defaults to `false`. If `true`, skip building indexes on this schema's paths.\n *\n * #### Note:\n *\n * _When nesting schemas, (`children` in the example above), always declare the child schema first before passing it into its parent._\n *\n * @param {Object|Schema|Array} [definition] Can be one of: object describing schema paths, or schema to copy, or array of objects and schemas\n * @param {Object} [options]\n * @inherits NodeJS EventEmitter https://nodejs.org/api/events.html#class-eventemitter\n * @event `init`: Emitted after the schema is compiled into a `Model`.\n * @api public\n */\n\nfunction Schema(obj, options) {\n  if (!(this instanceof Schema)) {\n    return new Schema(obj, options);\n  }\n\n  this.obj = obj;\n  this.paths = {};\n  this.aliases = {};\n  this.subpaths = {};\n  this.virtuals = {};\n  this.singleNestedPaths = {};\n  this.nested = {};\n  this.inherits = {};\n  this.callQueue = [];\n  this._indexes = [];\n  this.methods = (options && options.methods) || {};\n  this.methodOptions = {};\n  this.statics = (options && options.statics) || {};\n  this.tree = {};\n  this.query = (options && options.query) || {};\n  this.childSchemas = [];\n  this.plugins = [];\n  // For internal debugging. Do not use this to try to save a schema in MDB.\n  this.$id = ++id;\n  this.mapPaths = [];\n\n  this.s = {\n    hooks: new Kareem()\n  };\n  this.options = this.defaultOptions(options);\n\n  // build paths\n  if (Array.isArray(obj)) {\n    for (const definition of obj) {\n      this.add(definition);\n    }\n  } else if (obj) {\n    this.add(obj);\n  }\n\n  // build virtual paths\n  if (options && options.virtuals) {\n    const virtuals = options.virtuals;\n    const pathNames = Object.keys(virtuals);\n    for (const pathName of pathNames) {\n      const pathOptions = virtuals[pathName].options ? virtuals[pathName].options : undefined;\n      const virtual = this.virtual(pathName, pathOptions);\n\n      if (virtuals[pathName].get) {\n        virtual.get(virtuals[pathName].get);\n      }\n\n      if (virtuals[pathName].set) {\n        virtual.set(virtuals[pathName].set);\n      }\n    }\n  }\n\n  // check if _id's value is a subdocument (gh-2276)\n  const _idSubDoc = obj && obj._id && utils.isObject(obj._id);\n\n  // ensure the documents get an auto _id unless disabled\n  const auto_id = !this.paths['_id'] &&\n      (this.options._id) && !_idSubDoc;\n\n  if (auto_id) {\n    addAutoId(this);\n  }\n\n  this.setupTimestamp(this.options.timestamps);\n}\n\n/**\n * Create virtual properties with alias field\n * @api private\n */\nfunction aliasFields(schema, paths) {\n  for (const path of Object.keys(paths)) {\n    let alias = null;\n    if (paths[path] != null) {\n      alias = paths[path];\n    } else {\n      const options = get(schema.paths[path], 'options');\n      if (options == null) {\n        continue;\n      }\n\n      alias = options.alias;\n    }\n\n    if (!alias) {\n      continue;\n    }\n\n    const prop = schema.paths[path].path;\n    if (Array.isArray(alias)) {\n      for (const a of alias) {\n        if (typeof a !== 'string') {\n          throw new Error('Invalid value for alias option on ' + prop + ', got ' + a);\n        }\n\n        schema.aliases[a] = prop;\n\n        schema.\n          virtual(a).\n          get((function(p) {\n            return function() {\n              if (typeof this.get === 'function') {\n                return this.get(p);\n              }\n              return this[p];\n            };\n          })(prop)).\n          set((function(p) {\n            return function(v) {\n              return this.$set(p, v);\n            };\n          })(prop));\n      }\n\n      continue;\n    }\n\n    if (typeof alias !== 'string') {\n      throw new Error('Invalid value for alias option on ' + prop + ', got ' + alias);\n    }\n\n    schema.aliases[alias] = prop;\n\n    schema.\n      virtual(alias).\n      get((function(p) {\n        return function() {\n          if (typeof this.get === 'function') {\n            return this.get(p);\n          }\n          return this[p];\n        };\n      })(prop)).\n      set((function(p) {\n        return function(v) {\n          return this.$set(p, v);\n        };\n      })(prop));\n  }\n}\n\n/*!\n * Inherit from EventEmitter.\n */\nSchema.prototype = Object.create(EventEmitter.prototype);\nSchema.prototype.constructor = Schema;\nSchema.prototype.instanceOfSchema = true;\n\n/*!\n * ignore\n */\n\nObject.defineProperty(Schema.prototype, '$schemaType', {\n  configurable: false,\n  enumerable: false,\n  writable: true\n});\n\n/**\n * Array of child schemas (from document arrays and single nested subdocs)\n * and their corresponding compiled models. Each element of the array is\n * an object with 2 properties: `schema` and `model`.\n *\n * This property is typically only useful for plugin authors and advanced users.\n * You do not need to interact with this property at all to use mongoose.\n *\n * @api public\n * @property childSchemas\n * @memberOf Schema\n * @instance\n */\n\nObject.defineProperty(Schema.prototype, 'childSchemas', {\n  configurable: false,\n  enumerable: true,\n  writable: true\n});\n\n/**\n * Object containing all virtuals defined on this schema.\n * The objects' keys are the virtual paths and values are instances of `VirtualType`.\n *\n * This property is typically only useful for plugin authors and advanced users.\n * You do not need to interact with this property at all to use mongoose.\n *\n * #### Example:\n *\n *     const schema = new Schema({});\n *     schema.virtual('answer').get(() => 42);\n *\n *     console.log(schema.virtuals); // { answer: VirtualType { path: 'answer', ... } }\n *     console.log(schema.virtuals['answer'].getters[0].call()); // 42\n *\n * @api public\n * @property virtuals\n * @memberOf Schema\n * @instance\n */\n\nObject.defineProperty(Schema.prototype, 'virtuals', {\n  configurable: false,\n  enumerable: true,\n  writable: true\n});\n\n/**\n * The original object passed to the schema constructor\n *\n * #### Example:\n *\n *     const schema = new Schema({ a: String }).add({ b: String });\n *     schema.obj; // { a: String }\n *\n * @api public\n * @property obj\n * @memberOf Schema\n * @instance\n */\n\nSchema.prototype.obj;\n\n/**\n * The paths defined on this schema. The keys are the top-level paths\n * in this schema, and the values are instances of the SchemaType class.\n *\n * #### Example:\n *\n *     const schema = new Schema({ name: String }, { _id: false });\n *     schema.paths; // { name: SchemaString { ... } }\n *\n *     schema.add({ age: Number });\n *     schema.paths; // { name: SchemaString { ... }, age: SchemaNumber { ... } }\n *\n * @api public\n * @property paths\n * @memberOf Schema\n * @instance\n */\n\nSchema.prototype.paths;\n\n/**\n * Schema as a tree\n *\n * #### Example:\n *\n *     {\n *         '_id'     : ObjectId\n *       , 'nested'  : {\n *             'key' : String\n *         }\n *     }\n *\n * @api private\n * @property tree\n * @memberOf Schema\n * @instance\n */\n\nSchema.prototype.tree;\n\n/**\n * Returns a deep copy of the schema\n *\n * #### Example:\n *\n *     const schema = new Schema({ name: String });\n *     const clone = schema.clone();\n *     clone === schema; // false\n *     clone.path('name'); // SchemaString { ... }\n *\n * @return {Schema} the cloned schema\n * @api public\n * @memberOf Schema\n * @instance\n */\n\nSchema.prototype.clone = function() {\n  const s = this._clone();\n\n  // Bubble up `init` for backwards compat\n  s.on('init', v => this.emit('init', v));\n\n  return s;\n};\n\n/*!\n * ignore\n */\n\nSchema.prototype._clone = function _clone(Constructor) {\n  Constructor = Constructor || (this.base == null ? Schema : this.base.Schema);\n\n  const s = new Constructor({}, this._userProvidedOptions);\n  s.base = this.base;\n  s.obj = this.obj;\n  s.options = clone(this.options);\n  s.callQueue = this.callQueue.map(function(f) { return f; });\n  s.methods = clone(this.methods);\n  s.methodOptions = clone(this.methodOptions);\n  s.statics = clone(this.statics);\n  s.query = clone(this.query);\n  s.plugins = Array.prototype.slice.call(this.plugins);\n  s._indexes = clone(this._indexes);\n  s.s.hooks = this.s.hooks.clone();\n\n  s.tree = clone(this.tree);\n  s.paths = Object.fromEntries(\n    Object.entries(this.paths).map(([key, value]) => ([key, value.clone()]))\n  );\n  s.nested = clone(this.nested);\n  s.subpaths = clone(this.subpaths);\n  for (const schemaType of Object.values(s.paths)) {\n    if (schemaType.$isSingleNested) {\n      const path = schemaType.path;\n      for (const key of Object.keys(schemaType.schema.paths)) {\n        s.singleNestedPaths[path + '.' + key] = schemaType.schema.paths[key];\n      }\n      for (const key of Object.keys(schemaType.schema.singleNestedPaths)) {\n        s.singleNestedPaths[path + '.' + key] =\n          schemaType.schema.singleNestedPaths[key];\n      }\n      for (const key of Object.keys(schemaType.schema.subpaths)) {\n        s.singleNestedPaths[path + '.' + key] =\n          schemaType.schema.subpaths[key];\n      }\n      for (const key of Object.keys(schemaType.schema.nested)) {\n        s.singleNestedPaths[path + '.' + key] = 'nested';\n      }\n    }\n  }\n  s.childSchemas = gatherChildSchemas(s);\n\n  s.virtuals = clone(this.virtuals);\n  s.$globalPluginsApplied = this.$globalPluginsApplied;\n  s.$isRootDiscriminator = this.$isRootDiscriminator;\n  s.$implicitlyCreated = this.$implicitlyCreated;\n  s.$id = ++id;\n  s.$originalSchemaId = this.$id;\n  s.mapPaths = [].concat(this.mapPaths);\n\n  if (this.discriminatorMapping != null) {\n    s.discriminatorMapping = Object.assign({}, this.discriminatorMapping);\n  }\n  if (this.discriminators != null) {\n    s.discriminators = Object.assign({}, this.discriminators);\n  }\n  if (this._applyDiscriminators != null) {\n    s._applyDiscriminators = new Map(this._applyDiscriminators);\n  }\n\n  s.aliases = Object.assign({}, this.aliases);\n\n  return s;\n};\n\n/**\n * Returns a new schema that has the picked `paths` from this schema.\n *\n * This method is analagous to [Lodash's `pick()` function](https://lodash.com/docs/4.17.15#pick) for Mongoose schemas.\n *\n * #### Example:\n *\n *     const schema = Schema({ name: String, age: Number });\n *     // Creates a new schema with the same `name` path as `schema`,\n *     // but no `age` path.\n *     const newSchema = schema.pick(['name']);\n *\n *     newSchema.path('name'); // SchemaString { ... }\n *     newSchema.path('age'); // undefined\n *\n * @param {String[]} paths List of Paths to pick for the new Schema\n * @param {Object} [options] Options to pass to the new Schema Constructor (same as `new Schema(.., Options)`). Defaults to `this.options` if not set.\n * @return {Schema}\n * @api public\n */\n\nSchema.prototype.pick = function(paths, options) {\n  const newSchema = new Schema({}, options || this.options);\n  if (!Array.isArray(paths)) {\n    throw new MongooseError('Schema#pick() only accepts an array argument, ' +\n      'got \"' + typeof paths + '\"');\n  }\n\n  for (const path of paths) {\n    if (this.nested[path]) {\n      newSchema.add({ [path]: get(this.tree, path) });\n    } else {\n      const schematype = this.path(path);\n      if (schematype == null) {\n        throw new MongooseError('Path `' + path + '` is not in the schema');\n      }\n      newSchema.add({ [path]: schematype });\n    }\n  }\n\n  return newSchema;\n};\n\n/**\n * Returns a new schema that has the `paths` from the original schema, minus the omitted ones.\n *\n * This method is analagous to [Lodash's `omit()` function](https://lodash.com/docs/#omit) for Mongoose schemas.\n *\n * #### Example:\n *\n *     const schema = Schema({ name: String, age: Number });\n *     // Creates a new schema omitting the `age` path\n *     const newSchema = schema.omit(['age']);\n *\n *     newSchema.path('name'); // SchemaString { ... }\n *     newSchema.path('age'); // undefined\n *\n * @param {String[]} paths List of Paths to omit for the new Schema\n * @param {Object} [options] Options to pass to the new Schema Constructor (same as `new Schema(.., Options)`). Defaults to `this.options` if not set.\n * @return {Schema}\n * @api public\n */\n\nSchema.prototype.omit = function(paths, options) {\n  const newSchema = new Schema(this, options || this.options);\n  if (!Array.isArray(paths)) {\n    throw new MongooseError(\n      'Schema#omit() only accepts an array argument, ' +\n        'got \"' +\n        typeof paths +\n        '\"'\n    );\n  }\n\n  newSchema.remove(paths);\n\n  for (const nested in newSchema.singleNestedPaths) {\n    if (paths.includes(nested)) {\n      delete newSchema.singleNestedPaths[nested];\n    }\n  }\n\n  return newSchema;\n};\n\n/**\n * Returns default options for this schema, merged with `options`.\n *\n * @param {Object} [options] Options to overwrite the default options\n * @return {Object} The merged options of `options` and the default options\n * @api private\n */\n\nSchema.prototype.defaultOptions = function(options) {\n  this._userProvidedOptions = options == null ? {} : clone(options);\n  const baseOptions = this.base && this.base.options || {};\n  const strict = 'strict' in baseOptions ? baseOptions.strict : true;\n  const strictQuery = 'strictQuery' in baseOptions ? baseOptions.strictQuery : false;\n  const id = 'id' in baseOptions ? baseOptions.id : true;\n  options = utils.options({\n    strict,\n    strictQuery,\n    bufferCommands: true,\n    capped: false, // { size, max, autoIndexId }\n    versionKey: '__v',\n    optimisticConcurrency: false,\n    minimize: true,\n    autoIndex: null,\n    discriminatorKey: '__t',\n    shardKey: null,\n    read: null,\n    validateBeforeSave: true,\n    validateModifiedOnly: false,\n    // the following are only applied at construction time\n    _id: true,\n    id: id,\n    typeKey: 'type'\n  }, clone(options));\n\n  if (options.versionKey && typeof options.versionKey !== 'string') {\n    throw new MongooseError('`versionKey` must be falsy or string, got `' + (typeof options.versionKey) + '`');\n  }\n\n  if (typeof options.read === 'string') {\n    options.read = handleReadPreferenceAliases(options.read);\n  } else if (Array.isArray(options.read) && typeof options.read[0] === 'string') {\n    options.read = {\n      mode: handleReadPreferenceAliases(options.read[0]),\n      tags: options.read[1]\n    };\n  }\n\n  if (options.optimisticConcurrency && !options.versionKey) {\n    throw new MongooseError('Must set `versionKey` if using `optimisticConcurrency`');\n  }\n\n  return options;\n};\n\n/**\n * Inherit a Schema by applying a discriminator on an existing Schema.\n *\n *\n * #### Example:\n *\n *     const eventSchema = new mongoose.Schema({ timestamp: Date }, { discriminatorKey: 'kind' });\n *\n *     const clickedEventSchema = new mongoose.Schema({ element: String }, { discriminatorKey: 'kind' });\n *     const ClickedModel = eventSchema.discriminator('clicked', clickedEventSchema);\n *\n *     const Event = mongoose.model('Event', eventSchema);\n *\n *     Event.discriminators['clicked']; // Model { clicked }\n *\n *     const doc = await Event.create({ kind: 'clicked', element: '#hero' });\n *     doc.element; // '#hero'\n *     doc instanceof ClickedModel; // true\n *\n * @param {String} name the name of the discriminator\n * @param {Schema} schema the discriminated Schema\n * @return {Schema} the Schema instance\n * @api public\n */\nSchema.prototype.discriminator = function(name, schema) {\n  this._applyDiscriminators = this._applyDiscriminators || new Map();\n  this._applyDiscriminators.set(name, schema);\n\n  return this;\n};\n\n/**\n * Adds key path / schema type pairs to this schema.\n *\n * #### Example:\n *\n *     const ToySchema = new Schema();\n *     ToySchema.add({ name: 'string', color: 'string', price: 'number' });\n *\n *     const TurboManSchema = new Schema();\n *     // You can also `add()` another schema and copy over all paths, virtuals,\n *     // getters, setters, indexes, methods, and statics.\n *     TurboManSchema.add(ToySchema).add({ year: Number });\n *\n * @param {Object|Schema} obj plain object with paths to add, or another schema\n * @param {String} [prefix] path to prefix the newly added paths with\n * @return {Schema} the Schema instance\n * @api public\n */\n\nSchema.prototype.add = function add(obj, prefix) {\n  if (obj instanceof Schema || (obj != null && obj.instanceOfSchema)) {\n    merge(this, obj);\n\n    return this;\n  }\n\n  // Special case: setting top-level `_id` to false should convert to disabling\n  // the `_id` option. This behavior never worked before 5.4.11 but numerous\n  // codebases use it (see gh-7516, gh-7512).\n  if (obj._id === false && prefix == null) {\n    this.options._id = false;\n  }\n\n  prefix = prefix || '';\n  // avoid prototype pollution\n  if (prefix === '__proto__.' || prefix === 'constructor.' || prefix === 'prototype.') {\n    return this;\n  }\n\n  const keys = Object.keys(obj);\n  const typeKey = this.options.typeKey;\n  for (const key of keys) {\n    if (utils.specialProperties.has(key)) {\n      continue;\n    }\n\n    const fullPath = prefix + key;\n    const val = obj[key];\n\n    if (val == null) {\n      throw new TypeError('Invalid value for schema path `' + fullPath +\n        '`, got value \"' + val + '\"');\n    }\n    // Retain `_id: false` but don't set it as a path, re: gh-8274.\n    if (key === '_id' && val === false) {\n      continue;\n    }\n    // Deprecate setting schema paths to primitive types (gh-7558)\n    let isMongooseTypeString = false;\n    if (typeof val === 'string') {\n      // Handle the case in which the type is specified as a string (eg. 'date', 'oid', ...)\n      const MongooseTypes = this.base != null ? this.base.Schema.Types : Schema.Types;\n      const upperVal = val.charAt(0).toUpperCase() + val.substring(1);\n      isMongooseTypeString = MongooseTypes[upperVal] != null;\n    }\n    if (\n      key !== '_id' &&\n      ((typeof val !== 'object' && typeof val !== 'function' && !isMongooseTypeString) ||\n      val == null)\n    ) {\n      throw new TypeError(`Invalid schema configuration: \\`${val}\\` is not ` +\n        `a valid type at path \\`${key}\\`. See ` +\n        'https://bit.ly/mongoose-schematypes for a list of valid schema types.');\n    }\n    if (val instanceof VirtualType || (val.constructor && val.constructor.name || null) === 'VirtualType') {\n      this.virtual(val);\n      continue;\n    }\n\n    if (Array.isArray(val) && val.length === 1 && val[0] == null) {\n      throw new TypeError('Invalid value for schema Array path `' + fullPath +\n        '`, got value \"' + val[0] + '\"');\n    }\n\n    if (!(isPOJO(val) || val instanceof SchemaTypeOptions)) {\n      // Special-case: Non-options definitely a path so leaf at this node\n      // Examples: Schema instances, SchemaType instances\n      if (prefix) {\n        this.nested[prefix.substring(0, prefix.length - 1)] = true;\n      }\n      this.path(prefix + key, val);\n      if (val[0] != null && !(val[0].instanceOfSchema) && utils.isPOJO(val[0].discriminators)) {\n        const schemaType = this.path(prefix + key);\n        for (const key in val[0].discriminators) {\n          schemaType.discriminator(key, val[0].discriminators[key]);\n        }\n      }\n    } else if (Object.keys(val).length < 1) {\n      // Special-case: {} always interpreted as Mixed path so leaf at this node\n      if (prefix) {\n        this.nested[prefix.substring(0, prefix.length - 1)] = true;\n      }\n      this.path(fullPath, val); // mixed type\n    } else if (!val[typeKey] || (typeKey === 'type' && isPOJO(val.type) && val.type.type)) {\n      // Special-case: POJO with no bona-fide type key - interpret as tree of deep paths so recurse\n      // nested object `{ last: { name: String } }`. Avoid functions with `.type` re: #10807 because\n      // NestJS sometimes adds `Date.type`.\n      this.nested[fullPath] = true;\n      this.add(val, fullPath + '.');\n    } else {\n      // There IS a bona-fide type key that may also be a POJO\n      const _typeDef = val[typeKey];\n      if (isPOJO(_typeDef) && Object.keys(_typeDef).length > 0) {\n        // If a POJO is the value of a type key, make it a subdocument\n        if (prefix) {\n          this.nested[prefix.substring(0, prefix.length - 1)] = true;\n        }\n\n        const childSchemaOptions = {};\n        if (this._userProvidedOptions.typeKey) {\n          childSchemaOptions.typeKey = this._userProvidedOptions.typeKey;\n        }\n        // propagate 'strict' option to child schema\n        if (this._userProvidedOptions.strict != null) {\n          childSchemaOptions.strict = this._userProvidedOptions.strict;\n        }\n        if (this._userProvidedOptions.toObject != null) {\n          childSchemaOptions.toObject = utils.omit(this._userProvidedOptions.toObject, ['transform']);\n        }\n        if (this._userProvidedOptions.toJSON != null) {\n          childSchemaOptions.toJSON = utils.omit(this._userProvidedOptions.toJSON, ['transform']);\n        }\n\n        const _schema = new Schema(_typeDef, childSchemaOptions);\n        _schema.$implicitlyCreated = true;\n        const schemaWrappedPath = Object.assign({}, val, { [typeKey]: _schema });\n        this.path(prefix + key, schemaWrappedPath);\n      } else {\n        // Either the type is non-POJO or we interpret it as Mixed anyway\n        if (prefix) {\n          this.nested[prefix.substring(0, prefix.length - 1)] = true;\n        }\n        this.path(prefix + key, val);\n        if (val != null && !(val.instanceOfSchema) && utils.isPOJO(val.discriminators)) {\n          const schemaType = this.path(prefix + key);\n          for (const key in val.discriminators) {\n            schemaType.discriminator(key, val.discriminators[key]);\n          }\n        }\n      }\n    }\n  }\n\n  const aliasObj = Object.fromEntries(\n    Object.entries(obj).map(([key]) => ([prefix + key, null]))\n  );\n  aliasFields(this, aliasObj);\n  return this;\n};\n\n/**\n * Add an alias for `path`. This means getting or setting the `alias`\n * is equivalent to getting or setting the `path`.\n *\n * #### Example:\n *\n *     const toySchema = new Schema({ n: String });\n *\n *     // Make 'name' an alias for 'n'\n *     toySchema.alias('n', 'name');\n *\n *     const Toy = mongoose.model('Toy', toySchema);\n *     const turboMan = new Toy({ n: 'Turbo Man' });\n *\n *     turboMan.name; // 'Turbo Man'\n *     turboMan.n; // 'Turbo Man'\n *\n *     turboMan.name = 'Turbo Man Action Figure';\n *     turboMan.n; // 'Turbo Man Action Figure'\n *\n *     await turboMan.save(); // Saves { _id: ..., n: 'Turbo Man Action Figure' }\n *\n *\n * @param {String} path real path to alias\n * @param {String|String[]} alias the path(s) to use as an alias for `path`\n * @return {Schema} the Schema instance\n * @api public\n */\n\nSchema.prototype.alias = function alias(path, alias) {\n  aliasFields(this, { [path]: alias });\n  return this;\n};\n\n/**\n * Remove an index by name or index specification.\n *\n * removeIndex only removes indexes from your schema object. Does **not** affect the indexes\n * in MongoDB.\n *\n * #### Example:\n *\n *     const ToySchema = new Schema({ name: String, color: String, price: Number });\n *\n *     // Add a new index on { name, color }\n *     ToySchema.index({ name: 1, color: 1 });\n *\n *     // Remove index on { name, color }\n *     // Keep in mind that order matters! `removeIndex({ color: 1, name: 1 })` won't remove the index\n *     ToySchema.removeIndex({ name: 1, color: 1 });\n *\n *     // Add an index with a custom name\n *     ToySchema.index({ color: 1 }, { name: 'my custom index name' });\n *     // Remove index by name\n *     ToySchema.removeIndex('my custom index name');\n *\n * @param {Object|string} index name or index specification\n * @return {Schema} the Schema instance\n * @api public\n */\n\nSchema.prototype.removeIndex = function removeIndex(index) {\n  if (arguments.length > 1) {\n    throw new Error('removeIndex() takes only 1 argument');\n  }\n\n  if (typeof index !== 'object' && typeof index !== 'string') {\n    throw new Error('removeIndex() may only take either an object or a string as an argument');\n  }\n\n  if (typeof index === 'object') {\n    for (let i = this._indexes.length - 1; i >= 0; --i) {\n      if (util.isDeepStrictEqual(this._indexes[i][0], index)) {\n        this._indexes.splice(i, 1);\n      }\n    }\n  } else {\n    for (let i = this._indexes.length - 1; i >= 0; --i) {\n      if (this._indexes[i][1] != null && this._indexes[i][1].name === index) {\n        this._indexes.splice(i, 1);\n      }\n    }\n  }\n\n  return this;\n};\n\n/**\n * Remove all indexes from this schema.\n *\n * clearIndexes only removes indexes from your schema object. Does **not** affect the indexes\n * in MongoDB.\n *\n * #### Example:\n *\n *     const ToySchema = new Schema({ name: String, color: String, price: Number });\n *     ToySchema.index({ name: 1 });\n *     ToySchema.index({ color: 1 });\n *\n *     // Remove all indexes on this schema\n *     ToySchema.clearIndexes();\n *\n *     ToySchema.indexes(); // []\n *\n * @return {Schema} the Schema instance\n * @api public\n */\n\nSchema.prototype.clearIndexes = function clearIndexes() {\n  this._indexes.length = 0;\n\n  return this;\n};\n\n/**\n * Reserved document keys.\n *\n * Keys in this object are names that are warned in schema declarations\n * because they have the potential to break Mongoose/ Mongoose plugins functionality. If you create a schema\n * using `new Schema()` with one of these property names, Mongoose will log a warning.\n *\n * - _posts\n * - _pres\n * - collection\n  * - emit\n * - errors\n * - get\n * - init\n * - isModified\n * - isNew\n * - listeners\n * - modelName\n * - on\n * - once\n * - populated\n * - prototype\n * - remove\n * - removeListener\n * - save\n * - schema\n * - toObject\n * - validate\n *\n * _NOTE:_ Use of these terms as method names is permitted, but play at your own risk, as they may be existing mongoose document methods you are stomping on.\n *\n *      const schema = new Schema(..);\n *      schema.methods.init = function () {} // potentially breaking\n *\n * @property reserved\n * @memberOf Schema\n * @static\n */\n\nSchema.reserved = Object.create(null);\nSchema.prototype.reserved = Schema.reserved;\n\nconst reserved = Schema.reserved;\n// Core object\nreserved['prototype'] =\n// EventEmitter\nreserved.emit =\nreserved.listeners =\nreserved.removeListener =\n\n// document properties and functions\nreserved.collection =\nreserved.errors =\nreserved.get =\nreserved.init =\nreserved.isModified =\nreserved.isNew =\nreserved.populated =\nreserved.remove =\nreserved.save =\nreserved.toObject =\nreserved.validate = 1;\nreserved.collection = 1;\n\n/**\n * Gets/sets schema paths.\n *\n * Sets a path (if arity 2)\n * Gets a path (if arity 1)\n *\n * #### Example:\n *\n *     schema.path('name') // returns a SchemaType\n *     schema.path('name', Number) // changes the schemaType of `name` to Number\n *\n * @param {String} path The name of the Path to get / set\n * @param {Object} [obj] The Type to set the path to, if provided the path will be SET, otherwise the path will be GET\n * @api public\n */\n\nSchema.prototype.path = function(path, obj) {\n  if (obj === undefined) {\n    // Convert to '.$' to check subpaths re: gh-6405\n    const cleanPath = _pathToPositionalSyntax(path);\n    let schematype = _getPath(this, path, cleanPath);\n    if (schematype != null) {\n      return schematype;\n    }\n\n    // Look for maps\n    const mapPath = getMapPath(this, path);\n    if (mapPath != null) {\n      return mapPath;\n    }\n\n    // Look if a parent of this path is mixed\n    schematype = this.hasMixedParent(cleanPath);\n    if (schematype != null) {\n      return schematype;\n    }\n\n    // subpaths?\n    return /\\.\\d+\\.?.*$/.test(path)\n      ? getPositionalPath(this, path, cleanPath)\n      : undefined;\n  }\n\n  // some path names conflict with document methods\n  const firstPieceOfPath = path.split('.')[0];\n  if (reserved[firstPieceOfPath] && !this.options.suppressReservedKeysWarning) {\n    const errorMessage = `\\`${firstPieceOfPath}\\` is a reserved schema pathname and may break some functionality. ` +\n      'You are allowed to use it, but use at your own risk. ' +\n      'To disable this warning pass `suppressReservedKeysWarning` as a schema option.';\n\n    utils.warn(errorMessage);\n  }\n\n  if (typeof obj === 'object' && utils.hasUserDefinedProperty(obj, 'ref')) {\n    validateRef(obj.ref, path);\n  }\n\n  // update the tree\n  const subpaths = path.split(/\\./);\n  const last = subpaths.pop();\n  let branch = this.tree;\n  let fullPath = '';\n\n  for (const sub of subpaths) {\n    if (utils.specialProperties.has(sub)) {\n      throw new Error('Cannot set special property `' + sub + '` on a schema');\n    }\n    fullPath = fullPath += (fullPath.length > 0 ? '.' : '') + sub;\n    if (!branch[sub]) {\n      this.nested[fullPath] = true;\n      branch[sub] = {};\n    }\n    if (typeof branch[sub] !== 'object') {\n      const msg = 'Cannot set nested path `' + path + '`. '\n          + 'Parent path `'\n          + fullPath\n          + '` already set to type ' + branch[sub].name\n          + '.';\n      throw new Error(msg);\n    }\n    branch = branch[sub];\n  }\n\n  branch[last] = clone(obj);\n\n  this.paths[path] = this.interpretAsType(path, obj, this.options);\n  const schemaType = this.paths[path];\n\n  if (schemaType.$isSchemaMap) {\n    // Maps can have arbitrary keys, so `$*` is internal shorthand for \"any key\"\n    // The '$' is to imply this path should never be stored in MongoDB so we\n    // can easily build a regexp out of this path, and '*' to imply \"any key.\"\n    const mapPath = path + '.$*';\n\n    this.paths[mapPath] = schemaType.$__schemaType;\n    this.mapPaths.push(this.paths[mapPath]);\n  }\n\n  if (schemaType.$isSingleNested) {\n    for (const key of Object.keys(schemaType.schema.paths)) {\n      this.singleNestedPaths[path + '.' + key] = schemaType.schema.paths[key];\n    }\n    for (const key of Object.keys(schemaType.schema.singleNestedPaths)) {\n      this.singleNestedPaths[path + '.' + key] =\n        schemaType.schema.singleNestedPaths[key];\n    }\n    for (const key of Object.keys(schemaType.schema.subpaths)) {\n      this.singleNestedPaths[path + '.' + key] =\n        schemaType.schema.subpaths[key];\n    }\n    for (const key of Object.keys(schemaType.schema.nested)) {\n      this.singleNestedPaths[path + '.' + key] = 'nested';\n    }\n\n    Object.defineProperty(schemaType.schema, 'base', {\n      configurable: true,\n      enumerable: false,\n      writable: false,\n      value: this.base\n    });\n\n    schemaType.caster.base = this.base;\n    this.childSchemas.push({\n      schema: schemaType.schema,\n      model: schemaType.caster\n    });\n  } else if (schemaType.$isMongooseDocumentArray) {\n    Object.defineProperty(schemaType.schema, 'base', {\n      configurable: true,\n      enumerable: false,\n      writable: false,\n      value: this.base\n    });\n\n    schemaType.casterConstructor.base = this.base;\n    this.childSchemas.push({\n      schema: schemaType.schema,\n      model: schemaType.casterConstructor\n    });\n  }\n\n  if (schemaType.$isMongooseArray && schemaType.caster instanceof SchemaType) {\n    let arrayPath = path;\n    let _schemaType = schemaType;\n\n    const toAdd = [];\n    while (_schemaType.$isMongooseArray) {\n      arrayPath = arrayPath + '.$';\n\n      // Skip arrays of document arrays\n      if (_schemaType.$isMongooseDocumentArray) {\n        _schemaType.$embeddedSchemaType._arrayPath = arrayPath;\n        _schemaType.$embeddedSchemaType._arrayParentPath = path;\n        _schemaType = _schemaType.$embeddedSchemaType.clone();\n      } else {\n        _schemaType.caster._arrayPath = arrayPath;\n        _schemaType.caster._arrayParentPath = path;\n        _schemaType = _schemaType.caster.clone();\n      }\n\n      _schemaType.path = arrayPath;\n      toAdd.push(_schemaType);\n    }\n\n    for (const _schemaType of toAdd) {\n      this.subpaths[_schemaType.path] = _schemaType;\n    }\n  }\n\n  if (schemaType.$isMongooseDocumentArray) {\n    for (const key of Object.keys(schemaType.schema.paths)) {\n      const _schemaType = schemaType.schema.paths[key];\n      this.subpaths[path + '.' + key] = _schemaType;\n      if (typeof _schemaType === 'object' && _schemaType != null && _schemaType.$parentSchemaDocArray == null) {\n        _schemaType.$parentSchemaDocArray = schemaType;\n      }\n    }\n    for (const key of Object.keys(schemaType.schema.subpaths)) {\n      const _schemaType = schemaType.schema.subpaths[key];\n      this.subpaths[path + '.' + key] = _schemaType;\n      if (typeof _schemaType === 'object' && _schemaType != null && _schemaType.$parentSchemaDocArray == null) {\n        _schemaType.$parentSchemaDocArray = schemaType;\n      }\n    }\n    for (const key of Object.keys(schemaType.schema.singleNestedPaths)) {\n      const _schemaType = schemaType.schema.singleNestedPaths[key];\n      this.subpaths[path + '.' + key] = _schemaType;\n      if (typeof _schemaType === 'object' && _schemaType != null && _schemaType.$parentSchemaDocArray == null) {\n        _schemaType.$parentSchemaDocArray = schemaType;\n      }\n    }\n  }\n\n  return this;\n};\n\n/*!\n * ignore\n */\n\nfunction gatherChildSchemas(schema) {\n  const childSchemas = [];\n\n  for (const path of Object.keys(schema.paths)) {\n    const schematype = schema.paths[path];\n    if (schematype.$isMongooseDocumentArray || schematype.$isSingleNested) {\n      childSchemas.push({ schema: schematype.schema, model: schematype.caster });\n    }\n  }\n\n  return childSchemas;\n}\n\n/*!\n * ignore\n */\n\nfunction _getPath(schema, path, cleanPath) {\n  if (schema.paths.hasOwnProperty(path)) {\n    return schema.paths[path];\n  }\n  if (schema.subpaths.hasOwnProperty(cleanPath)) {\n    return schema.subpaths[cleanPath];\n  }\n  if (schema.singleNestedPaths.hasOwnProperty(cleanPath) && typeof schema.singleNestedPaths[cleanPath] === 'object') {\n    return schema.singleNestedPaths[cleanPath];\n  }\n\n  return null;\n}\n\n/*!\n * ignore\n */\n\nfunction _pathToPositionalSyntax(path) {\n  if (!/\\.\\d+/.test(path)) {\n    return path;\n  }\n  return path.replace(/\\.\\d+\\./g, '.$.').replace(/\\.\\d+$/, '.$');\n}\n\n/*!\n * ignore\n */\n\nfunction getMapPath(schema, path) {\n  if (schema.mapPaths.length === 0) {\n    return null;\n  }\n  for (const val of schema.mapPaths) {\n    const _path = val.path;\n    const re = new RegExp('^' + _path.replace(/\\.\\$\\*/g, '\\\\.[^.]+') + '$');\n    if (re.test(path)) {\n      return schema.paths[_path];\n    }\n  }\n\n  return null;\n}\n\n/**\n * The Mongoose instance this schema is associated with\n *\n * @property base\n * @api private\n */\n\nObject.defineProperty(Schema.prototype, 'base', {\n  configurable: true,\n  enumerable: false,\n  writable: true,\n  value: null\n});\n\n/**\n * Converts type arguments into Mongoose Types.\n *\n * @param {String} path\n * @param {Object} obj constructor\n * @param {Object} options\n * @api private\n */\n\nSchema.prototype.interpretAsType = function(path, obj, options) {\n  if (obj instanceof SchemaType) {\n    if (obj.path === path) {\n      return obj;\n    }\n    const clone = obj.clone();\n    clone.path = path;\n    return clone;\n  }\n\n  // If this schema has an associated Mongoose object, use the Mongoose object's\n  // copy of SchemaTypes re: gh-7158 gh-6933\n  const MongooseTypes = this.base != null ? this.base.Schema.Types : Schema.Types;\n  const Types = this.base != null ? this.base.Types : __webpack_require__(/*! ./types */ \"(ssr)/./node_modules/mongoose/lib/types/index.js\");\n\n  if (!utils.isPOJO(obj) && !(obj instanceof SchemaTypeOptions)) {\n    const constructorName = utils.getFunctionName(obj.constructor);\n    if (constructorName !== 'Object') {\n      const oldObj = obj;\n      obj = {};\n      obj[options.typeKey] = oldObj;\n    }\n  }\n\n  // Get the type making sure to allow keys named \"type\"\n  // and default to mixed if not specified.\n  // { type: { type: String, default: 'freshcut' } }\n  let type = obj[options.typeKey] && (obj[options.typeKey] instanceof Function || options.typeKey !== 'type' || !obj.type.type)\n    ? obj[options.typeKey]\n    : {};\n  let name;\n\n  if (utils.isPOJO(type) || type === 'mixed') {\n    return new MongooseTypes.Mixed(path, obj);\n  }\n\n  if (Array.isArray(type) || type === Array || type === 'array' || type === MongooseTypes.Array) {\n    // if it was specified through { type } look for `cast`\n    let cast = (type === Array || type === 'array')\n      ? obj.cast || obj.of\n      : type[0];\n\n    // new Schema({ path: [new Schema({ ... })] })\n    if (cast && cast.instanceOfSchema) {\n      if (!(cast instanceof Schema)) {\n        if (this.options._isMerging) {\n          cast = new Schema(cast);\n        } else {\n          throw new TypeError('Schema for array path `' + path +\n            '` is from a different copy of the Mongoose module. ' +\n            'Please make sure you\\'re using the same version ' +\n            'of Mongoose everywhere with `npm list mongoose`. If you are still ' +\n            'getting this error, please add `new Schema()` around the path: ' +\n            `${path}: new Schema(...)`);\n        }\n      }\n      return new MongooseTypes.DocumentArray(path, cast, obj);\n    }\n    if (cast &&\n        cast[options.typeKey] &&\n        cast[options.typeKey].instanceOfSchema) {\n      if (!(cast[options.typeKey] instanceof Schema)) {\n        if (this.options._isMerging) {\n          cast[options.typeKey] = new Schema(cast[options.typeKey]);\n        } else {\n          throw new TypeError('Schema for array path `' + path +\n            '` is from a different copy of the Mongoose module. ' +\n            'Please make sure you\\'re using the same version ' +\n            'of Mongoose everywhere with `npm list mongoose`. If you are still ' +\n            'getting this error, please add `new Schema()` around the path: ' +\n            `${path}: new Schema(...)`);\n        }\n      }\n      return new MongooseTypes.DocumentArray(path, cast[options.typeKey], obj, cast);\n    }\n\n    if (Array.isArray(cast)) {\n      return new MongooseTypes.Array(path, this.interpretAsType(path, cast, options), obj);\n    }\n\n    // Handle both `new Schema({ arr: [{ subpath: String }] })` and `new Schema({ arr: [{ type: { subpath: string } }] })`\n    const castFromTypeKey = (cast != null && cast[options.typeKey] && (options.typeKey !== 'type' || !cast.type.type)) ?\n      cast[options.typeKey] :\n      cast;\n    if (typeof cast === 'string') {\n      cast = MongooseTypes[cast.charAt(0).toUpperCase() + cast.substring(1)];\n    } else if (utils.isPOJO(castFromTypeKey)) {\n      if (Object.keys(castFromTypeKey).length) {\n        // The `minimize` and `typeKey` options propagate to child schemas\n        // declared inline, like `{ arr: [{ val: { $type: String } }] }`.\n        // See gh-3560\n        const childSchemaOptions = { minimize: options.minimize };\n        if (options.typeKey) {\n          childSchemaOptions.typeKey = options.typeKey;\n        }\n        // propagate 'strict' option to child schema\n        if (options.hasOwnProperty('strict')) {\n          childSchemaOptions.strict = options.strict;\n        }\n        if (options.hasOwnProperty('strictQuery')) {\n          childSchemaOptions.strictQuery = options.strictQuery;\n        }\n        if (options.hasOwnProperty('toObject')) {\n          childSchemaOptions.toObject = utils.omit(options.toObject, ['transform']);\n        }\n        if (options.hasOwnProperty('toJSON')) {\n          childSchemaOptions.toJSON = utils.omit(options.toJSON, ['transform']);\n        }\n\n        if (this._userProvidedOptions.hasOwnProperty('_id')) {\n          childSchemaOptions._id = this._userProvidedOptions._id;\n        } else if (Schema.Types.DocumentArray.defaultOptions._id != null) {\n          childSchemaOptions._id = Schema.Types.DocumentArray.defaultOptions._id;\n        }\n\n        const childSchema = new Schema(castFromTypeKey, childSchemaOptions);\n        childSchema.$implicitlyCreated = true;\n        return new MongooseTypes.DocumentArray(path, childSchema, obj);\n      } else {\n        // Special case: empty object becomes mixed\n        return new MongooseTypes.Array(path, MongooseTypes.Mixed, obj);\n      }\n    }\n\n    if (cast) {\n      type = cast[options.typeKey] && (options.typeKey !== 'type' || !cast.type.type)\n        ? cast[options.typeKey]\n        : cast;\n\n      if (Array.isArray(type)) {\n        return new MongooseTypes.Array(path, this.interpretAsType(path, type, options), obj);\n      }\n\n      name = typeof type === 'string'\n        ? type\n        : type.schemaName || utils.getFunctionName(type);\n\n      // For Jest 26+, see #10296\n      if (name === 'ClockDate') {\n        name = 'Date';\n      }\n\n      if (name === void 0) {\n        throw new TypeError('Invalid schema configuration: ' +\n          `Could not determine the embedded type for array \\`${path}\\`. ` +\n          'See https://mongoosejs.com/docs/guide.html#definition for more info on supported schema syntaxes.');\n      }\n      if (!MongooseTypes.hasOwnProperty(name)) {\n        throw new TypeError('Invalid schema configuration: ' +\n          `\\`${name}\\` is not a valid type within the array \\`${path}\\`.` +\n          'See https://bit.ly/mongoose-schematypes for a list of valid schema types.');\n      }\n    }\n\n    return new MongooseTypes.Array(path, cast || MongooseTypes.Mixed, obj, options);\n  }\n\n  if (type && type.instanceOfSchema) {\n    return new MongooseTypes.Subdocument(type, path, obj);\n  }\n\n  if (Buffer.isBuffer(type)) {\n    name = 'Buffer';\n  } else if (typeof type === 'function' || typeof type === 'object') {\n    name = type.schemaName || utils.getFunctionName(type);\n  } else if (type === Types.ObjectId) {\n    name = 'ObjectId';\n  } else if (type === Types.Decimal128) {\n    name = 'Decimal128';\n  } else {\n    name = type == null ? '' + type : type.toString();\n  }\n\n  if (name) {\n    name = name.charAt(0).toUpperCase() + name.substring(1);\n  }\n  // Special case re: gh-7049 because the bson `ObjectID` class' capitalization\n  // doesn't line up with Mongoose's.\n  if (name === 'ObjectID') {\n    name = 'ObjectId';\n  }\n  // For Jest 26+, see #10296\n  if (name === 'ClockDate') {\n    name = 'Date';\n  }\n\n  if (name === void 0) {\n    throw new TypeError(`Invalid schema configuration: \\`${path}\\` schematype definition is ` +\n      'invalid. See ' +\n      'https://mongoosejs.com/docs/guide.html#definition for more info on supported schema syntaxes.');\n  }\n  if (MongooseTypes[name] == null) {\n    throw new TypeError(`Invalid schema configuration: \\`${name}\\` is not ` +\n      `a valid type at path \\`${path}\\`. See ` +\n      'https://bit.ly/mongoose-schematypes for a list of valid schema types.');\n  }\n\n  const schemaType = new MongooseTypes[name](path, obj);\n\n  if (schemaType.$isSchemaMap) {\n    createMapNestedSchemaType(this, schemaType, path, obj, options);\n  }\n\n  return schemaType;\n};\n\n/*!\n * ignore\n */\n\nfunction createMapNestedSchemaType(schema, schemaType, path, obj, options) {\n  const mapPath = path + '.$*';\n  let _mapType = { type: {} };\n  if (utils.hasUserDefinedProperty(obj, 'of')) {\n    const isInlineSchema = utils.isPOJO(obj.of) &&\n      Object.keys(obj.of).length > 0 &&\n      !utils.hasUserDefinedProperty(obj.of, schema.options.typeKey);\n    if (isInlineSchema) {\n      _mapType = { [schema.options.typeKey]: new Schema(obj.of) };\n    } else if (utils.isPOJO(obj.of)) {\n      _mapType = Object.assign({}, obj.of);\n    } else {\n      _mapType = { [schema.options.typeKey]: obj.of };\n    }\n\n    if (_mapType[schema.options.typeKey] && _mapType[schema.options.typeKey].instanceOfSchema) {\n      const subdocumentSchema = _mapType[schema.options.typeKey];\n      subdocumentSchema.eachPath((subpath, type) => {\n        if (type.options.select === true || type.options.select === false) {\n          throw new MongooseError('Cannot use schema-level projections (`select: true` or `select: false`) within maps at path \"' + path + '.' + subpath + '\"');\n        }\n      });\n    }\n\n    if (utils.hasUserDefinedProperty(obj, 'ref')) {\n      _mapType.ref = obj.ref;\n    }\n  }\n  schemaType.$__schemaType = schema.interpretAsType(mapPath, _mapType, options);\n}\n\n/**\n * Iterates the schemas paths similar to Array#forEach.\n *\n * The callback is passed the pathname and the schemaType instance.\n *\n * #### Example:\n *\n *     const userSchema = new Schema({ name: String, registeredAt: Date });\n *     userSchema.eachPath((pathname, schematype) => {\n *       // Prints twice:\n *       // name SchemaString { ... }\n *       // registeredAt SchemaDate { ... }\n *       console.log(pathname, schematype);\n *     });\n *\n * @param {Function} fn callback function\n * @return {Schema} this\n * @api public\n */\n\nSchema.prototype.eachPath = function(fn) {\n  const keys = Object.keys(this.paths);\n  const len = keys.length;\n\n  for (let i = 0; i < len; ++i) {\n    fn(keys[i], this.paths[keys[i]]);\n  }\n\n  return this;\n};\n\n/**\n * Returns an Array of path strings that are required by this schema.\n *\n * #### Example:\n *\n *     const s = new Schema({\n *       name: { type: String, required: true },\n *       age: { type: String, required: true },\n *       notes: String\n *     });\n *     s.requiredPaths(); // [ 'age', 'name' ]\n *\n * @api public\n * @param {Boolean} invalidate Refresh the cache\n * @return {Array}\n */\n\nSchema.prototype.requiredPaths = function requiredPaths(invalidate) {\n  if (this._requiredpaths && !invalidate) {\n    return this._requiredpaths;\n  }\n\n  const paths = Object.keys(this.paths);\n  let i = paths.length;\n  const ret = [];\n\n  while (i--) {\n    const path = paths[i];\n    if (this.paths[path].isRequired) {\n      ret.push(path);\n    }\n  }\n  this._requiredpaths = ret;\n  return this._requiredpaths;\n};\n\n/**\n * Returns indexes from fields and schema-level indexes (cached).\n *\n * @api private\n * @return {Array}\n */\n\nSchema.prototype.indexedPaths = function indexedPaths() {\n  if (this._indexedpaths) {\n    return this._indexedpaths;\n  }\n  this._indexedpaths = this.indexes();\n  return this._indexedpaths;\n};\n\n/**\n * Returns the pathType of `path` for this schema.\n *\n * Given a path, returns whether it is a real, virtual, nested, or ad-hoc/undefined path.\n *\n * #### Example:\n *\n *     const s = new Schema({ name: String, nested: { foo: String } });\n *     s.virtual('foo').get(() => 42);\n *     s.pathType('name'); // \"real\"\n *     s.pathType('nested'); // \"nested\"\n *     s.pathType('foo'); // \"virtual\"\n *     s.pathType('fail'); // \"adhocOrUndefined\"\n *\n * @param {String} path\n * @return {String}\n * @api public\n */\n\nSchema.prototype.pathType = function(path) {\n  if (this.paths.hasOwnProperty(path)) {\n    return 'real';\n  }\n  if (this.virtuals.hasOwnProperty(path)) {\n    return 'virtual';\n  }\n  if (this.nested.hasOwnProperty(path)) {\n    return 'nested';\n  }\n\n  // Convert to '.$' to check subpaths re: gh-6405\n  const cleanPath = _pathToPositionalSyntax(path);\n\n  if (this.subpaths.hasOwnProperty(cleanPath) || this.subpaths.hasOwnProperty(path)) {\n    return 'real';\n  }\n\n  const singleNestedPath = this.singleNestedPaths.hasOwnProperty(cleanPath) || this.singleNestedPaths.hasOwnProperty(path);\n  if (singleNestedPath) {\n    return singleNestedPath === 'nested' ? 'nested' : 'real';\n  }\n\n  // Look for maps\n  const mapPath = getMapPath(this, path);\n  if (mapPath != null) {\n    return 'real';\n  }\n\n  if (/\\.\\d+\\.|\\.\\d+$/.test(path)) {\n    return getPositionalPathType(this, path, cleanPath);\n  }\n  return 'adhocOrUndefined';\n};\n\n/**\n * Returns true iff this path is a child of a mixed schema.\n *\n * @param {String} path\n * @return {Boolean}\n * @api private\n */\n\nSchema.prototype.hasMixedParent = function(path) {\n  const subpaths = path.split(/\\./g);\n  path = '';\n  for (let i = 0; i < subpaths.length; ++i) {\n    path = i > 0 ? path + '.' + subpaths[i] : subpaths[i];\n    if (this.paths.hasOwnProperty(path) &&\n        this.paths[path] instanceof MongooseTypes.Mixed) {\n      return this.paths[path];\n    }\n  }\n\n  return null;\n};\n\n/**\n * Setup updatedAt and createdAt timestamps to documents if enabled\n *\n * @param {Boolean|Object} timestamps timestamps options\n * @api private\n */\nSchema.prototype.setupTimestamp = function(timestamps) {\n  return setupTimestamps(this, timestamps);\n};\n\n/**\n * ignore. Deprecated re: #6405\n * @param {Any} self\n * @param {String} path\n * @api private\n */\n\nfunction getPositionalPathType(self, path, cleanPath) {\n  const subpaths = path.split(/\\.(\\d+)\\.|\\.(\\d+)$/).filter(Boolean);\n  if (subpaths.length < 2) {\n    return self.paths.hasOwnProperty(subpaths[0]) ?\n      self.paths[subpaths[0]] :\n      'adhocOrUndefined';\n  }\n\n  let val = self.path(subpaths[0]);\n  let isNested = false;\n  if (!val) {\n    return 'adhocOrUndefined';\n  }\n\n  const last = subpaths.length - 1;\n\n  for (let i = 1; i < subpaths.length; ++i) {\n    isNested = false;\n    const subpath = subpaths[i];\n\n    if (i === last && val && !/\\D/.test(subpath)) {\n      if (val.$isMongooseDocumentArray) {\n        val = val.$embeddedSchemaType;\n      } else if (val instanceof MongooseTypes.Array) {\n        // StringSchema, NumberSchema, etc\n        val = val.caster;\n      } else {\n        val = undefined;\n      }\n      break;\n    }\n\n    // ignore if its just a position segment: path.0.subpath\n    if (!/\\D/.test(subpath)) {\n      // Nested array\n      if (val instanceof MongooseTypes.Array && i !== last) {\n        val = val.caster;\n      }\n      continue;\n    }\n\n    if (!(val && val.schema)) {\n      val = undefined;\n      break;\n    }\n\n    const type = val.schema.pathType(subpath);\n    isNested = (type === 'nested');\n    val = val.schema.path(subpath);\n  }\n\n  self.subpaths[cleanPath] = val;\n  if (val) {\n    return 'real';\n  }\n  if (isNested) {\n    return 'nested';\n  }\n  return 'adhocOrUndefined';\n}\n\n\n/*!\n * ignore\n */\n\nfunction getPositionalPath(self, path, cleanPath) {\n  getPositionalPathType(self, path, cleanPath);\n  return self.subpaths[cleanPath];\n}\n\n/**\n * Adds a method call to the queue.\n *\n * #### Example:\n *\n *     schema.methods.print = function() { console.log(this); };\n *     schema.queue('print', []); // Print the doc every one is instantiated\n *\n *     const Model = mongoose.model('Test', schema);\n *     new Model({ name: 'test' }); // Prints '{\"_id\": ..., \"name\": \"test\" }'\n *\n * @param {String} name name of the document method to call later\n * @param {Array} args arguments to pass to the method\n * @api public\n */\n\nSchema.prototype.queue = function(name, args) {\n  this.callQueue.push([name, args]);\n  return this;\n};\n\n/**\n * Defines a pre hook for the model.\n *\n * #### Example:\n *\n *     const toySchema = new Schema({ name: String, created: Date });\n *\n *     toySchema.pre('save', function(next) {\n *       if (!this.created) this.created = new Date;\n *       next();\n *     });\n *\n *     toySchema.pre('validate', function(next) {\n *       if (this.name !== 'Woody') this.name = 'Woody';\n *       next();\n *     });\n *\n *     // Equivalent to calling `pre()` on `find`, `findOne`, `findOneAndUpdate`.\n *     toySchema.pre(/^find/, function(next) {\n *       console.log(this.getFilter());\n *     });\n *\n *     // Equivalent to calling `pre()` on `updateOne`, `findOneAndUpdate`.\n *     toySchema.pre(['updateOne', 'findOneAndUpdate'], function(next) {\n *       console.log(this.getFilter());\n *     });\n *\n *     toySchema.pre('deleteOne', function() {\n *       // Runs when you call `Toy.deleteOne()`\n *     });\n *\n *     toySchema.pre('deleteOne', { document: true }, function() {\n *       // Runs when you call `doc.deleteOne()`\n *     });\n *\n * @param {String|RegExp|String[]} methodName The method name or regular expression to match method name\n * @param {Object} [options]\n * @param {Boolean} [options.document] If `name` is a hook for both document and query middleware, set to `true` to run on document middleware. For example, set `options.document` to `true` to apply this hook to `Document#deleteOne()` rather than `Query#deleteOne()`.\n * @param {Boolean} [options.query] If `name` is a hook for both document and query middleware, set to `true` to run on query middleware.\n * @param {Function} callback\n * @api public\n */\n\nSchema.prototype.pre = function(name) {\n  if (name instanceof RegExp) {\n    const remainingArgs = Array.prototype.slice.call(arguments, 1);\n    for (const fn of hookNames) {\n      if (name.test(fn)) {\n        this.pre.apply(this, [fn].concat(remainingArgs));\n      }\n    }\n    return this;\n  }\n  if (Array.isArray(name)) {\n    const remainingArgs = Array.prototype.slice.call(arguments, 1);\n    for (const el of name) {\n      this.pre.apply(this, [el].concat(remainingArgs));\n    }\n    return this;\n  }\n  this.s.hooks.pre.apply(this.s.hooks, arguments);\n  return this;\n};\n\n/**\n * Defines a post hook for the document\n *\n *     const schema = new Schema(..);\n *     schema.post('save', function (doc) {\n *       console.log('this fired after a document was saved');\n *     });\n *\n *     schema.post('find', function(docs) {\n *       console.log('this fired after you ran a find query');\n *     });\n *\n *     schema.post(/Many$/, function(res) {\n *       console.log('this fired after you ran `updateMany()` or `deleteMany()`');\n *     });\n *\n *     const Model = mongoose.model('Model', schema);\n *\n *     const m = new Model(..);\n *     m.save(function(err) {\n *       console.log('this fires after the `post` hook');\n *     });\n *\n *     m.find(function(err, docs) {\n *       console.log('this fires after the post find hook');\n *     });\n *\n * @param {String|RegExp|String[]} methodName The method name or regular expression to match method name\n * @param {Object} [options]\n * @param {Boolean} [options.document] If `name` is a hook for both document and query middleware, set to `true` to run on document middleware.\n * @param {Boolean} [options.query] If `name` is a hook for both document and query middleware, set to `true` to run on query middleware.\n * @param {Function} fn callback\n * @see middleware https://mongoosejs.com/docs/middleware.html\n * @see kareem https://npmjs.org/package/kareem\n * @api public\n */\n\nSchema.prototype.post = function(name) {\n  if (name instanceof RegExp) {\n    const remainingArgs = Array.prototype.slice.call(arguments, 1);\n    for (const fn of hookNames) {\n      if (name.test(fn)) {\n        this.post.apply(this, [fn].concat(remainingArgs));\n      }\n    }\n    return this;\n  }\n  if (Array.isArray(name)) {\n    const remainingArgs = Array.prototype.slice.call(arguments, 1);\n    for (const el of name) {\n      this.post.apply(this, [el].concat(remainingArgs));\n    }\n    return this;\n  }\n  this.s.hooks.post.apply(this.s.hooks, arguments);\n  return this;\n};\n\n/**\n * Registers a plugin for this schema.\n *\n * #### Example:\n *\n *     const s = new Schema({ name: String });\n *     s.plugin(schema => console.log(schema.path('name').path));\n *     mongoose.model('Test', s); // Prints 'name'\n *\n * Or with Options:\n *\n *     const s = new Schema({ name: String });\n *     s.plugin((schema, opts) => console.log(opts.text, schema.path('name').path), { text: \"Schema Path Name:\" });\n *     mongoose.model('Test', s); // Prints 'Schema Path Name: name'\n *\n * @param {Function} plugin The Plugin's callback\n * @param {Object} [opts] Options to pass to the plugin\n * @param {Boolean} [opts.deduplicate=false] If true, ignore duplicate plugins (same `fn` argument using `===`)\n * @see plugins https://mongoosejs.com/docs/plugins.html\n * @api public\n */\n\nSchema.prototype.plugin = function(fn, opts) {\n  if (typeof fn !== 'function') {\n    throw new Error('First param to `schema.plugin()` must be a function, ' +\n      'got \"' + (typeof fn) + '\"');\n  }\n\n  if (opts && opts.deduplicate) {\n    for (const plugin of this.plugins) {\n      if (plugin.fn === fn) {\n        return this;\n      }\n    }\n  }\n  this.plugins.push({ fn: fn, opts: opts });\n\n  fn(this, opts);\n  return this;\n};\n\n/**\n * Adds an instance method to documents constructed from Models compiled from this schema.\n *\n * #### Example:\n *\n *     const schema = kittySchema = new Schema(..);\n *\n *     schema.method('meow', function () {\n *       console.log('meeeeeoooooooooooow');\n *     })\n *\n *     const Kitty = mongoose.model('Kitty', schema);\n *\n *     const fizz = new Kitty;\n *     fizz.meow(); // meeeeeooooooooooooow\n *\n * If a hash of name/fn pairs is passed as the only argument, each name/fn pair will be added as methods.\n *\n *     schema.method({\n *         purr: function () {}\n *       , scratch: function () {}\n *     });\n *\n *     // later\n *     const fizz = new Kitty;\n *     fizz.purr();\n *     fizz.scratch();\n *\n * NOTE: `Schema.method()` adds instance methods to the `Schema.methods` object. You can also add instance methods directly to the `Schema.methods` object as seen in the [guide](https://mongoosejs.com/docs/guide.html#methods)\n *\n * @param {String|Object} name The Method Name for a single function, or a Object of \"string-function\" pairs.\n * @param {Function} [fn] The Function in a single-function definition.\n * @api public\n */\n\nSchema.prototype.method = function(name, fn, options) {\n  if (typeof name !== 'string') {\n    for (const i in name) {\n      this.methods[i] = name[i];\n      this.methodOptions[i] = clone(options);\n    }\n  } else {\n    this.methods[name] = fn;\n    this.methodOptions[name] = clone(options);\n  }\n  return this;\n};\n\n/**\n * Adds static \"class\" methods to Models compiled from this schema.\n *\n * #### Example:\n *\n *     const schema = new Schema(..);\n *     // Equivalent to `schema.statics.findByName = function(name) {}`;\n *     schema.static('findByName', function(name) {\n *       return this.find({ name: name });\n *     });\n *\n *     const Drink = mongoose.model('Drink', schema);\n *     await Drink.findByName('LaCroix');\n *\n * If a hash of name/fn pairs is passed as the only argument, each name/fn pair will be added as methods.\n *\n *     schema.static({\n *         findByName: function () {..}\n *       , findByCost: function () {..}\n *     });\n *\n *     const Drink = mongoose.model('Drink', schema);\n *     await Drink.findByName('LaCroix');\n *     await Drink.findByCost(3);\n *\n * If a hash of name/fn pairs is passed as the only argument, each name/fn pair will be added as statics.\n *\n * @param {String|Object} name The Method Name for a single function, or a Object of \"string-function\" pairs.\n * @param {Function} [fn] The Function in a single-function definition.\n * @api public\n * @see Statics https://mongoosejs.com/docs/guide.html#statics\n */\n\nSchema.prototype.static = function(name, fn) {\n  if (typeof name !== 'string') {\n    for (const i in name) {\n      this.statics[i] = name[i];\n    }\n  } else {\n    this.statics[name] = fn;\n  }\n  return this;\n};\n\n/**\n * Defines an index (most likely compound) for this schema.\n *\n * #### Example:\n *\n *     schema.index({ first: 1, last: -1 })\n *\n * @param {Object} fields The Fields to index, with the order, available values: `1 | -1 | '2d' | '2dsphere' | 'geoHaystack' | 'hashed' | 'text'`\n * @param {Object} [options] Options to pass to [MongoDB driver's `createIndex()` function](https://mongodb.github.io/node-mongodb-native/4.9/classes/Collection.html#createIndex)\n * @param {String | number} [options.expires=null] Mongoose-specific syntactic sugar, uses [ms](https://www.npmjs.com/package/ms) to convert `expires` option into seconds for the `expireAfterSeconds` in the above link.\n * @param {String} [options.language_override=null] Tells mongodb to use the specified field instead of `language` for parsing text indexes.\n * @api public\n */\n\nSchema.prototype.index = function(fields, options) {\n  fields || (fields = {});\n  options || (options = {});\n\n  if (options.expires) {\n    utils.expires(options);\n  }\n  for (const key in fields) {\n    if (this.aliases[key]) {\n      fields = utils.renameObjKey(fields, key, this.aliases[key]);\n    }\n  }\n  for (const field of Object.keys(fields)) {\n    if (fields[field] === 'ascending' || fields[field] === 'asc') {\n      fields[field] = 1;\n    } else if (fields[field] === 'descending' || fields[field] === 'desc') {\n      fields[field] = -1;\n    }\n  }\n\n  this._indexes.push([fields, options]);\n  return this;\n};\n\n/**\n * Sets a schema option.\n *\n * #### Example:\n *\n *     schema.set('strict'); // 'true' by default\n *     schema.set('strict', false); // Sets 'strict' to false\n *     schema.set('strict'); // 'false'\n *\n * @param {String} key The name of the option to set the value to\n * @param {Object} [value] The value to set the option to, if not passed, the option will be reset to default\n * @param {Array<string>} [tags] tags to add to read preference if key === 'read'\n * @see Schema https://mongoosejs.com/docs/api/schema.html#Schema()\n * @api public\n */\n\nSchema.prototype.set = function(key, value, tags) {\n  if (arguments.length === 1) {\n    return this.options[key];\n  }\n\n  switch (key) {\n    case 'read':\n      if (typeof value === 'string') {\n        this.options[key] = { mode: handleReadPreferenceAliases(value), tags };\n      } else if (Array.isArray(value) && typeof value[0] === 'string') {\n        this.options[key] = {\n          mode: handleReadPreferenceAliases(value[0]),\n          tags: value[1]\n        };\n      } else {\n        this.options[key] = value;\n      }\n      this._userProvidedOptions[key] = this.options[key];\n      break;\n    case 'timestamps':\n      this.setupTimestamp(value);\n      this.options[key] = value;\n      this._userProvidedOptions[key] = this.options[key];\n      break;\n    case '_id':\n      this.options[key] = value;\n      this._userProvidedOptions[key] = this.options[key];\n\n      if (value && !this.paths['_id']) {\n        addAutoId(this);\n      } else if (!value && this.paths['_id'] != null && this.paths['_id'].auto) {\n        this.remove('_id');\n      }\n      break;\n    default:\n      this.options[key] = value;\n      this._userProvidedOptions[key] = this.options[key];\n      break;\n  }\n\n  // Propagate `strict` and `strictQuery` changes down to implicitly created schemas\n  if (key === 'strict') {\n    _propagateOptionsToImplicitlyCreatedSchemas(this, { strict: value });\n  }\n  if (key === 'strictQuery') {\n    _propagateOptionsToImplicitlyCreatedSchemas(this, { strictQuery: value });\n  }\n\n  return this;\n};\n\n/*!\n * Recursively set options on implicitly created schemas\n */\n\nfunction _propagateOptionsToImplicitlyCreatedSchemas(baseSchema, options) {\n  for (const { schema } of baseSchema.childSchemas) {\n    if (!schema.$implicitlyCreated) {\n      continue;\n    }\n    Object.assign(schema.options, options);\n    _propagateOptionsToImplicitlyCreatedSchemas(schema, options);\n  }\n}\n\n/**\n * Gets a schema option.\n *\n * #### Example:\n *\n *     schema.get('strict'); // true\n *     schema.set('strict', false);\n *     schema.get('strict'); // false\n *\n * @param {String} key The name of the Option to get the current value for\n * @api public\n * @return {Any} the option's value\n */\n\nSchema.prototype.get = function(key) {\n  return this.options[key];\n};\n\nconst indexTypes = '2d 2dsphere hashed text'.split(' ');\n\n/**\n * The allowed index types\n *\n * @property {String[]} indexTypes\n * @memberOf Schema\n * @static\n * @api public\n */\n\nObject.defineProperty(Schema, 'indexTypes', {\n  get: function() {\n    return indexTypes;\n  },\n  set: function() {\n    throw new Error('Cannot overwrite Schema.indexTypes');\n  }\n});\n\n/**\n * Returns a list of indexes that this schema declares, via `schema.index()` or by `index: true` in a path's options.\n * Indexes are expressed as an array `[spec, options]`.\n *\n * #### Example:\n *\n *     const userSchema = new Schema({\n *       email: { type: String, required: true, unique: true },\n *       registeredAt: { type: Date, index: true }\n *     });\n *\n *     // [ [ { email: 1 }, { unique: true, background: true } ],\n *     //   [ { registeredAt: 1 }, { background: true } ] ]\n *     userSchema.indexes();\n *\n * [Plugins](https://mongoosejs.com/docs/plugins.html) can use the return value of this function to modify a schema's indexes.\n * For example, the below plugin makes every index unique by default.\n *\n *     function myPlugin(schema) {\n *       for (const index of schema.indexes()) {\n *         if (index[1].unique === undefined) {\n *           index[1].unique = true;\n *         }\n *       }\n *     }\n *\n * @api public\n * @return {Array} list of indexes defined in the schema\n */\n\nSchema.prototype.indexes = function() {\n  return getIndexes(this);\n};\n\n/**\n * Creates a virtual type with the given name.\n *\n * @param {String} name The name of the Virtual\n * @param {Object} [options]\n * @param {String|Model} [options.ref] model name or model instance. Marks this as a [populate virtual](https://mongoosejs.com/docs/populate.html#populate-virtuals).\n * @param {String|Function} [options.localField] Required for populate virtuals. See [populate virtual docs](https://mongoosejs.com/docs/populate.html#populate-virtuals) for more information.\n * @param {String|Function} [options.foreignField] Required for populate virtuals. See [populate virtual docs](https://mongoosejs.com/docs/populate.html#populate-virtuals) for more information.\n * @param {Boolean|Function} [options.justOne=false] Only works with populate virtuals. If [truthy](https://masteringjs.io/tutorials/fundamentals/truthy), will be a single doc or `null`. Otherwise, the populate virtual will be an array.\n * @param {Boolean} [options.count=false] Only works with populate virtuals. If [truthy](https://masteringjs.io/tutorials/fundamentals/truthy), this populate virtual will contain the number of documents rather than the documents themselves when you `populate()`.\n * @param {Function|null} [options.get=null] Adds a [getter](https://mongoosejs.com/docs/tutorials/getters-setters.html) to this virtual to transform the populated doc.\n * @param {Object|Function} [options.match=null] Apply a default [`match` option to populate](https://mongoosejs.com/docs/populate.html#match), adding an additional filter to the populate query.\n * @return {VirtualType}\n */\n\nSchema.prototype.virtual = function(name, options) {\n  if (name instanceof VirtualType || getConstructorName(name) === 'VirtualType') {\n    return this.virtual(name.path, name.options);\n  }\n  options = new VirtualOptions(options);\n\n  if (utils.hasUserDefinedProperty(options, ['ref', 'refPath'])) {\n    if (options.localField == null) {\n      throw new Error('Reference virtuals require `localField` option');\n    }\n\n    if (options.foreignField == null) {\n      throw new Error('Reference virtuals require `foreignField` option');\n    }\n\n    this.pre('init', function virtualPreInit(obj) {\n      if (mpath.has(name, obj)) {\n        const _v = mpath.get(name, obj);\n        if (!this.$$populatedVirtuals) {\n          this.$$populatedVirtuals = {};\n        }\n\n        if (options.justOne || options.count) {\n          this.$$populatedVirtuals[name] = Array.isArray(_v) ?\n            _v[0] :\n            _v;\n        } else {\n          this.$$populatedVirtuals[name] = Array.isArray(_v) ?\n            _v :\n            _v == null ? [] : [_v];\n        }\n\n        mpath.unset(name, obj);\n      }\n    });\n\n    const virtual = this.virtual(name);\n    virtual.options = options;\n\n    virtual.\n      set(function(_v) {\n        if (!this.$$populatedVirtuals) {\n          this.$$populatedVirtuals = {};\n        }\n\n        if (options.justOne || options.count) {\n          this.$$populatedVirtuals[name] = Array.isArray(_v) ?\n            _v[0] :\n            _v;\n\n          if (typeof this.$$populatedVirtuals[name] !== 'object') {\n            this.$$populatedVirtuals[name] = options.count ? _v : null;\n          }\n        } else {\n          this.$$populatedVirtuals[name] = Array.isArray(_v) ?\n            _v :\n            _v == null ? [] : [_v];\n\n          this.$$populatedVirtuals[name] = this.$$populatedVirtuals[name].filter(function(doc) {\n            return doc && typeof doc === 'object';\n          });\n        }\n      });\n\n    if (typeof options.get === 'function') {\n      virtual.get(options.get);\n    }\n\n    // Workaround for gh-8198: if virtual is under document array, make a fake\n    // virtual. See gh-8210, gh-13189\n    const parts = name.split('.');\n    let cur = parts[0];\n    for (let i = 0; i < parts.length - 1; ++i) {\n      if (this.paths[cur] == null) {\n        continue;\n      }\n\n      if (this.paths[cur].$isMongooseDocumentArray || this.paths[cur].$isSingleNested) {\n        const remnant = parts.slice(i + 1).join('.');\n        this.paths[cur].schema.virtual(remnant, options);\n        break;\n      }\n\n      cur += '.' + parts[i + 1];\n    }\n\n    return virtual;\n  }\n\n  const virtuals = this.virtuals;\n  const parts = name.split('.');\n\n  if (this.pathType(name) === 'real') {\n    throw new Error('Virtual path \"' + name + '\"' +\n      ' conflicts with a real path in the schema');\n  }\n\n  virtuals[name] = parts.reduce(function(mem, part, i) {\n    mem[part] || (mem[part] = (i === parts.length - 1)\n      ? new VirtualType(options, name)\n      : {});\n    return mem[part];\n  }, this.tree);\n\n  return virtuals[name];\n};\n\n/**\n * Returns the virtual type with the given `name`.\n *\n * @param {String} name The name of the Virtual to get\n * @return {VirtualType|null}\n */\n\nSchema.prototype.virtualpath = function(name) {\n  return this.virtuals.hasOwnProperty(name) ? this.virtuals[name] : null;\n};\n\n/**\n * Removes the given `path` (or [`paths`]).\n *\n * #### Example:\n *\n *     const schema = new Schema({ name: String, age: Number });\n *     schema.remove('name');\n *     schema.path('name'); // Undefined\n *     schema.path('age'); // SchemaNumber { ... }\n *\n * Or as a Array:\n *\n *     schema.remove(['name', 'age']);\n *     schema.path('name'); // Undefined\n *     schema.path('age'); // Undefined\n *\n * @param {String|Array} path The Path(s) to remove\n * @return {Schema} the Schema instance\n * @api public\n */\nSchema.prototype.remove = function(path) {\n  if (typeof path === 'string') {\n    path = [path];\n  }\n  if (Array.isArray(path)) {\n    path.forEach(function(name) {\n      if (this.path(name) == null && !this.nested[name]) {\n        return;\n      }\n      if (this.nested[name]) {\n        const allKeys = Object.keys(this.paths).\n          concat(Object.keys(this.nested));\n        for (const path of allKeys) {\n          if (path.startsWith(name + '.')) {\n            delete this.paths[path];\n            delete this.nested[path];\n            _deletePath(this, path);\n          }\n        }\n\n        delete this.nested[name];\n        _deletePath(this, name);\n        return;\n      }\n\n      delete this.paths[name];\n      _deletePath(this, name);\n    }, this);\n  }\n  return this;\n};\n\n/*!\n * ignore\n */\n\nfunction _deletePath(schema, name) {\n  const pieces = name.split('.');\n  const last = pieces.pop();\n\n  let branch = schema.tree;\n\n  for (const piece of pieces) {\n    branch = branch[piece];\n  }\n\n  delete branch[last];\n}\n\n/**\n * Removes the given virtual or virtuals from the schema.\n *\n * @param {String|Array} path The virutal path(s) to remove.\n * @returns {Schema} the Schema instance, or a mongoose error if the virtual does not exist.\n * @api public\n */\n\nSchema.prototype.removeVirtual = function(path) {\n  if (typeof path === 'string') {\n    path = [path];\n  }\n  if (Array.isArray(path)) {\n    for (const virtual of path) {\n      if (this.virtuals[virtual] == null) {\n        throw new MongooseError(`Attempting to remove virtual \"${virtual}\" that does not exist.`);\n      }\n    }\n\n    for (const virtual of path) {\n      delete this.paths[virtual];\n      delete this.virtuals[virtual];\n      if (virtual.indexOf('.') !== -1) {\n        mpath.unset(virtual, this.tree);\n      } else {\n        delete this.tree[virtual];\n      }\n    }\n  }\n  return this;\n};\n\n/**\n * Loads an ES6 class into a schema. Maps [setters](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/set) + [getters](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/get), [static methods](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Classes/static),\n * and [instance methods](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Classes#Class_body_and_method_definitions)\n * to schema [virtuals](https://mongoosejs.com/docs/guide.html#virtuals),\n * [statics](https://mongoosejs.com/docs/guide.html#statics), and\n * [methods](https://mongoosejs.com/docs/guide.html#methods).\n *\n * #### Example:\n *\n * ```javascript\n * const md5 = require('md5');\n * const userSchema = new Schema({ email: String });\n * class UserClass {\n *   // `gravatarImage` becomes a virtual\n *   get gravatarImage() {\n *     const hash = md5(this.email.toLowerCase());\n *     return `https://www.gravatar.com/avatar/${hash}`;\n *   }\n *\n *   // `getProfileUrl()` becomes a document method\n *   getProfileUrl() {\n *     return `https://mysite.com/${this.email}`;\n *   }\n *\n *   // `findByEmail()` becomes a static\n *   static findByEmail(email) {\n *     return this.findOne({ email });\n *   }\n * }\n *\n * // `schema` will now have a `gravatarImage` virtual, a `getProfileUrl()` method,\n * // and a `findByEmail()` static\n * userSchema.loadClass(UserClass);\n * ```\n *\n * @param {Function} model The Class to load\n * @param {Boolean} [virtualsOnly] if truthy, only pulls virtuals from the class, not methods or statics\n */\nSchema.prototype.loadClass = function(model, virtualsOnly) {\n  // Stop copying when hit certain base classes\n  if (model === Object.prototype ||\n      model === Function.prototype ||\n      model.prototype.hasOwnProperty('$isMongooseModelPrototype') ||\n      model.prototype.hasOwnProperty('$isMongooseDocumentPrototype')) {\n    return this;\n  }\n\n  this.loadClass(Object.getPrototypeOf(model), virtualsOnly);\n\n  // Add static methods\n  if (!virtualsOnly) {\n    Object.getOwnPropertyNames(model).forEach(function(name) {\n      if (name.match(/^(length|name|prototype|constructor|__proto__)$/)) {\n        return;\n      }\n      const prop = Object.getOwnPropertyDescriptor(model, name);\n      if (prop.hasOwnProperty('value')) {\n        this.static(name, prop.value);\n      }\n    }, this);\n  }\n\n  // Add methods and virtuals\n  Object.getOwnPropertyNames(model.prototype).forEach(function(name) {\n    if (name.match(/^(constructor)$/)) {\n      return;\n    }\n    const method = Object.getOwnPropertyDescriptor(model.prototype, name);\n    if (!virtualsOnly) {\n      if (typeof method.value === 'function') {\n        this.method(name, method.value);\n      }\n    }\n    if (typeof method.get === 'function') {\n      if (this.virtuals[name]) {\n        this.virtuals[name].getters = [];\n      }\n      this.virtual(name).get(method.get);\n    }\n    if (typeof method.set === 'function') {\n      if (this.virtuals[name]) {\n        this.virtuals[name].setters = [];\n      }\n      this.virtual(name).set(method.set);\n    }\n  }, this);\n\n  return this;\n};\n\n/*!\n * ignore\n */\n\nSchema.prototype._getSchema = function(path) {\n  const _this = this;\n  const pathschema = _this.path(path);\n  const resultPath = [];\n\n  if (pathschema) {\n    pathschema.$fullPath = path;\n    return pathschema;\n  }\n\n  function search(parts, schema) {\n    let p = parts.length + 1;\n    let foundschema;\n    let trypath;\n\n    while (p--) {\n      trypath = parts.slice(0, p).join('.');\n      foundschema = schema.path(trypath);\n      if (foundschema) {\n        resultPath.push(trypath);\n\n        if (foundschema.caster) {\n          // array of Mixed?\n          if (foundschema.caster instanceof MongooseTypes.Mixed) {\n            foundschema.caster.$fullPath = resultPath.join('.');\n            return foundschema.caster;\n          }\n\n          // Now that we found the array, we need to check if there\n          // are remaining document paths to look up for casting.\n          // Also we need to handle array.$.path since schema.path\n          // doesn't work for that.\n          // If there is no foundschema.schema we are dealing with\n          // a path like array.$\n          if (p !== parts.length) {\n            if (foundschema.schema) {\n              let ret;\n              if (parts[p] === '$' || isArrayFilter(parts[p])) {\n                if (p + 1 === parts.length) {\n                  // comments.$\n                  return foundschema.$embeddedSchemaType;\n                }\n                // comments.$.comments.$.title\n                ret = search(parts.slice(p + 1), foundschema.schema);\n                if (ret) {\n                  ret.$parentSchemaDocArray = ret.$parentSchemaDocArray ||\n                    (foundschema.schema.$isSingleNested ? null : foundschema);\n                }\n                return ret;\n              }\n              // this is the last path of the selector\n              ret = search(parts.slice(p), foundschema.schema);\n              if (ret) {\n                ret.$parentSchemaDocArray = ret.$parentSchemaDocArray ||\n                  (foundschema.schema.$isSingleNested ? null : foundschema);\n              }\n              return ret;\n            }\n          }\n        } else if (foundschema.$isSchemaMap) {\n          if (p >= parts.length) {\n            return foundschema;\n          }\n          // Any path in the map will be an instance of the map's embedded schematype\n          if (p + 1 >= parts.length) {\n            return foundschema.$__schemaType;\n          }\n\n          if (foundschema.$__schemaType instanceof MongooseTypes.Mixed) {\n            return foundschema.$__schemaType;\n          }\n          if (foundschema.$__schemaType.schema != null) {\n            // Map of docs\n            const ret = search(parts.slice(p + 1), foundschema.$__schemaType.schema);\n            return ret;\n          }\n        }\n\n        foundschema.$fullPath = resultPath.join('.');\n\n        return foundschema;\n      }\n    }\n  }\n\n  // look for arrays\n  const parts = path.split('.');\n  for (let i = 0; i < parts.length; ++i) {\n    if (parts[i] === '$' || isArrayFilter(parts[i])) {\n      // Re: gh-5628, because `schema.path()` doesn't take $ into account.\n      parts[i] = '0';\n    }\n    if (numberRE.test(parts[i])) {\n      parts[i] = '$';\n    }\n  }\n  return search(parts, _this);\n};\n\n/*!\n * ignore\n */\n\nSchema.prototype._getPathType = function(path) {\n  const _this = this;\n  const pathschema = _this.path(path);\n\n  if (pathschema) {\n    return 'real';\n  }\n\n  function search(parts, schema) {\n    let p = parts.length + 1,\n        foundschema,\n        trypath;\n\n    while (p--) {\n      trypath = parts.slice(0, p).join('.');\n      foundschema = schema.path(trypath);\n      if (foundschema) {\n        if (foundschema.caster) {\n          // array of Mixed?\n          if (foundschema.caster instanceof MongooseTypes.Mixed) {\n            return { schema: foundschema, pathType: 'mixed' };\n          }\n\n          // Now that we found the array, we need to check if there\n          // are remaining document paths to look up for casting.\n          // Also we need to handle array.$.path since schema.path\n          // doesn't work for that.\n          // If there is no foundschema.schema we are dealing with\n          // a path like array.$\n          if (p !== parts.length && foundschema.schema) {\n            if (parts[p] === '$' || isArrayFilter(parts[p])) {\n              if (p === parts.length - 1) {\n                return { schema: foundschema, pathType: 'nested' };\n              }\n              // comments.$.comments.$.title\n              return search(parts.slice(p + 1), foundschema.schema);\n            }\n            // this is the last path of the selector\n            return search(parts.slice(p), foundschema.schema);\n          }\n          return {\n            schema: foundschema,\n            pathType: foundschema.$isSingleNested ? 'nested' : 'array'\n          };\n        }\n        return { schema: foundschema, pathType: 'real' };\n      } else if (p === parts.length && schema.nested[trypath]) {\n        return { schema: schema, pathType: 'nested' };\n      }\n    }\n    return { schema: foundschema || schema, pathType: 'undefined' };\n  }\n\n  // look for arrays\n  return search(path.split('.'), _this);\n};\n\n/*!\n * ignore\n */\n\nfunction isArrayFilter(piece) {\n  return piece.startsWith('$[') && piece.endsWith(']');\n}\n\n/**\n * Called by `compile()` _right before_ compiling. Good for making any changes to\n * the schema that should respect options set by plugins, like `id`\n * @method _preCompile\n * @memberOf Schema\n * @instance\n * @api private\n */\n\nSchema.prototype._preCompile = function _preCompile() {\n  idGetter(this);\n};\n\n/*!\n * Module exports.\n */\n\nmodule.exports = exports = Schema;\n\n// require down here because of reference issues\n\n/**\n * The various built-in Mongoose Schema Types.\n *\n * #### Example:\n *\n *     const mongoose = require('mongoose');\n *     const ObjectId = mongoose.Schema.Types.ObjectId;\n *\n * #### Types:\n *\n * - [String](https://mongoosejs.com/docs/schematypes.html#strings)\n * - [Number](https://mongoosejs.com/docs/schematypes.html#numbers)\n * - [Boolean](https://mongoosejs.com/docs/schematypes.html#booleans) | Bool\n * - [Array](https://mongoosejs.com/docs/schematypes.html#arrays)\n * - [Buffer](https://mongoosejs.com/docs/schematypes.html#buffers)\n * - [Date](https://mongoosejs.com/docs/schematypes.html#dates)\n * - [ObjectId](https://mongoosejs.com/docs/schematypes.html#objectids) | Oid\n * - [Mixed](https://mongoosejs.com/docs/schematypes.html#mixed)\n * - [UUID](https://mongoosejs.com/docs/schematypes.html#uuid)\n * - [BigInt](https://mongoosejs.com/docs/schematypes.html#bigint)\n *\n * Using this exposed access to the `Mixed` SchemaType, we can use them in our schema.\n *\n *     const Mixed = mongoose.Schema.Types.Mixed;\n *     new mongoose.Schema({ _user: Mixed })\n *\n * @api public\n */\n\nSchema.Types = MongooseTypes = __webpack_require__(/*! ./schema/index */ \"(ssr)/./node_modules/mongoose/lib/schema/index.js\");\n\n/*!\n * ignore\n */\n\nexports.ObjectId = MongooseTypes.ObjectId;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbW9uZ29vc2UvbGliL3NjaGVtYS5qcyIsIm1hcHBpbmdzIjoiQUFBYTs7QUFFYjtBQUNBO0FBQ0E7O0FBRUEscUJBQXFCLDBEQUE4QjtBQUNuRCxlQUFlLG1CQUFPLENBQUMsb0RBQVE7QUFDL0Isc0JBQXNCLG1CQUFPLENBQUMsdUZBQXVCO0FBQ3JELG1CQUFtQixtQkFBTyxDQUFDLHFFQUFjO0FBQ3pDLDBCQUEwQixtQkFBTyxDQUFDLG1HQUE2QjtBQUMvRCx1QkFBdUIsbUJBQU8sQ0FBQyw2RkFBMEI7QUFDekQsb0JBQW9CLG1CQUFPLENBQUMsdUVBQWU7QUFDM0Msa0JBQWtCLG1CQUFPLENBQUMsaUdBQTRCO0FBQ3RELGNBQWMsbUJBQU8sQ0FBQywyRUFBaUI7QUFDdkMsWUFBWSxtQkFBTyxDQUFDLHVFQUFlO0FBQ25DLDJCQUEyQixtQkFBTyxDQUFDLHFHQUE4QjtBQUNqRSxtQkFBbUIsbUJBQU8sQ0FBQyxtR0FBNkI7QUFDeEQsb0NBQW9DLG1CQUFPLENBQUMsbUlBQTZDO0FBQ3pGLGlCQUFpQixtQkFBTyxDQUFDLCtGQUEyQjtBQUNwRCxjQUFjLG1CQUFPLENBQUMseUZBQXdCO0FBQzlDLGNBQWMsbUJBQU8sQ0FBQyxrREFBTztBQUM3Qix3QkFBd0IsbUJBQU8sQ0FBQyxxSEFBc0M7QUFDdEUsY0FBYyxtQkFBTyxDQUFDLDJEQUFTO0FBQy9CLG9CQUFvQixtQkFBTyxDQUFDLHlHQUFnQztBQUM1RCxhQUFhLG1CQUFPLENBQUMsa0JBQU07O0FBRTNCOztBQUVBLG1CQUFtQixnS0FDRTtBQUNyQixzQkFBc0IsNElBQXlEO0FBQy9FO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQyxjQUFjO0FBQ2hELG1DQUFtQyw4Q0FBOEM7QUFDakY7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLGNBQWMsSUFBSSw4QkFBOEI7QUFDcEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxxQkFBcUI7QUFDaEMsV0FBVyxRQUFRO0FBQ25CO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNB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Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsOEJBQThCLGlCQUFpQjtBQUMvQztBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FB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QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QixjQUFjO0FBQzNDO0FBQ0E7QUFDQTs7QUFFQSwrQkFBK0IsbUJBQU8sQ0FBQyx5RUFBZ0I7O0FBRXZEO0FBQ0E7QUFDQTs7QUFFQSxnQkFBZ0IiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9hcHAxLy4vbm9kZV9tb2R1bGVzL21vbmdvb3NlL2xpYi9zY2hlbWEuanM/YTI2ZCJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbi8qIVxuICogTW9kdWxlIGRlcGVuZGVuY2llcy5cbiAqL1xuXG5jb25zdCBFdmVudEVtaXR0ZXIgPSByZXF1aXJlKCdldmVudHMnKS5FdmVudEVtaXR0ZXI7XG5jb25zdCBLYXJlZW0gPSByZXF1aXJlKCdrYXJlZW0nKTtcbmNvbnN0IE1vbmdvb3NlRXJyb3IgPSByZXF1aXJlKCcuL2Vycm9yL21vbmdvb3NlRXJyb3InKTtcbmNvbnN0IFNjaGVtYVR5cGUgPSByZXF1aXJlKCcuL3NjaGVtYVR5cGUnKTtcbmNvbnN0IFNjaGVtYVR5cGVPcHRpb25zID0gcmVxdWlyZSgnLi9vcHRpb25zL3NjaGVtYVR5cGVPcHRpb25zJyk7XG5jb25zdCBWaXJ0dWFsT3B0aW9ucyA9IHJlcXVpcmUoJy4vb3B0aW9ucy92aXJ0dWFsT3B0aW9ucycpO1xuY29uc3QgVmlydHVhbFR5cGUgPSByZXF1aXJlKCcuL3ZpcnR1YWxUeXBlJyk7XG5jb25zdCBhZGRBdXRvSWQgPSByZXF1aXJlKCcuL2hlbHBlcnMvc2NoZW1hL2FkZEF1dG9JZCcpO1xuY29uc3QgY2xvbmUgPSByZXF1aXJlKCcuL2hlbHBlcnMvY2xvbmUnKTtcbmNvbnN0IGdldCA9IHJlcXVpcmUoJy4vaGVscGVycy9nZXQnKTtcbmNvbnN0IGdldENvbnN0cnVjdG9yTmFtZSA9IHJlcXVpcmUoJy4vaGVscGVycy9nZXRDb25zdHJ1Y3Rvck5hbWUnKTtcbmNvbnN0IGdldEluZGV4ZXMgPSByZXF1aXJlKCcuL2hlbHBlcnMvc2NoZW1hL2dldEluZGV4ZXMnKTtcbmNvbnN0IGhhbmRsZVJlYWRQcmVmZXJlbmNlQWxpYXNlcyA9IHJlcXVpcmUoJy4vaGVscGVycy9xdWVyeS9oYW5kbGVSZWFkUHJlZmVyZW5jZUFsaWFzZXMnKTtcbmNvbnN0IGlkR2V0dGVyID0gcmVxdWlyZSgnLi9oZWxwZXJzL3NjaGVtYS9pZEdldHRlcicpO1xuY29uc3QgbWVyZ2UgPSByZXF1aXJlKCcuL2hlbHBlcnMvc2NoZW1hL21lcmdlJyk7XG5jb25zdCBtcGF0aCA9IHJlcXVpcmUoJ21wYXRoJyk7XG5jb25zdCBzZXR1cFRpbWVzdGFtcHMgPSByZXF1aXJlKCcuL2hlbHBlcnMvdGltZXN0YW1wcy9zZXR1cFRpbWVzdGFtcHMnKTtcbmNvbnN0IHV0aWxzID0gcmVxdWlyZSgnLi91dGlscycpO1xuY29uc3QgdmFsaWRhdGVSZWYgPSByZXF1aXJlKCcuL2hlbHBlcnMvcG9wdWxhdGUvdmFsaWRhdGVSZWYnKTtcbmNvbnN0IHV0aWwgPSByZXF1aXJlKCd1dGlsJyk7XG5cbmxldCBNb25nb29zZVR5cGVzO1xuXG5jb25zdCBxdWVyeUhvb2tzID0gcmVxdWlyZSgnLi9oZWxwZXJzL3F1ZXJ5L2FwcGx5UXVlcnlNaWRkbGV3YXJlJykuXG4gIG1pZGRsZXdhcmVGdW5jdGlvbnM7XG5jb25zdCBkb2N1bWVudEhvb2tzID0gcmVxdWlyZSgnLi9oZWxwZXJzL21vZGVsL2FwcGx5SG9va3MnKS5taWRkbGV3YXJlRnVuY3Rpb25zO1xuY29uc3QgaG9va05hbWVzID0gcXVlcnlIb29rcy5jb25jYXQoZG9jdW1lbnRIb29rcykuXG4gIHJlZHVjZSgocywgaG9vaykgPT4gcy5hZGQoaG9vayksIG5ldyBTZXQoKSk7XG5cbmNvbnN0IGlzUE9KTyA9IHV0aWxzLmlzUE9KTztcblxubGV0IGlkID0gMDtcblxuY29uc3QgbnVtYmVyUkUgPSAvXlxcZCskLztcblxuLyoqXG4gKiBTY2hlbWEgY29uc3RydWN0b3IuXG4gKlxuICogIyMjIyBFeGFtcGxlOlxuICpcbiAqICAgICBjb25zdCBjaGlsZCA9IG5ldyBTY2hlbWEoeyBuYW1lOiBTdHJpbmcgfSk7XG4gKiAgICAgY29uc3Qgc2NoZW1hID0gbmV3IFNjaGVtYSh7IG5hbWU6IFN0cmluZywgYWdlOiBOdW1iZXIsIGNoaWxkcmVuOiBbY2hpbGRdIH0pO1xuICogICAgIGNvbnN0IFRyZWUgPSBtb25nb29zZS5tb2RlbCgnVHJlZScsIHNjaGVtYSk7XG4gKlxuICogICAgIC8vIHNldHRpbmcgc2NoZW1hIG9wdGlvbnNcbiAqICAgICBuZXcgU2NoZW1hKHsgbmFtZTogU3RyaW5nIH0sIHsgX2lkOiBmYWxzZSwgYXV0b0luZGV4OiBmYWxzZSB9KVxuICpcbiAqICMjIyMgT3B0aW9uczpcbiAqXG4gKiAtIFthdXRvSW5kZXhdKGh0dHBzOi8vbW9uZ29vc2Vqcy5jb20vZG9jcy9ndWlkZS5odG1sI2F1dG9JbmRleCk6IGJvb2wgLSBkZWZhdWx0cyB0byBudWxsICh3aGljaCBtZWFucyB1c2UgdGhlIGNvbm5lY3Rpb24ncyBhdXRvSW5kZXggb3B0aW9uKVxuICogLSBbYXV0b0NyZWF0ZV0oaHR0cHM6Ly9tb25nb29zZWpzLmNvbS9kb2NzL2d1aWRlLmh0bWwjYXV0b0NyZWF0ZSk6IGJvb2wgLSBkZWZhdWx0cyB0byBudWxsICh3aGljaCBtZWFucyB1c2UgdGhlIGNvbm5lY3Rpb24ncyBhdXRvQ3JlYXRlIG9wdGlvbilcbiAqIC0gW2J1ZmZlckNvbW1hbmRzXShodHRwczovL21vbmdvb3NlanMuY29tL2RvY3MvZ3VpZGUuaHRtbCNidWZmZXJDb21tYW5kcyk6IGJvb2wgLSBkZWZhdWx0cyB0byB0cnVlXG4gKiAtIFtidWZmZXJUaW1lb3V0TVNdKGh0dHBzOi8vbW9uZ29vc2Vqcy5jb20vZG9jcy9ndWlkZS5odG1sI2J1ZmZlclRpbWVvdXRNUyk6IG51bWJlciAtIGRlZmF1bHRzIHRvIDEwMDAwICgxMCBzZWNvbmRzKS4gSWYgYGJ1ZmZlckNvbW1hbmRzYCBpcyBlbmFibGVkLCB0aGUgYW1vdW50IG9mIHRpbWUgTW9uZ29vc2Ugd2lsbCB3YWl0IGZvciBjb25uZWN0aXZpdHkgdG8gYmUgcmVzdGFibGlzaGVkIGJlZm9yZSBlcnJvcmluZyBvdXQuXG4gKiAtIFtjYXBwZWRdKGh0dHBzOi8vbW9uZ29vc2Vqcy5jb20vZG9jcy9ndWlkZS5odG1sI2NhcHBlZCk6IGJvb2wgfCBudW1iZXIgfCBvYmplY3QgLSBkZWZhdWx0cyB0byBmYWxzZVxuICogLSBbY29sbGVjdGlvbl0oaHR0cHM6Ly9tb25nb29zZWpzLmNvbS9kb2NzL2d1aWRlLmh0bWwjY29sbGVjdGlvbik6IHN0cmluZyAtIG5vIGRlZmF1bHRcbiAqIC0gW2Rpc2NyaW1pbmF0b3JLZXldKGh0dHBzOi8vbW9uZ29vc2Vqcy5jb20vZG9jcy9ndWlkZS5odG1sI2Rpc2NyaW1pbmF0b3JLZXkpOiBzdHJpbmcgLSBkZWZhdWx0cyB0byBgX190YFxuICogLSBbaWRdKGh0dHBzOi8vbW9uZ29vc2Vqcy5jb20vZG9jcy9ndWlkZS5odG1sI2lkKTogYm9vbCAtIGRlZmF1bHRzIHRvIHRydWVcbiAqIC0gW19pZF0oaHR0cHM6Ly9tb25nb29zZWpzLmNvbS9kb2NzL2d1aWRlLmh0bWwjX2lkKTogYm9vbCAtIGRlZmF1bHRzIHRvIHRydWVcbiAqIC0gW21pbmltaXplXShodHRwczovL21vbmdvb3NlanMuY29tL2RvY3MvZ3VpZGUuaHRtbCNtaW5pbWl6ZSk6IGJvb2wgLSBjb250cm9scyBbZG9jdW1lbnQjdG9PYmplY3RdKGh0dHBzOi8vbW9uZ29vc2Vqcy5jb20vZG9jcy9hcGkvZG9jdW1lbnQuaHRtbCNEb2N1bWVudC5wcm90b3R5cGUudG9PYmplY3QoKSkgYmVoYXZpb3Igd2hlbiBjYWxsZWQgbWFudWFsbHkgLSBkZWZhdWx0cyB0byB0cnVlXG4gKiAtIFtyZWFkXShodHRwczovL21vbmdvb3NlanMuY29tL2RvY3MvZ3VpZGUuaHRtbCNyZWFkKTogc3RyaW5nXG4gKiAtIFt3cml0ZUNvbmNlcm5dKGh0dHBzOi8vbW9uZ29vc2Vqcy5jb20vZG9jcy9ndWlkZS5odG1sI3dyaXRlQ29uY2Vybik6IG9iamVjdCAtIGRlZmF1bHRzIHRvIG51bGwsIHVzZSB0byBvdmVycmlkZSBbdGhlIE1vbmdvREIgc2VydmVyJ3MgZGVmYXVsdCB3cml0ZSBjb25jZXJuIHNldHRpbmdzXShodHRwczovL3d3dy5tb25nb2RiLmNvbS9kb2NzL21hbnVhbC9yZWZlcmVuY2Uvd3JpdGUtY29uY2Vybi8pXG4gKiAtIFtzaGFyZEtleV0oaHR0cHM6Ly9tb25nb29zZWpzLmNvbS9kb2NzL2d1aWRlLmh0bWwjc2hhcmRLZXkpOiBvYmplY3QgLSBkZWZhdWx0cyB0byBgbnVsbGBcbiAqIC0gW3N0cmljdF0oaHR0cHM6Ly9tb25nb29zZWpzLmNvbS9kb2NzL2d1aWRlLmh0bWwjc3RyaWN0KTogYm9vbCAtIGRlZmF1bHRzIHRvIHRydWVcbiAqIC0gW3N0cmljdFF1ZXJ5XShodHRwczovL21vbmdvb3NlanMuY29tL2RvY3MvZ3VpZGUuaHRtbCNzdHJpY3RRdWVyeSk6IGJvb2wgLSBkZWZhdWx0cyB0byBmYWxzZVxuICogLSBbdG9KU09OXShodHRwczovL21vbmdvb3NlanMuY29tL2RvY3MvZ3VpZGUuaHRtbCN0b0pTT04pIC0gb2JqZWN0IC0gbm8gZGVmYXVsdFxuICogLSBbdG9PYmplY3RdKGh0dHBzOi8vbW9uZ29vc2Vqcy5jb20vZG9jcy9ndWlkZS5odG1sI3RvT2JqZWN0KSAtIG9iamVjdCAtIG5vIGRlZmF1bHRcbiAqIC0gW3R5cGVLZXldKGh0dHBzOi8vbW9uZ29vc2Vqcy5jb20vZG9jcy9ndWlkZS5odG1sI3R5cGVLZXkpIC0gc3RyaW5nIC0gZGVmYXVsdHMgdG8gJ3R5cGUnXG4gKiAtIFt2YWxpZGF0ZUJlZm9yZVNhdmVdKGh0dHBzOi8vbW9uZ29vc2Vqcy5jb20vZG9jcy9ndWlkZS5odG1sI3ZhbGlkYXRlQmVmb3JlU2F2ZSkgLSBib29sIC0gZGVmYXVsdHMgdG8gYHRydWVgXG4gKiAtIFt2YWxpZGF0ZU1vZGlmaWVkT25seV0oaHR0cHM6Ly9tb25nb29zZWpzLmNvbS9kb2NzL2FwaS9kb2N1bWVudC5odG1sI0RvY3VtZW50LnByb3RvdHlwZS52YWxpZGF0ZSgpKSAtIGJvb2wgLSBkZWZhdWx0cyB0byBgZmFsc2VgXG4gKiAtIFt2ZXJzaW9uS2V5XShodHRwczovL21vbmdvb3NlanMuY29tL2RvY3MvZ3VpZGUuaHRtbCN2ZXJzaW9uS2V5KTogc3RyaW5nIG9yIG9iamVjdCAtIGRlZmF1bHRzIHRvIFwiX192XCJcbiAqIC0gW29wdGltaXN0aWNDb25jdXJyZW5jeV0oaHR0cHM6Ly9tb25nb29zZWpzLmNvbS9kb2NzL2d1aWRlLmh0bWwjb3B0aW1pc3RpY0NvbmN1cnJlbmN5KTogYm9vbCAtIGRlZmF1bHRzIHRvIGZhbHNlLiBTZXQgdG8gdHJ1ZSB0byBlbmFibGUgW29wdGltaXN0aWMgY29uY3VycmVuY3ldKGh0dHBzOi8vdGhlY29kZWJhcmJhcmlhbi5jb20vd2hhdHMtbmV3LWluLW1vbmdvb3NlLTUtMTAtb3B0aW1pc3RpYy1jb25jdXJyZW5jeS5odG1sKS5cbiAqIC0gW2NvbGxhdGlvbl0oaHR0cHM6Ly9tb25nb29zZWpzLmNvbS9kb2NzL2d1aWRlLmh0bWwjY29sbGF0aW9uKTogb2JqZWN0IC0gZGVmYXVsdHMgdG8gbnVsbCAod2hpY2ggbWVhbnMgdXNlIG5vIGNvbGxhdGlvbilcbiAqIC0gW3RpbWVzZXJpZXNdKGh0dHBzOi8vbW9uZ29vc2Vqcy5jb20vZG9jcy9ndWlkZS5odG1sI3RpbWVzZXJpZXMpOiBvYmplY3QgLSBkZWZhdWx0cyB0byBudWxsICh3aGljaCBtZWFucyB0aGlzIHNjaGVtYSdzIGNvbGxlY3Rpb24gd29uJ3QgYmUgYSB0aW1lc2VyaWVzIGNvbGxlY3Rpb24pXG4gKiAtIFtzZWxlY3RQb3B1bGF0ZWRQYXRoc10oaHR0cHM6Ly9tb25nb29zZWpzLmNvbS9kb2NzL2d1aWRlLmh0bWwjc2VsZWN0UG9wdWxhdGVkUGF0aHMpOiBib29sZWFuIC0gZGVmYXVsdHMgdG8gYHRydWVgXG4gKiAtIFtza2lwVmVyc2lvbmluZ10oaHR0cHM6Ly9tb25nb29zZWpzLmNvbS9kb2NzL2d1aWRlLmh0bWwjc2tpcFZlcnNpb25pbmcpOiBvYmplY3QgLSBwYXRocyB0byBleGNsdWRlIGZyb20gdmVyc2lvbmluZ1xuICogLSBbdGltZXN0YW1wc10oaHR0cHM6Ly9tb25nb29zZWpzLmNvbS9kb2NzL2d1aWRlLmh0bWwjdGltZXN0YW1wcyk6IG9iamVjdCBvciBib29sZWFuIC0gZGVmYXVsdHMgdG8gYGZhbHNlYC4gSWYgdHJ1ZSwgTW9uZ29vc2UgYWRkcyBgY3JlYXRlZEF0YCBhbmQgYHVwZGF0ZWRBdGAgcHJvcGVydGllcyB0byB5b3VyIHNjaGVtYSBhbmQgbWFuYWdlcyB0aG9zZSBwcm9wZXJ0aWVzIGZvciB5b3UuXG4gKiAtIFtwbHVnaW5UYWdzXShodHRwczovL21vbmdvb3NlanMuY29tL2RvY3MvZ3VpZGUuaHRtbCNwbHVnaW5UYWdzKTogYXJyYXkgb2Ygc3RyaW5ncyAtIGRlZmF1bHRzIHRvIGB1bmRlZmluZWRgLiBJZiBzZXQgYW5kIHBsdWdpbiBjYWxsZWQgd2l0aCBgdGFnc2Agb3B0aW9uLCB3aWxsIG9ubHkgYXBwbHkgdGhhdCBwbHVnaW4gdG8gc2NoZW1hcyB3aXRoIGEgbWF0Y2hpbmcgdGFnLlxuICogLSBbdmlydHVhbHNdKGh0dHBzOi8vbW9uZ29vc2Vqcy5jb20vZG9jcy90dXRvcmlhbHMvdmlydHVhbHMuaHRtbCN2aXJ0dWFscy12aWEtc2NoZW1hLW9wdGlvbnMpOiBvYmplY3QgLSB2aXJ0dWFscyB0byBkZWZpbmUsIGFsaWFzIGZvciBbYC52aXJ0dWFsYF0oaHR0cHM6Ly9tb25nb29zZWpzLmNvbS9kb2NzL2FwaS9zY2hlbWEuaHRtbCNTY2hlbWEucHJvdG90eXBlLnZpcnR1YWwoKSlcbiAqIC0gW2NvbGxlY3Rpb25PcHRpb25zXTogb2JqZWN0IHdpdGggb3B0aW9ucyBwYXNzZWQgdG8gW2BjcmVhdGVDb2xsZWN0aW9uKClgXShodHRwczovL3d3dy5tb25nb2RiLmNvbS9kb2NzL21hbnVhbC9yZWZlcmVuY2UvbWV0aG9kL2RiLmNyZWF0ZUNvbGxlY3Rpb24vKSB3aGVuIGNhbGxpbmcgYE1vZGVsLmNyZWF0ZUNvbGxlY3Rpb24oKWAgb3IgYGF1dG9DcmVhdGVgIHNldCB0byB0cnVlLlxuICpcbiAqICMjIyMgT3B0aW9ucyBmb3IgTmVzdGVkIFNjaGVtYXM6XG4gKlxuICogLSBgZXhjbHVkZUluZGV4ZXNgOiBib29sIC0gZGVmYXVsdHMgdG8gYGZhbHNlYC4gSWYgYHRydWVgLCBza2lwIGJ1aWxkaW5nIGluZGV4ZXMgb24gdGhpcyBzY2hlbWEncyBwYXRocy5cbiAqXG4gKiAjIyMjIE5vdGU6XG4gKlxuICogX1doZW4gbmVzdGluZyBzY2hlbWFzLCAoYGNoaWxkcmVuYCBpbiB0aGUgZXhhbXBsZSBhYm92ZSksIGFsd2F5cyBkZWNsYXJlIHRoZSBjaGlsZCBzY2hlbWEgZmlyc3QgYmVmb3JlIHBhc3NpbmcgaXQgaW50byBpdHMgcGFyZW50Ll9cbiAqXG4gKiBAcGFyYW0ge09iamVjdHxTY2hlbWF8QXJyYXl9IFtkZWZpbml0aW9uXSBDYW4gYmUgb25lIG9mOiBvYmplY3QgZGVzY3JpYmluZyBzY2hlbWEgcGF0aHMsIG9yIHNjaGVtYSB0byBjb3B5LCBvciBhcnJheSBvZiBvYmplY3RzIGFuZCBzY2hlbWFzXG4gKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdXG4gKiBAaW5oZXJpdHMgTm9kZUpTIEV2ZW50RW1pdHRlciBodHRwczovL25vZGVqcy5vcmcvYXBpL2V2ZW50cy5odG1sI2NsYXNzLWV2ZW50ZW1pdHRlclxuICogQGV2ZW50IGBpbml0YDogRW1pdHRlZCBhZnRlciB0aGUgc2NoZW1hIGlzIGNvbXBpbGVkIGludG8gYSBgTW9kZWxgLlxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5mdW5jdGlvbiBTY2hlbWEob2JqLCBvcHRpb25zKSB7XG4gIGlmICghKHRoaXMgaW5zdGFuY2VvZiBTY2hlbWEpKSB7XG4gICAgcmV0dXJuIG5ldyBTY2hlbWEob2JqLCBvcHRpb25zKTtcbiAgfVxuXG4gIHRoaXMub2JqID0gb2JqO1xuICB0aGlzLnBhdGhzID0ge307XG4gIHRoaXMuYWxpYXNlcyA9IHt9O1xuICB0aGlzLnN1YnBhdGhzID0ge307XG4gIHRoaXMudmlydHVhbHMgPSB7fTtcbiAgdGhpcy5zaW5nbGVOZXN0ZWRQYXRocyA9IHt9O1xuICB0aGlzLm5lc3RlZCA9IHt9O1xuICB0aGlzLmluaGVyaXRzID0ge307XG4gIHRoaXMuY2FsbFF1ZXVlID0gW107XG4gIHRoaXMuX2luZGV4ZXMgPSBbXTtcbiAgdGhpcy5tZXRob2RzID0gKG9wdGlvbnMgJiYgb3B0aW9ucy5tZXRob2RzKSB8fCB7fTtcbiAgdGhpcy5tZXRob2RPcHRpb25zID0ge307XG4gIHRoaXMuc3RhdGljcyA9IChvcHRpb25zICYmIG9wdGlvbnMuc3RhdGljcykgfHwge307XG4gIHRoaXMudHJlZSA9IHt9O1xuICB0aGlzLnF1ZXJ5ID0gKG9wdGlvbnMgJiYgb3B0aW9ucy5xdWVyeSkgfHwge307XG4gIHRoaXMuY2hpbGRTY2hlbWFzID0gW107XG4gIHRoaXMucGx1Z2lucyA9IFtdO1xuICAvLyBGb3IgaW50ZXJuYWwgZGVidWdnaW5nLiBEbyBub3QgdXNlIHRoaXMgdG8gdHJ5IHRvIHNhdmUgYSBzY2hlbWEgaW4gTURCLlxuICB0aGlzLiRpZCA9ICsraWQ7XG4gIHRoaXMubWFwUGF0aHMgPSBbXTtcblxuICB0aGlzLnMgPSB7XG4gICAgaG9va3M6IG5ldyBLYXJlZW0oKVxuICB9O1xuICB0aGlzLm9wdGlvbnMgPSB0aGlzLmRlZmF1bHRPcHRpb25zKG9wdGlvbnMpO1xuXG4gIC8vIGJ1aWxkIHBhdGhzXG4gIGlmIChBcnJheS5pc0FycmF5KG9iaikpIHtcbiAgICBmb3IgKGNvbnN0IGRlZmluaXRpb24gb2Ygb2JqKSB7XG4gICAgICB0aGlzLmFkZChkZWZpbml0aW9uKTtcbiAgICB9XG4gIH0gZWxzZSBpZiAob2JqKSB7XG4gICAgdGhpcy5hZGQob2JqKTtcbiAgfVxuXG4gIC8vIGJ1aWxkIHZpcnR1YWwgcGF0aHNcbiAgaWYgKG9wdGlvbnMgJiYgb3B0aW9ucy52aXJ0dWFscykge1xuICAgIGNvbnN0IHZpcnR1YWxzID0gb3B0aW9ucy52aXJ0dWFscztcbiAgICBjb25zdCBwYXRoTmFtZXMgPSBPYmplY3Qua2V5cyh2aXJ0dWFscyk7XG4gICAgZm9yIChjb25zdCBwYXRoTmFtZSBvZiBwYXRoTmFtZXMpIHtcbiAgICAgIGNvbnN0IHBhdGhPcHRpb25zID0gdmlydHVhbHNbcGF0aE5hbWVdLm9wdGlvbnMgPyB2aXJ0dWFsc1twYXRoTmFtZV0ub3B0aW9ucyA6IHVuZGVmaW5lZDtcbiAgICAgIGNvbnN0IHZpcnR1YWwgPSB0aGlzLnZpcnR1YWwocGF0aE5hbWUsIHBhdGhPcHRpb25zKTtcblxuICAgICAgaWYgKHZpcnR1YWxzW3BhdGhOYW1lXS5nZXQpIHtcbiAgICAgICAgdmlydHVhbC5nZXQodmlydHVhbHNbcGF0aE5hbWVdLmdldCk7XG4gICAgICB9XG5cbiAgICAgIGlmICh2aXJ0dWFsc1twYXRoTmFtZV0uc2V0KSB7XG4gICAgICAgIHZpcnR1YWwuc2V0KHZpcnR1YWxzW3BhdGhOYW1lXS5zZXQpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8vIGNoZWNrIGlmIF9pZCdzIHZhbHVlIGlzIGEgc3ViZG9jdW1lbnQgKGdoLTIyNzYpXG4gIGNvbnN0IF9pZFN1YkRvYyA9IG9iaiAmJiBvYmouX2lkICYmIHV0aWxzLmlzT2JqZWN0KG9iai5faWQpO1xuXG4gIC8vIGVuc3VyZSB0aGUgZG9jdW1lbnRzIGdldCBhbiBhdXRvIF9pZCB1bmxlc3MgZGlzYWJsZWRcbiAgY29uc3QgYXV0b19pZCA9ICF0aGlzLnBhdGhzWydfaWQnXSAmJlxuICAgICAgKHRoaXMub3B0aW9ucy5faWQpICYmICFfaWRTdWJEb2M7XG5cbiAgaWYgKGF1dG9faWQpIHtcbiAgICBhZGRBdXRvSWQodGhpcyk7XG4gIH1cblxuICB0aGlzLnNldHVwVGltZXN0YW1wKHRoaXMub3B0aW9ucy50aW1lc3RhbXBzKTtcbn1cblxuLyoqXG4gKiBDcmVhdGUgdmlydHVhbCBwcm9wZXJ0aWVzIHdpdGggYWxpYXMgZmllbGRcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBhbGlhc0ZpZWxkcyhzY2hlbWEsIHBhdGhzKSB7XG4gIGZvciAoY29uc3QgcGF0aCBvZiBPYmplY3Qua2V5cyhwYXRocykpIHtcbiAgICBsZXQgYWxpYXMgPSBudWxsO1xuICAgIGlmIChwYXRoc1twYXRoXSAhPSBudWxsKSB7XG4gICAgICBhbGlhcyA9IHBhdGhzW3BhdGhdO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCBvcHRpb25zID0gZ2V0KHNjaGVtYS5wYXRoc1twYXRoXSwgJ29wdGlvbnMnKTtcbiAgICAgIGlmIChvcHRpb25zID09IG51bGwpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIGFsaWFzID0gb3B0aW9ucy5hbGlhcztcbiAgICB9XG5cbiAgICBpZiAoIWFsaWFzKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICBjb25zdCBwcm9wID0gc2NoZW1hLnBhdGhzW3BhdGhdLnBhdGg7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkoYWxpYXMpKSB7XG4gICAgICBmb3IgKGNvbnN0IGEgb2YgYWxpYXMpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBhICE9PSAnc3RyaW5nJykge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCB2YWx1ZSBmb3IgYWxpYXMgb3B0aW9uIG9uICcgKyBwcm9wICsgJywgZ290ICcgKyBhKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHNjaGVtYS5hbGlhc2VzW2FdID0gcHJvcDtcblxuICAgICAgICBzY2hlbWEuXG4gICAgICAgICAgdmlydHVhbChhKS5cbiAgICAgICAgICBnZXQoKGZ1bmN0aW9uKHApIHtcbiAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgaWYgKHR5cGVvZiB0aGlzLmdldCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmdldChwKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICByZXR1cm4gdGhpc1twXTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgfSkocHJvcCkpLlxuICAgICAgICAgIHNldCgoZnVuY3Rpb24ocCkge1xuICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKHYpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuJHNldChwLCB2KTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgfSkocHJvcCkpO1xuICAgICAgfVxuXG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIGFsaWFzICE9PSAnc3RyaW5nJykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIHZhbHVlIGZvciBhbGlhcyBvcHRpb24gb24gJyArIHByb3AgKyAnLCBnb3QgJyArIGFsaWFzKTtcbiAgICB9XG5cbiAgICBzY2hlbWEuYWxpYXNlc1thbGlhc10gPSBwcm9wO1xuXG4gICAgc2NoZW1hLlxuICAgICAgdmlydHVhbChhbGlhcykuXG4gICAgICBnZXQoKGZ1bmN0aW9uKHApIHtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgICAgIGlmICh0eXBlb2YgdGhpcy5nZXQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmdldChwKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIHRoaXNbcF07XG4gICAgICAgIH07XG4gICAgICB9KShwcm9wKSkuXG4gICAgICBzZXQoKGZ1bmN0aW9uKHApIHtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKHYpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy4kc2V0KHAsIHYpO1xuICAgICAgICB9O1xuICAgICAgfSkocHJvcCkpO1xuICB9XG59XG5cbi8qIVxuICogSW5oZXJpdCBmcm9tIEV2ZW50RW1pdHRlci5cbiAqL1xuU2NoZW1hLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoRXZlbnRFbWl0dGVyLnByb3RvdHlwZSk7XG5TY2hlbWEucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gU2NoZW1hO1xuU2NoZW1hLnByb3RvdHlwZS5pbnN0YW5jZU9mU2NoZW1hID0gdHJ1ZTtcblxuLyohXG4gKiBpZ25vcmVcbiAqL1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoU2NoZW1hLnByb3RvdHlwZSwgJyRzY2hlbWFUeXBlJywge1xuICBjb25maWd1cmFibGU6IGZhbHNlLFxuICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgd3JpdGFibGU6IHRydWVcbn0pO1xuXG4vKipcbiAqIEFycmF5IG9mIGNoaWxkIHNjaGVtYXMgKGZyb20gZG9jdW1lbnQgYXJyYXlzIGFuZCBzaW5nbGUgbmVzdGVkIHN1YmRvY3MpXG4gKiBhbmQgdGhlaXIgY29ycmVzcG9uZGluZyBjb21waWxlZCBtb2RlbHMuIEVhY2ggZWxlbWVudCBvZiB0aGUgYXJyYXkgaXNcbiAqIGFuIG9iamVjdCB3aXRoIDIgcHJvcGVydGllczogYHNjaGVtYWAgYW5kIGBtb2RlbGAuXG4gKlxuICogVGhpcyBwcm9wZXJ0eSBpcyB0eXBpY2FsbHkgb25seSB1c2VmdWwgZm9yIHBsdWdpbiBhdXRob3JzIGFuZCBhZHZhbmNlZCB1c2Vycy5cbiAqIFlvdSBkbyBub3QgbmVlZCB0byBpbnRlcmFjdCB3aXRoIHRoaXMgcHJvcGVydHkgYXQgYWxsIHRvIHVzZSBtb25nb29zZS5cbiAqXG4gKiBAYXBpIHB1YmxpY1xuICogQHByb3BlcnR5IGNoaWxkU2NoZW1hc1xuICogQG1lbWJlck9mIFNjaGVtYVxuICogQGluc3RhbmNlXG4gKi9cblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KFNjaGVtYS5wcm90b3R5cGUsICdjaGlsZFNjaGVtYXMnLCB7XG4gIGNvbmZpZ3VyYWJsZTogZmFsc2UsXG4gIGVudW1lcmFibGU6IHRydWUsXG4gIHdyaXRhYmxlOiB0cnVlXG59KTtcblxuLyoqXG4gKiBPYmplY3QgY29udGFpbmluZyBhbGwgdmlydHVhbHMgZGVmaW5lZCBvbiB0aGlzIHNjaGVtYS5cbiAqIFRoZSBvYmplY3RzJyBrZXlzIGFyZSB0aGUgdmlydHVhbCBwYXRocyBhbmQgdmFsdWVzIGFyZSBpbnN0YW5jZXMgb2YgYFZpcnR1YWxUeXBlYC5cbiAqXG4gKiBUaGlzIHByb3BlcnR5IGlzIHR5cGljYWxseSBvbmx5IHVzZWZ1bCBmb3IgcGx1Z2luIGF1dGhvcnMgYW5kIGFkdmFuY2VkIHVzZXJzLlxuICogWW91IGRvIG5vdCBuZWVkIHRvIGludGVyYWN0IHdpdGggdGhpcyBwcm9wZXJ0eSBhdCBhbGwgdG8gdXNlIG1vbmdvb3NlLlxuICpcbiAqICMjIyMgRXhhbXBsZTpcbiAqXG4gKiAgICAgY29uc3Qgc2NoZW1hID0gbmV3IFNjaGVtYSh7fSk7XG4gKiAgICAgc2NoZW1hLnZpcnR1YWwoJ2Fuc3dlcicpLmdldCgoKSA9PiA0Mik7XG4gKlxuICogICAgIGNvbnNvbGUubG9nKHNjaGVtYS52aXJ0dWFscyk7IC8vIHsgYW5zd2VyOiBWaXJ0dWFsVHlwZSB7IHBhdGg6ICdhbnN3ZXInLCAuLi4gfSB9XG4gKiAgICAgY29uc29sZS5sb2coc2NoZW1hLnZpcnR1YWxzWydhbnN3ZXInXS5nZXR0ZXJzWzBdLmNhbGwoKSk7IC8vIDQyXG4gKlxuICogQGFwaSBwdWJsaWNcbiAqIEBwcm9wZXJ0eSB2aXJ0dWFsc1xuICogQG1lbWJlck9mIFNjaGVtYVxuICogQGluc3RhbmNlXG4gKi9cblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KFNjaGVtYS5wcm90b3R5cGUsICd2aXJ0dWFscycsIHtcbiAgY29uZmlndXJhYmxlOiBmYWxzZSxcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgd3JpdGFibGU6IHRydWVcbn0pO1xuXG4vKipcbiAqIFRoZSBvcmlnaW5hbCBvYmplY3QgcGFzc2VkIHRvIHRoZSBzY2hlbWEgY29uc3RydWN0b3JcbiAqXG4gKiAjIyMjIEV4YW1wbGU6XG4gKlxuICogICAgIGNvbnN0IHNjaGVtYSA9IG5ldyBTY2hlbWEoeyBhOiBTdHJpbmcgfSkuYWRkKHsgYjogU3RyaW5nIH0pO1xuICogICAgIHNjaGVtYS5vYmo7IC8vIHsgYTogU3RyaW5nIH1cbiAqXG4gKiBAYXBpIHB1YmxpY1xuICogQHByb3BlcnR5IG9ialxuICogQG1lbWJlck9mIFNjaGVtYVxuICogQGluc3RhbmNlXG4gKi9cblxuU2NoZW1hLnByb3RvdHlwZS5vYmo7XG5cbi8qKlxuICogVGhlIHBhdGhzIGRlZmluZWQgb24gdGhpcyBzY2hlbWEuIFRoZSBrZXlzIGFyZSB0aGUgdG9wLWxldmVsIHBhdGhzXG4gKiBpbiB0aGlzIHNjaGVtYSwgYW5kIHRoZSB2YWx1ZXMgYXJlIGluc3RhbmNlcyBvZiB0aGUgU2NoZW1hVHlwZSBjbGFzcy5cbiAqXG4gKiAjIyMjIEV4YW1wbGU6XG4gKlxuICogICAgIGNvbnN0IHNjaGVtYSA9IG5ldyBTY2hlbWEoeyBuYW1lOiBTdHJpbmcgfSwgeyBfaWQ6IGZhbHNlIH0pO1xuICogICAgIHNjaGVtYS5wYXRoczsgLy8geyBuYW1lOiBTY2hlbWFTdHJpbmcgeyAuLi4gfSB9XG4gKlxuICogICAgIHNjaGVtYS5hZGQoeyBhZ2U6IE51bWJlciB9KTtcbiAqICAgICBzY2hlbWEucGF0aHM7IC8vIHsgbmFtZTogU2NoZW1hU3RyaW5nIHsgLi4uIH0sIGFnZTogU2NoZW1hTnVtYmVyIHsgLi4uIH0gfVxuICpcbiAqIEBhcGkgcHVibGljXG4gKiBAcHJvcGVydHkgcGF0aHNcbiAqIEBtZW1iZXJPZiBTY2hlbWFcbiAqIEBpbnN0YW5jZVxuICovXG5cblNjaGVtYS5wcm90b3R5cGUucGF0aHM7XG5cbi8qKlxuICogU2NoZW1hIGFzIGEgdHJlZVxuICpcbiAqICMjIyMgRXhhbXBsZTpcbiAqXG4gKiAgICAge1xuICogICAgICAgICAnX2lkJyAgICAgOiBPYmplY3RJZFxuICogICAgICAgLCAnbmVzdGVkJyAgOiB7XG4gKiAgICAgICAgICAgICAna2V5JyA6IFN0cmluZ1xuICogICAgICAgICB9XG4gKiAgICAgfVxuICpcbiAqIEBhcGkgcHJpdmF0ZVxuICogQHByb3BlcnR5IHRyZWVcbiAqIEBtZW1iZXJPZiBTY2hlbWFcbiAqIEBpbnN0YW5jZVxuICovXG5cblNjaGVtYS5wcm90b3R5cGUudHJlZTtcblxuLyoqXG4gKiBSZXR1cm5zIGEgZGVlcCBjb3B5IG9mIHRoZSBzY2hlbWFcbiAqXG4gKiAjIyMjIEV4YW1wbGU6XG4gKlxuICogICAgIGNvbnN0IHNjaGVtYSA9IG5ldyBTY2hlbWEoeyBuYW1lOiBTdHJpbmcgfSk7XG4gKiAgICAgY29uc3QgY2xvbmUgPSBzY2hlbWEuY2xvbmUoKTtcbiAqICAgICBjbG9uZSA9PT0gc2NoZW1hOyAvLyBmYWxzZVxuICogICAgIGNsb25lLnBhdGgoJ25hbWUnKTsgLy8gU2NoZW1hU3RyaW5nIHsgLi4uIH1cbiAqXG4gKiBAcmV0dXJuIHtTY2hlbWF9IHRoZSBjbG9uZWQgc2NoZW1hXG4gKiBAYXBpIHB1YmxpY1xuICogQG1lbWJlck9mIFNjaGVtYVxuICogQGluc3RhbmNlXG4gKi9cblxuU2NoZW1hLnByb3RvdHlwZS5jbG9uZSA9IGZ1bmN0aW9uKCkge1xuICBjb25zdCBzID0gdGhpcy5fY2xvbmUoKTtcblxuICAvLyBCdWJibGUgdXAgYGluaXRgIGZvciBiYWNrd2FyZHMgY29tcGF0XG4gIHMub24oJ2luaXQnLCB2ID0+IHRoaXMuZW1pdCgnaW5pdCcsIHYpKTtcblxuICByZXR1cm4gcztcbn07XG5cbi8qIVxuICogaWdub3JlXG4gKi9cblxuU2NoZW1hLnByb3RvdHlwZS5fY2xvbmUgPSBmdW5jdGlvbiBfY2xvbmUoQ29uc3RydWN0b3IpIHtcbiAgQ29uc3RydWN0b3IgPSBDb25zdHJ1Y3RvciB8fCAodGhpcy5iYXNlID09IG51bGwgPyBTY2hlbWEgOiB0aGlzLmJhc2UuU2NoZW1hKTtcblxuICBjb25zdCBzID0gbmV3IENvbnN0cnVjdG9yKHt9LCB0aGlzLl91c2VyUHJvdmlkZWRPcHRpb25zKTtcbiAgcy5iYXNlID0gdGhpcy5iYXNlO1xuICBzLm9iaiA9IHRoaXMub2JqO1xuICBzLm9wdGlvbnMgPSBjbG9uZSh0aGlzLm9wdGlvbnMpO1xuICBzLmNhbGxRdWV1ZSA9IHRoaXMuY2FsbFF1ZXVlLm1hcChmdW5jdGlvbihmKSB7IHJldHVybiBmOyB9KTtcbiAgcy5tZXRob2RzID0gY2xvbmUodGhpcy5tZXRob2RzKTtcbiAgcy5tZXRob2RPcHRpb25zID0gY2xvbmUodGhpcy5tZXRob2RPcHRpb25zKTtcbiAgcy5zdGF0aWNzID0gY2xvbmUodGhpcy5zdGF0aWNzKTtcbiAgcy5xdWVyeSA9IGNsb25lKHRoaXMucXVlcnkpO1xuICBzLnBsdWdpbnMgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbCh0aGlzLnBsdWdpbnMpO1xuICBzLl9pbmRleGVzID0gY2xvbmUodGhpcy5faW5kZXhlcyk7XG4gIHMucy5ob29rcyA9IHRoaXMucy5ob29rcy5jbG9uZSgpO1xuXG4gIHMudHJlZSA9IGNsb25lKHRoaXMudHJlZSk7XG4gIHMucGF0aHMgPSBPYmplY3QuZnJvbUVudHJpZXMoXG4gICAgT2JqZWN0LmVudHJpZXModGhpcy5wYXRocykubWFwKChba2V5LCB2YWx1ZV0pID0+IChba2V5LCB2YWx1ZS5jbG9uZSgpXSkpXG4gICk7XG4gIHMubmVzdGVkID0gY2xvbmUodGhpcy5uZXN0ZWQpO1xuICBzLnN1YnBhdGhzID0gY2xvbmUodGhpcy5zdWJwYXRocyk7XG4gIGZvciAoY29uc3Qgc2NoZW1hVHlwZSBvZiBPYmplY3QudmFsdWVzKHMucGF0aHMpKSB7XG4gICAgaWYgKHNjaGVtYVR5cGUuJGlzU2luZ2xlTmVzdGVkKSB7XG4gICAgICBjb25zdCBwYXRoID0gc2NoZW1hVHlwZS5wYXRoO1xuICAgICAgZm9yIChjb25zdCBrZXkgb2YgT2JqZWN0LmtleXMoc2NoZW1hVHlwZS5zY2hlbWEucGF0aHMpKSB7XG4gICAgICAgIHMuc2luZ2xlTmVzdGVkUGF0aHNbcGF0aCArICcuJyArIGtleV0gPSBzY2hlbWFUeXBlLnNjaGVtYS5wYXRoc1trZXldO1xuICAgICAgfVxuICAgICAgZm9yIChjb25zdCBrZXkgb2YgT2JqZWN0LmtleXMoc2NoZW1hVHlwZS5zY2hlbWEuc2luZ2xlTmVzdGVkUGF0aHMpKSB7XG4gICAgICAgIHMuc2luZ2xlTmVzdGVkUGF0aHNbcGF0aCArICcuJyArIGtleV0gPVxuICAgICAgICAgIHNjaGVtYVR5cGUuc2NoZW1hLnNpbmdsZU5lc3RlZFBhdGhzW2tleV07XG4gICAgICB9XG4gICAgICBmb3IgKGNvbnN0IGtleSBvZiBPYmplY3Qua2V5cyhzY2hlbWFUeXBlLnNjaGVtYS5zdWJwYXRocykpIHtcbiAgICAgICAgcy5zaW5nbGVOZXN0ZWRQYXRoc1twYXRoICsgJy4nICsga2V5XSA9XG4gICAgICAgICAgc2NoZW1hVHlwZS5zY2hlbWEuc3VicGF0aHNba2V5XTtcbiAgICAgIH1cbiAgICAgIGZvciAoY29uc3Qga2V5IG9mIE9iamVjdC5rZXlzKHNjaGVtYVR5cGUuc2NoZW1hLm5lc3RlZCkpIHtcbiAgICAgICAgcy5zaW5nbGVOZXN0ZWRQYXRoc1twYXRoICsgJy4nICsga2V5XSA9ICduZXN0ZWQnO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBzLmNoaWxkU2NoZW1hcyA9IGdhdGhlckNoaWxkU2NoZW1hcyhzKTtcblxuICBzLnZpcnR1YWxzID0gY2xvbmUodGhpcy52aXJ0dWFscyk7XG4gIHMuJGdsb2JhbFBsdWdpbnNBcHBsaWVkID0gdGhpcy4kZ2xvYmFsUGx1Z2luc0FwcGxpZWQ7XG4gIHMuJGlzUm9vdERpc2NyaW1pbmF0b3IgPSB0aGlzLiRpc1Jvb3REaXNjcmltaW5hdG9yO1xuICBzLiRpbXBsaWNpdGx5Q3JlYXRlZCA9IHRoaXMuJGltcGxpY2l0bHlDcmVhdGVkO1xuICBzLiRpZCA9ICsraWQ7XG4gIHMuJG9yaWdpbmFsU2NoZW1hSWQgPSB0aGlzLiRpZDtcbiAgcy5tYXBQYXRocyA9IFtdLmNvbmNhdCh0aGlzLm1hcFBhdGhzKTtcblxuICBpZiAodGhpcy5kaXNjcmltaW5hdG9yTWFwcGluZyAhPSBudWxsKSB7XG4gICAgcy5kaXNjcmltaW5hdG9yTWFwcGluZyA9IE9iamVjdC5hc3NpZ24oe30sIHRoaXMuZGlzY3JpbWluYXRvck1hcHBpbmcpO1xuICB9XG4gIGlmICh0aGlzLmRpc2NyaW1pbmF0b3JzICE9IG51bGwpIHtcbiAgICBzLmRpc2NyaW1pbmF0b3JzID0gT2JqZWN0LmFzc2lnbih7fSwgdGhpcy5kaXNjcmltaW5hdG9ycyk7XG4gIH1cbiAgaWYgKHRoaXMuX2FwcGx5RGlzY3JpbWluYXRvcnMgIT0gbnVsbCkge1xuICAgIHMuX2FwcGx5RGlzY3JpbWluYXRvcnMgPSBuZXcgTWFwKHRoaXMuX2FwcGx5RGlzY3JpbWluYXRvcnMpO1xuICB9XG5cbiAgcy5hbGlhc2VzID0gT2JqZWN0LmFzc2lnbih7fSwgdGhpcy5hbGlhc2VzKTtcblxuICByZXR1cm4gcztcbn07XG5cbi8qKlxuICogUmV0dXJucyBhIG5ldyBzY2hlbWEgdGhhdCBoYXMgdGhlIHBpY2tlZCBgcGF0aHNgIGZyb20gdGhpcyBzY2hlbWEuXG4gKlxuICogVGhpcyBtZXRob2QgaXMgYW5hbGFnb3VzIHRvIFtMb2Rhc2gncyBgcGljaygpYCBmdW5jdGlvbl0oaHR0cHM6Ly9sb2Rhc2guY29tL2RvY3MvNC4xNy4xNSNwaWNrKSBmb3IgTW9uZ29vc2Ugc2NoZW1hcy5cbiAqXG4gKiAjIyMjIEV4YW1wbGU6XG4gKlxuICogICAgIGNvbnN0IHNjaGVtYSA9IFNjaGVtYSh7IG5hbWU6IFN0cmluZywgYWdlOiBOdW1iZXIgfSk7XG4gKiAgICAgLy8gQ3JlYXRlcyBhIG5ldyBzY2hlbWEgd2l0aCB0aGUgc2FtZSBgbmFtZWAgcGF0aCBhcyBgc2NoZW1hYCxcbiAqICAgICAvLyBidXQgbm8gYGFnZWAgcGF0aC5cbiAqICAgICBjb25zdCBuZXdTY2hlbWEgPSBzY2hlbWEucGljayhbJ25hbWUnXSk7XG4gKlxuICogICAgIG5ld1NjaGVtYS5wYXRoKCduYW1lJyk7IC8vIFNjaGVtYVN0cmluZyB7IC4uLiB9XG4gKiAgICAgbmV3U2NoZW1hLnBhdGgoJ2FnZScpOyAvLyB1bmRlZmluZWRcbiAqXG4gKiBAcGFyYW0ge1N0cmluZ1tdfSBwYXRocyBMaXN0IG9mIFBhdGhzIHRvIHBpY2sgZm9yIHRoZSBuZXcgU2NoZW1hXG4gKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdIE9wdGlvbnMgdG8gcGFzcyB0byB0aGUgbmV3IFNjaGVtYSBDb25zdHJ1Y3RvciAoc2FtZSBhcyBgbmV3IFNjaGVtYSguLiwgT3B0aW9ucylgKS4gRGVmYXVsdHMgdG8gYHRoaXMub3B0aW9uc2AgaWYgbm90IHNldC5cbiAqIEByZXR1cm4ge1NjaGVtYX1cbiAqIEBhcGkgcHVibGljXG4gKi9cblxuU2NoZW1hLnByb3RvdHlwZS5waWNrID0gZnVuY3Rpb24ocGF0aHMsIG9wdGlvbnMpIHtcbiAgY29uc3QgbmV3U2NoZW1hID0gbmV3IFNjaGVtYSh7fSwgb3B0aW9ucyB8fCB0aGlzLm9wdGlvbnMpO1xuICBpZiAoIUFycmF5LmlzQXJyYXkocGF0aHMpKSB7XG4gICAgdGhyb3cgbmV3IE1vbmdvb3NlRXJyb3IoJ1NjaGVtYSNwaWNrKCkgb25seSBhY2NlcHRzIGFuIGFycmF5IGFyZ3VtZW50LCAnICtcbiAgICAgICdnb3QgXCInICsgdHlwZW9mIHBhdGhzICsgJ1wiJyk7XG4gIH1cblxuICBmb3IgKGNvbnN0IHBhdGggb2YgcGF0aHMpIHtcbiAgICBpZiAodGhpcy5uZXN0ZWRbcGF0aF0pIHtcbiAgICAgIG5ld1NjaGVtYS5hZGQoeyBbcGF0aF06IGdldCh0aGlzLnRyZWUsIHBhdGgpIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCBzY2hlbWF0eXBlID0gdGhpcy5wYXRoKHBhdGgpO1xuICAgICAgaWYgKHNjaGVtYXR5cGUgPT0gbnVsbCkge1xuICAgICAgICB0aHJvdyBuZXcgTW9uZ29vc2VFcnJvcignUGF0aCBgJyArIHBhdGggKyAnYCBpcyBub3QgaW4gdGhlIHNjaGVtYScpO1xuICAgICAgfVxuICAgICAgbmV3U2NoZW1hLmFkZCh7IFtwYXRoXTogc2NoZW1hdHlwZSB9KTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gbmV3U2NoZW1hO1xufTtcblxuLyoqXG4gKiBSZXR1cm5zIGEgbmV3IHNjaGVtYSB0aGF0IGhhcyB0aGUgYHBhdGhzYCBmcm9tIHRoZSBvcmlnaW5hbCBzY2hlbWEsIG1pbnVzIHRoZSBvbWl0dGVkIG9uZXMuXG4gKlxuICogVGhpcyBtZXRob2QgaXMgYW5hbGFnb3VzIHRvIFtMb2Rhc2gncyBgb21pdCgpYCBmdW5jdGlvbl0oaHR0cHM6Ly9sb2Rhc2guY29tL2RvY3MvI29taXQpIGZvciBNb25nb29zZSBzY2hlbWFzLlxuICpcbiAqICMjIyMgRXhhbXBsZTpcbiAqXG4gKiAgICAgY29uc3Qgc2NoZW1hID0gU2NoZW1hKHsgbmFtZTogU3RyaW5nLCBhZ2U6IE51bWJlciB9KTtcbiAqICAgICAvLyBDcmVhdGVzIGEgbmV3IHNjaGVtYSBvbWl0dGluZyB0aGUgYGFnZWAgcGF0aFxuICogICAgIGNvbnN0IG5ld1NjaGVtYSA9IHNjaGVtYS5vbWl0KFsnYWdlJ10pO1xuICpcbiAqICAgICBuZXdTY2hlbWEucGF0aCgnbmFtZScpOyAvLyBTY2hlbWFTdHJpbmcgeyAuLi4gfVxuICogICAgIG5ld1NjaGVtYS5wYXRoKCdhZ2UnKTsgLy8gdW5kZWZpbmVkXG4gKlxuICogQHBhcmFtIHtTdHJpbmdbXX0gcGF0aHMgTGlzdCBvZiBQYXRocyB0byBvbWl0IGZvciB0aGUgbmV3IFNjaGVtYVxuICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSBPcHRpb25zIHRvIHBhc3MgdG8gdGhlIG5ldyBTY2hlbWEgQ29uc3RydWN0b3IgKHNhbWUgYXMgYG5ldyBTY2hlbWEoLi4sIE9wdGlvbnMpYCkuIERlZmF1bHRzIHRvIGB0aGlzLm9wdGlvbnNgIGlmIG5vdCBzZXQuXG4gKiBAcmV0dXJuIHtTY2hlbWF9XG4gKiBAYXBpIHB1YmxpY1xuICovXG5cblNjaGVtYS5wcm90b3R5cGUub21pdCA9IGZ1bmN0aW9uKHBhdGhzLCBvcHRpb25zKSB7XG4gIGNvbnN0IG5ld1NjaGVtYSA9IG5ldyBTY2hlbWEodGhpcywgb3B0aW9ucyB8fCB0aGlzLm9wdGlvbnMpO1xuICBpZiAoIUFycmF5LmlzQXJyYXkocGF0aHMpKSB7XG4gICAgdGhyb3cgbmV3IE1vbmdvb3NlRXJyb3IoXG4gICAgICAnU2NoZW1hI29taXQoKSBvbmx5IGFjY2VwdHMgYW4gYXJyYXkgYXJndW1lbnQsICcgK1xuICAgICAgICAnZ290IFwiJyArXG4gICAgICAgIHR5cGVvZiBwYXRocyArXG4gICAgICAgICdcIidcbiAgICApO1xuICB9XG5cbiAgbmV3U2NoZW1hLnJlbW92ZShwYXRocyk7XG5cbiAgZm9yIChjb25zdCBuZXN0ZWQgaW4gbmV3U2NoZW1hLnNpbmdsZU5lc3RlZFBhdGhzKSB7XG4gICAgaWYgKHBhdGhzLmluY2x1ZGVzKG5lc3RlZCkpIHtcbiAgICAgIGRlbGV0ZSBuZXdTY2hlbWEuc2luZ2xlTmVzdGVkUGF0aHNbbmVzdGVkXTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gbmV3U2NoZW1hO1xufTtcblxuLyoqXG4gKiBSZXR1cm5zIGRlZmF1bHQgb3B0aW9ucyBmb3IgdGhpcyBzY2hlbWEsIG1lcmdlZCB3aXRoIGBvcHRpb25zYC5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdIE9wdGlvbnMgdG8gb3ZlcndyaXRlIHRoZSBkZWZhdWx0IG9wdGlvbnNcbiAqIEByZXR1cm4ge09iamVjdH0gVGhlIG1lcmdlZCBvcHRpb25zIG9mIGBvcHRpb25zYCBhbmQgdGhlIGRlZmF1bHQgb3B0aW9uc1xuICogQGFwaSBwcml2YXRlXG4gKi9cblxuU2NoZW1hLnByb3RvdHlwZS5kZWZhdWx0T3B0aW9ucyA9IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgdGhpcy5fdXNlclByb3ZpZGVkT3B0aW9ucyA9IG9wdGlvbnMgPT0gbnVsbCA/IHt9IDogY2xvbmUob3B0aW9ucyk7XG4gIGNvbnN0IGJhc2VPcHRpb25zID0gdGhpcy5iYXNlICYmIHRoaXMuYmFzZS5vcHRpb25zIHx8IHt9O1xuICBjb25zdCBzdHJpY3QgPSAnc3RyaWN0JyBpbiBiYXNlT3B0aW9ucyA/IGJhc2VPcHRpb25zLnN0cmljdCA6IHRydWU7XG4gIGNvbnN0IHN0cmljdFF1ZXJ5ID0gJ3N0cmljdFF1ZXJ5JyBpbiBiYXNlT3B0aW9ucyA/IGJhc2VPcHRpb25zLnN0cmljdFF1ZXJ5IDogZmFsc2U7XG4gIGNvbnN0IGlkID0gJ2lkJyBpbiBiYXNlT3B0aW9ucyA/IGJhc2VPcHRpb25zLmlkIDogdHJ1ZTtcbiAgb3B0aW9ucyA9IHV0aWxzLm9wdGlvbnMoe1xuICAgIHN0cmljdCxcbiAgICBzdHJpY3RRdWVyeSxcbiAgICBidWZmZXJDb21tYW5kczogdHJ1ZSxcbiAgICBjYXBwZWQ6IGZhbHNlLCAvLyB7IHNpemUsIG1heCwgYXV0b0luZGV4SWQgfVxuICAgIHZlcnNpb25LZXk6ICdfX3YnLFxuICAgIG9wdGltaXN0aWNDb25jdXJyZW5jeTogZmFsc2UsXG4gICAgbWluaW1pemU6IHRydWUsXG4gICAgYXV0b0luZGV4OiBudWxsLFxuICAgIGRpc2NyaW1pbmF0b3JLZXk6ICdfX3QnLFxuICAgIHNoYXJkS2V5OiBudWxsLFxuICAgIHJlYWQ6IG51bGwsXG4gICAgdmFsaWRhdGVCZWZvcmVTYXZlOiB0cnVlLFxuICAgIHZhbGlkYXRlTW9kaWZpZWRPbmx5OiBmYWxzZSxcbiAgICAvLyB0aGUgZm9sbG93aW5nIGFyZSBvbmx5IGFwcGxpZWQgYXQgY29uc3RydWN0aW9uIHRpbWVcbiAgICBfaWQ6IHRydWUsXG4gICAgaWQ6IGlkLFxuICAgIHR5cGVLZXk6ICd0eXBlJ1xuICB9LCBjbG9uZShvcHRpb25zKSk7XG5cbiAgaWYgKG9wdGlvbnMudmVyc2lvbktleSAmJiB0eXBlb2Ygb3B0aW9ucy52ZXJzaW9uS2V5ICE9PSAnc3RyaW5nJykge1xuICAgIHRocm93IG5ldyBNb25nb29zZUVycm9yKCdgdmVyc2lvbktleWAgbXVzdCBiZSBmYWxzeSBvciBzdHJpbmcsIGdvdCBgJyArICh0eXBlb2Ygb3B0aW9ucy52ZXJzaW9uS2V5KSArICdgJyk7XG4gIH1cblxuICBpZiAodHlwZW9mIG9wdGlvbnMucmVhZCA9PT0gJ3N0cmluZycpIHtcbiAgICBvcHRpb25zLnJlYWQgPSBoYW5kbGVSZWFkUHJlZmVyZW5jZUFsaWFzZXMob3B0aW9ucy5yZWFkKTtcbiAgfSBlbHNlIGlmIChBcnJheS5pc0FycmF5KG9wdGlvbnMucmVhZCkgJiYgdHlwZW9mIG9wdGlvbnMucmVhZFswXSA9PT0gJ3N0cmluZycpIHtcbiAgICBvcHRpb25zLnJlYWQgPSB7XG4gICAgICBtb2RlOiBoYW5kbGVSZWFkUHJlZmVyZW5jZUFsaWFzZXMob3B0aW9ucy5yZWFkWzBdKSxcbiAgICAgIHRhZ3M6IG9wdGlvbnMucmVhZFsxXVxuICAgIH07XG4gIH1cblxuICBpZiAob3B0aW9ucy5vcHRpbWlzdGljQ29uY3VycmVuY3kgJiYgIW9wdGlvbnMudmVyc2lvbktleSkge1xuICAgIHRocm93IG5ldyBNb25nb29zZUVycm9yKCdNdXN0IHNldCBgdmVyc2lvbktleWAgaWYgdXNpbmcgYG9wdGltaXN0aWNDb25jdXJyZW5jeWAnKTtcbiAgfVxuXG4gIHJldHVybiBvcHRpb25zO1xufTtcblxuLyoqXG4gKiBJbmhlcml0IGEgU2NoZW1hIGJ5IGFwcGx5aW5nIGEgZGlzY3JpbWluYXRvciBvbiBhbiBleGlzdGluZyBTY2hlbWEuXG4gKlxuICpcbiAqICMjIyMgRXhhbXBsZTpcbiAqXG4gKiAgICAgY29uc3QgZXZlbnRTY2hlbWEgPSBuZXcgbW9uZ29vc2UuU2NoZW1hKHsgdGltZXN0YW1wOiBEYXRlIH0sIHsgZGlzY3JpbWluYXRvcktleTogJ2tpbmQnIH0pO1xuICpcbiAqICAgICBjb25zdCBjbGlja2VkRXZlbnRTY2hlbWEgPSBuZXcgbW9uZ29vc2UuU2NoZW1hKHsgZWxlbWVudDogU3RyaW5nIH0sIHsgZGlzY3JpbWluYXRvcktleTogJ2tpbmQnIH0pO1xuICogICAgIGNvbnN0IENsaWNrZWRNb2RlbCA9IGV2ZW50U2NoZW1hLmRpc2NyaW1pbmF0b3IoJ2NsaWNrZWQnLCBjbGlja2VkRXZlbnRTY2hlbWEpO1xuICpcbiAqICAgICBjb25zdCBFdmVudCA9IG1vbmdvb3NlLm1vZGVsKCdFdmVudCcsIGV2ZW50U2NoZW1hKTtcbiAqXG4gKiAgICAgRXZlbnQuZGlzY3JpbWluYXRvcnNbJ2NsaWNrZWQnXTsgLy8gTW9kZWwgeyBjbGlja2VkIH1cbiAqXG4gKiAgICAgY29uc3QgZG9jID0gYXdhaXQgRXZlbnQuY3JlYXRlKHsga2luZDogJ2NsaWNrZWQnLCBlbGVtZW50OiAnI2hlcm8nIH0pO1xuICogICAgIGRvYy5lbGVtZW50OyAvLyAnI2hlcm8nXG4gKiAgICAgZG9jIGluc3RhbmNlb2YgQ2xpY2tlZE1vZGVsOyAvLyB0cnVlXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IG5hbWUgdGhlIG5hbWUgb2YgdGhlIGRpc2NyaW1pbmF0b3JcbiAqIEBwYXJhbSB7U2NoZW1hfSBzY2hlbWEgdGhlIGRpc2NyaW1pbmF0ZWQgU2NoZW1hXG4gKiBAcmV0dXJuIHtTY2hlbWF9IHRoZSBTY2hlbWEgaW5zdGFuY2VcbiAqIEBhcGkgcHVibGljXG4gKi9cblNjaGVtYS5wcm90b3R5cGUuZGlzY3JpbWluYXRvciA9IGZ1bmN0aW9uKG5hbWUsIHNjaGVtYSkge1xuICB0aGlzLl9hcHBseURpc2NyaW1pbmF0b3JzID0gdGhpcy5fYXBwbHlEaXNjcmltaW5hdG9ycyB8fCBuZXcgTWFwKCk7XG4gIHRoaXMuX2FwcGx5RGlzY3JpbWluYXRvcnMuc2V0KG5hbWUsIHNjaGVtYSk7XG5cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIEFkZHMga2V5IHBhdGggLyBzY2hlbWEgdHlwZSBwYWlycyB0byB0aGlzIHNjaGVtYS5cbiAqXG4gKiAjIyMjIEV4YW1wbGU6XG4gKlxuICogICAgIGNvbnN0IFRveVNjaGVtYSA9IG5ldyBTY2hlbWEoKTtcbiAqICAgICBUb3lTY2hlbWEuYWRkKHsgbmFtZTogJ3N0cmluZycsIGNvbG9yOiAnc3RyaW5nJywgcHJpY2U6ICdudW1iZXInIH0pO1xuICpcbiAqICAgICBjb25zdCBUdXJib01hblNjaGVtYSA9IG5ldyBTY2hlbWEoKTtcbiAqICAgICAvLyBZb3UgY2FuIGFsc28gYGFkZCgpYCBhbm90aGVyIHNjaGVtYSBhbmQgY29weSBvdmVyIGFsbCBwYXRocywgdmlydHVhbHMsXG4gKiAgICAgLy8gZ2V0dGVycywgc2V0dGVycywgaW5kZXhlcywgbWV0aG9kcywgYW5kIHN0YXRpY3MuXG4gKiAgICAgVHVyYm9NYW5TY2hlbWEuYWRkKFRveVNjaGVtYSkuYWRkKHsgeWVhcjogTnVtYmVyIH0pO1xuICpcbiAqIEBwYXJhbSB7T2JqZWN0fFNjaGVtYX0gb2JqIHBsYWluIG9iamVjdCB3aXRoIHBhdGhzIHRvIGFkZCwgb3IgYW5vdGhlciBzY2hlbWFcbiAqIEBwYXJhbSB7U3RyaW5nfSBbcHJlZml4XSBwYXRoIHRvIHByZWZpeCB0aGUgbmV3bHkgYWRkZWQgcGF0aHMgd2l0aFxuICogQHJldHVybiB7U2NoZW1hfSB0aGUgU2NoZW1hIGluc3RhbmNlXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cblNjaGVtYS5wcm90b3R5cGUuYWRkID0gZnVuY3Rpb24gYWRkKG9iaiwgcHJlZml4KSB7XG4gIGlmIChvYmogaW5zdGFuY2VvZiBTY2hlbWEgfHwgKG9iaiAhPSBudWxsICYmIG9iai5pbnN0YW5jZU9mU2NoZW1hKSkge1xuICAgIG1lcmdlKHRoaXMsIG9iaik7XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIC8vIFNwZWNpYWwgY2FzZTogc2V0dGluZyB0b3AtbGV2ZWwgYF9pZGAgdG8gZmFsc2Ugc2hvdWxkIGNvbnZlcnQgdG8gZGlzYWJsaW5nXG4gIC8vIHRoZSBgX2lkYCBvcHRpb24uIFRoaXMgYmVoYXZpb3IgbmV2ZXIgd29ya2VkIGJlZm9yZSA1LjQuMTEgYnV0IG51bWVyb3VzXG4gIC8vIGNvZGViYXNlcyB1c2UgaXQgKHNlZSBnaC03NTE2LCBnaC03NTEyKS5cbiAgaWYgKG9iai5faWQgPT09IGZhbHNlICYmIHByZWZpeCA9PSBudWxsKSB7XG4gICAgdGhpcy5vcHRpb25zLl9pZCA9IGZhbHNlO1xuICB9XG5cbiAgcHJlZml4ID0gcHJlZml4IHx8ICcnO1xuICAvLyBhdm9pZCBwcm90b3R5cGUgcG9sbHV0aW9uXG4gIGlmIChwcmVmaXggPT09ICdfX3Byb3RvX18uJyB8fCBwcmVmaXggPT09ICdjb25zdHJ1Y3Rvci4nIHx8IHByZWZpeCA9PT0gJ3Byb3RvdHlwZS4nKSB7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICBjb25zdCBrZXlzID0gT2JqZWN0LmtleXMob2JqKTtcbiAgY29uc3QgdHlwZUtleSA9IHRoaXMub3B0aW9ucy50eXBlS2V5O1xuICBmb3IgKGNvbnN0IGtleSBvZiBrZXlzKSB7XG4gICAgaWYgKHV0aWxzLnNwZWNpYWxQcm9wZXJ0aWVzLmhhcyhrZXkpKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICBjb25zdCBmdWxsUGF0aCA9IHByZWZpeCArIGtleTtcbiAgICBjb25zdCB2YWwgPSBvYmpba2V5XTtcblxuICAgIGlmICh2YWwgPT0gbnVsbCkge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignSW52YWxpZCB2YWx1ZSBmb3Igc2NoZW1hIHBhdGggYCcgKyBmdWxsUGF0aCArXG4gICAgICAgICdgLCBnb3QgdmFsdWUgXCInICsgdmFsICsgJ1wiJyk7XG4gICAgfVxuICAgIC8vIFJldGFpbiBgX2lkOiBmYWxzZWAgYnV0IGRvbid0IHNldCBpdCBhcyBhIHBhdGgsIHJlOiBnaC04Mjc0LlxuICAgIGlmIChrZXkgPT09ICdfaWQnICYmIHZhbCA9PT0gZmFsc2UpIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICAvLyBEZXByZWNhdGUgc2V0dGluZyBzY2hlbWEgcGF0aHMgdG8gcHJpbWl0aXZlIHR5cGVzIChnaC03NTU4KVxuICAgIGxldCBpc01vbmdvb3NlVHlwZVN0cmluZyA9IGZhbHNlO1xuICAgIGlmICh0eXBlb2YgdmFsID09PSAnc3RyaW5nJykge1xuICAgICAgLy8gSGFuZGxlIHRoZSBjYXNlIGluIHdoaWNoIHRoZSB0eXBlIGlzIHNwZWNpZmllZCBhcyBhIHN0cmluZyAoZWcuICdkYXRlJywgJ29pZCcsIC4uLilcbiAgICAgIGNvbnN0IE1vbmdvb3NlVHlwZXMgPSB0aGlzLmJhc2UgIT0gbnVsbCA/IHRoaXMuYmFzZS5TY2hlbWEuVHlwZXMgOiBTY2hlbWEuVHlwZXM7XG4gICAgICBjb25zdCB1cHBlclZhbCA9IHZhbC5jaGFyQXQoMCkudG9VcHBlckNhc2UoKSArIHZhbC5zdWJzdHJpbmcoMSk7XG4gICAgICBpc01vbmdvb3NlVHlwZVN0cmluZyA9IE1vbmdvb3NlVHlwZXNbdXBwZXJWYWxdICE9IG51bGw7XG4gICAgfVxuICAgIGlmIChcbiAgICAgIGtleSAhPT0gJ19pZCcgJiZcbiAgICAgICgodHlwZW9mIHZhbCAhPT0gJ29iamVjdCcgJiYgdHlwZW9mIHZhbCAhPT0gJ2Z1bmN0aW9uJyAmJiAhaXNNb25nb29zZVR5cGVTdHJpbmcpIHx8XG4gICAgICB2YWwgPT0gbnVsbClcbiAgICApIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYEludmFsaWQgc2NoZW1hIGNvbmZpZ3VyYXRpb246IFxcYCR7dmFsfVxcYCBpcyBub3QgYCArXG4gICAgICAgIGBhIHZhbGlkIHR5cGUgYXQgcGF0aCBcXGAke2tleX1cXGAuIFNlZSBgICtcbiAgICAgICAgJ2h0dHBzOi8vYml0Lmx5L21vbmdvb3NlLXNjaGVtYXR5cGVzIGZvciBhIGxpc3Qgb2YgdmFsaWQgc2NoZW1hIHR5cGVzLicpO1xuICAgIH1cbiAgICBpZiAodmFsIGluc3RhbmNlb2YgVmlydHVhbFR5cGUgfHwgKHZhbC5jb25zdHJ1Y3RvciAmJiB2YWwuY29uc3RydWN0b3IubmFtZSB8fCBudWxsKSA9PT0gJ1ZpcnR1YWxUeXBlJykge1xuICAgICAgdGhpcy52aXJ0dWFsKHZhbCk7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICBpZiAoQXJyYXkuaXNBcnJheSh2YWwpICYmIHZhbC5sZW5ndGggPT09IDEgJiYgdmFsWzBdID09IG51bGwpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0ludmFsaWQgdmFsdWUgZm9yIHNjaGVtYSBBcnJheSBwYXRoIGAnICsgZnVsbFBhdGggK1xuICAgICAgICAnYCwgZ290IHZhbHVlIFwiJyArIHZhbFswXSArICdcIicpO1xuICAgIH1cblxuICAgIGlmICghKGlzUE9KTyh2YWwpIHx8IHZhbCBpbnN0YW5jZW9mIFNjaGVtYVR5cGVPcHRpb25zKSkge1xuICAgICAgLy8gU3BlY2lhbC1jYXNlOiBOb24tb3B0aW9ucyBkZWZpbml0ZWx5IGEgcGF0aCBzbyBsZWFmIGF0IHRoaXMgbm9kZVxuICAgICAgLy8gRXhhbXBsZXM6IFNjaGVtYSBpbnN0YW5jZXMsIFNjaGVtYVR5cGUgaW5zdGFuY2VzXG4gICAgICBpZiAocHJlZml4KSB7XG4gICAgICAgIHRoaXMubmVzdGVkW3ByZWZpeC5zdWJzdHJpbmcoMCwgcHJlZml4Lmxlbmd0aCAtIDEpXSA9IHRydWU7XG4gICAgICB9XG4gICAgICB0aGlzLnBhdGgocHJlZml4ICsga2V5LCB2YWwpO1xuICAgICAgaWYgKHZhbFswXSAhPSBudWxsICYmICEodmFsWzBdLmluc3RhbmNlT2ZTY2hlbWEpICYmIHV0aWxzLmlzUE9KTyh2YWxbMF0uZGlzY3JpbWluYXRvcnMpKSB7XG4gICAgICAgIGNvbnN0IHNjaGVtYVR5cGUgPSB0aGlzLnBhdGgocHJlZml4ICsga2V5KTtcbiAgICAgICAgZm9yIChjb25zdCBrZXkgaW4gdmFsWzBdLmRpc2NyaW1pbmF0b3JzKSB7XG4gICAgICAgICAgc2NoZW1hVHlwZS5kaXNjcmltaW5hdG9yKGtleSwgdmFsWzBdLmRpc2NyaW1pbmF0b3JzW2tleV0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChPYmplY3Qua2V5cyh2YWwpLmxlbmd0aCA8IDEpIHtcbiAgICAgIC8vIFNwZWNpYWwtY2FzZToge30gYWx3YXlzIGludGVycHJldGVkIGFzIE1peGVkIHBhdGggc28gbGVhZiBhdCB0aGlzIG5vZGVcbiAgICAgIGlmIChwcmVmaXgpIHtcbiAgICAgICAgdGhpcy5uZXN0ZWRbcHJlZml4LnN1YnN0cmluZygwLCBwcmVmaXgubGVuZ3RoIC0gMSldID0gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIHRoaXMucGF0aChmdWxsUGF0aCwgdmFsKTsgLy8gbWl4ZWQgdHlwZVxuICAgIH0gZWxzZSBpZiAoIXZhbFt0eXBlS2V5XSB8fCAodHlwZUtleSA9PT0gJ3R5cGUnICYmIGlzUE9KTyh2YWwudHlwZSkgJiYgdmFsLnR5cGUudHlwZSkpIHtcbiAgICAgIC8vIFNwZWNpYWwtY2FzZTogUE9KTyB3aXRoIG5vIGJvbmEtZmlkZSB0eXBlIGtleSAtIGludGVycHJldCBhcyB0cmVlIG9mIGRlZXAgcGF0aHMgc28gcmVjdXJzZVxuICAgICAgLy8gbmVzdGVkIG9iamVjdCBgeyBsYXN0OiB7IG5hbWU6IFN0cmluZyB9IH1gLiBBdm9pZCBmdW5jdGlvbnMgd2l0aCBgLnR5cGVgIHJlOiAjMTA4MDcgYmVjYXVzZVxuICAgICAgLy8gTmVzdEpTIHNvbWV0aW1lcyBhZGRzIGBEYXRlLnR5cGVgLlxuICAgICAgdGhpcy5uZXN0ZWRbZnVsbFBhdGhdID0gdHJ1ZTtcbiAgICAgIHRoaXMuYWRkKHZhbCwgZnVsbFBhdGggKyAnLicpO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBUaGVyZSBJUyBhIGJvbmEtZmlkZSB0eXBlIGtleSB0aGF0IG1heSBhbHNvIGJlIGEgUE9KT1xuICAgICAgY29uc3QgX3R5cGVEZWYgPSB2YWxbdHlwZUtleV07XG4gICAgICBpZiAoaXNQT0pPKF90eXBlRGVmKSAmJiBPYmplY3Qua2V5cyhfdHlwZURlZikubGVuZ3RoID4gMCkge1xuICAgICAgICAvLyBJZiBhIFBPSk8gaXMgdGhlIHZhbHVlIG9mIGEgdHlwZSBrZXksIG1ha2UgaXQgYSBzdWJkb2N1bWVudFxuICAgICAgICBpZiAocHJlZml4KSB7XG4gICAgICAgICAgdGhpcy5uZXN0ZWRbcHJlZml4LnN1YnN0cmluZygwLCBwcmVmaXgubGVuZ3RoIC0gMSldID0gdHJ1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IGNoaWxkU2NoZW1hT3B0aW9ucyA9IHt9O1xuICAgICAgICBpZiAodGhpcy5fdXNlclByb3ZpZGVkT3B0aW9ucy50eXBlS2V5KSB7XG4gICAgICAgICAgY2hpbGRTY2hlbWFPcHRpb25zLnR5cGVLZXkgPSB0aGlzLl91c2VyUHJvdmlkZWRPcHRpb25zLnR5cGVLZXk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gcHJvcGFnYXRlICdzdHJpY3QnIG9wdGlvbiB0byBjaGlsZCBzY2hlbWFcbiAgICAgICAgaWYgKHRoaXMuX3VzZXJQcm92aWRlZE9wdGlvbnMuc3RyaWN0ICE9IG51bGwpIHtcbiAgICAgICAgICBjaGlsZFNjaGVtYU9wdGlvbnMuc3RyaWN0ID0gdGhpcy5fdXNlclByb3ZpZGVkT3B0aW9ucy5zdHJpY3Q7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuX3VzZXJQcm92aWRlZE9wdGlvbnMudG9PYmplY3QgIT0gbnVsbCkge1xuICAgICAgICAgIGNoaWxkU2NoZW1hT3B0aW9ucy50b09iamVjdCA9IHV0aWxzLm9taXQodGhpcy5fdXNlclByb3ZpZGVkT3B0aW9ucy50b09iamVjdCwgWyd0cmFuc2Zvcm0nXSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuX3VzZXJQcm92aWRlZE9wdGlvbnMudG9KU09OICE9IG51bGwpIHtcbiAgICAgICAgICBjaGlsZFNjaGVtYU9wdGlvbnMudG9KU09OID0gdXRpbHMub21pdCh0aGlzLl91c2VyUHJvdmlkZWRPcHRpb25zLnRvSlNPTiwgWyd0cmFuc2Zvcm0nXSk7XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBfc2NoZW1hID0gbmV3IFNjaGVtYShfdHlwZURlZiwgY2hpbGRTY2hlbWFPcHRpb25zKTtcbiAgICAgICAgX3NjaGVtYS4kaW1wbGljaXRseUNyZWF0ZWQgPSB0cnVlO1xuICAgICAgICBjb25zdCBzY2hlbWFXcmFwcGVkUGF0aCA9IE9iamVjdC5hc3NpZ24oe30sIHZhbCwgeyBbdHlwZUtleV06IF9zY2hlbWEgfSk7XG4gICAgICAgIHRoaXMucGF0aChwcmVmaXggKyBrZXksIHNjaGVtYVdyYXBwZWRQYXRoKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIEVpdGhlciB0aGUgdHlwZSBpcyBub24tUE9KTyBvciB3ZSBpbnRlcnByZXQgaXQgYXMgTWl4ZWQgYW55d2F5XG4gICAgICAgIGlmIChwcmVmaXgpIHtcbiAgICAgICAgICB0aGlzLm5lc3RlZFtwcmVmaXguc3Vic3RyaW5nKDAsIHByZWZpeC5sZW5ndGggLSAxKV0gPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMucGF0aChwcmVmaXggKyBrZXksIHZhbCk7XG4gICAgICAgIGlmICh2YWwgIT0gbnVsbCAmJiAhKHZhbC5pbnN0YW5jZU9mU2NoZW1hKSAmJiB1dGlscy5pc1BPSk8odmFsLmRpc2NyaW1pbmF0b3JzKSkge1xuICAgICAgICAgIGNvbnN0IHNjaGVtYVR5cGUgPSB0aGlzLnBhdGgocHJlZml4ICsga2V5KTtcbiAgICAgICAgICBmb3IgKGNvbnN0IGtleSBpbiB2YWwuZGlzY3JpbWluYXRvcnMpIHtcbiAgICAgICAgICAgIHNjaGVtYVR5cGUuZGlzY3JpbWluYXRvcihrZXksIHZhbC5kaXNjcmltaW5hdG9yc1trZXldKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBjb25zdCBhbGlhc09iaiA9IE9iamVjdC5mcm9tRW50cmllcyhcbiAgICBPYmplY3QuZW50cmllcyhvYmopLm1hcCgoW2tleV0pID0+IChbcHJlZml4ICsga2V5LCBudWxsXSkpXG4gICk7XG4gIGFsaWFzRmllbGRzKHRoaXMsIGFsaWFzT2JqKTtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIEFkZCBhbiBhbGlhcyBmb3IgYHBhdGhgLiBUaGlzIG1lYW5zIGdldHRpbmcgb3Igc2V0dGluZyB0aGUgYGFsaWFzYFxuICogaXMgZXF1aXZhbGVudCB0byBnZXR0aW5nIG9yIHNldHRpbmcgdGhlIGBwYXRoYC5cbiAqXG4gKiAjIyMjIEV4YW1wbGU6XG4gKlxuICogICAgIGNvbnN0IHRveVNjaGVtYSA9IG5ldyBTY2hlbWEoeyBuOiBTdHJpbmcgfSk7XG4gKlxuICogICAgIC8vIE1ha2UgJ25hbWUnIGFuIGFsaWFzIGZvciAnbidcbiAqICAgICB0b3lTY2hlbWEuYWxpYXMoJ24nLCAnbmFtZScpO1xuICpcbiAqICAgICBjb25zdCBUb3kgPSBtb25nb29zZS5tb2RlbCgnVG95JywgdG95U2NoZW1hKTtcbiAqICAgICBjb25zdCB0dXJib01hbiA9IG5ldyBUb3koeyBuOiAnVHVyYm8gTWFuJyB9KTtcbiAqXG4gKiAgICAgdHVyYm9NYW4ubmFtZTsgLy8gJ1R1cmJvIE1hbidcbiAqICAgICB0dXJib01hbi5uOyAvLyAnVHVyYm8gTWFuJ1xuICpcbiAqICAgICB0dXJib01hbi5uYW1lID0gJ1R1cmJvIE1hbiBBY3Rpb24gRmlndXJlJztcbiAqICAgICB0dXJib01hbi5uOyAvLyAnVHVyYm8gTWFuIEFjdGlvbiBGaWd1cmUnXG4gKlxuICogICAgIGF3YWl0IHR1cmJvTWFuLnNhdmUoKTsgLy8gU2F2ZXMgeyBfaWQ6IC4uLiwgbjogJ1R1cmJvIE1hbiBBY3Rpb24gRmlndXJlJyB9XG4gKlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBwYXRoIHJlYWwgcGF0aCB0byBhbGlhc1xuICogQHBhcmFtIHtTdHJpbmd8U3RyaW5nW119IGFsaWFzIHRoZSBwYXRoKHMpIHRvIHVzZSBhcyBhbiBhbGlhcyBmb3IgYHBhdGhgXG4gKiBAcmV0dXJuIHtTY2hlbWF9IHRoZSBTY2hlbWEgaW5zdGFuY2VcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuU2NoZW1hLnByb3RvdHlwZS5hbGlhcyA9IGZ1bmN0aW9uIGFsaWFzKHBhdGgsIGFsaWFzKSB7XG4gIGFsaWFzRmllbGRzKHRoaXMsIHsgW3BhdGhdOiBhbGlhcyB9KTtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIFJlbW92ZSBhbiBpbmRleCBieSBuYW1lIG9yIGluZGV4IHNwZWNpZmljYXRpb24uXG4gKlxuICogcmVtb3ZlSW5kZXggb25seSByZW1vdmVzIGluZGV4ZXMgZnJvbSB5b3VyIHNjaGVtYSBvYmplY3QuIERvZXMgKipub3QqKiBhZmZlY3QgdGhlIGluZGV4ZXNcbiAqIGluIE1vbmdvREIuXG4gKlxuICogIyMjIyBFeGFtcGxlOlxuICpcbiAqICAgICBjb25zdCBUb3lTY2hlbWEgPSBuZXcgU2NoZW1hKHsgbmFtZTogU3RyaW5nLCBjb2xvcjogU3RyaW5nLCBwcmljZTogTnVtYmVyIH0pO1xuICpcbiAqICAgICAvLyBBZGQgYSBuZXcgaW5kZXggb24geyBuYW1lLCBjb2xvciB9XG4gKiAgICAgVG95U2NoZW1hLmluZGV4KHsgbmFtZTogMSwgY29sb3I6IDEgfSk7XG4gKlxuICogICAgIC8vIFJlbW92ZSBpbmRleCBvbiB7IG5hbWUsIGNvbG9yIH1cbiAqICAgICAvLyBLZWVwIGluIG1pbmQgdGhhdCBvcmRlciBtYXR0ZXJzISBgcmVtb3ZlSW5kZXgoeyBjb2xvcjogMSwgbmFtZTogMSB9KWAgd29uJ3QgcmVtb3ZlIHRoZSBpbmRleFxuICogICAgIFRveVNjaGVtYS5yZW1vdmVJbmRleCh7IG5hbWU6IDEsIGNvbG9yOiAxIH0pO1xuICpcbiAqICAgICAvLyBBZGQgYW4gaW5kZXggd2l0aCBhIGN1c3RvbSBuYW1lXG4gKiAgICAgVG95U2NoZW1hLmluZGV4KHsgY29sb3I6IDEgfSwgeyBuYW1lOiAnbXkgY3VzdG9tIGluZGV4IG5hbWUnIH0pO1xuICogICAgIC8vIFJlbW92ZSBpbmRleCBieSBuYW1lXG4gKiAgICAgVG95U2NoZW1hLnJlbW92ZUluZGV4KCdteSBjdXN0b20gaW5kZXggbmFtZScpO1xuICpcbiAqIEBwYXJhbSB7T2JqZWN0fHN0cmluZ30gaW5kZXggbmFtZSBvciBpbmRleCBzcGVjaWZpY2F0aW9uXG4gKiBAcmV0dXJuIHtTY2hlbWF9IHRoZSBTY2hlbWEgaW5zdGFuY2VcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuU2NoZW1hLnByb3RvdHlwZS5yZW1vdmVJbmRleCA9IGZ1bmN0aW9uIHJlbW92ZUluZGV4KGluZGV4KSB7XG4gIGlmIChhcmd1bWVudHMubGVuZ3RoID4gMSkge1xuICAgIHRocm93IG5ldyBFcnJvcigncmVtb3ZlSW5kZXgoKSB0YWtlcyBvbmx5IDEgYXJndW1lbnQnKTtcbiAgfVxuXG4gIGlmICh0eXBlb2YgaW5kZXggIT09ICdvYmplY3QnICYmIHR5cGVvZiBpbmRleCAhPT0gJ3N0cmluZycpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3JlbW92ZUluZGV4KCkgbWF5IG9ubHkgdGFrZSBlaXRoZXIgYW4gb2JqZWN0IG9yIGEgc3RyaW5nIGFzIGFuIGFyZ3VtZW50Jyk7XG4gIH1cblxuICBpZiAodHlwZW9mIGluZGV4ID09PSAnb2JqZWN0Jykge1xuICAgIGZvciAobGV0IGkgPSB0aGlzLl9pbmRleGVzLmxlbmd0aCAtIDE7IGkgPj0gMDsgLS1pKSB7XG4gICAgICBpZiAodXRpbC5pc0RlZXBTdHJpY3RFcXVhbCh0aGlzLl9pbmRleGVzW2ldWzBdLCBpbmRleCkpIHtcbiAgICAgICAgdGhpcy5faW5kZXhlcy5zcGxpY2UoaSwgMSk7XG4gICAgICB9XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGZvciAobGV0IGkgPSB0aGlzLl9pbmRleGVzLmxlbmd0aCAtIDE7IGkgPj0gMDsgLS1pKSB7XG4gICAgICBpZiAodGhpcy5faW5kZXhlc1tpXVsxXSAhPSBudWxsICYmIHRoaXMuX2luZGV4ZXNbaV1bMV0ubmFtZSA9PT0gaW5kZXgpIHtcbiAgICAgICAgdGhpcy5faW5kZXhlcy5zcGxpY2UoaSwgMSk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIFJlbW92ZSBhbGwgaW5kZXhlcyBmcm9tIHRoaXMgc2NoZW1hLlxuICpcbiAqIGNsZWFySW5kZXhlcyBvbmx5IHJlbW92ZXMgaW5kZXhlcyBmcm9tIHlvdXIgc2NoZW1hIG9iamVjdC4gRG9lcyAqKm5vdCoqIGFmZmVjdCB0aGUgaW5kZXhlc1xuICogaW4gTW9uZ29EQi5cbiAqXG4gKiAjIyMjIEV4YW1wbGU6XG4gKlxuICogICAgIGNvbnN0IFRveVNjaGVtYSA9IG5ldyBTY2hlbWEoeyBuYW1lOiBTdHJpbmcsIGNvbG9yOiBTdHJpbmcsIHByaWNlOiBOdW1iZXIgfSk7XG4gKiAgICAgVG95U2NoZW1hLmluZGV4KHsgbmFtZTogMSB9KTtcbiAqICAgICBUb3lTY2hlbWEuaW5kZXgoeyBjb2xvcjogMSB9KTtcbiAqXG4gKiAgICAgLy8gUmVtb3ZlIGFsbCBpbmRleGVzIG9uIHRoaXMgc2NoZW1hXG4gKiAgICAgVG95U2NoZW1hLmNsZWFySW5kZXhlcygpO1xuICpcbiAqICAgICBUb3lTY2hlbWEuaW5kZXhlcygpOyAvLyBbXVxuICpcbiAqIEByZXR1cm4ge1NjaGVtYX0gdGhlIFNjaGVtYSBpbnN0YW5jZVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5TY2hlbWEucHJvdG90eXBlLmNsZWFySW5kZXhlcyA9IGZ1bmN0aW9uIGNsZWFySW5kZXhlcygpIHtcbiAgdGhpcy5faW5kZXhlcy5sZW5ndGggPSAwO1xuXG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBSZXNlcnZlZCBkb2N1bWVudCBrZXlzLlxuICpcbiAqIEtleXMgaW4gdGhpcyBvYmplY3QgYXJlIG5hbWVzIHRoYXQgYXJlIHdhcm5lZCBpbiBzY2hlbWEgZGVjbGFyYXRpb25zXG4gKiBiZWNhdXNlIHRoZXkgaGF2ZSB0aGUgcG90ZW50aWFsIHRvIGJyZWFrIE1vbmdvb3NlLyBNb25nb29zZSBwbHVnaW5zIGZ1bmN0aW9uYWxpdHkuIElmIHlvdSBjcmVhdGUgYSBzY2hlbWFcbiAqIHVzaW5nIGBuZXcgU2NoZW1hKClgIHdpdGggb25lIG9mIHRoZXNlIHByb3BlcnR5IG5hbWVzLCBNb25nb29zZSB3aWxsIGxvZyBhIHdhcm5pbmcuXG4gKlxuICogLSBfcG9zdHNcbiAqIC0gX3ByZXNcbiAqIC0gY29sbGVjdGlvblxuICAqIC0gZW1pdFxuICogLSBlcnJvcnNcbiAqIC0gZ2V0XG4gKiAtIGluaXRcbiAqIC0gaXNNb2RpZmllZFxuICogLSBpc05ld1xuICogLSBsaXN0ZW5lcnNcbiAqIC0gbW9kZWxOYW1lXG4gKiAtIG9uXG4gKiAtIG9uY2VcbiAqIC0gcG9wdWxhdGVkXG4gKiAtIHByb3RvdHlwZVxuICogLSByZW1vdmVcbiAqIC0gcmVtb3ZlTGlzdGVuZXJcbiAqIC0gc2F2ZVxuICogLSBzY2hlbWFcbiAqIC0gdG9PYmplY3RcbiAqIC0gdmFsaWRhdGVcbiAqXG4gKiBfTk9URTpfIFVzZSBvZiB0aGVzZSB0ZXJtcyBhcyBtZXRob2QgbmFtZXMgaXMgcGVybWl0dGVkLCBidXQgcGxheSBhdCB5b3VyIG93biByaXNrLCBhcyB0aGV5IG1heSBiZSBleGlzdGluZyBtb25nb29zZSBkb2N1bWVudCBtZXRob2RzIHlvdSBhcmUgc3RvbXBpbmcgb24uXG4gKlxuICogICAgICBjb25zdCBzY2hlbWEgPSBuZXcgU2NoZW1hKC4uKTtcbiAqICAgICAgc2NoZW1hLm1ldGhvZHMuaW5pdCA9IGZ1bmN0aW9uICgpIHt9IC8vIHBvdGVudGlhbGx5IGJyZWFraW5nXG4gKlxuICogQHByb3BlcnR5IHJlc2VydmVkXG4gKiBAbWVtYmVyT2YgU2NoZW1hXG4gKiBAc3RhdGljXG4gKi9cblxuU2NoZW1hLnJlc2VydmVkID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcblNjaGVtYS5wcm90b3R5cGUucmVzZXJ2ZWQgPSBTY2hlbWEucmVzZXJ2ZWQ7XG5cbmNvbnN0IHJlc2VydmVkID0gU2NoZW1hLnJlc2VydmVkO1xuLy8gQ29yZSBvYmplY3RcbnJlc2VydmVkWydwcm90b3R5cGUnXSA9XG4vLyBFdmVudEVtaXR0ZXJcbnJlc2VydmVkLmVtaXQgPVxucmVzZXJ2ZWQubGlzdGVuZXJzID1cbnJlc2VydmVkLnJlbW92ZUxpc3RlbmVyID1cblxuLy8gZG9jdW1lbnQgcHJvcGVydGllcyBhbmQgZnVuY3Rpb25zXG5yZXNlcnZlZC5jb2xsZWN0aW9uID1cbnJlc2VydmVkLmVycm9ycyA9XG5yZXNlcnZlZC5nZXQgPVxucmVzZXJ2ZWQuaW5pdCA9XG5yZXNlcnZlZC5pc01vZGlmaWVkID1cbnJlc2VydmVkLmlzTmV3ID1cbnJlc2VydmVkLnBvcHVsYXRlZCA9XG5yZXNlcnZlZC5yZW1vdmUgPVxucmVzZXJ2ZWQuc2F2ZSA9XG5yZXNlcnZlZC50b09iamVjdCA9XG5yZXNlcnZlZC52YWxpZGF0ZSA9IDE7XG5yZXNlcnZlZC5jb2xsZWN0aW9uID0gMTtcblxuLyoqXG4gKiBHZXRzL3NldHMgc2NoZW1hIHBhdGhzLlxuICpcbiAqIFNldHMgYSBwYXRoIChpZiBhcml0eSAyKVxuICogR2V0cyBhIHBhdGggKGlmIGFyaXR5IDEpXG4gKlxuICogIyMjIyBFeGFtcGxlOlxuICpcbiAqICAgICBzY2hlbWEucGF0aCgnbmFtZScpIC8vIHJldHVybnMgYSBTY2hlbWFUeXBlXG4gKiAgICAgc2NoZW1hLnBhdGgoJ25hbWUnLCBOdW1iZXIpIC8vIGNoYW5nZXMgdGhlIHNjaGVtYVR5cGUgb2YgYG5hbWVgIHRvIE51bWJlclxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBwYXRoIFRoZSBuYW1lIG9mIHRoZSBQYXRoIHRvIGdldCAvIHNldFxuICogQHBhcmFtIHtPYmplY3R9IFtvYmpdIFRoZSBUeXBlIHRvIHNldCB0aGUgcGF0aCB0bywgaWYgcHJvdmlkZWQgdGhlIHBhdGggd2lsbCBiZSBTRVQsIG90aGVyd2lzZSB0aGUgcGF0aCB3aWxsIGJlIEdFVFxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5TY2hlbWEucHJvdG90eXBlLnBhdGggPSBmdW5jdGlvbihwYXRoLCBvYmopIHtcbiAgaWYgKG9iaiA9PT0gdW5kZWZpbmVkKSB7XG4gICAgLy8gQ29udmVydCB0byAnLiQnIHRvIGNoZWNrIHN1YnBhdGhzIHJlOiBnaC02NDA1XG4gICAgY29uc3QgY2xlYW5QYXRoID0gX3BhdGhUb1Bvc2l0aW9uYWxTeW50YXgocGF0aCk7XG4gICAgbGV0IHNjaGVtYXR5cGUgPSBfZ2V0UGF0aCh0aGlzLCBwYXRoLCBjbGVhblBhdGgpO1xuICAgIGlmIChzY2hlbWF0eXBlICE9IG51bGwpIHtcbiAgICAgIHJldHVybiBzY2hlbWF0eXBlO1xuICAgIH1cblxuICAgIC8vIExvb2sgZm9yIG1hcHNcbiAgICBjb25zdCBtYXBQYXRoID0gZ2V0TWFwUGF0aCh0aGlzLCBwYXRoKTtcbiAgICBpZiAobWFwUGF0aCAhPSBudWxsKSB7XG4gICAgICByZXR1cm4gbWFwUGF0aDtcbiAgICB9XG5cbiAgICAvLyBMb29rIGlmIGEgcGFyZW50IG9mIHRoaXMgcGF0aCBpcyBtaXhlZFxuICAgIHNjaGVtYXR5cGUgPSB0aGlzLmhhc01peGVkUGFyZW50KGNsZWFuUGF0aCk7XG4gICAgaWYgKHNjaGVtYXR5cGUgIT0gbnVsbCkge1xuICAgICAgcmV0dXJuIHNjaGVtYXR5cGU7XG4gICAgfVxuXG4gICAgLy8gc3VicGF0aHM/XG4gICAgcmV0dXJuIC9cXC5cXGQrXFwuPy4qJC8udGVzdChwYXRoKVxuICAgICAgPyBnZXRQb3NpdGlvbmFsUGF0aCh0aGlzLCBwYXRoLCBjbGVhblBhdGgpXG4gICAgICA6IHVuZGVmaW5lZDtcbiAgfVxuXG4gIC8vIHNvbWUgcGF0aCBuYW1lcyBjb25mbGljdCB3aXRoIGRvY3VtZW50IG1ldGhvZHNcbiAgY29uc3QgZmlyc3RQaWVjZU9mUGF0aCA9IHBhdGguc3BsaXQoJy4nKVswXTtcbiAgaWYgKHJlc2VydmVkW2ZpcnN0UGllY2VPZlBhdGhdICYmICF0aGlzLm9wdGlvbnMuc3VwcHJlc3NSZXNlcnZlZEtleXNXYXJuaW5nKSB7XG4gICAgY29uc3QgZXJyb3JNZXNzYWdlID0gYFxcYCR7Zmlyc3RQaWVjZU9mUGF0aH1cXGAgaXMgYSByZXNlcnZlZCBzY2hlbWEgcGF0aG5hbWUgYW5kIG1heSBicmVhayBzb21lIGZ1bmN0aW9uYWxpdHkuIGAgK1xuICAgICAgJ1lvdSBhcmUgYWxsb3dlZCB0byB1c2UgaXQsIGJ1dCB1c2UgYXQgeW91ciBvd24gcmlzay4gJyArXG4gICAgICAnVG8gZGlzYWJsZSB0aGlzIHdhcm5pbmcgcGFzcyBgc3VwcHJlc3NSZXNlcnZlZEtleXNXYXJuaW5nYCBhcyBhIHNjaGVtYSBvcHRpb24uJztcblxuICAgIHV0aWxzLndhcm4oZXJyb3JNZXNzYWdlKTtcbiAgfVxuXG4gIGlmICh0eXBlb2Ygb2JqID09PSAnb2JqZWN0JyAmJiB1dGlscy5oYXNVc2VyRGVmaW5lZFByb3BlcnR5KG9iaiwgJ3JlZicpKSB7XG4gICAgdmFsaWRhdGVSZWYob2JqLnJlZiwgcGF0aCk7XG4gIH1cblxuICAvLyB1cGRhdGUgdGhlIHRyZWVcbiAgY29uc3Qgc3VicGF0aHMgPSBwYXRoLnNwbGl0KC9cXC4vKTtcbiAgY29uc3QgbGFzdCA9IHN1YnBhdGhzLnBvcCgpO1xuICBsZXQgYnJhbmNoID0gdGhpcy50cmVlO1xuICBsZXQgZnVsbFBhdGggPSAnJztcblxuICBmb3IgKGNvbnN0IHN1YiBvZiBzdWJwYXRocykge1xuICAgIGlmICh1dGlscy5zcGVjaWFsUHJvcGVydGllcy5oYXMoc3ViKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdDYW5ub3Qgc2V0IHNwZWNpYWwgcHJvcGVydHkgYCcgKyBzdWIgKyAnYCBvbiBhIHNjaGVtYScpO1xuICAgIH1cbiAgICBmdWxsUGF0aCA9IGZ1bGxQYXRoICs9IChmdWxsUGF0aC5sZW5ndGggPiAwID8gJy4nIDogJycpICsgc3ViO1xuICAgIGlmICghYnJhbmNoW3N1Yl0pIHtcbiAgICAgIHRoaXMubmVzdGVkW2Z1bGxQYXRoXSA9IHRydWU7XG4gICAgICBicmFuY2hbc3ViXSA9IHt9O1xuICAgIH1cbiAgICBpZiAodHlwZW9mIGJyYW5jaFtzdWJdICE9PSAnb2JqZWN0Jykge1xuICAgICAgY29uc3QgbXNnID0gJ0Nhbm5vdCBzZXQgbmVzdGVkIHBhdGggYCcgKyBwYXRoICsgJ2AuICdcbiAgICAgICAgICArICdQYXJlbnQgcGF0aCBgJ1xuICAgICAgICAgICsgZnVsbFBhdGhcbiAgICAgICAgICArICdgIGFscmVhZHkgc2V0IHRvIHR5cGUgJyArIGJyYW5jaFtzdWJdLm5hbWVcbiAgICAgICAgICArICcuJztcbiAgICAgIHRocm93IG5ldyBFcnJvcihtc2cpO1xuICAgIH1cbiAgICBicmFuY2ggPSBicmFuY2hbc3ViXTtcbiAgfVxuXG4gIGJyYW5jaFtsYXN0XSA9IGNsb25lKG9iaik7XG5cbiAgdGhpcy5wYXRoc1twYXRoXSA9IHRoaXMuaW50ZXJwcmV0QXNUeXBlKHBhdGgsIG9iaiwgdGhpcy5vcHRpb25zKTtcbiAgY29uc3Qgc2NoZW1hVHlwZSA9IHRoaXMucGF0aHNbcGF0aF07XG5cbiAgaWYgKHNjaGVtYVR5cGUuJGlzU2NoZW1hTWFwKSB7XG4gICAgLy8gTWFwcyBjYW4gaGF2ZSBhcmJpdHJhcnkga2V5cywgc28gYCQqYCBpcyBpbnRlcm5hbCBzaG9ydGhhbmQgZm9yIFwiYW55IGtleVwiXG4gICAgLy8gVGhlICckJyBpcyB0byBpbXBseSB0aGlzIHBhdGggc2hvdWxkIG5ldmVyIGJlIHN0b3JlZCBpbiBNb25nb0RCIHNvIHdlXG4gICAgLy8gY2FuIGVhc2lseSBidWlsZCBhIHJlZ2V4cCBvdXQgb2YgdGhpcyBwYXRoLCBhbmQgJyonIHRvIGltcGx5IFwiYW55IGtleS5cIlxuICAgIGNvbnN0IG1hcFBhdGggPSBwYXRoICsgJy4kKic7XG5cbiAgICB0aGlzLnBhdGhzW21hcFBhdGhdID0gc2NoZW1hVHlwZS4kX19zY2hlbWFUeXBlO1xuICAgIHRoaXMubWFwUGF0aHMucHVzaCh0aGlzLnBhdGhzW21hcFBhdGhdKTtcbiAgfVxuXG4gIGlmIChzY2hlbWFUeXBlLiRpc1NpbmdsZU5lc3RlZCkge1xuICAgIGZvciAoY29uc3Qga2V5IG9mIE9iamVjdC5rZXlzKHNjaGVtYVR5cGUuc2NoZW1hLnBhdGhzKSkge1xuICAgICAgdGhpcy5zaW5nbGVOZXN0ZWRQYXRoc1twYXRoICsgJy4nICsga2V5XSA9IHNjaGVtYVR5cGUuc2NoZW1hLnBhdGhzW2tleV07XG4gICAgfVxuICAgIGZvciAoY29uc3Qga2V5IG9mIE9iamVjdC5rZXlzKHNjaGVtYVR5cGUuc2NoZW1hLnNpbmdsZU5lc3RlZFBhdGhzKSkge1xuICAgICAgdGhpcy5zaW5nbGVOZXN0ZWRQYXRoc1twYXRoICsgJy4nICsga2V5XSA9XG4gICAgICAgIHNjaGVtYVR5cGUuc2NoZW1hLnNpbmdsZU5lc3RlZFBhdGhzW2tleV07XG4gICAgfVxuICAgIGZvciAoY29uc3Qga2V5IG9mIE9iamVjdC5rZXlzKHNjaGVtYVR5cGUuc2NoZW1hLnN1YnBhdGhzKSkge1xuICAgICAgdGhpcy5zaW5nbGVOZXN0ZWRQYXRoc1twYXRoICsgJy4nICsga2V5XSA9XG4gICAgICAgIHNjaGVtYVR5cGUuc2NoZW1hLnN1YnBhdGhzW2tleV07XG4gICAgfVxuICAgIGZvciAoY29uc3Qga2V5IG9mIE9iamVjdC5rZXlzKHNjaGVtYVR5cGUuc2NoZW1hLm5lc3RlZCkpIHtcbiAgICAgIHRoaXMuc2luZ2xlTmVzdGVkUGF0aHNbcGF0aCArICcuJyArIGtleV0gPSAnbmVzdGVkJztcbiAgICB9XG5cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoc2NoZW1hVHlwZS5zY2hlbWEsICdiYXNlJywge1xuICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICB3cml0YWJsZTogZmFsc2UsXG4gICAgICB2YWx1ZTogdGhpcy5iYXNlXG4gICAgfSk7XG5cbiAgICBzY2hlbWFUeXBlLmNhc3Rlci5iYXNlID0gdGhpcy5iYXNlO1xuICAgIHRoaXMuY2hpbGRTY2hlbWFzLnB1c2goe1xuICAgICAgc2NoZW1hOiBzY2hlbWFUeXBlLnNjaGVtYSxcbiAgICAgIG1vZGVsOiBzY2hlbWFUeXBlLmNhc3RlclxuICAgIH0pO1xuICB9IGVsc2UgaWYgKHNjaGVtYVR5cGUuJGlzTW9uZ29vc2VEb2N1bWVudEFycmF5KSB7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHNjaGVtYVR5cGUuc2NoZW1hLCAnYmFzZScsIHtcbiAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgd3JpdGFibGU6IGZhbHNlLFxuICAgICAgdmFsdWU6IHRoaXMuYmFzZVxuICAgIH0pO1xuXG4gICAgc2NoZW1hVHlwZS5jYXN0ZXJDb25zdHJ1Y3Rvci5iYXNlID0gdGhpcy5iYXNlO1xuICAgIHRoaXMuY2hpbGRTY2hlbWFzLnB1c2goe1xuICAgICAgc2NoZW1hOiBzY2hlbWFUeXBlLnNjaGVtYSxcbiAgICAgIG1vZGVsOiBzY2hlbWFUeXBlLmNhc3RlckNvbnN0cnVjdG9yXG4gICAgfSk7XG4gIH1cblxuICBpZiAoc2NoZW1hVHlwZS4kaXNNb25nb29zZUFycmF5ICYmIHNjaGVtYVR5cGUuY2FzdGVyIGluc3RhbmNlb2YgU2NoZW1hVHlwZSkge1xuICAgIGxldCBhcnJheVBhdGggPSBwYXRoO1xuICAgIGxldCBfc2NoZW1hVHlwZSA9IHNjaGVtYVR5cGU7XG5cbiAgICBjb25zdCB0b0FkZCA9IFtdO1xuICAgIHdoaWxlIChfc2NoZW1hVHlwZS4kaXNNb25nb29zZUFycmF5KSB7XG4gICAgICBhcnJheVBhdGggPSBhcnJheVBhdGggKyAnLiQnO1xuXG4gICAgICAvLyBTa2lwIGFycmF5cyBvZiBkb2N1bWVudCBhcnJheXNcbiAgICAgIGlmIChfc2NoZW1hVHlwZS4kaXNNb25nb29zZURvY3VtZW50QXJyYXkpIHtcbiAgICAgICAgX3NjaGVtYVR5cGUuJGVtYmVkZGVkU2NoZW1hVHlwZS5fYXJyYXlQYXRoID0gYXJyYXlQYXRoO1xuICAgICAgICBfc2NoZW1hVHlwZS4kZW1iZWRkZWRTY2hlbWFUeXBlLl9hcnJheVBhcmVudFBhdGggPSBwYXRoO1xuICAgICAgICBfc2NoZW1hVHlwZSA9IF9zY2hlbWFUeXBlLiRlbWJlZGRlZFNjaGVtYVR5cGUuY2xvbmUoKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIF9zY2hlbWFUeXBlLmNhc3Rlci5fYXJyYXlQYXRoID0gYXJyYXlQYXRoO1xuICAgICAgICBfc2NoZW1hVHlwZS5jYXN0ZXIuX2FycmF5UGFyZW50UGF0aCA9IHBhdGg7XG4gICAgICAgIF9zY2hlbWFUeXBlID0gX3NjaGVtYVR5cGUuY2FzdGVyLmNsb25lKCk7XG4gICAgICB9XG5cbiAgICAgIF9zY2hlbWFUeXBlLnBhdGggPSBhcnJheVBhdGg7XG4gICAgICB0b0FkZC5wdXNoKF9zY2hlbWFUeXBlKTtcbiAgICB9XG5cbiAgICBmb3IgKGNvbnN0IF9zY2hlbWFUeXBlIG9mIHRvQWRkKSB7XG4gICAgICB0aGlzLnN1YnBhdGhzW19zY2hlbWFUeXBlLnBhdGhdID0gX3NjaGVtYVR5cGU7XG4gICAgfVxuICB9XG5cbiAgaWYgKHNjaGVtYVR5cGUuJGlzTW9uZ29vc2VEb2N1bWVudEFycmF5KSB7XG4gICAgZm9yIChjb25zdCBrZXkgb2YgT2JqZWN0LmtleXMoc2NoZW1hVHlwZS5zY2hlbWEucGF0aHMpKSB7XG4gICAgICBjb25zdCBfc2NoZW1hVHlwZSA9IHNjaGVtYVR5cGUuc2NoZW1hLnBhdGhzW2tleV07XG4gICAgICB0aGlzLnN1YnBhdGhzW3BhdGggKyAnLicgKyBrZXldID0gX3NjaGVtYVR5cGU7XG4gICAgICBpZiAodHlwZW9mIF9zY2hlbWFUeXBlID09PSAnb2JqZWN0JyAmJiBfc2NoZW1hVHlwZSAhPSBudWxsICYmIF9zY2hlbWFUeXBlLiRwYXJlbnRTY2hlbWFEb2NBcnJheSA9PSBudWxsKSB7XG4gICAgICAgIF9zY2hlbWFUeXBlLiRwYXJlbnRTY2hlbWFEb2NBcnJheSA9IHNjaGVtYVR5cGU7XG4gICAgICB9XG4gICAgfVxuICAgIGZvciAoY29uc3Qga2V5IG9mIE9iamVjdC5rZXlzKHNjaGVtYVR5cGUuc2NoZW1hLnN1YnBhdGhzKSkge1xuICAgICAgY29uc3QgX3NjaGVtYVR5cGUgPSBzY2hlbWFUeXBlLnNjaGVtYS5zdWJwYXRoc1trZXldO1xuICAgICAgdGhpcy5zdWJwYXRoc1twYXRoICsgJy4nICsga2V5XSA9IF9zY2hlbWFUeXBlO1xuICAgICAgaWYgKHR5cGVvZiBfc2NoZW1hVHlwZSA9PT0gJ29iamVjdCcgJiYgX3NjaGVtYVR5cGUgIT0gbnVsbCAmJiBfc2NoZW1hVHlwZS4kcGFyZW50U2NoZW1hRG9jQXJyYXkgPT0gbnVsbCkge1xuICAgICAgICBfc2NoZW1hVHlwZS4kcGFyZW50U2NoZW1hRG9jQXJyYXkgPSBzY2hlbWFUeXBlO1xuICAgICAgfVxuICAgIH1cbiAgICBmb3IgKGNvbnN0IGtleSBvZiBPYmplY3Qua2V5cyhzY2hlbWFUeXBlLnNjaGVtYS5zaW5nbGVOZXN0ZWRQYXRocykpIHtcbiAgICAgIGNvbnN0IF9zY2hlbWFUeXBlID0gc2NoZW1hVHlwZS5zY2hlbWEuc2luZ2xlTmVzdGVkUGF0aHNba2V5XTtcbiAgICAgIHRoaXMuc3VicGF0aHNbcGF0aCArICcuJyArIGtleV0gPSBfc2NoZW1hVHlwZTtcbiAgICAgIGlmICh0eXBlb2YgX3NjaGVtYVR5cGUgPT09ICdvYmplY3QnICYmIF9zY2hlbWFUeXBlICE9IG51bGwgJiYgX3NjaGVtYVR5cGUuJHBhcmVudFNjaGVtYURvY0FycmF5ID09IG51bGwpIHtcbiAgICAgICAgX3NjaGVtYVR5cGUuJHBhcmVudFNjaGVtYURvY0FycmF5ID0gc2NoZW1hVHlwZTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gdGhpcztcbn07XG5cbi8qIVxuICogaWdub3JlXG4gKi9cblxuZnVuY3Rpb24gZ2F0aGVyQ2hpbGRTY2hlbWFzKHNjaGVtYSkge1xuICBjb25zdCBjaGlsZFNjaGVtYXMgPSBbXTtcblxuICBmb3IgKGNvbnN0IHBhdGggb2YgT2JqZWN0LmtleXMoc2NoZW1hLnBhdGhzKSkge1xuICAgIGNvbnN0IHNjaGVtYXR5cGUgPSBzY2hlbWEucGF0aHNbcGF0aF07XG4gICAgaWYgKHNjaGVtYXR5cGUuJGlzTW9uZ29vc2VEb2N1bWVudEFycmF5IHx8IHNjaGVtYXR5cGUuJGlzU2luZ2xlTmVzdGVkKSB7XG4gICAgICBjaGlsZFNjaGVtYXMucHVzaCh7IHNjaGVtYTogc2NoZW1hdHlwZS5zY2hlbWEsIG1vZGVsOiBzY2hlbWF0eXBlLmNhc3RlciB9KTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gY2hpbGRTY2hlbWFzO1xufVxuXG4vKiFcbiAqIGlnbm9yZVxuICovXG5cbmZ1bmN0aW9uIF9nZXRQYXRoKHNjaGVtYSwgcGF0aCwgY2xlYW5QYXRoKSB7XG4gIGlmIChzY2hlbWEucGF0aHMuaGFzT3duUHJvcGVydHkocGF0aCkpIHtcbiAgICByZXR1cm4gc2NoZW1hLnBhdGhzW3BhdGhdO1xuICB9XG4gIGlmIChzY2hlbWEuc3VicGF0aHMuaGFzT3duUHJvcGVydHkoY2xlYW5QYXRoKSkge1xuICAgIHJldHVybiBzY2hlbWEuc3VicGF0aHNbY2xlYW5QYXRoXTtcbiAgfVxuICBpZiAoc2NoZW1hLnNpbmdsZU5lc3RlZFBhdGhzLmhhc093blByb3BlcnR5KGNsZWFuUGF0aCkgJiYgdHlwZW9mIHNjaGVtYS5zaW5nbGVOZXN0ZWRQYXRoc1tjbGVhblBhdGhdID09PSAnb2JqZWN0Jykge1xuICAgIHJldHVybiBzY2hlbWEuc2luZ2xlTmVzdGVkUGF0aHNbY2xlYW5QYXRoXTtcbiAgfVxuXG4gIHJldHVybiBudWxsO1xufVxuXG4vKiFcbiAqIGlnbm9yZVxuICovXG5cbmZ1bmN0aW9uIF9wYXRoVG9Qb3NpdGlvbmFsU3ludGF4KHBhdGgpIHtcbiAgaWYgKCEvXFwuXFxkKy8udGVzdChwYXRoKSkge1xuICAgIHJldHVybiBwYXRoO1xuICB9XG4gIHJldHVybiBwYXRoLnJlcGxhY2UoL1xcLlxcZCtcXC4vZywgJy4kLicpLnJlcGxhY2UoL1xcLlxcZCskLywgJy4kJyk7XG59XG5cbi8qIVxuICogaWdub3JlXG4gKi9cblxuZnVuY3Rpb24gZ2V0TWFwUGF0aChzY2hlbWEsIHBhdGgpIHtcbiAgaWYgKHNjaGVtYS5tYXBQYXRocy5sZW5ndGggPT09IDApIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICBmb3IgKGNvbnN0IHZhbCBvZiBzY2hlbWEubWFwUGF0aHMpIHtcbiAgICBjb25zdCBfcGF0aCA9IHZhbC5wYXRoO1xuICAgIGNvbnN0IHJlID0gbmV3IFJlZ0V4cCgnXicgKyBfcGF0aC5yZXBsYWNlKC9cXC5cXCRcXCovZywgJ1xcXFwuW14uXSsnKSArICckJyk7XG4gICAgaWYgKHJlLnRlc3QocGF0aCkpIHtcbiAgICAgIHJldHVybiBzY2hlbWEucGF0aHNbX3BhdGhdO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBudWxsO1xufVxuXG4vKipcbiAqIFRoZSBNb25nb29zZSBpbnN0YW5jZSB0aGlzIHNjaGVtYSBpcyBhc3NvY2lhdGVkIHdpdGhcbiAqXG4gKiBAcHJvcGVydHkgYmFzZVxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KFNjaGVtYS5wcm90b3R5cGUsICdiYXNlJywge1xuICBjb25maWd1cmFibGU6IHRydWUsXG4gIGVudW1lcmFibGU6IGZhbHNlLFxuICB3cml0YWJsZTogdHJ1ZSxcbiAgdmFsdWU6IG51bGxcbn0pO1xuXG4vKipcbiAqIENvbnZlcnRzIHR5cGUgYXJndW1lbnRzIGludG8gTW9uZ29vc2UgVHlwZXMuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IHBhdGhcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmogY29uc3RydWN0b3JcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5TY2hlbWEucHJvdG90eXBlLmludGVycHJldEFzVHlwZSA9IGZ1bmN0aW9uKHBhdGgsIG9iaiwgb3B0aW9ucykge1xuICBpZiAob2JqIGluc3RhbmNlb2YgU2NoZW1hVHlwZSkge1xuICAgIGlmIChvYmoucGF0aCA9PT0gcGF0aCkge1xuICAgICAgcmV0dXJuIG9iajtcbiAgICB9XG4gICAgY29uc3QgY2xvbmUgPSBvYmouY2xvbmUoKTtcbiAgICBjbG9uZS5wYXRoID0gcGF0aDtcbiAgICByZXR1cm4gY2xvbmU7XG4gIH1cblxuICAvLyBJZiB0aGlzIHNjaGVtYSBoYXMgYW4gYXNzb2NpYXRlZCBNb25nb29zZSBvYmplY3QsIHVzZSB0aGUgTW9uZ29vc2Ugb2JqZWN0J3NcbiAgLy8gY29weSBvZiBTY2hlbWFUeXBlcyByZTogZ2gtNzE1OCBnaC02OTMzXG4gIGNvbnN0IE1vbmdvb3NlVHlwZXMgPSB0aGlzLmJhc2UgIT0gbnVsbCA/IHRoaXMuYmFzZS5TY2hlbWEuVHlwZXMgOiBTY2hlbWEuVHlwZXM7XG4gIGNvbnN0IFR5cGVzID0gdGhpcy5iYXNlICE9IG51bGwgPyB0aGlzLmJhc2UuVHlwZXMgOiByZXF1aXJlKCcuL3R5cGVzJyk7XG5cbiAgaWYgKCF1dGlscy5pc1BPSk8ob2JqKSAmJiAhKG9iaiBpbnN0YW5jZW9mIFNjaGVtYVR5cGVPcHRpb25zKSkge1xuICAgIGNvbnN0IGNvbnN0cnVjdG9yTmFtZSA9IHV0aWxzLmdldEZ1bmN0aW9uTmFtZShvYmouY29uc3RydWN0b3IpO1xuICAgIGlmIChjb25zdHJ1Y3Rvck5hbWUgIT09ICdPYmplY3QnKSB7XG4gICAgICBjb25zdCBvbGRPYmogPSBvYmo7XG4gICAgICBvYmogPSB7fTtcbiAgICAgIG9ialtvcHRpb25zLnR5cGVLZXldID0gb2xkT2JqO1xuICAgIH1cbiAgfVxuXG4gIC8vIEdldCB0aGUgdHlwZSBtYWtpbmcgc3VyZSB0byBhbGxvdyBrZXlzIG5hbWVkIFwidHlwZVwiXG4gIC8vIGFuZCBkZWZhdWx0IHRvIG1peGVkIGlmIG5vdCBzcGVjaWZpZWQuXG4gIC8vIHsgdHlwZTogeyB0eXBlOiBTdHJpbmcsIGRlZmF1bHQ6ICdmcmVzaGN1dCcgfSB9XG4gIGxldCB0eXBlID0gb2JqW29wdGlvbnMudHlwZUtleV0gJiYgKG9ialtvcHRpb25zLnR5cGVLZXldIGluc3RhbmNlb2YgRnVuY3Rpb24gfHwgb3B0aW9ucy50eXBlS2V5ICE9PSAndHlwZScgfHwgIW9iai50eXBlLnR5cGUpXG4gICAgPyBvYmpbb3B0aW9ucy50eXBlS2V5XVxuICAgIDoge307XG4gIGxldCBuYW1lO1xuXG4gIGlmICh1dGlscy5pc1BPSk8odHlwZSkgfHwgdHlwZSA9PT0gJ21peGVkJykge1xuICAgIHJldHVybiBuZXcgTW9uZ29vc2VUeXBlcy5NaXhlZChwYXRoLCBvYmopO1xuICB9XG5cbiAgaWYgKEFycmF5LmlzQXJyYXkodHlwZSkgfHwgdHlwZSA9PT0gQXJyYXkgfHwgdHlwZSA9PT0gJ2FycmF5JyB8fCB0eXBlID09PSBNb25nb29zZVR5cGVzLkFycmF5KSB7XG4gICAgLy8gaWYgaXQgd2FzIHNwZWNpZmllZCB0aHJvdWdoIHsgdHlwZSB9IGxvb2sgZm9yIGBjYXN0YFxuICAgIGxldCBjYXN0ID0gKHR5cGUgPT09IEFycmF5IHx8IHR5cGUgPT09ICdhcnJheScpXG4gICAgICA/IG9iai5jYXN0IHx8IG9iai5vZlxuICAgICAgOiB0eXBlWzBdO1xuXG4gICAgLy8gbmV3IFNjaGVtYSh7IHBhdGg6IFtuZXcgU2NoZW1hKHsgLi4uIH0pXSB9KVxuICAgIGlmIChjYXN0ICYmIGNhc3QuaW5zdGFuY2VPZlNjaGVtYSkge1xuICAgICAgaWYgKCEoY2FzdCBpbnN0YW5jZW9mIFNjaGVtYSkpIHtcbiAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5faXNNZXJnaW5nKSB7XG4gICAgICAgICAgY2FzdCA9IG5ldyBTY2hlbWEoY2FzdCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignU2NoZW1hIGZvciBhcnJheSBwYXRoIGAnICsgcGF0aCArXG4gICAgICAgICAgICAnYCBpcyBmcm9tIGEgZGlmZmVyZW50IGNvcHkgb2YgdGhlIE1vbmdvb3NlIG1vZHVsZS4gJyArXG4gICAgICAgICAgICAnUGxlYXNlIG1ha2Ugc3VyZSB5b3VcXCdyZSB1c2luZyB0aGUgc2FtZSB2ZXJzaW9uICcgK1xuICAgICAgICAgICAgJ29mIE1vbmdvb3NlIGV2ZXJ5d2hlcmUgd2l0aCBgbnBtIGxpc3QgbW9uZ29vc2VgLiBJZiB5b3UgYXJlIHN0aWxsICcgK1xuICAgICAgICAgICAgJ2dldHRpbmcgdGhpcyBlcnJvciwgcGxlYXNlIGFkZCBgbmV3IFNjaGVtYSgpYCBhcm91bmQgdGhlIHBhdGg6ICcgK1xuICAgICAgICAgICAgYCR7cGF0aH06IG5ldyBTY2hlbWEoLi4uKWApO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gbmV3IE1vbmdvb3NlVHlwZXMuRG9jdW1lbnRBcnJheShwYXRoLCBjYXN0LCBvYmopO1xuICAgIH1cbiAgICBpZiAoY2FzdCAmJlxuICAgICAgICBjYXN0W29wdGlvbnMudHlwZUtleV0gJiZcbiAgICAgICAgY2FzdFtvcHRpb25zLnR5cGVLZXldLmluc3RhbmNlT2ZTY2hlbWEpIHtcbiAgICAgIGlmICghKGNhc3Rbb3B0aW9ucy50eXBlS2V5XSBpbnN0YW5jZW9mIFNjaGVtYSkpIHtcbiAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5faXNNZXJnaW5nKSB7XG4gICAgICAgICAgY2FzdFtvcHRpb25zLnR5cGVLZXldID0gbmV3IFNjaGVtYShjYXN0W29wdGlvbnMudHlwZUtleV0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1NjaGVtYSBmb3IgYXJyYXkgcGF0aCBgJyArIHBhdGggK1xuICAgICAgICAgICAgJ2AgaXMgZnJvbSBhIGRpZmZlcmVudCBjb3B5IG9mIHRoZSBNb25nb29zZSBtb2R1bGUuICcgK1xuICAgICAgICAgICAgJ1BsZWFzZSBtYWtlIHN1cmUgeW91XFwncmUgdXNpbmcgdGhlIHNhbWUgdmVyc2lvbiAnICtcbiAgICAgICAgICAgICdvZiBNb25nb29zZSBldmVyeXdoZXJlIHdpdGggYG5wbSBsaXN0IG1vbmdvb3NlYC4gSWYgeW91IGFyZSBzdGlsbCAnICtcbiAgICAgICAgICAgICdnZXR0aW5nIHRoaXMgZXJyb3IsIHBsZWFzZSBhZGQgYG5ldyBTY2hlbWEoKWAgYXJvdW5kIHRoZSBwYXRoOiAnICtcbiAgICAgICAgICAgIGAke3BhdGh9OiBuZXcgU2NoZW1hKC4uLilgKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIG5ldyBNb25nb29zZVR5cGVzLkRvY3VtZW50QXJyYXkocGF0aCwgY2FzdFtvcHRpb25zLnR5cGVLZXldLCBvYmosIGNhc3QpO1xuICAgIH1cblxuICAgIGlmIChBcnJheS5pc0FycmF5KGNhc3QpKSB7XG4gICAgICByZXR1cm4gbmV3IE1vbmdvb3NlVHlwZXMuQXJyYXkocGF0aCwgdGhpcy5pbnRlcnByZXRBc1R5cGUocGF0aCwgY2FzdCwgb3B0aW9ucyksIG9iaik7XG4gICAgfVxuXG4gICAgLy8gSGFuZGxlIGJvdGggYG5ldyBTY2hlbWEoeyBhcnI6IFt7IHN1YnBhdGg6IFN0cmluZyB9XSB9KWAgYW5kIGBuZXcgU2NoZW1hKHsgYXJyOiBbeyB0eXBlOiB7IHN1YnBhdGg6IHN0cmluZyB9IH1dIH0pYFxuICAgIGNvbnN0IGNhc3RGcm9tVHlwZUtleSA9IChjYXN0ICE9IG51bGwgJiYgY2FzdFtvcHRpb25zLnR5cGVLZXldICYmIChvcHRpb25zLnR5cGVLZXkgIT09ICd0eXBlJyB8fCAhY2FzdC50eXBlLnR5cGUpKSA/XG4gICAgICBjYXN0W29wdGlvbnMudHlwZUtleV0gOlxuICAgICAgY2FzdDtcbiAgICBpZiAodHlwZW9mIGNhc3QgPT09ICdzdHJpbmcnKSB7XG4gICAgICBjYXN0ID0gTW9uZ29vc2VUeXBlc1tjYXN0LmNoYXJBdCgwKS50b1VwcGVyQ2FzZSgpICsgY2FzdC5zdWJzdHJpbmcoMSldO1xuICAgIH0gZWxzZSBpZiAodXRpbHMuaXNQT0pPKGNhc3RGcm9tVHlwZUtleSkpIHtcbiAgICAgIGlmIChPYmplY3Qua2V5cyhjYXN0RnJvbVR5cGVLZXkpLmxlbmd0aCkge1xuICAgICAgICAvLyBUaGUgYG1pbmltaXplYCBhbmQgYHR5cGVLZXlgIG9wdGlvbnMgcHJvcGFnYXRlIHRvIGNoaWxkIHNjaGVtYXNcbiAgICAgICAgLy8gZGVjbGFyZWQgaW5saW5lLCBsaWtlIGB7IGFycjogW3sgdmFsOiB7ICR0eXBlOiBTdHJpbmcgfSB9XSB9YC5cbiAgICAgICAgLy8gU2VlIGdoLTM1NjBcbiAgICAgICAgY29uc3QgY2hpbGRTY2hlbWFPcHRpb25zID0geyBtaW5pbWl6ZTogb3B0aW9ucy5taW5pbWl6ZSB9O1xuICAgICAgICBpZiAob3B0aW9ucy50eXBlS2V5KSB7XG4gICAgICAgICAgY2hpbGRTY2hlbWFPcHRpb25zLnR5cGVLZXkgPSBvcHRpb25zLnR5cGVLZXk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gcHJvcGFnYXRlICdzdHJpY3QnIG9wdGlvbiB0byBjaGlsZCBzY2hlbWFcbiAgICAgICAgaWYgKG9wdGlvbnMuaGFzT3duUHJvcGVydHkoJ3N0cmljdCcpKSB7XG4gICAgICAgICAgY2hpbGRTY2hlbWFPcHRpb25zLnN0cmljdCA9IG9wdGlvbnMuc3RyaWN0O1xuICAgICAgICB9XG4gICAgICAgIGlmIChvcHRpb25zLmhhc093blByb3BlcnR5KCdzdHJpY3RRdWVyeScpKSB7XG4gICAgICAgICAgY2hpbGRTY2hlbWFPcHRpb25zLnN0cmljdFF1ZXJ5ID0gb3B0aW9ucy5zdHJpY3RRdWVyeTtcbiAgICAgICAgfVxuICAgICAgICBpZiAob3B0aW9ucy5oYXNPd25Qcm9wZXJ0eSgndG9PYmplY3QnKSkge1xuICAgICAgICAgIGNoaWxkU2NoZW1hT3B0aW9ucy50b09iamVjdCA9IHV0aWxzLm9taXQob3B0aW9ucy50b09iamVjdCwgWyd0cmFuc2Zvcm0nXSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG9wdGlvbnMuaGFzT3duUHJvcGVydHkoJ3RvSlNPTicpKSB7XG4gICAgICAgICAgY2hpbGRTY2hlbWFPcHRpb25zLnRvSlNPTiA9IHV0aWxzLm9taXQob3B0aW9ucy50b0pTT04sIFsndHJhbnNmb3JtJ10pO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRoaXMuX3VzZXJQcm92aWRlZE9wdGlvbnMuaGFzT3duUHJvcGVydHkoJ19pZCcpKSB7XG4gICAgICAgICAgY2hpbGRTY2hlbWFPcHRpb25zLl9pZCA9IHRoaXMuX3VzZXJQcm92aWRlZE9wdGlvbnMuX2lkO1xuICAgICAgICB9IGVsc2UgaWYgKFNjaGVtYS5UeXBlcy5Eb2N1bWVudEFycmF5LmRlZmF1bHRPcHRpb25zLl9pZCAhPSBudWxsKSB7XG4gICAgICAgICAgY2hpbGRTY2hlbWFPcHRpb25zLl9pZCA9IFNjaGVtYS5UeXBlcy5Eb2N1bWVudEFycmF5LmRlZmF1bHRPcHRpb25zLl9pZDtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IGNoaWxkU2NoZW1hID0gbmV3IFNjaGVtYShjYXN0RnJvbVR5cGVLZXksIGNoaWxkU2NoZW1hT3B0aW9ucyk7XG4gICAgICAgIGNoaWxkU2NoZW1hLiRpbXBsaWNpdGx5Q3JlYXRlZCA9IHRydWU7XG4gICAgICAgIHJldHVybiBuZXcgTW9uZ29vc2VUeXBlcy5Eb2N1bWVudEFycmF5KHBhdGgsIGNoaWxkU2NoZW1hLCBvYmopO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gU3BlY2lhbCBjYXNlOiBlbXB0eSBvYmplY3QgYmVjb21lcyBtaXhlZFxuICAgICAgICByZXR1cm4gbmV3IE1vbmdvb3NlVHlwZXMuQXJyYXkocGF0aCwgTW9uZ29vc2VUeXBlcy5NaXhlZCwgb2JqKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoY2FzdCkge1xuICAgICAgdHlwZSA9IGNhc3Rbb3B0aW9ucy50eXBlS2V5XSAmJiAob3B0aW9ucy50eXBlS2V5ICE9PSAndHlwZScgfHwgIWNhc3QudHlwZS50eXBlKVxuICAgICAgICA/IGNhc3Rbb3B0aW9ucy50eXBlS2V5XVxuICAgICAgICA6IGNhc3Q7XG5cbiAgICAgIGlmIChBcnJheS5pc0FycmF5KHR5cGUpKSB7XG4gICAgICAgIHJldHVybiBuZXcgTW9uZ29vc2VUeXBlcy5BcnJheShwYXRoLCB0aGlzLmludGVycHJldEFzVHlwZShwYXRoLCB0eXBlLCBvcHRpb25zKSwgb2JqKTtcbiAgICAgIH1cblxuICAgICAgbmFtZSA9IHR5cGVvZiB0eXBlID09PSAnc3RyaW5nJ1xuICAgICAgICA/IHR5cGVcbiAgICAgICAgOiB0eXBlLnNjaGVtYU5hbWUgfHwgdXRpbHMuZ2V0RnVuY3Rpb25OYW1lKHR5cGUpO1xuXG4gICAgICAvLyBGb3IgSmVzdCAyNissIHNlZSAjMTAyOTZcbiAgICAgIGlmIChuYW1lID09PSAnQ2xvY2tEYXRlJykge1xuICAgICAgICBuYW1lID0gJ0RhdGUnO1xuICAgICAgfVxuXG4gICAgICBpZiAobmFtZSA9PT0gdm9pZCAwKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0ludmFsaWQgc2NoZW1hIGNvbmZpZ3VyYXRpb246ICcgK1xuICAgICAgICAgIGBDb3VsZCBub3QgZGV0ZXJtaW5lIHRoZSBlbWJlZGRlZCB0eXBlIGZvciBhcnJheSBcXGAke3BhdGh9XFxgLiBgICtcbiAgICAgICAgICAnU2VlIGh0dHBzOi8vbW9uZ29vc2Vqcy5jb20vZG9jcy9ndWlkZS5odG1sI2RlZmluaXRpb24gZm9yIG1vcmUgaW5mbyBvbiBzdXBwb3J0ZWQgc2NoZW1hIHN5bnRheGVzLicpO1xuICAgICAgfVxuICAgICAgaWYgKCFNb25nb29zZVR5cGVzLmhhc093blByb3BlcnR5KG5hbWUpKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0ludmFsaWQgc2NoZW1hIGNvbmZpZ3VyYXRpb246ICcgK1xuICAgICAgICAgIGBcXGAke25hbWV9XFxgIGlzIG5vdCBhIHZhbGlkIHR5cGUgd2l0aGluIHRoZSBhcnJheSBcXGAke3BhdGh9XFxgLmAgK1xuICAgICAgICAgICdTZWUgaHR0cHM6Ly9iaXQubHkvbW9uZ29vc2Utc2NoZW1hdHlwZXMgZm9yIGEgbGlzdCBvZiB2YWxpZCBzY2hlbWEgdHlwZXMuJyk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIG5ldyBNb25nb29zZVR5cGVzLkFycmF5KHBhdGgsIGNhc3QgfHwgTW9uZ29vc2VUeXBlcy5NaXhlZCwgb2JqLCBvcHRpb25zKTtcbiAgfVxuXG4gIGlmICh0eXBlICYmIHR5cGUuaW5zdGFuY2VPZlNjaGVtYSkge1xuICAgIHJldHVybiBuZXcgTW9uZ29vc2VUeXBlcy5TdWJkb2N1bWVudCh0eXBlLCBwYXRoLCBvYmopO1xuICB9XG5cbiAgaWYgKEJ1ZmZlci5pc0J1ZmZlcih0eXBlKSkge1xuICAgIG5hbWUgPSAnQnVmZmVyJztcbiAgfSBlbHNlIGlmICh0eXBlb2YgdHlwZSA9PT0gJ2Z1bmN0aW9uJyB8fCB0eXBlb2YgdHlwZSA9PT0gJ29iamVjdCcpIHtcbiAgICBuYW1lID0gdHlwZS5zY2hlbWFOYW1lIHx8IHV0aWxzLmdldEZ1bmN0aW9uTmFtZSh0eXBlKTtcbiAgfSBlbHNlIGlmICh0eXBlID09PSBUeXBlcy5PYmplY3RJZCkge1xuICAgIG5hbWUgPSAnT2JqZWN0SWQnO1xuICB9IGVsc2UgaWYgKHR5cGUgPT09IFR5cGVzLkRlY2ltYWwxMjgpIHtcbiAgICBuYW1lID0gJ0RlY2ltYWwxMjgnO1xuICB9IGVsc2Uge1xuICAgIG5hbWUgPSB0eXBlID09IG51bGwgPyAnJyArIHR5cGUgOiB0eXBlLnRvU3RyaW5nKCk7XG4gIH1cblxuICBpZiAobmFtZSkge1xuICAgIG5hbWUgPSBuYW1lLmNoYXJBdCgwKS50b1VwcGVyQ2FzZSgpICsgbmFtZS5zdWJzdHJpbmcoMSk7XG4gIH1cbiAgLy8gU3BlY2lhbCBjYXNlIHJlOiBnaC03MDQ5IGJlY2F1c2UgdGhlIGJzb24gYE9iamVjdElEYCBjbGFzcycgY2FwaXRhbGl6YXRpb25cbiAgLy8gZG9lc24ndCBsaW5lIHVwIHdpdGggTW9uZ29vc2Uncy5cbiAgaWYgKG5hbWUgPT09ICdPYmplY3RJRCcpIHtcbiAgICBuYW1lID0gJ09iamVjdElkJztcbiAgfVxuICAvLyBGb3IgSmVzdCAyNissIHNlZSAjMTAyOTZcbiAgaWYgKG5hbWUgPT09ICdDbG9ja0RhdGUnKSB7XG4gICAgbmFtZSA9ICdEYXRlJztcbiAgfVxuXG4gIGlmIChuYW1lID09PSB2b2lkIDApIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGBJbnZhbGlkIHNjaGVtYSBjb25maWd1cmF0aW9uOiBcXGAke3BhdGh9XFxgIHNjaGVtYXR5cGUgZGVmaW5pdGlvbiBpcyBgICtcbiAgICAgICdpbnZhbGlkLiBTZWUgJyArXG4gICAgICAnaHR0cHM6Ly9tb25nb29zZWpzLmNvbS9kb2NzL2d1aWRlLmh0bWwjZGVmaW5pdGlvbiBmb3IgbW9yZSBpbmZvIG9uIHN1cHBvcnRlZCBzY2hlbWEgc3ludGF4ZXMuJyk7XG4gIH1cbiAgaWYgKE1vbmdvb3NlVHlwZXNbbmFtZV0gPT0gbnVsbCkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYEludmFsaWQgc2NoZW1hIGNvbmZpZ3VyYXRpb246IFxcYCR7bmFtZX1cXGAgaXMgbm90IGAgK1xuICAgICAgYGEgdmFsaWQgdHlwZSBhdCBwYXRoIFxcYCR7cGF0aH1cXGAuIFNlZSBgICtcbiAgICAgICdodHRwczovL2JpdC5seS9tb25nb29zZS1zY2hlbWF0eXBlcyBmb3IgYSBsaXN0IG9mIHZhbGlkIHNjaGVtYSB0eXBlcy4nKTtcbiAgfVxuXG4gIGNvbnN0IHNjaGVtYVR5cGUgPSBuZXcgTW9uZ29vc2VUeXBlc1tuYW1lXShwYXRoLCBvYmopO1xuXG4gIGlmIChzY2hlbWFUeXBlLiRpc1NjaGVtYU1hcCkge1xuICAgIGNyZWF0ZU1hcE5lc3RlZFNjaGVtYVR5cGUodGhpcywgc2NoZW1hVHlwZSwgcGF0aCwgb2JqLCBvcHRpb25zKTtcbiAgfVxuXG4gIHJldHVybiBzY2hlbWFUeXBlO1xufTtcblxuLyohXG4gKiBpZ25vcmVcbiAqL1xuXG5mdW5jdGlvbiBjcmVhdGVNYXBOZXN0ZWRTY2hlbWFUeXBlKHNjaGVtYSwgc2NoZW1hVHlwZSwgcGF0aCwgb2JqLCBvcHRpb25zKSB7XG4gIGNvbnN0IG1hcFBhdGggPSBwYXRoICsgJy4kKic7XG4gIGxldCBfbWFwVHlwZSA9IHsgdHlwZToge30gfTtcbiAgaWYgKHV0aWxzLmhhc1VzZXJEZWZpbmVkUHJvcGVydHkob2JqLCAnb2YnKSkge1xuICAgIGNvbnN0IGlzSW5saW5lU2NoZW1hID0gdXRpbHMuaXNQT0pPKG9iai5vZikgJiZcbiAgICAgIE9iamVjdC5rZXlzKG9iai5vZikubGVuZ3RoID4gMCAmJlxuICAgICAgIXV0aWxzLmhhc1VzZXJEZWZpbmVkUHJvcGVydHkob2JqLm9mLCBzY2hlbWEub3B0aW9ucy50eXBlS2V5KTtcbiAgICBpZiAoaXNJbmxpbmVTY2hlbWEpIHtcbiAgICAgIF9tYXBUeXBlID0geyBbc2NoZW1hLm9wdGlvbnMudHlwZUtleV06IG5ldyBTY2hlbWEob2JqLm9mKSB9O1xuICAgIH0gZWxzZSBpZiAodXRpbHMuaXNQT0pPKG9iai5vZikpIHtcbiAgICAgIF9tYXBUeXBlID0gT2JqZWN0LmFzc2lnbih7fSwgb2JqLm9mKTtcbiAgICB9IGVsc2Uge1xuICAgICAgX21hcFR5cGUgPSB7IFtzY2hlbWEub3B0aW9ucy50eXBlS2V5XTogb2JqLm9mIH07XG4gICAgfVxuXG4gICAgaWYgKF9tYXBUeXBlW3NjaGVtYS5vcHRpb25zLnR5cGVLZXldICYmIF9tYXBUeXBlW3NjaGVtYS5vcHRpb25zLnR5cGVLZXldLmluc3RhbmNlT2ZTY2hlbWEpIHtcbiAgICAgIGNvbnN0IHN1YmRvY3VtZW50U2NoZW1hID0gX21hcFR5cGVbc2NoZW1hLm9wdGlvbnMudHlwZUtleV07XG4gICAgICBzdWJkb2N1bWVudFNjaGVtYS5lYWNoUGF0aCgoc3VicGF0aCwgdHlwZSkgPT4ge1xuICAgICAgICBpZiAodHlwZS5vcHRpb25zLnNlbGVjdCA9PT0gdHJ1ZSB8fCB0eXBlLm9wdGlvbnMuc2VsZWN0ID09PSBmYWxzZSkge1xuICAgICAgICAgIHRocm93IG5ldyBNb25nb29zZUVycm9yKCdDYW5ub3QgdXNlIHNjaGVtYS1sZXZlbCBwcm9qZWN0aW9ucyAoYHNlbGVjdDogdHJ1ZWAgb3IgYHNlbGVjdDogZmFsc2VgKSB3aXRoaW4gbWFwcyBhdCBwYXRoIFwiJyArIHBhdGggKyAnLicgKyBzdWJwYXRoICsgJ1wiJyk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cblxuICAgIGlmICh1dGlscy5oYXNVc2VyRGVmaW5lZFByb3BlcnR5KG9iaiwgJ3JlZicpKSB7XG4gICAgICBfbWFwVHlwZS5yZWYgPSBvYmoucmVmO1xuICAgIH1cbiAgfVxuICBzY2hlbWFUeXBlLiRfX3NjaGVtYVR5cGUgPSBzY2hlbWEuaW50ZXJwcmV0QXNUeXBlKG1hcFBhdGgsIF9tYXBUeXBlLCBvcHRpb25zKTtcbn1cblxuLyoqXG4gKiBJdGVyYXRlcyB0aGUgc2NoZW1hcyBwYXRocyBzaW1pbGFyIHRvIEFycmF5I2ZvckVhY2guXG4gKlxuICogVGhlIGNhbGxiYWNrIGlzIHBhc3NlZCB0aGUgcGF0aG5hbWUgYW5kIHRoZSBzY2hlbWFUeXBlIGluc3RhbmNlLlxuICpcbiAqICMjIyMgRXhhbXBsZTpcbiAqXG4gKiAgICAgY29uc3QgdXNlclNjaGVtYSA9IG5ldyBTY2hlbWEoeyBuYW1lOiBTdHJpbmcsIHJlZ2lzdGVyZWRBdDogRGF0ZSB9KTtcbiAqICAgICB1c2VyU2NoZW1hLmVhY2hQYXRoKChwYXRobmFtZSwgc2NoZW1hdHlwZSkgPT4ge1xuICogICAgICAgLy8gUHJpbnRzIHR3aWNlOlxuICogICAgICAgLy8gbmFtZSBTY2hlbWFTdHJpbmcgeyAuLi4gfVxuICogICAgICAgLy8gcmVnaXN0ZXJlZEF0IFNjaGVtYURhdGUgeyAuLi4gfVxuICogICAgICAgY29uc29sZS5sb2cocGF0aG5hbWUsIHNjaGVtYXR5cGUpO1xuICogICAgIH0pO1xuICpcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuIGNhbGxiYWNrIGZ1bmN0aW9uXG4gKiBAcmV0dXJuIHtTY2hlbWF9IHRoaXNcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuU2NoZW1hLnByb3RvdHlwZS5lYWNoUGF0aCA9IGZ1bmN0aW9uKGZuKSB7XG4gIGNvbnN0IGtleXMgPSBPYmplY3Qua2V5cyh0aGlzLnBhdGhzKTtcbiAgY29uc3QgbGVuID0ga2V5cy5sZW5ndGg7XG5cbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZW47ICsraSkge1xuICAgIGZuKGtleXNbaV0sIHRoaXMucGF0aHNba2V5c1tpXV0pO1xuICB9XG5cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIFJldHVybnMgYW4gQXJyYXkgb2YgcGF0aCBzdHJpbmdzIHRoYXQgYXJlIHJlcXVpcmVkIGJ5IHRoaXMgc2NoZW1hLlxuICpcbiAqICMjIyMgRXhhbXBsZTpcbiAqXG4gKiAgICAgY29uc3QgcyA9IG5ldyBTY2hlbWEoe1xuICogICAgICAgbmFtZTogeyB0eXBlOiBTdHJpbmcsIHJlcXVpcmVkOiB0cnVlIH0sXG4gKiAgICAgICBhZ2U6IHsgdHlwZTogU3RyaW5nLCByZXF1aXJlZDogdHJ1ZSB9LFxuICogICAgICAgbm90ZXM6IFN0cmluZ1xuICogICAgIH0pO1xuICogICAgIHMucmVxdWlyZWRQYXRocygpOyAvLyBbICdhZ2UnLCAnbmFtZScgXVxuICpcbiAqIEBhcGkgcHVibGljXG4gKiBAcGFyYW0ge0Jvb2xlYW59IGludmFsaWRhdGUgUmVmcmVzaCB0aGUgY2FjaGVcbiAqIEByZXR1cm4ge0FycmF5fVxuICovXG5cblNjaGVtYS5wcm90b3R5cGUucmVxdWlyZWRQYXRocyA9IGZ1bmN0aW9uIHJlcXVpcmVkUGF0aHMoaW52YWxpZGF0ZSkge1xuICBpZiAodGhpcy5fcmVxdWlyZWRwYXRocyAmJiAhaW52YWxpZGF0ZSkge1xuICAgIHJldHVybiB0aGlzLl9yZXF1aXJlZHBhdGhzO1xuICB9XG5cbiAgY29uc3QgcGF0aHMgPSBPYmplY3Qua2V5cyh0aGlzLnBhdGhzKTtcbiAgbGV0IGkgPSBwYXRocy5sZW5ndGg7XG4gIGNvbnN0IHJldCA9IFtdO1xuXG4gIHdoaWxlIChpLS0pIHtcbiAgICBjb25zdCBwYXRoID0gcGF0aHNbaV07XG4gICAgaWYgKHRoaXMucGF0aHNbcGF0aF0uaXNSZXF1aXJlZCkge1xuICAgICAgcmV0LnB1c2gocGF0aCk7XG4gICAgfVxuICB9XG4gIHRoaXMuX3JlcXVpcmVkcGF0aHMgPSByZXQ7XG4gIHJldHVybiB0aGlzLl9yZXF1aXJlZHBhdGhzO1xufTtcblxuLyoqXG4gKiBSZXR1cm5zIGluZGV4ZXMgZnJvbSBmaWVsZHMgYW5kIHNjaGVtYS1sZXZlbCBpbmRleGVzIChjYWNoZWQpLlxuICpcbiAqIEBhcGkgcHJpdmF0ZVxuICogQHJldHVybiB7QXJyYXl9XG4gKi9cblxuU2NoZW1hLnByb3RvdHlwZS5pbmRleGVkUGF0aHMgPSBmdW5jdGlvbiBpbmRleGVkUGF0aHMoKSB7XG4gIGlmICh0aGlzLl9pbmRleGVkcGF0aHMpIHtcbiAgICByZXR1cm4gdGhpcy5faW5kZXhlZHBhdGhzO1xuICB9XG4gIHRoaXMuX2luZGV4ZWRwYXRocyA9IHRoaXMuaW5kZXhlcygpO1xuICByZXR1cm4gdGhpcy5faW5kZXhlZHBhdGhzO1xufTtcblxuLyoqXG4gKiBSZXR1cm5zIHRoZSBwYXRoVHlwZSBvZiBgcGF0aGAgZm9yIHRoaXMgc2NoZW1hLlxuICpcbiAqIEdpdmVuIGEgcGF0aCwgcmV0dXJucyB3aGV0aGVyIGl0IGlzIGEgcmVhbCwgdmlydHVhbCwgbmVzdGVkLCBvciBhZC1ob2MvdW5kZWZpbmVkIHBhdGguXG4gKlxuICogIyMjIyBFeGFtcGxlOlxuICpcbiAqICAgICBjb25zdCBzID0gbmV3IFNjaGVtYSh7IG5hbWU6IFN0cmluZywgbmVzdGVkOiB7IGZvbzogU3RyaW5nIH0gfSk7XG4gKiAgICAgcy52aXJ0dWFsKCdmb28nKS5nZXQoKCkgPT4gNDIpO1xuICogICAgIHMucGF0aFR5cGUoJ25hbWUnKTsgLy8gXCJyZWFsXCJcbiAqICAgICBzLnBhdGhUeXBlKCduZXN0ZWQnKTsgLy8gXCJuZXN0ZWRcIlxuICogICAgIHMucGF0aFR5cGUoJ2ZvbycpOyAvLyBcInZpcnR1YWxcIlxuICogICAgIHMucGF0aFR5cGUoJ2ZhaWwnKTsgLy8gXCJhZGhvY09yVW5kZWZpbmVkXCJcbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gcGF0aFxuICogQHJldHVybiB7U3RyaW5nfVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5TY2hlbWEucHJvdG90eXBlLnBhdGhUeXBlID0gZnVuY3Rpb24ocGF0aCkge1xuICBpZiAodGhpcy5wYXRocy5oYXNPd25Qcm9wZXJ0eShwYXRoKSkge1xuICAgIHJldHVybiAncmVhbCc7XG4gIH1cbiAgaWYgKHRoaXMudmlydHVhbHMuaGFzT3duUHJvcGVydHkocGF0aCkpIHtcbiAgICByZXR1cm4gJ3ZpcnR1YWwnO1xuICB9XG4gIGlmICh0aGlzLm5lc3RlZC5oYXNPd25Qcm9wZXJ0eShwYXRoKSkge1xuICAgIHJldHVybiAnbmVzdGVkJztcbiAgfVxuXG4gIC8vIENvbnZlcnQgdG8gJy4kJyB0byBjaGVjayBzdWJwYXRocyByZTogZ2gtNjQwNVxuICBjb25zdCBjbGVhblBhdGggPSBfcGF0aFRvUG9zaXRpb25hbFN5bnRheChwYXRoKTtcblxuICBpZiAodGhpcy5zdWJwYXRocy5oYXNPd25Qcm9wZXJ0eShjbGVhblBhdGgpIHx8IHRoaXMuc3VicGF0aHMuaGFzT3duUHJvcGVydHkocGF0aCkpIHtcbiAgICByZXR1cm4gJ3JlYWwnO1xuICB9XG5cbiAgY29uc3Qgc2luZ2xlTmVzdGVkUGF0aCA9IHRoaXMuc2luZ2xlTmVzdGVkUGF0aHMuaGFzT3duUHJvcGVydHkoY2xlYW5QYXRoKSB8fCB0aGlzLnNpbmdsZU5lc3RlZFBhdGhzLmhhc093blByb3BlcnR5KHBhdGgpO1xuICBpZiAoc2luZ2xlTmVzdGVkUGF0aCkge1xuICAgIHJldHVybiBzaW5nbGVOZXN0ZWRQYXRoID09PSAnbmVzdGVkJyA/ICduZXN0ZWQnIDogJ3JlYWwnO1xuICB9XG5cbiAgLy8gTG9vayBmb3IgbWFwc1xuICBjb25zdCBtYXBQYXRoID0gZ2V0TWFwUGF0aCh0aGlzLCBwYXRoKTtcbiAgaWYgKG1hcFBhdGggIT0gbnVsbCkge1xuICAgIHJldHVybiAncmVhbCc7XG4gIH1cblxuICBpZiAoL1xcLlxcZCtcXC58XFwuXFxkKyQvLnRlc3QocGF0aCkpIHtcbiAgICByZXR1cm4gZ2V0UG9zaXRpb25hbFBhdGhUeXBlKHRoaXMsIHBhdGgsIGNsZWFuUGF0aCk7XG4gIH1cbiAgcmV0dXJuICdhZGhvY09yVW5kZWZpbmVkJztcbn07XG5cbi8qKlxuICogUmV0dXJucyB0cnVlIGlmZiB0aGlzIHBhdGggaXMgYSBjaGlsZCBvZiBhIG1peGVkIHNjaGVtYS5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gcGF0aFxuICogQHJldHVybiB7Qm9vbGVhbn1cbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cblNjaGVtYS5wcm90b3R5cGUuaGFzTWl4ZWRQYXJlbnQgPSBmdW5jdGlvbihwYXRoKSB7XG4gIGNvbnN0IHN1YnBhdGhzID0gcGF0aC5zcGxpdCgvXFwuL2cpO1xuICBwYXRoID0gJyc7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgc3VicGF0aHMubGVuZ3RoOyArK2kpIHtcbiAgICBwYXRoID0gaSA+IDAgPyBwYXRoICsgJy4nICsgc3VicGF0aHNbaV0gOiBzdWJwYXRoc1tpXTtcbiAgICBpZiAodGhpcy5wYXRocy5oYXNPd25Qcm9wZXJ0eShwYXRoKSAmJlxuICAgICAgICB0aGlzLnBhdGhzW3BhdGhdIGluc3RhbmNlb2YgTW9uZ29vc2VUeXBlcy5NaXhlZCkge1xuICAgICAgcmV0dXJuIHRoaXMucGF0aHNbcGF0aF07XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG51bGw7XG59O1xuXG4vKipcbiAqIFNldHVwIHVwZGF0ZWRBdCBhbmQgY3JlYXRlZEF0IHRpbWVzdGFtcHMgdG8gZG9jdW1lbnRzIGlmIGVuYWJsZWRcbiAqXG4gKiBAcGFyYW0ge0Jvb2xlYW58T2JqZWN0fSB0aW1lc3RhbXBzIHRpbWVzdGFtcHMgb3B0aW9uc1xuICogQGFwaSBwcml2YXRlXG4gKi9cblNjaGVtYS5wcm90b3R5cGUuc2V0dXBUaW1lc3RhbXAgPSBmdW5jdGlvbih0aW1lc3RhbXBzKSB7XG4gIHJldHVybiBzZXR1cFRpbWVzdGFtcHModGhpcywgdGltZXN0YW1wcyk7XG59O1xuXG4vKipcbiAqIGlnbm9yZS4gRGVwcmVjYXRlZCByZTogIzY0MDVcbiAqIEBwYXJhbSB7QW55fSBzZWxmXG4gKiBAcGFyYW0ge1N0cmluZ30gcGF0aFxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZnVuY3Rpb24gZ2V0UG9zaXRpb25hbFBhdGhUeXBlKHNlbGYsIHBhdGgsIGNsZWFuUGF0aCkge1xuICBjb25zdCBzdWJwYXRocyA9IHBhdGguc3BsaXQoL1xcLihcXGQrKVxcLnxcXC4oXFxkKykkLykuZmlsdGVyKEJvb2xlYW4pO1xuICBpZiAoc3VicGF0aHMubGVuZ3RoIDwgMikge1xuICAgIHJldHVybiBzZWxmLnBhdGhzLmhhc093blByb3BlcnR5KHN1YnBhdGhzWzBdKSA/XG4gICAgICBzZWxmLnBhdGhzW3N1YnBhdGhzWzBdXSA6XG4gICAgICAnYWRob2NPclVuZGVmaW5lZCc7XG4gIH1cblxuICBsZXQgdmFsID0gc2VsZi5wYXRoKHN1YnBhdGhzWzBdKTtcbiAgbGV0IGlzTmVzdGVkID0gZmFsc2U7XG4gIGlmICghdmFsKSB7XG4gICAgcmV0dXJuICdhZGhvY09yVW5kZWZpbmVkJztcbiAgfVxuXG4gIGNvbnN0IGxhc3QgPSBzdWJwYXRocy5sZW5ndGggLSAxO1xuXG4gIGZvciAobGV0IGkgPSAxOyBpIDwgc3VicGF0aHMubGVuZ3RoOyArK2kpIHtcbiAgICBpc05lc3RlZCA9IGZhbHNlO1xuICAgIGNvbnN0IHN1YnBhdGggPSBzdWJwYXRoc1tpXTtcblxuICAgIGlmIChpID09PSBsYXN0ICYmIHZhbCAmJiAhL1xcRC8udGVzdChzdWJwYXRoKSkge1xuICAgICAgaWYgKHZhbC4kaXNNb25nb29zZURvY3VtZW50QXJyYXkpIHtcbiAgICAgICAgdmFsID0gdmFsLiRlbWJlZGRlZFNjaGVtYVR5cGU7XG4gICAgICB9IGVsc2UgaWYgKHZhbCBpbnN0YW5jZW9mIE1vbmdvb3NlVHlwZXMuQXJyYXkpIHtcbiAgICAgICAgLy8gU3RyaW5nU2NoZW1hLCBOdW1iZXJTY2hlbWEsIGV0Y1xuICAgICAgICB2YWwgPSB2YWwuY2FzdGVyO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFsID0gdW5kZWZpbmVkO1xuICAgICAgfVxuICAgICAgYnJlYWs7XG4gICAgfVxuXG4gICAgLy8gaWdub3JlIGlmIGl0cyBqdXN0IGEgcG9zaXRpb24gc2VnbWVudDogcGF0aC4wLnN1YnBhdGhcbiAgICBpZiAoIS9cXEQvLnRlc3Qoc3VicGF0aCkpIHtcbiAgICAgIC8vIE5lc3RlZCBhcnJheVxuICAgICAgaWYgKHZhbCBpbnN0YW5jZW9mIE1vbmdvb3NlVHlwZXMuQXJyYXkgJiYgaSAhPT0gbGFzdCkge1xuICAgICAgICB2YWwgPSB2YWwuY2FzdGVyO1xuICAgICAgfVxuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgaWYgKCEodmFsICYmIHZhbC5zY2hlbWEpKSB7XG4gICAgICB2YWwgPSB1bmRlZmluZWQ7XG4gICAgICBicmVhaztcbiAgICB9XG5cbiAgICBjb25zdCB0eXBlID0gdmFsLnNjaGVtYS5wYXRoVHlwZShzdWJwYXRoKTtcbiAgICBpc05lc3RlZCA9ICh0eXBlID09PSAnbmVzdGVkJyk7XG4gICAgdmFsID0gdmFsLnNjaGVtYS5wYXRoKHN1YnBhdGgpO1xuICB9XG5cbiAgc2VsZi5zdWJwYXRoc1tjbGVhblBhdGhdID0gdmFsO1xuICBpZiAodmFsKSB7XG4gICAgcmV0dXJuICdyZWFsJztcbiAgfVxuICBpZiAoaXNOZXN0ZWQpIHtcbiAgICByZXR1cm4gJ25lc3RlZCc7XG4gIH1cbiAgcmV0dXJuICdhZGhvY09yVW5kZWZpbmVkJztcbn1cblxuXG4vKiFcbiAqIGlnbm9yZVxuICovXG5cbmZ1bmN0aW9uIGdldFBvc2l0aW9uYWxQYXRoKHNlbGYsIHBhdGgsIGNsZWFuUGF0aCkge1xuICBnZXRQb3NpdGlvbmFsUGF0aFR5cGUoc2VsZiwgcGF0aCwgY2xlYW5QYXRoKTtcbiAgcmV0dXJuIHNlbGYuc3VicGF0aHNbY2xlYW5QYXRoXTtcbn1cblxuLyoqXG4gKiBBZGRzIGEgbWV0aG9kIGNhbGwgdG8gdGhlIHF1ZXVlLlxuICpcbiAqICMjIyMgRXhhbXBsZTpcbiAqXG4gKiAgICAgc2NoZW1hLm1ldGhvZHMucHJpbnQgPSBmdW5jdGlvbigpIHsgY29uc29sZS5sb2codGhpcyk7IH07XG4gKiAgICAgc2NoZW1hLnF1ZXVlKCdwcmludCcsIFtdKTsgLy8gUHJpbnQgdGhlIGRvYyBldmVyeSBvbmUgaXMgaW5zdGFudGlhdGVkXG4gKlxuICogICAgIGNvbnN0IE1vZGVsID0gbW9uZ29vc2UubW9kZWwoJ1Rlc3QnLCBzY2hlbWEpO1xuICogICAgIG5ldyBNb2RlbCh7IG5hbWU6ICd0ZXN0JyB9KTsgLy8gUHJpbnRzICd7XCJfaWRcIjogLi4uLCBcIm5hbWVcIjogXCJ0ZXN0XCIgfSdcbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gbmFtZSBuYW1lIG9mIHRoZSBkb2N1bWVudCBtZXRob2QgdG8gY2FsbCBsYXRlclxuICogQHBhcmFtIHtBcnJheX0gYXJncyBhcmd1bWVudHMgdG8gcGFzcyB0byB0aGUgbWV0aG9kXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cblNjaGVtYS5wcm90b3R5cGUucXVldWUgPSBmdW5jdGlvbihuYW1lLCBhcmdzKSB7XG4gIHRoaXMuY2FsbFF1ZXVlLnB1c2goW25hbWUsIGFyZ3NdKTtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIERlZmluZXMgYSBwcmUgaG9vayBmb3IgdGhlIG1vZGVsLlxuICpcbiAqICMjIyMgRXhhbXBsZTpcbiAqXG4gKiAgICAgY29uc3QgdG95U2NoZW1hID0gbmV3IFNjaGVtYSh7IG5hbWU6IFN0cmluZywgY3JlYXRlZDogRGF0ZSB9KTtcbiAqXG4gKiAgICAgdG95U2NoZW1hLnByZSgnc2F2ZScsIGZ1bmN0aW9uKG5leHQpIHtcbiAqICAgICAgIGlmICghdGhpcy5jcmVhdGVkKSB0aGlzLmNyZWF0ZWQgPSBuZXcgRGF0ZTtcbiAqICAgICAgIG5leHQoKTtcbiAqICAgICB9KTtcbiAqXG4gKiAgICAgdG95U2NoZW1hLnByZSgndmFsaWRhdGUnLCBmdW5jdGlvbihuZXh0KSB7XG4gKiAgICAgICBpZiAodGhpcy5uYW1lICE9PSAnV29vZHknKSB0aGlzLm5hbWUgPSAnV29vZHknO1xuICogICAgICAgbmV4dCgpO1xuICogICAgIH0pO1xuICpcbiAqICAgICAvLyBFcXVpdmFsZW50IHRvIGNhbGxpbmcgYHByZSgpYCBvbiBgZmluZGAsIGBmaW5kT25lYCwgYGZpbmRPbmVBbmRVcGRhdGVgLlxuICogICAgIHRveVNjaGVtYS5wcmUoL15maW5kLywgZnVuY3Rpb24obmV4dCkge1xuICogICAgICAgY29uc29sZS5sb2codGhpcy5nZXRGaWx0ZXIoKSk7XG4gKiAgICAgfSk7XG4gKlxuICogICAgIC8vIEVxdWl2YWxlbnQgdG8gY2FsbGluZyBgcHJlKClgIG9uIGB1cGRhdGVPbmVgLCBgZmluZE9uZUFuZFVwZGF0ZWAuXG4gKiAgICAgdG95U2NoZW1hLnByZShbJ3VwZGF0ZU9uZScsICdmaW5kT25lQW5kVXBkYXRlJ10sIGZ1bmN0aW9uKG5leHQpIHtcbiAqICAgICAgIGNvbnNvbGUubG9nKHRoaXMuZ2V0RmlsdGVyKCkpO1xuICogICAgIH0pO1xuICpcbiAqICAgICB0b3lTY2hlbWEucHJlKCdkZWxldGVPbmUnLCBmdW5jdGlvbigpIHtcbiAqICAgICAgIC8vIFJ1bnMgd2hlbiB5b3UgY2FsbCBgVG95LmRlbGV0ZU9uZSgpYFxuICogICAgIH0pO1xuICpcbiAqICAgICB0b3lTY2hlbWEucHJlKCdkZWxldGVPbmUnLCB7IGRvY3VtZW50OiB0cnVlIH0sIGZ1bmN0aW9uKCkge1xuICogICAgICAgLy8gUnVucyB3aGVuIHlvdSBjYWxsIGBkb2MuZGVsZXRlT25lKClgXG4gKiAgICAgfSk7XG4gKlxuICogQHBhcmFtIHtTdHJpbmd8UmVnRXhwfFN0cmluZ1tdfSBtZXRob2ROYW1lIFRoZSBtZXRob2QgbmFtZSBvciByZWd1bGFyIGV4cHJlc3Npb24gdG8gbWF0Y2ggbWV0aG9kIG5hbWVcbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc11cbiAqIEBwYXJhbSB7Qm9vbGVhbn0gW29wdGlvbnMuZG9jdW1lbnRdIElmIGBuYW1lYCBpcyBhIGhvb2sgZm9yIGJvdGggZG9jdW1lbnQgYW5kIHF1ZXJ5IG1pZGRsZXdhcmUsIHNldCB0byBgdHJ1ZWAgdG8gcnVuIG9uIGRvY3VtZW50IG1pZGRsZXdhcmUuIEZvciBleGFtcGxlLCBzZXQgYG9wdGlvbnMuZG9jdW1lbnRgIHRvIGB0cnVlYCB0byBhcHBseSB0aGlzIGhvb2sgdG8gYERvY3VtZW50I2RlbGV0ZU9uZSgpYCByYXRoZXIgdGhhbiBgUXVlcnkjZGVsZXRlT25lKClgLlxuICogQHBhcmFtIHtCb29sZWFufSBbb3B0aW9ucy5xdWVyeV0gSWYgYG5hbWVgIGlzIGEgaG9vayBmb3IgYm90aCBkb2N1bWVudCBhbmQgcXVlcnkgbWlkZGxld2FyZSwgc2V0IHRvIGB0cnVlYCB0byBydW4gb24gcXVlcnkgbWlkZGxld2FyZS5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cblNjaGVtYS5wcm90b3R5cGUucHJlID0gZnVuY3Rpb24obmFtZSkge1xuICBpZiAobmFtZSBpbnN0YW5jZW9mIFJlZ0V4cCkge1xuICAgIGNvbnN0IHJlbWFpbmluZ0FyZ3MgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsIDEpO1xuICAgIGZvciAoY29uc3QgZm4gb2YgaG9va05hbWVzKSB7XG4gICAgICBpZiAobmFtZS50ZXN0KGZuKSkge1xuICAgICAgICB0aGlzLnByZS5hcHBseSh0aGlzLCBbZm5dLmNvbmNhdChyZW1haW5pbmdBcmdzKSk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIGlmIChBcnJheS5pc0FycmF5KG5hbWUpKSB7XG4gICAgY29uc3QgcmVtYWluaW5nQXJncyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMSk7XG4gICAgZm9yIChjb25zdCBlbCBvZiBuYW1lKSB7XG4gICAgICB0aGlzLnByZS5hcHBseSh0aGlzLCBbZWxdLmNvbmNhdChyZW1haW5pbmdBcmdzKSk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIHRoaXMucy5ob29rcy5wcmUuYXBwbHkodGhpcy5zLmhvb2tzLCBhcmd1bWVudHMpO1xuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogRGVmaW5lcyBhIHBvc3QgaG9vayBmb3IgdGhlIGRvY3VtZW50XG4gKlxuICogICAgIGNvbnN0IHNjaGVtYSA9IG5ldyBTY2hlbWEoLi4pO1xuICogICAgIHNjaGVtYS5wb3N0KCdzYXZlJywgZnVuY3Rpb24gKGRvYykge1xuICogICAgICAgY29uc29sZS5sb2coJ3RoaXMgZmlyZWQgYWZ0ZXIgYSBkb2N1bWVudCB3YXMgc2F2ZWQnKTtcbiAqICAgICB9KTtcbiAqXG4gKiAgICAgc2NoZW1hLnBvc3QoJ2ZpbmQnLCBmdW5jdGlvbihkb2NzKSB7XG4gKiAgICAgICBjb25zb2xlLmxvZygndGhpcyBmaXJlZCBhZnRlciB5b3UgcmFuIGEgZmluZCBxdWVyeScpO1xuICogICAgIH0pO1xuICpcbiAqICAgICBzY2hlbWEucG9zdCgvTWFueSQvLCBmdW5jdGlvbihyZXMpIHtcbiAqICAgICAgIGNvbnNvbGUubG9nKCd0aGlzIGZpcmVkIGFmdGVyIHlvdSByYW4gYHVwZGF0ZU1hbnkoKWAgb3IgYGRlbGV0ZU1hbnkoKWAnKTtcbiAqICAgICB9KTtcbiAqXG4gKiAgICAgY29uc3QgTW9kZWwgPSBtb25nb29zZS5tb2RlbCgnTW9kZWwnLCBzY2hlbWEpO1xuICpcbiAqICAgICBjb25zdCBtID0gbmV3IE1vZGVsKC4uKTtcbiAqICAgICBtLnNhdmUoZnVuY3Rpb24oZXJyKSB7XG4gKiAgICAgICBjb25zb2xlLmxvZygndGhpcyBmaXJlcyBhZnRlciB0aGUgYHBvc3RgIGhvb2snKTtcbiAqICAgICB9KTtcbiAqXG4gKiAgICAgbS5maW5kKGZ1bmN0aW9uKGVyciwgZG9jcykge1xuICogICAgICAgY29uc29sZS5sb2coJ3RoaXMgZmlyZXMgYWZ0ZXIgdGhlIHBvc3QgZmluZCBob29rJyk7XG4gKiAgICAgfSk7XG4gKlxuICogQHBhcmFtIHtTdHJpbmd8UmVnRXhwfFN0cmluZ1tdfSBtZXRob2ROYW1lIFRoZSBtZXRob2QgbmFtZSBvciByZWd1bGFyIGV4cHJlc3Npb24gdG8gbWF0Y2ggbWV0aG9kIG5hbWVcbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc11cbiAqIEBwYXJhbSB7Qm9vbGVhbn0gW29wdGlvbnMuZG9jdW1lbnRdIElmIGBuYW1lYCBpcyBhIGhvb2sgZm9yIGJvdGggZG9jdW1lbnQgYW5kIHF1ZXJ5IG1pZGRsZXdhcmUsIHNldCB0byBgdHJ1ZWAgdG8gcnVuIG9uIGRvY3VtZW50IG1pZGRsZXdhcmUuXG4gKiBAcGFyYW0ge0Jvb2xlYW59IFtvcHRpb25zLnF1ZXJ5XSBJZiBgbmFtZWAgaXMgYSBob29rIGZvciBib3RoIGRvY3VtZW50IGFuZCBxdWVyeSBtaWRkbGV3YXJlLCBzZXQgdG8gYHRydWVgIHRvIHJ1biBvbiBxdWVyeSBtaWRkbGV3YXJlLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gZm4gY2FsbGJhY2tcbiAqIEBzZWUgbWlkZGxld2FyZSBodHRwczovL21vbmdvb3NlanMuY29tL2RvY3MvbWlkZGxld2FyZS5odG1sXG4gKiBAc2VlIGthcmVlbSBodHRwczovL25wbWpzLm9yZy9wYWNrYWdlL2thcmVlbVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5TY2hlbWEucHJvdG90eXBlLnBvc3QgPSBmdW5jdGlvbihuYW1lKSB7XG4gIGlmIChuYW1lIGluc3RhbmNlb2YgUmVnRXhwKSB7XG4gICAgY29uc3QgcmVtYWluaW5nQXJncyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMSk7XG4gICAgZm9yIChjb25zdCBmbiBvZiBob29rTmFtZXMpIHtcbiAgICAgIGlmIChuYW1lLnRlc3QoZm4pKSB7XG4gICAgICAgIHRoaXMucG9zdC5hcHBseSh0aGlzLCBbZm5dLmNvbmNhdChyZW1haW5pbmdBcmdzKSk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIGlmIChBcnJheS5pc0FycmF5KG5hbWUpKSB7XG4gICAgY29uc3QgcmVtYWluaW5nQXJncyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMSk7XG4gICAgZm9yIChjb25zdCBlbCBvZiBuYW1lKSB7XG4gICAgICB0aGlzLnBvc3QuYXBwbHkodGhpcywgW2VsXS5jb25jYXQocmVtYWluaW5nQXJncykpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICB0aGlzLnMuaG9va3MucG9zdC5hcHBseSh0aGlzLnMuaG9va3MsIGFyZ3VtZW50cyk7XG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBSZWdpc3RlcnMgYSBwbHVnaW4gZm9yIHRoaXMgc2NoZW1hLlxuICpcbiAqICMjIyMgRXhhbXBsZTpcbiAqXG4gKiAgICAgY29uc3QgcyA9IG5ldyBTY2hlbWEoeyBuYW1lOiBTdHJpbmcgfSk7XG4gKiAgICAgcy5wbHVnaW4oc2NoZW1hID0+IGNvbnNvbGUubG9nKHNjaGVtYS5wYXRoKCduYW1lJykucGF0aCkpO1xuICogICAgIG1vbmdvb3NlLm1vZGVsKCdUZXN0Jywgcyk7IC8vIFByaW50cyAnbmFtZSdcbiAqXG4gKiBPciB3aXRoIE9wdGlvbnM6XG4gKlxuICogICAgIGNvbnN0IHMgPSBuZXcgU2NoZW1hKHsgbmFtZTogU3RyaW5nIH0pO1xuICogICAgIHMucGx1Z2luKChzY2hlbWEsIG9wdHMpID0+IGNvbnNvbGUubG9nKG9wdHMudGV4dCwgc2NoZW1hLnBhdGgoJ25hbWUnKS5wYXRoKSwgeyB0ZXh0OiBcIlNjaGVtYSBQYXRoIE5hbWU6XCIgfSk7XG4gKiAgICAgbW9uZ29vc2UubW9kZWwoJ1Rlc3QnLCBzKTsgLy8gUHJpbnRzICdTY2hlbWEgUGF0aCBOYW1lOiBuYW1lJ1xuICpcbiAqIEBwYXJhbSB7RnVuY3Rpb259IHBsdWdpbiBUaGUgUGx1Z2luJ3MgY2FsbGJhY2tcbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0c10gT3B0aW9ucyB0byBwYXNzIHRvIHRoZSBwbHVnaW5cbiAqIEBwYXJhbSB7Qm9vbGVhbn0gW29wdHMuZGVkdXBsaWNhdGU9ZmFsc2VdIElmIHRydWUsIGlnbm9yZSBkdXBsaWNhdGUgcGx1Z2lucyAoc2FtZSBgZm5gIGFyZ3VtZW50IHVzaW5nIGA9PT1gKVxuICogQHNlZSBwbHVnaW5zIGh0dHBzOi8vbW9uZ29vc2Vqcy5jb20vZG9jcy9wbHVnaW5zLmh0bWxcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuU2NoZW1hLnByb3RvdHlwZS5wbHVnaW4gPSBmdW5jdGlvbihmbiwgb3B0cykge1xuICBpZiAodHlwZW9mIGZuICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdGaXJzdCBwYXJhbSB0byBgc2NoZW1hLnBsdWdpbigpYCBtdXN0IGJlIGEgZnVuY3Rpb24sICcgK1xuICAgICAgJ2dvdCBcIicgKyAodHlwZW9mIGZuKSArICdcIicpO1xuICB9XG5cbiAgaWYgKG9wdHMgJiYgb3B0cy5kZWR1cGxpY2F0ZSkge1xuICAgIGZvciAoY29uc3QgcGx1Z2luIG9mIHRoaXMucGx1Z2lucykge1xuICAgICAgaWYgKHBsdWdpbi5mbiA9PT0gZm4pIHtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHRoaXMucGx1Z2lucy5wdXNoKHsgZm46IGZuLCBvcHRzOiBvcHRzIH0pO1xuXG4gIGZuKHRoaXMsIG9wdHMpO1xuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogQWRkcyBhbiBpbnN0YW5jZSBtZXRob2QgdG8gZG9jdW1lbnRzIGNvbnN0cnVjdGVkIGZyb20gTW9kZWxzIGNvbXBpbGVkIGZyb20gdGhpcyBzY2hlbWEuXG4gKlxuICogIyMjIyBFeGFtcGxlOlxuICpcbiAqICAgICBjb25zdCBzY2hlbWEgPSBraXR0eVNjaGVtYSA9IG5ldyBTY2hlbWEoLi4pO1xuICpcbiAqICAgICBzY2hlbWEubWV0aG9kKCdtZW93JywgZnVuY3Rpb24gKCkge1xuICogICAgICAgY29uc29sZS5sb2coJ21lZWVlZW9vb29vb29vb29vb3cnKTtcbiAqICAgICB9KVxuICpcbiAqICAgICBjb25zdCBLaXR0eSA9IG1vbmdvb3NlLm1vZGVsKCdLaXR0eScsIHNjaGVtYSk7XG4gKlxuICogICAgIGNvbnN0IGZpenogPSBuZXcgS2l0dHk7XG4gKiAgICAgZml6ei5tZW93KCk7IC8vIG1lZWVlZW9vb29vb29vb29vb293XG4gKlxuICogSWYgYSBoYXNoIG9mIG5hbWUvZm4gcGFpcnMgaXMgcGFzc2VkIGFzIHRoZSBvbmx5IGFyZ3VtZW50LCBlYWNoIG5hbWUvZm4gcGFpciB3aWxsIGJlIGFkZGVkIGFzIG1ldGhvZHMuXG4gKlxuICogICAgIHNjaGVtYS5tZXRob2Qoe1xuICogICAgICAgICBwdXJyOiBmdW5jdGlvbiAoKSB7fVxuICogICAgICAgLCBzY3JhdGNoOiBmdW5jdGlvbiAoKSB7fVxuICogICAgIH0pO1xuICpcbiAqICAgICAvLyBsYXRlclxuICogICAgIGNvbnN0IGZpenogPSBuZXcgS2l0dHk7XG4gKiAgICAgZml6ei5wdXJyKCk7XG4gKiAgICAgZml6ei5zY3JhdGNoKCk7XG4gKlxuICogTk9URTogYFNjaGVtYS5tZXRob2QoKWAgYWRkcyBpbnN0YW5jZSBtZXRob2RzIHRvIHRoZSBgU2NoZW1hLm1ldGhvZHNgIG9iamVjdC4gWW91IGNhbiBhbHNvIGFkZCBpbnN0YW5jZSBtZXRob2RzIGRpcmVjdGx5IHRvIHRoZSBgU2NoZW1hLm1ldGhvZHNgIG9iamVjdCBhcyBzZWVuIGluIHRoZSBbZ3VpZGVdKGh0dHBzOi8vbW9uZ29vc2Vqcy5jb20vZG9jcy9ndWlkZS5odG1sI21ldGhvZHMpXG4gKlxuICogQHBhcmFtIHtTdHJpbmd8T2JqZWN0fSBuYW1lIFRoZSBNZXRob2QgTmFtZSBmb3IgYSBzaW5nbGUgZnVuY3Rpb24sIG9yIGEgT2JqZWN0IG9mIFwic3RyaW5nLWZ1bmN0aW9uXCIgcGFpcnMuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbZm5dIFRoZSBGdW5jdGlvbiBpbiBhIHNpbmdsZS1mdW5jdGlvbiBkZWZpbml0aW9uLlxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5TY2hlbWEucHJvdG90eXBlLm1ldGhvZCA9IGZ1bmN0aW9uKG5hbWUsIGZuLCBvcHRpb25zKSB7XG4gIGlmICh0eXBlb2YgbmFtZSAhPT0gJ3N0cmluZycpIHtcbiAgICBmb3IgKGNvbnN0IGkgaW4gbmFtZSkge1xuICAgICAgdGhpcy5tZXRob2RzW2ldID0gbmFtZVtpXTtcbiAgICAgIHRoaXMubWV0aG9kT3B0aW9uc1tpXSA9IGNsb25lKG9wdGlvbnMpO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICB0aGlzLm1ldGhvZHNbbmFtZV0gPSBmbjtcbiAgICB0aGlzLm1ldGhvZE9wdGlvbnNbbmFtZV0gPSBjbG9uZShvcHRpb25zKTtcbiAgfVxuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogQWRkcyBzdGF0aWMgXCJjbGFzc1wiIG1ldGhvZHMgdG8gTW9kZWxzIGNvbXBpbGVkIGZyb20gdGhpcyBzY2hlbWEuXG4gKlxuICogIyMjIyBFeGFtcGxlOlxuICpcbiAqICAgICBjb25zdCBzY2hlbWEgPSBuZXcgU2NoZW1hKC4uKTtcbiAqICAgICAvLyBFcXVpdmFsZW50IHRvIGBzY2hlbWEuc3RhdGljcy5maW5kQnlOYW1lID0gZnVuY3Rpb24obmFtZSkge31gO1xuICogICAgIHNjaGVtYS5zdGF0aWMoJ2ZpbmRCeU5hbWUnLCBmdW5jdGlvbihuYW1lKSB7XG4gKiAgICAgICByZXR1cm4gdGhpcy5maW5kKHsgbmFtZTogbmFtZSB9KTtcbiAqICAgICB9KTtcbiAqXG4gKiAgICAgY29uc3QgRHJpbmsgPSBtb25nb29zZS5tb2RlbCgnRHJpbmsnLCBzY2hlbWEpO1xuICogICAgIGF3YWl0IERyaW5rLmZpbmRCeU5hbWUoJ0xhQ3JvaXgnKTtcbiAqXG4gKiBJZiBhIGhhc2ggb2YgbmFtZS9mbiBwYWlycyBpcyBwYXNzZWQgYXMgdGhlIG9ubHkgYXJndW1lbnQsIGVhY2ggbmFtZS9mbiBwYWlyIHdpbGwgYmUgYWRkZWQgYXMgbWV0aG9kcy5cbiAqXG4gKiAgICAgc2NoZW1hLnN0YXRpYyh7XG4gKiAgICAgICAgIGZpbmRCeU5hbWU6IGZ1bmN0aW9uICgpIHsuLn1cbiAqICAgICAgICwgZmluZEJ5Q29zdDogZnVuY3Rpb24gKCkgey4ufVxuICogICAgIH0pO1xuICpcbiAqICAgICBjb25zdCBEcmluayA9IG1vbmdvb3NlLm1vZGVsKCdEcmluaycsIHNjaGVtYSk7XG4gKiAgICAgYXdhaXQgRHJpbmsuZmluZEJ5TmFtZSgnTGFDcm9peCcpO1xuICogICAgIGF3YWl0IERyaW5rLmZpbmRCeUNvc3QoMyk7XG4gKlxuICogSWYgYSBoYXNoIG9mIG5hbWUvZm4gcGFpcnMgaXMgcGFzc2VkIGFzIHRoZSBvbmx5IGFyZ3VtZW50LCBlYWNoIG5hbWUvZm4gcGFpciB3aWxsIGJlIGFkZGVkIGFzIHN0YXRpY3MuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd8T2JqZWN0fSBuYW1lIFRoZSBNZXRob2QgTmFtZSBmb3IgYSBzaW5nbGUgZnVuY3Rpb24sIG9yIGEgT2JqZWN0IG9mIFwic3RyaW5nLWZ1bmN0aW9uXCIgcGFpcnMuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbZm5dIFRoZSBGdW5jdGlvbiBpbiBhIHNpbmdsZS1mdW5jdGlvbiBkZWZpbml0aW9uLlxuICogQGFwaSBwdWJsaWNcbiAqIEBzZWUgU3RhdGljcyBodHRwczovL21vbmdvb3NlanMuY29tL2RvY3MvZ3VpZGUuaHRtbCNzdGF0aWNzXG4gKi9cblxuU2NoZW1hLnByb3RvdHlwZS5zdGF0aWMgPSBmdW5jdGlvbihuYW1lLCBmbikge1xuICBpZiAodHlwZW9mIG5hbWUgIT09ICdzdHJpbmcnKSB7XG4gICAgZm9yIChjb25zdCBpIGluIG5hbWUpIHtcbiAgICAgIHRoaXMuc3RhdGljc1tpXSA9IG5hbWVbaV07XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHRoaXMuc3RhdGljc1tuYW1lXSA9IGZuO1xuICB9XG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBEZWZpbmVzIGFuIGluZGV4IChtb3N0IGxpa2VseSBjb21wb3VuZCkgZm9yIHRoaXMgc2NoZW1hLlxuICpcbiAqICMjIyMgRXhhbXBsZTpcbiAqXG4gKiAgICAgc2NoZW1hLmluZGV4KHsgZmlyc3Q6IDEsIGxhc3Q6IC0xIH0pXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IGZpZWxkcyBUaGUgRmllbGRzIHRvIGluZGV4LCB3aXRoIHRoZSBvcmRlciwgYXZhaWxhYmxlIHZhbHVlczogYDEgfCAtMSB8ICcyZCcgfCAnMmRzcGhlcmUnIHwgJ2dlb0hheXN0YWNrJyB8ICdoYXNoZWQnIHwgJ3RleHQnYFxuICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSBPcHRpb25zIHRvIHBhc3MgdG8gW01vbmdvREIgZHJpdmVyJ3MgYGNyZWF0ZUluZGV4KClgIGZ1bmN0aW9uXShodHRwczovL21vbmdvZGIuZ2l0aHViLmlvL25vZGUtbW9uZ29kYi1uYXRpdmUvNC45L2NsYXNzZXMvQ29sbGVjdGlvbi5odG1sI2NyZWF0ZUluZGV4KVxuICogQHBhcmFtIHtTdHJpbmcgfCBudW1iZXJ9IFtvcHRpb25zLmV4cGlyZXM9bnVsbF0gTW9uZ29vc2Utc3BlY2lmaWMgc3ludGFjdGljIHN1Z2FyLCB1c2VzIFttc10oaHR0cHM6Ly93d3cubnBtanMuY29tL3BhY2thZ2UvbXMpIHRvIGNvbnZlcnQgYGV4cGlyZXNgIG9wdGlvbiBpbnRvIHNlY29uZHMgZm9yIHRoZSBgZXhwaXJlQWZ0ZXJTZWNvbmRzYCBpbiB0aGUgYWJvdmUgbGluay5cbiAqIEBwYXJhbSB7U3RyaW5nfSBbb3B0aW9ucy5sYW5ndWFnZV9vdmVycmlkZT1udWxsXSBUZWxscyBtb25nb2RiIHRvIHVzZSB0aGUgc3BlY2lmaWVkIGZpZWxkIGluc3RlYWQgb2YgYGxhbmd1YWdlYCBmb3IgcGFyc2luZyB0ZXh0IGluZGV4ZXMuXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cblNjaGVtYS5wcm90b3R5cGUuaW5kZXggPSBmdW5jdGlvbihmaWVsZHMsIG9wdGlvbnMpIHtcbiAgZmllbGRzIHx8IChmaWVsZHMgPSB7fSk7XG4gIG9wdGlvbnMgfHwgKG9wdGlvbnMgPSB7fSk7XG5cbiAgaWYgKG9wdGlvbnMuZXhwaXJlcykge1xuICAgIHV0aWxzLmV4cGlyZXMob3B0aW9ucyk7XG4gIH1cbiAgZm9yIChjb25zdCBrZXkgaW4gZmllbGRzKSB7XG4gICAgaWYgKHRoaXMuYWxpYXNlc1trZXldKSB7XG4gICAgICBmaWVsZHMgPSB1dGlscy5yZW5hbWVPYmpLZXkoZmllbGRzLCBrZXksIHRoaXMuYWxpYXNlc1trZXldKTtcbiAgICB9XG4gIH1cbiAgZm9yIChjb25zdCBmaWVsZCBvZiBPYmplY3Qua2V5cyhmaWVsZHMpKSB7XG4gICAgaWYgKGZpZWxkc1tmaWVsZF0gPT09ICdhc2NlbmRpbmcnIHx8IGZpZWxkc1tmaWVsZF0gPT09ICdhc2MnKSB7XG4gICAgICBmaWVsZHNbZmllbGRdID0gMTtcbiAgICB9IGVsc2UgaWYgKGZpZWxkc1tmaWVsZF0gPT09ICdkZXNjZW5kaW5nJyB8fCBmaWVsZHNbZmllbGRdID09PSAnZGVzYycpIHtcbiAgICAgIGZpZWxkc1tmaWVsZF0gPSAtMTtcbiAgICB9XG4gIH1cblxuICB0aGlzLl9pbmRleGVzLnB1c2goW2ZpZWxkcywgb3B0aW9uc10pO1xuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogU2V0cyBhIHNjaGVtYSBvcHRpb24uXG4gKlxuICogIyMjIyBFeGFtcGxlOlxuICpcbiAqICAgICBzY2hlbWEuc2V0KCdzdHJpY3QnKTsgLy8gJ3RydWUnIGJ5IGRlZmF1bHRcbiAqICAgICBzY2hlbWEuc2V0KCdzdHJpY3QnLCBmYWxzZSk7IC8vIFNldHMgJ3N0cmljdCcgdG8gZmFsc2VcbiAqICAgICBzY2hlbWEuc2V0KCdzdHJpY3QnKTsgLy8gJ2ZhbHNlJ1xuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBrZXkgVGhlIG5hbWUgb2YgdGhlIG9wdGlvbiB0byBzZXQgdGhlIHZhbHVlIHRvXG4gKiBAcGFyYW0ge09iamVjdH0gW3ZhbHVlXSBUaGUgdmFsdWUgdG8gc2V0IHRoZSBvcHRpb24gdG8sIGlmIG5vdCBwYXNzZWQsIHRoZSBvcHRpb24gd2lsbCBiZSByZXNldCB0byBkZWZhdWx0XG4gKiBAcGFyYW0ge0FycmF5PHN0cmluZz59IFt0YWdzXSB0YWdzIHRvIGFkZCB0byByZWFkIHByZWZlcmVuY2UgaWYga2V5ID09PSAncmVhZCdcbiAqIEBzZWUgU2NoZW1hIGh0dHBzOi8vbW9uZ29vc2Vqcy5jb20vZG9jcy9hcGkvc2NoZW1hLmh0bWwjU2NoZW1hKClcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuU2NoZW1hLnByb3RvdHlwZS5zZXQgPSBmdW5jdGlvbihrZXksIHZhbHVlLCB0YWdzKSB7XG4gIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAxKSB7XG4gICAgcmV0dXJuIHRoaXMub3B0aW9uc1trZXldO1xuICB9XG5cbiAgc3dpdGNoIChrZXkpIHtcbiAgICBjYXNlICdyZWFkJzpcbiAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHRoaXMub3B0aW9uc1trZXldID0geyBtb2RlOiBoYW5kbGVSZWFkUHJlZmVyZW5jZUFsaWFzZXModmFsdWUpLCB0YWdzIH07XG4gICAgICB9IGVsc2UgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUpICYmIHR5cGVvZiB2YWx1ZVswXSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgdGhpcy5vcHRpb25zW2tleV0gPSB7XG4gICAgICAgICAgbW9kZTogaGFuZGxlUmVhZFByZWZlcmVuY2VBbGlhc2VzKHZhbHVlWzBdKSxcbiAgICAgICAgICB0YWdzOiB2YWx1ZVsxXVxuICAgICAgICB9O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5vcHRpb25zW2tleV0gPSB2YWx1ZTtcbiAgICAgIH1cbiAgICAgIHRoaXMuX3VzZXJQcm92aWRlZE9wdGlvbnNba2V5XSA9IHRoaXMub3B0aW9uc1trZXldO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAndGltZXN0YW1wcyc6XG4gICAgICB0aGlzLnNldHVwVGltZXN0YW1wKHZhbHVlKTtcbiAgICAgIHRoaXMub3B0aW9uc1trZXldID0gdmFsdWU7XG4gICAgICB0aGlzLl91c2VyUHJvdmlkZWRPcHRpb25zW2tleV0gPSB0aGlzLm9wdGlvbnNba2V5XTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgJ19pZCc6XG4gICAgICB0aGlzLm9wdGlvbnNba2V5XSA9IHZhbHVlO1xuICAgICAgdGhpcy5fdXNlclByb3ZpZGVkT3B0aW9uc1trZXldID0gdGhpcy5vcHRpb25zW2tleV07XG5cbiAgICAgIGlmICh2YWx1ZSAmJiAhdGhpcy5wYXRoc1snX2lkJ10pIHtcbiAgICAgICAgYWRkQXV0b0lkKHRoaXMpO1xuICAgICAgfSBlbHNlIGlmICghdmFsdWUgJiYgdGhpcy5wYXRoc1snX2lkJ10gIT0gbnVsbCAmJiB0aGlzLnBhdGhzWydfaWQnXS5hdXRvKSB7XG4gICAgICAgIHRoaXMucmVtb3ZlKCdfaWQnKTtcbiAgICAgIH1cbiAgICAgIGJyZWFrO1xuICAgIGRlZmF1bHQ6XG4gICAgICB0aGlzLm9wdGlvbnNba2V5XSA9IHZhbHVlO1xuICAgICAgdGhpcy5fdXNlclByb3ZpZGVkT3B0aW9uc1trZXldID0gdGhpcy5vcHRpb25zW2tleV07XG4gICAgICBicmVhaztcbiAgfVxuXG4gIC8vIFByb3BhZ2F0ZSBgc3RyaWN0YCBhbmQgYHN0cmljdFF1ZXJ5YCBjaGFuZ2VzIGRvd24gdG8gaW1wbGljaXRseSBjcmVhdGVkIHNjaGVtYXNcbiAgaWYgKGtleSA9PT0gJ3N0cmljdCcpIHtcbiAgICBfcHJvcGFnYXRlT3B0aW9uc1RvSW1wbGljaXRseUNyZWF0ZWRTY2hlbWFzKHRoaXMsIHsgc3RyaWN0OiB2YWx1ZSB9KTtcbiAgfVxuICBpZiAoa2V5ID09PSAnc3RyaWN0UXVlcnknKSB7XG4gICAgX3Byb3BhZ2F0ZU9wdGlvbnNUb0ltcGxpY2l0bHlDcmVhdGVkU2NoZW1hcyh0aGlzLCB7IHN0cmljdFF1ZXJ5OiB2YWx1ZSB9KTtcbiAgfVxuXG4gIHJldHVybiB0aGlzO1xufTtcblxuLyohXG4gKiBSZWN1cnNpdmVseSBzZXQgb3B0aW9ucyBvbiBpbXBsaWNpdGx5IGNyZWF0ZWQgc2NoZW1hc1xuICovXG5cbmZ1bmN0aW9uIF9wcm9wYWdhdGVPcHRpb25zVG9JbXBsaWNpdGx5Q3JlYXRlZFNjaGVtYXMoYmFzZVNjaGVtYSwgb3B0aW9ucykge1xuICBmb3IgKGNvbnN0IHsgc2NoZW1hIH0gb2YgYmFzZVNjaGVtYS5jaGlsZFNjaGVtYXMpIHtcbiAgICBpZiAoIXNjaGVtYS4kaW1wbGljaXRseUNyZWF0ZWQpIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICBPYmplY3QuYXNzaWduKHNjaGVtYS5vcHRpb25zLCBvcHRpb25zKTtcbiAgICBfcHJvcGFnYXRlT3B0aW9uc1RvSW1wbGljaXRseUNyZWF0ZWRTY2hlbWFzKHNjaGVtYSwgb3B0aW9ucyk7XG4gIH1cbn1cblxuLyoqXG4gKiBHZXRzIGEgc2NoZW1hIG9wdGlvbi5cbiAqXG4gKiAjIyMjIEV4YW1wbGU6XG4gKlxuICogICAgIHNjaGVtYS5nZXQoJ3N0cmljdCcpOyAvLyB0cnVlXG4gKiAgICAgc2NoZW1hLnNldCgnc3RyaWN0JywgZmFsc2UpO1xuICogICAgIHNjaGVtYS5nZXQoJ3N0cmljdCcpOyAvLyBmYWxzZVxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBrZXkgVGhlIG5hbWUgb2YgdGhlIE9wdGlvbiB0byBnZXQgdGhlIGN1cnJlbnQgdmFsdWUgZm9yXG4gKiBAYXBpIHB1YmxpY1xuICogQHJldHVybiB7QW55fSB0aGUgb3B0aW9uJ3MgdmFsdWVcbiAqL1xuXG5TY2hlbWEucHJvdG90eXBlLmdldCA9IGZ1bmN0aW9uKGtleSkge1xuICByZXR1cm4gdGhpcy5vcHRpb25zW2tleV07XG59O1xuXG5jb25zdCBpbmRleFR5cGVzID0gJzJkIDJkc3BoZXJlIGhhc2hlZCB0ZXh0Jy5zcGxpdCgnICcpO1xuXG4vKipcbiAqIFRoZSBhbGxvd2VkIGluZGV4IHR5cGVzXG4gKlxuICogQHByb3BlcnR5IHtTdHJpbmdbXX0gaW5kZXhUeXBlc1xuICogQG1lbWJlck9mIFNjaGVtYVxuICogQHN0YXRpY1xuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoU2NoZW1hLCAnaW5kZXhUeXBlcycsIHtcbiAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gaW5kZXhUeXBlcztcbiAgfSxcbiAgc2V0OiBmdW5jdGlvbigpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0Nhbm5vdCBvdmVyd3JpdGUgU2NoZW1hLmluZGV4VHlwZXMnKTtcbiAgfVxufSk7XG5cbi8qKlxuICogUmV0dXJucyBhIGxpc3Qgb2YgaW5kZXhlcyB0aGF0IHRoaXMgc2NoZW1hIGRlY2xhcmVzLCB2aWEgYHNjaGVtYS5pbmRleCgpYCBvciBieSBgaW5kZXg6IHRydWVgIGluIGEgcGF0aCdzIG9wdGlvbnMuXG4gKiBJbmRleGVzIGFyZSBleHByZXNzZWQgYXMgYW4gYXJyYXkgYFtzcGVjLCBvcHRpb25zXWAuXG4gKlxuICogIyMjIyBFeGFtcGxlOlxuICpcbiAqICAgICBjb25zdCB1c2VyU2NoZW1hID0gbmV3IFNjaGVtYSh7XG4gKiAgICAgICBlbWFpbDogeyB0eXBlOiBTdHJpbmcsIHJlcXVpcmVkOiB0cnVlLCB1bmlxdWU6IHRydWUgfSxcbiAqICAgICAgIHJlZ2lzdGVyZWRBdDogeyB0eXBlOiBEYXRlLCBpbmRleDogdHJ1ZSB9XG4gKiAgICAgfSk7XG4gKlxuICogICAgIC8vIFsgWyB7IGVtYWlsOiAxIH0sIHsgdW5pcXVlOiB0cnVlLCBiYWNrZ3JvdW5kOiB0cnVlIH0gXSxcbiAqICAgICAvLyAgIFsgeyByZWdpc3RlcmVkQXQ6IDEgfSwgeyBiYWNrZ3JvdW5kOiB0cnVlIH0gXSBdXG4gKiAgICAgdXNlclNjaGVtYS5pbmRleGVzKCk7XG4gKlxuICogW1BsdWdpbnNdKGh0dHBzOi8vbW9uZ29vc2Vqcy5jb20vZG9jcy9wbHVnaW5zLmh0bWwpIGNhbiB1c2UgdGhlIHJldHVybiB2YWx1ZSBvZiB0aGlzIGZ1bmN0aW9uIHRvIG1vZGlmeSBhIHNjaGVtYSdzIGluZGV4ZXMuXG4gKiBGb3IgZXhhbXBsZSwgdGhlIGJlbG93IHBsdWdpbiBtYWtlcyBldmVyeSBpbmRleCB1bmlxdWUgYnkgZGVmYXVsdC5cbiAqXG4gKiAgICAgZnVuY3Rpb24gbXlQbHVnaW4oc2NoZW1hKSB7XG4gKiAgICAgICBmb3IgKGNvbnN0IGluZGV4IG9mIHNjaGVtYS5pbmRleGVzKCkpIHtcbiAqICAgICAgICAgaWYgKGluZGV4WzFdLnVuaXF1ZSA9PT0gdW5kZWZpbmVkKSB7XG4gKiAgICAgICAgICAgaW5kZXhbMV0udW5pcXVlID0gdHJ1ZTtcbiAqICAgICAgICAgfVxuICogICAgICAgfVxuICogICAgIH1cbiAqXG4gKiBAYXBpIHB1YmxpY1xuICogQHJldHVybiB7QXJyYXl9IGxpc3Qgb2YgaW5kZXhlcyBkZWZpbmVkIGluIHRoZSBzY2hlbWFcbiAqL1xuXG5TY2hlbWEucHJvdG90eXBlLmluZGV4ZXMgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIGdldEluZGV4ZXModGhpcyk7XG59O1xuXG4vKipcbiAqIENyZWF0ZXMgYSB2aXJ0dWFsIHR5cGUgd2l0aCB0aGUgZ2l2ZW4gbmFtZS5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gbmFtZSBUaGUgbmFtZSBvZiB0aGUgVmlydHVhbFxuICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXVxuICogQHBhcmFtIHtTdHJpbmd8TW9kZWx9IFtvcHRpb25zLnJlZl0gbW9kZWwgbmFtZSBvciBtb2RlbCBpbnN0YW5jZS4gTWFya3MgdGhpcyBhcyBhIFtwb3B1bGF0ZSB2aXJ0dWFsXShodHRwczovL21vbmdvb3NlanMuY29tL2RvY3MvcG9wdWxhdGUuaHRtbCNwb3B1bGF0ZS12aXJ0dWFscykuXG4gKiBAcGFyYW0ge1N0cmluZ3xGdW5jdGlvbn0gW29wdGlvbnMubG9jYWxGaWVsZF0gUmVxdWlyZWQgZm9yIHBvcHVsYXRlIHZpcnR1YWxzLiBTZWUgW3BvcHVsYXRlIHZpcnR1YWwgZG9jc10oaHR0cHM6Ly9tb25nb29zZWpzLmNvbS9kb2NzL3BvcHVsYXRlLmh0bWwjcG9wdWxhdGUtdmlydHVhbHMpIGZvciBtb3JlIGluZm9ybWF0aW9uLlxuICogQHBhcmFtIHtTdHJpbmd8RnVuY3Rpb259IFtvcHRpb25zLmZvcmVpZ25GaWVsZF0gUmVxdWlyZWQgZm9yIHBvcHVsYXRlIHZpcnR1YWxzLiBTZWUgW3BvcHVsYXRlIHZpcnR1YWwgZG9jc10oaHR0cHM6Ly9tb25nb29zZWpzLmNvbS9kb2NzL3BvcHVsYXRlLmh0bWwjcG9wdWxhdGUtdmlydHVhbHMpIGZvciBtb3JlIGluZm9ybWF0aW9uLlxuICogQHBhcmFtIHtCb29sZWFufEZ1bmN0aW9ufSBbb3B0aW9ucy5qdXN0T25lPWZhbHNlXSBPbmx5IHdvcmtzIHdpdGggcG9wdWxhdGUgdmlydHVhbHMuIElmIFt0cnV0aHldKGh0dHBzOi8vbWFzdGVyaW5nanMuaW8vdHV0b3JpYWxzL2Z1bmRhbWVudGFscy90cnV0aHkpLCB3aWxsIGJlIGEgc2luZ2xlIGRvYyBvciBgbnVsbGAuIE90aGVyd2lzZSwgdGhlIHBvcHVsYXRlIHZpcnR1YWwgd2lsbCBiZSBhbiBhcnJheS5cbiAqIEBwYXJhbSB7Qm9vbGVhbn0gW29wdGlvbnMuY291bnQ9ZmFsc2VdIE9ubHkgd29ya3Mgd2l0aCBwb3B1bGF0ZSB2aXJ0dWFscy4gSWYgW3RydXRoeV0oaHR0cHM6Ly9tYXN0ZXJpbmdqcy5pby90dXRvcmlhbHMvZnVuZGFtZW50YWxzL3RydXRoeSksIHRoaXMgcG9wdWxhdGUgdmlydHVhbCB3aWxsIGNvbnRhaW4gdGhlIG51bWJlciBvZiBkb2N1bWVudHMgcmF0aGVyIHRoYW4gdGhlIGRvY3VtZW50cyB0aGVtc2VsdmVzIHdoZW4geW91IGBwb3B1bGF0ZSgpYC5cbiAqIEBwYXJhbSB7RnVuY3Rpb258bnVsbH0gW29wdGlvbnMuZ2V0PW51bGxdIEFkZHMgYSBbZ2V0dGVyXShodHRwczovL21vbmdvb3NlanMuY29tL2RvY3MvdHV0b3JpYWxzL2dldHRlcnMtc2V0dGVycy5odG1sKSB0byB0aGlzIHZpcnR1YWwgdG8gdHJhbnNmb3JtIHRoZSBwb3B1bGF0ZWQgZG9jLlxuICogQHBhcmFtIHtPYmplY3R8RnVuY3Rpb259IFtvcHRpb25zLm1hdGNoPW51bGxdIEFwcGx5IGEgZGVmYXVsdCBbYG1hdGNoYCBvcHRpb24gdG8gcG9wdWxhdGVdKGh0dHBzOi8vbW9uZ29vc2Vqcy5jb20vZG9jcy9wb3B1bGF0ZS5odG1sI21hdGNoKSwgYWRkaW5nIGFuIGFkZGl0aW9uYWwgZmlsdGVyIHRvIHRoZSBwb3B1bGF0ZSBxdWVyeS5cbiAqIEByZXR1cm4ge1ZpcnR1YWxUeXBlfVxuICovXG5cblNjaGVtYS5wcm90b3R5cGUudmlydHVhbCA9IGZ1bmN0aW9uKG5hbWUsIG9wdGlvbnMpIHtcbiAgaWYgKG5hbWUgaW5zdGFuY2VvZiBWaXJ0dWFsVHlwZSB8fCBnZXRDb25zdHJ1Y3Rvck5hbWUobmFtZSkgPT09ICdWaXJ0dWFsVHlwZScpIHtcbiAgICByZXR1cm4gdGhpcy52aXJ0dWFsKG5hbWUucGF0aCwgbmFtZS5vcHRpb25zKTtcbiAgfVxuICBvcHRpb25zID0gbmV3IFZpcnR1YWxPcHRpb25zKG9wdGlvbnMpO1xuXG4gIGlmICh1dGlscy5oYXNVc2VyRGVmaW5lZFByb3BlcnR5KG9wdGlvbnMsIFsncmVmJywgJ3JlZlBhdGgnXSkpIHtcbiAgICBpZiAob3B0aW9ucy5sb2NhbEZpZWxkID09IG51bGwpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignUmVmZXJlbmNlIHZpcnR1YWxzIHJlcXVpcmUgYGxvY2FsRmllbGRgIG9wdGlvbicpO1xuICAgIH1cblxuICAgIGlmIChvcHRpb25zLmZvcmVpZ25GaWVsZCA9PSBudWxsKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1JlZmVyZW5jZSB2aXJ0dWFscyByZXF1aXJlIGBmb3JlaWduRmllbGRgIG9wdGlvbicpO1xuICAgIH1cblxuICAgIHRoaXMucHJlKCdpbml0JywgZnVuY3Rpb24gdmlydHVhbFByZUluaXQob2JqKSB7XG4gICAgICBpZiAobXBhdGguaGFzKG5hbWUsIG9iaikpIHtcbiAgICAgICAgY29uc3QgX3YgPSBtcGF0aC5nZXQobmFtZSwgb2JqKTtcbiAgICAgICAgaWYgKCF0aGlzLiQkcG9wdWxhdGVkVmlydHVhbHMpIHtcbiAgICAgICAgICB0aGlzLiQkcG9wdWxhdGVkVmlydHVhbHMgPSB7fTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChvcHRpb25zLmp1c3RPbmUgfHwgb3B0aW9ucy5jb3VudCkge1xuICAgICAgICAgIHRoaXMuJCRwb3B1bGF0ZWRWaXJ0dWFsc1tuYW1lXSA9IEFycmF5LmlzQXJyYXkoX3YpID9cbiAgICAgICAgICAgIF92WzBdIDpcbiAgICAgICAgICAgIF92O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMuJCRwb3B1bGF0ZWRWaXJ0dWFsc1tuYW1lXSA9IEFycmF5LmlzQXJyYXkoX3YpID9cbiAgICAgICAgICAgIF92IDpcbiAgICAgICAgICAgIF92ID09IG51bGwgPyBbXSA6IFtfdl07XG4gICAgICAgIH1cblxuICAgICAgICBtcGF0aC51bnNldChuYW1lLCBvYmopO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgY29uc3QgdmlydHVhbCA9IHRoaXMudmlydHVhbChuYW1lKTtcbiAgICB2aXJ0dWFsLm9wdGlvbnMgPSBvcHRpb25zO1xuXG4gICAgdmlydHVhbC5cbiAgICAgIHNldChmdW5jdGlvbihfdikge1xuICAgICAgICBpZiAoIXRoaXMuJCRwb3B1bGF0ZWRWaXJ0dWFscykge1xuICAgICAgICAgIHRoaXMuJCRwb3B1bGF0ZWRWaXJ0dWFscyA9IHt9O1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKG9wdGlvbnMuanVzdE9uZSB8fCBvcHRpb25zLmNvdW50KSB7XG4gICAgICAgICAgdGhpcy4kJHBvcHVsYXRlZFZpcnR1YWxzW25hbWVdID0gQXJyYXkuaXNBcnJheShfdikgP1xuICAgICAgICAgICAgX3ZbMF0gOlxuICAgICAgICAgICAgX3Y7XG5cbiAgICAgICAgICBpZiAodHlwZW9mIHRoaXMuJCRwb3B1bGF0ZWRWaXJ0dWFsc1tuYW1lXSAhPT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgIHRoaXMuJCRwb3B1bGF0ZWRWaXJ0dWFsc1tuYW1lXSA9IG9wdGlvbnMuY291bnQgPyBfdiA6IG51bGw7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMuJCRwb3B1bGF0ZWRWaXJ0dWFsc1tuYW1lXSA9IEFycmF5LmlzQXJyYXkoX3YpID9cbiAgICAgICAgICAgIF92IDpcbiAgICAgICAgICAgIF92ID09IG51bGwgPyBbXSA6IFtfdl07XG5cbiAgICAgICAgICB0aGlzLiQkcG9wdWxhdGVkVmlydHVhbHNbbmFtZV0gPSB0aGlzLiQkcG9wdWxhdGVkVmlydHVhbHNbbmFtZV0uZmlsdGVyKGZ1bmN0aW9uKGRvYykge1xuICAgICAgICAgICAgcmV0dXJuIGRvYyAmJiB0eXBlb2YgZG9jID09PSAnb2JqZWN0JztcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfSk7XG5cbiAgICBpZiAodHlwZW9mIG9wdGlvbnMuZ2V0ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICB2aXJ0dWFsLmdldChvcHRpb25zLmdldCk7XG4gICAgfVxuXG4gICAgLy8gV29ya2Fyb3VuZCBmb3IgZ2gtODE5ODogaWYgdmlydHVhbCBpcyB1bmRlciBkb2N1bWVudCBhcnJheSwgbWFrZSBhIGZha2VcbiAgICAvLyB2aXJ0dWFsLiBTZWUgZ2gtODIxMCwgZ2gtMTMxODlcbiAgICBjb25zdCBwYXJ0cyA9IG5hbWUuc3BsaXQoJy4nKTtcbiAgICBsZXQgY3VyID0gcGFydHNbMF07XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBwYXJ0cy5sZW5ndGggLSAxOyArK2kpIHtcbiAgICAgIGlmICh0aGlzLnBhdGhzW2N1cl0gPT0gbnVsbCkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgaWYgKHRoaXMucGF0aHNbY3VyXS4kaXNNb25nb29zZURvY3VtZW50QXJyYXkgfHwgdGhpcy5wYXRoc1tjdXJdLiRpc1NpbmdsZU5lc3RlZCkge1xuICAgICAgICBjb25zdCByZW1uYW50ID0gcGFydHMuc2xpY2UoaSArIDEpLmpvaW4oJy4nKTtcbiAgICAgICAgdGhpcy5wYXRoc1tjdXJdLnNjaGVtYS52aXJ0dWFsKHJlbW5hbnQsIG9wdGlvbnMpO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cblxuICAgICAgY3VyICs9ICcuJyArIHBhcnRzW2kgKyAxXTtcbiAgICB9XG5cbiAgICByZXR1cm4gdmlydHVhbDtcbiAgfVxuXG4gIGNvbnN0IHZpcnR1YWxzID0gdGhpcy52aXJ0dWFscztcbiAgY29uc3QgcGFydHMgPSBuYW1lLnNwbGl0KCcuJyk7XG5cbiAgaWYgKHRoaXMucGF0aFR5cGUobmFtZSkgPT09ICdyZWFsJykge1xuICAgIHRocm93IG5ldyBFcnJvcignVmlydHVhbCBwYXRoIFwiJyArIG5hbWUgKyAnXCInICtcbiAgICAgICcgY29uZmxpY3RzIHdpdGggYSByZWFsIHBhdGggaW4gdGhlIHNjaGVtYScpO1xuICB9XG5cbiAgdmlydHVhbHNbbmFtZV0gPSBwYXJ0cy5yZWR1Y2UoZnVuY3Rpb24obWVtLCBwYXJ0LCBpKSB7XG4gICAgbWVtW3BhcnRdIHx8IChtZW1bcGFydF0gPSAoaSA9PT0gcGFydHMubGVuZ3RoIC0gMSlcbiAgICAgID8gbmV3IFZpcnR1YWxUeXBlKG9wdGlvbnMsIG5hbWUpXG4gICAgICA6IHt9KTtcbiAgICByZXR1cm4gbWVtW3BhcnRdO1xuICB9LCB0aGlzLnRyZWUpO1xuXG4gIHJldHVybiB2aXJ0dWFsc1tuYW1lXTtcbn07XG5cbi8qKlxuICogUmV0dXJucyB0aGUgdmlydHVhbCB0eXBlIHdpdGggdGhlIGdpdmVuIGBuYW1lYC5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gbmFtZSBUaGUgbmFtZSBvZiB0aGUgVmlydHVhbCB0byBnZXRcbiAqIEByZXR1cm4ge1ZpcnR1YWxUeXBlfG51bGx9XG4gKi9cblxuU2NoZW1hLnByb3RvdHlwZS52aXJ0dWFscGF0aCA9IGZ1bmN0aW9uKG5hbWUpIHtcbiAgcmV0dXJuIHRoaXMudmlydHVhbHMuaGFzT3duUHJvcGVydHkobmFtZSkgPyB0aGlzLnZpcnR1YWxzW25hbWVdIDogbnVsbDtcbn07XG5cbi8qKlxuICogUmVtb3ZlcyB0aGUgZ2l2ZW4gYHBhdGhgIChvciBbYHBhdGhzYF0pLlxuICpcbiAqICMjIyMgRXhhbXBsZTpcbiAqXG4gKiAgICAgY29uc3Qgc2NoZW1hID0gbmV3IFNjaGVtYSh7IG5hbWU6IFN0cmluZywgYWdlOiBOdW1iZXIgfSk7XG4gKiAgICAgc2NoZW1hLnJlbW92ZSgnbmFtZScpO1xuICogICAgIHNjaGVtYS5wYXRoKCduYW1lJyk7IC8vIFVuZGVmaW5lZFxuICogICAgIHNjaGVtYS5wYXRoKCdhZ2UnKTsgLy8gU2NoZW1hTnVtYmVyIHsgLi4uIH1cbiAqXG4gKiBPciBhcyBhIEFycmF5OlxuICpcbiAqICAgICBzY2hlbWEucmVtb3ZlKFsnbmFtZScsICdhZ2UnXSk7XG4gKiAgICAgc2NoZW1hLnBhdGgoJ25hbWUnKTsgLy8gVW5kZWZpbmVkXG4gKiAgICAgc2NoZW1hLnBhdGgoJ2FnZScpOyAvLyBVbmRlZmluZWRcbiAqXG4gKiBAcGFyYW0ge1N0cmluZ3xBcnJheX0gcGF0aCBUaGUgUGF0aChzKSB0byByZW1vdmVcbiAqIEByZXR1cm4ge1NjaGVtYX0gdGhlIFNjaGVtYSBpbnN0YW5jZVxuICogQGFwaSBwdWJsaWNcbiAqL1xuU2NoZW1hLnByb3RvdHlwZS5yZW1vdmUgPSBmdW5jdGlvbihwYXRoKSB7XG4gIGlmICh0eXBlb2YgcGF0aCA9PT0gJ3N0cmluZycpIHtcbiAgICBwYXRoID0gW3BhdGhdO1xuICB9XG4gIGlmIChBcnJheS5pc0FycmF5KHBhdGgpKSB7XG4gICAgcGF0aC5mb3JFYWNoKGZ1bmN0aW9uKG5hbWUpIHtcbiAgICAgIGlmICh0aGlzLnBhdGgobmFtZSkgPT0gbnVsbCAmJiAhdGhpcy5uZXN0ZWRbbmFtZV0pIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgaWYgKHRoaXMubmVzdGVkW25hbWVdKSB7XG4gICAgICAgIGNvbnN0IGFsbEtleXMgPSBPYmplY3Qua2V5cyh0aGlzLnBhdGhzKS5cbiAgICAgICAgICBjb25jYXQoT2JqZWN0LmtleXModGhpcy5uZXN0ZWQpKTtcbiAgICAgICAgZm9yIChjb25zdCBwYXRoIG9mIGFsbEtleXMpIHtcbiAgICAgICAgICBpZiAocGF0aC5zdGFydHNXaXRoKG5hbWUgKyAnLicpKSB7XG4gICAgICAgICAgICBkZWxldGUgdGhpcy5wYXRoc1twYXRoXTtcbiAgICAgICAgICAgIGRlbGV0ZSB0aGlzLm5lc3RlZFtwYXRoXTtcbiAgICAgICAgICAgIF9kZWxldGVQYXRoKHRoaXMsIHBhdGgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGRlbGV0ZSB0aGlzLm5lc3RlZFtuYW1lXTtcbiAgICAgICAgX2RlbGV0ZVBhdGgodGhpcywgbmFtZSk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgZGVsZXRlIHRoaXMucGF0aHNbbmFtZV07XG4gICAgICBfZGVsZXRlUGF0aCh0aGlzLCBuYW1lKTtcbiAgICB9LCB0aGlzKTtcbiAgfVxuICByZXR1cm4gdGhpcztcbn07XG5cbi8qIVxuICogaWdub3JlXG4gKi9cblxuZnVuY3Rpb24gX2RlbGV0ZVBhdGgoc2NoZW1hLCBuYW1lKSB7XG4gIGNvbnN0IHBpZWNlcyA9IG5hbWUuc3BsaXQoJy4nKTtcbiAgY29uc3QgbGFzdCA9IHBpZWNlcy5wb3AoKTtcblxuICBsZXQgYnJhbmNoID0gc2NoZW1hLnRyZWU7XG5cbiAgZm9yIChjb25zdCBwaWVjZSBvZiBwaWVjZXMpIHtcbiAgICBicmFuY2ggPSBicmFuY2hbcGllY2VdO1xuICB9XG5cbiAgZGVsZXRlIGJyYW5jaFtsYXN0XTtcbn1cblxuLyoqXG4gKiBSZW1vdmVzIHRoZSBnaXZlbiB2aXJ0dWFsIG9yIHZpcnR1YWxzIGZyb20gdGhlIHNjaGVtYS5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ3xBcnJheX0gcGF0aCBUaGUgdmlydXRhbCBwYXRoKHMpIHRvIHJlbW92ZS5cbiAqIEByZXR1cm5zIHtTY2hlbWF9IHRoZSBTY2hlbWEgaW5zdGFuY2UsIG9yIGEgbW9uZ29vc2UgZXJyb3IgaWYgdGhlIHZpcnR1YWwgZG9lcyBub3QgZXhpc3QuXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cblNjaGVtYS5wcm90b3R5cGUucmVtb3ZlVmlydHVhbCA9IGZ1bmN0aW9uKHBhdGgpIHtcbiAgaWYgKHR5cGVvZiBwYXRoID09PSAnc3RyaW5nJykge1xuICAgIHBhdGggPSBbcGF0aF07XG4gIH1cbiAgaWYgKEFycmF5LmlzQXJyYXkocGF0aCkpIHtcbiAgICBmb3IgKGNvbnN0IHZpcnR1YWwgb2YgcGF0aCkge1xuICAgICAgaWYgKHRoaXMudmlydHVhbHNbdmlydHVhbF0gPT0gbnVsbCkge1xuICAgICAgICB0aHJvdyBuZXcgTW9uZ29vc2VFcnJvcihgQXR0ZW1wdGluZyB0byByZW1vdmUgdmlydHVhbCBcIiR7dmlydHVhbH1cIiB0aGF0IGRvZXMgbm90IGV4aXN0LmApO1xuICAgICAgfVxuICAgIH1cblxuICAgIGZvciAoY29uc3QgdmlydHVhbCBvZiBwYXRoKSB7XG4gICAgICBkZWxldGUgdGhpcy5wYXRoc1t2aXJ0dWFsXTtcbiAgICAgIGRlbGV0ZSB0aGlzLnZpcnR1YWxzW3ZpcnR1YWxdO1xuICAgICAgaWYgKHZpcnR1YWwuaW5kZXhPZignLicpICE9PSAtMSkge1xuICAgICAgICBtcGF0aC51bnNldCh2aXJ0dWFsLCB0aGlzLnRyZWUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZGVsZXRlIHRoaXMudHJlZVt2aXJ0dWFsXTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIExvYWRzIGFuIEVTNiBjbGFzcyBpbnRvIGEgc2NoZW1hLiBNYXBzIFtzZXR0ZXJzXShodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9GdW5jdGlvbnMvc2V0KSArIFtnZXR0ZXJzXShodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9GdW5jdGlvbnMvZ2V0KSwgW3N0YXRpYyBtZXRob2RzXShodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9DbGFzc2VzL3N0YXRpYyksXG4gKiBhbmQgW2luc3RhbmNlIG1ldGhvZHNdKGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0NsYXNzZXMjQ2xhc3NfYm9keV9hbmRfbWV0aG9kX2RlZmluaXRpb25zKVxuICogdG8gc2NoZW1hIFt2aXJ0dWFsc10oaHR0cHM6Ly9tb25nb29zZWpzLmNvbS9kb2NzL2d1aWRlLmh0bWwjdmlydHVhbHMpLFxuICogW3N0YXRpY3NdKGh0dHBzOi8vbW9uZ29vc2Vqcy5jb20vZG9jcy9ndWlkZS5odG1sI3N0YXRpY3MpLCBhbmRcbiAqIFttZXRob2RzXShodHRwczovL21vbmdvb3NlanMuY29tL2RvY3MvZ3VpZGUuaHRtbCNtZXRob2RzKS5cbiAqXG4gKiAjIyMjIEV4YW1wbGU6XG4gKlxuICogYGBgamF2YXNjcmlwdFxuICogY29uc3QgbWQ1ID0gcmVxdWlyZSgnbWQ1Jyk7XG4gKiBjb25zdCB1c2VyU2NoZW1hID0gbmV3IFNjaGVtYSh7IGVtYWlsOiBTdHJpbmcgfSk7XG4gKiBjbGFzcyBVc2VyQ2xhc3Mge1xuICogICAvLyBgZ3JhdmF0YXJJbWFnZWAgYmVjb21lcyBhIHZpcnR1YWxcbiAqICAgZ2V0IGdyYXZhdGFySW1hZ2UoKSB7XG4gKiAgICAgY29uc3QgaGFzaCA9IG1kNSh0aGlzLmVtYWlsLnRvTG93ZXJDYXNlKCkpO1xuICogICAgIHJldHVybiBgaHR0cHM6Ly93d3cuZ3JhdmF0YXIuY29tL2F2YXRhci8ke2hhc2h9YDtcbiAqICAgfVxuICpcbiAqICAgLy8gYGdldFByb2ZpbGVVcmwoKWAgYmVjb21lcyBhIGRvY3VtZW50IG1ldGhvZFxuICogICBnZXRQcm9maWxlVXJsKCkge1xuICogICAgIHJldHVybiBgaHR0cHM6Ly9teXNpdGUuY29tLyR7dGhpcy5lbWFpbH1gO1xuICogICB9XG4gKlxuICogICAvLyBgZmluZEJ5RW1haWwoKWAgYmVjb21lcyBhIHN0YXRpY1xuICogICBzdGF0aWMgZmluZEJ5RW1haWwoZW1haWwpIHtcbiAqICAgICByZXR1cm4gdGhpcy5maW5kT25lKHsgZW1haWwgfSk7XG4gKiAgIH1cbiAqIH1cbiAqXG4gKiAvLyBgc2NoZW1hYCB3aWxsIG5vdyBoYXZlIGEgYGdyYXZhdGFySW1hZ2VgIHZpcnR1YWwsIGEgYGdldFByb2ZpbGVVcmwoKWAgbWV0aG9kLFxuICogLy8gYW5kIGEgYGZpbmRCeUVtYWlsKClgIHN0YXRpY1xuICogdXNlclNjaGVtYS5sb2FkQ2xhc3MoVXNlckNsYXNzKTtcbiAqIGBgYFxuICpcbiAqIEBwYXJhbSB7RnVuY3Rpb259IG1vZGVsIFRoZSBDbGFzcyB0byBsb2FkXG4gKiBAcGFyYW0ge0Jvb2xlYW59IFt2aXJ0dWFsc09ubHldIGlmIHRydXRoeSwgb25seSBwdWxscyB2aXJ0dWFscyBmcm9tIHRoZSBjbGFzcywgbm90IG1ldGhvZHMgb3Igc3RhdGljc1xuICovXG5TY2hlbWEucHJvdG90eXBlLmxvYWRDbGFzcyA9IGZ1bmN0aW9uKG1vZGVsLCB2aXJ0dWFsc09ubHkpIHtcbiAgLy8gU3RvcCBjb3B5aW5nIHdoZW4gaGl0IGNlcnRhaW4gYmFzZSBjbGFzc2VzXG4gIGlmIChtb2RlbCA9PT0gT2JqZWN0LnByb3RvdHlwZSB8fFxuICAgICAgbW9kZWwgPT09IEZ1bmN0aW9uLnByb3RvdHlwZSB8fFxuICAgICAgbW9kZWwucHJvdG90eXBlLmhhc093blByb3BlcnR5KCckaXNNb25nb29zZU1vZGVsUHJvdG90eXBlJykgfHxcbiAgICAgIG1vZGVsLnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eSgnJGlzTW9uZ29vc2VEb2N1bWVudFByb3RvdHlwZScpKSB7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICB0aGlzLmxvYWRDbGFzcyhPYmplY3QuZ2V0UHJvdG90eXBlT2YobW9kZWwpLCB2aXJ0dWFsc09ubHkpO1xuXG4gIC8vIEFkZCBzdGF0aWMgbWV0aG9kc1xuICBpZiAoIXZpcnR1YWxzT25seSkge1xuICAgIE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKG1vZGVsKS5mb3JFYWNoKGZ1bmN0aW9uKG5hbWUpIHtcbiAgICAgIGlmIChuYW1lLm1hdGNoKC9eKGxlbmd0aHxuYW1lfHByb3RvdHlwZXxjb25zdHJ1Y3RvcnxfX3Byb3RvX18pJC8pKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHByb3AgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG1vZGVsLCBuYW1lKTtcbiAgICAgIGlmIChwcm9wLmhhc093blByb3BlcnR5KCd2YWx1ZScpKSB7XG4gICAgICAgIHRoaXMuc3RhdGljKG5hbWUsIHByb3AudmFsdWUpO1xuICAgICAgfVxuICAgIH0sIHRoaXMpO1xuICB9XG5cbiAgLy8gQWRkIG1ldGhvZHMgYW5kIHZpcnR1YWxzXG4gIE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKG1vZGVsLnByb3RvdHlwZSkuZm9yRWFjaChmdW5jdGlvbihuYW1lKSB7XG4gICAgaWYgKG5hbWUubWF0Y2goL14oY29uc3RydWN0b3IpJC8pKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IG1ldGhvZCA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IobW9kZWwucHJvdG90eXBlLCBuYW1lKTtcbiAgICBpZiAoIXZpcnR1YWxzT25seSkge1xuICAgICAgaWYgKHR5cGVvZiBtZXRob2QudmFsdWUgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgdGhpcy5tZXRob2QobmFtZSwgbWV0aG9kLnZhbHVlKTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKHR5cGVvZiBtZXRob2QuZ2V0ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBpZiAodGhpcy52aXJ0dWFsc1tuYW1lXSkge1xuICAgICAgICB0aGlzLnZpcnR1YWxzW25hbWVdLmdldHRlcnMgPSBbXTtcbiAgICAgIH1cbiAgICAgIHRoaXMudmlydHVhbChuYW1lKS5nZXQobWV0aG9kLmdldCk7XG4gICAgfVxuICAgIGlmICh0eXBlb2YgbWV0aG9kLnNldCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgaWYgKHRoaXMudmlydHVhbHNbbmFtZV0pIHtcbiAgICAgICAgdGhpcy52aXJ0dWFsc1tuYW1lXS5zZXR0ZXJzID0gW107XG4gICAgICB9XG4gICAgICB0aGlzLnZpcnR1YWwobmFtZSkuc2V0KG1ldGhvZC5zZXQpO1xuICAgIH1cbiAgfSwgdGhpcyk7XG5cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKiFcbiAqIGlnbm9yZVxuICovXG5cblNjaGVtYS5wcm90b3R5cGUuX2dldFNjaGVtYSA9IGZ1bmN0aW9uKHBhdGgpIHtcbiAgY29uc3QgX3RoaXMgPSB0aGlzO1xuICBjb25zdCBwYXRoc2NoZW1hID0gX3RoaXMucGF0aChwYXRoKTtcbiAgY29uc3QgcmVzdWx0UGF0aCA9IFtdO1xuXG4gIGlmIChwYXRoc2NoZW1hKSB7XG4gICAgcGF0aHNjaGVtYS4kZnVsbFBhdGggPSBwYXRoO1xuICAgIHJldHVybiBwYXRoc2NoZW1hO1xuICB9XG5cbiAgZnVuY3Rpb24gc2VhcmNoKHBhcnRzLCBzY2hlbWEpIHtcbiAgICBsZXQgcCA9IHBhcnRzLmxlbmd0aCArIDE7XG4gICAgbGV0IGZvdW5kc2NoZW1hO1xuICAgIGxldCB0cnlwYXRoO1xuXG4gICAgd2hpbGUgKHAtLSkge1xuICAgICAgdHJ5cGF0aCA9IHBhcnRzLnNsaWNlKDAsIHApLmpvaW4oJy4nKTtcbiAgICAgIGZvdW5kc2NoZW1hID0gc2NoZW1hLnBhdGgodHJ5cGF0aCk7XG4gICAgICBpZiAoZm91bmRzY2hlbWEpIHtcbiAgICAgICAgcmVzdWx0UGF0aC5wdXNoKHRyeXBhdGgpO1xuXG4gICAgICAgIGlmIChmb3VuZHNjaGVtYS5jYXN0ZXIpIHtcbiAgICAgICAgICAvLyBhcnJheSBvZiBNaXhlZD9cbiAgICAgICAgICBpZiAoZm91bmRzY2hlbWEuY2FzdGVyIGluc3RhbmNlb2YgTW9uZ29vc2VUeXBlcy5NaXhlZCkge1xuICAgICAgICAgICAgZm91bmRzY2hlbWEuY2FzdGVyLiRmdWxsUGF0aCA9IHJlc3VsdFBhdGguam9pbignLicpO1xuICAgICAgICAgICAgcmV0dXJuIGZvdW5kc2NoZW1hLmNhc3RlcjtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICAvLyBOb3cgdGhhdCB3ZSBmb3VuZCB0aGUgYXJyYXksIHdlIG5lZWQgdG8gY2hlY2sgaWYgdGhlcmVcbiAgICAgICAgICAvLyBhcmUgcmVtYWluaW5nIGRvY3VtZW50IHBhdGhzIHRvIGxvb2sgdXAgZm9yIGNhc3RpbmcuXG4gICAgICAgICAgLy8gQWxzbyB3ZSBuZWVkIHRvIGhhbmRsZSBhcnJheS4kLnBhdGggc2luY2Ugc2NoZW1hLnBhdGhcbiAgICAgICAgICAvLyBkb2Vzbid0IHdvcmsgZm9yIHRoYXQuXG4gICAgICAgICAgLy8gSWYgdGhlcmUgaXMgbm8gZm91bmRzY2hlbWEuc2NoZW1hIHdlIGFyZSBkZWFsaW5nIHdpdGhcbiAgICAgICAgICAvLyBhIHBhdGggbGlrZSBhcnJheS4kXG4gICAgICAgICAgaWYgKHAgIT09IHBhcnRzLmxlbmd0aCkge1xuICAgICAgICAgICAgaWYgKGZvdW5kc2NoZW1hLnNjaGVtYSkge1xuICAgICAgICAgICAgICBsZXQgcmV0O1xuICAgICAgICAgICAgICBpZiAocGFydHNbcF0gPT09ICckJyB8fCBpc0FycmF5RmlsdGVyKHBhcnRzW3BdKSkge1xuICAgICAgICAgICAgICAgIGlmIChwICsgMSA9PT0gcGFydHMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAvLyBjb21tZW50cy4kXG4gICAgICAgICAgICAgICAgICByZXR1cm4gZm91bmRzY2hlbWEuJGVtYmVkZGVkU2NoZW1hVHlwZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gY29tbWVudHMuJC5jb21tZW50cy4kLnRpdGxlXG4gICAgICAgICAgICAgICAgcmV0ID0gc2VhcmNoKHBhcnRzLnNsaWNlKHAgKyAxKSwgZm91bmRzY2hlbWEuc2NoZW1hKTtcbiAgICAgICAgICAgICAgICBpZiAocmV0KSB7XG4gICAgICAgICAgICAgICAgICByZXQuJHBhcmVudFNjaGVtYURvY0FycmF5ID0gcmV0LiRwYXJlbnRTY2hlbWFEb2NBcnJheSB8fFxuICAgICAgICAgICAgICAgICAgICAoZm91bmRzY2hlbWEuc2NoZW1hLiRpc1NpbmdsZU5lc3RlZCA/IG51bGwgOiBmb3VuZHNjaGVtYSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiByZXQ7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgLy8gdGhpcyBpcyB0aGUgbGFzdCBwYXRoIG9mIHRoZSBzZWxlY3RvclxuICAgICAgICAgICAgICByZXQgPSBzZWFyY2gocGFydHMuc2xpY2UocCksIGZvdW5kc2NoZW1hLnNjaGVtYSk7XG4gICAgICAgICAgICAgIGlmIChyZXQpIHtcbiAgICAgICAgICAgICAgICByZXQuJHBhcmVudFNjaGVtYURvY0FycmF5ID0gcmV0LiRwYXJlbnRTY2hlbWFEb2NBcnJheSB8fFxuICAgICAgICAgICAgICAgICAgKGZvdW5kc2NoZW1hLnNjaGVtYS4kaXNTaW5nbGVOZXN0ZWQgPyBudWxsIDogZm91bmRzY2hlbWEpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHJldHVybiByZXQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKGZvdW5kc2NoZW1hLiRpc1NjaGVtYU1hcCkge1xuICAgICAgICAgIGlmIChwID49IHBhcnRzLmxlbmd0aCkge1xuICAgICAgICAgICAgcmV0dXJuIGZvdW5kc2NoZW1hO1xuICAgICAgICAgIH1cbiAgICAgICAgICAvLyBBbnkgcGF0aCBpbiB0aGUgbWFwIHdpbGwgYmUgYW4gaW5zdGFuY2Ugb2YgdGhlIG1hcCdzIGVtYmVkZGVkIHNjaGVtYXR5cGVcbiAgICAgICAgICBpZiAocCArIDEgPj0gcGFydHMubGVuZ3RoKSB7XG4gICAgICAgICAgICByZXR1cm4gZm91bmRzY2hlbWEuJF9fc2NoZW1hVHlwZTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoZm91bmRzY2hlbWEuJF9fc2NoZW1hVHlwZSBpbnN0YW5jZW9mIE1vbmdvb3NlVHlwZXMuTWl4ZWQpIHtcbiAgICAgICAgICAgIHJldHVybiBmb3VuZHNjaGVtYS4kX19zY2hlbWFUeXBlO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoZm91bmRzY2hlbWEuJF9fc2NoZW1hVHlwZS5zY2hlbWEgIT0gbnVsbCkge1xuICAgICAgICAgICAgLy8gTWFwIG9mIGRvY3NcbiAgICAgICAgICAgIGNvbnN0IHJldCA9IHNlYXJjaChwYXJ0cy5zbGljZShwICsgMSksIGZvdW5kc2NoZW1hLiRfX3NjaGVtYVR5cGUuc2NoZW1hKTtcbiAgICAgICAgICAgIHJldHVybiByZXQ7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgZm91bmRzY2hlbWEuJGZ1bGxQYXRoID0gcmVzdWx0UGF0aC5qb2luKCcuJyk7XG5cbiAgICAgICAgcmV0dXJuIGZvdW5kc2NoZW1hO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8vIGxvb2sgZm9yIGFycmF5c1xuICBjb25zdCBwYXJ0cyA9IHBhdGguc3BsaXQoJy4nKTtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBwYXJ0cy5sZW5ndGg7ICsraSkge1xuICAgIGlmIChwYXJ0c1tpXSA9PT0gJyQnIHx8IGlzQXJyYXlGaWx0ZXIocGFydHNbaV0pKSB7XG4gICAgICAvLyBSZTogZ2gtNTYyOCwgYmVjYXVzZSBgc2NoZW1hLnBhdGgoKWAgZG9lc24ndCB0YWtlICQgaW50byBhY2NvdW50LlxuICAgICAgcGFydHNbaV0gPSAnMCc7XG4gICAgfVxuICAgIGlmIChudW1iZXJSRS50ZXN0KHBhcnRzW2ldKSkge1xuICAgICAgcGFydHNbaV0gPSAnJCc7XG4gICAgfVxuICB9XG4gIHJldHVybiBzZWFyY2gocGFydHMsIF90aGlzKTtcbn07XG5cbi8qIVxuICogaWdub3JlXG4gKi9cblxuU2NoZW1hLnByb3RvdHlwZS5fZ2V0UGF0aFR5cGUgPSBmdW5jdGlvbihwYXRoKSB7XG4gIGNvbnN0IF90aGlzID0gdGhpcztcbiAgY29uc3QgcGF0aHNjaGVtYSA9IF90aGlzLnBhdGgocGF0aCk7XG5cbiAgaWYgKHBhdGhzY2hlbWEpIHtcbiAgICByZXR1cm4gJ3JlYWwnO1xuICB9XG5cbiAgZnVuY3Rpb24gc2VhcmNoKHBhcnRzLCBzY2hlbWEpIHtcbiAgICBsZXQgcCA9IHBhcnRzLmxlbmd0aCArIDEsXG4gICAgICAgIGZvdW5kc2NoZW1hLFxuICAgICAgICB0cnlwYXRoO1xuXG4gICAgd2hpbGUgKHAtLSkge1xuICAgICAgdHJ5cGF0aCA9IHBhcnRzLnNsaWNlKDAsIHApLmpvaW4oJy4nKTtcbiAgICAgIGZvdW5kc2NoZW1hID0gc2NoZW1hLnBhdGgodHJ5cGF0aCk7XG4gICAgICBpZiAoZm91bmRzY2hlbWEpIHtcbiAgICAgICAgaWYgKGZvdW5kc2NoZW1hLmNhc3Rlcikge1xuICAgICAgICAgIC8vIGFycmF5IG9mIE1peGVkP1xuICAgICAgICAgIGlmIChmb3VuZHNjaGVtYS5jYXN0ZXIgaW5zdGFuY2VvZiBNb25nb29zZVR5cGVzLk1peGVkKSB7XG4gICAgICAgICAgICByZXR1cm4geyBzY2hlbWE6IGZvdW5kc2NoZW1hLCBwYXRoVHlwZTogJ21peGVkJyB9O1xuICAgICAgICAgIH1cblxuICAgICAgICAgIC8vIE5vdyB0aGF0IHdlIGZvdW5kIHRoZSBhcnJheSwgd2UgbmVlZCB0byBjaGVjayBpZiB0aGVyZVxuICAgICAgICAgIC8vIGFyZSByZW1haW5pbmcgZG9jdW1lbnQgcGF0aHMgdG8gbG9vayB1cCBmb3IgY2FzdGluZy5cbiAgICAgICAgICAvLyBBbHNvIHdlIG5lZWQgdG8gaGFuZGxlIGFycmF5LiQucGF0aCBzaW5jZSBzY2hlbWEucGF0aFxuICAgICAgICAgIC8vIGRvZXNuJ3Qgd29yayBmb3IgdGhhdC5cbiAgICAgICAgICAvLyBJZiB0aGVyZSBpcyBubyBmb3VuZHNjaGVtYS5zY2hlbWEgd2UgYXJlIGRlYWxpbmcgd2l0aFxuICAgICAgICAgIC8vIGEgcGF0aCBsaWtlIGFycmF5LiRcbiAgICAgICAgICBpZiAocCAhPT0gcGFydHMubGVuZ3RoICYmIGZvdW5kc2NoZW1hLnNjaGVtYSkge1xuICAgICAgICAgICAgaWYgKHBhcnRzW3BdID09PSAnJCcgfHwgaXNBcnJheUZpbHRlcihwYXJ0c1twXSkpIHtcbiAgICAgICAgICAgICAgaWYgKHAgPT09IHBhcnRzLmxlbmd0aCAtIDEpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4geyBzY2hlbWE6IGZvdW5kc2NoZW1hLCBwYXRoVHlwZTogJ25lc3RlZCcgfTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAvLyBjb21tZW50cy4kLmNvbW1lbnRzLiQudGl0bGVcbiAgICAgICAgICAgICAgcmV0dXJuIHNlYXJjaChwYXJ0cy5zbGljZShwICsgMSksIGZvdW5kc2NoZW1hLnNjaGVtYSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyB0aGlzIGlzIHRoZSBsYXN0IHBhdGggb2YgdGhlIHNlbGVjdG9yXG4gICAgICAgICAgICByZXR1cm4gc2VhcmNoKHBhcnRzLnNsaWNlKHApLCBmb3VuZHNjaGVtYS5zY2hlbWEpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgc2NoZW1hOiBmb3VuZHNjaGVtYSxcbiAgICAgICAgICAgIHBhdGhUeXBlOiBmb3VuZHNjaGVtYS4kaXNTaW5nbGVOZXN0ZWQgPyAnbmVzdGVkJyA6ICdhcnJheSdcbiAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7IHNjaGVtYTogZm91bmRzY2hlbWEsIHBhdGhUeXBlOiAncmVhbCcgfTtcbiAgICAgIH0gZWxzZSBpZiAocCA9PT0gcGFydHMubGVuZ3RoICYmIHNjaGVtYS5uZXN0ZWRbdHJ5cGF0aF0pIHtcbiAgICAgICAgcmV0dXJuIHsgc2NoZW1hOiBzY2hlbWEsIHBhdGhUeXBlOiAnbmVzdGVkJyB9O1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4geyBzY2hlbWE6IGZvdW5kc2NoZW1hIHx8IHNjaGVtYSwgcGF0aFR5cGU6ICd1bmRlZmluZWQnIH07XG4gIH1cblxuICAvLyBsb29rIGZvciBhcnJheXNcbiAgcmV0dXJuIHNlYXJjaChwYXRoLnNwbGl0KCcuJyksIF90aGlzKTtcbn07XG5cbi8qIVxuICogaWdub3JlXG4gKi9cblxuZnVuY3Rpb24gaXNBcnJheUZpbHRlcihwaWVjZSkge1xuICByZXR1cm4gcGllY2Uuc3RhcnRzV2l0aCgnJFsnKSAmJiBwaWVjZS5lbmRzV2l0aCgnXScpO1xufVxuXG4vKipcbiAqIENhbGxlZCBieSBgY29tcGlsZSgpYCBfcmlnaHQgYmVmb3JlXyBjb21waWxpbmcuIEdvb2QgZm9yIG1ha2luZyBhbnkgY2hhbmdlcyB0b1xuICogdGhlIHNjaGVtYSB0aGF0IHNob3VsZCByZXNwZWN0IG9wdGlvbnMgc2V0IGJ5IHBsdWdpbnMsIGxpa2UgYGlkYFxuICogQG1ldGhvZCBfcHJlQ29tcGlsZVxuICogQG1lbWJlck9mIFNjaGVtYVxuICogQGluc3RhbmNlXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5TY2hlbWEucHJvdG90eXBlLl9wcmVDb21waWxlID0gZnVuY3Rpb24gX3ByZUNvbXBpbGUoKSB7XG4gIGlkR2V0dGVyKHRoaXMpO1xufTtcblxuLyohXG4gKiBNb2R1bGUgZXhwb3J0cy5cbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHMgPSBTY2hlbWE7XG5cbi8vIHJlcXVpcmUgZG93biBoZXJlIGJlY2F1c2Ugb2YgcmVmZXJlbmNlIGlzc3Vlc1xuXG4vKipcbiAqIFRoZSB2YXJpb3VzIGJ1aWx0LWluIE1vbmdvb3NlIFNjaGVtYSBUeXBlcy5cbiAqXG4gKiAjIyMjIEV4YW1wbGU6XG4gKlxuICogICAgIGNvbnN0IG1vbmdvb3NlID0gcmVxdWlyZSgnbW9uZ29vc2UnKTtcbiAqICAgICBjb25zdCBPYmplY3RJZCA9IG1vbmdvb3NlLlNjaGVtYS5UeXBlcy5PYmplY3RJZDtcbiAqXG4gKiAjIyMjIFR5cGVzOlxuICpcbiAqIC0gW1N0cmluZ10oaHR0cHM6Ly9tb25nb29zZWpzLmNvbS9kb2NzL3NjaGVtYXR5cGVzLmh0bWwjc3RyaW5ncylcbiAqIC0gW051bWJlcl0oaHR0cHM6Ly9tb25nb29zZWpzLmNvbS9kb2NzL3NjaGVtYXR5cGVzLmh0bWwjbnVtYmVycylcbiAqIC0gW0Jvb2xlYW5dKGh0dHBzOi8vbW9uZ29vc2Vqcy5jb20vZG9jcy9zY2hlbWF0eXBlcy5odG1sI2Jvb2xlYW5zKSB8IEJvb2xcbiAqIC0gW0FycmF5XShodHRwczovL21vbmdvb3NlanMuY29tL2RvY3Mvc2NoZW1hdHlwZXMuaHRtbCNhcnJheXMpXG4gKiAtIFtCdWZmZXJdKGh0dHBzOi8vbW9uZ29vc2Vqcy5jb20vZG9jcy9zY2hlbWF0eXBlcy5odG1sI2J1ZmZlcnMpXG4gKiAtIFtEYXRlXShodHRwczovL21vbmdvb3NlanMuY29tL2RvY3Mvc2NoZW1hdHlwZXMuaHRtbCNkYXRlcylcbiAqIC0gW09iamVjdElkXShodHRwczovL21vbmdvb3NlanMuY29tL2RvY3Mvc2NoZW1hdHlwZXMuaHRtbCNvYmplY3RpZHMpIHwgT2lkXG4gKiAtIFtNaXhlZF0oaHR0cHM6Ly9tb25nb29zZWpzLmNvbS9kb2NzL3NjaGVtYXR5cGVzLmh0bWwjbWl4ZWQpXG4gKiAtIFtVVUlEXShodHRwczovL21vbmdvb3NlanMuY29tL2RvY3Mvc2NoZW1hdHlwZXMuaHRtbCN1dWlkKVxuICogLSBbQmlnSW50XShodHRwczovL21vbmdvb3NlanMuY29tL2RvY3Mvc2NoZW1hdHlwZXMuaHRtbCNiaWdpbnQpXG4gKlxuICogVXNpbmcgdGhpcyBleHBvc2VkIGFjY2VzcyB0byB0aGUgYE1peGVkYCBTY2hlbWFUeXBlLCB3ZSBjYW4gdXNlIHRoZW0gaW4gb3VyIHNjaGVtYS5cbiAqXG4gKiAgICAgY29uc3QgTWl4ZWQgPSBtb25nb29zZS5TY2hlbWEuVHlwZXMuTWl4ZWQ7XG4gKiAgICAgbmV3IG1vbmdvb3NlLlNjaGVtYSh7IF91c2VyOiBNaXhlZCB9KVxuICpcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuU2NoZW1hLlR5cGVzID0gTW9uZ29vc2VUeXBlcyA9IHJlcXVpcmUoJy4vc2NoZW1hL2luZGV4Jyk7XG5cbi8qIVxuICogaWdub3JlXG4gKi9cblxuZXhwb3J0cy5PYmplY3RJZCA9IE1vbmdvb3NlVHlwZXMuT2JqZWN0SWQ7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/mongoose/lib/schema.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/mongoose/lib/schema/array.js":
/*!***************************************************!*\
  !*** ./node_modules/mongoose/lib/schema/array.js ***!
  \***************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\n\n/*!\n * Module dependencies.\n */\n\nconst $exists = __webpack_require__(/*! ./operators/exists */ \"(ssr)/./node_modules/mongoose/lib/schema/operators/exists.js\");\nconst $type = __webpack_require__(/*! ./operators/type */ \"(ssr)/./node_modules/mongoose/lib/schema/operators/type.js\");\nconst MongooseError = __webpack_require__(/*! ../error/mongooseError */ \"(ssr)/./node_modules/mongoose/lib/error/mongooseError.js\");\nconst SchemaArrayOptions = __webpack_require__(/*! ../options/schemaArrayOptions */ \"(ssr)/./node_modules/mongoose/lib/options/schemaArrayOptions.js\");\nconst SchemaType = __webpack_require__(/*! ../schemaType */ \"(ssr)/./node_modules/mongoose/lib/schemaType.js\");\nconst CastError = SchemaType.CastError;\nconst Mixed = __webpack_require__(/*! ./mixed */ \"(ssr)/./node_modules/mongoose/lib/schema/mixed.js\");\nconst arrayDepth = __webpack_require__(/*! ../helpers/arrayDepth */ \"(ssr)/./node_modules/mongoose/lib/helpers/arrayDepth.js\");\nconst cast = __webpack_require__(/*! ../cast */ \"(ssr)/./node_modules/mongoose/lib/cast.js\");\nconst clone = __webpack_require__(/*! ../helpers/clone */ \"(ssr)/./node_modules/mongoose/lib/helpers/clone.js\");\nconst isOperator = __webpack_require__(/*! ../helpers/query/isOperator */ \"(ssr)/./node_modules/mongoose/lib/helpers/query/isOperator.js\");\nconst util = __webpack_require__(/*! util */ \"util\");\nconst utils = __webpack_require__(/*! ../utils */ \"(ssr)/./node_modules/mongoose/lib/utils.js\");\nconst castToNumber = (__webpack_require__(/*! ./operators/helpers */ \"(ssr)/./node_modules/mongoose/lib/schema/operators/helpers.js\").castToNumber);\nconst geospatial = __webpack_require__(/*! ./operators/geospatial */ \"(ssr)/./node_modules/mongoose/lib/schema/operators/geospatial.js\");\nconst getDiscriminatorByValue = __webpack_require__(/*! ../helpers/discriminator/getDiscriminatorByValue */ \"(ssr)/./node_modules/mongoose/lib/helpers/discriminator/getDiscriminatorByValue.js\");\n\nlet MongooseArray;\nlet EmbeddedDoc;\n\nconst isNestedArraySymbol = Symbol('mongoose#isNestedArray');\nconst emptyOpts = Object.freeze({});\n\n/**\n * Array SchemaType constructor\n *\n * @param {String} key\n * @param {SchemaType} cast\n * @param {Object} options\n * @param {Object} schemaOptions\n * @inherits SchemaType\n * @api public\n */\n\nfunction SchemaArray(key, cast, options, schemaOptions) {\n  // lazy load\n  EmbeddedDoc || (EmbeddedDoc = (__webpack_require__(/*! ../types */ \"(ssr)/./node_modules/mongoose/lib/types/index.js\").Embedded));\n\n  let typeKey = 'type';\n  if (schemaOptions && schemaOptions.typeKey) {\n    typeKey = schemaOptions.typeKey;\n  }\n  this.schemaOptions = schemaOptions;\n\n  if (cast) {\n    let castOptions = {};\n\n    if (utils.isPOJO(cast)) {\n      if (cast[typeKey]) {\n        // support { type: Woot }\n        castOptions = clone(cast); // do not alter user arguments\n        delete castOptions[typeKey];\n        cast = cast[typeKey];\n      } else {\n        cast = Mixed;\n      }\n    }\n\n    if (options != null && options.ref != null && castOptions.ref == null) {\n      castOptions.ref = options.ref;\n    }\n\n    if (cast === Object) {\n      cast = Mixed;\n    }\n\n    // support { type: 'String' }\n    const name = typeof cast === 'string'\n      ? cast\n      : utils.getFunctionName(cast);\n\n    const Types = __webpack_require__(/*! ./index.js */ \"(ssr)/./node_modules/mongoose/lib/schema/index.js\");\n    const caster = Types.hasOwnProperty(name) ? Types[name] : cast;\n\n    this.casterConstructor = caster;\n\n    if (this.casterConstructor instanceof SchemaArray) {\n      this.casterConstructor[isNestedArraySymbol] = true;\n    }\n\n    if (typeof caster === 'function' &&\n        !caster.$isArraySubdocument &&\n        !caster.$isSchemaMap) {\n      const path = this.caster instanceof EmbeddedDoc ? null : key;\n      this.caster = new caster(path, castOptions);\n    } else {\n      this.caster = caster;\n      if (!(this.caster instanceof EmbeddedDoc)) {\n        this.caster.path = key;\n      }\n    }\n\n    this.$embeddedSchemaType = this.caster;\n  }\n\n  this.$isMongooseArray = true;\n\n  SchemaType.call(this, key, options, 'Array');\n\n  let defaultArr;\n  let fn;\n\n  if (this.defaultValue != null) {\n    defaultArr = this.defaultValue;\n    fn = typeof defaultArr === 'function';\n  }\n\n  if (!('defaultValue' in this) || this.defaultValue !== void 0) {\n    const defaultFn = function() {\n      // Leave it up to `cast()` to convert the array\n      return fn\n        ? defaultArr.call(this)\n        : defaultArr != null\n          ? [].concat(defaultArr)\n          : [];\n    };\n    defaultFn.$runBeforeSetters = !fn;\n    this.default(defaultFn);\n  }\n}\n\n/**\n * This schema type's name, to defend against minifiers that mangle\n * function names.\n *\n * @api public\n */\nSchemaArray.schemaName = 'Array';\n\n\n/**\n * Options for all arrays.\n *\n * - `castNonArrays`: `true` by default. If `false`, Mongoose will throw a CastError when a value isn't an array. If `true`, Mongoose will wrap the provided value in an array before casting.\n *\n * @static\n * @api public\n */\n\nSchemaArray.options = { castNonArrays: true };\n\n/*!\n * ignore\n */\n\nSchemaArray.defaultOptions = {};\n\n/**\n * Sets a default option for all Array instances.\n *\n * #### Example:\n *\n *     // Make all Array instances have `required` of true by default.\n *     mongoose.Schema.Array.set('required', true);\n *\n *     const User = mongoose.model('User', new Schema({ test: Array }));\n *     new User({ }).validateSync().errors.test.message; // Path `test` is required.\n *\n * @param {String} option The option you'd like to set the value for\n * @param {Any} value value for option\n * @return {undefined}\n * @function set\n * @api public\n */\nSchemaArray.set = SchemaType.set;\n\nSchemaArray.setters = [];\n\n/**\n * Attaches a getter for all Array instances\n *\n * @param {Function} getter\n * @return {this}\n * @function get\n * @static\n * @api public\n */\n\nSchemaArray.get = SchemaType.get;\n\n/*!\n * Inherits from SchemaType.\n */\nSchemaArray.prototype = Object.create(SchemaType.prototype);\nSchemaArray.prototype.constructor = SchemaArray;\nSchemaArray.prototype.OptionsConstructor = SchemaArrayOptions;\n\n/*!\n * ignore\n */\n\nSchemaArray._checkRequired = SchemaType.prototype.checkRequired;\n\n/**\n * Override the function the required validator uses to check whether an array\n * passes the `required` check.\n *\n * #### Example:\n *\n *     // Require non-empty array to pass `required` check\n *     mongoose.Schema.Types.Array.checkRequired(v => Array.isArray(v) && v.length);\n *\n *     const M = mongoose.model({ arr: { type: Array, required: true } });\n *     new M({ arr: [] }).validateSync(); // `null`, validation fails!\n *\n * @param {Function} fn\n * @return {Function}\n * @function checkRequired\n * @api public\n */\n\nSchemaArray.checkRequired = SchemaType.checkRequired;\n\n/**\n * Check if the given value satisfies the `required` validator.\n *\n * @param {Any} value\n * @param {Document} doc\n * @return {Boolean}\n * @api public\n */\n\nSchemaArray.prototype.checkRequired = function checkRequired(value, doc) {\n  if (typeof value === 'object' && SchemaType._isRef(this, value, doc, true)) {\n    return !!value;\n  }\n\n  // `require('util').inherits()` does **not** copy static properties, and\n  // plugins like mongoose-float use `inherits()` for pre-ES6.\n  const _checkRequired = typeof this.constructor.checkRequired === 'function' ?\n    this.constructor.checkRequired() :\n    SchemaArray.checkRequired();\n\n  return _checkRequired(value);\n};\n\n/**\n * Adds an enum validator if this is an array of strings or numbers. Equivalent to\n * `SchemaString.prototype.enum()` or `SchemaNumber.prototype.enum()`\n *\n * @param {...String|Object} [args] enumeration values\n * @return {SchemaArray} this\n */\n\nSchemaArray.prototype.enum = function() {\n  let arr = this;\n  while (true) {\n    const instance = arr &&\n    arr.caster &&\n    arr.caster.instance;\n    if (instance === 'Array') {\n      arr = arr.caster;\n      continue;\n    }\n    if (instance !== 'String' && instance !== 'Number') {\n      throw new Error('`enum` can only be set on an array of strings or numbers ' +\n        ', not ' + instance);\n    }\n    break;\n  }\n\n  let enumArray = arguments;\n  if (!Array.isArray(arguments) && utils.isObject(arguments)) {\n    enumArray = utils.object.vals(enumArray);\n  }\n\n  arr.caster.enum.apply(arr.caster, enumArray);\n  return this;\n};\n\n/**\n * Overrides the getters application for the population special-case\n *\n * @param {Object} value\n * @param {Object} scope\n * @api private\n */\n\nSchemaArray.prototype.applyGetters = function(value, scope) {\n  if (scope != null && scope.$__ != null && scope.$populated(this.path)) {\n    // means the object id was populated\n    return value;\n  }\n\n  const ret = SchemaType.prototype.applyGetters.call(this, value, scope);\n  return ret;\n};\n\nSchemaArray.prototype._applySetters = function(value, scope, init, priorVal) {\n  if (this.casterConstructor.$isMongooseArray &&\n      SchemaArray.options.castNonArrays &&\n      !this[isNestedArraySymbol]) {\n    // Check nesting levels and wrap in array if necessary\n    let depth = 0;\n    let arr = this;\n    while (arr != null &&\n      arr.$isMongooseArray &&\n      !arr.$isMongooseDocumentArray) {\n      ++depth;\n      arr = arr.casterConstructor;\n    }\n\n    // No need to wrap empty arrays\n    if (value != null && value.length !== 0) {\n      const valueDepth = arrayDepth(value);\n      if (valueDepth.min === valueDepth.max && valueDepth.max < depth && valueDepth.containsNonArrayItem) {\n        for (let i = valueDepth.max; i < depth; ++i) {\n          value = [value];\n        }\n      }\n    }\n  }\n\n  return SchemaType.prototype._applySetters.call(this, value, scope, init, priorVal);\n};\n\n/**\n * Casts values for set().\n *\n * @param {Object} value\n * @param {Document} doc document that triggers the casting\n * @param {Boolean} init whether this is an initialization cast\n * @api private\n */\n\nSchemaArray.prototype.cast = function(value, doc, init, prev, options) {\n  // lazy load\n  MongooseArray || (MongooseArray = (__webpack_require__(/*! ../types */ \"(ssr)/./node_modules/mongoose/lib/types/index.js\").Array));\n\n  let i;\n  let l;\n\n  if (Array.isArray(value)) {\n    const len = value.length;\n    if (!len && doc) {\n      const indexes = doc.schema.indexedPaths();\n\n      const arrayPath = this.path;\n      for (i = 0, l = indexes.length; i < l; ++i) {\n        const pathIndex = indexes[i][0][arrayPath];\n        if (pathIndex === '2dsphere' || pathIndex === '2d') {\n          return;\n        }\n      }\n\n      // Special case: if this index is on the parent of what looks like\n      // GeoJSON, skip setting the default to empty array re: #1668, #3233\n      const arrayGeojsonPath = this.path.endsWith('.coordinates') ?\n        this.path.substring(0, this.path.lastIndexOf('.')) : null;\n      if (arrayGeojsonPath != null) {\n        for (i = 0, l = indexes.length; i < l; ++i) {\n          const pathIndex = indexes[i][0][arrayGeojsonPath];\n          if (pathIndex === '2dsphere') {\n            return;\n          }\n        }\n      }\n    }\n\n    options = options || emptyOpts;\n\n    let rawValue = utils.isMongooseArray(value) ? value.__array : value;\n    let path = options.path || this.path;\n    if (options.arrayPathIndex != null) {\n      path += '.' + options.arrayPathIndex;\n    }\n    value = MongooseArray(rawValue, path, doc, this);\n    rawValue = value.__array;\n\n    if (init && doc != null && doc.$__ != null && doc.$populated(this.path)) {\n      return value;\n    }\n\n    const caster = this.caster;\n    const isMongooseArray = caster.$isMongooseArray;\n    if (caster && this.casterConstructor !== Mixed) {\n      try {\n        const len = rawValue.length;\n        for (i = 0; i < len; i++) {\n          const opts = {};\n          // Perf: creating `arrayPath` is expensive for large arrays.\n          // We only need `arrayPath` if this is a nested array, so\n          // skip if possible.\n          if (isMongooseArray) {\n            if (options.arrayPath != null) {\n              opts.arrayPathIndex = i;\n            } else if (caster._arrayParentPath != null) {\n              opts.arrayPathIndex = i;\n            }\n          }\n          rawValue[i] = caster.applySetters(rawValue[i], doc, init, void 0, opts);\n        }\n      } catch (e) {\n        // rethrow\n        throw new CastError('[' + e.kind + ']', util.inspect(value), this.path + '.' + i, e, this);\n      }\n    }\n\n    return value;\n  }\n\n  const castNonArraysOption = this.options.castNonArrays != null ? this.options.castNonArrays : SchemaArray.options.castNonArrays;\n  if (init || castNonArraysOption) {\n    // gh-2442: if we're loading this from the db and its not an array, mark\n    // the whole array as modified.\n    if (!!doc && !!init) {\n      doc.markModified(this.path);\n    }\n    return this.cast([value], doc, init);\n  }\n\n  throw new CastError('Array', util.inspect(value), this.path, null, this);\n};\n\n/*!\n * ignore\n */\n\nSchemaArray.prototype._castForPopulate = function _castForPopulate(value, doc) {\n  // lazy load\n  MongooseArray || (MongooseArray = (__webpack_require__(/*! ../types */ \"(ssr)/./node_modules/mongoose/lib/types/index.js\").Array));\n\n  if (Array.isArray(value)) {\n    let i;\n    const rawValue = value.__array ? value.__array : value;\n    const len = rawValue.length;\n\n    const caster = this.caster;\n    if (caster && this.casterConstructor !== Mixed) {\n      try {\n        for (i = 0; i < len; i++) {\n          const opts = {};\n          // Perf: creating `arrayPath` is expensive for large arrays.\n          // We only need `arrayPath` if this is a nested array, so\n          // skip if possible.\n          if (caster.$isMongooseArray && caster._arrayParentPath != null) {\n            opts.arrayPathIndex = i;\n          }\n\n          rawValue[i] = caster.cast(rawValue[i], doc, false, void 0, opts);\n        }\n      } catch (e) {\n        // rethrow\n        throw new CastError('[' + e.kind + ']', util.inspect(value), this.path + '.' + i, e, this);\n      }\n    }\n\n    return value;\n  }\n\n  throw new CastError('Array', util.inspect(value), this.path, null, this);\n};\n\nSchemaArray.prototype.$toObject = SchemaArray.prototype.toObject;\n\n/*!\n * ignore\n */\n\nSchemaArray.prototype.discriminator = function(...args) {\n  let arr = this;\n  while (arr.$isMongooseArray && !arr.$isMongooseDocumentArray) {\n    arr = arr.casterConstructor;\n    if (arr == null || typeof arr === 'function') {\n      throw new MongooseError('You can only add an embedded discriminator on ' +\n        'a document array, ' + this.path + ' is a plain array');\n    }\n  }\n  return arr.discriminator(...args);\n};\n\n/*!\n * ignore\n */\n\nSchemaArray.prototype.clone = function() {\n  const options = Object.assign({}, this.options);\n  const schematype = new this.constructor(this.path, this.caster, options, this.schemaOptions);\n  schematype.validators = this.validators.slice();\n  if (this.requiredValidator !== undefined) {\n    schematype.requiredValidator = this.requiredValidator;\n  }\n  return schematype;\n};\n\nSchemaArray.prototype._castForQuery = function(val, context) {\n  let Constructor = this.casterConstructor;\n\n  if (val &&\n      Constructor.discriminators &&\n      Constructor.schema &&\n      Constructor.schema.options &&\n      Constructor.schema.options.discriminatorKey) {\n    if (typeof val[Constructor.schema.options.discriminatorKey] === 'string' &&\n        Constructor.discriminators[val[Constructor.schema.options.discriminatorKey]]) {\n      Constructor = Constructor.discriminators[val[Constructor.schema.options.discriminatorKey]];\n    } else {\n      const constructorByValue = getDiscriminatorByValue(Constructor.discriminators, val[Constructor.schema.options.discriminatorKey]);\n      if (constructorByValue) {\n        Constructor = constructorByValue;\n      }\n    }\n  }\n\n  const proto = this.casterConstructor.prototype;\n  const protoCastForQuery = proto && proto.castForQuery;\n  const protoCast = proto && proto.cast;\n  const constructorCastForQuery = Constructor.castForQuery;\n  const caster = this.caster;\n\n  if (Array.isArray(val)) {\n    this.setters.reverse().forEach(setter => {\n      val = setter.call(this, val, this);\n    });\n    val = val.map(function(v) {\n      if (utils.isObject(v) && v.$elemMatch) {\n        return v;\n      }\n      if (protoCastForQuery) {\n        v = protoCastForQuery.call(caster, null, v, context);\n        return v;\n      } else if (protoCast) {\n        v = protoCast.call(caster, v);\n        return v;\n      } else if (constructorCastForQuery) {\n        v = constructorCastForQuery.call(caster, null, v, context);\n        return v;\n      }\n      if (v != null) {\n        v = new Constructor(v);\n        return v;\n      }\n      return v;\n    });\n  } else if (protoCastForQuery) {\n    val = protoCastForQuery.call(caster, null, val, context);\n  } else if (protoCast) {\n    val = protoCast.call(caster, val);\n  } else if (constructorCastForQuery) {\n    val = constructorCastForQuery.call(caster, null, val, context);\n  } else if (val != null) {\n    val = new Constructor(val);\n  }\n\n  return val;\n};\n\n/**\n * Casts values for queries.\n *\n * @param {String} $conditional\n * @param {any} [value]\n * @api private\n */\n\nSchemaArray.prototype.castForQuery = function($conditional, val, context) {\n  let handler;\n\n  if ($conditional != null) {\n    handler = this.$conditionalHandlers[$conditional];\n\n    if (!handler) {\n      throw new Error('Can\\'t use ' + $conditional + ' with Array.');\n    }\n\n    return handler.call(this, val, context);\n  } else {\n    return this._castForQuery(val, context);\n  }\n};\n\nfunction cast$all(val, context) {\n  if (!Array.isArray(val)) {\n    val = [val];\n  }\n\n  val = val.map((v) => {\n    if (!utils.isObject(v)) {\n      return v;\n    }\n    if (v.$elemMatch != null) {\n      return { $elemMatch: cast(this.casterConstructor.schema, v.$elemMatch, null, this && this.$$context) };\n    }\n\n    const o = {};\n    o[this.path] = v;\n    return cast(this.casterConstructor.schema, o, null, this && this.$$context)[this.path];\n  }, this);\n\n  return this.castForQuery(null, val, context);\n}\n\nfunction cast$elemMatch(val, context) {\n  const keys = Object.keys(val);\n  const numKeys = keys.length;\n  for (let i = 0; i < numKeys; ++i) {\n    const key = keys[i];\n    const value = val[key];\n    if (isOperator(key) && value != null) {\n      val[key] = this.castForQuery(key, value, context);\n    }\n  }\n\n  // Is this an embedded discriminator and is the discriminator key set?\n  // If so, use the discriminator schema. See gh-7449\n  const discriminatorKey = this &&\n    this.casterConstructor &&\n    this.casterConstructor.schema &&\n    this.casterConstructor.schema.options &&\n    this.casterConstructor.schema.options.discriminatorKey;\n  const discriminators = this &&\n  this.casterConstructor &&\n  this.casterConstructor.schema &&\n  this.casterConstructor.schema.discriminators || {};\n  if (discriminatorKey != null &&\n      val[discriminatorKey] != null &&\n      discriminators[val[discriminatorKey]] != null) {\n    return cast(discriminators[val[discriminatorKey]], val, null, this && this.$$context);\n  }\n  const schema = this.casterConstructor.schema ?? context.schema;\n  return cast(schema, val, null, this && this.$$context);\n}\n\nconst handle = SchemaArray.prototype.$conditionalHandlers = {};\n\nhandle.$all = cast$all;\nhandle.$options = String;\nhandle.$elemMatch = cast$elemMatch;\nhandle.$geoIntersects = geospatial.cast$geoIntersects;\nhandle.$or = createLogicalQueryOperatorHandler('$or');\nhandle.$and = createLogicalQueryOperatorHandler('$and');\nhandle.$nor = createLogicalQueryOperatorHandler('$nor');\n\nfunction createLogicalQueryOperatorHandler(op) {\n  return function logicalQueryOperatorHandler(val) {\n    if (!Array.isArray(val)) {\n      throw new TypeError('conditional ' + op + ' requires an array');\n    }\n\n    const ret = [];\n    for (const obj of val) {\n      ret.push(cast(this.casterConstructor.schema, obj, null, this && this.$$context));\n    }\n\n    return ret;\n  };\n}\n\nhandle.$near =\nhandle.$nearSphere = geospatial.cast$near;\n\nhandle.$within =\nhandle.$geoWithin = geospatial.cast$within;\n\nhandle.$size =\nhandle.$minDistance =\nhandle.$maxDistance = castToNumber;\n\nhandle.$exists = $exists;\nhandle.$type = $type;\n\nhandle.$eq =\nhandle.$gt =\nhandle.$gte =\nhandle.$lt =\nhandle.$lte =\nhandle.$not =\nhandle.$regex =\nhandle.$ne = SchemaArray.prototype._castForQuery;\n\n// `$in` is special because you can also include an empty array in the query\n// like `$in: [1, []]`, see gh-5913\nhandle.$nin = SchemaType.prototype.$conditionalHandlers.$nin;\nhandle.$in = SchemaType.prototype.$conditionalHandlers.$in;\n\n/*!\n * Module exports.\n */\n\nmodule.exports = SchemaArray;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbW9uZ29vc2UvbGliL3NjaGVtYS9hcnJheS5qcyIsIm1hcHBpbmdzIjoiQUFBYTs7QUFFYjtBQUNBO0FBQ0E7O0FBRUEsZ0JBQWdCLG1CQUFPLENBQUMsd0ZBQW9CO0FBQzVDLGNBQWMsbUJBQU8sQ0FBQyxvRkFBa0I7QUFDeEMsc0JBQXNCLG1CQUFPLENBQUMsd0ZBQXdCO0FBQ3RELDJCQUEyQixtQkFBTyxDQUFDLHNHQUErQjtBQUNsRSxtQkFBbUIsbUJBQU8sQ0FBQyxzRUFBZTtBQUMxQztBQUNBLGNBQWMsbUJBQU8sQ0FBQyxrRUFBUztBQUMvQixtQkFBbUIsbUJBQU8sQ0FBQyxzRkFBdUI7QUFDbEQsYUFBYSxtQkFBTyxDQUFDLDBEQUFTO0FBQzlCLGNBQWMsbUJBQU8sQ0FBQyw0RUFBa0I7QUFDeEMsbUJBQW1CLG1CQUFPLENBQUMsa0dBQTZCO0FBQ3hELGFBQWEsbUJBQU8sQ0FBQyxrQkFBTTtBQUMzQixjQUFjLG1CQUFPLENBQUMsNERBQVU7QUFDaEMscUJBQXFCLDhIQUEyQztBQUNoRSxtQkFBbUIsbUJBQU8sQ0FBQyxnR0FBd0I7QUFDbkQsZ0NBQWdDLG1CQUFPLENBQUMsNElBQWtEOztBQUUxRjtBQUNBOztBQUVBO0FBQ0Esa0NBQWtDOztBQUVsQztBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsV0FBVyxZQUFZO0FBQ3ZCLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxnQ0FBZ0Msa0dBQTRCOztBQUU1RDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQixtQ0FBbUM7QUFDbkM7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBOztBQUVBLGtCQUFrQixtQkFBTyxDQUFDLHFF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O0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxvQ0FBb0MsK0ZBQXlCOztBQUU3RDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsU0FBUztBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxrQ0FBa0M7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsSUFBSTtBQUNKO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsV0FBVyxLQUFLO0FBQ2hCO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLGFBQWE7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSIsInNvdXJjZXMiOlsid2VicGFjazovL2FwcDEvLi9ub2RlX21vZHVsZXMvbW9uZ29vc2UvbGliL3NjaGVtYS9hcnJheS5qcz82YzY3Il0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxuLyohXG4gKiBNb2R1bGUgZGVwZW5kZW5jaWVzLlxuICovXG5cbmNvbnN0ICRleGlzdHMgPSByZXF1aXJlKCcuL29wZXJhdG9ycy9leGlzdHMnKTtcbmNvbnN0ICR0eXBlID0gcmVxdWlyZSgnLi9vcGVyYXRvcnMvdHlwZScpO1xuY29uc3QgTW9uZ29vc2VFcnJvciA9IHJlcXVpcmUoJy4uL2Vycm9yL21vbmdvb3NlRXJyb3InKTtcbmNvbnN0IFNjaGVtYUFycmF5T3B0aW9ucyA9IHJlcXVpcmUoJy4uL29wdGlvbnMvc2NoZW1hQXJyYXlPcHRpb25zJyk7XG5jb25zdCBTY2hlbWFUeXBlID0gcmVxdWlyZSgnLi4vc2NoZW1hVHlwZScpO1xuY29uc3QgQ2FzdEVycm9yID0gU2NoZW1hVHlwZS5DYXN0RXJyb3I7XG5jb25zdCBNaXhlZCA9IHJlcXVpcmUoJy4vbWl4ZWQnKTtcbmNvbnN0IGFycmF5RGVwdGggPSByZXF1aXJlKCcuLi9oZWxwZXJzL2FycmF5RGVwdGgnKTtcbmNvbnN0IGNhc3QgPSByZXF1aXJlKCcuLi9jYXN0Jyk7XG5jb25zdCBjbG9uZSA9IHJlcXVpcmUoJy4uL2hlbHBlcnMvY2xvbmUnKTtcbmNvbnN0IGlzT3BlcmF0b3IgPSByZXF1aXJlKCcuLi9oZWxwZXJzL3F1ZXJ5L2lzT3BlcmF0b3InKTtcbmNvbnN0IHV0aWwgPSByZXF1aXJlKCd1dGlsJyk7XG5jb25zdCB1dGlscyA9IHJlcXVpcmUoJy4uL3V0aWxzJyk7XG5jb25zdCBjYXN0VG9OdW1iZXIgPSByZXF1aXJlKCcuL29wZXJhdG9ycy9oZWxwZXJzJykuY2FzdFRvTnVtYmVyO1xuY29uc3QgZ2Vvc3BhdGlhbCA9IHJlcXVpcmUoJy4vb3BlcmF0b3JzL2dlb3NwYXRpYWwnKTtcbmNvbnN0IGdldERpc2NyaW1pbmF0b3JCeVZhbHVlID0gcmVxdWlyZSgnLi4vaGVscGVycy9kaXNjcmltaW5hdG9yL2dldERpc2NyaW1pbmF0b3JCeVZhbHVlJyk7XG5cbmxldCBNb25nb29zZUFycmF5O1xubGV0IEVtYmVkZGVkRG9jO1xuXG5jb25zdCBpc05lc3RlZEFycmF5U3ltYm9sID0gU3ltYm9sKCdtb25nb29zZSNpc05lc3RlZEFycmF5Jyk7XG5jb25zdCBlbXB0eU9wdHMgPSBPYmplY3QuZnJlZXplKHt9KTtcblxuLyoqXG4gKiBBcnJheSBTY2hlbWFUeXBlIGNvbnN0cnVjdG9yXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IGtleVxuICogQHBhcmFtIHtTY2hlbWFUeXBlfSBjYXN0XG4gKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xuICogQHBhcmFtIHtPYmplY3R9IHNjaGVtYU9wdGlvbnNcbiAqIEBpbmhlcml0cyBTY2hlbWFUeXBlXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmZ1bmN0aW9uIFNjaGVtYUFycmF5KGtleSwgY2FzdCwgb3B0aW9ucywgc2NoZW1hT3B0aW9ucykge1xuICAvLyBsYXp5IGxvYWRcbiAgRW1iZWRkZWREb2MgfHwgKEVtYmVkZGVkRG9jID0gcmVxdWlyZSgnLi4vdHlwZXMnKS5FbWJlZGRlZCk7XG5cbiAgbGV0IHR5cGVLZXkgPSAndHlwZSc7XG4gIGlmIChzY2hlbWFPcHRpb25zICYmIHNjaGVtYU9wdGlvbnMudHlwZUtleSkge1xuICAgIHR5cGVLZXkgPSBzY2hlbWFPcHRpb25zLnR5cGVLZXk7XG4gIH1cbiAgdGhpcy5zY2hlbWFPcHRpb25zID0gc2NoZW1hT3B0aW9ucztcblxuICBpZiAoY2FzdCkge1xuICAgIGxldCBjYXN0T3B0aW9ucyA9IHt9O1xuXG4gICAgaWYgKHV0aWxzLmlzUE9KTyhjYXN0KSkge1xuICAgICAgaWYgKGNhc3RbdHlwZUtleV0pIHtcbiAgICAgICAgLy8gc3VwcG9ydCB7IHR5cGU6IFdvb3QgfVxuICAgICAgICBjYXN0T3B0aW9ucyA9IGNsb25lKGNhc3QpOyAvLyBkbyBub3QgYWx0ZXIgdXNlciBhcmd1bWVudHNcbiAgICAgICAgZGVsZXRlIGNhc3RPcHRpb25zW3R5cGVLZXldO1xuICAgICAgICBjYXN0ID0gY2FzdFt0eXBlS2V5XTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNhc3QgPSBNaXhlZDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAob3B0aW9ucyAhPSBudWxsICYmIG9wdGlvbnMucmVmICE9IG51bGwgJiYgY2FzdE9wdGlvbnMucmVmID09IG51bGwpIHtcbiAgICAgIGNhc3RPcHRpb25zLnJlZiA9IG9wdGlvbnMucmVmO1xuICAgIH1cblxuICAgIGlmIChjYXN0ID09PSBPYmplY3QpIHtcbiAgICAgIGNhc3QgPSBNaXhlZDtcbiAgICB9XG5cbiAgICAvLyBzdXBwb3J0IHsgdHlwZTogJ1N0cmluZycgfVxuICAgIGNvbnN0IG5hbWUgPSB0eXBlb2YgY2FzdCA9PT0gJ3N0cmluZydcbiAgICAgID8gY2FzdFxuICAgICAgOiB1dGlscy5nZXRGdW5jdGlvbk5hbWUoY2FzdCk7XG5cbiAgICBjb25zdCBUeXBlcyA9IHJlcXVpcmUoJy4vaW5kZXguanMnKTtcbiAgICBjb25zdCBjYXN0ZXIgPSBUeXBlcy5oYXNPd25Qcm9wZXJ0eShuYW1lKSA/IFR5cGVzW25hbWVdIDogY2FzdDtcblxuICAgIHRoaXMuY2FzdGVyQ29uc3RydWN0b3IgPSBjYXN0ZXI7XG5cbiAgICBpZiAodGhpcy5jYXN0ZXJDb25zdHJ1Y3RvciBpbnN0YW5jZW9mIFNjaGVtYUFycmF5KSB7XG4gICAgICB0aGlzLmNhc3RlckNvbnN0cnVjdG9yW2lzTmVzdGVkQXJyYXlTeW1ib2xdID0gdHJ1ZTtcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIGNhc3RlciA9PT0gJ2Z1bmN0aW9uJyAmJlxuICAgICAgICAhY2FzdGVyLiRpc0FycmF5U3ViZG9jdW1lbnQgJiZcbiAgICAgICAgIWNhc3Rlci4kaXNTY2hlbWFNYXApIHtcbiAgICAgIGNvbnN0IHBhdGggPSB0aGlzLmNhc3RlciBpbnN0YW5jZW9mIEVtYmVkZGVkRG9jID8gbnVsbCA6IGtleTtcbiAgICAgIHRoaXMuY2FzdGVyID0gbmV3IGNhc3RlcihwYXRoLCBjYXN0T3B0aW9ucyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuY2FzdGVyID0gY2FzdGVyO1xuICAgICAgaWYgKCEodGhpcy5jYXN0ZXIgaW5zdGFuY2VvZiBFbWJlZGRlZERvYykpIHtcbiAgICAgICAgdGhpcy5jYXN0ZXIucGF0aCA9IGtleTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB0aGlzLiRlbWJlZGRlZFNjaGVtYVR5cGUgPSB0aGlzLmNhc3RlcjtcbiAgfVxuXG4gIHRoaXMuJGlzTW9uZ29vc2VBcnJheSA9IHRydWU7XG5cbiAgU2NoZW1hVHlwZS5jYWxsKHRoaXMsIGtleSwgb3B0aW9ucywgJ0FycmF5Jyk7XG5cbiAgbGV0IGRlZmF1bHRBcnI7XG4gIGxldCBmbjtcblxuICBpZiAodGhpcy5kZWZhdWx0VmFsdWUgIT0gbnVsbCkge1xuICAgIGRlZmF1bHRBcnIgPSB0aGlzLmRlZmF1bHRWYWx1ZTtcbiAgICBmbiA9IHR5cGVvZiBkZWZhdWx0QXJyID09PSAnZnVuY3Rpb24nO1xuICB9XG5cbiAgaWYgKCEoJ2RlZmF1bHRWYWx1ZScgaW4gdGhpcykgfHwgdGhpcy5kZWZhdWx0VmFsdWUgIT09IHZvaWQgMCkge1xuICAgIGNvbnN0IGRlZmF1bHRGbiA9IGZ1bmN0aW9uKCkge1xuICAgICAgLy8gTGVhdmUgaXQgdXAgdG8gYGNhc3QoKWAgdG8gY29udmVydCB0aGUgYXJyYXlcbiAgICAgIHJldHVybiBmblxuICAgICAgICA/IGRlZmF1bHRBcnIuY2FsbCh0aGlzKVxuICAgICAgICA6IGRlZmF1bHRBcnIgIT0gbnVsbFxuICAgICAgICAgID8gW10uY29uY2F0KGRlZmF1bHRBcnIpXG4gICAgICAgICAgOiBbXTtcbiAgICB9O1xuICAgIGRlZmF1bHRGbi4kcnVuQmVmb3JlU2V0dGVycyA9ICFmbjtcbiAgICB0aGlzLmRlZmF1bHQoZGVmYXVsdEZuKTtcbiAgfVxufVxuXG4vKipcbiAqIFRoaXMgc2NoZW1hIHR5cGUncyBuYW1lLCB0byBkZWZlbmQgYWdhaW5zdCBtaW5pZmllcnMgdGhhdCBtYW5nbGVcbiAqIGZ1bmN0aW9uIG5hbWVzLlxuICpcbiAqIEBhcGkgcHVibGljXG4gKi9cblNjaGVtYUFycmF5LnNjaGVtYU5hbWUgPSAnQXJyYXknO1xuXG5cbi8qKlxuICogT3B0aW9ucyBmb3IgYWxsIGFycmF5cy5cbiAqXG4gKiAtIGBjYXN0Tm9uQXJyYXlzYDogYHRydWVgIGJ5IGRlZmF1bHQuIElmIGBmYWxzZWAsIE1vbmdvb3NlIHdpbGwgdGhyb3cgYSBDYXN0RXJyb3Igd2hlbiBhIHZhbHVlIGlzbid0IGFuIGFycmF5LiBJZiBgdHJ1ZWAsIE1vbmdvb3NlIHdpbGwgd3JhcCB0aGUgcHJvdmlkZWQgdmFsdWUgaW4gYW4gYXJyYXkgYmVmb3JlIGNhc3RpbmcuXG4gKlxuICogQHN0YXRpY1xuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5TY2hlbWFBcnJheS5vcHRpb25zID0geyBjYXN0Tm9uQXJyYXlzOiB0cnVlIH07XG5cbi8qIVxuICogaWdub3JlXG4gKi9cblxuU2NoZW1hQXJyYXkuZGVmYXVsdE9wdGlvbnMgPSB7fTtcblxuLyoqXG4gKiBTZXRzIGEgZGVmYXVsdCBvcHRpb24gZm9yIGFsbCBBcnJheSBpbnN0YW5jZXMuXG4gKlxuICogIyMjIyBFeGFtcGxlOlxuICpcbiAqICAgICAvLyBNYWtlIGFsbCBBcnJheSBpbnN0YW5jZXMgaGF2ZSBgcmVxdWlyZWRgIG9mIHRydWUgYnkgZGVmYXVsdC5cbiAqICAgICBtb25nb29zZS5TY2hlbWEuQXJyYXkuc2V0KCdyZXF1aXJlZCcsIHRydWUpO1xuICpcbiAqICAgICBjb25zdCBVc2VyID0gbW9uZ29vc2UubW9kZWwoJ1VzZXInLCBuZXcgU2NoZW1hKHsgdGVzdDogQXJyYXkgfSkpO1xuICogICAgIG5ldyBVc2VyKHsgfSkudmFsaWRhdGVTeW5jKCkuZXJyb3JzLnRlc3QubWVzc2FnZTsgLy8gUGF0aCBgdGVzdGAgaXMgcmVxdWlyZWQuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IG9wdGlvbiBUaGUgb3B0aW9uIHlvdSdkIGxpa2UgdG8gc2V0IHRoZSB2YWx1ZSBmb3JcbiAqIEBwYXJhbSB7QW55fSB2YWx1ZSB2YWx1ZSBmb3Igb3B0aW9uXG4gKiBAcmV0dXJuIHt1bmRlZmluZWR9XG4gKiBAZnVuY3Rpb24gc2V0XG4gKiBAYXBpIHB1YmxpY1xuICovXG5TY2hlbWFBcnJheS5zZXQgPSBTY2hlbWFUeXBlLnNldDtcblxuU2NoZW1hQXJyYXkuc2V0dGVycyA9IFtdO1xuXG4vKipcbiAqIEF0dGFjaGVzIGEgZ2V0dGVyIGZvciBhbGwgQXJyYXkgaW5zdGFuY2VzXG4gKlxuICogQHBhcmFtIHtGdW5jdGlvbn0gZ2V0dGVyXG4gKiBAcmV0dXJuIHt0aGlzfVxuICogQGZ1bmN0aW9uIGdldFxuICogQHN0YXRpY1xuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5TY2hlbWFBcnJheS5nZXQgPSBTY2hlbWFUeXBlLmdldDtcblxuLyohXG4gKiBJbmhlcml0cyBmcm9tIFNjaGVtYVR5cGUuXG4gKi9cblNjaGVtYUFycmF5LnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoU2NoZW1hVHlwZS5wcm90b3R5cGUpO1xuU2NoZW1hQXJyYXkucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gU2NoZW1hQXJyYXk7XG5TY2hlbWFBcnJheS5wcm90b3R5cGUuT3B0aW9uc0NvbnN0cnVjdG9yID0gU2NoZW1hQXJyYXlPcHRpb25zO1xuXG4vKiFcbiAqIGlnbm9yZVxuICovXG5cblNjaGVtYUFycmF5Ll9jaGVja1JlcXVpcmVkID0gU2NoZW1hVHlwZS5wcm90b3R5cGUuY2hlY2tSZXF1aXJlZDtcblxuLyoqXG4gKiBPdmVycmlkZSB0aGUgZnVuY3Rpb24gdGhlIHJlcXVpcmVkIHZhbGlkYXRvciB1c2VzIHRvIGNoZWNrIHdoZXRoZXIgYW4gYXJyYXlcbiAqIHBhc3NlcyB0aGUgYHJlcXVpcmVkYCBjaGVjay5cbiAqXG4gKiAjIyMjIEV4YW1wbGU6XG4gKlxuICogICAgIC8vIFJlcXVpcmUgbm9uLWVtcHR5IGFycmF5IHRvIHBhc3MgYHJlcXVpcmVkYCBjaGVja1xuICogICAgIG1vbmdvb3NlLlNjaGVtYS5UeXBlcy5BcnJheS5jaGVja1JlcXVpcmVkKHYgPT4gQXJyYXkuaXNBcnJheSh2KSAmJiB2Lmxlbmd0aCk7XG4gKlxuICogICAgIGNvbnN0IE0gPSBtb25nb29zZS5tb2RlbCh7IGFycjogeyB0eXBlOiBBcnJheSwgcmVxdWlyZWQ6IHRydWUgfSB9KTtcbiAqICAgICBuZXcgTSh7IGFycjogW10gfSkudmFsaWRhdGVTeW5jKCk7IC8vIGBudWxsYCwgdmFsaWRhdGlvbiBmYWlscyFcbiAqXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmblxuICogQHJldHVybiB7RnVuY3Rpb259XG4gKiBAZnVuY3Rpb24gY2hlY2tSZXF1aXJlZFxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5TY2hlbWFBcnJheS5jaGVja1JlcXVpcmVkID0gU2NoZW1hVHlwZS5jaGVja1JlcXVpcmVkO1xuXG4vKipcbiAqIENoZWNrIGlmIHRoZSBnaXZlbiB2YWx1ZSBzYXRpc2ZpZXMgdGhlIGByZXF1aXJlZGAgdmFsaWRhdG9yLlxuICpcbiAqIEBwYXJhbSB7QW55fSB2YWx1ZVxuICogQHBhcmFtIHtEb2N1bWVudH0gZG9jXG4gKiBAcmV0dXJuIHtCb29sZWFufVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5TY2hlbWFBcnJheS5wcm90b3R5cGUuY2hlY2tSZXF1aXJlZCA9IGZ1bmN0aW9uIGNoZWNrUmVxdWlyZWQodmFsdWUsIGRvYykge1xuICBpZiAodHlwZW9mIHZhbHVlID09PSAnb2JqZWN0JyAmJiBTY2hlbWFUeXBlLl9pc1JlZih0aGlzLCB2YWx1ZSwgZG9jLCB0cnVlKSkge1xuICAgIHJldHVybiAhIXZhbHVlO1xuICB9XG5cbiAgLy8gYHJlcXVpcmUoJ3V0aWwnKS5pbmhlcml0cygpYCBkb2VzICoqbm90KiogY29weSBzdGF0aWMgcHJvcGVydGllcywgYW5kXG4gIC8vIHBsdWdpbnMgbGlrZSBtb25nb29zZS1mbG9hdCB1c2UgYGluaGVyaXRzKClgIGZvciBwcmUtRVM2LlxuICBjb25zdCBfY2hlY2tSZXF1aXJlZCA9IHR5cGVvZiB0aGlzLmNvbnN0cnVjdG9yLmNoZWNrUmVxdWlyZWQgPT09ICdmdW5jdGlvbicgP1xuICAgIHRoaXMuY29uc3RydWN0b3IuY2hlY2tSZXF1aXJlZCgpIDpcbiAgICBTY2hlbWFBcnJheS5jaGVja1JlcXVpcmVkKCk7XG5cbiAgcmV0dXJuIF9jaGVja1JlcXVpcmVkKHZhbHVlKTtcbn07XG5cbi8qKlxuICogQWRkcyBhbiBlbnVtIHZhbGlkYXRvciBpZiB0aGlzIGlzIGFuIGFycmF5IG9mIHN0cmluZ3Mgb3IgbnVtYmVycy4gRXF1aXZhbGVudCB0b1xuICogYFNjaGVtYVN0cmluZy5wcm90b3R5cGUuZW51bSgpYCBvciBgU2NoZW1hTnVtYmVyLnByb3RvdHlwZS5lbnVtKClgXG4gKlxuICogQHBhcmFtIHsuLi5TdHJpbmd8T2JqZWN0fSBbYXJnc10gZW51bWVyYXRpb24gdmFsdWVzXG4gKiBAcmV0dXJuIHtTY2hlbWFBcnJheX0gdGhpc1xuICovXG5cblNjaGVtYUFycmF5LnByb3RvdHlwZS5lbnVtID0gZnVuY3Rpb24oKSB7XG4gIGxldCBhcnIgPSB0aGlzO1xuICB3aGlsZSAodHJ1ZSkge1xuICAgIGNvbnN0IGluc3RhbmNlID0gYXJyICYmXG4gICAgYXJyLmNhc3RlciAmJlxuICAgIGFyci5jYXN0ZXIuaW5zdGFuY2U7XG4gICAgaWYgKGluc3RhbmNlID09PSAnQXJyYXknKSB7XG4gICAgICBhcnIgPSBhcnIuY2FzdGVyO1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIGlmIChpbnN0YW5jZSAhPT0gJ1N0cmluZycgJiYgaW5zdGFuY2UgIT09ICdOdW1iZXInKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ2BlbnVtYCBjYW4gb25seSBiZSBzZXQgb24gYW4gYXJyYXkgb2Ygc3RyaW5ncyBvciBudW1iZXJzICcgK1xuICAgICAgICAnLCBub3QgJyArIGluc3RhbmNlKTtcbiAgICB9XG4gICAgYnJlYWs7XG4gIH1cblxuICBsZXQgZW51bUFycmF5ID0gYXJndW1lbnRzO1xuICBpZiAoIUFycmF5LmlzQXJyYXkoYXJndW1lbnRzKSAmJiB1dGlscy5pc09iamVjdChhcmd1bWVudHMpKSB7XG4gICAgZW51bUFycmF5ID0gdXRpbHMub2JqZWN0LnZhbHMoZW51bUFycmF5KTtcbiAgfVxuXG4gIGFyci5jYXN0ZXIuZW51bS5hcHBseShhcnIuY2FzdGVyLCBlbnVtQXJyYXkpO1xuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogT3ZlcnJpZGVzIHRoZSBnZXR0ZXJzIGFwcGxpY2F0aW9uIGZvciB0aGUgcG9wdWxhdGlvbiBzcGVjaWFsLWNhc2VcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gdmFsdWVcbiAqIEBwYXJhbSB7T2JqZWN0fSBzY29wZVxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuU2NoZW1hQXJyYXkucHJvdG90eXBlLmFwcGx5R2V0dGVycyA9IGZ1bmN0aW9uKHZhbHVlLCBzY29wZSkge1xuICBpZiAoc2NvcGUgIT0gbnVsbCAmJiBzY29wZS4kX18gIT0gbnVsbCAmJiBzY29wZS4kcG9wdWxhdGVkKHRoaXMucGF0aCkpIHtcbiAgICAvLyBtZWFucyB0aGUgb2JqZWN0IGlkIHdhcyBwb3B1bGF0ZWRcbiAgICByZXR1cm4gdmFsdWU7XG4gIH1cblxuICBjb25zdCByZXQgPSBTY2hlbWFUeXBlLnByb3RvdHlwZS5hcHBseUdldHRlcnMuY2FsbCh0aGlzLCB2YWx1ZSwgc2NvcGUpO1xuICByZXR1cm4gcmV0O1xufTtcblxuU2NoZW1hQXJyYXkucHJvdG90eXBlLl9hcHBseVNldHRlcnMgPSBmdW5jdGlvbih2YWx1ZSwgc2NvcGUsIGluaXQsIHByaW9yVmFsKSB7XG4gIGlmICh0aGlzLmNhc3RlckNvbnN0cnVjdG9yLiRpc01vbmdvb3NlQXJyYXkgJiZcbiAgICAgIFNjaGVtYUFycmF5Lm9wdGlvbnMuY2FzdE5vbkFycmF5cyAmJlxuICAgICAgIXRoaXNbaXNOZXN0ZWRBcnJheVN5bWJvbF0pIHtcbiAgICAvLyBDaGVjayBuZXN0aW5nIGxldmVscyBhbmQgd3JhcCBpbiBhcnJheSBpZiBuZWNlc3NhcnlcbiAgICBsZXQgZGVwdGggPSAwO1xuICAgIGxldCBhcnIgPSB0aGlzO1xuICAgIHdoaWxlIChhcnIgIT0gbnVsbCAmJlxuICAgICAgYXJyLiRpc01vbmdvb3NlQXJyYXkgJiZcbiAgICAgICFhcnIuJGlzTW9uZ29vc2VEb2N1bWVudEFycmF5KSB7XG4gICAgICArK2RlcHRoO1xuICAgICAgYXJyID0gYXJyLmNhc3RlckNvbnN0cnVjdG9yO1xuICAgIH1cblxuICAgIC8vIE5vIG5lZWQgdG8gd3JhcCBlbXB0eSBhcnJheXNcbiAgICBpZiAodmFsdWUgIT0gbnVsbCAmJiB2YWx1ZS5sZW5ndGggIT09IDApIHtcbiAgICAgIGNvbnN0IHZhbHVlRGVwdGggPSBhcnJheURlcHRoKHZhbHVlKTtcbiAgICAgIGlmICh2YWx1ZURlcHRoLm1pbiA9PT0gdmFsdWVEZXB0aC5tYXggJiYgdmFsdWVEZXB0aC5tYXggPCBkZXB0aCAmJiB2YWx1ZURlcHRoLmNvbnRhaW5zTm9uQXJyYXlJdGVtKSB7XG4gICAgICAgIGZvciAobGV0IGkgPSB2YWx1ZURlcHRoLm1heDsgaSA8IGRlcHRoOyArK2kpIHtcbiAgICAgICAgICB2YWx1ZSA9IFt2YWx1ZV07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gU2NoZW1hVHlwZS5wcm90b3R5cGUuX2FwcGx5U2V0dGVycy5jYWxsKHRoaXMsIHZhbHVlLCBzY29wZSwgaW5pdCwgcHJpb3JWYWwpO1xufTtcblxuLyoqXG4gKiBDYXN0cyB2YWx1ZXMgZm9yIHNldCgpLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSB2YWx1ZVxuICogQHBhcmFtIHtEb2N1bWVudH0gZG9jIGRvY3VtZW50IHRoYXQgdHJpZ2dlcnMgdGhlIGNhc3RpbmdcbiAqIEBwYXJhbSB7Qm9vbGVhbn0gaW5pdCB3aGV0aGVyIHRoaXMgaXMgYW4gaW5pdGlhbGl6YXRpb24gY2FzdFxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuU2NoZW1hQXJyYXkucHJvdG90eXBlLmNhc3QgPSBmdW5jdGlvbih2YWx1ZSwgZG9jLCBpbml0LCBwcmV2LCBvcHRpb25zKSB7XG4gIC8vIGxhenkgbG9hZFxuICBNb25nb29zZUFycmF5IHx8IChNb25nb29zZUFycmF5ID0gcmVxdWlyZSgnLi4vdHlwZXMnKS5BcnJheSk7XG5cbiAgbGV0IGk7XG4gIGxldCBsO1xuXG4gIGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgIGNvbnN0IGxlbiA9IHZhbHVlLmxlbmd0aDtcbiAgICBpZiAoIWxlbiAmJiBkb2MpIHtcbiAgICAgIGNvbnN0IGluZGV4ZXMgPSBkb2Muc2NoZW1hLmluZGV4ZWRQYXRocygpO1xuXG4gICAgICBjb25zdCBhcnJheVBhdGggPSB0aGlzLnBhdGg7XG4gICAgICBmb3IgKGkgPSAwLCBsID0gaW5kZXhlcy5sZW5ndGg7IGkgPCBsOyArK2kpIHtcbiAgICAgICAgY29uc3QgcGF0aEluZGV4ID0gaW5kZXhlc1tpXVswXVthcnJheVBhdGhdO1xuICAgICAgICBpZiAocGF0aEluZGV4ID09PSAnMmRzcGhlcmUnIHx8IHBhdGhJbmRleCA9PT0gJzJkJykge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLyBTcGVjaWFsIGNhc2U6IGlmIHRoaXMgaW5kZXggaXMgb24gdGhlIHBhcmVudCBvZiB3aGF0IGxvb2tzIGxpa2VcbiAgICAgIC8vIEdlb0pTT04sIHNraXAgc2V0dGluZyB0aGUgZGVmYXVsdCB0byBlbXB0eSBhcnJheSByZTogIzE2NjgsICMzMjMzXG4gICAgICBjb25zdCBhcnJheUdlb2pzb25QYXRoID0gdGhpcy5wYXRoLmVuZHNXaXRoKCcuY29vcmRpbmF0ZXMnKSA/XG4gICAgICAgIHRoaXMucGF0aC5zdWJzdHJpbmcoMCwgdGhpcy5wYXRoLmxhc3RJbmRleE9mKCcuJykpIDogbnVsbDtcbiAgICAgIGlmIChhcnJheUdlb2pzb25QYXRoICE9IG51bGwpIHtcbiAgICAgICAgZm9yIChpID0gMCwgbCA9IGluZGV4ZXMubGVuZ3RoOyBpIDwgbDsgKytpKSB7XG4gICAgICAgICAgY29uc3QgcGF0aEluZGV4ID0gaW5kZXhlc1tpXVswXVthcnJheUdlb2pzb25QYXRoXTtcbiAgICAgICAgICBpZiAocGF0aEluZGV4ID09PSAnMmRzcGhlcmUnKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwgZW1wdHlPcHRzO1xuXG4gICAgbGV0IHJhd1ZhbHVlID0gdXRpbHMuaXNNb25nb29zZUFycmF5KHZhbHVlKSA/IHZhbHVlLl9fYXJyYXkgOiB2YWx1ZTtcbiAgICBsZXQgcGF0aCA9IG9wdGlvbnMucGF0aCB8fCB0aGlzLnBhdGg7XG4gICAgaWYgKG9wdGlvbnMuYXJyYXlQYXRoSW5kZXggIT0gbnVsbCkge1xuICAgICAgcGF0aCArPSAnLicgKyBvcHRpb25zLmFycmF5UGF0aEluZGV4O1xuICAgIH1cbiAgICB2YWx1ZSA9IE1vbmdvb3NlQXJyYXkocmF3VmFsdWUsIHBhdGgsIGRvYywgdGhpcyk7XG4gICAgcmF3VmFsdWUgPSB2YWx1ZS5fX2FycmF5O1xuXG4gICAgaWYgKGluaXQgJiYgZG9jICE9IG51bGwgJiYgZG9jLiRfXyAhPSBudWxsICYmIGRvYy4kcG9wdWxhdGVkKHRoaXMucGF0aCkpIHtcbiAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9XG5cbiAgICBjb25zdCBjYXN0ZXIgPSB0aGlzLmNhc3RlcjtcbiAgICBjb25zdCBpc01vbmdvb3NlQXJyYXkgPSBjYXN0ZXIuJGlzTW9uZ29vc2VBcnJheTtcbiAgICBpZiAoY2FzdGVyICYmIHRoaXMuY2FzdGVyQ29uc3RydWN0b3IgIT09IE1peGVkKSB7XG4gICAgICB0cnkge1xuICAgICAgICBjb25zdCBsZW4gPSByYXdWYWx1ZS5sZW5ndGg7XG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgIGNvbnN0IG9wdHMgPSB7fTtcbiAgICAgICAgICAvLyBQZXJmOiBjcmVhdGluZyBgYXJyYXlQYXRoYCBpcyBleHBlbnNpdmUgZm9yIGxhcmdlIGFycmF5cy5cbiAgICAgICAgICAvLyBXZSBvbmx5IG5lZWQgYGFycmF5UGF0aGAgaWYgdGhpcyBpcyBhIG5lc3RlZCBhcnJheSwgc29cbiAgICAgICAgICAvLyBza2lwIGlmIHBvc3NpYmxlLlxuICAgICAgICAgIGlmIChpc01vbmdvb3NlQXJyYXkpIHtcbiAgICAgICAgICAgIGlmIChvcHRpb25zLmFycmF5UGF0aCAhPSBudWxsKSB7XG4gICAgICAgICAgICAgIG9wdHMuYXJyYXlQYXRoSW5kZXggPSBpO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChjYXN0ZXIuX2FycmF5UGFyZW50UGF0aCAhPSBudWxsKSB7XG4gICAgICAgICAgICAgIG9wdHMuYXJyYXlQYXRoSW5kZXggPSBpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICByYXdWYWx1ZVtpXSA9IGNhc3Rlci5hcHBseVNldHRlcnMocmF3VmFsdWVbaV0sIGRvYywgaW5pdCwgdm9pZCAwLCBvcHRzKTtcbiAgICAgICAgfVxuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAvLyByZXRocm93XG4gICAgICAgIHRocm93IG5ldyBDYXN0RXJyb3IoJ1snICsgZS5raW5kICsgJ10nLCB1dGlsLmluc3BlY3QodmFsdWUpLCB0aGlzLnBhdGggKyAnLicgKyBpLCBlLCB0aGlzKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gdmFsdWU7XG4gIH1cblxuICBjb25zdCBjYXN0Tm9uQXJyYXlzT3B0aW9uID0gdGhpcy5vcHRpb25zLmNhc3ROb25BcnJheXMgIT0gbnVsbCA/IHRoaXMub3B0aW9ucy5jYXN0Tm9uQXJyYXlzIDogU2NoZW1hQXJyYXkub3B0aW9ucy5jYXN0Tm9uQXJyYXlzO1xuICBpZiAoaW5pdCB8fCBjYXN0Tm9uQXJyYXlzT3B0aW9uKSB7XG4gICAgLy8gZ2gtMjQ0MjogaWYgd2UncmUgbG9hZGluZyB0aGlzIGZyb20gdGhlIGRiIGFuZCBpdHMgbm90IGFuIGFycmF5LCBtYXJrXG4gICAgLy8gdGhlIHdob2xlIGFycmF5IGFzIG1vZGlmaWVkLlxuICAgIGlmICghIWRvYyAmJiAhIWluaXQpIHtcbiAgICAgIGRvYy5tYXJrTW9kaWZpZWQodGhpcy5wYXRoKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuY2FzdChbdmFsdWVdLCBkb2MsIGluaXQpO1xuICB9XG5cbiAgdGhyb3cgbmV3IENhc3RFcnJvcignQXJyYXknLCB1dGlsLmluc3BlY3QodmFsdWUpLCB0aGlzLnBhdGgsIG51bGwsIHRoaXMpO1xufTtcblxuLyohXG4gKiBpZ25vcmVcbiAqL1xuXG5TY2hlbWFBcnJheS5wcm90b3R5cGUuX2Nhc3RGb3JQb3B1bGF0ZSA9IGZ1bmN0aW9uIF9jYXN0Rm9yUG9wdWxhdGUodmFsdWUsIGRvYykge1xuICAvLyBsYXp5IGxvYWRcbiAgTW9uZ29vc2VBcnJheSB8fCAoTW9uZ29vc2VBcnJheSA9IHJlcXVpcmUoJy4uL3R5cGVzJykuQXJyYXkpO1xuXG4gIGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgIGxldCBpO1xuICAgIGNvbnN0IHJhd1ZhbHVlID0gdmFsdWUuX19hcnJheSA/IHZhbHVlLl9fYXJyYXkgOiB2YWx1ZTtcbiAgICBjb25zdCBsZW4gPSByYXdWYWx1ZS5sZW5ndGg7XG5cbiAgICBjb25zdCBjYXN0ZXIgPSB0aGlzLmNhc3RlcjtcbiAgICBpZiAoY2FzdGVyICYmIHRoaXMuY2FzdGVyQ29uc3RydWN0b3IgIT09IE1peGVkKSB7XG4gICAgICB0cnkge1xuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICBjb25zdCBvcHRzID0ge307XG4gICAgICAgICAgLy8gUGVyZjogY3JlYXRpbmcgYGFycmF5UGF0aGAgaXMgZXhwZW5zaXZlIGZvciBsYXJnZSBhcnJheXMuXG4gICAgICAgICAgLy8gV2Ugb25seSBuZWVkIGBhcnJheVBhdGhgIGlmIHRoaXMgaXMgYSBuZXN0ZWQgYXJyYXksIHNvXG4gICAgICAgICAgLy8gc2tpcCBpZiBwb3NzaWJsZS5cbiAgICAgICAgICBpZiAoY2FzdGVyLiRpc01vbmdvb3NlQXJyYXkgJiYgY2FzdGVyLl9hcnJheVBhcmVudFBhdGggIT0gbnVsbCkge1xuICAgICAgICAgICAgb3B0cy5hcnJheVBhdGhJbmRleCA9IGk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmF3VmFsdWVbaV0gPSBjYXN0ZXIuY2FzdChyYXdWYWx1ZVtpXSwgZG9jLCBmYWxzZSwgdm9pZCAwLCBvcHRzKTtcbiAgICAgICAgfVxuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAvLyByZXRocm93XG4gICAgICAgIHRocm93IG5ldyBDYXN0RXJyb3IoJ1snICsgZS5raW5kICsgJ10nLCB1dGlsLmluc3BlY3QodmFsdWUpLCB0aGlzLnBhdGggKyAnLicgKyBpLCBlLCB0aGlzKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gdmFsdWU7XG4gIH1cblxuICB0aHJvdyBuZXcgQ2FzdEVycm9yKCdBcnJheScsIHV0aWwuaW5zcGVjdCh2YWx1ZSksIHRoaXMucGF0aCwgbnVsbCwgdGhpcyk7XG59O1xuXG5TY2hlbWFBcnJheS5wcm90b3R5cGUuJHRvT2JqZWN0ID0gU2NoZW1hQXJyYXkucHJvdG90eXBlLnRvT2JqZWN0O1xuXG4vKiFcbiAqIGlnbm9yZVxuICovXG5cblNjaGVtYUFycmF5LnByb3RvdHlwZS5kaXNjcmltaW5hdG9yID0gZnVuY3Rpb24oLi4uYXJncykge1xuICBsZXQgYXJyID0gdGhpcztcbiAgd2hpbGUgKGFyci4kaXNNb25nb29zZUFycmF5ICYmICFhcnIuJGlzTW9uZ29vc2VEb2N1bWVudEFycmF5KSB7XG4gICAgYXJyID0gYXJyLmNhc3RlckNvbnN0cnVjdG9yO1xuICAgIGlmIChhcnIgPT0gbnVsbCB8fCB0eXBlb2YgYXJyID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICB0aHJvdyBuZXcgTW9uZ29vc2VFcnJvcignWW91IGNhbiBvbmx5IGFkZCBhbiBlbWJlZGRlZCBkaXNjcmltaW5hdG9yIG9uICcgK1xuICAgICAgICAnYSBkb2N1bWVudCBhcnJheSwgJyArIHRoaXMucGF0aCArICcgaXMgYSBwbGFpbiBhcnJheScpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gYXJyLmRpc2NyaW1pbmF0b3IoLi4uYXJncyk7XG59O1xuXG4vKiFcbiAqIGlnbm9yZVxuICovXG5cblNjaGVtYUFycmF5LnByb3RvdHlwZS5jbG9uZSA9IGZ1bmN0aW9uKCkge1xuICBjb25zdCBvcHRpb25zID0gT2JqZWN0LmFzc2lnbih7fSwgdGhpcy5vcHRpb25zKTtcbiAgY29uc3Qgc2NoZW1hdHlwZSA9IG5ldyB0aGlzLmNvbnN0cnVjdG9yKHRoaXMucGF0aCwgdGhpcy5jYXN0ZXIsIG9wdGlvbnMsIHRoaXMuc2NoZW1hT3B0aW9ucyk7XG4gIHNjaGVtYXR5cGUudmFsaWRhdG9ycyA9IHRoaXMudmFsaWRhdG9ycy5zbGljZSgpO1xuICBpZiAodGhpcy5yZXF1aXJlZFZhbGlkYXRvciAhPT0gdW5kZWZpbmVkKSB7XG4gICAgc2NoZW1hdHlwZS5yZXF1aXJlZFZhbGlkYXRvciA9IHRoaXMucmVxdWlyZWRWYWxpZGF0b3I7XG4gIH1cbiAgcmV0dXJuIHNjaGVtYXR5cGU7XG59O1xuXG5TY2hlbWFBcnJheS5wcm90b3R5cGUuX2Nhc3RGb3JRdWVyeSA9IGZ1bmN0aW9uKHZhbCwgY29udGV4dCkge1xuICBsZXQgQ29uc3RydWN0b3IgPSB0aGlzLmNhc3RlckNvbnN0cnVjdG9yO1xuXG4gIGlmICh2YWwgJiZcbiAgICAgIENvbnN0cnVjdG9yLmRpc2NyaW1pbmF0b3JzICYmXG4gICAgICBDb25zdHJ1Y3Rvci5zY2hlbWEgJiZcbiAgICAgIENvbnN0cnVjdG9yLnNjaGVtYS5vcHRpb25zICYmXG4gICAgICBDb25zdHJ1Y3Rvci5zY2hlbWEub3B0aW9ucy5kaXNjcmltaW5hdG9yS2V5KSB7XG4gICAgaWYgKHR5cGVvZiB2YWxbQ29uc3RydWN0b3Iuc2NoZW1hLm9wdGlvbnMuZGlzY3JpbWluYXRvcktleV0gPT09ICdzdHJpbmcnICYmXG4gICAgICAgIENvbnN0cnVjdG9yLmRpc2NyaW1pbmF0b3JzW3ZhbFtDb25zdHJ1Y3Rvci5zY2hlbWEub3B0aW9ucy5kaXNjcmltaW5hdG9yS2V5XV0pIHtcbiAgICAgIENvbnN0cnVjdG9yID0gQ29uc3RydWN0b3IuZGlzY3JpbWluYXRvcnNbdmFsW0NvbnN0cnVjdG9yLnNjaGVtYS5vcHRpb25zLmRpc2NyaW1pbmF0b3JLZXldXTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3QgY29uc3RydWN0b3JCeVZhbHVlID0gZ2V0RGlzY3JpbWluYXRvckJ5VmFsdWUoQ29uc3RydWN0b3IuZGlzY3JpbWluYXRvcnMsIHZhbFtDb25zdHJ1Y3Rvci5zY2hlbWEub3B0aW9ucy5kaXNjcmltaW5hdG9yS2V5XSk7XG4gICAgICBpZiAoY29uc3RydWN0b3JCeVZhbHVlKSB7XG4gICAgICAgIENvbnN0cnVjdG9yID0gY29uc3RydWN0b3JCeVZhbHVlO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGNvbnN0IHByb3RvID0gdGhpcy5jYXN0ZXJDb25zdHJ1Y3Rvci5wcm90b3R5cGU7XG4gIGNvbnN0IHByb3RvQ2FzdEZvclF1ZXJ5ID0gcHJvdG8gJiYgcHJvdG8uY2FzdEZvclF1ZXJ5O1xuICBjb25zdCBwcm90b0Nhc3QgPSBwcm90byAmJiBwcm90by5jYXN0O1xuICBjb25zdCBjb25zdHJ1Y3RvckNhc3RGb3JRdWVyeSA9IENvbnN0cnVjdG9yLmNhc3RGb3JRdWVyeTtcbiAgY29uc3QgY2FzdGVyID0gdGhpcy5jYXN0ZXI7XG5cbiAgaWYgKEFycmF5LmlzQXJyYXkodmFsKSkge1xuICAgIHRoaXMuc2V0dGVycy5yZXZlcnNlKCkuZm9yRWFjaChzZXR0ZXIgPT4ge1xuICAgICAgdmFsID0gc2V0dGVyLmNhbGwodGhpcywgdmFsLCB0aGlzKTtcbiAgICB9KTtcbiAgICB2YWwgPSB2YWwubWFwKGZ1bmN0aW9uKHYpIHtcbiAgICAgIGlmICh1dGlscy5pc09iamVjdCh2KSAmJiB2LiRlbGVtTWF0Y2gpIHtcbiAgICAgICAgcmV0dXJuIHY7XG4gICAgICB9XG4gICAgICBpZiAocHJvdG9DYXN0Rm9yUXVlcnkpIHtcbiAgICAgICAgdiA9IHByb3RvQ2FzdEZvclF1ZXJ5LmNhbGwoY2FzdGVyLCBudWxsLCB2LCBjb250ZXh0KTtcbiAgICAgICAgcmV0dXJuIHY7XG4gICAgICB9IGVsc2UgaWYgKHByb3RvQ2FzdCkge1xuICAgICAgICB2ID0gcHJvdG9DYXN0LmNhbGwoY2FzdGVyLCB2KTtcbiAgICAgICAgcmV0dXJuIHY7XG4gICAgICB9IGVsc2UgaWYgKGNvbnN0cnVjdG9yQ2FzdEZvclF1ZXJ5KSB7XG4gICAgICAgIHYgPSBjb25zdHJ1Y3RvckNhc3RGb3JRdWVyeS5jYWxsKGNhc3RlciwgbnVsbCwgdiwgY29udGV4dCk7XG4gICAgICAgIHJldHVybiB2O1xuICAgICAgfVxuICAgICAgaWYgKHYgIT0gbnVsbCkge1xuICAgICAgICB2ID0gbmV3IENvbnN0cnVjdG9yKHYpO1xuICAgICAgICByZXR1cm4gdjtcbiAgICAgIH1cbiAgICAgIHJldHVybiB2O1xuICAgIH0pO1xuICB9IGVsc2UgaWYgKHByb3RvQ2FzdEZvclF1ZXJ5KSB7XG4gICAgdmFsID0gcHJvdG9DYXN0Rm9yUXVlcnkuY2FsbChjYXN0ZXIsIG51bGwsIHZhbCwgY29udGV4dCk7XG4gIH0gZWxzZSBpZiAocHJvdG9DYXN0KSB7XG4gICAgdmFsID0gcHJvdG9DYXN0LmNhbGwoY2FzdGVyLCB2YWwpO1xuICB9IGVsc2UgaWYgKGNvbnN0cnVjdG9yQ2FzdEZvclF1ZXJ5KSB7XG4gICAgdmFsID0gY29uc3RydWN0b3JDYXN0Rm9yUXVlcnkuY2FsbChjYXN0ZXIsIG51bGwsIHZhbCwgY29udGV4dCk7XG4gIH0gZWxzZSBpZiAodmFsICE9IG51bGwpIHtcbiAgICB2YWwgPSBuZXcgQ29uc3RydWN0b3IodmFsKTtcbiAgfVxuXG4gIHJldHVybiB2YWw7XG59O1xuXG4vKipcbiAqIENhc3RzIHZhbHVlcyBmb3IgcXVlcmllcy5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gJGNvbmRpdGlvbmFsXG4gKiBAcGFyYW0ge2FueX0gW3ZhbHVlXVxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuU2NoZW1hQXJyYXkucHJvdG90eXBlLmNhc3RGb3JRdWVyeSA9IGZ1bmN0aW9uKCRjb25kaXRpb25hbCwgdmFsLCBjb250ZXh0KSB7XG4gIGxldCBoYW5kbGVyO1xuXG4gIGlmICgkY29uZGl0aW9uYWwgIT0gbnVsbCkge1xuICAgIGhhbmRsZXIgPSB0aGlzLiRjb25kaXRpb25hbEhhbmRsZXJzWyRjb25kaXRpb25hbF07XG5cbiAgICBpZiAoIWhhbmRsZXIpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignQ2FuXFwndCB1c2UgJyArICRjb25kaXRpb25hbCArICcgd2l0aCBBcnJheS4nKTtcbiAgICB9XG5cbiAgICByZXR1cm4gaGFuZGxlci5jYWxsKHRoaXMsIHZhbCwgY29udGV4dCk7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIHRoaXMuX2Nhc3RGb3JRdWVyeSh2YWwsIGNvbnRleHQpO1xuICB9XG59O1xuXG5mdW5jdGlvbiBjYXN0JGFsbCh2YWwsIGNvbnRleHQpIHtcbiAgaWYgKCFBcnJheS5pc0FycmF5KHZhbCkpIHtcbiAgICB2YWwgPSBbdmFsXTtcbiAgfVxuXG4gIHZhbCA9IHZhbC5tYXAoKHYpID0+IHtcbiAgICBpZiAoIXV0aWxzLmlzT2JqZWN0KHYpKSB7XG4gICAgICByZXR1cm4gdjtcbiAgICB9XG4gICAgaWYgKHYuJGVsZW1NYXRjaCAhPSBudWxsKSB7XG4gICAgICByZXR1cm4geyAkZWxlbU1hdGNoOiBjYXN0KHRoaXMuY2FzdGVyQ29uc3RydWN0b3Iuc2NoZW1hLCB2LiRlbGVtTWF0Y2gsIG51bGwsIHRoaXMgJiYgdGhpcy4kJGNvbnRleHQpIH07XG4gICAgfVxuXG4gICAgY29uc3QgbyA9IHt9O1xuICAgIG9bdGhpcy5wYXRoXSA9IHY7XG4gICAgcmV0dXJuIGNhc3QodGhpcy5jYXN0ZXJDb25zdHJ1Y3Rvci5zY2hlbWEsIG8sIG51bGwsIHRoaXMgJiYgdGhpcy4kJGNvbnRleHQpW3RoaXMucGF0aF07XG4gIH0sIHRoaXMpO1xuXG4gIHJldHVybiB0aGlzLmNhc3RGb3JRdWVyeShudWxsLCB2YWwsIGNvbnRleHQpO1xufVxuXG5mdW5jdGlvbiBjYXN0JGVsZW1NYXRjaCh2YWwsIGNvbnRleHQpIHtcbiAgY29uc3Qga2V5cyA9IE9iamVjdC5rZXlzKHZhbCk7XG4gIGNvbnN0IG51bUtleXMgPSBrZXlzLmxlbmd0aDtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBudW1LZXlzOyArK2kpIHtcbiAgICBjb25zdCBrZXkgPSBrZXlzW2ldO1xuICAgIGNvbnN0IHZhbHVlID0gdmFsW2tleV07XG4gICAgaWYgKGlzT3BlcmF0b3Ioa2V5KSAmJiB2YWx1ZSAhPSBudWxsKSB7XG4gICAgICB2YWxba2V5XSA9IHRoaXMuY2FzdEZvclF1ZXJ5KGtleSwgdmFsdWUsIGNvbnRleHQpO1xuICAgIH1cbiAgfVxuXG4gIC8vIElzIHRoaXMgYW4gZW1iZWRkZWQgZGlzY3JpbWluYXRvciBhbmQgaXMgdGhlIGRpc2NyaW1pbmF0b3Iga2V5IHNldD9cbiAgLy8gSWYgc28sIHVzZSB0aGUgZGlzY3JpbWluYXRvciBzY2hlbWEuIFNlZSBnaC03NDQ5XG4gIGNvbnN0IGRpc2NyaW1pbmF0b3JLZXkgPSB0aGlzICYmXG4gICAgdGhpcy5jYXN0ZXJDb25zdHJ1Y3RvciAmJlxuICAgIHRoaXMuY2FzdGVyQ29uc3RydWN0b3Iuc2NoZW1hICYmXG4gICAgdGhpcy5jYXN0ZXJDb25zdHJ1Y3Rvci5zY2hlbWEub3B0aW9ucyAmJlxuICAgIHRoaXMuY2FzdGVyQ29uc3RydWN0b3Iuc2NoZW1hLm9wdGlvbnMuZGlzY3JpbWluYXRvcktleTtcbiAgY29uc3QgZGlzY3JpbWluYXRvcnMgPSB0aGlzICYmXG4gIHRoaXMuY2FzdGVyQ29uc3RydWN0b3IgJiZcbiAgdGhpcy5jYXN0ZXJDb25zdHJ1Y3Rvci5zY2hlbWEgJiZcbiAgdGhpcy5jYXN0ZXJDb25zdHJ1Y3Rvci5zY2hlbWEuZGlzY3JpbWluYXRvcnMgfHwge307XG4gIGlmIChkaXNjcmltaW5hdG9yS2V5ICE9IG51bGwgJiZcbiAgICAgIHZhbFtkaXNjcmltaW5hdG9yS2V5XSAhPSBudWxsICYmXG4gICAgICBkaXNjcmltaW5hdG9yc1t2YWxbZGlzY3JpbWluYXRvcktleV1dICE9IG51bGwpIHtcbiAgICByZXR1cm4gY2FzdChkaXNjcmltaW5hdG9yc1t2YWxbZGlzY3JpbWluYXRvcktleV1dLCB2YWwsIG51bGwsIHRoaXMgJiYgdGhpcy4kJGNvbnRleHQpO1xuICB9XG4gIGNvbnN0IHNjaGVtYSA9IHRoaXMuY2FzdGVyQ29uc3RydWN0b3Iuc2NoZW1hID8/IGNvbnRleHQuc2NoZW1hO1xuICByZXR1cm4gY2FzdChzY2hlbWEsIHZhbCwgbnVsbCwgdGhpcyAmJiB0aGlzLiQkY29udGV4dCk7XG59XG5cbmNvbnN0IGhhbmRsZSA9IFNjaGVtYUFycmF5LnByb3RvdHlwZS4kY29uZGl0aW9uYWxIYW5kbGVycyA9IHt9O1xuXG5oYW5kbGUuJGFsbCA9IGNhc3QkYWxsO1xuaGFuZGxlLiRvcHRpb25zID0gU3RyaW5nO1xuaGFuZGxlLiRlbGVtTWF0Y2ggPSBjYXN0JGVsZW1NYXRjaDtcbmhhbmRsZS4kZ2VvSW50ZXJzZWN0cyA9IGdlb3NwYXRpYWwuY2FzdCRnZW9JbnRlcnNlY3RzO1xuaGFuZGxlLiRvciA9IGNyZWF0ZUxvZ2ljYWxRdWVyeU9wZXJhdG9ySGFuZGxlcignJG9yJyk7XG5oYW5kbGUuJGFuZCA9IGNyZWF0ZUxvZ2ljYWxRdWVyeU9wZXJhdG9ySGFuZGxlcignJGFuZCcpO1xuaGFuZGxlLiRub3IgPSBjcmVhdGVMb2dpY2FsUXVlcnlPcGVyYXRvckhhbmRsZXIoJyRub3InKTtcblxuZnVuY3Rpb24gY3JlYXRlTG9naWNhbFF1ZXJ5T3BlcmF0b3JIYW5kbGVyKG9wKSB7XG4gIHJldHVybiBmdW5jdGlvbiBsb2dpY2FsUXVlcnlPcGVyYXRvckhhbmRsZXIodmFsKSB7XG4gICAgaWYgKCFBcnJheS5pc0FycmF5KHZhbCkpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2NvbmRpdGlvbmFsICcgKyBvcCArICcgcmVxdWlyZXMgYW4gYXJyYXknKTtcbiAgICB9XG5cbiAgICBjb25zdCByZXQgPSBbXTtcbiAgICBmb3IgKGNvbnN0IG9iaiBvZiB2YWwpIHtcbiAgICAgIHJldC5wdXNoKGNhc3QodGhpcy5jYXN0ZXJDb25zdHJ1Y3Rvci5zY2hlbWEsIG9iaiwgbnVsbCwgdGhpcyAmJiB0aGlzLiQkY29udGV4dCkpO1xuICAgIH1cblxuICAgIHJldHVybiByZXQ7XG4gIH07XG59XG5cbmhhbmRsZS4kbmVhciA9XG5oYW5kbGUuJG5lYXJTcGhlcmUgPSBnZW9zcGF0aWFsLmNhc3QkbmVhcjtcblxuaGFuZGxlLiR3aXRoaW4gPVxuaGFuZGxlLiRnZW9XaXRoaW4gPSBnZW9zcGF0aWFsLmNhc3Qkd2l0aGluO1xuXG5oYW5kbGUuJHNpemUgPVxuaGFuZGxlLiRtaW5EaXN0YW5jZSA9XG5oYW5kbGUuJG1heERpc3RhbmNlID0gY2FzdFRvTnVtYmVyO1xuXG5oYW5kbGUuJGV4aXN0cyA9ICRleGlzdHM7XG5oYW5kbGUuJHR5cGUgPSAkdHlwZTtcblxuaGFuZGxlLiRlcSA9XG5oYW5kbGUuJGd0ID1cbmhhbmRsZS4kZ3RlID1cbmhhbmRsZS4kbHQgPVxuaGFuZGxlLiRsdGUgPVxuaGFuZGxlLiRub3QgPVxuaGFuZGxlLiRyZWdleCA9XG5oYW5kbGUuJG5lID0gU2NoZW1hQXJyYXkucHJvdG90eXBlLl9jYXN0Rm9yUXVlcnk7XG5cbi8vIGAkaW5gIGlzIHNwZWNpYWwgYmVjYXVzZSB5b3UgY2FuIGFsc28gaW5jbHVkZSBhbiBlbXB0eSBhcnJheSBpbiB0aGUgcXVlcnlcbi8vIGxpa2UgYCRpbjogWzEsIFtdXWAsIHNlZSBnaC01OTEzXG5oYW5kbGUuJG5pbiA9IFNjaGVtYVR5cGUucHJvdG90eXBlLiRjb25kaXRpb25hbEhhbmRsZXJzLiRuaW47XG5oYW5kbGUuJGluID0gU2NoZW1hVHlwZS5wcm90b3R5cGUuJGNvbmRpdGlvbmFsSGFuZGxlcnMuJGluO1xuXG4vKiFcbiAqIE1vZHVsZSBleHBvcnRzLlxuICovXG5cbm1vZHVsZS5leHBvcnRzID0gU2NoZW1hQXJyYXk7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/mongoose/lib/schema/array.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/mongoose/lib/schema/bigint.js":
/*!****************************************************!*\
  !*** ./node_modules/mongoose/lib/schema/bigint.js ***!
  \****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\n\n/*!\n * Module dependencies.\n */\n\nconst CastError = __webpack_require__(/*! ../error/cast */ \"(ssr)/./node_modules/mongoose/lib/error/cast.js\");\nconst SchemaType = __webpack_require__(/*! ../schemaType */ \"(ssr)/./node_modules/mongoose/lib/schemaType.js\");\nconst castBigInt = __webpack_require__(/*! ../cast/bigint */ \"(ssr)/./node_modules/mongoose/lib/cast/bigint.js\");\nconst utils = __webpack_require__(/*! ../utils */ \"(ssr)/./node_modules/mongoose/lib/utils.js\");\n\n/**\n * BigInt SchemaType constructor.\n *\n * @param {String} path\n * @param {Object} options\n * @inherits SchemaType\n * @api public\n */\n\nfunction SchemaBigInt(path, options) {\n  SchemaType.call(this, path, options, 'BigInt');\n}\n\n/**\n * This schema type's name, to defend against minifiers that mangle\n * function names.\n *\n * @api public\n */\nSchemaBigInt.schemaName = 'BigInt';\n\nSchemaBigInt.defaultOptions = {};\n\n/*!\n * Inherits from SchemaType.\n */\nSchemaBigInt.prototype = Object.create(SchemaType.prototype);\nSchemaBigInt.prototype.constructor = SchemaBigInt;\n\n/*!\n * ignore\n */\n\nSchemaBigInt._cast = castBigInt;\n\n/**\n * Sets a default option for all BigInt instances.\n *\n * #### Example:\n *\n *     // Make all bigints required by default\n *     mongoose.Schema.BigInt.set('required', true);\n *\n * @param {String} option The option you'd like to set the value for\n * @param {Any} value value for option\n * @return {undefined}\n * @function set\n * @static\n * @api public\n */\n\nSchemaBigInt.set = SchemaType.set;\n\nSchemaBigInt.setters = [];\n\n/**\n * Attaches a getter for all BigInt instances\n *\n * #### Example:\n *\n *     // Convert bigints to numbers\n *     mongoose.Schema.BigInt.get(v => v == null ? v : Number(v));\n *\n * @param {Function} getter\n * @return {this}\n * @function get\n * @static\n * @api public\n */\n\nSchemaBigInt.get = SchemaType.get;\n\n/**\n * Get/set the function used to cast arbitrary values to booleans.\n *\n * #### Example:\n *\n *     // Make Mongoose cast empty string '' to false.\n *     const original = mongoose.Schema.BigInt.cast();\n *     mongoose.Schema.BigInt.cast(v => {\n *       if (v === '') {\n *         return false;\n *       }\n *       return original(v);\n *     });\n *\n *     // Or disable casting entirely\n *     mongoose.Schema.BigInt.cast(false);\n *\n * @param {Function} caster\n * @return {Function}\n * @function get\n * @static\n * @api public\n */\n\nSchemaBigInt.cast = function cast(caster) {\n  if (arguments.length === 0) {\n    return this._cast;\n  }\n  if (caster === false) {\n    caster = this._defaultCaster;\n  }\n  this._cast = caster;\n\n  return this._cast;\n};\n\n/*!\n * ignore\n */\n\nSchemaBigInt._checkRequired = v => v != null;\n\n/**\n * Override the function the required validator uses to check whether a value\n * passes the `required` check.\n *\n * @param {Function} fn\n * @return {Function}\n * @function checkRequired\n * @static\n * @api public\n */\n\nSchemaBigInt.checkRequired = SchemaType.checkRequired;\n\n/**\n * Check if the given value satisfies a required validator.\n *\n * @param {Any} value\n * @return {Boolean}\n * @api public\n */\n\nSchemaBigInt.prototype.checkRequired = function(value) {\n  return this.constructor._checkRequired(value);\n};\n\n/**\n * Casts to bigint\n *\n * @param {Object} value\n * @param {Object} model this value is optional\n * @api private\n */\n\nSchemaBigInt.prototype.cast = function(value) {\n  let castBigInt;\n  if (typeof this._castFunction === 'function') {\n    castBigInt = this._castFunction;\n  } else if (typeof this.constructor.cast === 'function') {\n    castBigInt = this.constructor.cast();\n  } else {\n    castBigInt = SchemaBigInt.cast();\n  }\n\n  try {\n    return castBigInt(value);\n  } catch (error) {\n    throw new CastError('BigInt', value, this.path, error, this);\n  }\n};\n\n/*!\n * ignore\n */\n\nSchemaBigInt.$conditionalHandlers = utils.options(SchemaType.prototype.$conditionalHandlers, {\n  $gt: handleSingle,\n  $gte: handleSingle,\n  $lt: handleSingle,\n  $lte: handleSingle\n});\n\n/*!\n * ignore\n */\n\nfunction handleSingle(val, context) {\n  return this.castForQuery(null, val, context);\n}\n\n/**\n * Casts contents for queries.\n *\n * @param {String} $conditional\n * @param {any} val\n * @api private\n */\n\nSchemaBigInt.prototype.castForQuery = function($conditional, val, context) {\n  let handler;\n  if ($conditional != null) {\n    handler = SchemaBigInt.$conditionalHandlers[$conditional];\n\n    if (handler) {\n      return handler.call(this, val);\n    }\n\n    return this.applySetters(null, val, context);\n  }\n\n  return this.applySetters(val, context);\n};\n\n/**\n *\n * @api private\n */\n\nSchemaBigInt.prototype._castNullish = function _castNullish(v) {\n  if (typeof v === 'undefined') {\n    return v;\n  }\n  const castBigInt = typeof this.constructor.cast === 'function' ?\n    this.constructor.cast() :\n    SchemaBigInt.cast();\n  if (castBigInt == null) {\n    return v;\n  }\n  return v;\n};\n\n/*!\n * Module exports.\n */\n\nmodule.exports = SchemaBigInt;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbW9uZ29vc2UvbGliL3NjaGVtYS9iaWdpbnQuanMiLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWI7QUFDQTtBQUNBOztBQUVBLGtCQUFrQixtQkFBTyxDQUFDLHNFQUFlO0FBQ3pDLG1CQUFtQixtQkFBTyxDQUFDLHNFQUFlO0FBQzFDLG1CQUFtQixtQkFBTyxDQUFDLHdFQUFnQjtBQUMzQyxjQUFjLG1CQUFPLENBQUMsNERBQVU7O0FBRWhDO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFdBQVcsS0FBSztBQUNoQixZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsVUFBVTtBQUNyQixZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxVQUFVO0FBQ3JCLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxVQUFVO0FBQ3JCLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLEtBQUs7QUFDaEIsWUFBWTtBQUNaO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBLElBQUk7QUFDSjtBQUNBOztBQUVBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLEtBQUs7QUFDaEI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9hcHAxLy4vbm9kZV9tb2R1bGVzL21vbmdvb3NlL2xpYi9zY2hlbWEvYmlnaW50LmpzPzhjYjMiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG4vKiFcbiAqIE1vZHVsZSBkZXBlbmRlbmNpZXMuXG4gKi9cblxuY29uc3QgQ2FzdEVycm9yID0gcmVxdWlyZSgnLi4vZXJyb3IvY2FzdCcpO1xuY29uc3QgU2NoZW1hVHlwZSA9IHJlcXVpcmUoJy4uL3NjaGVtYVR5cGUnKTtcbmNvbnN0IGNhc3RCaWdJbnQgPSByZXF1aXJlKCcuLi9jYXN0L2JpZ2ludCcpO1xuY29uc3QgdXRpbHMgPSByZXF1aXJlKCcuLi91dGlscycpO1xuXG4vKipcbiAqIEJpZ0ludCBTY2hlbWFUeXBlIGNvbnN0cnVjdG9yLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBwYXRoXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xuICogQGluaGVyaXRzIFNjaGVtYVR5cGVcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZnVuY3Rpb24gU2NoZW1hQmlnSW50KHBhdGgsIG9wdGlvbnMpIHtcbiAgU2NoZW1hVHlwZS5jYWxsKHRoaXMsIHBhdGgsIG9wdGlvbnMsICdCaWdJbnQnKTtcbn1cblxuLyoqXG4gKiBUaGlzIHNjaGVtYSB0eXBlJ3MgbmFtZSwgdG8gZGVmZW5kIGFnYWluc3QgbWluaWZpZXJzIHRoYXQgbWFuZ2xlXG4gKiBmdW5jdGlvbiBuYW1lcy5cbiAqXG4gKiBAYXBpIHB1YmxpY1xuICovXG5TY2hlbWFCaWdJbnQuc2NoZW1hTmFtZSA9ICdCaWdJbnQnO1xuXG5TY2hlbWFCaWdJbnQuZGVmYXVsdE9wdGlvbnMgPSB7fTtcblxuLyohXG4gKiBJbmhlcml0cyBmcm9tIFNjaGVtYVR5cGUuXG4gKi9cblNjaGVtYUJpZ0ludC5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKFNjaGVtYVR5cGUucHJvdG90eXBlKTtcblNjaGVtYUJpZ0ludC5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBTY2hlbWFCaWdJbnQ7XG5cbi8qIVxuICogaWdub3JlXG4gKi9cblxuU2NoZW1hQmlnSW50Ll9jYXN0ID0gY2FzdEJpZ0ludDtcblxuLyoqXG4gKiBTZXRzIGEgZGVmYXVsdCBvcHRpb24gZm9yIGFsbCBCaWdJbnQgaW5zdGFuY2VzLlxuICpcbiAqICMjIyMgRXhhbXBsZTpcbiAqXG4gKiAgICAgLy8gTWFrZSBhbGwgYmlnaW50cyByZXF1aXJlZCBieSBkZWZhdWx0XG4gKiAgICAgbW9uZ29vc2UuU2NoZW1hLkJpZ0ludC5zZXQoJ3JlcXVpcmVkJywgdHJ1ZSk7XG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IG9wdGlvbiBUaGUgb3B0aW9uIHlvdSdkIGxpa2UgdG8gc2V0IHRoZSB2YWx1ZSBmb3JcbiAqIEBwYXJhbSB7QW55fSB2YWx1ZSB2YWx1ZSBmb3Igb3B0aW9uXG4gKiBAcmV0dXJuIHt1bmRlZmluZWR9XG4gKiBAZnVuY3Rpb24gc2V0XG4gKiBAc3RhdGljXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cblNjaGVtYUJpZ0ludC5zZXQgPSBTY2hlbWFUeXBlLnNldDtcblxuU2NoZW1hQmlnSW50LnNldHRlcnMgPSBbXTtcblxuLyoqXG4gKiBBdHRhY2hlcyBhIGdldHRlciBmb3IgYWxsIEJpZ0ludCBpbnN0YW5jZXNcbiAqXG4gKiAjIyMjIEV4YW1wbGU6XG4gKlxuICogICAgIC8vIENvbnZlcnQgYmlnaW50cyB0byBudW1iZXJzXG4gKiAgICAgbW9uZ29vc2UuU2NoZW1hLkJpZ0ludC5nZXQodiA9PiB2ID09IG51bGwgPyB2IDogTnVtYmVyKHYpKTtcbiAqXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBnZXR0ZXJcbiAqIEByZXR1cm4ge3RoaXN9XG4gKiBAZnVuY3Rpb24gZ2V0XG4gKiBAc3RhdGljXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cblNjaGVtYUJpZ0ludC5nZXQgPSBTY2hlbWFUeXBlLmdldDtcblxuLyoqXG4gKiBHZXQvc2V0IHRoZSBmdW5jdGlvbiB1c2VkIHRvIGNhc3QgYXJiaXRyYXJ5IHZhbHVlcyB0byBib29sZWFucy5cbiAqXG4gKiAjIyMjIEV4YW1wbGU6XG4gKlxuICogICAgIC8vIE1ha2UgTW9uZ29vc2UgY2FzdCBlbXB0eSBzdHJpbmcgJycgdG8gZmFsc2UuXG4gKiAgICAgY29uc3Qgb3JpZ2luYWwgPSBtb25nb29zZS5TY2hlbWEuQmlnSW50LmNhc3QoKTtcbiAqICAgICBtb25nb29zZS5TY2hlbWEuQmlnSW50LmNhc3QodiA9PiB7XG4gKiAgICAgICBpZiAodiA9PT0gJycpIHtcbiAqICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICogICAgICAgfVxuICogICAgICAgcmV0dXJuIG9yaWdpbmFsKHYpO1xuICogICAgIH0pO1xuICpcbiAqICAgICAvLyBPciBkaXNhYmxlIGNhc3RpbmcgZW50aXJlbHlcbiAqICAgICBtb25nb29zZS5TY2hlbWEuQmlnSW50LmNhc3QoZmFsc2UpO1xuICpcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGNhc3RlclxuICogQHJldHVybiB7RnVuY3Rpb259XG4gKiBAZnVuY3Rpb24gZ2V0XG4gKiBAc3RhdGljXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cblNjaGVtYUJpZ0ludC5jYXN0ID0gZnVuY3Rpb24gY2FzdChjYXN0ZXIpIHtcbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDApIHtcbiAgICByZXR1cm4gdGhpcy5fY2FzdDtcbiAgfVxuICBpZiAoY2FzdGVyID09PSBmYWxzZSkge1xuICAgIGNhc3RlciA9IHRoaXMuX2RlZmF1bHRDYXN0ZXI7XG4gIH1cbiAgdGhpcy5fY2FzdCA9IGNhc3RlcjtcblxuICByZXR1cm4gdGhpcy5fY2FzdDtcbn07XG5cbi8qIVxuICogaWdub3JlXG4gKi9cblxuU2NoZW1hQmlnSW50Ll9jaGVja1JlcXVpcmVkID0gdiA9PiB2ICE9IG51bGw7XG5cbi8qKlxuICogT3ZlcnJpZGUgdGhlIGZ1bmN0aW9uIHRoZSByZXF1aXJlZCB2YWxpZGF0b3IgdXNlcyB0byBjaGVjayB3aGV0aGVyIGEgdmFsdWVcbiAqIHBhc3NlcyB0aGUgYHJlcXVpcmVkYCBjaGVjay5cbiAqXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmblxuICogQHJldHVybiB7RnVuY3Rpb259XG4gKiBAZnVuY3Rpb24gY2hlY2tSZXF1aXJlZFxuICogQHN0YXRpY1xuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5TY2hlbWFCaWdJbnQuY2hlY2tSZXF1aXJlZCA9IFNjaGVtYVR5cGUuY2hlY2tSZXF1aXJlZDtcblxuLyoqXG4gKiBDaGVjayBpZiB0aGUgZ2l2ZW4gdmFsdWUgc2F0aXNmaWVzIGEgcmVxdWlyZWQgdmFsaWRhdG9yLlxuICpcbiAqIEBwYXJhbSB7QW55fSB2YWx1ZVxuICogQHJldHVybiB7Qm9vbGVhbn1cbiAqIEBhcGkgcHVibGljXG4gKi9cblxuU2NoZW1hQmlnSW50LnByb3RvdHlwZS5jaGVja1JlcXVpcmVkID0gZnVuY3Rpb24odmFsdWUpIHtcbiAgcmV0dXJuIHRoaXMuY29uc3RydWN0b3IuX2NoZWNrUmVxdWlyZWQodmFsdWUpO1xufTtcblxuLyoqXG4gKiBDYXN0cyB0byBiaWdpbnRcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gdmFsdWVcbiAqIEBwYXJhbSB7T2JqZWN0fSBtb2RlbCB0aGlzIHZhbHVlIGlzIG9wdGlvbmFsXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5TY2hlbWFCaWdJbnQucHJvdG90eXBlLmNhc3QgPSBmdW5jdGlvbih2YWx1ZSkge1xuICBsZXQgY2FzdEJpZ0ludDtcbiAgaWYgKHR5cGVvZiB0aGlzLl9jYXN0RnVuY3Rpb24gPT09ICdmdW5jdGlvbicpIHtcbiAgICBjYXN0QmlnSW50ID0gdGhpcy5fY2FzdEZ1bmN0aW9uO1xuICB9IGVsc2UgaWYgKHR5cGVvZiB0aGlzLmNvbnN0cnVjdG9yLmNhc3QgPT09ICdmdW5jdGlvbicpIHtcbiAgICBjYXN0QmlnSW50ID0gdGhpcy5jb25zdHJ1Y3Rvci5jYXN0KCk7XG4gIH0gZWxzZSB7XG4gICAgY2FzdEJpZ0ludCA9IFNjaGVtYUJpZ0ludC5jYXN0KCk7XG4gIH1cblxuICB0cnkge1xuICAgIHJldHVybiBjYXN0QmlnSW50KHZhbHVlKTtcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICB0aHJvdyBuZXcgQ2FzdEVycm9yKCdCaWdJbnQnLCB2YWx1ZSwgdGhpcy5wYXRoLCBlcnJvciwgdGhpcyk7XG4gIH1cbn07XG5cbi8qIVxuICogaWdub3JlXG4gKi9cblxuU2NoZW1hQmlnSW50LiRjb25kaXRpb25hbEhhbmRsZXJzID0gdXRpbHMub3B0aW9ucyhTY2hlbWFUeXBlLnByb3RvdHlwZS4kY29uZGl0aW9uYWxIYW5kbGVycywge1xuICAkZ3Q6IGhhbmRsZVNpbmdsZSxcbiAgJGd0ZTogaGFuZGxlU2luZ2xlLFxuICAkbHQ6IGhhbmRsZVNpbmdsZSxcbiAgJGx0ZTogaGFuZGxlU2luZ2xlXG59KTtcblxuLyohXG4gKiBpZ25vcmVcbiAqL1xuXG5mdW5jdGlvbiBoYW5kbGVTaW5nbGUodmFsLCBjb250ZXh0KSB7XG4gIHJldHVybiB0aGlzLmNhc3RGb3JRdWVyeShudWxsLCB2YWwsIGNvbnRleHQpO1xufVxuXG4vKipcbiAqIENhc3RzIGNvbnRlbnRzIGZvciBxdWVyaWVzLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSAkY29uZGl0aW9uYWxcbiAqIEBwYXJhbSB7YW55fSB2YWxcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cblNjaGVtYUJpZ0ludC5wcm90b3R5cGUuY2FzdEZvclF1ZXJ5ID0gZnVuY3Rpb24oJGNvbmRpdGlvbmFsLCB2YWwsIGNvbnRleHQpIHtcbiAgbGV0IGhhbmRsZXI7XG4gIGlmICgkY29uZGl0aW9uYWwgIT0gbnVsbCkge1xuICAgIGhhbmRsZXIgPSBTY2hlbWFCaWdJbnQuJGNvbmRpdGlvbmFsSGFuZGxlcnNbJGNvbmRpdGlvbmFsXTtcblxuICAgIGlmIChoYW5kbGVyKSB7XG4gICAgICByZXR1cm4gaGFuZGxlci5jYWxsKHRoaXMsIHZhbCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMuYXBwbHlTZXR0ZXJzKG51bGwsIHZhbCwgY29udGV4dCk7XG4gIH1cblxuICByZXR1cm4gdGhpcy5hcHBseVNldHRlcnModmFsLCBjb250ZXh0KTtcbn07XG5cbi8qKlxuICpcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cblNjaGVtYUJpZ0ludC5wcm90b3R5cGUuX2Nhc3ROdWxsaXNoID0gZnVuY3Rpb24gX2Nhc3ROdWxsaXNoKHYpIHtcbiAgaWYgKHR5cGVvZiB2ID09PSAndW5kZWZpbmVkJykge1xuICAgIHJldHVybiB2O1xuICB9XG4gIGNvbnN0IGNhc3RCaWdJbnQgPSB0eXBlb2YgdGhpcy5jb25zdHJ1Y3Rvci5jYXN0ID09PSAnZnVuY3Rpb24nID9cbiAgICB0aGlzLmNvbnN0cnVjdG9yLmNhc3QoKSA6XG4gICAgU2NoZW1hQmlnSW50LmNhc3QoKTtcbiAgaWYgKGNhc3RCaWdJbnQgPT0gbnVsbCkge1xuICAgIHJldHVybiB2O1xuICB9XG4gIHJldHVybiB2O1xufTtcblxuLyohXG4gKiBNb2R1bGUgZXhwb3J0cy5cbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IFNjaGVtYUJpZ0ludDtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/mongoose/lib/schema/bigint.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/mongoose/lib/schema/boolean.js":
/*!*****************************************************!*\
  !*** ./node_modules/mongoose/lib/schema/boolean.js ***!
  \*****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\n\n/*!\n * Module dependencies.\n */\n\nconst CastError = __webpack_require__(/*! ../error/cast */ \"(ssr)/./node_modules/mongoose/lib/error/cast.js\");\nconst SchemaType = __webpack_require__(/*! ../schemaType */ \"(ssr)/./node_modules/mongoose/lib/schemaType.js\");\nconst castBoolean = __webpack_require__(/*! ../cast/boolean */ \"(ssr)/./node_modules/mongoose/lib/cast/boolean.js\");\nconst utils = __webpack_require__(/*! ../utils */ \"(ssr)/./node_modules/mongoose/lib/utils.js\");\n\n/**\n * Boolean SchemaType constructor.\n *\n * @param {String} path\n * @param {Object} options\n * @inherits SchemaType\n * @api public\n */\n\nfunction SchemaBoolean(path, options) {\n  SchemaType.call(this, path, options, 'Boolean');\n}\n\n/**\n * This schema type's name, to defend against minifiers that mangle\n * function names.\n *\n * @api public\n */\nSchemaBoolean.schemaName = 'Boolean';\n\nSchemaBoolean.defaultOptions = {};\n\n/*!\n * Inherits from SchemaType.\n */\nSchemaBoolean.prototype = Object.create(SchemaType.prototype);\nSchemaBoolean.prototype.constructor = SchemaBoolean;\n\n/*!\n * ignore\n */\n\nSchemaBoolean._cast = castBoolean;\n\n/**\n * Sets a default option for all Boolean instances.\n *\n * #### Example:\n *\n *     // Make all booleans have `default` of false.\n *     mongoose.Schema.Boolean.set('default', false);\n *\n *     const Order = mongoose.model('Order', new Schema({ isPaid: Boolean }));\n *     new Order({ }).isPaid; // false\n *\n * @param {String} option The option you'd like to set the value for\n * @param {Any} value value for option\n * @return {undefined}\n * @function set\n * @static\n * @api public\n */\n\nSchemaBoolean.set = SchemaType.set;\n\nSchemaBoolean.setters = [];\n\n/**\n * Attaches a getter for all Boolean instances\n *\n * #### Example:\n *\n *     mongoose.Schema.Boolean.get(v => v === true ? 'yes' : 'no');\n *\n *     const Order = mongoose.model('Order', new Schema({ isPaid: Boolean }));\n *     new Order({ isPaid: false }).isPaid; // 'no'\n *\n * @param {Function} getter\n * @return {this}\n * @function get\n * @static\n * @api public\n */\n\nSchemaBoolean.get = SchemaType.get;\n\n/**\n * Get/set the function used to cast arbitrary values to booleans.\n *\n * #### Example:\n *\n *     // Make Mongoose cast empty string '' to false.\n *     const original = mongoose.Schema.Boolean.cast();\n *     mongoose.Schema.Boolean.cast(v => {\n *       if (v === '') {\n *         return false;\n *       }\n *       return original(v);\n *     });\n *\n *     // Or disable casting entirely\n *     mongoose.Schema.Boolean.cast(false);\n *\n * @param {Function} caster\n * @return {Function}\n * @function get\n * @static\n * @api public\n */\n\nSchemaBoolean.cast = function cast(caster) {\n  if (arguments.length === 0) {\n    return this._cast;\n  }\n  if (caster === false) {\n    caster = this._defaultCaster;\n  }\n  this._cast = caster;\n\n  return this._cast;\n};\n\n/*!\n * ignore\n */\n\nSchemaBoolean._defaultCaster = v => {\n  if (v != null && typeof v !== 'boolean') {\n    throw new Error();\n  }\n  return v;\n};\n\n/*!\n * ignore\n */\n\nSchemaBoolean._checkRequired = v => v === true || v === false;\n\n/**\n * Override the function the required validator uses to check whether a boolean\n * passes the `required` check.\n *\n * @param {Function} fn\n * @return {Function}\n * @function checkRequired\n * @static\n * @api public\n */\n\nSchemaBoolean.checkRequired = SchemaType.checkRequired;\n\n/**\n * Check if the given value satisfies a required validator. For a boolean\n * to satisfy a required validator, it must be strictly equal to true or to\n * false.\n *\n * @param {Any} value\n * @return {Boolean}\n * @api public\n */\n\nSchemaBoolean.prototype.checkRequired = function(value) {\n  return this.constructor._checkRequired(value);\n};\n\n/**\n * Configure which values get casted to `true`.\n *\n * #### Example:\n *\n *     const M = mongoose.model('Test', new Schema({ b: Boolean }));\n *     new M({ b: 'affirmative' }).b; // undefined\n *     mongoose.Schema.Boolean.convertToTrue.add('affirmative');\n *     new M({ b: 'affirmative' }).b; // true\n *\n * @property convertToTrue\n * @static\n * @memberOf SchemaBoolean\n * @type {Set}\n * @api public\n */\n\nObject.defineProperty(SchemaBoolean, 'convertToTrue', {\n  get: () => castBoolean.convertToTrue,\n  set: v => { castBoolean.convertToTrue = v; }\n});\n\n/**\n * Configure which values get casted to `false`.\n *\n * #### Example:\n *\n *     const M = mongoose.model('Test', new Schema({ b: Boolean }));\n *     new M({ b: 'nay' }).b; // undefined\n *     mongoose.Schema.Types.Boolean.convertToFalse.add('nay');\n *     new M({ b: 'nay' }).b; // false\n *\n * @property convertToFalse\n * @static\n * @memberOf SchemaBoolean\n * @type {Set}\n * @api public\n */\n\nObject.defineProperty(SchemaBoolean, 'convertToFalse', {\n  get: () => castBoolean.convertToFalse,\n  set: v => { castBoolean.convertToFalse = v; }\n});\n\n/**\n * Casts to boolean\n *\n * @param {Object} value\n * @param {Object} model this value is optional\n * @api private\n */\n\nSchemaBoolean.prototype.cast = function(value) {\n  let castBoolean;\n  if (typeof this._castFunction === 'function') {\n    castBoolean = this._castFunction;\n  } else if (typeof this.constructor.cast === 'function') {\n    castBoolean = this.constructor.cast();\n  } else {\n    castBoolean = SchemaBoolean.cast();\n  }\n\n  try {\n    return castBoolean(value);\n  } catch (error) {\n    throw new CastError('Boolean', value, this.path, error, this);\n  }\n};\n\nSchemaBoolean.$conditionalHandlers =\n    utils.options(SchemaType.prototype.$conditionalHandlers, {});\n\n/**\n * Casts contents for queries.\n *\n * @param {String} $conditional\n * @param {any} val\n * @api private\n */\n\nSchemaBoolean.prototype.castForQuery = function($conditional, val, context) {\n  let handler;\n  if ($conditional != null) {\n    handler = SchemaBoolean.$conditionalHandlers[$conditional];\n\n    if (handler) {\n      return handler.call(this, val);\n    }\n\n    return this.applySetters(null, val, context);\n  }\n\n  return this.applySetters(val, context);\n};\n\n/**\n *\n * @api private\n */\n\nSchemaBoolean.prototype._castNullish = function _castNullish(v) {\n  if (typeof v === 'undefined') {\n    return v;\n  }\n  const castBoolean = typeof this.constructor.cast === 'function' ?\n    this.constructor.cast() :\n    SchemaBoolean.cast();\n  if (castBoolean == null) {\n    return v;\n  }\n  if (castBoolean.convertToFalse instanceof Set && castBoolean.convertToFalse.has(v)) {\n    return false;\n  }\n  if (castBoolean.convertToTrue instanceof Set && castBoolean.convertToTrue.has(v)) {\n    return true;\n  }\n  return v;\n};\n\n/*!\n * Module exports.\n */\n\nmodule.exports = SchemaBoolean;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbW9uZ29vc2UvbGliL3NjaGVtYS9ib29sZWFuLmpzIiwibWFwcGluZ3MiOiJBQUFhOztBQUViO0FBQ0E7QUFDQTs7QUFFQSxrQkFBa0IsbUJBQU8sQ0FBQyxzRUFBZTtBQUN6QyxtQkFBbUIsbUJBQU8sQ0FBQyxzRUFBZTtBQUMxQyxvQkFBb0IsbUJBQU8sQ0FBQywwRUFBaUI7QUFDN0MsY0FBYyxtQkFBTyxDQUFDLDREQUFVOztBQUVoQztBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBEQUEwRCxpQkFBaUI7QUFDM0Usb0JBQW9CLFVBQVU7QUFDOUI7QUFDQSxXQUFXLFFBQVE7QUFDbkIsV0FBVyxLQUFLO0FBQ2hCLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBEQUEwRCxpQkFBaUI7QUFDM0UsbUJBQW1CLGVBQWUsVUFBVTtBQUM1QztBQUNBLFdBQVcsVUFBVTtBQUNyQixZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxVQUFVO0FBQ3JCLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFVBQVU7QUFDckIsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLEtBQUs7QUFDaEIsWUFBWTtBQUNaO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxREFBcUQsWUFBWTtBQUNqRSxlQUFlLGtCQUFrQixLQUFLO0FBQ3RDO0FBQ0EsZUFBZSxrQkFBa0IsS0FBSztBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBOztBQUVBO0FBQ0E7QUFDQSxjQUFjO0FBQ2QsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscURBQXFELFlBQVk7QUFDakUsZUFBZSxVQUFVLEtBQUs7QUFDOUI7QUFDQSxlQUFlLFVBQVUsS0FBSztBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBOztBQUVBO0FBQ0E7QUFDQSxjQUFjO0FBQ2QsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQSxJQUFJO0FBQ0o7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLCtEQUErRDs7QUFFL0Q7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFdBQVcsS0FBSztBQUNoQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSIsInNvdXJjZXMiOlsid2VicGFjazovL2FwcDEvLi9ub2RlX21vZHVsZXMvbW9uZ29vc2UvbGliL3NjaGVtYS9ib29sZWFuLmpzP2Q4MWQiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG4vKiFcbiAqIE1vZHVsZSBkZXBlbmRlbmNpZXMuXG4gKi9cblxuY29uc3QgQ2FzdEVycm9yID0gcmVxdWlyZSgnLi4vZXJyb3IvY2FzdCcpO1xuY29uc3QgU2NoZW1hVHlwZSA9IHJlcXVpcmUoJy4uL3NjaGVtYVR5cGUnKTtcbmNvbnN0IGNhc3RCb29sZWFuID0gcmVxdWlyZSgnLi4vY2FzdC9ib29sZWFuJyk7XG5jb25zdCB1dGlscyA9IHJlcXVpcmUoJy4uL3V0aWxzJyk7XG5cbi8qKlxuICogQm9vbGVhbiBTY2hlbWFUeXBlIGNvbnN0cnVjdG9yLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBwYXRoXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xuICogQGluaGVyaXRzIFNjaGVtYVR5cGVcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZnVuY3Rpb24gU2NoZW1hQm9vbGVhbihwYXRoLCBvcHRpb25zKSB7XG4gIFNjaGVtYVR5cGUuY2FsbCh0aGlzLCBwYXRoLCBvcHRpb25zLCAnQm9vbGVhbicpO1xufVxuXG4vKipcbiAqIFRoaXMgc2NoZW1hIHR5cGUncyBuYW1lLCB0byBkZWZlbmQgYWdhaW5zdCBtaW5pZmllcnMgdGhhdCBtYW5nbGVcbiAqIGZ1bmN0aW9uIG5hbWVzLlxuICpcbiAqIEBhcGkgcHVibGljXG4gKi9cblNjaGVtYUJvb2xlYW4uc2NoZW1hTmFtZSA9ICdCb29sZWFuJztcblxuU2NoZW1hQm9vbGVhbi5kZWZhdWx0T3B0aW9ucyA9IHt9O1xuXG4vKiFcbiAqIEluaGVyaXRzIGZyb20gU2NoZW1hVHlwZS5cbiAqL1xuU2NoZW1hQm9vbGVhbi5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKFNjaGVtYVR5cGUucHJvdG90eXBlKTtcblNjaGVtYUJvb2xlYW4ucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gU2NoZW1hQm9vbGVhbjtcblxuLyohXG4gKiBpZ25vcmVcbiAqL1xuXG5TY2hlbWFCb29sZWFuLl9jYXN0ID0gY2FzdEJvb2xlYW47XG5cbi8qKlxuICogU2V0cyBhIGRlZmF1bHQgb3B0aW9uIGZvciBhbGwgQm9vbGVhbiBpbnN0YW5jZXMuXG4gKlxuICogIyMjIyBFeGFtcGxlOlxuICpcbiAqICAgICAvLyBNYWtlIGFsbCBib29sZWFucyBoYXZlIGBkZWZhdWx0YCBvZiBmYWxzZS5cbiAqICAgICBtb25nb29zZS5TY2hlbWEuQm9vbGVhbi5zZXQoJ2RlZmF1bHQnLCBmYWxzZSk7XG4gKlxuICogICAgIGNvbnN0IE9yZGVyID0gbW9uZ29vc2UubW9kZWwoJ09yZGVyJywgbmV3IFNjaGVtYSh7IGlzUGFpZDogQm9vbGVhbiB9KSk7XG4gKiAgICAgbmV3IE9yZGVyKHsgfSkuaXNQYWlkOyAvLyBmYWxzZVxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBvcHRpb24gVGhlIG9wdGlvbiB5b3UnZCBsaWtlIHRvIHNldCB0aGUgdmFsdWUgZm9yXG4gKiBAcGFyYW0ge0FueX0gdmFsdWUgdmFsdWUgZm9yIG9wdGlvblxuICogQHJldHVybiB7dW5kZWZpbmVkfVxuICogQGZ1bmN0aW9uIHNldFxuICogQHN0YXRpY1xuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5TY2hlbWFCb29sZWFuLnNldCA9IFNjaGVtYVR5cGUuc2V0O1xuXG5TY2hlbWFCb29sZWFuLnNldHRlcnMgPSBbXTtcblxuLyoqXG4gKiBBdHRhY2hlcyBhIGdldHRlciBmb3IgYWxsIEJvb2xlYW4gaW5zdGFuY2VzXG4gKlxuICogIyMjIyBFeGFtcGxlOlxuICpcbiAqICAgICBtb25nb29zZS5TY2hlbWEuQm9vbGVhbi5nZXQodiA9PiB2ID09PSB0cnVlID8gJ3llcycgOiAnbm8nKTtcbiAqXG4gKiAgICAgY29uc3QgT3JkZXIgPSBtb25nb29zZS5tb2RlbCgnT3JkZXInLCBuZXcgU2NoZW1hKHsgaXNQYWlkOiBCb29sZWFuIH0pKTtcbiAqICAgICBuZXcgT3JkZXIoeyBpc1BhaWQ6IGZhbHNlIH0pLmlzUGFpZDsgLy8gJ25vJ1xuICpcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGdldHRlclxuICogQHJldHVybiB7dGhpc31cbiAqIEBmdW5jdGlvbiBnZXRcbiAqIEBzdGF0aWNcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuU2NoZW1hQm9vbGVhbi5nZXQgPSBTY2hlbWFUeXBlLmdldDtcblxuLyoqXG4gKiBHZXQvc2V0IHRoZSBmdW5jdGlvbiB1c2VkIHRvIGNhc3QgYXJiaXRyYXJ5IHZhbHVlcyB0byBib29sZWFucy5cbiAqXG4gKiAjIyMjIEV4YW1wbGU6XG4gKlxuICogICAgIC8vIE1ha2UgTW9uZ29vc2UgY2FzdCBlbXB0eSBzdHJpbmcgJycgdG8gZmFsc2UuXG4gKiAgICAgY29uc3Qgb3JpZ2luYWwgPSBtb25nb29zZS5TY2hlbWEuQm9vbGVhbi5jYXN0KCk7XG4gKiAgICAgbW9uZ29vc2UuU2NoZW1hLkJvb2xlYW4uY2FzdCh2ID0+IHtcbiAqICAgICAgIGlmICh2ID09PSAnJykge1xuICogICAgICAgICByZXR1cm4gZmFsc2U7XG4gKiAgICAgICB9XG4gKiAgICAgICByZXR1cm4gb3JpZ2luYWwodik7XG4gKiAgICAgfSk7XG4gKlxuICogICAgIC8vIE9yIGRpc2FibGUgY2FzdGluZyBlbnRpcmVseVxuICogICAgIG1vbmdvb3NlLlNjaGVtYS5Cb29sZWFuLmNhc3QoZmFsc2UpO1xuICpcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGNhc3RlclxuICogQHJldHVybiB7RnVuY3Rpb259XG4gKiBAZnVuY3Rpb24gZ2V0XG4gKiBAc3RhdGljXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cblNjaGVtYUJvb2xlYW4uY2FzdCA9IGZ1bmN0aW9uIGNhc3QoY2FzdGVyKSB7XG4gIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAwKSB7XG4gICAgcmV0dXJuIHRoaXMuX2Nhc3Q7XG4gIH1cbiAgaWYgKGNhc3RlciA9PT0gZmFsc2UpIHtcbiAgICBjYXN0ZXIgPSB0aGlzLl9kZWZhdWx0Q2FzdGVyO1xuICB9XG4gIHRoaXMuX2Nhc3QgPSBjYXN0ZXI7XG5cbiAgcmV0dXJuIHRoaXMuX2Nhc3Q7XG59O1xuXG4vKiFcbiAqIGlnbm9yZVxuICovXG5cblNjaGVtYUJvb2xlYW4uX2RlZmF1bHRDYXN0ZXIgPSB2ID0+IHtcbiAgaWYgKHYgIT0gbnVsbCAmJiB0eXBlb2YgdiAhPT0gJ2Jvb2xlYW4nKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCk7XG4gIH1cbiAgcmV0dXJuIHY7XG59O1xuXG4vKiFcbiAqIGlnbm9yZVxuICovXG5cblNjaGVtYUJvb2xlYW4uX2NoZWNrUmVxdWlyZWQgPSB2ID0+IHYgPT09IHRydWUgfHwgdiA9PT0gZmFsc2U7XG5cbi8qKlxuICogT3ZlcnJpZGUgdGhlIGZ1bmN0aW9uIHRoZSByZXF1aXJlZCB2YWxpZGF0b3IgdXNlcyB0byBjaGVjayB3aGV0aGVyIGEgYm9vbGVhblxuICogcGFzc2VzIHRoZSBgcmVxdWlyZWRgIGNoZWNrLlxuICpcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuXG4gKiBAcmV0dXJuIHtGdW5jdGlvbn1cbiAqIEBmdW5jdGlvbiBjaGVja1JlcXVpcmVkXG4gKiBAc3RhdGljXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cblNjaGVtYUJvb2xlYW4uY2hlY2tSZXF1aXJlZCA9IFNjaGVtYVR5cGUuY2hlY2tSZXF1aXJlZDtcblxuLyoqXG4gKiBDaGVjayBpZiB0aGUgZ2l2ZW4gdmFsdWUgc2F0aXNmaWVzIGEgcmVxdWlyZWQgdmFsaWRhdG9yLiBGb3IgYSBib29sZWFuXG4gKiB0byBzYXRpc2Z5IGEgcmVxdWlyZWQgdmFsaWRhdG9yLCBpdCBtdXN0IGJlIHN0cmljdGx5IGVxdWFsIHRvIHRydWUgb3IgdG9cbiAqIGZhbHNlLlxuICpcbiAqIEBwYXJhbSB7QW55fSB2YWx1ZVxuICogQHJldHVybiB7Qm9vbGVhbn1cbiAqIEBhcGkgcHVibGljXG4gKi9cblxuU2NoZW1hQm9vbGVhbi5wcm90b3R5cGUuY2hlY2tSZXF1aXJlZCA9IGZ1bmN0aW9uKHZhbHVlKSB7XG4gIHJldHVybiB0aGlzLmNvbnN0cnVjdG9yLl9jaGVja1JlcXVpcmVkKHZhbHVlKTtcbn07XG5cbi8qKlxuICogQ29uZmlndXJlIHdoaWNoIHZhbHVlcyBnZXQgY2FzdGVkIHRvIGB0cnVlYC5cbiAqXG4gKiAjIyMjIEV4YW1wbGU6XG4gKlxuICogICAgIGNvbnN0IE0gPSBtb25nb29zZS5tb2RlbCgnVGVzdCcsIG5ldyBTY2hlbWEoeyBiOiBCb29sZWFuIH0pKTtcbiAqICAgICBuZXcgTSh7IGI6ICdhZmZpcm1hdGl2ZScgfSkuYjsgLy8gdW5kZWZpbmVkXG4gKiAgICAgbW9uZ29vc2UuU2NoZW1hLkJvb2xlYW4uY29udmVydFRvVHJ1ZS5hZGQoJ2FmZmlybWF0aXZlJyk7XG4gKiAgICAgbmV3IE0oeyBiOiAnYWZmaXJtYXRpdmUnIH0pLmI7IC8vIHRydWVcbiAqXG4gKiBAcHJvcGVydHkgY29udmVydFRvVHJ1ZVxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIFNjaGVtYUJvb2xlYW5cbiAqIEB0eXBlIHtTZXR9XG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShTY2hlbWFCb29sZWFuLCAnY29udmVydFRvVHJ1ZScsIHtcbiAgZ2V0OiAoKSA9PiBjYXN0Qm9vbGVhbi5jb252ZXJ0VG9UcnVlLFxuICBzZXQ6IHYgPT4geyBjYXN0Qm9vbGVhbi5jb252ZXJ0VG9UcnVlID0gdjsgfVxufSk7XG5cbi8qKlxuICogQ29uZmlndXJlIHdoaWNoIHZhbHVlcyBnZXQgY2FzdGVkIHRvIGBmYWxzZWAuXG4gKlxuICogIyMjIyBFeGFtcGxlOlxuICpcbiAqICAgICBjb25zdCBNID0gbW9uZ29vc2UubW9kZWwoJ1Rlc3QnLCBuZXcgU2NoZW1hKHsgYjogQm9vbGVhbiB9KSk7XG4gKiAgICAgbmV3IE0oeyBiOiAnbmF5JyB9KS5iOyAvLyB1bmRlZmluZWRcbiAqICAgICBtb25nb29zZS5TY2hlbWEuVHlwZXMuQm9vbGVhbi5jb252ZXJ0VG9GYWxzZS5hZGQoJ25heScpO1xuICogICAgIG5ldyBNKHsgYjogJ25heScgfSkuYjsgLy8gZmFsc2VcbiAqXG4gKiBAcHJvcGVydHkgY29udmVydFRvRmFsc2VcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBTY2hlbWFCb29sZWFuXG4gKiBAdHlwZSB7U2V0fVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoU2NoZW1hQm9vbGVhbiwgJ2NvbnZlcnRUb0ZhbHNlJywge1xuICBnZXQ6ICgpID0+IGNhc3RCb29sZWFuLmNvbnZlcnRUb0ZhbHNlLFxuICBzZXQ6IHYgPT4geyBjYXN0Qm9vbGVhbi5jb252ZXJ0VG9GYWxzZSA9IHY7IH1cbn0pO1xuXG4vKipcbiAqIENhc3RzIHRvIGJvb2xlYW5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gdmFsdWVcbiAqIEBwYXJhbSB7T2JqZWN0fSBtb2RlbCB0aGlzIHZhbHVlIGlzIG9wdGlvbmFsXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5TY2hlbWFCb29sZWFuLnByb3RvdHlwZS5jYXN0ID0gZnVuY3Rpb24odmFsdWUpIHtcbiAgbGV0IGNhc3RCb29sZWFuO1xuICBpZiAodHlwZW9mIHRoaXMuX2Nhc3RGdW5jdGlvbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIGNhc3RCb29sZWFuID0gdGhpcy5fY2FzdEZ1bmN0aW9uO1xuICB9IGVsc2UgaWYgKHR5cGVvZiB0aGlzLmNvbnN0cnVjdG9yLmNhc3QgPT09ICdmdW5jdGlvbicpIHtcbiAgICBjYXN0Qm9vbGVhbiA9IHRoaXMuY29uc3RydWN0b3IuY2FzdCgpO1xuICB9IGVsc2Uge1xuICAgIGNhc3RCb29sZWFuID0gU2NoZW1hQm9vbGVhbi5jYXN0KCk7XG4gIH1cblxuICB0cnkge1xuICAgIHJldHVybiBjYXN0Qm9vbGVhbih2YWx1ZSk7XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgdGhyb3cgbmV3IENhc3RFcnJvcignQm9vbGVhbicsIHZhbHVlLCB0aGlzLnBhdGgsIGVycm9yLCB0aGlzKTtcbiAgfVxufTtcblxuU2NoZW1hQm9vbGVhbi4kY29uZGl0aW9uYWxIYW5kbGVycyA9XG4gICAgdXRpbHMub3B0aW9ucyhTY2hlbWFUeXBlLnByb3RvdHlwZS4kY29uZGl0aW9uYWxIYW5kbGVycywge30pO1xuXG4vKipcbiAqIENhc3RzIGNvbnRlbnRzIGZvciBxdWVyaWVzLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSAkY29uZGl0aW9uYWxcbiAqIEBwYXJhbSB7YW55fSB2YWxcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cblNjaGVtYUJvb2xlYW4ucHJvdG90eXBlLmNhc3RGb3JRdWVyeSA9IGZ1bmN0aW9uKCRjb25kaXRpb25hbCwgdmFsLCBjb250ZXh0KSB7XG4gIGxldCBoYW5kbGVyO1xuICBpZiAoJGNvbmRpdGlvbmFsICE9IG51bGwpIHtcbiAgICBoYW5kbGVyID0gU2NoZW1hQm9vbGVhbi4kY29uZGl0aW9uYWxIYW5kbGVyc1skY29uZGl0aW9uYWxdO1xuXG4gICAgaWYgKGhhbmRsZXIpIHtcbiAgICAgIHJldHVybiBoYW5kbGVyLmNhbGwodGhpcywgdmFsKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5hcHBseVNldHRlcnMobnVsbCwgdmFsLCBjb250ZXh0KTtcbiAgfVxuXG4gIHJldHVybiB0aGlzLmFwcGx5U2V0dGVycyh2YWwsIGNvbnRleHQpO1xufTtcblxuLyoqXG4gKlxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuU2NoZW1hQm9vbGVhbi5wcm90b3R5cGUuX2Nhc3ROdWxsaXNoID0gZnVuY3Rpb24gX2Nhc3ROdWxsaXNoKHYpIHtcbiAgaWYgKHR5cGVvZiB2ID09PSAndW5kZWZpbmVkJykge1xuICAgIHJldHVybiB2O1xuICB9XG4gIGNvbnN0IGNhc3RCb29sZWFuID0gdHlwZW9mIHRoaXMuY29uc3RydWN0b3IuY2FzdCA9PT0gJ2Z1bmN0aW9uJyA/XG4gICAgdGhpcy5jb25zdHJ1Y3Rvci5jYXN0KCkgOlxuICAgIFNjaGVtYUJvb2xlYW4uY2FzdCgpO1xuICBpZiAoY2FzdEJvb2xlYW4gPT0gbnVsbCkge1xuICAgIHJldHVybiB2O1xuICB9XG4gIGlmIChjYXN0Qm9vbGVhbi5jb252ZXJ0VG9GYWxzZSBpbnN0YW5jZW9mIFNldCAmJiBjYXN0Qm9vbGVhbi5jb252ZXJ0VG9GYWxzZS5oYXModikpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgaWYgKGNhc3RCb29sZWFuLmNvbnZlcnRUb1RydWUgaW5zdGFuY2VvZiBTZXQgJiYgY2FzdEJvb2xlYW4uY29udmVydFRvVHJ1ZS5oYXModikpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICByZXR1cm4gdjtcbn07XG5cbi8qIVxuICogTW9kdWxlIGV4cG9ydHMuXG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSBTY2hlbWFCb29sZWFuO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/mongoose/lib/schema/boolean.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/mongoose/lib/schema/buffer.js":
/*!****************************************************!*\
  !*** ./node_modules/mongoose/lib/schema/buffer.js ***!
  \****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("/*!\n * Module dependencies.\n */\n\n\n\nconst MongooseBuffer = __webpack_require__(/*! ../types/buffer */ \"(ssr)/./node_modules/mongoose/lib/types/buffer.js\");\nconst SchemaBufferOptions = __webpack_require__(/*! ../options/schemaBufferOptions */ \"(ssr)/./node_modules/mongoose/lib/options/schemaBufferOptions.js\");\nconst SchemaType = __webpack_require__(/*! ../schemaType */ \"(ssr)/./node_modules/mongoose/lib/schemaType.js\");\nconst handleBitwiseOperator = __webpack_require__(/*! ./operators/bitwise */ \"(ssr)/./node_modules/mongoose/lib/schema/operators/bitwise.js\");\nconst utils = __webpack_require__(/*! ../utils */ \"(ssr)/./node_modules/mongoose/lib/utils.js\");\n\nconst Binary = MongooseBuffer.Binary;\nconst CastError = SchemaType.CastError;\n\n/**\n * Buffer SchemaType constructor\n *\n * @param {String} key\n * @param {Object} options\n * @inherits SchemaType\n * @api public\n */\n\nfunction SchemaBuffer(key, options) {\n  SchemaType.call(this, key, options, 'Buffer');\n}\n\n/**\n * This schema type's name, to defend against minifiers that mangle\n * function names.\n *\n * @api public\n */\nSchemaBuffer.schemaName = 'Buffer';\n\nSchemaBuffer.defaultOptions = {};\n\n/*!\n * Inherits from SchemaType.\n */\nSchemaBuffer.prototype = Object.create(SchemaType.prototype);\nSchemaBuffer.prototype.constructor = SchemaBuffer;\nSchemaBuffer.prototype.OptionsConstructor = SchemaBufferOptions;\n\n/*!\n * ignore\n */\n\nSchemaBuffer._checkRequired = v => !!(v && v.length);\n\n/**\n * Sets a default option for all Buffer instances.\n *\n * #### Example:\n *\n *     // Make all buffers have `required` of true by default.\n *     mongoose.Schema.Buffer.set('required', true);\n *\n *     const User = mongoose.model('User', new Schema({ test: Buffer }));\n *     new User({ }).validateSync().errors.test.message; // Path `test` is required.\n *\n * @param {String} option The option you'd like to set the value for\n * @param {Any} value value for option\n * @return {undefined}\n * @function set\n * @static\n * @api public\n */\n\nSchemaBuffer.set = SchemaType.set;\n\nSchemaBuffer.setters = [];\n\n/**\n * Attaches a getter for all Buffer instances\n *\n * #### Example:\n *\n *     // Always convert to string when getting an ObjectId\n *     mongoose.Schema.Types.Buffer.get(v => v.toString('hex'));\n *\n *     const Model = mongoose.model('Test', new Schema({ buf: Buffer } }));\n *     typeof (new Model({ buf: Buffer.fromString('hello') }).buf); // 'string'\n *\n * @param {Function} getter\n * @return {this}\n * @function get\n * @static\n * @api public\n */\n\nSchemaBuffer.get = SchemaType.get;\n\n/**\n * Override the function the required validator uses to check whether a string\n * passes the `required` check.\n *\n * #### Example:\n *\n *     // Allow empty strings to pass `required` check\n *     mongoose.Schema.Types.String.checkRequired(v => v != null);\n *\n *     const M = mongoose.model({ buf: { type: Buffer, required: true } });\n *     new M({ buf: Buffer.from('') }).validateSync(); // validation passes!\n *\n * @param {Function} fn\n * @return {Function}\n * @function checkRequired\n * @static\n * @api public\n */\n\nSchemaBuffer.checkRequired = SchemaType.checkRequired;\n\n/**\n * Check if the given value satisfies a required validator. To satisfy a\n * required validator, a buffer must not be null or undefined and have\n * non-zero length.\n *\n * @param {Any} value\n * @param {Document} doc\n * @return {Boolean}\n * @api public\n */\n\nSchemaBuffer.prototype.checkRequired = function(value, doc) {\n  if (SchemaType._isRef(this, value, doc, true)) {\n    return !!value;\n  }\n  return this.constructor._checkRequired(value);\n};\n\n/**\n * Casts contents\n *\n * @param {Object} value\n * @param {Document} doc document that triggers the casting\n * @param {Boolean} init\n * @api private\n */\n\nSchemaBuffer.prototype.cast = function(value, doc, init) {\n  let ret;\n  if (SchemaType._isRef(this, value, doc, init)) {\n    if (value && value.isMongooseBuffer) {\n      return value;\n    }\n\n    if (Buffer.isBuffer(value)) {\n      if (!value || !value.isMongooseBuffer) {\n        value = new MongooseBuffer(value, [this.path, doc]);\n        if (this.options.subtype != null) {\n          value._subtype = this.options.subtype;\n        }\n      }\n      return value;\n    }\n\n    if (value instanceof Binary) {\n      ret = new MongooseBuffer(value.value(true), [this.path, doc]);\n      if (typeof value.sub_type !== 'number') {\n        throw new CastError('Buffer', value, this.path, null, this);\n      }\n      ret._subtype = value.sub_type;\n      return ret;\n    }\n\n    if (value == null || utils.isNonBuiltinObject(value)) {\n      return this._castRef(value, doc, init);\n    }\n  }\n\n  // documents\n  if (value && value._id) {\n    value = value._id;\n  }\n\n  if (value && value.isMongooseBuffer) {\n    return value;\n  }\n\n  if (Buffer.isBuffer(value)) {\n    if (!value || !value.isMongooseBuffer) {\n      value = new MongooseBuffer(value, [this.path, doc]);\n      if (this.options.subtype != null) {\n        value._subtype = this.options.subtype;\n      }\n    }\n    return value;\n  }\n\n  if (value instanceof Binary) {\n    ret = new MongooseBuffer(value.value(true), [this.path, doc]);\n    if (typeof value.sub_type !== 'number') {\n      throw new CastError('Buffer', value, this.path, null, this);\n    }\n    ret._subtype = value.sub_type;\n    return ret;\n  }\n\n  if (value === null) {\n    return value;\n  }\n\n\n  const type = typeof value;\n  if (\n    type === 'string' || type === 'number' || Array.isArray(value) ||\n    (type === 'object' && value.type === 'Buffer' && Array.isArray(value.data)) // gh-6863\n  ) {\n    if (type === 'number') {\n      value = [value];\n    }\n    ret = new MongooseBuffer(value, [this.path, doc]);\n    if (this.options.subtype != null) {\n      ret._subtype = this.options.subtype;\n    }\n    return ret;\n  }\n\n  throw new CastError('Buffer', value, this.path, null, this);\n};\n\n/**\n * Sets the default [subtype](https://studio3t.com/whats-new/best-practices-uuid-mongodb/)\n * for this buffer. You can find a [list of allowed subtypes here](https://api.mongodb.com/python/current/api/bson/binary.html).\n *\n * #### Example:\n *\n *     const s = new Schema({ uuid: { type: Buffer, subtype: 4 });\n *     const M = db.model('M', s);\n *     const m = new M({ uuid: 'test string' });\n *     m.uuid._subtype; // 4\n *\n * @param {Number} subtype the default subtype\n * @return {SchemaType} this\n * @api public\n */\n\nSchemaBuffer.prototype.subtype = function(subtype) {\n  this.options.subtype = subtype;\n  return this;\n};\n\n/*!\n * ignore\n */\nfunction handleSingle(val, context) {\n  return this.castForQuery(null, val, context);\n}\n\nSchemaBuffer.prototype.$conditionalHandlers =\n    utils.options(SchemaType.prototype.$conditionalHandlers, {\n      $bitsAllClear: handleBitwiseOperator,\n      $bitsAnyClear: handleBitwiseOperator,\n      $bitsAllSet: handleBitwiseOperator,\n      $bitsAnySet: handleBitwiseOperator,\n      $gt: handleSingle,\n      $gte: handleSingle,\n      $lt: handleSingle,\n      $lte: handleSingle\n    });\n\n/**\n * Casts contents for queries.\n *\n * @param {String} $conditional\n * @param {any} [value]\n * @api private\n */\n\nSchemaBuffer.prototype.castForQuery = function($conditional, val, context) {\n  let handler;\n  if ($conditional != null) {\n    handler = this.$conditionalHandlers[$conditional];\n    if (!handler) {\n      throw new Error('Can\\'t use ' + $conditional + ' with Buffer.');\n    }\n    return handler.call(this, val);\n  }\n  const casted = this.applySetters(val, context);\n  return casted ? casted.toObject({ transform: false, virtuals: false }) : casted;\n};\n\n/*!\n * Module exports.\n */\n\nmodule.exports = SchemaBuffer;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbW9uZ29vc2UvbGliL3NjaGVtYS9idWZmZXIuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBOztBQUVhOztBQUViLHVCQUF1QixtQkFBTyxDQUFDLDBFQUFpQjtBQUNoRCw0QkFBNEIsbUJBQU8sQ0FBQyx3R0FBZ0M7QUFDcEUsbUJBQW1CLG1CQUFPLENBQUMsc0VBQWU7QUFDMUMsOEJBQThCLG1CQUFPLENBQUMsMEZBQXFCO0FBQzNELGNBQWMsbUJBQU8sQ0FBQyw0REFBVTs7QUFFaEM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0RBQXdELGNBQWM7QUFDdEUsbUJBQW1CLHNDQUFzQztBQUN6RDtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLEtBQUs7QUFDaEIsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5REFBeUQsZUFBZTtBQUN4RSwyQkFBMkIsaUNBQWlDLFFBQVE7QUFDcEU7QUFDQSxXQUFXLFVBQVU7QUFDckIsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQyxPQUFPLGdDQUFnQztBQUN6RSxlQUFlLHNCQUFzQixrQkFBa0I7QUFDdkQ7QUFDQSxXQUFXLFVBQVU7QUFDckIsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLEtBQUs7QUFDaEIsV0FBVyxVQUFVO0FBQ3JCLFlBQVk7QUFDWjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsV0FBVyxVQUFVO0FBQ3JCLFdBQVcsU0FBUztBQUNwQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCLFFBQVEsMEJBQTBCO0FBQ2hFO0FBQ0EseUJBQXlCLHFCQUFxQjtBQUM5Qyx3QkFBd0I7QUFDeEI7QUFDQSxXQUFXLFFBQVE7QUFDbkIsWUFBWSxZQUFZO0FBQ3hCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsV0FBVyxLQUFLO0FBQ2hCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0MsbUNBQW1DO0FBQ3ZFOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSIsInNvdXJjZXMiOlsid2VicGFjazovL2FwcDEvLi9ub2RlX21vZHVsZXMvbW9uZ29vc2UvbGliL3NjaGVtYS9idWZmZXIuanM/NWZlNSJdLCJzb3VyY2VzQ29udGVudCI6WyIvKiFcbiAqIE1vZHVsZSBkZXBlbmRlbmNpZXMuXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG5jb25zdCBNb25nb29zZUJ1ZmZlciA9IHJlcXVpcmUoJy4uL3R5cGVzL2J1ZmZlcicpO1xuY29uc3QgU2NoZW1hQnVmZmVyT3B0aW9ucyA9IHJlcXVpcmUoJy4uL29wdGlvbnMvc2NoZW1hQnVmZmVyT3B0aW9ucycpO1xuY29uc3QgU2NoZW1hVHlwZSA9IHJlcXVpcmUoJy4uL3NjaGVtYVR5cGUnKTtcbmNvbnN0IGhhbmRsZUJpdHdpc2VPcGVyYXRvciA9IHJlcXVpcmUoJy4vb3BlcmF0b3JzL2JpdHdpc2UnKTtcbmNvbnN0IHV0aWxzID0gcmVxdWlyZSgnLi4vdXRpbHMnKTtcblxuY29uc3QgQmluYXJ5ID0gTW9uZ29vc2VCdWZmZXIuQmluYXJ5O1xuY29uc3QgQ2FzdEVycm9yID0gU2NoZW1hVHlwZS5DYXN0RXJyb3I7XG5cbi8qKlxuICogQnVmZmVyIFNjaGVtYVR5cGUgY29uc3RydWN0b3JcbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30ga2V5XG4gKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xuICogQGluaGVyaXRzIFNjaGVtYVR5cGVcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZnVuY3Rpb24gU2NoZW1hQnVmZmVyKGtleSwgb3B0aW9ucykge1xuICBTY2hlbWFUeXBlLmNhbGwodGhpcywga2V5LCBvcHRpb25zLCAnQnVmZmVyJyk7XG59XG5cbi8qKlxuICogVGhpcyBzY2hlbWEgdHlwZSdzIG5hbWUsIHRvIGRlZmVuZCBhZ2FpbnN0IG1pbmlmaWVycyB0aGF0IG1hbmdsZVxuICogZnVuY3Rpb24gbmFtZXMuXG4gKlxuICogQGFwaSBwdWJsaWNcbiAqL1xuU2NoZW1hQnVmZmVyLnNjaGVtYU5hbWUgPSAnQnVmZmVyJztcblxuU2NoZW1hQnVmZmVyLmRlZmF1bHRPcHRpb25zID0ge307XG5cbi8qIVxuICogSW5oZXJpdHMgZnJvbSBTY2hlbWFUeXBlLlxuICovXG5TY2hlbWFCdWZmZXIucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShTY2hlbWFUeXBlLnByb3RvdHlwZSk7XG5TY2hlbWFCdWZmZXIucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gU2NoZW1hQnVmZmVyO1xuU2NoZW1hQnVmZmVyLnByb3RvdHlwZS5PcHRpb25zQ29uc3RydWN0b3IgPSBTY2hlbWFCdWZmZXJPcHRpb25zO1xuXG4vKiFcbiAqIGlnbm9yZVxuICovXG5cblNjaGVtYUJ1ZmZlci5fY2hlY2tSZXF1aXJlZCA9IHYgPT4gISEodiAmJiB2Lmxlbmd0aCk7XG5cbi8qKlxuICogU2V0cyBhIGRlZmF1bHQgb3B0aW9uIGZvciBhbGwgQnVmZmVyIGluc3RhbmNlcy5cbiAqXG4gKiAjIyMjIEV4YW1wbGU6XG4gKlxuICogICAgIC8vIE1ha2UgYWxsIGJ1ZmZlcnMgaGF2ZSBgcmVxdWlyZWRgIG9mIHRydWUgYnkgZGVmYXVsdC5cbiAqICAgICBtb25nb29zZS5TY2hlbWEuQnVmZmVyLnNldCgncmVxdWlyZWQnLCB0cnVlKTtcbiAqXG4gKiAgICAgY29uc3QgVXNlciA9IG1vbmdvb3NlLm1vZGVsKCdVc2VyJywgbmV3IFNjaGVtYSh7IHRlc3Q6IEJ1ZmZlciB9KSk7XG4gKiAgICAgbmV3IFVzZXIoeyB9KS52YWxpZGF0ZVN5bmMoKS5lcnJvcnMudGVzdC5tZXNzYWdlOyAvLyBQYXRoIGB0ZXN0YCBpcyByZXF1aXJlZC5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gb3B0aW9uIFRoZSBvcHRpb24geW91J2QgbGlrZSB0byBzZXQgdGhlIHZhbHVlIGZvclxuICogQHBhcmFtIHtBbnl9IHZhbHVlIHZhbHVlIGZvciBvcHRpb25cbiAqIEByZXR1cm4ge3VuZGVmaW5lZH1cbiAqIEBmdW5jdGlvbiBzZXRcbiAqIEBzdGF0aWNcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuU2NoZW1hQnVmZmVyLnNldCA9IFNjaGVtYVR5cGUuc2V0O1xuXG5TY2hlbWFCdWZmZXIuc2V0dGVycyA9IFtdO1xuXG4vKipcbiAqIEF0dGFjaGVzIGEgZ2V0dGVyIGZvciBhbGwgQnVmZmVyIGluc3RhbmNlc1xuICpcbiAqICMjIyMgRXhhbXBsZTpcbiAqXG4gKiAgICAgLy8gQWx3YXlzIGNvbnZlcnQgdG8gc3RyaW5nIHdoZW4gZ2V0dGluZyBhbiBPYmplY3RJZFxuICogICAgIG1vbmdvb3NlLlNjaGVtYS5UeXBlcy5CdWZmZXIuZ2V0KHYgPT4gdi50b1N0cmluZygnaGV4JykpO1xuICpcbiAqICAgICBjb25zdCBNb2RlbCA9IG1vbmdvb3NlLm1vZGVsKCdUZXN0JywgbmV3IFNjaGVtYSh7IGJ1ZjogQnVmZmVyIH0gfSkpO1xuICogICAgIHR5cGVvZiAobmV3IE1vZGVsKHsgYnVmOiBCdWZmZXIuZnJvbVN0cmluZygnaGVsbG8nKSB9KS5idWYpOyAvLyAnc3RyaW5nJ1xuICpcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGdldHRlclxuICogQHJldHVybiB7dGhpc31cbiAqIEBmdW5jdGlvbiBnZXRcbiAqIEBzdGF0aWNcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuU2NoZW1hQnVmZmVyLmdldCA9IFNjaGVtYVR5cGUuZ2V0O1xuXG4vKipcbiAqIE92ZXJyaWRlIHRoZSBmdW5jdGlvbiB0aGUgcmVxdWlyZWQgdmFsaWRhdG9yIHVzZXMgdG8gY2hlY2sgd2hldGhlciBhIHN0cmluZ1xuICogcGFzc2VzIHRoZSBgcmVxdWlyZWRgIGNoZWNrLlxuICpcbiAqICMjIyMgRXhhbXBsZTpcbiAqXG4gKiAgICAgLy8gQWxsb3cgZW1wdHkgc3RyaW5ncyB0byBwYXNzIGByZXF1aXJlZGAgY2hlY2tcbiAqICAgICBtb25nb29zZS5TY2hlbWEuVHlwZXMuU3RyaW5nLmNoZWNrUmVxdWlyZWQodiA9PiB2ICE9IG51bGwpO1xuICpcbiAqICAgICBjb25zdCBNID0gbW9uZ29vc2UubW9kZWwoeyBidWY6IHsgdHlwZTogQnVmZmVyLCByZXF1aXJlZDogdHJ1ZSB9IH0pO1xuICogICAgIG5ldyBNKHsgYnVmOiBCdWZmZXIuZnJvbSgnJykgfSkudmFsaWRhdGVTeW5jKCk7IC8vIHZhbGlkYXRpb24gcGFzc2VzIVxuICpcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuXG4gKiBAcmV0dXJuIHtGdW5jdGlvbn1cbiAqIEBmdW5jdGlvbiBjaGVja1JlcXVpcmVkXG4gKiBAc3RhdGljXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cblNjaGVtYUJ1ZmZlci5jaGVja1JlcXVpcmVkID0gU2NoZW1hVHlwZS5jaGVja1JlcXVpcmVkO1xuXG4vKipcbiAqIENoZWNrIGlmIHRoZSBnaXZlbiB2YWx1ZSBzYXRpc2ZpZXMgYSByZXF1aXJlZCB2YWxpZGF0b3IuIFRvIHNhdGlzZnkgYVxuICogcmVxdWlyZWQgdmFsaWRhdG9yLCBhIGJ1ZmZlciBtdXN0IG5vdCBiZSBudWxsIG9yIHVuZGVmaW5lZCBhbmQgaGF2ZVxuICogbm9uLXplcm8gbGVuZ3RoLlxuICpcbiAqIEBwYXJhbSB7QW55fSB2YWx1ZVxuICogQHBhcmFtIHtEb2N1bWVudH0gZG9jXG4gKiBAcmV0dXJuIHtCb29sZWFufVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5TY2hlbWFCdWZmZXIucHJvdG90eXBlLmNoZWNrUmVxdWlyZWQgPSBmdW5jdGlvbih2YWx1ZSwgZG9jKSB7XG4gIGlmIChTY2hlbWFUeXBlLl9pc1JlZih0aGlzLCB2YWx1ZSwgZG9jLCB0cnVlKSkge1xuICAgIHJldHVybiAhIXZhbHVlO1xuICB9XG4gIHJldHVybiB0aGlzLmNvbnN0cnVjdG9yLl9jaGVja1JlcXVpcmVkKHZhbHVlKTtcbn07XG5cbi8qKlxuICogQ2FzdHMgY29udGVudHNcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gdmFsdWVcbiAqIEBwYXJhbSB7RG9jdW1lbnR9IGRvYyBkb2N1bWVudCB0aGF0IHRyaWdnZXJzIHRoZSBjYXN0aW5nXG4gKiBAcGFyYW0ge0Jvb2xlYW59IGluaXRcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cblNjaGVtYUJ1ZmZlci5wcm90b3R5cGUuY2FzdCA9IGZ1bmN0aW9uKHZhbHVlLCBkb2MsIGluaXQpIHtcbiAgbGV0IHJldDtcbiAgaWYgKFNjaGVtYVR5cGUuX2lzUmVmKHRoaXMsIHZhbHVlLCBkb2MsIGluaXQpKSB7XG4gICAgaWYgKHZhbHVlICYmIHZhbHVlLmlzTW9uZ29vc2VCdWZmZXIpIHtcbiAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9XG5cbiAgICBpZiAoQnVmZmVyLmlzQnVmZmVyKHZhbHVlKSkge1xuICAgICAgaWYgKCF2YWx1ZSB8fCAhdmFsdWUuaXNNb25nb29zZUJ1ZmZlcikge1xuICAgICAgICB2YWx1ZSA9IG5ldyBNb25nb29zZUJ1ZmZlcih2YWx1ZSwgW3RoaXMucGF0aCwgZG9jXSk7XG4gICAgICAgIGlmICh0aGlzLm9wdGlvbnMuc3VidHlwZSAhPSBudWxsKSB7XG4gICAgICAgICAgdmFsdWUuX3N1YnR5cGUgPSB0aGlzLm9wdGlvbnMuc3VidHlwZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH1cblxuICAgIGlmICh2YWx1ZSBpbnN0YW5jZW9mIEJpbmFyeSkge1xuICAgICAgcmV0ID0gbmV3IE1vbmdvb3NlQnVmZmVyKHZhbHVlLnZhbHVlKHRydWUpLCBbdGhpcy5wYXRoLCBkb2NdKTtcbiAgICAgIGlmICh0eXBlb2YgdmFsdWUuc3ViX3R5cGUgIT09ICdudW1iZXInKSB7XG4gICAgICAgIHRocm93IG5ldyBDYXN0RXJyb3IoJ0J1ZmZlcicsIHZhbHVlLCB0aGlzLnBhdGgsIG51bGwsIHRoaXMpO1xuICAgICAgfVxuICAgICAgcmV0Ll9zdWJ0eXBlID0gdmFsdWUuc3ViX3R5cGU7XG4gICAgICByZXR1cm4gcmV0O1xuICAgIH1cblxuICAgIGlmICh2YWx1ZSA9PSBudWxsIHx8IHV0aWxzLmlzTm9uQnVpbHRpbk9iamVjdCh2YWx1ZSkpIHtcbiAgICAgIHJldHVybiB0aGlzLl9jYXN0UmVmKHZhbHVlLCBkb2MsIGluaXQpO1xuICAgIH1cbiAgfVxuXG4gIC8vIGRvY3VtZW50c1xuICBpZiAodmFsdWUgJiYgdmFsdWUuX2lkKSB7XG4gICAgdmFsdWUgPSB2YWx1ZS5faWQ7XG4gIH1cblxuICBpZiAodmFsdWUgJiYgdmFsdWUuaXNNb25nb29zZUJ1ZmZlcikge1xuICAgIHJldHVybiB2YWx1ZTtcbiAgfVxuXG4gIGlmIChCdWZmZXIuaXNCdWZmZXIodmFsdWUpKSB7XG4gICAgaWYgKCF2YWx1ZSB8fCAhdmFsdWUuaXNNb25nb29zZUJ1ZmZlcikge1xuICAgICAgdmFsdWUgPSBuZXcgTW9uZ29vc2VCdWZmZXIodmFsdWUsIFt0aGlzLnBhdGgsIGRvY10pO1xuICAgICAgaWYgKHRoaXMub3B0aW9ucy5zdWJ0eXBlICE9IG51bGwpIHtcbiAgICAgICAgdmFsdWUuX3N1YnR5cGUgPSB0aGlzLm9wdGlvbnMuc3VidHlwZTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHZhbHVlO1xuICB9XG5cbiAgaWYgKHZhbHVlIGluc3RhbmNlb2YgQmluYXJ5KSB7XG4gICAgcmV0ID0gbmV3IE1vbmdvb3NlQnVmZmVyKHZhbHVlLnZhbHVlKHRydWUpLCBbdGhpcy5wYXRoLCBkb2NdKTtcbiAgICBpZiAodHlwZW9mIHZhbHVlLnN1Yl90eXBlICE9PSAnbnVtYmVyJykge1xuICAgICAgdGhyb3cgbmV3IENhc3RFcnJvcignQnVmZmVyJywgdmFsdWUsIHRoaXMucGF0aCwgbnVsbCwgdGhpcyk7XG4gICAgfVxuICAgIHJldC5fc3VidHlwZSA9IHZhbHVlLnN1Yl90eXBlO1xuICAgIHJldHVybiByZXQ7XG4gIH1cblxuICBpZiAodmFsdWUgPT09IG51bGwpIHtcbiAgICByZXR1cm4gdmFsdWU7XG4gIH1cblxuXG4gIGNvbnN0IHR5cGUgPSB0eXBlb2YgdmFsdWU7XG4gIGlmIChcbiAgICB0eXBlID09PSAnc3RyaW5nJyB8fCB0eXBlID09PSAnbnVtYmVyJyB8fCBBcnJheS5pc0FycmF5KHZhbHVlKSB8fFxuICAgICh0eXBlID09PSAnb2JqZWN0JyAmJiB2YWx1ZS50eXBlID09PSAnQnVmZmVyJyAmJiBBcnJheS5pc0FycmF5KHZhbHVlLmRhdGEpKSAvLyBnaC02ODYzXG4gICkge1xuICAgIGlmICh0eXBlID09PSAnbnVtYmVyJykge1xuICAgICAgdmFsdWUgPSBbdmFsdWVdO1xuICAgIH1cbiAgICByZXQgPSBuZXcgTW9uZ29vc2VCdWZmZXIodmFsdWUsIFt0aGlzLnBhdGgsIGRvY10pO1xuICAgIGlmICh0aGlzLm9wdGlvbnMuc3VidHlwZSAhPSBudWxsKSB7XG4gICAgICByZXQuX3N1YnR5cGUgPSB0aGlzLm9wdGlvbnMuc3VidHlwZTtcbiAgICB9XG4gICAgcmV0dXJuIHJldDtcbiAgfVxuXG4gIHRocm93IG5ldyBDYXN0RXJyb3IoJ0J1ZmZlcicsIHZhbHVlLCB0aGlzLnBhdGgsIG51bGwsIHRoaXMpO1xufTtcblxuLyoqXG4gKiBTZXRzIHRoZSBkZWZhdWx0IFtzdWJ0eXBlXShodHRwczovL3N0dWRpbzN0LmNvbS93aGF0cy1uZXcvYmVzdC1wcmFjdGljZXMtdXVpZC1tb25nb2RiLylcbiAqIGZvciB0aGlzIGJ1ZmZlci4gWW91IGNhbiBmaW5kIGEgW2xpc3Qgb2YgYWxsb3dlZCBzdWJ0eXBlcyBoZXJlXShodHRwczovL2FwaS5tb25nb2RiLmNvbS9weXRob24vY3VycmVudC9hcGkvYnNvbi9iaW5hcnkuaHRtbCkuXG4gKlxuICogIyMjIyBFeGFtcGxlOlxuICpcbiAqICAgICBjb25zdCBzID0gbmV3IFNjaGVtYSh7IHV1aWQ6IHsgdHlwZTogQnVmZmVyLCBzdWJ0eXBlOiA0IH0pO1xuICogICAgIGNvbnN0IE0gPSBkYi5tb2RlbCgnTScsIHMpO1xuICogICAgIGNvbnN0IG0gPSBuZXcgTSh7IHV1aWQ6ICd0ZXN0IHN0cmluZycgfSk7XG4gKiAgICAgbS51dWlkLl9zdWJ0eXBlOyAvLyA0XG4gKlxuICogQHBhcmFtIHtOdW1iZXJ9IHN1YnR5cGUgdGhlIGRlZmF1bHQgc3VidHlwZVxuICogQHJldHVybiB7U2NoZW1hVHlwZX0gdGhpc1xuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5TY2hlbWFCdWZmZXIucHJvdG90eXBlLnN1YnR5cGUgPSBmdW5jdGlvbihzdWJ0eXBlKSB7XG4gIHRoaXMub3B0aW9ucy5zdWJ0eXBlID0gc3VidHlwZTtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKiFcbiAqIGlnbm9yZVxuICovXG5mdW5jdGlvbiBoYW5kbGVTaW5nbGUodmFsLCBjb250ZXh0KSB7XG4gIHJldHVybiB0aGlzLmNhc3RGb3JRdWVyeShudWxsLCB2YWwsIGNvbnRleHQpO1xufVxuXG5TY2hlbWFCdWZmZXIucHJvdG90eXBlLiRjb25kaXRpb25hbEhhbmRsZXJzID1cbiAgICB1dGlscy5vcHRpb25zKFNjaGVtYVR5cGUucHJvdG90eXBlLiRjb25kaXRpb25hbEhhbmRsZXJzLCB7XG4gICAgICAkYml0c0FsbENsZWFyOiBoYW5kbGVCaXR3aXNlT3BlcmF0b3IsXG4gICAgICAkYml0c0FueUNsZWFyOiBoYW5kbGVCaXR3aXNlT3BlcmF0b3IsXG4gICAgICAkYml0c0FsbFNldDogaGFuZGxlQml0d2lzZU9wZXJhdG9yLFxuICAgICAgJGJpdHNBbnlTZXQ6IGhhbmRsZUJpdHdpc2VPcGVyYXRvcixcbiAgICAgICRndDogaGFuZGxlU2luZ2xlLFxuICAgICAgJGd0ZTogaGFuZGxlU2luZ2xlLFxuICAgICAgJGx0OiBoYW5kbGVTaW5nbGUsXG4gICAgICAkbHRlOiBoYW5kbGVTaW5nbGVcbiAgICB9KTtcblxuLyoqXG4gKiBDYXN0cyBjb250ZW50cyBmb3IgcXVlcmllcy5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gJGNvbmRpdGlvbmFsXG4gKiBAcGFyYW0ge2FueX0gW3ZhbHVlXVxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuU2NoZW1hQnVmZmVyLnByb3RvdHlwZS5jYXN0Rm9yUXVlcnkgPSBmdW5jdGlvbigkY29uZGl0aW9uYWwsIHZhbCwgY29udGV4dCkge1xuICBsZXQgaGFuZGxlcjtcbiAgaWYgKCRjb25kaXRpb25hbCAhPSBudWxsKSB7XG4gICAgaGFuZGxlciA9IHRoaXMuJGNvbmRpdGlvbmFsSGFuZGxlcnNbJGNvbmRpdGlvbmFsXTtcbiAgICBpZiAoIWhhbmRsZXIpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignQ2FuXFwndCB1c2UgJyArICRjb25kaXRpb25hbCArICcgd2l0aCBCdWZmZXIuJyk7XG4gICAgfVxuICAgIHJldHVybiBoYW5kbGVyLmNhbGwodGhpcywgdmFsKTtcbiAgfVxuICBjb25zdCBjYXN0ZWQgPSB0aGlzLmFwcGx5U2V0dGVycyh2YWwsIGNvbnRleHQpO1xuICByZXR1cm4gY2FzdGVkID8gY2FzdGVkLnRvT2JqZWN0KHsgdHJhbnNmb3JtOiBmYWxzZSwgdmlydHVhbHM6IGZhbHNlIH0pIDogY2FzdGVkO1xufTtcblxuLyohXG4gKiBNb2R1bGUgZXhwb3J0cy5cbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IFNjaGVtYUJ1ZmZlcjtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/mongoose/lib/schema/buffer.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/mongoose/lib/schema/date.js":
/*!**************************************************!*\
  !*** ./node_modules/mongoose/lib/schema/date.js ***!
  \**************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("/*!\n * Module requirements.\n */\n\n\n\nconst MongooseError = __webpack_require__(/*! ../error/index */ \"(ssr)/./node_modules/mongoose/lib/error/index.js\");\nconst SchemaDateOptions = __webpack_require__(/*! ../options/schemaDateOptions */ \"(ssr)/./node_modules/mongoose/lib/options/schemaDateOptions.js\");\nconst SchemaType = __webpack_require__(/*! ../schemaType */ \"(ssr)/./node_modules/mongoose/lib/schemaType.js\");\nconst castDate = __webpack_require__(/*! ../cast/date */ \"(ssr)/./node_modules/mongoose/lib/cast/date.js\");\nconst getConstructorName = __webpack_require__(/*! ../helpers/getConstructorName */ \"(ssr)/./node_modules/mongoose/lib/helpers/getConstructorName.js\");\nconst utils = __webpack_require__(/*! ../utils */ \"(ssr)/./node_modules/mongoose/lib/utils.js\");\n\nconst CastError = SchemaType.CastError;\n\n/**\n * Date SchemaType constructor.\n *\n * @param {String} key\n * @param {Object} options\n * @inherits SchemaType\n * @api public\n */\n\nfunction SchemaDate(key, options) {\n  SchemaType.call(this, key, options, 'Date');\n}\n\n/**\n * This schema type's name, to defend against minifiers that mangle\n * function names.\n *\n * @api public\n */\nSchemaDate.schemaName = 'Date';\n\nSchemaDate.defaultOptions = {};\n\n/*!\n * Inherits from SchemaType.\n */\nSchemaDate.prototype = Object.create(SchemaType.prototype);\nSchemaDate.prototype.constructor = SchemaDate;\nSchemaDate.prototype.OptionsConstructor = SchemaDateOptions;\n\n/*!\n * ignore\n */\n\nSchemaDate._cast = castDate;\n\n/**\n * Sets a default option for all Date instances.\n *\n * #### Example:\n *\n *     // Make all dates have `required` of true by default.\n *     mongoose.Schema.Date.set('required', true);\n *\n *     const User = mongoose.model('User', new Schema({ test: Date }));\n *     new User({ }).validateSync().errors.test.message; // Path `test` is required.\n *\n * @param {String} option The option you'd like to set the value for\n * @param {Any} value value for option\n * @return {undefined}\n * @function set\n * @static\n * @api public\n */\n\nSchemaDate.set = SchemaType.set;\n\nSchemaDate.setters = [];\n\n/**\n * Attaches a getter for all Date instances\n *\n * #### Example:\n *\n *     // Always convert Dates to string\n *     mongoose.Date.get(v => v.toString());\n *\n *     const Model = mongoose.model('Test', new Schema({ date: { type: Date, default: () => new Date() } }));\n *     typeof (new Model({}).date); // 'string'\n *\n * @param {Function} getter\n * @return {this}\n * @function get\n * @static\n * @api public\n */\n\nSchemaDate.get = SchemaType.get;\n\n/**\n * Get/set the function used to cast arbitrary values to dates.\n *\n * #### Example:\n *\n *     // Mongoose converts empty string '' into `null` for date types. You\n *     // can create a custom caster to disable it.\n *     const original = mongoose.Schema.Types.Date.cast();\n *     mongoose.Schema.Types.Date.cast(v => {\n *       assert.ok(v !== '');\n *       return original(v);\n *     });\n *\n *     // Or disable casting entirely\n *     mongoose.Schema.Types.Date.cast(false);\n *\n * @param {Function} caster\n * @return {Function}\n * @function get\n * @static\n * @api public\n */\n\nSchemaDate.cast = function cast(caster) {\n  if (arguments.length === 0) {\n    return this._cast;\n  }\n  if (caster === false) {\n    caster = this._defaultCaster;\n  }\n  this._cast = caster;\n\n  return this._cast;\n};\n\n/*!\n * ignore\n */\n\nSchemaDate._defaultCaster = v => {\n  if (v != null && !(v instanceof Date)) {\n    throw new Error();\n  }\n  return v;\n};\n\n/**\n * Declares a TTL index (rounded to the nearest second) for _Date_ types only.\n *\n * This sets the `expireAfterSeconds` index option available in MongoDB >= 2.1.2.\n * This index type is only compatible with Date types.\n *\n * #### Example:\n *\n *     // expire in 24 hours\n *     new Schema({ createdAt: { type: Date, expires: 60*60*24 }});\n *\n * `expires` utilizes the `ms` module from [guille](https://github.com/guille/) allowing us to use a friendlier syntax:\n *\n * #### Example:\n *\n *     // expire in 24 hours\n *     new Schema({ createdAt: { type: Date, expires: '24h' }});\n *\n *     // expire in 1.5 hours\n *     new Schema({ createdAt: { type: Date, expires: '1.5h' }});\n *\n *     // expire in 7 days\n *     const schema = new Schema({ createdAt: Date });\n *     schema.path('createdAt').expires('7d');\n *\n * @param {Number|String} when\n * @added 3.0.0\n * @return {SchemaType} this\n * @api public\n */\n\nSchemaDate.prototype.expires = function(when) {\n  if (getConstructorName(this._index) !== 'Object') {\n    this._index = {};\n  }\n\n  this._index.expires = when;\n  utils.expires(this._index);\n  return this;\n};\n\n/*!\n * ignore\n */\n\nSchemaDate._checkRequired = v => v instanceof Date;\n\n/**\n * Override the function the required validator uses to check whether a string\n * passes the `required` check.\n *\n * #### Example:\n *\n *     // Allow empty strings to pass `required` check\n *     mongoose.Schema.Types.String.checkRequired(v => v != null);\n *\n *     const M = mongoose.model({ str: { type: String, required: true } });\n *     new M({ str: '' }).validateSync(); // `null`, validation passes!\n *\n * @param {Function} fn\n * @return {Function}\n * @function checkRequired\n * @static\n * @api public\n */\n\nSchemaDate.checkRequired = SchemaType.checkRequired;\n\n/**\n * Check if the given value satisfies a required validator. To satisfy\n * a required validator, the given value must be an instance of `Date`.\n *\n * @param {Any} value\n * @param {Document} doc\n * @return {Boolean}\n * @api public\n */\n\nSchemaDate.prototype.checkRequired = function(value, doc) {\n  if (typeof value === 'object' && SchemaType._isRef(this, value, doc, true)) {\n    return value != null;\n  }\n\n  // `require('util').inherits()` does **not** copy static properties, and\n  // plugins like mongoose-float use `inherits()` for pre-ES6.\n  const _checkRequired = typeof this.constructor.checkRequired === 'function' ?\n    this.constructor.checkRequired() :\n    SchemaDate.checkRequired();\n  return _checkRequired(value);\n};\n\n/**\n * Sets a minimum date validator.\n *\n * #### Example:\n *\n *     const s = new Schema({ d: { type: Date, min: Date('1970-01-01') })\n *     const M = db.model('M', s)\n *     const m = new M({ d: Date('1969-12-31') })\n *     m.save(function (err) {\n *       console.error(err) // validator error\n *       m.d = Date('2014-12-08');\n *       m.save() // success\n *     })\n *\n *     // custom error messages\n *     // We can also use the special {MIN} token which will be replaced with the invalid value\n *     const min = [Date('1970-01-01'), 'The value of path `{PATH}` ({VALUE}) is beneath the limit ({MIN}).'];\n *     const schema = new Schema({ d: { type: Date, min: min })\n *     const M = mongoose.model('M', schema);\n *     const s= new M({ d: Date('1969-12-31') });\n *     s.validate(function (err) {\n *       console.log(String(err)) // ValidationError: The value of path `d` (1969-12-31) is before the limit (1970-01-01).\n *     })\n *\n * @param {Date} value minimum date\n * @param {String} [message] optional custom error message\n * @return {SchemaType} this\n * @see Customized Error Messages https://mongoosejs.com/docs/api/error.html#Error.messages\n * @api public\n */\n\nSchemaDate.prototype.min = function(value, message) {\n  if (this.minValidator) {\n    this.validators = this.validators.filter(function(v) {\n      return v.validator !== this.minValidator;\n    }, this);\n  }\n\n  if (value) {\n    let msg = message || MongooseError.messages.Date.min;\n    if (typeof msg === 'string') {\n      msg = msg.replace(/{MIN}/, (value === Date.now ? 'Date.now()' : value.toString()));\n    }\n    const _this = this;\n    this.validators.push({\n      validator: this.minValidator = function(val) {\n        let _value = value;\n        if (typeof value === 'function' && value !== Date.now) {\n          _value = _value.call(this);\n        }\n        const min = (_value === Date.now ? _value() : _this.cast(_value));\n        return val === null || val.valueOf() >= min.valueOf();\n      },\n      message: msg,\n      type: 'min',\n      min: value\n    });\n  }\n\n  return this;\n};\n\n/**\n * Sets a maximum date validator.\n *\n * #### Example:\n *\n *     const s = new Schema({ d: { type: Date, max: Date('2014-01-01') })\n *     const M = db.model('M', s)\n *     const m = new M({ d: Date('2014-12-08') })\n *     m.save(function (err) {\n *       console.error(err) // validator error\n *       m.d = Date('2013-12-31');\n *       m.save() // success\n *     })\n *\n *     // custom error messages\n *     // We can also use the special {MAX} token which will be replaced with the invalid value\n *     const max = [Date('2014-01-01'), 'The value of path `{PATH}` ({VALUE}) exceeds the limit ({MAX}).'];\n *     const schema = new Schema({ d: { type: Date, max: max })\n *     const M = mongoose.model('M', schema);\n *     const s= new M({ d: Date('2014-12-08') });\n *     s.validate(function (err) {\n *       console.log(String(err)) // ValidationError: The value of path `d` (2014-12-08) exceeds the limit (2014-01-01).\n *     })\n *\n * @param {Date} maximum date\n * @param {String} [message] optional custom error message\n * @return {SchemaType} this\n * @see Customized Error Messages https://mongoosejs.com/docs/api/error.html#Error.messages\n * @api public\n */\n\nSchemaDate.prototype.max = function(value, message) {\n  if (this.maxValidator) {\n    this.validators = this.validators.filter(function(v) {\n      return v.validator !== this.maxValidator;\n    }, this);\n  }\n\n  if (value) {\n    let msg = message || MongooseError.messages.Date.max;\n    if (typeof msg === 'string') {\n      msg = msg.replace(/{MAX}/, (value === Date.now ? 'Date.now()' : value.toString()));\n    }\n    const _this = this;\n    this.validators.push({\n      validator: this.maxValidator = function(val) {\n        let _value = value;\n        if (typeof _value === 'function' && _value !== Date.now) {\n          _value = _value.call(this);\n        }\n        const max = (_value === Date.now ? _value() : _this.cast(_value));\n        return val === null || val.valueOf() <= max.valueOf();\n      },\n      message: msg,\n      type: 'max',\n      max: value\n    });\n  }\n\n  return this;\n};\n\n/**\n * Casts to date\n *\n * @param {Object} value to cast\n * @api private\n */\n\nSchemaDate.prototype.cast = function(value) {\n  let castDate;\n  if (typeof this._castFunction === 'function') {\n    castDate = this._castFunction;\n  } else if (typeof this.constructor.cast === 'function') {\n    castDate = this.constructor.cast();\n  } else {\n    castDate = SchemaDate.cast();\n  }\n\n  try {\n    return castDate(value);\n  } catch (error) {\n    throw new CastError('date', value, this.path, error, this);\n  }\n};\n\n/**\n * Date Query casting.\n *\n * @param {Any} val\n * @api private\n */\n\nfunction handleSingle(val) {\n  return this.cast(val);\n}\n\nSchemaDate.prototype.$conditionalHandlers =\n    utils.options(SchemaType.prototype.$conditionalHandlers, {\n      $gt: handleSingle,\n      $gte: handleSingle,\n      $lt: handleSingle,\n      $lte: handleSingle\n    });\n\n\n/**\n * Casts contents for queries.\n *\n * @param {String} $conditional\n * @param {any} [value]\n * @api private\n */\n\nSchemaDate.prototype.castForQuery = function($conditional, val, context) {\n  if ($conditional == null) {\n    return this.applySetters(val, context);\n  }\n\n  const handler = this.$conditionalHandlers[$conditional];\n\n  if (!handler) {\n    throw new Error('Can\\'t use ' + $conditional + ' with Date.');\n  }\n\n  return handler.call(this, val);\n};\n\n/*!\n * Module exports.\n */\n\nmodule.exports = SchemaDate;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbW9uZ29vc2UvbGliL3NjaGVtYS9kYXRlLmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTs7QUFFYTs7QUFFYixzQkFBc0IsbUJBQU8sQ0FBQyx3RUFBZ0I7QUFDOUMsMEJBQTBCLG1CQUFPLENBQUMsb0dBQThCO0FBQ2hFLG1CQUFtQixtQkFBTyxDQUFDLHNFQUFlO0FBQzFDLGlCQUFpQixtQkFBTyxDQUFDLG9FQUFjO0FBQ3ZDLDJCQUEyQixtQkFBTyxDQUFDLHNHQUErQjtBQUNsRSxjQUFjLG1CQUFPLENBQUMsNERBQVU7O0FBRWhDOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3REFBd0QsWUFBWTtBQUNwRSxtQkFBbUIsc0NBQXNDO0FBQ3pEO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFdBQVcsS0FBSztBQUNoQixZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlEQUF5RCxRQUFRLHlDQUF5QztBQUMxRywyQkFBMkIsU0FBUztBQUNwQztBQUNBLFdBQVcsVUFBVTtBQUNyQixZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsVUFBVTtBQUNyQixZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7O0FB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QUFDQTtBQUNBLFdBQVcsS0FBSztBQUNoQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOzs7QUFHTDtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsV0FBVyxLQUFLO0FBQ2hCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vYXBwMS8uL25vZGVfbW9kdWxlcy9tb25nb29zZS9saWIvc2NoZW1hL2RhdGUuanM/ZDEwYiJdLCJzb3VyY2VzQ29udGVudCI6WyIvKiFcbiAqIE1vZHVsZSByZXF1aXJlbWVudHMuXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG5jb25zdCBNb25nb29zZUVycm9yID0gcmVxdWlyZSgnLi4vZXJyb3IvaW5kZXgnKTtcbmNvbnN0IFNjaGVtYURhdGVPcHRpb25zID0gcmVxdWlyZSgnLi4vb3B0aW9ucy9zY2hlbWFEYXRlT3B0aW9ucycpO1xuY29uc3QgU2NoZW1hVHlwZSA9IHJlcXVpcmUoJy4uL3NjaGVtYVR5cGUnKTtcbmNvbnN0IGNhc3REYXRlID0gcmVxdWlyZSgnLi4vY2FzdC9kYXRlJyk7XG5jb25zdCBnZXRDb25zdHJ1Y3Rvck5hbWUgPSByZXF1aXJlKCcuLi9oZWxwZXJzL2dldENvbnN0cnVjdG9yTmFtZScpO1xuY29uc3QgdXRpbHMgPSByZXF1aXJlKCcuLi91dGlscycpO1xuXG5jb25zdCBDYXN0RXJyb3IgPSBTY2hlbWFUeXBlLkNhc3RFcnJvcjtcblxuLyoqXG4gKiBEYXRlIFNjaGVtYVR5cGUgY29uc3RydWN0b3IuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IGtleVxuICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcbiAqIEBpbmhlcml0cyBTY2hlbWFUeXBlXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmZ1bmN0aW9uIFNjaGVtYURhdGUoa2V5LCBvcHRpb25zKSB7XG4gIFNjaGVtYVR5cGUuY2FsbCh0aGlzLCBrZXksIG9wdGlvbnMsICdEYXRlJyk7XG59XG5cbi8qKlxuICogVGhpcyBzY2hlbWEgdHlwZSdzIG5hbWUsIHRvIGRlZmVuZCBhZ2FpbnN0IG1pbmlmaWVycyB0aGF0IG1hbmdsZVxuICogZnVuY3Rpb24gbmFtZXMuXG4gKlxuICogQGFwaSBwdWJsaWNcbiAqL1xuU2NoZW1hRGF0ZS5zY2hlbWFOYW1lID0gJ0RhdGUnO1xuXG5TY2hlbWFEYXRlLmRlZmF1bHRPcHRpb25zID0ge307XG5cbi8qIVxuICogSW5oZXJpdHMgZnJvbSBTY2hlbWFUeXBlLlxuICovXG5TY2hlbWFEYXRlLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoU2NoZW1hVHlwZS5wcm90b3R5cGUpO1xuU2NoZW1hRGF0ZS5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBTY2hlbWFEYXRlO1xuU2NoZW1hRGF0ZS5wcm90b3R5cGUuT3B0aW9uc0NvbnN0cnVjdG9yID0gU2NoZW1hRGF0ZU9wdGlvbnM7XG5cbi8qIVxuICogaWdub3JlXG4gKi9cblxuU2NoZW1hRGF0ZS5fY2FzdCA9IGNhc3REYXRlO1xuXG4vKipcbiAqIFNldHMgYSBkZWZhdWx0IG9wdGlvbiBmb3IgYWxsIERhdGUgaW5zdGFuY2VzLlxuICpcbiAqICMjIyMgRXhhbXBsZTpcbiAqXG4gKiAgICAgLy8gTWFrZSBhbGwgZGF0ZXMgaGF2ZSBgcmVxdWlyZWRgIG9mIHRydWUgYnkgZGVmYXVsdC5cbiAqICAgICBtb25nb29zZS5TY2hlbWEuRGF0ZS5zZXQoJ3JlcXVpcmVkJywgdHJ1ZSk7XG4gKlxuICogICAgIGNvbnN0IFVzZXIgPSBtb25nb29zZS5tb2RlbCgnVXNlcicsIG5ldyBTY2hlbWEoeyB0ZXN0OiBEYXRlIH0pKTtcbiAqICAgICBuZXcgVXNlcih7IH0pLnZhbGlkYXRlU3luYygpLmVycm9ycy50ZXN0Lm1lc3NhZ2U7IC8vIFBhdGggYHRlc3RgIGlzIHJlcXVpcmVkLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBvcHRpb24gVGhlIG9wdGlvbiB5b3UnZCBsaWtlIHRvIHNldCB0aGUgdmFsdWUgZm9yXG4gKiBAcGFyYW0ge0FueX0gdmFsdWUgdmFsdWUgZm9yIG9wdGlvblxuICogQHJldHVybiB7dW5kZWZpbmVkfVxuICogQGZ1bmN0aW9uIHNldFxuICogQHN0YXRpY1xuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5TY2hlbWFEYXRlLnNldCA9IFNjaGVtYVR5cGUuc2V0O1xuXG5TY2hlbWFEYXRlLnNldHRlcnMgPSBbXTtcblxuLyoqXG4gKiBBdHRhY2hlcyBhIGdldHRlciBmb3IgYWxsIERhdGUgaW5zdGFuY2VzXG4gKlxuICogIyMjIyBFeGFtcGxlOlxuICpcbiAqICAgICAvLyBBbHdheXMgY29udmVydCBEYXRlcyB0byBzdHJpbmdcbiAqICAgICBtb25nb29zZS5EYXRlLmdldCh2ID0+IHYudG9TdHJpbmcoKSk7XG4gKlxuICogICAgIGNvbnN0IE1vZGVsID0gbW9uZ29vc2UubW9kZWwoJ1Rlc3QnLCBuZXcgU2NoZW1hKHsgZGF0ZTogeyB0eXBlOiBEYXRlLCBkZWZhdWx0OiAoKSA9PiBuZXcgRGF0ZSgpIH0gfSkpO1xuICogICAgIHR5cGVvZiAobmV3IE1vZGVsKHt9KS5kYXRlKTsgLy8gJ3N0cmluZydcbiAqXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBnZXR0ZXJcbiAqIEByZXR1cm4ge3RoaXN9XG4gKiBAZnVuY3Rpb24gZ2V0XG4gKiBAc3RhdGljXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cblNjaGVtYURhdGUuZ2V0ID0gU2NoZW1hVHlwZS5nZXQ7XG5cbi8qKlxuICogR2V0L3NldCB0aGUgZnVuY3Rpb24gdXNlZCB0byBjYXN0IGFyYml0cmFyeSB2YWx1ZXMgdG8gZGF0ZXMuXG4gKlxuICogIyMjIyBFeGFtcGxlOlxuICpcbiAqICAgICAvLyBNb25nb29zZSBjb252ZXJ0cyBlbXB0eSBzdHJpbmcgJycgaW50byBgbnVsbGAgZm9yIGRhdGUgdHlwZXMuIFlvdVxuICogICAgIC8vIGNhbiBjcmVhdGUgYSBjdXN0b20gY2FzdGVyIHRvIGRpc2FibGUgaXQuXG4gKiAgICAgY29uc3Qgb3JpZ2luYWwgPSBtb25nb29zZS5TY2hlbWEuVHlwZXMuRGF0ZS5jYXN0KCk7XG4gKiAgICAgbW9uZ29vc2UuU2NoZW1hLlR5cGVzLkRhdGUuY2FzdCh2ID0+IHtcbiAqICAgICAgIGFzc2VydC5vayh2ICE9PSAnJyk7XG4gKiAgICAgICByZXR1cm4gb3JpZ2luYWwodik7XG4gKiAgICAgfSk7XG4gKlxuICogICAgIC8vIE9yIGRpc2FibGUgY2FzdGluZyBlbnRpcmVseVxuICogICAgIG1vbmdvb3NlLlNjaGVtYS5UeXBlcy5EYXRlLmNhc3QoZmFsc2UpO1xuICpcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGNhc3RlclxuICogQHJldHVybiB7RnVuY3Rpb259XG4gKiBAZnVuY3Rpb24gZ2V0XG4gKiBAc3RhdGljXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cblNjaGVtYURhdGUuY2FzdCA9IGZ1bmN0aW9uIGNhc3QoY2FzdGVyKSB7XG4gIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAwKSB7XG4gICAgcmV0dXJuIHRoaXMuX2Nhc3Q7XG4gIH1cbiAgaWYgKGNhc3RlciA9PT0gZmFsc2UpIHtcbiAgICBjYXN0ZXIgPSB0aGlzLl9kZWZhdWx0Q2FzdGVyO1xuICB9XG4gIHRoaXMuX2Nhc3QgPSBjYXN0ZXI7XG5cbiAgcmV0dXJuIHRoaXMuX2Nhc3Q7XG59O1xuXG4vKiFcbiAqIGlnbm9yZVxuICovXG5cblNjaGVtYURhdGUuX2RlZmF1bHRDYXN0ZXIgPSB2ID0+IHtcbiAgaWYgKHYgIT0gbnVsbCAmJiAhKHYgaW5zdGFuY2VvZiBEYXRlKSkge1xuICAgIHRocm93IG5ldyBFcnJvcigpO1xuICB9XG4gIHJldHVybiB2O1xufTtcblxuLyoqXG4gKiBEZWNsYXJlcyBhIFRUTCBpbmRleCAocm91bmRlZCB0byB0aGUgbmVhcmVzdCBzZWNvbmQpIGZvciBfRGF0ZV8gdHlwZXMgb25seS5cbiAqXG4gKiBUaGlzIHNldHMgdGhlIGBleHBpcmVBZnRlclNlY29uZHNgIGluZGV4IG9wdGlvbiBhdmFpbGFibGUgaW4gTW9uZ29EQiA+PSAyLjEuMi5cbiAqIFRoaXMgaW5kZXggdHlwZSBpcyBvbmx5IGNvbXBhdGlibGUgd2l0aCBEYXRlIHR5cGVzLlxuICpcbiAqICMjIyMgRXhhbXBsZTpcbiAqXG4gKiAgICAgLy8gZXhwaXJlIGluIDI0IGhvdXJzXG4gKiAgICAgbmV3IFNjaGVtYSh7IGNyZWF0ZWRBdDogeyB0eXBlOiBEYXRlLCBleHBpcmVzOiA2MCo2MCoyNCB9fSk7XG4gKlxuICogYGV4cGlyZXNgIHV0aWxpemVzIHRoZSBgbXNgIG1vZHVsZSBmcm9tIFtndWlsbGVdKGh0dHBzOi8vZ2l0aHViLmNvbS9ndWlsbGUvKSBhbGxvd2luZyB1cyB0byB1c2UgYSBmcmllbmRsaWVyIHN5bnRheDpcbiAqXG4gKiAjIyMjIEV4YW1wbGU6XG4gKlxuICogICAgIC8vIGV4cGlyZSBpbiAyNCBob3Vyc1xuICogICAgIG5ldyBTY2hlbWEoeyBjcmVhdGVkQXQ6IHsgdHlwZTogRGF0ZSwgZXhwaXJlczogJzI0aCcgfX0pO1xuICpcbiAqICAgICAvLyBleHBpcmUgaW4gMS41IGhvdXJzXG4gKiAgICAgbmV3IFNjaGVtYSh7IGNyZWF0ZWRBdDogeyB0eXBlOiBEYXRlLCBleHBpcmVzOiAnMS41aCcgfX0pO1xuICpcbiAqICAgICAvLyBleHBpcmUgaW4gNyBkYXlzXG4gKiAgICAgY29uc3Qgc2NoZW1hID0gbmV3IFNjaGVtYSh7IGNyZWF0ZWRBdDogRGF0ZSB9KTtcbiAqICAgICBzY2hlbWEucGF0aCgnY3JlYXRlZEF0JykuZXhwaXJlcygnN2QnKTtcbiAqXG4gKiBAcGFyYW0ge051bWJlcnxTdHJpbmd9IHdoZW5cbiAqIEBhZGRlZCAzLjAuMFxuICogQHJldHVybiB7U2NoZW1hVHlwZX0gdGhpc1xuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5TY2hlbWFEYXRlLnByb3RvdHlwZS5leHBpcmVzID0gZnVuY3Rpb24od2hlbikge1xuICBpZiAoZ2V0Q29uc3RydWN0b3JOYW1lKHRoaXMuX2luZGV4KSAhPT0gJ09iamVjdCcpIHtcbiAgICB0aGlzLl9pbmRleCA9IHt9O1xuICB9XG5cbiAgdGhpcy5faW5kZXguZXhwaXJlcyA9IHdoZW47XG4gIHV0aWxzLmV4cGlyZXModGhpcy5faW5kZXgpO1xuICByZXR1cm4gdGhpcztcbn07XG5cbi8qIVxuICogaWdub3JlXG4gKi9cblxuU2NoZW1hRGF0ZS5fY2hlY2tSZXF1aXJlZCA9IHYgPT4gdiBpbnN0YW5jZW9mIERhdGU7XG5cbi8qKlxuICogT3ZlcnJpZGUgdGhlIGZ1bmN0aW9uIHRoZSByZXF1aXJlZCB2YWxpZGF0b3IgdXNlcyB0byBjaGVjayB3aGV0aGVyIGEgc3RyaW5nXG4gKiBwYXNzZXMgdGhlIGByZXF1aXJlZGAgY2hlY2suXG4gKlxuICogIyMjIyBFeGFtcGxlOlxuICpcbiAqICAgICAvLyBBbGxvdyBlbXB0eSBzdHJpbmdzIHRvIHBhc3MgYHJlcXVpcmVkYCBjaGVja1xuICogICAgIG1vbmdvb3NlLlNjaGVtYS5UeXBlcy5TdHJpbmcuY2hlY2tSZXF1aXJlZCh2ID0+IHYgIT0gbnVsbCk7XG4gKlxuICogICAgIGNvbnN0IE0gPSBtb25nb29zZS5tb2RlbCh7IHN0cjogeyB0eXBlOiBTdHJpbmcsIHJlcXVpcmVkOiB0cnVlIH0gfSk7XG4gKiAgICAgbmV3IE0oeyBzdHI6ICcnIH0pLnZhbGlkYXRlU3luYygpOyAvLyBgbnVsbGAsIHZhbGlkYXRpb24gcGFzc2VzIVxuICpcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuXG4gKiBAcmV0dXJuIHtGdW5jdGlvbn1cbiAqIEBmdW5jdGlvbiBjaGVja1JlcXVpcmVkXG4gKiBAc3RhdGljXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cblNjaGVtYURhdGUuY2hlY2tSZXF1aXJlZCA9IFNjaGVtYVR5cGUuY2hlY2tSZXF1aXJlZDtcblxuLyoqXG4gKiBDaGVjayBpZiB0aGUgZ2l2ZW4gdmFsdWUgc2F0aXNmaWVzIGEgcmVxdWlyZWQgdmFsaWRhdG9yLiBUbyBzYXRpc2Z5XG4gKiBhIHJlcXVpcmVkIHZhbGlkYXRvciwgdGhlIGdpdmVuIHZhbHVlIG11c3QgYmUgYW4gaW5zdGFuY2Ugb2YgYERhdGVgLlxuICpcbiAqIEBwYXJhbSB7QW55fSB2YWx1ZVxuICogQHBhcmFtIHtEb2N1bWVudH0gZG9jXG4gKiBAcmV0dXJuIHtCb29sZWFufVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5TY2hlbWFEYXRlLnByb3RvdHlwZS5jaGVja1JlcXVpcmVkID0gZnVuY3Rpb24odmFsdWUsIGRvYykge1xuICBpZiAodHlwZW9mIHZhbHVlID09PSAnb2JqZWN0JyAmJiBTY2hlbWFUeXBlLl9pc1JlZih0aGlzLCB2YWx1ZSwgZG9jLCB0cnVlKSkge1xuICAgIHJldHVybiB2YWx1ZSAhPSBudWxsO1xuICB9XG5cbiAgLy8gYHJlcXVpcmUoJ3V0aWwnKS5pbmhlcml0cygpYCBkb2VzICoqbm90KiogY29weSBzdGF0aWMgcHJvcGVydGllcywgYW5kXG4gIC8vIHBsdWdpbnMgbGlrZSBtb25nb29zZS1mbG9hdCB1c2UgYGluaGVyaXRzKClgIGZvciBwcmUtRVM2LlxuICBjb25zdCBfY2hlY2tSZXF1aXJlZCA9IHR5cGVvZiB0aGlzLmNvbnN0cnVjdG9yLmNoZWNrUmVxdWlyZWQgPT09ICdmdW5jdGlvbicgP1xuICAgIHRoaXMuY29uc3RydWN0b3IuY2hlY2tSZXF1aXJlZCgpIDpcbiAgICBTY2hlbWFEYXRlLmNoZWNrUmVxdWlyZWQoKTtcbiAgcmV0dXJuIF9jaGVja1JlcXVpcmVkKHZhbHVlKTtcbn07XG5cbi8qKlxuICogU2V0cyBhIG1pbmltdW0gZGF0ZSB2YWxpZGF0b3IuXG4gKlxuICogIyMjIyBFeGFtcGxlOlxuICpcbiAqICAgICBjb25zdCBzID0gbmV3IFNjaGVtYSh7IGQ6IHsgdHlwZTogRGF0ZSwgbWluOiBEYXRlKCcxOTcwLTAxLTAxJykgfSlcbiAqICAgICBjb25zdCBNID0gZGIubW9kZWwoJ00nLCBzKVxuICogICAgIGNvbnN0IG0gPSBuZXcgTSh7IGQ6IERhdGUoJzE5NjktMTItMzEnKSB9KVxuICogICAgIG0uc2F2ZShmdW5jdGlvbiAoZXJyKSB7XG4gKiAgICAgICBjb25zb2xlLmVycm9yKGVycikgLy8gdmFsaWRhdG9yIGVycm9yXG4gKiAgICAgICBtLmQgPSBEYXRlKCcyMDE0LTEyLTA4Jyk7XG4gKiAgICAgICBtLnNhdmUoKSAvLyBzdWNjZXNzXG4gKiAgICAgfSlcbiAqXG4gKiAgICAgLy8gY3VzdG9tIGVycm9yIG1lc3NhZ2VzXG4gKiAgICAgLy8gV2UgY2FuIGFsc28gdXNlIHRoZSBzcGVjaWFsIHtNSU59IHRva2VuIHdoaWNoIHdpbGwgYmUgcmVwbGFjZWQgd2l0aCB0aGUgaW52YWxpZCB2YWx1ZVxuICogICAgIGNvbnN0IG1pbiA9IFtEYXRlKCcxOTcwLTAxLTAxJyksICdUaGUgdmFsdWUgb2YgcGF0aCBge1BBVEh9YCAoe1ZBTFVFfSkgaXMgYmVuZWF0aCB0aGUgbGltaXQgKHtNSU59KS4nXTtcbiAqICAgICBjb25zdCBzY2hlbWEgPSBuZXcgU2NoZW1hKHsgZDogeyB0eXBlOiBEYXRlLCBtaW46IG1pbiB9KVxuICogICAgIGNvbnN0IE0gPSBtb25nb29zZS5tb2RlbCgnTScsIHNjaGVtYSk7XG4gKiAgICAgY29uc3Qgcz0gbmV3IE0oeyBkOiBEYXRlKCcxOTY5LTEyLTMxJykgfSk7XG4gKiAgICAgcy52YWxpZGF0ZShmdW5jdGlvbiAoZXJyKSB7XG4gKiAgICAgICBjb25zb2xlLmxvZyhTdHJpbmcoZXJyKSkgLy8gVmFsaWRhdGlvbkVycm9yOiBUaGUgdmFsdWUgb2YgcGF0aCBgZGAgKDE5NjktMTItMzEpIGlzIGJlZm9yZSB0aGUgbGltaXQgKDE5NzAtMDEtMDEpLlxuICogICAgIH0pXG4gKlxuICogQHBhcmFtIHtEYXRlfSB2YWx1ZSBtaW5pbXVtIGRhdGVcbiAqIEBwYXJhbSB7U3RyaW5nfSBbbWVzc2FnZV0gb3B0aW9uYWwgY3VzdG9tIGVycm9yIG1lc3NhZ2VcbiAqIEByZXR1cm4ge1NjaGVtYVR5cGV9IHRoaXNcbiAqIEBzZWUgQ3VzdG9taXplZCBFcnJvciBNZXNzYWdlcyBodHRwczovL21vbmdvb3NlanMuY29tL2RvY3MvYXBpL2Vycm9yLmh0bWwjRXJyb3IubWVzc2FnZXNcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuU2NoZW1hRGF0ZS5wcm90b3R5cGUubWluID0gZnVuY3Rpb24odmFsdWUsIG1lc3NhZ2UpIHtcbiAgaWYgKHRoaXMubWluVmFsaWRhdG9yKSB7XG4gICAgdGhpcy52YWxpZGF0b3JzID0gdGhpcy52YWxpZGF0b3JzLmZpbHRlcihmdW5jdGlvbih2KSB7XG4gICAgICByZXR1cm4gdi52YWxpZGF0b3IgIT09IHRoaXMubWluVmFsaWRhdG9yO1xuICAgIH0sIHRoaXMpO1xuICB9XG5cbiAgaWYgKHZhbHVlKSB7XG4gICAgbGV0IG1zZyA9IG1lc3NhZ2UgfHwgTW9uZ29vc2VFcnJvci5tZXNzYWdlcy5EYXRlLm1pbjtcbiAgICBpZiAodHlwZW9mIG1zZyA9PT0gJ3N0cmluZycpIHtcbiAgICAgIG1zZyA9IG1zZy5yZXBsYWNlKC97TUlOfS8sICh2YWx1ZSA9PT0gRGF0ZS5ub3cgPyAnRGF0ZS5ub3coKScgOiB2YWx1ZS50b1N0cmluZygpKSk7XG4gICAgfVxuICAgIGNvbnN0IF90aGlzID0gdGhpcztcbiAgICB0aGlzLnZhbGlkYXRvcnMucHVzaCh7XG4gICAgICB2YWxpZGF0b3I6IHRoaXMubWluVmFsaWRhdG9yID0gZnVuY3Rpb24odmFsKSB7XG4gICAgICAgIGxldCBfdmFsdWUgPSB2YWx1ZTtcbiAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ2Z1bmN0aW9uJyAmJiB2YWx1ZSAhPT0gRGF0ZS5ub3cpIHtcbiAgICAgICAgICBfdmFsdWUgPSBfdmFsdWUuY2FsbCh0aGlzKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBtaW4gPSAoX3ZhbHVlID09PSBEYXRlLm5vdyA/IF92YWx1ZSgpIDogX3RoaXMuY2FzdChfdmFsdWUpKTtcbiAgICAgICAgcmV0dXJuIHZhbCA9PT0gbnVsbCB8fCB2YWwudmFsdWVPZigpID49IG1pbi52YWx1ZU9mKCk7XG4gICAgICB9LFxuICAgICAgbWVzc2FnZTogbXNnLFxuICAgICAgdHlwZTogJ21pbicsXG4gICAgICBtaW46IHZhbHVlXG4gICAgfSk7XG4gIH1cblxuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogU2V0cyBhIG1heGltdW0gZGF0ZSB2YWxpZGF0b3IuXG4gKlxuICogIyMjIyBFeGFtcGxlOlxuICpcbiAqICAgICBjb25zdCBzID0gbmV3IFNjaGVtYSh7IGQ6IHsgdHlwZTogRGF0ZSwgbWF4OiBEYXRlKCcyMDE0LTAxLTAxJykgfSlcbiAqICAgICBjb25zdCBNID0gZGIubW9kZWwoJ00nLCBzKVxuICogICAgIGNvbnN0IG0gPSBuZXcgTSh7IGQ6IERhdGUoJzIwMTQtMTItMDgnKSB9KVxuICogICAgIG0uc2F2ZShmdW5jdGlvbiAoZXJyKSB7XG4gKiAgICAgICBjb25zb2xlLmVycm9yKGVycikgLy8gdmFsaWRhdG9yIGVycm9yXG4gKiAgICAgICBtLmQgPSBEYXRlKCcyMDEzLTEyLTMxJyk7XG4gKiAgICAgICBtLnNhdmUoKSAvLyBzdWNjZXNzXG4gKiAgICAgfSlcbiAqXG4gKiAgICAgLy8gY3VzdG9tIGVycm9yIG1lc3NhZ2VzXG4gKiAgICAgLy8gV2UgY2FuIGFsc28gdXNlIHRoZSBzcGVjaWFsIHtNQVh9IHRva2VuIHdoaWNoIHdpbGwgYmUgcmVwbGFjZWQgd2l0aCB0aGUgaW52YWxpZCB2YWx1ZVxuICogICAgIGNvbnN0IG1heCA9IFtEYXRlKCcyMDE0LTAxLTAxJyksICdUaGUgdmFsdWUgb2YgcGF0aCBge1BBVEh9YCAoe1ZBTFVFfSkgZXhjZWVkcyB0aGUgbGltaXQgKHtNQVh9KS4nXTtcbiAqICAgICBjb25zdCBzY2hlbWEgPSBuZXcgU2NoZW1hKHsgZDogeyB0eXBlOiBEYXRlLCBtYXg6IG1heCB9KVxuICogICAgIGNvbnN0IE0gPSBtb25nb29zZS5tb2RlbCgnTScsIHNjaGVtYSk7XG4gKiAgICAgY29uc3Qgcz0gbmV3IE0oeyBkOiBEYXRlKCcyMDE0LTEyLTA4JykgfSk7XG4gKiAgICAgcy52YWxpZGF0ZShmdW5jdGlvbiAoZXJyKSB7XG4gKiAgICAgICBjb25zb2xlLmxvZyhTdHJpbmcoZXJyKSkgLy8gVmFsaWRhdGlvbkVycm9yOiBUaGUgdmFsdWUgb2YgcGF0aCBgZGAgKDIwMTQtMTItMDgpIGV4Y2VlZHMgdGhlIGxpbWl0ICgyMDE0LTAxLTAxKS5cbiAqICAgICB9KVxuICpcbiAqIEBwYXJhbSB7RGF0ZX0gbWF4aW11bSBkYXRlXG4gKiBAcGFyYW0ge1N0cmluZ30gW21lc3NhZ2VdIG9wdGlvbmFsIGN1c3RvbSBlcnJvciBtZXNzYWdlXG4gKiBAcmV0dXJuIHtTY2hlbWFUeXBlfSB0aGlzXG4gKiBAc2VlIEN1c3RvbWl6ZWQgRXJyb3IgTWVzc2FnZXMgaHR0cHM6Ly9tb25nb29zZWpzLmNvbS9kb2NzL2FwaS9lcnJvci5odG1sI0Vycm9yLm1lc3NhZ2VzXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cblNjaGVtYURhdGUucHJvdG90eXBlLm1heCA9IGZ1bmN0aW9uKHZhbHVlLCBtZXNzYWdlKSB7XG4gIGlmICh0aGlzLm1heFZhbGlkYXRvcikge1xuICAgIHRoaXMudmFsaWRhdG9ycyA9IHRoaXMudmFsaWRhdG9ycy5maWx0ZXIoZnVuY3Rpb24odikge1xuICAgICAgcmV0dXJuIHYudmFsaWRhdG9yICE9PSB0aGlzLm1heFZhbGlkYXRvcjtcbiAgICB9LCB0aGlzKTtcbiAgfVxuXG4gIGlmICh2YWx1ZSkge1xuICAgIGxldCBtc2cgPSBtZXNzYWdlIHx8IE1vbmdvb3NlRXJyb3IubWVzc2FnZXMuRGF0ZS5tYXg7XG4gICAgaWYgKHR5cGVvZiBtc2cgPT09ICdzdHJpbmcnKSB7XG4gICAgICBtc2cgPSBtc2cucmVwbGFjZSgve01BWH0vLCAodmFsdWUgPT09IERhdGUubm93ID8gJ0RhdGUubm93KCknIDogdmFsdWUudG9TdHJpbmcoKSkpO1xuICAgIH1cbiAgICBjb25zdCBfdGhpcyA9IHRoaXM7XG4gICAgdGhpcy52YWxpZGF0b3JzLnB1c2goe1xuICAgICAgdmFsaWRhdG9yOiB0aGlzLm1heFZhbGlkYXRvciA9IGZ1bmN0aW9uKHZhbCkge1xuICAgICAgICBsZXQgX3ZhbHVlID0gdmFsdWU7XG4gICAgICAgIGlmICh0eXBlb2YgX3ZhbHVlID09PSAnZnVuY3Rpb24nICYmIF92YWx1ZSAhPT0gRGF0ZS5ub3cpIHtcbiAgICAgICAgICBfdmFsdWUgPSBfdmFsdWUuY2FsbCh0aGlzKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBtYXggPSAoX3ZhbHVlID09PSBEYXRlLm5vdyA/IF92YWx1ZSgpIDogX3RoaXMuY2FzdChfdmFsdWUpKTtcbiAgICAgICAgcmV0dXJuIHZhbCA9PT0gbnVsbCB8fCB2YWwudmFsdWVPZigpIDw9IG1heC52YWx1ZU9mKCk7XG4gICAgICB9LFxuICAgICAgbWVzc2FnZTogbXNnLFxuICAgICAgdHlwZTogJ21heCcsXG4gICAgICBtYXg6IHZhbHVlXG4gICAgfSk7XG4gIH1cblxuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogQ2FzdHMgdG8gZGF0ZVxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSB2YWx1ZSB0byBjYXN0XG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5TY2hlbWFEYXRlLnByb3RvdHlwZS5jYXN0ID0gZnVuY3Rpb24odmFsdWUpIHtcbiAgbGV0IGNhc3REYXRlO1xuICBpZiAodHlwZW9mIHRoaXMuX2Nhc3RGdW5jdGlvbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIGNhc3REYXRlID0gdGhpcy5fY2FzdEZ1bmN0aW9uO1xuICB9IGVsc2UgaWYgKHR5cGVvZiB0aGlzLmNvbnN0cnVjdG9yLmNhc3QgPT09ICdmdW5jdGlvbicpIHtcbiAgICBjYXN0RGF0ZSA9IHRoaXMuY29uc3RydWN0b3IuY2FzdCgpO1xuICB9IGVsc2Uge1xuICAgIGNhc3REYXRlID0gU2NoZW1hRGF0ZS5jYXN0KCk7XG4gIH1cblxuICB0cnkge1xuICAgIHJldHVybiBjYXN0RGF0ZSh2YWx1ZSk7XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgdGhyb3cgbmV3IENhc3RFcnJvcignZGF0ZScsIHZhbHVlLCB0aGlzLnBhdGgsIGVycm9yLCB0aGlzKTtcbiAgfVxufTtcblxuLyoqXG4gKiBEYXRlIFF1ZXJ5IGNhc3RpbmcuXG4gKlxuICogQHBhcmFtIHtBbnl9IHZhbFxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZnVuY3Rpb24gaGFuZGxlU2luZ2xlKHZhbCkge1xuICByZXR1cm4gdGhpcy5jYXN0KHZhbCk7XG59XG5cblNjaGVtYURhdGUucHJvdG90eXBlLiRjb25kaXRpb25hbEhhbmRsZXJzID1cbiAgICB1dGlscy5vcHRpb25zKFNjaGVtYVR5cGUucHJvdG90eXBlLiRjb25kaXRpb25hbEhhbmRsZXJzLCB7XG4gICAgICAkZ3Q6IGhhbmRsZVNpbmdsZSxcbiAgICAgICRndGU6IGhhbmRsZVNpbmdsZSxcbiAgICAgICRsdDogaGFuZGxlU2luZ2xlLFxuICAgICAgJGx0ZTogaGFuZGxlU2luZ2xlXG4gICAgfSk7XG5cblxuLyoqXG4gKiBDYXN0cyBjb250ZW50cyBmb3IgcXVlcmllcy5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gJGNvbmRpdGlvbmFsXG4gKiBAcGFyYW0ge2FueX0gW3ZhbHVlXVxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuU2NoZW1hRGF0ZS5wcm90b3R5cGUuY2FzdEZvclF1ZXJ5ID0gZnVuY3Rpb24oJGNvbmRpdGlvbmFsLCB2YWwsIGNvbnRleHQpIHtcbiAgaWYgKCRjb25kaXRpb25hbCA9PSBudWxsKSB7XG4gICAgcmV0dXJuIHRoaXMuYXBwbHlTZXR0ZXJzKHZhbCwgY29udGV4dCk7XG4gIH1cblxuICBjb25zdCBoYW5kbGVyID0gdGhpcy4kY29uZGl0aW9uYWxIYW5kbGVyc1skY29uZGl0aW9uYWxdO1xuXG4gIGlmICghaGFuZGxlcikge1xuICAgIHRocm93IG5ldyBFcnJvcignQ2FuXFwndCB1c2UgJyArICRjb25kaXRpb25hbCArICcgd2l0aCBEYXRlLicpO1xuICB9XG5cbiAgcmV0dXJuIGhhbmRsZXIuY2FsbCh0aGlzLCB2YWwpO1xufTtcblxuLyohXG4gKiBNb2R1bGUgZXhwb3J0cy5cbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IFNjaGVtYURhdGU7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/mongoose/lib/schema/date.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/mongoose/lib/schema/decimal128.js":
/*!********************************************************!*\
  !*** ./node_modules/mongoose/lib/schema/decimal128.js ***!
  \********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("/*!\n * Module dependencies.\n */\n\n\n\nconst SchemaType = __webpack_require__(/*! ../schemaType */ \"(ssr)/./node_modules/mongoose/lib/schemaType.js\");\nconst CastError = SchemaType.CastError;\nconst castDecimal128 = __webpack_require__(/*! ../cast/decimal128 */ \"(ssr)/./node_modules/mongoose/lib/cast/decimal128.js\");\nconst utils = __webpack_require__(/*! ../utils */ \"(ssr)/./node_modules/mongoose/lib/utils.js\");\nconst isBsonType = __webpack_require__(/*! ../helpers/isBsonType */ \"(ssr)/./node_modules/mongoose/lib/helpers/isBsonType.js\");\n\n/**\n * Decimal128 SchemaType constructor.\n *\n * @param {String} key\n * @param {Object} options\n * @inherits SchemaType\n * @api public\n */\n\nfunction SchemaDecimal128(key, options) {\n  SchemaType.call(this, key, options, 'Decimal128');\n}\n\n/**\n * This schema type's name, to defend against minifiers that mangle\n * function names.\n *\n * @api public\n */\nSchemaDecimal128.schemaName = 'Decimal128';\n\nSchemaDecimal128.defaultOptions = {};\n\n/*!\n * Inherits from SchemaType.\n */\nSchemaDecimal128.prototype = Object.create(SchemaType.prototype);\nSchemaDecimal128.prototype.constructor = SchemaDecimal128;\n\n/*!\n * ignore\n */\n\nSchemaDecimal128._cast = castDecimal128;\n\n/**\n * Sets a default option for all Decimal128 instances.\n *\n * #### Example:\n *\n *     // Make all decimal 128s have `required` of true by default.\n *     mongoose.Schema.Decimal128.set('required', true);\n *\n *     const User = mongoose.model('User', new Schema({ test: mongoose.Decimal128 }));\n *     new User({ }).validateSync().errors.test.message; // Path `test` is required.\n *\n * @param {String} option The option you'd like to set the value for\n * @param {Any} value value for option\n * @return {undefined}\n * @function set\n * @static\n * @api public\n */\n\nSchemaDecimal128.set = SchemaType.set;\n\nSchemaDecimal128.setters = [];\n\n/**\n * Attaches a getter for all Decimal128 instances\n *\n * #### Example:\n *\n *     // Automatically convert Decimal128s to Numbers\n *     mongoose.Schema.Decimal128.get(v => v == null ? v : Number(v));\n *\n * @param {Function} getter\n * @return {this}\n * @function get\n * @static\n * @api public\n */\n\nSchemaDecimal128.get = SchemaType.get;\n\n/**\n * Get/set the function used to cast arbitrary values to decimals.\n *\n * #### Example:\n *\n *     // Make Mongoose only refuse to cast numbers as decimal128\n *     const original = mongoose.Schema.Types.Decimal128.cast();\n *     mongoose.Decimal128.cast(v => {\n *       assert.ok(typeof v !== 'number');\n *       return original(v);\n *     });\n *\n *     // Or disable casting entirely\n *     mongoose.Decimal128.cast(false);\n *\n * @param {Function} [caster]\n * @return {Function}\n * @function get\n * @static\n * @api public\n */\n\nSchemaDecimal128.cast = function cast(caster) {\n  if (arguments.length === 0) {\n    return this._cast;\n  }\n  if (caster === false) {\n    caster = this._defaultCaster;\n  }\n  this._cast = caster;\n\n  return this._cast;\n};\n\n/*!\n * ignore\n */\n\nSchemaDecimal128._defaultCaster = v => {\n  if (v != null && !isBsonType(v, 'Decimal128')) {\n    throw new Error();\n  }\n  return v;\n};\n\n/*!\n * ignore\n */\n\nSchemaDecimal128._checkRequired = v => isBsonType(v, 'Decimal128');\n\n/**\n * Override the function the required validator uses to check whether a string\n * passes the `required` check.\n *\n * @param {Function} fn\n * @return {Function}\n * @function checkRequired\n * @static\n * @api public\n */\n\nSchemaDecimal128.checkRequired = SchemaType.checkRequired;\n\n/**\n * Check if the given value satisfies a required validator.\n *\n * @param {Any} value\n * @param {Document} doc\n * @return {Boolean}\n * @api public\n */\n\nSchemaDecimal128.prototype.checkRequired = function checkRequired(value, doc) {\n  if (SchemaType._isRef(this, value, doc, true)) {\n    return !!value;\n  }\n\n  // `require('util').inherits()` does **not** copy static properties, and\n  // plugins like mongoose-float use `inherits()` for pre-ES6.\n  const _checkRequired = typeof this.constructor.checkRequired === 'function' ?\n    this.constructor.checkRequired() :\n    SchemaDecimal128.checkRequired();\n\n  return _checkRequired(value);\n};\n\n/**\n * Casts to Decimal128\n *\n * @param {Object} value\n * @param {Object} doc\n * @param {Boolean} init whether this is an initialization cast\n * @api private\n */\n\nSchemaDecimal128.prototype.cast = function(value, doc, init) {\n  if (SchemaType._isRef(this, value, doc, init)) {\n    if (isBsonType(value, 'Decimal128')) {\n      return value;\n    }\n\n    return this._castRef(value, doc, init);\n  }\n\n  let castDecimal128;\n  if (typeof this._castFunction === 'function') {\n    castDecimal128 = this._castFunction;\n  } else if (typeof this.constructor.cast === 'function') {\n    castDecimal128 = this.constructor.cast();\n  } else {\n    castDecimal128 = SchemaDecimal128.cast();\n  }\n\n  try {\n    return castDecimal128(value);\n  } catch (error) {\n    throw new CastError('Decimal128', value, this.path, error, this);\n  }\n};\n\n/*!\n * ignore\n */\n\nfunction handleSingle(val) {\n  return this.cast(val);\n}\n\nSchemaDecimal128.prototype.$conditionalHandlers =\n    utils.options(SchemaType.prototype.$conditionalHandlers, {\n      $gt: handleSingle,\n      $gte: handleSingle,\n      $lt: handleSingle,\n      $lte: handleSingle\n    });\n\n/*!\n * Module exports.\n */\n\nmodule.exports = SchemaDecimal128;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbW9uZ29vc2UvbGliL3NjaGVtYS9kZWNpbWFsMTI4LmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTs7QUFFYTs7QUFFYixtQkFBbUIsbUJBQU8sQ0FBQyxzRUFBZTtBQUMxQztBQUNBLHVCQUF1QixtQkFBTyxDQUFDLGdGQUFvQjtBQUNuRCxjQUFjLG1CQUFPLENBQUMsNERBQVU7QUFDaEMsbUJBQW1CLG1CQUFPLENBQUMsc0ZBQXVCOztBQUVsRDtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdEQUF3RCwyQkFBMkI7QUFDbkYsbUJBQW1CLHNDQUFzQztBQUN6RDtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLEtBQUs7QUFDaEIsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFVBQVU7QUFDckIsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxVQUFVO0FBQ3JCLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFVBQVU7QUFDckIsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsS0FBSztBQUNoQixXQUFXLFVBQVU7QUFDckIsWUFBWTtBQUNaO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsV0FBVyxTQUFTO0FBQ3BCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBLElBQUk7QUFDSjtBQUNBOztBQUVBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7O0FBRUEiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9hcHAxLy4vbm9kZV9tb2R1bGVzL21vbmdvb3NlL2xpYi9zY2hlbWEvZGVjaW1hbDEyOC5qcz8xN2YxIl0sInNvdXJjZXNDb250ZW50IjpbIi8qIVxuICogTW9kdWxlIGRlcGVuZGVuY2llcy5cbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbmNvbnN0IFNjaGVtYVR5cGUgPSByZXF1aXJlKCcuLi9zY2hlbWFUeXBlJyk7XG5jb25zdCBDYXN0RXJyb3IgPSBTY2hlbWFUeXBlLkNhc3RFcnJvcjtcbmNvbnN0IGNhc3REZWNpbWFsMTI4ID0gcmVxdWlyZSgnLi4vY2FzdC9kZWNpbWFsMTI4Jyk7XG5jb25zdCB1dGlscyA9IHJlcXVpcmUoJy4uL3V0aWxzJyk7XG5jb25zdCBpc0Jzb25UeXBlID0gcmVxdWlyZSgnLi4vaGVscGVycy9pc0Jzb25UeXBlJyk7XG5cbi8qKlxuICogRGVjaW1hbDEyOCBTY2hlbWFUeXBlIGNvbnN0cnVjdG9yLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBrZXlcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zXG4gKiBAaW5oZXJpdHMgU2NoZW1hVHlwZVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5mdW5jdGlvbiBTY2hlbWFEZWNpbWFsMTI4KGtleSwgb3B0aW9ucykge1xuICBTY2hlbWFUeXBlLmNhbGwodGhpcywga2V5LCBvcHRpb25zLCAnRGVjaW1hbDEyOCcpO1xufVxuXG4vKipcbiAqIFRoaXMgc2NoZW1hIHR5cGUncyBuYW1lLCB0byBkZWZlbmQgYWdhaW5zdCBtaW5pZmllcnMgdGhhdCBtYW5nbGVcbiAqIGZ1bmN0aW9uIG5hbWVzLlxuICpcbiAqIEBhcGkgcHVibGljXG4gKi9cblNjaGVtYURlY2ltYWwxMjguc2NoZW1hTmFtZSA9ICdEZWNpbWFsMTI4JztcblxuU2NoZW1hRGVjaW1hbDEyOC5kZWZhdWx0T3B0aW9ucyA9IHt9O1xuXG4vKiFcbiAqIEluaGVyaXRzIGZyb20gU2NoZW1hVHlwZS5cbiAqL1xuU2NoZW1hRGVjaW1hbDEyOC5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKFNjaGVtYVR5cGUucHJvdG90eXBlKTtcblNjaGVtYURlY2ltYWwxMjgucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gU2NoZW1hRGVjaW1hbDEyODtcblxuLyohXG4gKiBpZ25vcmVcbiAqL1xuXG5TY2hlbWFEZWNpbWFsMTI4Ll9jYXN0ID0gY2FzdERlY2ltYWwxMjg7XG5cbi8qKlxuICogU2V0cyBhIGRlZmF1bHQgb3B0aW9uIGZvciBhbGwgRGVjaW1hbDEyOCBpbnN0YW5jZXMuXG4gKlxuICogIyMjIyBFeGFtcGxlOlxuICpcbiAqICAgICAvLyBNYWtlIGFsbCBkZWNpbWFsIDEyOHMgaGF2ZSBgcmVxdWlyZWRgIG9mIHRydWUgYnkgZGVmYXVsdC5cbiAqICAgICBtb25nb29zZS5TY2hlbWEuRGVjaW1hbDEyOC5zZXQoJ3JlcXVpcmVkJywgdHJ1ZSk7XG4gKlxuICogICAgIGNvbnN0IFVzZXIgPSBtb25nb29zZS5tb2RlbCgnVXNlcicsIG5ldyBTY2hlbWEoeyB0ZXN0OiBtb25nb29zZS5EZWNpbWFsMTI4IH0pKTtcbiAqICAgICBuZXcgVXNlcih7IH0pLnZhbGlkYXRlU3luYygpLmVycm9ycy50ZXN0Lm1lc3NhZ2U7IC8vIFBhdGggYHRlc3RgIGlzIHJlcXVpcmVkLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBvcHRpb24gVGhlIG9wdGlvbiB5b3UnZCBsaWtlIHRvIHNldCB0aGUgdmFsdWUgZm9yXG4gKiBAcGFyYW0ge0FueX0gdmFsdWUgdmFsdWUgZm9yIG9wdGlvblxuICogQHJldHVybiB7dW5kZWZpbmVkfVxuICogQGZ1bmN0aW9uIHNldFxuICogQHN0YXRpY1xuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5TY2hlbWFEZWNpbWFsMTI4LnNldCA9IFNjaGVtYVR5cGUuc2V0O1xuXG5TY2hlbWFEZWNpbWFsMTI4LnNldHRlcnMgPSBbXTtcblxuLyoqXG4gKiBBdHRhY2hlcyBhIGdldHRlciBmb3IgYWxsIERlY2ltYWwxMjggaW5zdGFuY2VzXG4gKlxuICogIyMjIyBFeGFtcGxlOlxuICpcbiAqICAgICAvLyBBdXRvbWF0aWNhbGx5IGNvbnZlcnQgRGVjaW1hbDEyOHMgdG8gTnVtYmVyc1xuICogICAgIG1vbmdvb3NlLlNjaGVtYS5EZWNpbWFsMTI4LmdldCh2ID0+IHYgPT0gbnVsbCA/IHYgOiBOdW1iZXIodikpO1xuICpcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGdldHRlclxuICogQHJldHVybiB7dGhpc31cbiAqIEBmdW5jdGlvbiBnZXRcbiAqIEBzdGF0aWNcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuU2NoZW1hRGVjaW1hbDEyOC5nZXQgPSBTY2hlbWFUeXBlLmdldDtcblxuLyoqXG4gKiBHZXQvc2V0IHRoZSBmdW5jdGlvbiB1c2VkIHRvIGNhc3QgYXJiaXRyYXJ5IHZhbHVlcyB0byBkZWNpbWFscy5cbiAqXG4gKiAjIyMjIEV4YW1wbGU6XG4gKlxuICogICAgIC8vIE1ha2UgTW9uZ29vc2Ugb25seSByZWZ1c2UgdG8gY2FzdCBudW1iZXJzIGFzIGRlY2ltYWwxMjhcbiAqICAgICBjb25zdCBvcmlnaW5hbCA9IG1vbmdvb3NlLlNjaGVtYS5UeXBlcy5EZWNpbWFsMTI4LmNhc3QoKTtcbiAqICAgICBtb25nb29zZS5EZWNpbWFsMTI4LmNhc3QodiA9PiB7XG4gKiAgICAgICBhc3NlcnQub2sodHlwZW9mIHYgIT09ICdudW1iZXInKTtcbiAqICAgICAgIHJldHVybiBvcmlnaW5hbCh2KTtcbiAqICAgICB9KTtcbiAqXG4gKiAgICAgLy8gT3IgZGlzYWJsZSBjYXN0aW5nIGVudGlyZWx5XG4gKiAgICAgbW9uZ29vc2UuRGVjaW1hbDEyOC5jYXN0KGZhbHNlKTtcbiAqXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY2FzdGVyXVxuICogQHJldHVybiB7RnVuY3Rpb259XG4gKiBAZnVuY3Rpb24gZ2V0XG4gKiBAc3RhdGljXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cblNjaGVtYURlY2ltYWwxMjguY2FzdCA9IGZ1bmN0aW9uIGNhc3QoY2FzdGVyKSB7XG4gIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAwKSB7XG4gICAgcmV0dXJuIHRoaXMuX2Nhc3Q7XG4gIH1cbiAgaWYgKGNhc3RlciA9PT0gZmFsc2UpIHtcbiAgICBjYXN0ZXIgPSB0aGlzLl9kZWZhdWx0Q2FzdGVyO1xuICB9XG4gIHRoaXMuX2Nhc3QgPSBjYXN0ZXI7XG5cbiAgcmV0dXJuIHRoaXMuX2Nhc3Q7XG59O1xuXG4vKiFcbiAqIGlnbm9yZVxuICovXG5cblNjaGVtYURlY2ltYWwxMjguX2RlZmF1bHRDYXN0ZXIgPSB2ID0+IHtcbiAgaWYgKHYgIT0gbnVsbCAmJiAhaXNCc29uVHlwZSh2LCAnRGVjaW1hbDEyOCcpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCk7XG4gIH1cbiAgcmV0dXJuIHY7XG59O1xuXG4vKiFcbiAqIGlnbm9yZVxuICovXG5cblNjaGVtYURlY2ltYWwxMjguX2NoZWNrUmVxdWlyZWQgPSB2ID0+IGlzQnNvblR5cGUodiwgJ0RlY2ltYWwxMjgnKTtcblxuLyoqXG4gKiBPdmVycmlkZSB0aGUgZnVuY3Rpb24gdGhlIHJlcXVpcmVkIHZhbGlkYXRvciB1c2VzIHRvIGNoZWNrIHdoZXRoZXIgYSBzdHJpbmdcbiAqIHBhc3NlcyB0aGUgYHJlcXVpcmVkYCBjaGVjay5cbiAqXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmblxuICogQHJldHVybiB7RnVuY3Rpb259XG4gKiBAZnVuY3Rpb24gY2hlY2tSZXF1aXJlZFxuICogQHN0YXRpY1xuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5TY2hlbWFEZWNpbWFsMTI4LmNoZWNrUmVxdWlyZWQgPSBTY2hlbWFUeXBlLmNoZWNrUmVxdWlyZWQ7XG5cbi8qKlxuICogQ2hlY2sgaWYgdGhlIGdpdmVuIHZhbHVlIHNhdGlzZmllcyBhIHJlcXVpcmVkIHZhbGlkYXRvci5cbiAqXG4gKiBAcGFyYW0ge0FueX0gdmFsdWVcbiAqIEBwYXJhbSB7RG9jdW1lbnR9IGRvY1xuICogQHJldHVybiB7Qm9vbGVhbn1cbiAqIEBhcGkgcHVibGljXG4gKi9cblxuU2NoZW1hRGVjaW1hbDEyOC5wcm90b3R5cGUuY2hlY2tSZXF1aXJlZCA9IGZ1bmN0aW9uIGNoZWNrUmVxdWlyZWQodmFsdWUsIGRvYykge1xuICBpZiAoU2NoZW1hVHlwZS5faXNSZWYodGhpcywgdmFsdWUsIGRvYywgdHJ1ZSkpIHtcbiAgICByZXR1cm4gISF2YWx1ZTtcbiAgfVxuXG4gIC8vIGByZXF1aXJlKCd1dGlsJykuaW5oZXJpdHMoKWAgZG9lcyAqKm5vdCoqIGNvcHkgc3RhdGljIHByb3BlcnRpZXMsIGFuZFxuICAvLyBwbHVnaW5zIGxpa2UgbW9uZ29vc2UtZmxvYXQgdXNlIGBpbmhlcml0cygpYCBmb3IgcHJlLUVTNi5cbiAgY29uc3QgX2NoZWNrUmVxdWlyZWQgPSB0eXBlb2YgdGhpcy5jb25zdHJ1Y3Rvci5jaGVja1JlcXVpcmVkID09PSAnZnVuY3Rpb24nID9cbiAgICB0aGlzLmNvbnN0cnVjdG9yLmNoZWNrUmVxdWlyZWQoKSA6XG4gICAgU2NoZW1hRGVjaW1hbDEyOC5jaGVja1JlcXVpcmVkKCk7XG5cbiAgcmV0dXJuIF9jaGVja1JlcXVpcmVkKHZhbHVlKTtcbn07XG5cbi8qKlxuICogQ2FzdHMgdG8gRGVjaW1hbDEyOFxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSB2YWx1ZVxuICogQHBhcmFtIHtPYmplY3R9IGRvY1xuICogQHBhcmFtIHtCb29sZWFufSBpbml0IHdoZXRoZXIgdGhpcyBpcyBhbiBpbml0aWFsaXphdGlvbiBjYXN0XG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5TY2hlbWFEZWNpbWFsMTI4LnByb3RvdHlwZS5jYXN0ID0gZnVuY3Rpb24odmFsdWUsIGRvYywgaW5pdCkge1xuICBpZiAoU2NoZW1hVHlwZS5faXNSZWYodGhpcywgdmFsdWUsIGRvYywgaW5pdCkpIHtcbiAgICBpZiAoaXNCc29uVHlwZSh2YWx1ZSwgJ0RlY2ltYWwxMjgnKSkge1xuICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzLl9jYXN0UmVmKHZhbHVlLCBkb2MsIGluaXQpO1xuICB9XG5cbiAgbGV0IGNhc3REZWNpbWFsMTI4O1xuICBpZiAodHlwZW9mIHRoaXMuX2Nhc3RGdW5jdGlvbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIGNhc3REZWNpbWFsMTI4ID0gdGhpcy5fY2FzdEZ1bmN0aW9uO1xuICB9IGVsc2UgaWYgKHR5cGVvZiB0aGlzLmNvbnN0cnVjdG9yLmNhc3QgPT09ICdmdW5jdGlvbicpIHtcbiAgICBjYXN0RGVjaW1hbDEyOCA9IHRoaXMuY29uc3RydWN0b3IuY2FzdCgpO1xuICB9IGVsc2Uge1xuICAgIGNhc3REZWNpbWFsMTI4ID0gU2NoZW1hRGVjaW1hbDEyOC5jYXN0KCk7XG4gIH1cblxuICB0cnkge1xuICAgIHJldHVybiBjYXN0RGVjaW1hbDEyOCh2YWx1ZSk7XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgdGhyb3cgbmV3IENhc3RFcnJvcignRGVjaW1hbDEyOCcsIHZhbHVlLCB0aGlzLnBhdGgsIGVycm9yLCB0aGlzKTtcbiAgfVxufTtcblxuLyohXG4gKiBpZ25vcmVcbiAqL1xuXG5mdW5jdGlvbiBoYW5kbGVTaW5nbGUodmFsKSB7XG4gIHJldHVybiB0aGlzLmNhc3QodmFsKTtcbn1cblxuU2NoZW1hRGVjaW1hbDEyOC5wcm90b3R5cGUuJGNvbmRpdGlvbmFsSGFuZGxlcnMgPVxuICAgIHV0aWxzLm9wdGlvbnMoU2NoZW1hVHlwZS5wcm90b3R5cGUuJGNvbmRpdGlvbmFsSGFuZGxlcnMsIHtcbiAgICAgICRndDogaGFuZGxlU2luZ2xlLFxuICAgICAgJGd0ZTogaGFuZGxlU2luZ2xlLFxuICAgICAgJGx0OiBoYW5kbGVTaW5nbGUsXG4gICAgICAkbHRlOiBoYW5kbGVTaW5nbGVcbiAgICB9KTtcblxuLyohXG4gKiBNb2R1bGUgZXhwb3J0cy5cbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IFNjaGVtYURlY2ltYWwxMjg7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/mongoose/lib/schema/decimal128.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/mongoose/lib/schema/documentArray.js":
/*!***********************************************************!*\
  !*** ./node_modules/mongoose/lib/schema/documentArray.js ***!
  \***********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\n\n/*!\n * Module dependencies.\n */\n\nconst CastError = __webpack_require__(/*! ../error/cast */ \"(ssr)/./node_modules/mongoose/lib/error/cast.js\");\nconst DocumentArrayElement = __webpack_require__(/*! ./documentArrayElement */ \"(ssr)/./node_modules/mongoose/lib/schema/documentArrayElement.js\");\nconst EventEmitter = (__webpack_require__(/*! events */ \"events\").EventEmitter);\nconst SchemaArray = __webpack_require__(/*! ./array */ \"(ssr)/./node_modules/mongoose/lib/schema/array.js\");\nconst SchemaDocumentArrayOptions =\n  __webpack_require__(/*! ../options/schemaDocumentArrayOptions */ \"(ssr)/./node_modules/mongoose/lib/options/schemaDocumentArrayOptions.js\");\nconst SchemaType = __webpack_require__(/*! ../schemaType */ \"(ssr)/./node_modules/mongoose/lib/schemaType.js\");\nconst discriminator = __webpack_require__(/*! ../helpers/model/discriminator */ \"(ssr)/./node_modules/mongoose/lib/helpers/model/discriminator.js\");\nconst handleIdOption = __webpack_require__(/*! ../helpers/schema/handleIdOption */ \"(ssr)/./node_modules/mongoose/lib/helpers/schema/handleIdOption.js\");\nconst handleSpreadDoc = __webpack_require__(/*! ../helpers/document/handleSpreadDoc */ \"(ssr)/./node_modules/mongoose/lib/helpers/document/handleSpreadDoc.js\");\nconst utils = __webpack_require__(/*! ../utils */ \"(ssr)/./node_modules/mongoose/lib/utils.js\");\nconst getConstructor = __webpack_require__(/*! ../helpers/discriminator/getConstructor */ \"(ssr)/./node_modules/mongoose/lib/helpers/discriminator/getConstructor.js\");\nconst InvalidSchemaOptionError = __webpack_require__(/*! ../error/invalidSchemaOption */ \"(ssr)/./node_modules/mongoose/lib/error/invalidSchemaOption.js\");\n\nconst arrayAtomicsSymbol = (__webpack_require__(/*! ../helpers/symbols */ \"(ssr)/./node_modules/mongoose/lib/helpers/symbols.js\").arrayAtomicsSymbol);\nconst arrayPathSymbol = (__webpack_require__(/*! ../helpers/symbols */ \"(ssr)/./node_modules/mongoose/lib/helpers/symbols.js\").arrayPathSymbol);\nconst documentArrayParent = (__webpack_require__(/*! ../helpers/symbols */ \"(ssr)/./node_modules/mongoose/lib/helpers/symbols.js\").documentArrayParent);\n\nlet MongooseDocumentArray;\nlet Subdocument;\n\n/**\n * SubdocsArray SchemaType constructor\n *\n * @param {String} key\n * @param {Schema} schema\n * @param {Object} options\n * @param {Object} schemaOptions\n * @inherits SchemaArray\n * @api public\n */\n\nfunction SchemaDocumentArray(key, schema, options, schemaOptions) {\n  if (schema.options && schema.options.timeseries) {\n    throw new InvalidSchemaOptionError(key, 'timeseries');\n  }\n  const schemaTypeIdOption = SchemaDocumentArray.defaultOptions &&\n    SchemaDocumentArray.defaultOptions._id;\n  if (schemaTypeIdOption != null) {\n    schemaOptions = schemaOptions || {};\n    schemaOptions._id = schemaTypeIdOption;\n  }\n\n  if (schemaOptions != null && schemaOptions._id != null) {\n    schema = handleIdOption(schema, schemaOptions);\n  } else if (options != null && options._id != null) {\n    schema = handleIdOption(schema, options);\n  }\n\n  const EmbeddedDocument = _createConstructor(schema, options);\n  EmbeddedDocument.prototype.$basePath = key;\n\n  SchemaArray.call(this, key, EmbeddedDocument, options);\n\n  this.schema = schema;\n  this.schemaOptions = schemaOptions || {};\n  this.$isMongooseDocumentArray = true;\n  this.Constructor = EmbeddedDocument;\n\n  EmbeddedDocument.base = schema.base;\n\n  const fn = this.defaultValue;\n\n  if (!('defaultValue' in this) || fn !== void 0) {\n    this.default(function() {\n      let arr = fn.call(this);\n      if (arr != null && !Array.isArray(arr)) {\n        arr = [arr];\n      }\n      // Leave it up to `cast()` to convert this to a documentarray\n      return arr;\n    });\n  }\n\n  const $parentSchemaType = this;\n  this.$embeddedSchemaType = new DocumentArrayElement(key + '.$', {\n    required: this &&\n      this.schemaOptions &&\n      this.schemaOptions.required || false,\n    $parentSchemaType\n  });\n\n  this.$embeddedSchemaType.caster = this.Constructor;\n  this.$embeddedSchemaType.schema = this.schema;\n\n  if (schema._applyDiscriminators != null && !options?._skipApplyDiscriminators) {\n    for (const disc of schema._applyDiscriminators.keys()) {\n      this.discriminator(disc, schema._applyDiscriminators.get(disc));\n    }\n  }\n}\n\n/**\n * This schema type's name, to defend against minifiers that mangle\n * function names.\n *\n * @api public\n */\nSchemaDocumentArray.schemaName = 'DocumentArray';\n\n/**\n * Options for all document arrays.\n *\n * - `castNonArrays`: `true` by default. If `false`, Mongoose will throw a CastError when a value isn't an array. If `true`, Mongoose will wrap the provided value in an array before casting.\n *\n * @api public\n */\n\nSchemaDocumentArray.options = { castNonArrays: true };\n\n/*!\n * Inherits from SchemaArray.\n */\nSchemaDocumentArray.prototype = Object.create(SchemaArray.prototype);\nSchemaDocumentArray.prototype.constructor = SchemaDocumentArray;\nSchemaDocumentArray.prototype.OptionsConstructor = SchemaDocumentArrayOptions;\n\n/*!\n * ignore\n */\n\nfunction _createConstructor(schema, options, baseClass) {\n  Subdocument || (Subdocument = __webpack_require__(/*! ../types/arraySubdocument */ \"(ssr)/./node_modules/mongoose/lib/types/arraySubdocument.js\"));\n\n  // compile an embedded document for this schema\n  function EmbeddedDocument() {\n    Subdocument.apply(this, arguments);\n    if (this.__parentArray == null || this.__parentArray.getArrayParent() == null) {\n      return;\n    }\n    this.$session(this.__parentArray.getArrayParent().$session());\n  }\n\n  schema._preCompile();\n\n  const proto = baseClass != null ? baseClass.prototype : Subdocument.prototype;\n  EmbeddedDocument.prototype = Object.create(proto);\n  EmbeddedDocument.prototype.$__setSchema(schema);\n  EmbeddedDocument.schema = schema;\n  EmbeddedDocument.prototype.constructor = EmbeddedDocument;\n  EmbeddedDocument.$isArraySubdocument = true;\n  EmbeddedDocument.events = new EventEmitter();\n  EmbeddedDocument.base = schema.base;\n\n  // apply methods\n  for (const i in schema.methods) {\n    EmbeddedDocument.prototype[i] = schema.methods[i];\n  }\n\n  // apply statics\n  for (const i in schema.statics) {\n    EmbeddedDocument[i] = schema.statics[i];\n  }\n\n  for (const i in EventEmitter.prototype) {\n    EmbeddedDocument[i] = EventEmitter.prototype[i];\n  }\n\n  EmbeddedDocument.options = options;\n\n  return EmbeddedDocument;\n}\n\n/**\n * Adds a discriminator to this document array.\n *\n * #### Example:\n *\n *     const shapeSchema = Schema({ name: String }, { discriminatorKey: 'kind' });\n *     const schema = Schema({ shapes: [shapeSchema] });\n *\n *     const docArrayPath = parentSchema.path('shapes');\n *     docArrayPath.discriminator('Circle', Schema({ radius: Number }));\n *\n * @param {String} name\n * @param {Schema} schema fields to add to the schema for instances of this sub-class\n * @param {Object|string} [options] If string, same as `options.value`.\n * @param {String} [options.value] the string stored in the `discriminatorKey` property. If not specified, Mongoose uses the `name` parameter.\n * @param {Boolean} [options.clone=true] By default, `discriminator()` clones the given `schema`. Set to `false` to skip cloning.\n * @see discriminators https://mongoosejs.com/docs/discriminators.html\n * @return {Function} the constructor Mongoose will use for creating instances of this discriminator model\n * @api public\n */\n\nSchemaDocumentArray.prototype.discriminator = function(name, schema, options) {\n  if (typeof name === 'function') {\n    name = utils.getFunctionName(name);\n  }\n\n  options = options || {};\n  const tiedValue = utils.isPOJO(options) ? options.value : options;\n  const clone = typeof options.clone === 'boolean' ? options.clone : true;\n\n  if (schema.instanceOfSchema && clone) {\n    schema = schema.clone();\n  }\n\n  schema = discriminator(this.casterConstructor, name, schema, tiedValue);\n\n  const EmbeddedDocument = _createConstructor(schema, null, this.casterConstructor);\n  EmbeddedDocument.baseCasterConstructor = this.casterConstructor;\n\n  try {\n    Object.defineProperty(EmbeddedDocument, 'name', {\n      value: name\n    });\n  } catch (error) {\n    // Ignore error, only happens on old versions of node\n  }\n\n  this.casterConstructor.discriminators[name] = EmbeddedDocument;\n\n  return this.casterConstructor.discriminators[name];\n};\n\n/**\n * Performs local validations first, then validations on each embedded doc\n *\n * @api private\n */\n\nSchemaDocumentArray.prototype.doValidate = function(array, fn, scope, options) {\n  // lazy load\n  MongooseDocumentArray || (MongooseDocumentArray = __webpack_require__(/*! ../types/documentArray */ \"(ssr)/./node_modules/mongoose/lib/types/documentArray/index.js\"));\n\n  const _this = this;\n  try {\n    SchemaType.prototype.doValidate.call(this, array, cb, scope);\n  } catch (err) {\n    return fn(err);\n  }\n\n  function cb(err) {\n    if (err) {\n      return fn(err);\n    }\n\n    let count = array && array.length;\n    let error;\n\n    if (!count) {\n      return fn();\n    }\n    if (options && options.updateValidator) {\n      return fn();\n    }\n    if (!utils.isMongooseDocumentArray(array)) {\n      array = new MongooseDocumentArray(array, _this.path, scope);\n    }\n\n    // handle sparse arrays, do not use array.forEach which does not\n    // iterate over sparse elements yet reports array.length including\n    // them :(\n\n    function callback(err) {\n      if (err != null) {\n        error = err;\n      }\n      --count || fn(error);\n    }\n\n    for (let i = 0, len = count; i < len; ++i) {\n      // sidestep sparse entries\n      let doc = array[i];\n      if (doc == null) {\n        --count || fn(error);\n        continue;\n      }\n\n      // If you set the array index directly, the doc might not yet be\n      // a full fledged mongoose subdoc, so make it into one.\n      if (!(doc instanceof Subdocument)) {\n        const Constructor = getConstructor(_this.casterConstructor, array[i]);\n        doc = array[i] = new Constructor(doc, array, undefined, undefined, i);\n      }\n\n      if (options != null && options.validateModifiedOnly && !doc.$isModified()) {\n        --count || fn(error);\n        continue;\n      }\n\n      doc.$__validate(callback);\n    }\n  }\n};\n\n/**\n * Performs local validations first, then validations on each embedded doc.\n *\n * #### Note:\n *\n * This method ignores the asynchronous validators.\n *\n * @return {MongooseError|undefined}\n * @api private\n */\n\nSchemaDocumentArray.prototype.doValidateSync = function(array, scope, options) {\n  const schemaTypeError = SchemaType.prototype.doValidateSync.call(this, array, scope);\n  if (schemaTypeError != null) {\n    return schemaTypeError;\n  }\n\n  const count = array && array.length;\n  let resultError = null;\n\n  if (!count) {\n    return;\n  }\n\n  // handle sparse arrays, do not use array.forEach which does not\n  // iterate over sparse elements yet reports array.length including\n  // them :(\n\n  for (let i = 0, len = count; i < len; ++i) {\n    // sidestep sparse entries\n    let doc = array[i];\n    if (!doc) {\n      continue;\n    }\n\n    // If you set the array index directly, the doc might not yet be\n    // a full fledged mongoose subdoc, so make it into one.\n    if (!(doc instanceof Subdocument)) {\n      const Constructor = getConstructor(this.casterConstructor, array[i]);\n      doc = array[i] = new Constructor(doc, array, undefined, undefined, i);\n    }\n\n    if (options != null && options.validateModifiedOnly && !doc.$isModified()) {\n      continue;\n    }\n\n    const subdocValidateError = doc.validateSync();\n\n    if (subdocValidateError && resultError == null) {\n      resultError = subdocValidateError;\n    }\n  }\n\n  return resultError;\n};\n\n/*!\n * ignore\n */\n\nSchemaDocumentArray.prototype.getDefault = function(scope, init, options) {\n  let ret = typeof this.defaultValue === 'function'\n    ? this.defaultValue.call(scope)\n    : this.defaultValue;\n\n  if (ret == null) {\n    return ret;\n  }\n\n  if (options && options.skipCast) {\n    return ret;\n  }\n\n  // lazy load\n  MongooseDocumentArray || (MongooseDocumentArray = __webpack_require__(/*! ../types/documentArray */ \"(ssr)/./node_modules/mongoose/lib/types/documentArray/index.js\"));\n\n  if (!Array.isArray(ret)) {\n    ret = [ret];\n  }\n\n  ret = new MongooseDocumentArray(ret, this.path, scope);\n\n  for (let i = 0; i < ret.length; ++i) {\n    const Constructor = getConstructor(this.casterConstructor, ret[i]);\n    const _subdoc = new Constructor({}, ret, undefined,\n      undefined, i);\n    _subdoc.$init(ret[i]);\n    _subdoc.isNew = true;\n\n    // Make sure all paths in the subdoc are set to `default` instead\n    // of `init` since we used `init`.\n    Object.assign(_subdoc.$__.activePaths.default, _subdoc.$__.activePaths.init);\n    _subdoc.$__.activePaths.init = {};\n\n    ret[i] = _subdoc;\n  }\n\n  return ret;\n};\n\nconst _toObjectOptions = Object.freeze({ transform: false, virtuals: false });\nconst initDocumentOptions = Object.freeze({ skipId: false, willInit: true });\n\n/**\n * Casts contents\n *\n * @param {Object} value\n * @param {Document} document that triggers the casting\n * @api private\n */\n\nSchemaDocumentArray.prototype.cast = function(value, doc, init, prev, options) {\n  // lazy load\n  MongooseDocumentArray || (MongooseDocumentArray = __webpack_require__(/*! ../types/documentArray */ \"(ssr)/./node_modules/mongoose/lib/types/documentArray/index.js\"));\n\n  // Skip casting if `value` is the same as the previous value, no need to cast. See gh-9266\n  if (value != null && value[arrayPathSymbol] != null && value === prev) {\n    return value;\n  }\n\n  let selected;\n  let subdoc;\n\n  options = options || {};\n\n  const path = options.path || this.path;\n\n  if (!Array.isArray(value)) {\n    if (!init && !SchemaDocumentArray.options.castNonArrays) {\n      throw new CastError('DocumentArray', value, this.path, null, this);\n    }\n    // gh-2442 mark whole array as modified if we're initializing a doc from\n    // the db and the path isn't an array in the document\n    if (!!doc && init) {\n      doc.markModified(path);\n    }\n    return this.cast([value], doc, init, prev, options);\n  }\n\n  // We need to create a new array, otherwise change tracking will\n  // update the old doc (gh-4449)\n  if (!options.skipDocumentArrayCast || utils.isMongooseDocumentArray(value)) {\n    value = new MongooseDocumentArray(value, path, doc);\n  }\n\n  if (prev != null) {\n    value[arrayAtomicsSymbol] = prev[arrayAtomicsSymbol] || {};\n  }\n\n  if (options.arrayPathIndex != null) {\n    value[arrayPathSymbol] = path + '.' + options.arrayPathIndex;\n  }\n\n  const rawArray = utils.isMongooseDocumentArray(value) ? value.__array : value;\n  const len = rawArray.length;\n\n  for (let i = 0; i < len; ++i) {\n    if (!rawArray[i]) {\n      continue;\n    }\n\n    const Constructor = getConstructor(this.casterConstructor, rawArray[i]);\n\n    // Check if the document has a different schema (re gh-3701)\n    if (rawArray[i].$__ != null && !(rawArray[i] instanceof Constructor)) {\n      const spreadDoc = handleSpreadDoc(rawArray[i], true);\n      if (rawArray[i] !== spreadDoc) {\n        rawArray[i] = spreadDoc;\n      } else {\n        rawArray[i] = rawArray[i].toObject({\n          transform: false,\n          // Special case: if different model, but same schema, apply virtuals\n          // re: gh-7898\n          virtuals: rawArray[i].schema === Constructor.schema\n        });\n      }\n    }\n\n    if (rawArray[i] instanceof Subdocument) {\n      if (rawArray[i][documentArrayParent] !== doc) {\n        if (init) {\n          const subdoc = new Constructor(null, value, initDocumentOptions, selected, i);\n          rawArray[i] = subdoc.$init(rawArray[i]);\n        } else {\n          const subdoc = new Constructor(rawArray[i], value, undefined, undefined, i);\n          rawArray[i] = subdoc;\n        }\n      }\n      // Might not have the correct index yet, so ensure it does.\n      if (rawArray[i].__index == null) {\n        rawArray[i].$setIndex(i);\n      }\n    } else if (rawArray[i] != null) {\n      if (init) {\n        if (doc) {\n          selected || (selected = scopePaths(this, doc.$__.selected, init));\n        } else {\n          selected = true;\n        }\n\n        subdoc = new Constructor(null, value, initDocumentOptions, selected, i);\n        rawArray[i] = subdoc.$init(rawArray[i]);\n      } else {\n        if (prev && typeof prev.id === 'function') {\n          subdoc = prev.id(rawArray[i]._id);\n        }\n\n        if (prev && subdoc && utils.deepEqual(subdoc.toObject(_toObjectOptions), rawArray[i])) {\n          // handle resetting doc with existing id and same data\n          subdoc.set(rawArray[i]);\n          // if set() is hooked it will have no return value\n          // see gh-746\n          rawArray[i] = subdoc;\n        } else {\n          try {\n            subdoc = new Constructor(rawArray[i], value, undefined,\n              undefined, i);\n            // if set() is hooked it will have no return value\n            // see gh-746\n            rawArray[i] = subdoc;\n          } catch (error) {\n            throw new CastError('embedded', rawArray[i],\n              value[arrayPathSymbol], error, this);\n          }\n        }\n      }\n    }\n  }\n\n  return value;\n};\n\n/*!\n * ignore\n */\n\nSchemaDocumentArray.prototype.clone = function() {\n  const options = Object.assign({}, this.options);\n  const schematype = new this.constructor(this.path, this.schema, { ...options, _skipApplyDiscriminators: true }, this.schemaOptions);\n  schematype.validators = this.validators.slice();\n  if (this.requiredValidator !== undefined) {\n    schematype.requiredValidator = this.requiredValidator;\n  }\n  schematype.Constructor.discriminators = Object.assign({},\n    this.Constructor.discriminators);\n  return schematype;\n};\n\n/*!\n * ignore\n */\n\nSchemaDocumentArray.prototype.applyGetters = function(value, scope) {\n  return SchemaType.prototype.applyGetters.call(this, value, scope);\n};\n\n/**\n * Scopes paths selected in a query to this array.\n * Necessary for proper default application of subdocument values.\n *\n * @param {DocumentArrayPath} array the array to scope `fields` paths\n * @param {Object|undefined} fields the root fields selected in the query\n * @param {Boolean|undefined} init if we are being created part of a query result\n * @api private\n */\n\nfunction scopePaths(array, fields, init) {\n  if (!(init && fields)) {\n    return undefined;\n  }\n\n  const path = array.path + '.';\n  const keys = Object.keys(fields);\n  let i = keys.length;\n  const selected = {};\n  let hasKeys;\n  let key;\n  let sub;\n\n  while (i--) {\n    key = keys[i];\n    if (key.startsWith(path)) {\n      sub = key.substring(path.length);\n      if (sub === '$') {\n        continue;\n      }\n      if (sub.startsWith('$.')) {\n        sub = sub.substring(2);\n      }\n      hasKeys || (hasKeys = true);\n      selected[sub] = fields[key];\n    }\n  }\n\n  return hasKeys && selected || undefined;\n}\n\n/*!\n * ignore\n */\n\nSchemaDocumentArray.defaultOptions = {};\n\n/**\n * Sets a default option for all DocumentArray instances.\n *\n * #### Example:\n *\n *     // Make all numbers have option `min` equal to 0.\n *     mongoose.Schema.DocumentArray.set('_id', false);\n *\n * @param {String} option The name of the option you'd like to set (e.g. trim, lowercase, etc...)\n * @param {Any} value The value of the option you'd like to set.\n * @return {void}\n * @function set\n * @static\n * @api public\n */\n\nSchemaDocumentArray.set = SchemaType.set;\n\nSchemaDocumentArray.setters = [];\n\n/**\n * Attaches a getter for all DocumentArrayPath instances\n *\n * @param {Function} getter\n * @return {this}\n * @function get\n * @static\n * @api public\n */\n\nSchemaDocumentArray.get = SchemaType.get;\n\n/*!\n * Module exports.\n */\n\nmodule.exports = SchemaDocumentArray;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbW9uZ29vc2UvbGliL3NjaGVtYS9kb2N1bWVudEFycmF5LmpzIiwibWFwcGluZ3MiOiJBQUFhOztBQUViO0FBQ0E7QUFDQTs7QUFFQSxrQkFBa0IsbUJBQU8sQ0FBQyxzRUFBZTtBQUN6Qyw2QkFBNkIsbUJBQU8sQ0FBQyxnR0FBd0I7QUFDN0QscUJBQXFCLDBEQUE4QjtBQUNuRCxvQkFBb0IsbUJBQU8sQ0FBQyxrRUFBUztBQUNyQztBQUNBLEVBQUUsbUJBQU8sQ0FBQyxzSEFBdUM7QUFDakQsbUJBQW1CLG1CQUFPLENBQUMsc0VBQWU7QUFDMUMsc0JBQXNCLG1CQUFPLENBQUMsd0dBQWdDO0FBQzlELHVCQUF1QixtQkFBTyxDQUFDLDRHQUFrQztBQUNqRSx3QkFBd0IsbUJBQU8sQ0FBQyxrSEFBcUM7QUFDckUsY0FBYyxtQkFBTyxDQUFDLDREQUFVO0FBQ2hDLHVCQUF1QixtQkFBTyxDQUFDLDBIQUF5QztBQUN4RSxpQ0FBaUMsbUJBQU8sQ0FBQyxvR0FBOEI7O0FBRXZFLDJCQUEyQiwwSEFBZ0Q7QUFDM0Usd0JBQXdCLHVIQUE2QztBQUNyRSw0QkFBNEIsMkhBQWlEOztBQUU3RTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7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QixZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxVQUFVO0FBQ3JCLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9hcHAxLy4vbm9kZV9tb2R1bGVzL21vbmdvb3NlL2xpYi9zY2hlbWEvZG9jdW1lbnRBcnJheS5qcz82YjhlIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxuLyohXG4gKiBNb2R1bGUgZGVwZW5kZW5jaWVzLlxuICovXG5cbmNvbnN0IENhc3RFcnJvciA9IHJlcXVpcmUoJy4uL2Vycm9yL2Nhc3QnKTtcbmNvbnN0IERvY3VtZW50QXJyYXlFbGVtZW50ID0gcmVxdWlyZSgnLi9kb2N1bWVudEFycmF5RWxlbWVudCcpO1xuY29uc3QgRXZlbnRFbWl0dGVyID0gcmVxdWlyZSgnZXZlbnRzJykuRXZlbnRFbWl0dGVyO1xuY29uc3QgU2NoZW1hQXJyYXkgPSByZXF1aXJlKCcuL2FycmF5Jyk7XG5jb25zdCBTY2hlbWFEb2N1bWVudEFycmF5T3B0aW9ucyA9XG4gIHJlcXVpcmUoJy4uL29wdGlvbnMvc2NoZW1hRG9jdW1lbnRBcnJheU9wdGlvbnMnKTtcbmNvbnN0IFNjaGVtYVR5cGUgPSByZXF1aXJlKCcuLi9zY2hlbWFUeXBlJyk7XG5jb25zdCBkaXNjcmltaW5hdG9yID0gcmVxdWlyZSgnLi4vaGVscGVycy9tb2RlbC9kaXNjcmltaW5hdG9yJyk7XG5jb25zdCBoYW5kbGVJZE9wdGlvbiA9IHJlcXVpcmUoJy4uL2hlbHBlcnMvc2NoZW1hL2hhbmRsZUlkT3B0aW9uJyk7XG5jb25zdCBoYW5kbGVTcHJlYWREb2MgPSByZXF1aXJlKCcuLi9oZWxwZXJzL2RvY3VtZW50L2hhbmRsZVNwcmVhZERvYycpO1xuY29uc3QgdXRpbHMgPSByZXF1aXJlKCcuLi91dGlscycpO1xuY29uc3QgZ2V0Q29uc3RydWN0b3IgPSByZXF1aXJlKCcuLi9oZWxwZXJzL2Rpc2NyaW1pbmF0b3IvZ2V0Q29uc3RydWN0b3InKTtcbmNvbnN0IEludmFsaWRTY2hlbWFPcHRpb25FcnJvciA9IHJlcXVpcmUoJy4uL2Vycm9yL2ludmFsaWRTY2hlbWFPcHRpb24nKTtcblxuY29uc3QgYXJyYXlBdG9taWNzU3ltYm9sID0gcmVxdWlyZSgnLi4vaGVscGVycy9zeW1ib2xzJykuYXJyYXlBdG9taWNzU3ltYm9sO1xuY29uc3QgYXJyYXlQYXRoU3ltYm9sID0gcmVxdWlyZSgnLi4vaGVscGVycy9zeW1ib2xzJykuYXJyYXlQYXRoU3ltYm9sO1xuY29uc3QgZG9jdW1lbnRBcnJheVBhcmVudCA9IHJlcXVpcmUoJy4uL2hlbHBlcnMvc3ltYm9scycpLmRvY3VtZW50QXJyYXlQYXJlbnQ7XG5cbmxldCBNb25nb29zZURvY3VtZW50QXJyYXk7XG5sZXQgU3ViZG9jdW1lbnQ7XG5cbi8qKlxuICogU3ViZG9jc0FycmF5IFNjaGVtYVR5cGUgY29uc3RydWN0b3JcbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30ga2V5XG4gKiBAcGFyYW0ge1NjaGVtYX0gc2NoZW1hXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xuICogQHBhcmFtIHtPYmplY3R9IHNjaGVtYU9wdGlvbnNcbiAqIEBpbmhlcml0cyBTY2hlbWFBcnJheVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5mdW5jdGlvbiBTY2hlbWFEb2N1bWVudEFycmF5KGtleSwgc2NoZW1hLCBvcHRpb25zLCBzY2hlbWFPcHRpb25zKSB7XG4gIGlmIChzY2hlbWEub3B0aW9ucyAmJiBzY2hlbWEub3B0aW9ucy50aW1lc2VyaWVzKSB7XG4gICAgdGhyb3cgbmV3IEludmFsaWRTY2hlbWFPcHRpb25FcnJvcihrZXksICd0aW1lc2VyaWVzJyk7XG4gIH1cbiAgY29uc3Qgc2NoZW1hVHlwZUlkT3B0aW9uID0gU2NoZW1hRG9jdW1lbnRBcnJheS5kZWZhdWx0T3B0aW9ucyAmJlxuICAgIFNjaGVtYURvY3VtZW50QXJyYXkuZGVmYXVsdE9wdGlvbnMuX2lkO1xuICBpZiAoc2NoZW1hVHlwZUlkT3B0aW9uICE9IG51bGwpIHtcbiAgICBzY2hlbWFPcHRpb25zID0gc2NoZW1hT3B0aW9ucyB8fCB7fTtcbiAgICBzY2hlbWFPcHRpb25zLl9pZCA9IHNjaGVtYVR5cGVJZE9wdGlvbjtcbiAgfVxuXG4gIGlmIChzY2hlbWFPcHRpb25zICE9IG51bGwgJiYgc2NoZW1hT3B0aW9ucy5faWQgIT0gbnVsbCkge1xuICAgIHNjaGVtYSA9IGhhbmRsZUlkT3B0aW9uKHNjaGVtYSwgc2NoZW1hT3B0aW9ucyk7XG4gIH0gZWxzZSBpZiAob3B0aW9ucyAhPSBudWxsICYmIG9wdGlvbnMuX2lkICE9IG51bGwpIHtcbiAgICBzY2hlbWEgPSBoYW5kbGVJZE9wdGlvbihzY2hlbWEsIG9wdGlvbnMpO1xuICB9XG5cbiAgY29uc3QgRW1iZWRkZWREb2N1bWVudCA9IF9jcmVhdGVDb25zdHJ1Y3RvcihzY2hlbWEsIG9wdGlvbnMpO1xuICBFbWJlZGRlZERvY3VtZW50LnByb3RvdHlwZS4kYmFzZVBhdGggPSBrZXk7XG5cbiAgU2NoZW1hQXJyYXkuY2FsbCh0aGlzLCBrZXksIEVtYmVkZGVkRG9jdW1lbnQsIG9wdGlvbnMpO1xuXG4gIHRoaXMuc2NoZW1hID0gc2NoZW1hO1xuICB0aGlzLnNjaGVtYU9wdGlvbnMgPSBzY2hlbWFPcHRpb25zIHx8IHt9O1xuICB0aGlzLiRpc01vbmdvb3NlRG9jdW1lbnRBcnJheSA9IHRydWU7XG4gIHRoaXMuQ29uc3RydWN0b3IgPSBFbWJlZGRlZERvY3VtZW50O1xuXG4gIEVtYmVkZGVkRG9jdW1lbnQuYmFzZSA9IHNjaGVtYS5iYXNlO1xuXG4gIGNvbnN0IGZuID0gdGhpcy5kZWZhdWx0VmFsdWU7XG5cbiAgaWYgKCEoJ2RlZmF1bHRWYWx1ZScgaW4gdGhpcykgfHwgZm4gIT09IHZvaWQgMCkge1xuICAgIHRoaXMuZGVmYXVsdChmdW5jdGlvbigpIHtcbiAgICAgIGxldCBhcnIgPSBmbi5jYWxsKHRoaXMpO1xuICAgICAgaWYgKGFyciAhPSBudWxsICYmICFBcnJheS5pc0FycmF5KGFycikpIHtcbiAgICAgICAgYXJyID0gW2Fycl07XG4gICAgICB9XG4gICAgICAvLyBMZWF2ZSBpdCB1cCB0byBgY2FzdCgpYCB0byBjb252ZXJ0IHRoaXMgdG8gYSBkb2N1bWVudGFycmF5XG4gICAgICByZXR1cm4gYXJyO1xuICAgIH0pO1xuICB9XG5cbiAgY29uc3QgJHBhcmVudFNjaGVtYVR5cGUgPSB0aGlzO1xuICB0aGlzLiRlbWJlZGRlZFNjaGVtYVR5cGUgPSBuZXcgRG9jdW1lbnRBcnJheUVsZW1lbnQoa2V5ICsgJy4kJywge1xuICAgIHJlcXVpcmVkOiB0aGlzICYmXG4gICAgICB0aGlzLnNjaGVtYU9wdGlvbnMgJiZcbiAgICAgIHRoaXMuc2NoZW1hT3B0aW9ucy5yZXF1aXJlZCB8fCBmYWxzZSxcbiAgICAkcGFyZW50U2NoZW1hVHlwZVxuICB9KTtcblxuICB0aGlzLiRlbWJlZGRlZFNjaGVtYVR5cGUuY2FzdGVyID0gdGhpcy5Db25zdHJ1Y3RvcjtcbiAgdGhpcy4kZW1iZWRkZWRTY2hlbWFUeXBlLnNjaGVtYSA9IHRoaXMuc2NoZW1hO1xuXG4gIGlmIChzY2hlbWEuX2FwcGx5RGlzY3JpbWluYXRvcnMgIT0gbnVsbCAmJiAhb3B0aW9ucz8uX3NraXBBcHBseURpc2NyaW1pbmF0b3JzKSB7XG4gICAgZm9yIChjb25zdCBkaXNjIG9mIHNjaGVtYS5fYXBwbHlEaXNjcmltaW5hdG9ycy5rZXlzKCkpIHtcbiAgICAgIHRoaXMuZGlzY3JpbWluYXRvcihkaXNjLCBzY2hlbWEuX2FwcGx5RGlzY3JpbWluYXRvcnMuZ2V0KGRpc2MpKTtcbiAgICB9XG4gIH1cbn1cblxuLyoqXG4gKiBUaGlzIHNjaGVtYSB0eXBlJ3MgbmFtZSwgdG8gZGVmZW5kIGFnYWluc3QgbWluaWZpZXJzIHRoYXQgbWFuZ2xlXG4gKiBmdW5jdGlvbiBuYW1lcy5cbiAqXG4gKiBAYXBpIHB1YmxpY1xuICovXG5TY2hlbWFEb2N1bWVudEFycmF5LnNjaGVtYU5hbWUgPSAnRG9jdW1lbnRBcnJheSc7XG5cbi8qKlxuICogT3B0aW9ucyBmb3IgYWxsIGRvY3VtZW50IGFycmF5cy5cbiAqXG4gKiAtIGBjYXN0Tm9uQXJyYXlzYDogYHRydWVgIGJ5IGRlZmF1bHQuIElmIGBmYWxzZWAsIE1vbmdvb3NlIHdpbGwgdGhyb3cgYSBDYXN0RXJyb3Igd2hlbiBhIHZhbHVlIGlzbid0IGFuIGFycmF5LiBJZiBgdHJ1ZWAsIE1vbmdvb3NlIHdpbGwgd3JhcCB0aGUgcHJvdmlkZWQgdmFsdWUgaW4gYW4gYXJyYXkgYmVmb3JlIGNhc3RpbmcuXG4gKlxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5TY2hlbWFEb2N1bWVudEFycmF5Lm9wdGlvbnMgPSB7IGNhc3ROb25BcnJheXM6IHRydWUgfTtcblxuLyohXG4gKiBJbmhlcml0cyBmcm9tIFNjaGVtYUFycmF5LlxuICovXG5TY2hlbWFEb2N1bWVudEFycmF5LnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoU2NoZW1hQXJyYXkucHJvdG90eXBlKTtcblNjaGVtYURvY3VtZW50QXJyYXkucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gU2NoZW1hRG9jdW1lbnRBcnJheTtcblNjaGVtYURvY3VtZW50QXJyYXkucHJvdG90eXBlLk9wdGlvbnNDb25zdHJ1Y3RvciA9IFNjaGVtYURvY3VtZW50QXJyYXlPcHRpb25zO1xuXG4vKiFcbiAqIGlnbm9yZVxuICovXG5cbmZ1bmN0aW9uIF9jcmVhdGVDb25zdHJ1Y3RvcihzY2hlbWEsIG9wdGlvbnMsIGJhc2VDbGFzcykge1xuICBTdWJkb2N1bWVudCB8fCAoU3ViZG9jdW1lbnQgPSByZXF1aXJlKCcuLi90eXBlcy9hcnJheVN1YmRvY3VtZW50JykpO1xuXG4gIC8vIGNvbXBpbGUgYW4gZW1iZWRkZWQgZG9jdW1lbnQgZm9yIHRoaXMgc2NoZW1hXG4gIGZ1bmN0aW9uIEVtYmVkZGVkRG9jdW1lbnQoKSB7XG4gICAgU3ViZG9jdW1lbnQuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICBpZiAodGhpcy5fX3BhcmVudEFycmF5ID09IG51bGwgfHwgdGhpcy5fX3BhcmVudEFycmF5LmdldEFycmF5UGFyZW50KCkgPT0gbnVsbCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLiRzZXNzaW9uKHRoaXMuX19wYXJlbnRBcnJheS5nZXRBcnJheVBhcmVudCgpLiRzZXNzaW9uKCkpO1xuICB9XG5cbiAgc2NoZW1hLl9wcmVDb21waWxlKCk7XG5cbiAgY29uc3QgcHJvdG8gPSBiYXNlQ2xhc3MgIT0gbnVsbCA/IGJhc2VDbGFzcy5wcm90b3R5cGUgOiBTdWJkb2N1bWVudC5wcm90b3R5cGU7XG4gIEVtYmVkZGVkRG9jdW1lbnQucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShwcm90byk7XG4gIEVtYmVkZGVkRG9jdW1lbnQucHJvdG90eXBlLiRfX3NldFNjaGVtYShzY2hlbWEpO1xuICBFbWJlZGRlZERvY3VtZW50LnNjaGVtYSA9IHNjaGVtYTtcbiAgRW1iZWRkZWREb2N1bWVudC5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBFbWJlZGRlZERvY3VtZW50O1xuICBFbWJlZGRlZERvY3VtZW50LiRpc0FycmF5U3ViZG9jdW1lbnQgPSB0cnVlO1xuICBFbWJlZGRlZERvY3VtZW50LmV2ZW50cyA9IG5ldyBFdmVudEVtaXR0ZXIoKTtcbiAgRW1iZWRkZWREb2N1bWVudC5iYXNlID0gc2NoZW1hLmJhc2U7XG5cbiAgLy8gYXBwbHkgbWV0aG9kc1xuICBmb3IgKGNvbnN0IGkgaW4gc2NoZW1hLm1ldGhvZHMpIHtcbiAgICBFbWJlZGRlZERvY3VtZW50LnByb3RvdHlwZVtpXSA9IHNjaGVtYS5tZXRob2RzW2ldO1xuICB9XG5cbiAgLy8gYXBwbHkgc3RhdGljc1xuICBmb3IgKGNvbnN0IGkgaW4gc2NoZW1hLnN0YXRpY3MpIHtcbiAgICBFbWJlZGRlZERvY3VtZW50W2ldID0gc2NoZW1hLnN0YXRpY3NbaV07XG4gIH1cblxuICBmb3IgKGNvbnN0IGkgaW4gRXZlbnRFbWl0dGVyLnByb3RvdHlwZSkge1xuICAgIEVtYmVkZGVkRG9jdW1lbnRbaV0gPSBFdmVudEVtaXR0ZXIucHJvdG90eXBlW2ldO1xuICB9XG5cbiAgRW1iZWRkZWREb2N1bWVudC5vcHRpb25zID0gb3B0aW9ucztcblxuICByZXR1cm4gRW1iZWRkZWREb2N1bWVudDtcbn1cblxuLyoqXG4gKiBBZGRzIGEgZGlzY3JpbWluYXRvciB0byB0aGlzIGRvY3VtZW50IGFycmF5LlxuICpcbiAqICMjIyMgRXhhbXBsZTpcbiAqXG4gKiAgICAgY29uc3Qgc2hhcGVTY2hlbWEgPSBTY2hlbWEoeyBuYW1lOiBTdHJpbmcgfSwgeyBkaXNjcmltaW5hdG9yS2V5OiAna2luZCcgfSk7XG4gKiAgICAgY29uc3Qgc2NoZW1hID0gU2NoZW1hKHsgc2hhcGVzOiBbc2hhcGVTY2hlbWFdIH0pO1xuICpcbiAqICAgICBjb25zdCBkb2NBcnJheVBhdGggPSBwYXJlbnRTY2hlbWEucGF0aCgnc2hhcGVzJyk7XG4gKiAgICAgZG9jQXJyYXlQYXRoLmRpc2NyaW1pbmF0b3IoJ0NpcmNsZScsIFNjaGVtYSh7IHJhZGl1czogTnVtYmVyIH0pKTtcbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gbmFtZVxuICogQHBhcmFtIHtTY2hlbWF9IHNjaGVtYSBmaWVsZHMgdG8gYWRkIHRvIHRoZSBzY2hlbWEgZm9yIGluc3RhbmNlcyBvZiB0aGlzIHN1Yi1jbGFzc1xuICogQHBhcmFtIHtPYmplY3R8c3RyaW5nfSBbb3B0aW9uc10gSWYgc3RyaW5nLCBzYW1lIGFzIGBvcHRpb25zLnZhbHVlYC5cbiAqIEBwYXJhbSB7U3RyaW5nfSBbb3B0aW9ucy52YWx1ZV0gdGhlIHN0cmluZyBzdG9yZWQgaW4gdGhlIGBkaXNjcmltaW5hdG9yS2V5YCBwcm9wZXJ0eS4gSWYgbm90IHNwZWNpZmllZCwgTW9uZ29vc2UgdXNlcyB0aGUgYG5hbWVgIHBhcmFtZXRlci5cbiAqIEBwYXJhbSB7Qm9vbGVhbn0gW29wdGlvbnMuY2xvbmU9dHJ1ZV0gQnkgZGVmYXVsdCwgYGRpc2NyaW1pbmF0b3IoKWAgY2xvbmVzIHRoZSBnaXZlbiBgc2NoZW1hYC4gU2V0IHRvIGBmYWxzZWAgdG8gc2tpcCBjbG9uaW5nLlxuICogQHNlZSBkaXNjcmltaW5hdG9ycyBodHRwczovL21vbmdvb3NlanMuY29tL2RvY3MvZGlzY3JpbWluYXRvcnMuaHRtbFxuICogQHJldHVybiB7RnVuY3Rpb259IHRoZSBjb25zdHJ1Y3RvciBNb25nb29zZSB3aWxsIHVzZSBmb3IgY3JlYXRpbmcgaW5zdGFuY2VzIG9mIHRoaXMgZGlzY3JpbWluYXRvciBtb2RlbFxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5TY2hlbWFEb2N1bWVudEFycmF5LnByb3RvdHlwZS5kaXNjcmltaW5hdG9yID0gZnVuY3Rpb24obmFtZSwgc2NoZW1hLCBvcHRpb25zKSB7XG4gIGlmICh0eXBlb2YgbmFtZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIG5hbWUgPSB1dGlscy5nZXRGdW5jdGlvbk5hbWUobmFtZSk7XG4gIH1cblxuICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgY29uc3QgdGllZFZhbHVlID0gdXRpbHMuaXNQT0pPKG9wdGlvbnMpID8gb3B0aW9ucy52YWx1ZSA6IG9wdGlvbnM7XG4gIGNvbnN0IGNsb25lID0gdHlwZW9mIG9wdGlvbnMuY2xvbmUgPT09ICdib29sZWFuJyA/IG9wdGlvbnMuY2xvbmUgOiB0cnVlO1xuXG4gIGlmIChzY2hlbWEuaW5zdGFuY2VPZlNjaGVtYSAmJiBjbG9uZSkge1xuICAgIHNjaGVtYSA9IHNjaGVtYS5jbG9uZSgpO1xuICB9XG5cbiAgc2NoZW1hID0gZGlzY3JpbWluYXRvcih0aGlzLmNhc3RlckNvbnN0cnVjdG9yLCBuYW1lLCBzY2hlbWEsIHRpZWRWYWx1ZSk7XG5cbiAgY29uc3QgRW1iZWRkZWREb2N1bWVudCA9IF9jcmVhdGVDb25zdHJ1Y3RvcihzY2hlbWEsIG51bGwsIHRoaXMuY2FzdGVyQ29uc3RydWN0b3IpO1xuICBFbWJlZGRlZERvY3VtZW50LmJhc2VDYXN0ZXJDb25zdHJ1Y3RvciA9IHRoaXMuY2FzdGVyQ29uc3RydWN0b3I7XG5cbiAgdHJ5IHtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoRW1iZWRkZWREb2N1bWVudCwgJ25hbWUnLCB7XG4gICAgICB2YWx1ZTogbmFtZVxuICAgIH0pO1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIC8vIElnbm9yZSBlcnJvciwgb25seSBoYXBwZW5zIG9uIG9sZCB2ZXJzaW9ucyBvZiBub2RlXG4gIH1cblxuICB0aGlzLmNhc3RlckNvbnN0cnVjdG9yLmRpc2NyaW1pbmF0b3JzW25hbWVdID0gRW1iZWRkZWREb2N1bWVudDtcblxuICByZXR1cm4gdGhpcy5jYXN0ZXJDb25zdHJ1Y3Rvci5kaXNjcmltaW5hdG9yc1tuYW1lXTtcbn07XG5cbi8qKlxuICogUGVyZm9ybXMgbG9jYWwgdmFsaWRhdGlvbnMgZmlyc3QsIHRoZW4gdmFsaWRhdGlvbnMgb24gZWFjaCBlbWJlZGRlZCBkb2NcbiAqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5TY2hlbWFEb2N1bWVudEFycmF5LnByb3RvdHlwZS5kb1ZhbGlkYXRlID0gZnVuY3Rpb24oYXJyYXksIGZuLCBzY29wZSwgb3B0aW9ucykge1xuICAvLyBsYXp5IGxvYWRcbiAgTW9uZ29vc2VEb2N1bWVudEFycmF5IHx8IChNb25nb29zZURvY3VtZW50QXJyYXkgPSByZXF1aXJlKCcuLi90eXBlcy9kb2N1bWVudEFycmF5JykpO1xuXG4gIGNvbnN0IF90aGlzID0gdGhpcztcbiAgdHJ5IHtcbiAgICBTY2hlbWFUeXBlLnByb3RvdHlwZS5kb1ZhbGlkYXRlLmNhbGwodGhpcywgYXJyYXksIGNiLCBzY29wZSk7XG4gIH0gY2F0Y2ggKGVycikge1xuICAgIHJldHVybiBmbihlcnIpO1xuICB9XG5cbiAgZnVuY3Rpb24gY2IoZXJyKSB7XG4gICAgaWYgKGVycikge1xuICAgICAgcmV0dXJuIGZuKGVycik7XG4gICAgfVxuXG4gICAgbGV0IGNvdW50ID0gYXJyYXkgJiYgYXJyYXkubGVuZ3RoO1xuICAgIGxldCBlcnJvcjtcblxuICAgIGlmICghY291bnQpIHtcbiAgICAgIHJldHVybiBmbigpO1xuICAgIH1cbiAgICBpZiAob3B0aW9ucyAmJiBvcHRpb25zLnVwZGF0ZVZhbGlkYXRvcikge1xuICAgICAgcmV0dXJuIGZuKCk7XG4gICAgfVxuICAgIGlmICghdXRpbHMuaXNNb25nb29zZURvY3VtZW50QXJyYXkoYXJyYXkpKSB7XG4gICAgICBhcnJheSA9IG5ldyBNb25nb29zZURvY3VtZW50QXJyYXkoYXJyYXksIF90aGlzLnBhdGgsIHNjb3BlKTtcbiAgICB9XG5cbiAgICAvLyBoYW5kbGUgc3BhcnNlIGFycmF5cywgZG8gbm90IHVzZSBhcnJheS5mb3JFYWNoIHdoaWNoIGRvZXMgbm90XG4gICAgLy8gaXRlcmF0ZSBvdmVyIHNwYXJzZSBlbGVtZW50cyB5ZXQgcmVwb3J0cyBhcnJheS5sZW5ndGggaW5jbHVkaW5nXG4gICAgLy8gdGhlbSA6KFxuXG4gICAgZnVuY3Rpb24gY2FsbGJhY2soZXJyKSB7XG4gICAgICBpZiAoZXJyICE9IG51bGwpIHtcbiAgICAgICAgZXJyb3IgPSBlcnI7XG4gICAgICB9XG4gICAgICAtLWNvdW50IHx8IGZuKGVycm9yKTtcbiAgICB9XG5cbiAgICBmb3IgKGxldCBpID0gMCwgbGVuID0gY291bnQ7IGkgPCBsZW47ICsraSkge1xuICAgICAgLy8gc2lkZXN0ZXAgc3BhcnNlIGVudHJpZXNcbiAgICAgIGxldCBkb2MgPSBhcnJheVtpXTtcbiAgICAgIGlmIChkb2MgPT0gbnVsbCkge1xuICAgICAgICAtLWNvdW50IHx8IGZuKGVycm9yKTtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIC8vIElmIHlvdSBzZXQgdGhlIGFycmF5IGluZGV4IGRpcmVjdGx5LCB0aGUgZG9jIG1pZ2h0IG5vdCB5ZXQgYmVcbiAgICAgIC8vIGEgZnVsbCBmbGVkZ2VkIG1vbmdvb3NlIHN1YmRvYywgc28gbWFrZSBpdCBpbnRvIG9uZS5cbiAgICAgIGlmICghKGRvYyBpbnN0YW5jZW9mIFN1YmRvY3VtZW50KSkge1xuICAgICAgICBjb25zdCBDb25zdHJ1Y3RvciA9IGdldENvbnN0cnVjdG9yKF90aGlzLmNhc3RlckNvbnN0cnVjdG9yLCBhcnJheVtpXSk7XG4gICAgICAgIGRvYyA9IGFycmF5W2ldID0gbmV3IENvbnN0cnVjdG9yKGRvYywgYXJyYXksIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCBpKTtcbiAgICAgIH1cblxuICAgICAgaWYgKG9wdGlvbnMgIT0gbnVsbCAmJiBvcHRpb25zLnZhbGlkYXRlTW9kaWZpZWRPbmx5ICYmICFkb2MuJGlzTW9kaWZpZWQoKSkge1xuICAgICAgICAtLWNvdW50IHx8IGZuKGVycm9yKTtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIGRvYy4kX192YWxpZGF0ZShjYWxsYmFjayk7XG4gICAgfVxuICB9XG59O1xuXG4vKipcbiAqIFBlcmZvcm1zIGxvY2FsIHZhbGlkYXRpb25zIGZpcnN0LCB0aGVuIHZhbGlkYXRpb25zIG9uIGVhY2ggZW1iZWRkZWQgZG9jLlxuICpcbiAqICMjIyMgTm90ZTpcbiAqXG4gKiBUaGlzIG1ldGhvZCBpZ25vcmVzIHRoZSBhc3luY2hyb25vdXMgdmFsaWRhdG9ycy5cbiAqXG4gKiBAcmV0dXJuIHtNb25nb29zZUVycm9yfHVuZGVmaW5lZH1cbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cblNjaGVtYURvY3VtZW50QXJyYXkucHJvdG90eXBlLmRvVmFsaWRhdGVTeW5jID0gZnVuY3Rpb24oYXJyYXksIHNjb3BlLCBvcHRpb25zKSB7XG4gIGNvbnN0IHNjaGVtYVR5cGVFcnJvciA9IFNjaGVtYVR5cGUucHJvdG90eXBlLmRvVmFsaWRhdGVTeW5jLmNhbGwodGhpcywgYXJyYXksIHNjb3BlKTtcbiAgaWYgKHNjaGVtYVR5cGVFcnJvciAhPSBudWxsKSB7XG4gICAgcmV0dXJuIHNjaGVtYVR5cGVFcnJvcjtcbiAgfVxuXG4gIGNvbnN0IGNvdW50ID0gYXJyYXkgJiYgYXJyYXkubGVuZ3RoO1xuICBsZXQgcmVzdWx0RXJyb3IgPSBudWxsO1xuXG4gIGlmICghY291bnQpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICAvLyBoYW5kbGUgc3BhcnNlIGFycmF5cywgZG8gbm90IHVzZSBhcnJheS5mb3JFYWNoIHdoaWNoIGRvZXMgbm90XG4gIC8vIGl0ZXJhdGUgb3ZlciBzcGFyc2UgZWxlbWVudHMgeWV0IHJlcG9ydHMgYXJyYXkubGVuZ3RoIGluY2x1ZGluZ1xuICAvLyB0aGVtIDooXG5cbiAgZm9yIChsZXQgaSA9IDAsIGxlbiA9IGNvdW50OyBpIDwgbGVuOyArK2kpIHtcbiAgICAvLyBzaWRlc3RlcCBzcGFyc2UgZW50cmllc1xuICAgIGxldCBkb2MgPSBhcnJheVtpXTtcbiAgICBpZiAoIWRvYykge1xuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgLy8gSWYgeW91IHNldCB0aGUgYXJyYXkgaW5kZXggZGlyZWN0bHksIHRoZSBkb2MgbWlnaHQgbm90IHlldCBiZVxuICAgIC8vIGEgZnVsbCBmbGVkZ2VkIG1vbmdvb3NlIHN1YmRvYywgc28gbWFrZSBpdCBpbnRvIG9uZS5cbiAgICBpZiAoIShkb2MgaW5zdGFuY2VvZiBTdWJkb2N1bWVudCkpIHtcbiAgICAgIGNvbnN0IENvbnN0cnVjdG9yID0gZ2V0Q29uc3RydWN0b3IodGhpcy5jYXN0ZXJDb25zdHJ1Y3RvciwgYXJyYXlbaV0pO1xuICAgICAgZG9jID0gYXJyYXlbaV0gPSBuZXcgQ29uc3RydWN0b3IoZG9jLCBhcnJheSwgdW5kZWZpbmVkLCB1bmRlZmluZWQsIGkpO1xuICAgIH1cblxuICAgIGlmIChvcHRpb25zICE9IG51bGwgJiYgb3B0aW9ucy52YWxpZGF0ZU1vZGlmaWVkT25seSAmJiAhZG9jLiRpc01vZGlmaWVkKCkpIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIGNvbnN0IHN1YmRvY1ZhbGlkYXRlRXJyb3IgPSBkb2MudmFsaWRhdGVTeW5jKCk7XG5cbiAgICBpZiAoc3ViZG9jVmFsaWRhdGVFcnJvciAmJiByZXN1bHRFcnJvciA9PSBudWxsKSB7XG4gICAgICByZXN1bHRFcnJvciA9IHN1YmRvY1ZhbGlkYXRlRXJyb3I7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHJlc3VsdEVycm9yO1xufTtcblxuLyohXG4gKiBpZ25vcmVcbiAqL1xuXG5TY2hlbWFEb2N1bWVudEFycmF5LnByb3RvdHlwZS5nZXREZWZhdWx0ID0gZnVuY3Rpb24oc2NvcGUsIGluaXQsIG9wdGlvbnMpIHtcbiAgbGV0IHJldCA9IHR5cGVvZiB0aGlzLmRlZmF1bHRWYWx1ZSA9PT0gJ2Z1bmN0aW9uJ1xuICAgID8gdGhpcy5kZWZhdWx0VmFsdWUuY2FsbChzY29wZSlcbiAgICA6IHRoaXMuZGVmYXVsdFZhbHVlO1xuXG4gIGlmIChyZXQgPT0gbnVsbCkge1xuICAgIHJldHVybiByZXQ7XG4gIH1cblxuICBpZiAob3B0aW9ucyAmJiBvcHRpb25zLnNraXBDYXN0KSB7XG4gICAgcmV0dXJuIHJldDtcbiAgfVxuXG4gIC8vIGxhenkgbG9hZFxuICBNb25nb29zZURvY3VtZW50QXJyYXkgfHwgKE1vbmdvb3NlRG9jdW1lbnRBcnJheSA9IHJlcXVpcmUoJy4uL3R5cGVzL2RvY3VtZW50QXJyYXknKSk7XG5cbiAgaWYgKCFBcnJheS5pc0FycmF5KHJldCkpIHtcbiAgICByZXQgPSBbcmV0XTtcbiAgfVxuXG4gIHJldCA9IG5ldyBNb25nb29zZURvY3VtZW50QXJyYXkocmV0LCB0aGlzLnBhdGgsIHNjb3BlKTtcblxuICBmb3IgKGxldCBpID0gMDsgaSA8IHJldC5sZW5ndGg7ICsraSkge1xuICAgIGNvbnN0IENvbnN0cnVjdG9yID0gZ2V0Q29uc3RydWN0b3IodGhpcy5jYXN0ZXJDb25zdHJ1Y3RvciwgcmV0W2ldKTtcbiAgICBjb25zdCBfc3ViZG9jID0gbmV3IENvbnN0cnVjdG9yKHt9LCByZXQsIHVuZGVmaW5lZCxcbiAgICAgIHVuZGVmaW5lZCwgaSk7XG4gICAgX3N1YmRvYy4kaW5pdChyZXRbaV0pO1xuICAgIF9zdWJkb2MuaXNOZXcgPSB0cnVlO1xuXG4gICAgLy8gTWFrZSBzdXJlIGFsbCBwYXRocyBpbiB0aGUgc3ViZG9jIGFyZSBzZXQgdG8gYGRlZmF1bHRgIGluc3RlYWRcbiAgICAvLyBvZiBgaW5pdGAgc2luY2Ugd2UgdXNlZCBgaW5pdGAuXG4gICAgT2JqZWN0LmFzc2lnbihfc3ViZG9jLiRfXy5hY3RpdmVQYXRocy5kZWZhdWx0LCBfc3ViZG9jLiRfXy5hY3RpdmVQYXRocy5pbml0KTtcbiAgICBfc3ViZG9jLiRfXy5hY3RpdmVQYXRocy5pbml0ID0ge307XG5cbiAgICByZXRbaV0gPSBfc3ViZG9jO1xuICB9XG5cbiAgcmV0dXJuIHJldDtcbn07XG5cbmNvbnN0IF90b09iamVjdE9wdGlvbnMgPSBPYmplY3QuZnJlZXplKHsgdHJhbnNmb3JtOiBmYWxzZSwgdmlydHVhbHM6IGZhbHNlIH0pO1xuY29uc3QgaW5pdERvY3VtZW50T3B0aW9ucyA9IE9iamVjdC5mcmVlemUoeyBza2lwSWQ6IGZhbHNlLCB3aWxsSW5pdDogdHJ1ZSB9KTtcblxuLyoqXG4gKiBDYXN0cyBjb250ZW50c1xuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSB2YWx1ZVxuICogQHBhcmFtIHtEb2N1bWVudH0gZG9jdW1lbnQgdGhhdCB0cmlnZ2VycyB0aGUgY2FzdGluZ1xuICogQGFwaSBwcml2YXRlXG4gKi9cblxuU2NoZW1hRG9jdW1lbnRBcnJheS5wcm90b3R5cGUuY2FzdCA9IGZ1bmN0aW9uKHZhbHVlLCBkb2MsIGluaXQsIHByZXYsIG9wdGlvbnMpIHtcbiAgLy8gbGF6eSBsb2FkXG4gIE1vbmdvb3NlRG9jdW1lbnRBcnJheSB8fCAoTW9uZ29vc2VEb2N1bWVudEFycmF5ID0gcmVxdWlyZSgnLi4vdHlwZXMvZG9jdW1lbnRBcnJheScpKTtcblxuICAvLyBTa2lwIGNhc3RpbmcgaWYgYHZhbHVlYCBpcyB0aGUgc2FtZSBhcyB0aGUgcHJldmlvdXMgdmFsdWUsIG5vIG5lZWQgdG8gY2FzdC4gU2VlIGdoLTkyNjZcbiAgaWYgKHZhbHVlICE9IG51bGwgJiYgdmFsdWVbYXJyYXlQYXRoU3ltYm9sXSAhPSBudWxsICYmIHZhbHVlID09PSBwcmV2KSB7XG4gICAgcmV0dXJuIHZhbHVlO1xuICB9XG5cbiAgbGV0IHNlbGVjdGVkO1xuICBsZXQgc3ViZG9jO1xuXG4gIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuXG4gIGNvbnN0IHBhdGggPSBvcHRpb25zLnBhdGggfHwgdGhpcy5wYXRoO1xuXG4gIGlmICghQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICBpZiAoIWluaXQgJiYgIVNjaGVtYURvY3VtZW50QXJyYXkub3B0aW9ucy5jYXN0Tm9uQXJyYXlzKSB7XG4gICAgICB0aHJvdyBuZXcgQ2FzdEVycm9yKCdEb2N1bWVudEFycmF5JywgdmFsdWUsIHRoaXMucGF0aCwgbnVsbCwgdGhpcyk7XG4gICAgfVxuICAgIC8vIGdoLTI0NDIgbWFyayB3aG9sZSBhcnJheSBhcyBtb2RpZmllZCBpZiB3ZSdyZSBpbml0aWFsaXppbmcgYSBkb2MgZnJvbVxuICAgIC8vIHRoZSBkYiBhbmQgdGhlIHBhdGggaXNuJ3QgYW4gYXJyYXkgaW4gdGhlIGRvY3VtZW50XG4gICAgaWYgKCEhZG9jICYmIGluaXQpIHtcbiAgICAgIGRvYy5tYXJrTW9kaWZpZWQocGF0aCk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLmNhc3QoW3ZhbHVlXSwgZG9jLCBpbml0LCBwcmV2LCBvcHRpb25zKTtcbiAgfVxuXG4gIC8vIFdlIG5lZWQgdG8gY3JlYXRlIGEgbmV3IGFycmF5LCBvdGhlcndpc2UgY2hhbmdlIHRyYWNraW5nIHdpbGxcbiAgLy8gdXBkYXRlIHRoZSBvbGQgZG9jIChnaC00NDQ5KVxuICBpZiAoIW9wdGlvbnMuc2tpcERvY3VtZW50QXJyYXlDYXN0IHx8IHV0aWxzLmlzTW9uZ29vc2VEb2N1bWVudEFycmF5KHZhbHVlKSkge1xuICAgIHZhbHVlID0gbmV3IE1vbmdvb3NlRG9jdW1lbnRBcnJheSh2YWx1ZSwgcGF0aCwgZG9jKTtcbiAgfVxuXG4gIGlmIChwcmV2ICE9IG51bGwpIHtcbiAgICB2YWx1ZVthcnJheUF0b21pY3NTeW1ib2xdID0gcHJldlthcnJheUF0b21pY3NTeW1ib2xdIHx8IHt9O1xuICB9XG5cbiAgaWYgKG9wdGlvbnMuYXJyYXlQYXRoSW5kZXggIT0gbnVsbCkge1xuICAgIHZhbHVlW2FycmF5UGF0aFN5bWJvbF0gPSBwYXRoICsgJy4nICsgb3B0aW9ucy5hcnJheVBhdGhJbmRleDtcbiAgfVxuXG4gIGNvbnN0IHJhd0FycmF5ID0gdXRpbHMuaXNNb25nb29zZURvY3VtZW50QXJyYXkodmFsdWUpID8gdmFsdWUuX19hcnJheSA6IHZhbHVlO1xuICBjb25zdCBsZW4gPSByYXdBcnJheS5sZW5ndGg7XG5cbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZW47ICsraSkge1xuICAgIGlmICghcmF3QXJyYXlbaV0pIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIGNvbnN0IENvbnN0cnVjdG9yID0gZ2V0Q29uc3RydWN0b3IodGhpcy5jYXN0ZXJDb25zdHJ1Y3RvciwgcmF3QXJyYXlbaV0pO1xuXG4gICAgLy8gQ2hlY2sgaWYgdGhlIGRvY3VtZW50IGhhcyBhIGRpZmZlcmVudCBzY2hlbWEgKHJlIGdoLTM3MDEpXG4gICAgaWYgKHJhd0FycmF5W2ldLiRfXyAhPSBudWxsICYmICEocmF3QXJyYXlbaV0gaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHtcbiAgICAgIGNvbnN0IHNwcmVhZERvYyA9IGhhbmRsZVNwcmVhZERvYyhyYXdBcnJheVtpXSwgdHJ1ZSk7XG4gICAgICBpZiAocmF3QXJyYXlbaV0gIT09IHNwcmVhZERvYykge1xuICAgICAgICByYXdBcnJheVtpXSA9IHNwcmVhZERvYztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJhd0FycmF5W2ldID0gcmF3QXJyYXlbaV0udG9PYmplY3Qoe1xuICAgICAgICAgIHRyYW5zZm9ybTogZmFsc2UsXG4gICAgICAgICAgLy8gU3BlY2lhbCBjYXNlOiBpZiBkaWZmZXJlbnQgbW9kZWwsIGJ1dCBzYW1lIHNjaGVtYSwgYXBwbHkgdmlydHVhbHNcbiAgICAgICAgICAvLyByZTogZ2gtNzg5OFxuICAgICAgICAgIHZpcnR1YWxzOiByYXdBcnJheVtpXS5zY2hlbWEgPT09IENvbnN0cnVjdG9yLnNjaGVtYVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAocmF3QXJyYXlbaV0gaW5zdGFuY2VvZiBTdWJkb2N1bWVudCkge1xuICAgICAgaWYgKHJhd0FycmF5W2ldW2RvY3VtZW50QXJyYXlQYXJlbnRdICE9PSBkb2MpIHtcbiAgICAgICAgaWYgKGluaXQpIHtcbiAgICAgICAgICBjb25zdCBzdWJkb2MgPSBuZXcgQ29uc3RydWN0b3IobnVsbCwgdmFsdWUsIGluaXREb2N1bWVudE9wdGlvbnMsIHNlbGVjdGVkLCBpKTtcbiAgICAgICAgICByYXdBcnJheVtpXSA9IHN1YmRvYy4kaW5pdChyYXdBcnJheVtpXSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY29uc3Qgc3ViZG9jID0gbmV3IENvbnN0cnVjdG9yKHJhd0FycmF5W2ldLCB2YWx1ZSwgdW5kZWZpbmVkLCB1bmRlZmluZWQsIGkpO1xuICAgICAgICAgIHJhd0FycmF5W2ldID0gc3ViZG9jO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICAvLyBNaWdodCBub3QgaGF2ZSB0aGUgY29ycmVjdCBpbmRleCB5ZXQsIHNvIGVuc3VyZSBpdCBkb2VzLlxuICAgICAgaWYgKHJhd0FycmF5W2ldLl9faW5kZXggPT0gbnVsbCkge1xuICAgICAgICByYXdBcnJheVtpXS4kc2V0SW5kZXgoaSk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChyYXdBcnJheVtpXSAhPSBudWxsKSB7XG4gICAgICBpZiAoaW5pdCkge1xuICAgICAgICBpZiAoZG9jKSB7XG4gICAgICAgICAgc2VsZWN0ZWQgfHwgKHNlbGVjdGVkID0gc2NvcGVQYXRocyh0aGlzLCBkb2MuJF9fLnNlbGVjdGVkLCBpbml0KSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgc2VsZWN0ZWQgPSB0cnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgc3ViZG9jID0gbmV3IENvbnN0cnVjdG9yKG51bGwsIHZhbHVlLCBpbml0RG9jdW1lbnRPcHRpb25zLCBzZWxlY3RlZCwgaSk7XG4gICAgICAgIHJhd0FycmF5W2ldID0gc3ViZG9jLiRpbml0KHJhd0FycmF5W2ldKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmIChwcmV2ICYmIHR5cGVvZiBwcmV2LmlkID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgc3ViZG9jID0gcHJldi5pZChyYXdBcnJheVtpXS5faWQpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHByZXYgJiYgc3ViZG9jICYmIHV0aWxzLmRlZXBFcXVhbChzdWJkb2MudG9PYmplY3QoX3RvT2JqZWN0T3B0aW9ucyksIHJhd0FycmF5W2ldKSkge1xuICAgICAgICAgIC8vIGhhbmRsZSByZXNldHRpbmcgZG9jIHdpdGggZXhpc3RpbmcgaWQgYW5kIHNhbWUgZGF0YVxuICAgICAgICAgIHN1YmRvYy5zZXQocmF3QXJyYXlbaV0pO1xuICAgICAgICAgIC8vIGlmIHNldCgpIGlzIGhvb2tlZCBpdCB3aWxsIGhhdmUgbm8gcmV0dXJuIHZhbHVlXG4gICAgICAgICAgLy8gc2VlIGdoLTc0NlxuICAgICAgICAgIHJhd0FycmF5W2ldID0gc3ViZG9jO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICBzdWJkb2MgPSBuZXcgQ29uc3RydWN0b3IocmF3QXJyYXlbaV0sIHZhbHVlLCB1bmRlZmluZWQsXG4gICAgICAgICAgICAgIHVuZGVmaW5lZCwgaSk7XG4gICAgICAgICAgICAvLyBpZiBzZXQoKSBpcyBob29rZWQgaXQgd2lsbCBoYXZlIG5vIHJldHVybiB2YWx1ZVxuICAgICAgICAgICAgLy8gc2VlIGdoLTc0NlxuICAgICAgICAgICAgcmF3QXJyYXlbaV0gPSBzdWJkb2M7XG4gICAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBDYXN0RXJyb3IoJ2VtYmVkZGVkJywgcmF3QXJyYXlbaV0sXG4gICAgICAgICAgICAgIHZhbHVlW2FycmF5UGF0aFN5bWJvbF0sIGVycm9yLCB0aGlzKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gdmFsdWU7XG59O1xuXG4vKiFcbiAqIGlnbm9yZVxuICovXG5cblNjaGVtYURvY3VtZW50QXJyYXkucHJvdG90eXBlLmNsb25lID0gZnVuY3Rpb24oKSB7XG4gIGNvbnN0IG9wdGlvbnMgPSBPYmplY3QuYXNzaWduKHt9LCB0aGlzLm9wdGlvbnMpO1xuICBjb25zdCBzY2hlbWF0eXBlID0gbmV3IHRoaXMuY29uc3RydWN0b3IodGhpcy5wYXRoLCB0aGlzLnNjaGVtYSwgeyAuLi5vcHRpb25zLCBfc2tpcEFwcGx5RGlzY3JpbWluYXRvcnM6IHRydWUgfSwgdGhpcy5zY2hlbWFPcHRpb25zKTtcbiAgc2NoZW1hdHlwZS52YWxpZGF0b3JzID0gdGhpcy52YWxpZGF0b3JzLnNsaWNlKCk7XG4gIGlmICh0aGlzLnJlcXVpcmVkVmFsaWRhdG9yICE9PSB1bmRlZmluZWQpIHtcbiAgICBzY2hlbWF0eXBlLnJlcXVpcmVkVmFsaWRhdG9yID0gdGhpcy5yZXF1aXJlZFZhbGlkYXRvcjtcbiAgfVxuICBzY2hlbWF0eXBlLkNvbnN0cnVjdG9yLmRpc2NyaW1pbmF0b3JzID0gT2JqZWN0LmFzc2lnbih7fSxcbiAgICB0aGlzLkNvbnN0cnVjdG9yLmRpc2NyaW1pbmF0b3JzKTtcbiAgcmV0dXJuIHNjaGVtYXR5cGU7XG59O1xuXG4vKiFcbiAqIGlnbm9yZVxuICovXG5cblNjaGVtYURvY3VtZW50QXJyYXkucHJvdG90eXBlLmFwcGx5R2V0dGVycyA9IGZ1bmN0aW9uKHZhbHVlLCBzY29wZSkge1xuICByZXR1cm4gU2NoZW1hVHlwZS5wcm90b3R5cGUuYXBwbHlHZXR0ZXJzLmNhbGwodGhpcywgdmFsdWUsIHNjb3BlKTtcbn07XG5cbi8qKlxuICogU2NvcGVzIHBhdGhzIHNlbGVjdGVkIGluIGEgcXVlcnkgdG8gdGhpcyBhcnJheS5cbiAqIE5lY2Vzc2FyeSBmb3IgcHJvcGVyIGRlZmF1bHQgYXBwbGljYXRpb24gb2Ygc3ViZG9jdW1lbnQgdmFsdWVzLlxuICpcbiAqIEBwYXJhbSB7RG9jdW1lbnRBcnJheVBhdGh9IGFycmF5IHRoZSBhcnJheSB0byBzY29wZSBgZmllbGRzYCBwYXRoc1xuICogQHBhcmFtIHtPYmplY3R8dW5kZWZpbmVkfSBmaWVsZHMgdGhlIHJvb3QgZmllbGRzIHNlbGVjdGVkIGluIHRoZSBxdWVyeVxuICogQHBhcmFtIHtCb29sZWFufHVuZGVmaW5lZH0gaW5pdCBpZiB3ZSBhcmUgYmVpbmcgY3JlYXRlZCBwYXJ0IG9mIGEgcXVlcnkgcmVzdWx0XG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5mdW5jdGlvbiBzY29wZVBhdGhzKGFycmF5LCBmaWVsZHMsIGluaXQpIHtcbiAgaWYgKCEoaW5pdCAmJiBmaWVsZHMpKSB7XG4gICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgfVxuXG4gIGNvbnN0IHBhdGggPSBhcnJheS5wYXRoICsgJy4nO1xuICBjb25zdCBrZXlzID0gT2JqZWN0LmtleXMoZmllbGRzKTtcbiAgbGV0IGkgPSBrZXlzLmxlbmd0aDtcbiAgY29uc3Qgc2VsZWN0ZWQgPSB7fTtcbiAgbGV0IGhhc0tleXM7XG4gIGxldCBrZXk7XG4gIGxldCBzdWI7XG5cbiAgd2hpbGUgKGktLSkge1xuICAgIGtleSA9IGtleXNbaV07XG4gICAgaWYgKGtleS5zdGFydHNXaXRoKHBhdGgpKSB7XG4gICAgICBzdWIgPSBrZXkuc3Vic3RyaW5nKHBhdGgubGVuZ3RoKTtcbiAgICAgIGlmIChzdWIgPT09ICckJykge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIGlmIChzdWIuc3RhcnRzV2l0aCgnJC4nKSkge1xuICAgICAgICBzdWIgPSBzdWIuc3Vic3RyaW5nKDIpO1xuICAgICAgfVxuICAgICAgaGFzS2V5cyB8fCAoaGFzS2V5cyA9IHRydWUpO1xuICAgICAgc2VsZWN0ZWRbc3ViXSA9IGZpZWxkc1trZXldO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBoYXNLZXlzICYmIHNlbGVjdGVkIHx8IHVuZGVmaW5lZDtcbn1cblxuLyohXG4gKiBpZ25vcmVcbiAqL1xuXG5TY2hlbWFEb2N1bWVudEFycmF5LmRlZmF1bHRPcHRpb25zID0ge307XG5cbi8qKlxuICogU2V0cyBhIGRlZmF1bHQgb3B0aW9uIGZvciBhbGwgRG9jdW1lbnRBcnJheSBpbnN0YW5jZXMuXG4gKlxuICogIyMjIyBFeGFtcGxlOlxuICpcbiAqICAgICAvLyBNYWtlIGFsbCBudW1iZXJzIGhhdmUgb3B0aW9uIGBtaW5gIGVxdWFsIHRvIDAuXG4gKiAgICAgbW9uZ29vc2UuU2NoZW1hLkRvY3VtZW50QXJyYXkuc2V0KCdfaWQnLCBmYWxzZSk7XG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IG9wdGlvbiBUaGUgbmFtZSBvZiB0aGUgb3B0aW9uIHlvdSdkIGxpa2UgdG8gc2V0IChlLmcuIHRyaW0sIGxvd2VyY2FzZSwgZXRjLi4uKVxuICogQHBhcmFtIHtBbnl9IHZhbHVlIFRoZSB2YWx1ZSBvZiB0aGUgb3B0aW9uIHlvdSdkIGxpa2UgdG8gc2V0LlxuICogQHJldHVybiB7dm9pZH1cbiAqIEBmdW5jdGlvbiBzZXRcbiAqIEBzdGF0aWNcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuU2NoZW1hRG9jdW1lbnRBcnJheS5zZXQgPSBTY2hlbWFUeXBlLnNldDtcblxuU2NoZW1hRG9jdW1lbnRBcnJheS5zZXR0ZXJzID0gW107XG5cbi8qKlxuICogQXR0YWNoZXMgYSBnZXR0ZXIgZm9yIGFsbCBEb2N1bWVudEFycmF5UGF0aCBpbnN0YW5jZXNcbiAqXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBnZXR0ZXJcbiAqIEByZXR1cm4ge3RoaXN9XG4gKiBAZnVuY3Rpb24gZ2V0XG4gKiBAc3RhdGljXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cblNjaGVtYURvY3VtZW50QXJyYXkuZ2V0ID0gU2NoZW1hVHlwZS5nZXQ7XG5cbi8qIVxuICogTW9kdWxlIGV4cG9ydHMuXG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSBTY2hlbWFEb2N1bWVudEFycmF5O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/mongoose/lib/schema/documentArray.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/mongoose/lib/schema/documentArrayElement.js":
/*!******************************************************************!*\
  !*** ./node_modules/mongoose/lib/schema/documentArrayElement.js ***!
  \******************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("/*!\n * Module dependencies.\n */\n\n\n\nconst MongooseError = __webpack_require__(/*! ../error/mongooseError */ \"(ssr)/./node_modules/mongoose/lib/error/mongooseError.js\");\nconst SchemaType = __webpack_require__(/*! ../schemaType */ \"(ssr)/./node_modules/mongoose/lib/schemaType.js\");\nconst SchemaSubdocument = __webpack_require__(/*! ./subdocument */ \"(ssr)/./node_modules/mongoose/lib/schema/subdocument.js\");\nconst getConstructor = __webpack_require__(/*! ../helpers/discriminator/getConstructor */ \"(ssr)/./node_modules/mongoose/lib/helpers/discriminator/getConstructor.js\");\n\n/**\n * DocumentArrayElement SchemaType constructor.\n *\n * @param {String} path\n * @param {Object} options\n * @inherits SchemaType\n * @api public\n */\n\nfunction SchemaDocumentArrayElement(path, options) {\n  this.$parentSchemaType = options && options.$parentSchemaType;\n  if (!this.$parentSchemaType) {\n    throw new MongooseError('Cannot create DocumentArrayElement schematype without a parent');\n  }\n  delete options.$parentSchemaType;\n\n  SchemaType.call(this, path, options, 'DocumentArrayElement');\n\n  this.$isMongooseDocumentArrayElement = true;\n}\n\n/**\n * This schema type's name, to defend against minifiers that mangle\n * function names.\n *\n * @api public\n */\nSchemaDocumentArrayElement.schemaName = 'DocumentArrayElement';\n\nSchemaDocumentArrayElement.defaultOptions = {};\n\n/*!\n * Inherits from SchemaType.\n */\nSchemaDocumentArrayElement.prototype = Object.create(SchemaType.prototype);\nSchemaDocumentArrayElement.prototype.constructor = SchemaDocumentArrayElement;\n\n/**\n * Casts `val` for DocumentArrayElement.\n *\n * @param {Object} value to cast\n * @api private\n */\n\nSchemaDocumentArrayElement.prototype.cast = function(...args) {\n  return this.$parentSchemaType.cast(...args)[0];\n};\n\n/**\n * Casts contents for queries.\n *\n * @param {String} $cond\n * @param {any} [val]\n * @api private\n */\n\nSchemaDocumentArrayElement.prototype.doValidate = function(value, fn, scope, options) {\n  const Constructor = getConstructor(this.caster, value);\n\n  if (value && !(value instanceof Constructor)) {\n    value = new Constructor(value, scope, null, null, options && options.index != null ? options.index : null);\n  }\n\n  return SchemaSubdocument.prototype.doValidate.call(this, value, fn, scope, options);\n};\n\n/**\n * Clone the current SchemaType\n *\n * @return {DocumentArrayElement} The cloned instance\n * @api private\n */\n\nSchemaDocumentArrayElement.prototype.clone = function() {\n  this.options.$parentSchemaType = this.$parentSchemaType;\n  const ret = SchemaType.prototype.clone.apply(this, arguments);\n  delete this.options.$parentSchemaType;\n\n  ret.caster = this.caster;\n  ret.schema = this.schema;\n\n  return ret;\n};\n\n/*!\n * Module exports.\n */\n\nmodule.exports = SchemaDocumentArrayElement;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbW9uZ29vc2UvbGliL3NjaGVtYS9kb2N1bWVudEFycmF5RWxlbWVudC5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7O0FBRWE7O0FBRWIsc0JBQXNCLG1CQUFPLENBQUMsd0ZBQXdCO0FBQ3RELG1CQUFtQixtQkFBTyxDQUFDLHNFQUFlO0FBQzFDLDBCQUEwQixtQkFBTyxDQUFDLDhFQUFlO0FBQ2pELHVCQUF1QixtQkFBTyxDQUFDLDBIQUF5Qzs7QUFFeEU7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFdBQVcsS0FBSztBQUNoQjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsWUFBWSxzQkFBc0I7QUFDbEM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vYXBwMS8uL25vZGVfbW9kdWxlcy9tb25nb29zZS9saWIvc2NoZW1hL2RvY3VtZW50QXJyYXlFbGVtZW50LmpzP2RmYzgiXSwic291cmNlc0NvbnRlbnQiOlsiLyohXG4gKiBNb2R1bGUgZGVwZW5kZW5jaWVzLlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxuY29uc3QgTW9uZ29vc2VFcnJvciA9IHJlcXVpcmUoJy4uL2Vycm9yL21vbmdvb3NlRXJyb3InKTtcbmNvbnN0IFNjaGVtYVR5cGUgPSByZXF1aXJlKCcuLi9zY2hlbWFUeXBlJyk7XG5jb25zdCBTY2hlbWFTdWJkb2N1bWVudCA9IHJlcXVpcmUoJy4vc3ViZG9jdW1lbnQnKTtcbmNvbnN0IGdldENvbnN0cnVjdG9yID0gcmVxdWlyZSgnLi4vaGVscGVycy9kaXNjcmltaW5hdG9yL2dldENvbnN0cnVjdG9yJyk7XG5cbi8qKlxuICogRG9jdW1lbnRBcnJheUVsZW1lbnQgU2NoZW1hVHlwZSBjb25zdHJ1Y3Rvci5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gcGF0aFxuICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcbiAqIEBpbmhlcml0cyBTY2hlbWFUeXBlXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmZ1bmN0aW9uIFNjaGVtYURvY3VtZW50QXJyYXlFbGVtZW50KHBhdGgsIG9wdGlvbnMpIHtcbiAgdGhpcy4kcGFyZW50U2NoZW1hVHlwZSA9IG9wdGlvbnMgJiYgb3B0aW9ucy4kcGFyZW50U2NoZW1hVHlwZTtcbiAgaWYgKCF0aGlzLiRwYXJlbnRTY2hlbWFUeXBlKSB7XG4gICAgdGhyb3cgbmV3IE1vbmdvb3NlRXJyb3IoJ0Nhbm5vdCBjcmVhdGUgRG9jdW1lbnRBcnJheUVsZW1lbnQgc2NoZW1hdHlwZSB3aXRob3V0IGEgcGFyZW50Jyk7XG4gIH1cbiAgZGVsZXRlIG9wdGlvbnMuJHBhcmVudFNjaGVtYVR5cGU7XG5cbiAgU2NoZW1hVHlwZS5jYWxsKHRoaXMsIHBhdGgsIG9wdGlvbnMsICdEb2N1bWVudEFycmF5RWxlbWVudCcpO1xuXG4gIHRoaXMuJGlzTW9uZ29vc2VEb2N1bWVudEFycmF5RWxlbWVudCA9IHRydWU7XG59XG5cbi8qKlxuICogVGhpcyBzY2hlbWEgdHlwZSdzIG5hbWUsIHRvIGRlZmVuZCBhZ2FpbnN0IG1pbmlmaWVycyB0aGF0IG1hbmdsZVxuICogZnVuY3Rpb24gbmFtZXMuXG4gKlxuICogQGFwaSBwdWJsaWNcbiAqL1xuU2NoZW1hRG9jdW1lbnRBcnJheUVsZW1lbnQuc2NoZW1hTmFtZSA9ICdEb2N1bWVudEFycmF5RWxlbWVudCc7XG5cblNjaGVtYURvY3VtZW50QXJyYXlFbGVtZW50LmRlZmF1bHRPcHRpb25zID0ge307XG5cbi8qIVxuICogSW5oZXJpdHMgZnJvbSBTY2hlbWFUeXBlLlxuICovXG5TY2hlbWFEb2N1bWVudEFycmF5RWxlbWVudC5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKFNjaGVtYVR5cGUucHJvdG90eXBlKTtcblNjaGVtYURvY3VtZW50QXJyYXlFbGVtZW50LnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFNjaGVtYURvY3VtZW50QXJyYXlFbGVtZW50O1xuXG4vKipcbiAqIENhc3RzIGB2YWxgIGZvciBEb2N1bWVudEFycmF5RWxlbWVudC5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gdmFsdWUgdG8gY2FzdFxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuU2NoZW1hRG9jdW1lbnRBcnJheUVsZW1lbnQucHJvdG90eXBlLmNhc3QgPSBmdW5jdGlvbiguLi5hcmdzKSB7XG4gIHJldHVybiB0aGlzLiRwYXJlbnRTY2hlbWFUeXBlLmNhc3QoLi4uYXJncylbMF07XG59O1xuXG4vKipcbiAqIENhc3RzIGNvbnRlbnRzIGZvciBxdWVyaWVzLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSAkY29uZFxuICogQHBhcmFtIHthbnl9IFt2YWxdXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5TY2hlbWFEb2N1bWVudEFycmF5RWxlbWVudC5wcm90b3R5cGUuZG9WYWxpZGF0ZSA9IGZ1bmN0aW9uKHZhbHVlLCBmbiwgc2NvcGUsIG9wdGlvbnMpIHtcbiAgY29uc3QgQ29uc3RydWN0b3IgPSBnZXRDb25zdHJ1Y3Rvcih0aGlzLmNhc3RlciwgdmFsdWUpO1xuXG4gIGlmICh2YWx1ZSAmJiAhKHZhbHVlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7XG4gICAgdmFsdWUgPSBuZXcgQ29uc3RydWN0b3IodmFsdWUsIHNjb3BlLCBudWxsLCBudWxsLCBvcHRpb25zICYmIG9wdGlvbnMuaW5kZXggIT0gbnVsbCA/IG9wdGlvbnMuaW5kZXggOiBudWxsKTtcbiAgfVxuXG4gIHJldHVybiBTY2hlbWFTdWJkb2N1bWVudC5wcm90b3R5cGUuZG9WYWxpZGF0ZS5jYWxsKHRoaXMsIHZhbHVlLCBmbiwgc2NvcGUsIG9wdGlvbnMpO1xufTtcblxuLyoqXG4gKiBDbG9uZSB0aGUgY3VycmVudCBTY2hlbWFUeXBlXG4gKlxuICogQHJldHVybiB7RG9jdW1lbnRBcnJheUVsZW1lbnR9IFRoZSBjbG9uZWQgaW5zdGFuY2VcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cblNjaGVtYURvY3VtZW50QXJyYXlFbGVtZW50LnByb3RvdHlwZS5jbG9uZSA9IGZ1bmN0aW9uKCkge1xuICB0aGlzLm9wdGlvbnMuJHBhcmVudFNjaGVtYVR5cGUgPSB0aGlzLiRwYXJlbnRTY2hlbWFUeXBlO1xuICBjb25zdCByZXQgPSBTY2hlbWFUeXBlLnByb3RvdHlwZS5jbG9uZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICBkZWxldGUgdGhpcy5vcHRpb25zLiRwYXJlbnRTY2hlbWFUeXBlO1xuXG4gIHJldC5jYXN0ZXIgPSB0aGlzLmNhc3RlcjtcbiAgcmV0LnNjaGVtYSA9IHRoaXMuc2NoZW1hO1xuXG4gIHJldHVybiByZXQ7XG59O1xuXG4vKiFcbiAqIE1vZHVsZSBleHBvcnRzLlxuICovXG5cbm1vZHVsZS5leHBvcnRzID0gU2NoZW1hRG9jdW1lbnRBcnJheUVsZW1lbnQ7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/mongoose/lib/schema/documentArrayElement.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/mongoose/lib/schema/index.js":
/*!***************************************************!*\
  !*** ./node_modules/mongoose/lib/schema/index.js ***!
  \***************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n/*!\n * Module exports.\n */\n\n\n\nexports.Array = __webpack_require__(/*! ./array */ \"(ssr)/./node_modules/mongoose/lib/schema/array.js\");\nexports.BigInt = __webpack_require__(/*! ./bigint */ \"(ssr)/./node_modules/mongoose/lib/schema/bigint.js\");\nexports.Boolean = __webpack_require__(/*! ./boolean */ \"(ssr)/./node_modules/mongoose/lib/schema/boolean.js\");\nexports.Buffer = __webpack_require__(/*! ./buffer */ \"(ssr)/./node_modules/mongoose/lib/schema/buffer.js\");\nexports.Date = __webpack_require__(/*! ./date */ \"(ssr)/./node_modules/mongoose/lib/schema/date.js\");\nexports.Decimal128 = exports.Decimal = __webpack_require__(/*! ./decimal128 */ \"(ssr)/./node_modules/mongoose/lib/schema/decimal128.js\");\nexports.DocumentArray = __webpack_require__(/*! ./documentArray */ \"(ssr)/./node_modules/mongoose/lib/schema/documentArray.js\");\nexports.Map = __webpack_require__(/*! ./map */ \"(ssr)/./node_modules/mongoose/lib/schema/map.js\");\nexports.Mixed = __webpack_require__(/*! ./mixed */ \"(ssr)/./node_modules/mongoose/lib/schema/mixed.js\");\nexports.Number = __webpack_require__(/*! ./number */ \"(ssr)/./node_modules/mongoose/lib/schema/number.js\");\nexports.ObjectId = __webpack_require__(/*! ./objectId */ \"(ssr)/./node_modules/mongoose/lib/schema/objectId.js\");\nexports.String = __webpack_require__(/*! ./string */ \"(ssr)/./node_modules/mongoose/lib/schema/string.js\");\nexports.Subdocument = __webpack_require__(/*! ./subdocument */ \"(ssr)/./node_modules/mongoose/lib/schema/subdocument.js\");\nexports.UUID = __webpack_require__(/*! ./uuid */ \"(ssr)/./node_modules/mongoose/lib/schema/uuid.js\");\n\n// alias\n\nexports.Oid = exports.ObjectId;\nexports.Object = exports.Mixed;\nexports.Bool = exports.Boolean;\nexports.ObjectID = exports.ObjectId;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbW9uZ29vc2UvbGliL3NjaGVtYS9pbmRleC5qcyIsIm1hcHBpbmdzIjoiO0FBQ0E7QUFDQTtBQUNBOztBQUVhOztBQUViLHVHQUFrQztBQUNsQywwR0FBb0M7QUFDcEMsNkdBQXNDO0FBQ3RDLDBHQUFvQztBQUNwQyxvR0FBZ0M7QUFDaEMsa0JBQWtCLEdBQUcsbUhBQXlDO0FBQzlELCtIQUFrRDtBQUNsRCxpR0FBOEI7QUFDOUIsdUdBQWtDO0FBQ2xDLDBHQUFvQztBQUNwQyxnSEFBd0M7QUFDeEMsMEdBQW9DO0FBQ3BDLHlIQUE4QztBQUM5QyxvR0FBZ0M7O0FBRWhDOztBQUVBLFdBQVc7QUFDWCxjQUFjO0FBQ2QsWUFBWTtBQUNaLGdCQUFnQiIsInNvdXJjZXMiOlsid2VicGFjazovL2FwcDEvLi9ub2RlX21vZHVsZXMvbW9uZ29vc2UvbGliL3NjaGVtYS9pbmRleC5qcz85ZTBiIl0sInNvdXJjZXNDb250ZW50IjpbIlxuLyohXG4gKiBNb2R1bGUgZXhwb3J0cy5cbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbmV4cG9ydHMuQXJyYXkgPSByZXF1aXJlKCcuL2FycmF5Jyk7XG5leHBvcnRzLkJpZ0ludCA9IHJlcXVpcmUoJy4vYmlnaW50Jyk7XG5leHBvcnRzLkJvb2xlYW4gPSByZXF1aXJlKCcuL2Jvb2xlYW4nKTtcbmV4cG9ydHMuQnVmZmVyID0gcmVxdWlyZSgnLi9idWZmZXInKTtcbmV4cG9ydHMuRGF0ZSA9IHJlcXVpcmUoJy4vZGF0ZScpO1xuZXhwb3J0cy5EZWNpbWFsMTI4ID0gZXhwb3J0cy5EZWNpbWFsID0gcmVxdWlyZSgnLi9kZWNpbWFsMTI4Jyk7XG5leHBvcnRzLkRvY3VtZW50QXJyYXkgPSByZXF1aXJlKCcuL2RvY3VtZW50QXJyYXknKTtcbmV4cG9ydHMuTWFwID0gcmVxdWlyZSgnLi9tYXAnKTtcbmV4cG9ydHMuTWl4ZWQgPSByZXF1aXJlKCcuL21peGVkJyk7XG5leHBvcnRzLk51bWJlciA9IHJlcXVpcmUoJy4vbnVtYmVyJyk7XG5leHBvcnRzLk9iamVjdElkID0gcmVxdWlyZSgnLi9vYmplY3RJZCcpO1xuZXhwb3J0cy5TdHJpbmcgPSByZXF1aXJlKCcuL3N0cmluZycpO1xuZXhwb3J0cy5TdWJkb2N1bWVudCA9IHJlcXVpcmUoJy4vc3ViZG9jdW1lbnQnKTtcbmV4cG9ydHMuVVVJRCA9IHJlcXVpcmUoJy4vdXVpZCcpO1xuXG4vLyBhbGlhc1xuXG5leHBvcnRzLk9pZCA9IGV4cG9ydHMuT2JqZWN0SWQ7XG5leHBvcnRzLk9iamVjdCA9IGV4cG9ydHMuTWl4ZWQ7XG5leHBvcnRzLkJvb2wgPSBleHBvcnRzLkJvb2xlYW47XG5leHBvcnRzLk9iamVjdElEID0gZXhwb3J0cy5PYmplY3RJZDtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/mongoose/lib/schema/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/mongoose/lib/schema/map.js":
/*!*************************************************!*\
  !*** ./node_modules/mongoose/lib/schema/map.js ***!
  \*************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\n\n/*!\n * ignore\n */\n\nconst MongooseMap = __webpack_require__(/*! ../types/map */ \"(ssr)/./node_modules/mongoose/lib/types/map.js\");\nconst SchemaMapOptions = __webpack_require__(/*! ../options/schemaMapOptions */ \"(ssr)/./node_modules/mongoose/lib/options/schemaMapOptions.js\");\nconst SchemaType = __webpack_require__(/*! ../schemaType */ \"(ssr)/./node_modules/mongoose/lib/schemaType.js\");\n/*!\n * ignore\n */\n\nclass SchemaMap extends SchemaType {\n  constructor(key, options) {\n    super(key, options, 'Map');\n    this.$isSchemaMap = true;\n  }\n\n  set(option, value) {\n    return SchemaType.set(option, value);\n  }\n\n  cast(val, doc, init) {\n    if (val instanceof MongooseMap) {\n      return val;\n    }\n\n    const path = this.path;\n\n    if (init) {\n      const map = new MongooseMap({}, path, doc, this.$__schemaType);\n\n      if (val instanceof global.Map) {\n        for (const key of val.keys()) {\n          let _val = val.get(key);\n          if (_val == null) {\n            _val = map.$__schemaType._castNullish(_val);\n          } else {\n            _val = map.$__schemaType.cast(_val, doc, true, null, { path: path + '.' + key });\n          }\n          map.$init(key, _val);\n        }\n      } else {\n        for (const key of Object.keys(val)) {\n          let _val = val[key];\n          if (_val == null) {\n            _val = map.$__schemaType._castNullish(_val);\n          } else {\n            _val = map.$__schemaType.cast(_val, doc, true, null, { path: path + '.' + key });\n          }\n          map.$init(key, _val);\n        }\n      }\n\n      return map;\n    }\n\n    return new MongooseMap(val, path, doc, this.$__schemaType);\n  }\n\n  clone() {\n    const schematype = super.clone();\n\n    if (this.$__schemaType != null) {\n      schematype.$__schemaType = this.$__schemaType.clone();\n    }\n    return schematype;\n  }\n}\n\n/**\n * This schema type's name, to defend against minifiers that mangle\n * function names.\n *\n * @api public\n */\nSchemaMap.schemaName = 'Map';\n\nSchemaMap.prototype.OptionsConstructor = SchemaMapOptions;\n\nSchemaMap.defaultOptions = {};\n\nmodule.exports = SchemaMap;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbW9uZ29vc2UvbGliL3NjaGVtYS9tYXAuanMiLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWI7QUFDQTtBQUNBOztBQUVBLG9CQUFvQixtQkFBTyxDQUFDLG9FQUFjO0FBQzFDLHlCQUF5QixtQkFBTyxDQUFDLGtHQUE2QjtBQUM5RCxtQkFBbUIsbUJBQU8sQ0FBQyxzRUFBZTtBQUMxQztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSxvQ0FBb0M7O0FBRXBDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1osbUVBQW1FLHdCQUF3QjtBQUMzRjtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1osbUVBQW1FLHdCQUF3QjtBQUMzRjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUEiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9hcHAxLy4vbm9kZV9tb2R1bGVzL21vbmdvb3NlL2xpYi9zY2hlbWEvbWFwLmpzP2UyMmIiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG4vKiFcbiAqIGlnbm9yZVxuICovXG5cbmNvbnN0IE1vbmdvb3NlTWFwID0gcmVxdWlyZSgnLi4vdHlwZXMvbWFwJyk7XG5jb25zdCBTY2hlbWFNYXBPcHRpb25zID0gcmVxdWlyZSgnLi4vb3B0aW9ucy9zY2hlbWFNYXBPcHRpb25zJyk7XG5jb25zdCBTY2hlbWFUeXBlID0gcmVxdWlyZSgnLi4vc2NoZW1hVHlwZScpO1xuLyohXG4gKiBpZ25vcmVcbiAqL1xuXG5jbGFzcyBTY2hlbWFNYXAgZXh0ZW5kcyBTY2hlbWFUeXBlIHtcbiAgY29uc3RydWN0b3Ioa2V5LCBvcHRpb25zKSB7XG4gICAgc3VwZXIoa2V5LCBvcHRpb25zLCAnTWFwJyk7XG4gICAgdGhpcy4kaXNTY2hlbWFNYXAgPSB0cnVlO1xuICB9XG5cbiAgc2V0KG9wdGlvbiwgdmFsdWUpIHtcbiAgICByZXR1cm4gU2NoZW1hVHlwZS5zZXQob3B0aW9uLCB2YWx1ZSk7XG4gIH1cblxuICBjYXN0KHZhbCwgZG9jLCBpbml0KSB7XG4gICAgaWYgKHZhbCBpbnN0YW5jZW9mIE1vbmdvb3NlTWFwKSB7XG4gICAgICByZXR1cm4gdmFsO1xuICAgIH1cblxuICAgIGNvbnN0IHBhdGggPSB0aGlzLnBhdGg7XG5cbiAgICBpZiAoaW5pdCkge1xuICAgICAgY29uc3QgbWFwID0gbmV3IE1vbmdvb3NlTWFwKHt9LCBwYXRoLCBkb2MsIHRoaXMuJF9fc2NoZW1hVHlwZSk7XG5cbiAgICAgIGlmICh2YWwgaW5zdGFuY2VvZiBnbG9iYWwuTWFwKSB7XG4gICAgICAgIGZvciAoY29uc3Qga2V5IG9mIHZhbC5rZXlzKCkpIHtcbiAgICAgICAgICBsZXQgX3ZhbCA9IHZhbC5nZXQoa2V5KTtcbiAgICAgICAgICBpZiAoX3ZhbCA9PSBudWxsKSB7XG4gICAgICAgICAgICBfdmFsID0gbWFwLiRfX3NjaGVtYVR5cGUuX2Nhc3ROdWxsaXNoKF92YWwpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBfdmFsID0gbWFwLiRfX3NjaGVtYVR5cGUuY2FzdChfdmFsLCBkb2MsIHRydWUsIG51bGwsIHsgcGF0aDogcGF0aCArICcuJyArIGtleSB9KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgbWFwLiRpbml0KGtleSwgX3ZhbCk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGZvciAoY29uc3Qga2V5IG9mIE9iamVjdC5rZXlzKHZhbCkpIHtcbiAgICAgICAgICBsZXQgX3ZhbCA9IHZhbFtrZXldO1xuICAgICAgICAgIGlmIChfdmFsID09IG51bGwpIHtcbiAgICAgICAgICAgIF92YWwgPSBtYXAuJF9fc2NoZW1hVHlwZS5fY2FzdE51bGxpc2goX3ZhbCk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIF92YWwgPSBtYXAuJF9fc2NoZW1hVHlwZS5jYXN0KF92YWwsIGRvYywgdHJ1ZSwgbnVsbCwgeyBwYXRoOiBwYXRoICsgJy4nICsga2V5IH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgICBtYXAuJGluaXQoa2V5LCBfdmFsKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gbWFwO1xuICAgIH1cblxuICAgIHJldHVybiBuZXcgTW9uZ29vc2VNYXAodmFsLCBwYXRoLCBkb2MsIHRoaXMuJF9fc2NoZW1hVHlwZSk7XG4gIH1cblxuICBjbG9uZSgpIHtcbiAgICBjb25zdCBzY2hlbWF0eXBlID0gc3VwZXIuY2xvbmUoKTtcblxuICAgIGlmICh0aGlzLiRfX3NjaGVtYVR5cGUgIT0gbnVsbCkge1xuICAgICAgc2NoZW1hdHlwZS4kX19zY2hlbWFUeXBlID0gdGhpcy4kX19zY2hlbWFUeXBlLmNsb25lKCk7XG4gICAgfVxuICAgIHJldHVybiBzY2hlbWF0eXBlO1xuICB9XG59XG5cbi8qKlxuICogVGhpcyBzY2hlbWEgdHlwZSdzIG5hbWUsIHRvIGRlZmVuZCBhZ2FpbnN0IG1pbmlmaWVycyB0aGF0IG1hbmdsZVxuICogZnVuY3Rpb24gbmFtZXMuXG4gKlxuICogQGFwaSBwdWJsaWNcbiAqL1xuU2NoZW1hTWFwLnNjaGVtYU5hbWUgPSAnTWFwJztcblxuU2NoZW1hTWFwLnByb3RvdHlwZS5PcHRpb25zQ29uc3RydWN0b3IgPSBTY2hlbWFNYXBPcHRpb25zO1xuXG5TY2hlbWFNYXAuZGVmYXVsdE9wdGlvbnMgPSB7fTtcblxubW9kdWxlLmV4cG9ydHMgPSBTY2hlbWFNYXA7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/mongoose/lib/schema/map.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/mongoose/lib/schema/mixed.js":
/*!***************************************************!*\
  !*** ./node_modules/mongoose/lib/schema/mixed.js ***!
  \***************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("/*!\n * Module dependencies.\n */\n\n\n\nconst SchemaType = __webpack_require__(/*! ../schemaType */ \"(ssr)/./node_modules/mongoose/lib/schemaType.js\");\nconst symbols = __webpack_require__(/*! ./symbols */ \"(ssr)/./node_modules/mongoose/lib/schema/symbols.js\");\nconst isObject = __webpack_require__(/*! ../helpers/isObject */ \"(ssr)/./node_modules/mongoose/lib/helpers/isObject.js\");\nconst utils = __webpack_require__(/*! ../utils */ \"(ssr)/./node_modules/mongoose/lib/utils.js\");\n\n/**\n * Mixed SchemaType constructor.\n *\n * @param {String} path\n * @param {Object} options\n * @inherits SchemaType\n * @api public\n */\n\nfunction SchemaMixed(path, options) {\n  if (options && options.default) {\n    const def = options.default;\n    if (Array.isArray(def) && def.length === 0) {\n      // make sure empty array defaults are handled\n      options.default = Array;\n    } else if (!options.shared && isObject(def) && Object.keys(def).length === 0) {\n      // prevent odd \"shared\" objects between documents\n      options.default = function() {\n        return {};\n      };\n    }\n  }\n\n  SchemaType.call(this, path, options, 'Mixed');\n\n  this[symbols.schemaMixedSymbol] = true;\n}\n\n/**\n * This schema type's name, to defend against minifiers that mangle\n * function names.\n *\n * @api public\n */\nSchemaMixed.schemaName = 'Mixed';\n\nSchemaMixed.defaultOptions = {};\n\n/*!\n * Inherits from SchemaType.\n */\nSchemaMixed.prototype = Object.create(SchemaType.prototype);\nSchemaMixed.prototype.constructor = SchemaMixed;\n\n/**\n * Attaches a getter for all Mixed paths.\n *\n * #### Example:\n *\n *     // Hide the 'hidden' path\n *     mongoose.Schema.Mixed.get(v => Object.assign({}, v, { hidden: null }));\n *\n *     const Model = mongoose.model('Test', new Schema({ test: {} }));\n *     new Model({ test: { hidden: 'Secret!' } }).test.hidden; // null\n *\n * @param {Function} getter\n * @return {this}\n * @function get\n * @static\n * @api public\n */\n\nSchemaMixed.get = SchemaType.get;\n\n/**\n * Sets a default option for all Mixed instances.\n *\n * #### Example:\n *\n *     // Make all mixed instances have `required` of true by default.\n *     mongoose.Schema.Mixed.set('required', true);\n *\n *     const User = mongoose.model('User', new Schema({ test: mongoose.Mixed }));\n *     new User({ }).validateSync().errors.test.message; // Path `test` is required.\n *\n * @param {String} option The option you'd like to set the value for\n * @param {Any} value value for option\n * @return {undefined}\n * @function set\n * @static\n * @api public\n */\n\nSchemaMixed.set = SchemaType.set;\n\nSchemaMixed.setters = [];\n\n/**\n * Casts `val` for Mixed.\n *\n * _this is a no-op_\n *\n * @param {Object} value to cast\n * @api private\n */\n\nSchemaMixed.prototype.cast = function(val) {\n  if (val instanceof Error) {\n    return utils.errorToPOJO(val);\n  }\n  return val;\n};\n\n/**\n * Casts contents for queries.\n *\n * @param {String} $cond\n * @param {any} [val]\n * @api private\n */\n\nSchemaMixed.prototype.castForQuery = function($cond, val) {\n  return val;\n};\n\n/*!\n * Module exports.\n */\n\nmodule.exports = SchemaMixed;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbW9uZ29vc2UvbGliL3NjaGVtYS9taXhlZC5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7O0FBRWE7O0FBRWIsbUJBQW1CLG1CQUFPLENBQUMsc0VBQWU7QUFDMUMsZ0JBQWdCLG1CQUFPLENBQUMsc0VBQVc7QUFDbkMsaUJBQWlCLG1CQUFPLENBQUMsa0ZBQXFCO0FBQzlDLGNBQWMsbUJBQU8sQ0FBQyw0REFBVTs7QUFFaEM7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0RBQXNELE9BQU8sY0FBYztBQUMzRTtBQUNBLHlEQUF5RCxVQUFVO0FBQ25FLG1CQUFtQixRQUFRLHFCQUFxQixlQUFlO0FBQy9EO0FBQ0EsV0FBVyxVQUFVO0FBQ3JCLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0RBQXdELHNCQUFzQjtBQUM5RSxtQkFBbUIsc0NBQXNDO0FBQ3pEO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFdBQVcsS0FBSztBQUNoQixZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsV0FBVyxLQUFLO0FBQ2hCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSIsInNvdXJjZXMiOlsid2VicGFjazovL2FwcDEvLi9ub2RlX21vZHVsZXMvbW9uZ29vc2UvbGliL3NjaGVtYS9taXhlZC5qcz9iYjQ0Il0sInNvdXJjZXNDb250ZW50IjpbIi8qIVxuICogTW9kdWxlIGRlcGVuZGVuY2llcy5cbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbmNvbnN0IFNjaGVtYVR5cGUgPSByZXF1aXJlKCcuLi9zY2hlbWFUeXBlJyk7XG5jb25zdCBzeW1ib2xzID0gcmVxdWlyZSgnLi9zeW1ib2xzJyk7XG5jb25zdCBpc09iamVjdCA9IHJlcXVpcmUoJy4uL2hlbHBlcnMvaXNPYmplY3QnKTtcbmNvbnN0IHV0aWxzID0gcmVxdWlyZSgnLi4vdXRpbHMnKTtcblxuLyoqXG4gKiBNaXhlZCBTY2hlbWFUeXBlIGNvbnN0cnVjdG9yLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBwYXRoXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xuICogQGluaGVyaXRzIFNjaGVtYVR5cGVcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZnVuY3Rpb24gU2NoZW1hTWl4ZWQocGF0aCwgb3B0aW9ucykge1xuICBpZiAob3B0aW9ucyAmJiBvcHRpb25zLmRlZmF1bHQpIHtcbiAgICBjb25zdCBkZWYgPSBvcHRpb25zLmRlZmF1bHQ7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkoZGVmKSAmJiBkZWYubGVuZ3RoID09PSAwKSB7XG4gICAgICAvLyBtYWtlIHN1cmUgZW1wdHkgYXJyYXkgZGVmYXVsdHMgYXJlIGhhbmRsZWRcbiAgICAgIG9wdGlvbnMuZGVmYXVsdCA9IEFycmF5O1xuICAgIH0gZWxzZSBpZiAoIW9wdGlvbnMuc2hhcmVkICYmIGlzT2JqZWN0KGRlZikgJiYgT2JqZWN0LmtleXMoZGVmKS5sZW5ndGggPT09IDApIHtcbiAgICAgIC8vIHByZXZlbnQgb2RkIFwic2hhcmVkXCIgb2JqZWN0cyBiZXR3ZWVuIGRvY3VtZW50c1xuICAgICAgb3B0aW9ucy5kZWZhdWx0ID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB7fTtcbiAgICAgIH07XG4gICAgfVxuICB9XG5cbiAgU2NoZW1hVHlwZS5jYWxsKHRoaXMsIHBhdGgsIG9wdGlvbnMsICdNaXhlZCcpO1xuXG4gIHRoaXNbc3ltYm9scy5zY2hlbWFNaXhlZFN5bWJvbF0gPSB0cnVlO1xufVxuXG4vKipcbiAqIFRoaXMgc2NoZW1hIHR5cGUncyBuYW1lLCB0byBkZWZlbmQgYWdhaW5zdCBtaW5pZmllcnMgdGhhdCBtYW5nbGVcbiAqIGZ1bmN0aW9uIG5hbWVzLlxuICpcbiAqIEBhcGkgcHVibGljXG4gKi9cblNjaGVtYU1peGVkLnNjaGVtYU5hbWUgPSAnTWl4ZWQnO1xuXG5TY2hlbWFNaXhlZC5kZWZhdWx0T3B0aW9ucyA9IHt9O1xuXG4vKiFcbiAqIEluaGVyaXRzIGZyb20gU2NoZW1hVHlwZS5cbiAqL1xuU2NoZW1hTWl4ZWQucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShTY2hlbWFUeXBlLnByb3RvdHlwZSk7XG5TY2hlbWFNaXhlZC5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBTY2hlbWFNaXhlZDtcblxuLyoqXG4gKiBBdHRhY2hlcyBhIGdldHRlciBmb3IgYWxsIE1peGVkIHBhdGhzLlxuICpcbiAqICMjIyMgRXhhbXBsZTpcbiAqXG4gKiAgICAgLy8gSGlkZSB0aGUgJ2hpZGRlbicgcGF0aFxuICogICAgIG1vbmdvb3NlLlNjaGVtYS5NaXhlZC5nZXQodiA9PiBPYmplY3QuYXNzaWduKHt9LCB2LCB7IGhpZGRlbjogbnVsbCB9KSk7XG4gKlxuICogICAgIGNvbnN0IE1vZGVsID0gbW9uZ29vc2UubW9kZWwoJ1Rlc3QnLCBuZXcgU2NoZW1hKHsgdGVzdDoge30gfSkpO1xuICogICAgIG5ldyBNb2RlbCh7IHRlc3Q6IHsgaGlkZGVuOiAnU2VjcmV0IScgfSB9KS50ZXN0LmhpZGRlbjsgLy8gbnVsbFxuICpcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGdldHRlclxuICogQHJldHVybiB7dGhpc31cbiAqIEBmdW5jdGlvbiBnZXRcbiAqIEBzdGF0aWNcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuU2NoZW1hTWl4ZWQuZ2V0ID0gU2NoZW1hVHlwZS5nZXQ7XG5cbi8qKlxuICogU2V0cyBhIGRlZmF1bHQgb3B0aW9uIGZvciBhbGwgTWl4ZWQgaW5zdGFuY2VzLlxuICpcbiAqICMjIyMgRXhhbXBsZTpcbiAqXG4gKiAgICAgLy8gTWFrZSBhbGwgbWl4ZWQgaW5zdGFuY2VzIGhhdmUgYHJlcXVpcmVkYCBvZiB0cnVlIGJ5IGRlZmF1bHQuXG4gKiAgICAgbW9uZ29vc2UuU2NoZW1hLk1peGVkLnNldCgncmVxdWlyZWQnLCB0cnVlKTtcbiAqXG4gKiAgICAgY29uc3QgVXNlciA9IG1vbmdvb3NlLm1vZGVsKCdVc2VyJywgbmV3IFNjaGVtYSh7IHRlc3Q6IG1vbmdvb3NlLk1peGVkIH0pKTtcbiAqICAgICBuZXcgVXNlcih7IH0pLnZhbGlkYXRlU3luYygpLmVycm9ycy50ZXN0Lm1lc3NhZ2U7IC8vIFBhdGggYHRlc3RgIGlzIHJlcXVpcmVkLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBvcHRpb24gVGhlIG9wdGlvbiB5b3UnZCBsaWtlIHRvIHNldCB0aGUgdmFsdWUgZm9yXG4gKiBAcGFyYW0ge0FueX0gdmFsdWUgdmFsdWUgZm9yIG9wdGlvblxuICogQHJldHVybiB7dW5kZWZpbmVkfVxuICogQGZ1bmN0aW9uIHNldFxuICogQHN0YXRpY1xuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5TY2hlbWFNaXhlZC5zZXQgPSBTY2hlbWFUeXBlLnNldDtcblxuU2NoZW1hTWl4ZWQuc2V0dGVycyA9IFtdO1xuXG4vKipcbiAqIENhc3RzIGB2YWxgIGZvciBNaXhlZC5cbiAqXG4gKiBfdGhpcyBpcyBhIG5vLW9wX1xuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSB2YWx1ZSB0byBjYXN0XG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5TY2hlbWFNaXhlZC5wcm90b3R5cGUuY2FzdCA9IGZ1bmN0aW9uKHZhbCkge1xuICBpZiAodmFsIGluc3RhbmNlb2YgRXJyb3IpIHtcbiAgICByZXR1cm4gdXRpbHMuZXJyb3JUb1BPSk8odmFsKTtcbiAgfVxuICByZXR1cm4gdmFsO1xufTtcblxuLyoqXG4gKiBDYXN0cyBjb250ZW50cyBmb3IgcXVlcmllcy5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gJGNvbmRcbiAqIEBwYXJhbSB7YW55fSBbdmFsXVxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuU2NoZW1hTWl4ZWQucHJvdG90eXBlLmNhc3RGb3JRdWVyeSA9IGZ1bmN0aW9uKCRjb25kLCB2YWwpIHtcbiAgcmV0dXJuIHZhbDtcbn07XG5cbi8qIVxuICogTW9kdWxlIGV4cG9ydHMuXG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSBTY2hlbWFNaXhlZDtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/mongoose/lib/schema/mixed.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/mongoose/lib/schema/number.js":
/*!****************************************************!*\
  !*** ./node_modules/mongoose/lib/schema/number.js ***!
  \****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\n\n/*!\n * Module requirements.\n */\n\nconst MongooseError = __webpack_require__(/*! ../error/index */ \"(ssr)/./node_modules/mongoose/lib/error/index.js\");\nconst SchemaNumberOptions = __webpack_require__(/*! ../options/schemaNumberOptions */ \"(ssr)/./node_modules/mongoose/lib/options/schemaNumberOptions.js\");\nconst SchemaType = __webpack_require__(/*! ../schemaType */ \"(ssr)/./node_modules/mongoose/lib/schemaType.js\");\nconst castNumber = __webpack_require__(/*! ../cast/number */ \"(ssr)/./node_modules/mongoose/lib/cast/number.js\");\nconst handleBitwiseOperator = __webpack_require__(/*! ./operators/bitwise */ \"(ssr)/./node_modules/mongoose/lib/schema/operators/bitwise.js\");\nconst utils = __webpack_require__(/*! ../utils */ \"(ssr)/./node_modules/mongoose/lib/utils.js\");\n\nconst CastError = SchemaType.CastError;\n\n/**\n * Number SchemaType constructor.\n *\n * @param {String} key\n * @param {Object} options\n * @inherits SchemaType\n * @api public\n */\n\nfunction SchemaNumber(key, options) {\n  SchemaType.call(this, key, options, 'Number');\n}\n\n/**\n * Attaches a getter for all Number instances.\n *\n * #### Example:\n *\n *     // Make all numbers round down\n *     mongoose.Number.get(function(v) { return Math.floor(v); });\n *\n *     const Model = mongoose.model('Test', new Schema({ test: Number }));\n *     new Model({ test: 3.14 }).test; // 3\n *\n * @param {Function} getter\n * @return {this}\n * @function get\n * @static\n * @api public\n */\n\nSchemaNumber.get = SchemaType.get;\n\n/**\n * Sets a default option for all Number instances.\n *\n * #### Example:\n *\n *     // Make all numbers have option `min` equal to 0.\n *     mongoose.Schema.Number.set('min', 0);\n *\n *     const Order = mongoose.model('Order', new Schema({ amount: Number }));\n *     new Order({ amount: -10 }).validateSync().errors.amount.message; // Path `amount` must be larger than 0.\n *\n * @param {String} option The option you'd like to set the value for\n * @param {Any} value value for option\n * @return {undefined}\n * @function set\n * @static\n * @api public\n */\n\nSchemaNumber.set = SchemaType.set;\n\nSchemaNumber.setters = [];\n\n/*!\n * ignore\n */\n\nSchemaNumber._cast = castNumber;\n\n/**\n * Get/set the function used to cast arbitrary values to numbers.\n *\n * #### Example:\n *\n *     // Make Mongoose cast empty strings '' to 0 for paths declared as numbers\n *     const original = mongoose.Number.cast();\n *     mongoose.Number.cast(v => {\n *       if (v === '') { return 0; }\n *       return original(v);\n *     });\n *\n *     // Or disable casting entirely\n *     mongoose.Number.cast(false);\n *\n * @param {Function} caster\n * @return {Function}\n * @function get\n * @static\n * @api public\n */\n\nSchemaNumber.cast = function cast(caster) {\n  if (arguments.length === 0) {\n    return this._cast;\n  }\n  if (caster === false) {\n    caster = this._defaultCaster;\n  }\n  this._cast = caster;\n\n  return this._cast;\n};\n\n/*!\n * ignore\n */\n\nSchemaNumber._defaultCaster = v => {\n  if (typeof v !== 'number') {\n    throw new Error();\n  }\n  return v;\n};\n\n/**\n * This schema type's name, to defend against minifiers that mangle\n * function names.\n *\n * @api public\n */\nSchemaNumber.schemaName = 'Number';\n\nSchemaNumber.defaultOptions = {};\n\n/*!\n * Inherits from SchemaType.\n */\nSchemaNumber.prototype = Object.create(SchemaType.prototype);\nSchemaNumber.prototype.constructor = SchemaNumber;\nSchemaNumber.prototype.OptionsConstructor = SchemaNumberOptions;\n\n/*!\n * ignore\n */\n\nSchemaNumber._checkRequired = v => typeof v === 'number' || v instanceof Number;\n\n/**\n * Override the function the required validator uses to check whether a string\n * passes the `required` check.\n *\n * @param {Function} fn\n * @return {Function}\n * @function checkRequired\n * @static\n * @api public\n */\n\nSchemaNumber.checkRequired = SchemaType.checkRequired;\n\n/**\n * Check if the given value satisfies a required validator.\n *\n * @param {Any} value\n * @param {Document} doc\n * @return {Boolean}\n * @api public\n */\n\nSchemaNumber.prototype.checkRequired = function checkRequired(value, doc) {\n  if (typeof value === 'object' && SchemaType._isRef(this, value, doc, true)) {\n    return value != null;\n  }\n\n  // `require('util').inherits()` does **not** copy static properties, and\n  // plugins like mongoose-float use `inherits()` for pre-ES6.\n  const _checkRequired = typeof this.constructor.checkRequired === 'function' ?\n    this.constructor.checkRequired() :\n    SchemaNumber.checkRequired();\n\n  return _checkRequired(value);\n};\n\n/**\n * Sets a minimum number validator.\n *\n * #### Example:\n *\n *     const s = new Schema({ n: { type: Number, min: 10 })\n *     const M = db.model('M', s)\n *     const m = new M({ n: 9 })\n *     m.save(function (err) {\n *       console.error(err) // validator error\n *       m.n = 10;\n *       m.save() // success\n *     })\n *\n *     // custom error messages\n *     // We can also use the special {MIN} token which will be replaced with the invalid value\n *     const min = [10, 'The value of path `{PATH}` ({VALUE}) is beneath the limit ({MIN}).'];\n *     const schema = new Schema({ n: { type: Number, min: min })\n *     const M = mongoose.model('Measurement', schema);\n *     const s= new M({ n: 4 });\n *     s.validate(function (err) {\n *       console.log(String(err)) // ValidationError: The value of path `n` (4) is beneath the limit (10).\n *     })\n *\n * @param {Number} value minimum number\n * @param {String} [message] optional custom error message\n * @return {SchemaType} this\n * @see Customized Error Messages https://mongoosejs.com/docs/api/error.html#Error.messages\n * @api public\n */\n\nSchemaNumber.prototype.min = function(value, message) {\n  if (this.minValidator) {\n    this.validators = this.validators.filter(function(v) {\n      return v.validator !== this.minValidator;\n    }, this);\n  }\n\n  if (value !== null && value !== undefined) {\n    let msg = message || MongooseError.messages.Number.min;\n    msg = msg.replace(/{MIN}/, value);\n    this.validators.push({\n      validator: this.minValidator = function(v) {\n        return v == null || v >= value;\n      },\n      message: msg,\n      type: 'min',\n      min: value\n    });\n  }\n\n  return this;\n};\n\n/**\n * Sets a maximum number validator.\n *\n * #### Example:\n *\n *     const s = new Schema({ n: { type: Number, max: 10 })\n *     const M = db.model('M', s)\n *     const m = new M({ n: 11 })\n *     m.save(function (err) {\n *       console.error(err) // validator error\n *       m.n = 10;\n *       m.save() // success\n *     })\n *\n *     // custom error messages\n *     // We can also use the special {MAX} token which will be replaced with the invalid value\n *     const max = [10, 'The value of path `{PATH}` ({VALUE}) exceeds the limit ({MAX}).'];\n *     const schema = new Schema({ n: { type: Number, max: max })\n *     const M = mongoose.model('Measurement', schema);\n *     const s= new M({ n: 4 });\n *     s.validate(function (err) {\n *       console.log(String(err)) // ValidationError: The value of path `n` (4) exceeds the limit (10).\n *     })\n *\n * @param {Number} maximum number\n * @param {String} [message] optional custom error message\n * @return {SchemaType} this\n * @see Customized Error Messages https://mongoosejs.com/docs/api/error.html#Error.messages\n * @api public\n */\n\nSchemaNumber.prototype.max = function(value, message) {\n  if (this.maxValidator) {\n    this.validators = this.validators.filter(function(v) {\n      return v.validator !== this.maxValidator;\n    }, this);\n  }\n\n  if (value !== null && value !== undefined) {\n    let msg = message || MongooseError.messages.Number.max;\n    msg = msg.replace(/{MAX}/, value);\n    this.validators.push({\n      validator: this.maxValidator = function(v) {\n        return v == null || v <= value;\n      },\n      message: msg,\n      type: 'max',\n      max: value\n    });\n  }\n\n  return this;\n};\n\n/**\n * Sets a enum validator\n *\n * #### Example:\n *\n *     const s = new Schema({ n: { type: Number, enum: [1, 2, 3] });\n *     const M = db.model('M', s);\n *\n *     const m = new M({ n: 4 });\n *     await m.save(); // throws validation error\n *\n *     m.n = 3;\n *     await m.save(); // succeeds\n *\n * @param {Array} values allowed values\n * @param {String} [message] optional custom error message\n * @return {SchemaType} this\n * @see Customized Error Messages https://mongoosejs.com/docs/api/error.html#Error.messages\n * @api public\n */\n\nSchemaNumber.prototype.enum = function(values, message) {\n  if (this.enumValidator) {\n    this.validators = this.validators.filter(function(v) {\n      return v.validator !== this.enumValidator;\n    }, this);\n  }\n\n\n  if (!Array.isArray(values)) {\n    const isObjectSyntax = utils.isPOJO(values) && values.values != null;\n    if (isObjectSyntax) {\n      message = values.message;\n      values = values.values;\n    } else if (typeof values === 'number') {\n      values = Array.prototype.slice.call(arguments);\n      message = null;\n    }\n\n    if (utils.isPOJO(values)) {\n      values = Object.values(values);\n    }\n    message = message || MongooseError.messages.Number.enum;\n  }\n\n  message = message == null ? MongooseError.messages.Number.enum : message;\n\n  this.enumValidator = v => v == null || values.indexOf(v) !== -1;\n  this.validators.push({\n    validator: this.enumValidator,\n    message: message,\n    type: 'enum',\n    enumValues: values\n  });\n\n  return this;\n};\n\n/**\n * Casts to number\n *\n * @param {Object} value value to cast\n * @param {Document} doc document that triggers the casting\n * @param {Boolean} init\n * @api private\n */\n\nSchemaNumber.prototype.cast = function(value, doc, init) {\n  if (typeof value !== 'number' && SchemaType._isRef(this, value, doc, init)) {\n    if (value == null || utils.isNonBuiltinObject(value)) {\n      return this._castRef(value, doc, init);\n    }\n  }\n\n  const val = value && typeof value._id !== 'undefined' ?\n    value._id : // documents\n    value;\n\n  let castNumber;\n  if (typeof this._castFunction === 'function') {\n    castNumber = this._castFunction;\n  } else if (typeof this.constructor.cast === 'function') {\n    castNumber = this.constructor.cast();\n  } else {\n    castNumber = SchemaNumber.cast();\n  }\n\n  try {\n    return castNumber(val);\n  } catch (err) {\n    throw new CastError('Number', val, this.path, err, this);\n  }\n};\n\n/*!\n * ignore\n */\n\nfunction handleSingle(val) {\n  return this.cast(val);\n}\n\nfunction handleArray(val) {\n  const _this = this;\n  if (!Array.isArray(val)) {\n    return [this.cast(val)];\n  }\n  return val.map(function(m) {\n    return _this.cast(m);\n  });\n}\n\nSchemaNumber.prototype.$conditionalHandlers =\n    utils.options(SchemaType.prototype.$conditionalHandlers, {\n      $bitsAllClear: handleBitwiseOperator,\n      $bitsAnyClear: handleBitwiseOperator,\n      $bitsAllSet: handleBitwiseOperator,\n      $bitsAnySet: handleBitwiseOperator,\n      $gt: handleSingle,\n      $gte: handleSingle,\n      $lt: handleSingle,\n      $lte: handleSingle,\n      $mod: handleArray\n    });\n\n/**\n * Casts contents for queries.\n *\n * @param {String} $conditional\n * @param {any} [value]\n * @api private\n */\n\nSchemaNumber.prototype.castForQuery = function($conditional, val, context) {\n  let handler;\n  if ($conditional != null) {\n    handler = this.$conditionalHandlers[$conditional];\n    if (!handler) {\n      throw new CastError('number', val, this.path, null, this);\n    }\n    return handler.call(this, val, context);\n  }\n  val = this.applySetters(val, context);\n  return val;\n};\n\n/*!\n * Module exports.\n */\n\nmodule.exports = SchemaNumber;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbW9uZ29vc2UvbGliL3NjaGVtYS9udW1iZXIuanMiLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWI7QUFDQTtBQUNBOztBQUVBLHNCQUFzQixtQkFBTyxDQUFDLHdFQUFnQjtBQUM5Qyw0QkFBNEIsbUJBQU8sQ0FBQyx3R0FBZ0M7QUFDcEUsbUJBQW1CLG1CQUFPLENBQUMsc0VBQWU7QUFDMUMsbUJBQW1CLG1CQUFPLENBQUMsd0VBQWdCO0FBQzNDLDhCQUE4QixtQkFBTyxDQUFDLDBGQUFxQjtBQUMzRCxjQUFjLG1CQUFPLENBQUMsNERBQVU7O0FBRWhDOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5Q0FBeUMsdUJBQXVCO0FBQ2hFO0FBQ0EseURBQXlELGNBQWM7QUFDdkUsbUJBQW1CLFlBQVksUUFBUTtBQUN2QztBQUNBLFdBQVcsVUFBVTtBQUNyQixZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBEQUEwRCxnQkFBZ0I7QUFDMUUsbUJBQW1CLGFBQWEsd0NBQXdDO0FBQ3hFO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFdBQVcsS0FBSztBQUNoQixZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFVBQVU7QUFDckIsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFD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O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLEtBQUs7QUFDaEI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vYXBwMS8uL25vZGVfbW9kdWxlcy9tb25nb29zZS9saWIvc2NoZW1hL251bWJlci5qcz9kZmZhIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxuLyohXG4gKiBNb2R1bGUgcmVxdWlyZW1lbnRzLlxuICovXG5cbmNvbnN0IE1vbmdvb3NlRXJyb3IgPSByZXF1aXJlKCcuLi9lcnJvci9pbmRleCcpO1xuY29uc3QgU2NoZW1hTnVtYmVyT3B0aW9ucyA9IHJlcXVpcmUoJy4uL29wdGlvbnMvc2NoZW1hTnVtYmVyT3B0aW9ucycpO1xuY29uc3QgU2NoZW1hVHlwZSA9IHJlcXVpcmUoJy4uL3NjaGVtYVR5cGUnKTtcbmNvbnN0IGNhc3ROdW1iZXIgPSByZXF1aXJlKCcuLi9jYXN0L251bWJlcicpO1xuY29uc3QgaGFuZGxlQml0d2lzZU9wZXJhdG9yID0gcmVxdWlyZSgnLi9vcGVyYXRvcnMvYml0d2lzZScpO1xuY29uc3QgdXRpbHMgPSByZXF1aXJlKCcuLi91dGlscycpO1xuXG5jb25zdCBDYXN0RXJyb3IgPSBTY2hlbWFUeXBlLkNhc3RFcnJvcjtcblxuLyoqXG4gKiBOdW1iZXIgU2NoZW1hVHlwZSBjb25zdHJ1Y3Rvci5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30ga2V5XG4gKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xuICogQGluaGVyaXRzIFNjaGVtYVR5cGVcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZnVuY3Rpb24gU2NoZW1hTnVtYmVyKGtleSwgb3B0aW9ucykge1xuICBTY2hlbWFUeXBlLmNhbGwodGhpcywga2V5LCBvcHRpb25zLCAnTnVtYmVyJyk7XG59XG5cbi8qKlxuICogQXR0YWNoZXMgYSBnZXR0ZXIgZm9yIGFsbCBOdW1iZXIgaW5zdGFuY2VzLlxuICpcbiAqICMjIyMgRXhhbXBsZTpcbiAqXG4gKiAgICAgLy8gTWFrZSBhbGwgbnVtYmVycyByb3VuZCBkb3duXG4gKiAgICAgbW9uZ29vc2UuTnVtYmVyLmdldChmdW5jdGlvbih2KSB7IHJldHVybiBNYXRoLmZsb29yKHYpOyB9KTtcbiAqXG4gKiAgICAgY29uc3QgTW9kZWwgPSBtb25nb29zZS5tb2RlbCgnVGVzdCcsIG5ldyBTY2hlbWEoeyB0ZXN0OiBOdW1iZXIgfSkpO1xuICogICAgIG5ldyBNb2RlbCh7IHRlc3Q6IDMuMTQgfSkudGVzdDsgLy8gM1xuICpcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGdldHRlclxuICogQHJldHVybiB7dGhpc31cbiAqIEBmdW5jdGlvbiBnZXRcbiAqIEBzdGF0aWNcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuU2NoZW1hTnVtYmVyLmdldCA9IFNjaGVtYVR5cGUuZ2V0O1xuXG4vKipcbiAqIFNldHMgYSBkZWZhdWx0IG9wdGlvbiBmb3IgYWxsIE51bWJlciBpbnN0YW5jZXMuXG4gKlxuICogIyMjIyBFeGFtcGxlOlxuICpcbiAqICAgICAvLyBNYWtlIGFsbCBudW1iZXJzIGhhdmUgb3B0aW9uIGBtaW5gIGVxdWFsIHRvIDAuXG4gKiAgICAgbW9uZ29vc2UuU2NoZW1hLk51bWJlci5zZXQoJ21pbicsIDApO1xuICpcbiAqICAgICBjb25zdCBPcmRlciA9IG1vbmdvb3NlLm1vZGVsKCdPcmRlcicsIG5ldyBTY2hlbWEoeyBhbW91bnQ6IE51bWJlciB9KSk7XG4gKiAgICAgbmV3IE9yZGVyKHsgYW1vdW50OiAtMTAgfSkudmFsaWRhdGVTeW5jKCkuZXJyb3JzLmFtb3VudC5tZXNzYWdlOyAvLyBQYXRoIGBhbW91bnRgIG11c3QgYmUgbGFyZ2VyIHRoYW4gMC5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gb3B0aW9uIFRoZSBvcHRpb24geW91J2QgbGlrZSB0byBzZXQgdGhlIHZhbHVlIGZvclxuICogQHBhcmFtIHtBbnl9IHZhbHVlIHZhbHVlIGZvciBvcHRpb25cbiAqIEByZXR1cm4ge3VuZGVmaW5lZH1cbiAqIEBmdW5jdGlvbiBzZXRcbiAqIEBzdGF0aWNcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuU2NoZW1hTnVtYmVyLnNldCA9IFNjaGVtYVR5cGUuc2V0O1xuXG5TY2hlbWFOdW1iZXIuc2V0dGVycyA9IFtdO1xuXG4vKiFcbiAqIGlnbm9yZVxuICovXG5cblNjaGVtYU51bWJlci5fY2FzdCA9IGNhc3ROdW1iZXI7XG5cbi8qKlxuICogR2V0L3NldCB0aGUgZnVuY3Rpb24gdXNlZCB0byBjYXN0IGFyYml0cmFyeSB2YWx1ZXMgdG8gbnVtYmVycy5cbiAqXG4gKiAjIyMjIEV4YW1wbGU6XG4gKlxuICogICAgIC8vIE1ha2UgTW9uZ29vc2UgY2FzdCBlbXB0eSBzdHJpbmdzICcnIHRvIDAgZm9yIHBhdGhzIGRlY2xhcmVkIGFzIG51bWJlcnNcbiAqICAgICBjb25zdCBvcmlnaW5hbCA9IG1vbmdvb3NlLk51bWJlci5jYXN0KCk7XG4gKiAgICAgbW9uZ29vc2UuTnVtYmVyLmNhc3QodiA9PiB7XG4gKiAgICAgICBpZiAodiA9PT0gJycpIHsgcmV0dXJuIDA7IH1cbiAqICAgICAgIHJldHVybiBvcmlnaW5hbCh2KTtcbiAqICAgICB9KTtcbiAqXG4gKiAgICAgLy8gT3IgZGlzYWJsZSBjYXN0aW5nIGVudGlyZWx5XG4gKiAgICAgbW9uZ29vc2UuTnVtYmVyLmNhc3QoZmFsc2UpO1xuICpcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGNhc3RlclxuICogQHJldHVybiB7RnVuY3Rpb259XG4gKiBAZnVuY3Rpb24gZ2V0XG4gKiBAc3RhdGljXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cblNjaGVtYU51bWJlci5jYXN0ID0gZnVuY3Rpb24gY2FzdChjYXN0ZXIpIHtcbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDApIHtcbiAgICByZXR1cm4gdGhpcy5fY2FzdDtcbiAgfVxuICBpZiAoY2FzdGVyID09PSBmYWxzZSkge1xuICAgIGNhc3RlciA9IHRoaXMuX2RlZmF1bHRDYXN0ZXI7XG4gIH1cbiAgdGhpcy5fY2FzdCA9IGNhc3RlcjtcblxuICByZXR1cm4gdGhpcy5fY2FzdDtcbn07XG5cbi8qIVxuICogaWdub3JlXG4gKi9cblxuU2NoZW1hTnVtYmVyLl9kZWZhdWx0Q2FzdGVyID0gdiA9PiB7XG4gIGlmICh0eXBlb2YgdiAhPT0gJ251bWJlcicpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoKTtcbiAgfVxuICByZXR1cm4gdjtcbn07XG5cbi8qKlxuICogVGhpcyBzY2hlbWEgdHlwZSdzIG5hbWUsIHRvIGRlZmVuZCBhZ2FpbnN0IG1pbmlmaWVycyB0aGF0IG1hbmdsZVxuICogZnVuY3Rpb24gbmFtZXMuXG4gKlxuICogQGFwaSBwdWJsaWNcbiAqL1xuU2NoZW1hTnVtYmVyLnNjaGVtYU5hbWUgPSAnTnVtYmVyJztcblxuU2NoZW1hTnVtYmVyLmRlZmF1bHRPcHRpb25zID0ge307XG5cbi8qIVxuICogSW5oZXJpdHMgZnJvbSBTY2hlbWFUeXBlLlxuICovXG5TY2hlbWFOdW1iZXIucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShTY2hlbWFUeXBlLnByb3RvdHlwZSk7XG5TY2hlbWFOdW1iZXIucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gU2NoZW1hTnVtYmVyO1xuU2NoZW1hTnVtYmVyLnByb3RvdHlwZS5PcHRpb25zQ29uc3RydWN0b3IgPSBTY2hlbWFOdW1iZXJPcHRpb25zO1xuXG4vKiFcbiAqIGlnbm9yZVxuICovXG5cblNjaGVtYU51bWJlci5fY2hlY2tSZXF1aXJlZCA9IHYgPT4gdHlwZW9mIHYgPT09ICdudW1iZXInIHx8IHYgaW5zdGFuY2VvZiBOdW1iZXI7XG5cbi8qKlxuICogT3ZlcnJpZGUgdGhlIGZ1bmN0aW9uIHRoZSByZXF1aXJlZCB2YWxpZGF0b3IgdXNlcyB0byBjaGVjayB3aGV0aGVyIGEgc3RyaW5nXG4gKiBwYXNzZXMgdGhlIGByZXF1aXJlZGAgY2hlY2suXG4gKlxuICogQHBhcmFtIHtGdW5jdGlvbn0gZm5cbiAqIEByZXR1cm4ge0Z1bmN0aW9ufVxuICogQGZ1bmN0aW9uIGNoZWNrUmVxdWlyZWRcbiAqIEBzdGF0aWNcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuU2NoZW1hTnVtYmVyLmNoZWNrUmVxdWlyZWQgPSBTY2hlbWFUeXBlLmNoZWNrUmVxdWlyZWQ7XG5cbi8qKlxuICogQ2hlY2sgaWYgdGhlIGdpdmVuIHZhbHVlIHNhdGlzZmllcyBhIHJlcXVpcmVkIHZhbGlkYXRvci5cbiAqXG4gKiBAcGFyYW0ge0FueX0gdmFsdWVcbiAqIEBwYXJhbSB7RG9jdW1lbnR9IGRvY1xuICogQHJldHVybiB7Qm9vbGVhbn1cbiAqIEBhcGkgcHVibGljXG4gKi9cblxuU2NoZW1hTnVtYmVyLnByb3RvdHlwZS5jaGVja1JlcXVpcmVkID0gZnVuY3Rpb24gY2hlY2tSZXF1aXJlZCh2YWx1ZSwgZG9jKSB7XG4gIGlmICh0eXBlb2YgdmFsdWUgPT09ICdvYmplY3QnICYmIFNjaGVtYVR5cGUuX2lzUmVmKHRoaXMsIHZhbHVlLCBkb2MsIHRydWUpKSB7XG4gICAgcmV0dXJuIHZhbHVlICE9IG51bGw7XG4gIH1cblxuICAvLyBgcmVxdWlyZSgndXRpbCcpLmluaGVyaXRzKClgIGRvZXMgKipub3QqKiBjb3B5IHN0YXRpYyBwcm9wZXJ0aWVzLCBhbmRcbiAgLy8gcGx1Z2lucyBsaWtlIG1vbmdvb3NlLWZsb2F0IHVzZSBgaW5oZXJpdHMoKWAgZm9yIHByZS1FUzYuXG4gIGNvbnN0IF9jaGVja1JlcXVpcmVkID0gdHlwZW9mIHRoaXMuY29uc3RydWN0b3IuY2hlY2tSZXF1aXJlZCA9PT0gJ2Z1bmN0aW9uJyA/XG4gICAgdGhpcy5jb25zdHJ1Y3Rvci5jaGVja1JlcXVpcmVkKCkgOlxuICAgIFNjaGVtYU51bWJlci5jaGVja1JlcXVpcmVkKCk7XG5cbiAgcmV0dXJuIF9jaGVja1JlcXVpcmVkKHZhbHVlKTtcbn07XG5cbi8qKlxuICogU2V0cyBhIG1pbmltdW0gbnVtYmVyIHZhbGlkYXRvci5cbiAqXG4gKiAjIyMjIEV4YW1wbGU6XG4gKlxuICogICAgIGNvbnN0IHMgPSBuZXcgU2NoZW1hKHsgbjogeyB0eXBlOiBOdW1iZXIsIG1pbjogMTAgfSlcbiAqICAgICBjb25zdCBNID0gZGIubW9kZWwoJ00nLCBzKVxuICogICAgIGNvbnN0IG0gPSBuZXcgTSh7IG46IDkgfSlcbiAqICAgICBtLnNhdmUoZnVuY3Rpb24gKGVycikge1xuICogICAgICAgY29uc29sZS5lcnJvcihlcnIpIC8vIHZhbGlkYXRvciBlcnJvclxuICogICAgICAgbS5uID0gMTA7XG4gKiAgICAgICBtLnNhdmUoKSAvLyBzdWNjZXNzXG4gKiAgICAgfSlcbiAqXG4gKiAgICAgLy8gY3VzdG9tIGVycm9yIG1lc3NhZ2VzXG4gKiAgICAgLy8gV2UgY2FuIGFsc28gdXNlIHRoZSBzcGVjaWFsIHtNSU59IHRva2VuIHdoaWNoIHdpbGwgYmUgcmVwbGFjZWQgd2l0aCB0aGUgaW52YWxpZCB2YWx1ZVxuICogICAgIGNvbnN0IG1pbiA9IFsxMCwgJ1RoZSB2YWx1ZSBvZiBwYXRoIGB7UEFUSH1gICh7VkFMVUV9KSBpcyBiZW5lYXRoIHRoZSBsaW1pdCAoe01JTn0pLiddO1xuICogICAgIGNvbnN0IHNjaGVtYSA9IG5ldyBTY2hlbWEoeyBuOiB7IHR5cGU6IE51bWJlciwgbWluOiBtaW4gfSlcbiAqICAgICBjb25zdCBNID0gbW9uZ29vc2UubW9kZWwoJ01lYXN1cmVtZW50Jywgc2NoZW1hKTtcbiAqICAgICBjb25zdCBzPSBuZXcgTSh7IG46IDQgfSk7XG4gKiAgICAgcy52YWxpZGF0ZShmdW5jdGlvbiAoZXJyKSB7XG4gKiAgICAgICBjb25zb2xlLmxvZyhTdHJpbmcoZXJyKSkgLy8gVmFsaWRhdGlvbkVycm9yOiBUaGUgdmFsdWUgb2YgcGF0aCBgbmAgKDQpIGlzIGJlbmVhdGggdGhlIGxpbWl0ICgxMCkuXG4gKiAgICAgfSlcbiAqXG4gKiBAcGFyYW0ge051bWJlcn0gdmFsdWUgbWluaW11bSBudW1iZXJcbiAqIEBwYXJhbSB7U3RyaW5nfSBbbWVzc2FnZV0gb3B0aW9uYWwgY3VzdG9tIGVycm9yIG1lc3NhZ2VcbiAqIEByZXR1cm4ge1NjaGVtYVR5cGV9IHRoaXNcbiAqIEBzZWUgQ3VzdG9taXplZCBFcnJvciBNZXNzYWdlcyBodHRwczovL21vbmdvb3NlanMuY29tL2RvY3MvYXBpL2Vycm9yLmh0bWwjRXJyb3IubWVzc2FnZXNcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuU2NoZW1hTnVtYmVyLnByb3RvdHlwZS5taW4gPSBmdW5jdGlvbih2YWx1ZSwgbWVzc2FnZSkge1xuICBpZiAodGhpcy5taW5WYWxpZGF0b3IpIHtcbiAgICB0aGlzLnZhbGlkYXRvcnMgPSB0aGlzLnZhbGlkYXRvcnMuZmlsdGVyKGZ1bmN0aW9uKHYpIHtcbiAgICAgIHJldHVybiB2LnZhbGlkYXRvciAhPT0gdGhpcy5taW5WYWxpZGF0b3I7XG4gICAgfSwgdGhpcyk7XG4gIH1cblxuICBpZiAodmFsdWUgIT09IG51bGwgJiYgdmFsdWUgIT09IHVuZGVmaW5lZCkge1xuICAgIGxldCBtc2cgPSBtZXNzYWdlIHx8IE1vbmdvb3NlRXJyb3IubWVzc2FnZXMuTnVtYmVyLm1pbjtcbiAgICBtc2cgPSBtc2cucmVwbGFjZSgve01JTn0vLCB2YWx1ZSk7XG4gICAgdGhpcy52YWxpZGF0b3JzLnB1c2goe1xuICAgICAgdmFsaWRhdG9yOiB0aGlzLm1pblZhbGlkYXRvciA9IGZ1bmN0aW9uKHYpIHtcbiAgICAgICAgcmV0dXJuIHYgPT0gbnVsbCB8fCB2ID49IHZhbHVlO1xuICAgICAgfSxcbiAgICAgIG1lc3NhZ2U6IG1zZyxcbiAgICAgIHR5cGU6ICdtaW4nLFxuICAgICAgbWluOiB2YWx1ZVxuICAgIH0pO1xuICB9XG5cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIFNldHMgYSBtYXhpbXVtIG51bWJlciB2YWxpZGF0b3IuXG4gKlxuICogIyMjIyBFeGFtcGxlOlxuICpcbiAqICAgICBjb25zdCBzID0gbmV3IFNjaGVtYSh7IG46IHsgdHlwZTogTnVtYmVyLCBtYXg6IDEwIH0pXG4gKiAgICAgY29uc3QgTSA9IGRiLm1vZGVsKCdNJywgcylcbiAqICAgICBjb25zdCBtID0gbmV3IE0oeyBuOiAxMSB9KVxuICogICAgIG0uc2F2ZShmdW5jdGlvbiAoZXJyKSB7XG4gKiAgICAgICBjb25zb2xlLmVycm9yKGVycikgLy8gdmFsaWRhdG9yIGVycm9yXG4gKiAgICAgICBtLm4gPSAxMDtcbiAqICAgICAgIG0uc2F2ZSgpIC8vIHN1Y2Nlc3NcbiAqICAgICB9KVxuICpcbiAqICAgICAvLyBjdXN0b20gZXJyb3IgbWVzc2FnZXNcbiAqICAgICAvLyBXZSBjYW4gYWxzbyB1c2UgdGhlIHNwZWNpYWwge01BWH0gdG9rZW4gd2hpY2ggd2lsbCBiZSByZXBsYWNlZCB3aXRoIHRoZSBpbnZhbGlkIHZhbHVlXG4gKiAgICAgY29uc3QgbWF4ID0gWzEwLCAnVGhlIHZhbHVlIG9mIHBhdGggYHtQQVRIfWAgKHtWQUxVRX0pIGV4Y2VlZHMgdGhlIGxpbWl0ICh7TUFYfSkuJ107XG4gKiAgICAgY29uc3Qgc2NoZW1hID0gbmV3IFNjaGVtYSh7IG46IHsgdHlwZTogTnVtYmVyLCBtYXg6IG1heCB9KVxuICogICAgIGNvbnN0IE0gPSBtb25nb29zZS5tb2RlbCgnTWVhc3VyZW1lbnQnLCBzY2hlbWEpO1xuICogICAgIGNvbnN0IHM9IG5ldyBNKHsgbjogNCB9KTtcbiAqICAgICBzLnZhbGlkYXRlKGZ1bmN0aW9uIChlcnIpIHtcbiAqICAgICAgIGNvbnNvbGUubG9nKFN0cmluZyhlcnIpKSAvLyBWYWxpZGF0aW9uRXJyb3I6IFRoZSB2YWx1ZSBvZiBwYXRoIGBuYCAoNCkgZXhjZWVkcyB0aGUgbGltaXQgKDEwKS5cbiAqICAgICB9KVxuICpcbiAqIEBwYXJhbSB7TnVtYmVyfSBtYXhpbXVtIG51bWJlclxuICogQHBhcmFtIHtTdHJpbmd9IFttZXNzYWdlXSBvcHRpb25hbCBjdXN0b20gZXJyb3IgbWVzc2FnZVxuICogQHJldHVybiB7U2NoZW1hVHlwZX0gdGhpc1xuICogQHNlZSBDdXN0b21pemVkIEVycm9yIE1lc3NhZ2VzIGh0dHBzOi8vbW9uZ29vc2Vqcy5jb20vZG9jcy9hcGkvZXJyb3IuaHRtbCNFcnJvci5tZXNzYWdlc1xuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5TY2hlbWFOdW1iZXIucHJvdG90eXBlLm1heCA9IGZ1bmN0aW9uKHZhbHVlLCBtZXNzYWdlKSB7XG4gIGlmICh0aGlzLm1heFZhbGlkYXRvcikge1xuICAgIHRoaXMudmFsaWRhdG9ycyA9IHRoaXMudmFsaWRhdG9ycy5maWx0ZXIoZnVuY3Rpb24odikge1xuICAgICAgcmV0dXJuIHYudmFsaWRhdG9yICE9PSB0aGlzLm1heFZhbGlkYXRvcjtcbiAgICB9LCB0aGlzKTtcbiAgfVxuXG4gIGlmICh2YWx1ZSAhPT0gbnVsbCAmJiB2YWx1ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgbGV0IG1zZyA9IG1lc3NhZ2UgfHwgTW9uZ29vc2VFcnJvci5tZXNzYWdlcy5OdW1iZXIubWF4O1xuICAgIG1zZyA9IG1zZy5yZXBsYWNlKC97TUFYfS8sIHZhbHVlKTtcbiAgICB0aGlzLnZhbGlkYXRvcnMucHVzaCh7XG4gICAgICB2YWxpZGF0b3I6IHRoaXMubWF4VmFsaWRhdG9yID0gZnVuY3Rpb24odikge1xuICAgICAgICByZXR1cm4gdiA9PSBudWxsIHx8IHYgPD0gdmFsdWU7XG4gICAgICB9LFxuICAgICAgbWVzc2FnZTogbXNnLFxuICAgICAgdHlwZTogJ21heCcsXG4gICAgICBtYXg6IHZhbHVlXG4gICAgfSk7XG4gIH1cblxuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogU2V0cyBhIGVudW0gdmFsaWRhdG9yXG4gKlxuICogIyMjIyBFeGFtcGxlOlxuICpcbiAqICAgICBjb25zdCBzID0gbmV3IFNjaGVtYSh7IG46IHsgdHlwZTogTnVtYmVyLCBlbnVtOiBbMSwgMiwgM10gfSk7XG4gKiAgICAgY29uc3QgTSA9IGRiLm1vZGVsKCdNJywgcyk7XG4gKlxuICogICAgIGNvbnN0IG0gPSBuZXcgTSh7IG46IDQgfSk7XG4gKiAgICAgYXdhaXQgbS5zYXZlKCk7IC8vIHRocm93cyB2YWxpZGF0aW9uIGVycm9yXG4gKlxuICogICAgIG0ubiA9IDM7XG4gKiAgICAgYXdhaXQgbS5zYXZlKCk7IC8vIHN1Y2NlZWRzXG4gKlxuICogQHBhcmFtIHtBcnJheX0gdmFsdWVzIGFsbG93ZWQgdmFsdWVzXG4gKiBAcGFyYW0ge1N0cmluZ30gW21lc3NhZ2VdIG9wdGlvbmFsIGN1c3RvbSBlcnJvciBtZXNzYWdlXG4gKiBAcmV0dXJuIHtTY2hlbWFUeXBlfSB0aGlzXG4gKiBAc2VlIEN1c3RvbWl6ZWQgRXJyb3IgTWVzc2FnZXMgaHR0cHM6Ly9tb25nb29zZWpzLmNvbS9kb2NzL2FwaS9lcnJvci5odG1sI0Vycm9yLm1lc3NhZ2VzXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cblNjaGVtYU51bWJlci5wcm90b3R5cGUuZW51bSA9IGZ1bmN0aW9uKHZhbHVlcywgbWVzc2FnZSkge1xuICBpZiAodGhpcy5lbnVtVmFsaWRhdG9yKSB7XG4gICAgdGhpcy52YWxpZGF0b3JzID0gdGhpcy52YWxpZGF0b3JzLmZpbHRlcihmdW5jdGlvbih2KSB7XG4gICAgICByZXR1cm4gdi52YWxpZGF0b3IgIT09IHRoaXMuZW51bVZhbGlkYXRvcjtcbiAgICB9LCB0aGlzKTtcbiAgfVxuXG5cbiAgaWYgKCFBcnJheS5pc0FycmF5KHZhbHVlcykpIHtcbiAgICBjb25zdCBpc09iamVjdFN5bnRheCA9IHV0aWxzLmlzUE9KTyh2YWx1ZXMpICYmIHZhbHVlcy52YWx1ZXMgIT0gbnVsbDtcbiAgICBpZiAoaXNPYmplY3RTeW50YXgpIHtcbiAgICAgIG1lc3NhZ2UgPSB2YWx1ZXMubWVzc2FnZTtcbiAgICAgIHZhbHVlcyA9IHZhbHVlcy52YWx1ZXM7XG4gICAgfSBlbHNlIGlmICh0eXBlb2YgdmFsdWVzID09PSAnbnVtYmVyJykge1xuICAgICAgdmFsdWVzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzKTtcbiAgICAgIG1lc3NhZ2UgPSBudWxsO1xuICAgIH1cblxuICAgIGlmICh1dGlscy5pc1BPSk8odmFsdWVzKSkge1xuICAgICAgdmFsdWVzID0gT2JqZWN0LnZhbHVlcyh2YWx1ZXMpO1xuICAgIH1cbiAgICBtZXNzYWdlID0gbWVzc2FnZSB8fCBNb25nb29zZUVycm9yLm1lc3NhZ2VzLk51bWJlci5lbnVtO1xuICB9XG5cbiAgbWVzc2FnZSA9IG1lc3NhZ2UgPT0gbnVsbCA/IE1vbmdvb3NlRXJyb3IubWVzc2FnZXMuTnVtYmVyLmVudW0gOiBtZXNzYWdlO1xuXG4gIHRoaXMuZW51bVZhbGlkYXRvciA9IHYgPT4gdiA9PSBudWxsIHx8IHZhbHVlcy5pbmRleE9mKHYpICE9PSAtMTtcbiAgdGhpcy52YWxpZGF0b3JzLnB1c2goe1xuICAgIHZhbGlkYXRvcjogdGhpcy5lbnVtVmFsaWRhdG9yLFxuICAgIG1lc3NhZ2U6IG1lc3NhZ2UsXG4gICAgdHlwZTogJ2VudW0nLFxuICAgIGVudW1WYWx1ZXM6IHZhbHVlc1xuICB9KTtcblxuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogQ2FzdHMgdG8gbnVtYmVyXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IHZhbHVlIHZhbHVlIHRvIGNhc3RcbiAqIEBwYXJhbSB7RG9jdW1lbnR9IGRvYyBkb2N1bWVudCB0aGF0IHRyaWdnZXJzIHRoZSBjYXN0aW5nXG4gKiBAcGFyYW0ge0Jvb2xlYW59IGluaXRcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cblNjaGVtYU51bWJlci5wcm90b3R5cGUuY2FzdCA9IGZ1bmN0aW9uKHZhbHVlLCBkb2MsIGluaXQpIHtcbiAgaWYgKHR5cGVvZiB2YWx1ZSAhPT0gJ251bWJlcicgJiYgU2NoZW1hVHlwZS5faXNSZWYodGhpcywgdmFsdWUsIGRvYywgaW5pdCkpIHtcbiAgICBpZiAodmFsdWUgPT0gbnVsbCB8fCB1dGlscy5pc05vbkJ1aWx0aW5PYmplY3QodmFsdWUpKSB7XG4gICAgICByZXR1cm4gdGhpcy5fY2FzdFJlZih2YWx1ZSwgZG9jLCBpbml0KTtcbiAgICB9XG4gIH1cblxuICBjb25zdCB2YWwgPSB2YWx1ZSAmJiB0eXBlb2YgdmFsdWUuX2lkICE9PSAndW5kZWZpbmVkJyA/XG4gICAgdmFsdWUuX2lkIDogLy8gZG9jdW1lbnRzXG4gICAgdmFsdWU7XG5cbiAgbGV0IGNhc3ROdW1iZXI7XG4gIGlmICh0eXBlb2YgdGhpcy5fY2FzdEZ1bmN0aW9uID09PSAnZnVuY3Rpb24nKSB7XG4gICAgY2FzdE51bWJlciA9IHRoaXMuX2Nhc3RGdW5jdGlvbjtcbiAgfSBlbHNlIGlmICh0eXBlb2YgdGhpcy5jb25zdHJ1Y3Rvci5jYXN0ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgY2FzdE51bWJlciA9IHRoaXMuY29uc3RydWN0b3IuY2FzdCgpO1xuICB9IGVsc2Uge1xuICAgIGNhc3ROdW1iZXIgPSBTY2hlbWFOdW1iZXIuY2FzdCgpO1xuICB9XG5cbiAgdHJ5IHtcbiAgICByZXR1cm4gY2FzdE51bWJlcih2YWwpO1xuICB9IGNhdGNoIChlcnIpIHtcbiAgICB0aHJvdyBuZXcgQ2FzdEVycm9yKCdOdW1iZXInLCB2YWwsIHRoaXMucGF0aCwgZXJyLCB0aGlzKTtcbiAgfVxufTtcblxuLyohXG4gKiBpZ25vcmVcbiAqL1xuXG5mdW5jdGlvbiBoYW5kbGVTaW5nbGUodmFsKSB7XG4gIHJldHVybiB0aGlzLmNhc3QodmFsKTtcbn1cblxuZnVuY3Rpb24gaGFuZGxlQXJyYXkodmFsKSB7XG4gIGNvbnN0IF90aGlzID0gdGhpcztcbiAgaWYgKCFBcnJheS5pc0FycmF5KHZhbCkpIHtcbiAgICByZXR1cm4gW3RoaXMuY2FzdCh2YWwpXTtcbiAgfVxuICByZXR1cm4gdmFsLm1hcChmdW5jdGlvbihtKSB7XG4gICAgcmV0dXJuIF90aGlzLmNhc3QobSk7XG4gIH0pO1xufVxuXG5TY2hlbWFOdW1iZXIucHJvdG90eXBlLiRjb25kaXRpb25hbEhhbmRsZXJzID1cbiAgICB1dGlscy5vcHRpb25zKFNjaGVtYVR5cGUucHJvdG90eXBlLiRjb25kaXRpb25hbEhhbmRsZXJzLCB7XG4gICAgICAkYml0c0FsbENsZWFyOiBoYW5kbGVCaXR3aXNlT3BlcmF0b3IsXG4gICAgICAkYml0c0FueUNsZWFyOiBoYW5kbGVCaXR3aXNlT3BlcmF0b3IsXG4gICAgICAkYml0c0FsbFNldDogaGFuZGxlQml0d2lzZU9wZXJhdG9yLFxuICAgICAgJGJpdHNBbnlTZXQ6IGhhbmRsZUJpdHdpc2VPcGVyYXRvcixcbiAgICAgICRndDogaGFuZGxlU2luZ2xlLFxuICAgICAgJGd0ZTogaGFuZGxlU2luZ2xlLFxuICAgICAgJGx0OiBoYW5kbGVTaW5nbGUsXG4gICAgICAkbHRlOiBoYW5kbGVTaW5nbGUsXG4gICAgICAkbW9kOiBoYW5kbGVBcnJheVxuICAgIH0pO1xuXG4vKipcbiAqIENhc3RzIGNvbnRlbnRzIGZvciBxdWVyaWVzLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSAkY29uZGl0aW9uYWxcbiAqIEBwYXJhbSB7YW55fSBbdmFsdWVdXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5TY2hlbWFOdW1iZXIucHJvdG90eXBlLmNhc3RGb3JRdWVyeSA9IGZ1bmN0aW9uKCRjb25kaXRpb25hbCwgdmFsLCBjb250ZXh0KSB7XG4gIGxldCBoYW5kbGVyO1xuICBpZiAoJGNvbmRpdGlvbmFsICE9IG51bGwpIHtcbiAgICBoYW5kbGVyID0gdGhpcy4kY29uZGl0aW9uYWxIYW5kbGVyc1skY29uZGl0aW9uYWxdO1xuICAgIGlmICghaGFuZGxlcikge1xuICAgICAgdGhyb3cgbmV3IENhc3RFcnJvcignbnVtYmVyJywgdmFsLCB0aGlzLnBhdGgsIG51bGwsIHRoaXMpO1xuICAgIH1cbiAgICByZXR1cm4gaGFuZGxlci5jYWxsKHRoaXMsIHZhbCwgY29udGV4dCk7XG4gIH1cbiAgdmFsID0gdGhpcy5hcHBseVNldHRlcnModmFsLCBjb250ZXh0KTtcbiAgcmV0dXJuIHZhbDtcbn07XG5cbi8qIVxuICogTW9kdWxlIGV4cG9ydHMuXG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSBTY2hlbWFOdW1iZXI7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/mongoose/lib/schema/number.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/mongoose/lib/schema/objectId.js":
/*!******************************************************!*\
  !*** ./node_modules/mongoose/lib/schema/objectId.js ***!
  \******************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("/*!\n * Module dependencies.\n */\n\n\n\nconst SchemaObjectIdOptions = __webpack_require__(/*! ../options/schemaObjectIdOptions */ \"(ssr)/./node_modules/mongoose/lib/options/schemaObjectIdOptions.js\");\nconst SchemaType = __webpack_require__(/*! ../schemaType */ \"(ssr)/./node_modules/mongoose/lib/schemaType.js\");\nconst castObjectId = __webpack_require__(/*! ../cast/objectid */ \"(ssr)/./node_modules/mongoose/lib/cast/objectid.js\");\nconst getConstructorName = __webpack_require__(/*! ../helpers/getConstructorName */ \"(ssr)/./node_modules/mongoose/lib/helpers/getConstructorName.js\");\nconst oid = __webpack_require__(/*! ../types/objectid */ \"(ssr)/./node_modules/mongoose/lib/types/objectid.js\");\nconst isBsonType = __webpack_require__(/*! ../helpers/isBsonType */ \"(ssr)/./node_modules/mongoose/lib/helpers/isBsonType.js\");\nconst utils = __webpack_require__(/*! ../utils */ \"(ssr)/./node_modules/mongoose/lib/utils.js\");\n\nconst CastError = SchemaType.CastError;\nlet Document;\n\n/**\n * ObjectId SchemaType constructor.\n *\n * @param {String} key\n * @param {Object} options\n * @inherits SchemaType\n * @api public\n */\n\nfunction SchemaObjectId(key, options) {\n  const isKeyHexStr = typeof key === 'string' && key.length === 24 && /^[a-f0-9]+$/i.test(key);\n  const suppressWarning = options && options.suppressWarning;\n  if ((isKeyHexStr || typeof key === 'undefined') && !suppressWarning) {\n    utils.warn('mongoose: To create a new ObjectId please try ' +\n      '`Mongoose.Types.ObjectId` instead of using ' +\n      '`Mongoose.Schema.ObjectId`. Set the `suppressWarning` option if ' +\n      'you\\'re trying to create a hex char path in your schema.');\n  }\n  SchemaType.call(this, key, options, 'ObjectId');\n}\n\n/**\n * This schema type's name, to defend against minifiers that mangle\n * function names.\n *\n * @api public\n */\nSchemaObjectId.schemaName = 'ObjectId';\n\nSchemaObjectId.defaultOptions = {};\n\n/*!\n * Inherits from SchemaType.\n */\nSchemaObjectId.prototype = Object.create(SchemaType.prototype);\nSchemaObjectId.prototype.constructor = SchemaObjectId;\nSchemaObjectId.prototype.OptionsConstructor = SchemaObjectIdOptions;\n\n/**\n * Attaches a getter for all ObjectId instances\n *\n * #### Example:\n *\n *     // Always convert to string when getting an ObjectId\n *     mongoose.ObjectId.get(v => v.toString());\n *\n *     const Model = mongoose.model('Test', new Schema({}));\n *     typeof (new Model({})._id); // 'string'\n *\n * @param {Function} getter\n * @return {this}\n * @function get\n * @static\n * @api public\n */\n\nSchemaObjectId.get = SchemaType.get;\n\n/**\n * Sets a default option for all ObjectId instances.\n *\n * #### Example:\n *\n *     // Make all object ids have option `required` equal to true.\n *     mongoose.Schema.ObjectId.set('required', true);\n *\n *     const Order = mongoose.model('Order', new Schema({ userId: ObjectId }));\n *     new Order({ }).validateSync().errors.userId.message; // Path `userId` is required.\n *\n * @param {String} option The option you'd like to set the value for\n * @param {Any} value value for option\n * @return {undefined}\n * @function set\n * @static\n * @api public\n */\n\nSchemaObjectId.set = SchemaType.set;\n\nSchemaObjectId.setters = [];\n\n/**\n * Adds an auto-generated ObjectId default if turnOn is true.\n * @param {Boolean} turnOn auto generated ObjectId defaults\n * @api public\n * @return {SchemaType} this\n */\n\nSchemaObjectId.prototype.auto = function(turnOn) {\n  if (turnOn) {\n    this.default(defaultId);\n    this.set(resetId);\n  }\n\n  return this;\n};\n\n/*!\n * ignore\n */\n\nSchemaObjectId._checkRequired = v => isBsonType(v, 'ObjectId');\n\n/*!\n * ignore\n */\n\nSchemaObjectId._cast = castObjectId;\n\n/**\n * Get/set the function used to cast arbitrary values to objectids.\n *\n * #### Example:\n *\n *     // Make Mongoose only try to cast length 24 strings. By default, any 12\n *     // char string is a valid ObjectId.\n *     const original = mongoose.ObjectId.cast();\n *     mongoose.ObjectId.cast(v => {\n *       assert.ok(typeof v !== 'string' || v.length === 24);\n *       return original(v);\n *     });\n *\n *     // Or disable casting entirely\n *     mongoose.ObjectId.cast(false);\n *\n * @param {Function} caster\n * @return {Function}\n * @function get\n * @static\n * @api public\n */\n\nSchemaObjectId.cast = function cast(caster) {\n  if (arguments.length === 0) {\n    return this._cast;\n  }\n  if (caster === false) {\n    caster = this._defaultCaster;\n  }\n  this._cast = caster;\n\n  return this._cast;\n};\n\n/*!\n * ignore\n */\n\nSchemaObjectId._defaultCaster = v => {\n  if (!(isBsonType(v, 'ObjectId'))) {\n    throw new Error(v + ' is not an instance of ObjectId');\n  }\n  return v;\n};\n\n/**\n * Override the function the required validator uses to check whether a string\n * passes the `required` check.\n *\n * #### Example:\n *\n *     // Allow empty strings to pass `required` check\n *     mongoose.Schema.Types.String.checkRequired(v => v != null);\n *\n *     const M = mongoose.model({ str: { type: String, required: true } });\n *     new M({ str: '' }).validateSync(); // `null`, validation passes!\n *\n * @param {Function} fn\n * @return {Function}\n * @function checkRequired\n * @static\n * @api public\n */\n\nSchemaObjectId.checkRequired = SchemaType.checkRequired;\n\n/**\n * Check if the given value satisfies a required validator.\n *\n * @param {Any} value\n * @param {Document} doc\n * @return {Boolean}\n * @api public\n */\n\nSchemaObjectId.prototype.checkRequired = function checkRequired(value, doc) {\n  if (SchemaType._isRef(this, value, doc, true)) {\n    return !!value;\n  }\n\n  // `require('util').inherits()` does **not** copy static properties, and\n  // plugins like mongoose-float use `inherits()` for pre-ES6.\n  const _checkRequired = typeof this.constructor.checkRequired === 'function' ?\n    this.constructor.checkRequired() :\n    SchemaObjectId.checkRequired();\n\n  return _checkRequired(value);\n};\n\n/**\n * Casts to ObjectId\n *\n * @param {Object} value\n * @param {Object} doc\n * @param {Boolean} init whether this is an initialization cast\n * @api private\n */\n\nSchemaObjectId.prototype.cast = function(value, doc, init) {\n  if (!(isBsonType(value, 'ObjectId')) && SchemaType._isRef(this, value, doc, init)) {\n    // wait! we may need to cast this to a document\n    if ((getConstructorName(value) || '').toLowerCase() === 'objectid') {\n      return new oid(value.toHexString());\n    }\n\n    if (value == null || utils.isNonBuiltinObject(value)) {\n      return this._castRef(value, doc, init);\n    }\n  }\n\n  let castObjectId;\n  if (typeof this._castFunction === 'function') {\n    castObjectId = this._castFunction;\n  } else if (typeof this.constructor.cast === 'function') {\n    castObjectId = this.constructor.cast();\n  } else {\n    castObjectId = SchemaObjectId.cast();\n  }\n\n  try {\n    return castObjectId(value);\n  } catch (error) {\n    throw new CastError('ObjectId', value, this.path, error, this);\n  }\n};\n\n/*!\n * ignore\n */\n\nfunction handleSingle(val) {\n  return this.cast(val);\n}\n\nSchemaObjectId.prototype.$conditionalHandlers =\n    utils.options(SchemaType.prototype.$conditionalHandlers, {\n      $gt: handleSingle,\n      $gte: handleSingle,\n      $lt: handleSingle,\n      $lte: handleSingle\n    });\n\n/*!\n * ignore\n */\n\nfunction defaultId() {\n  return new oid();\n}\n\ndefaultId.$runBeforeSetters = true;\n\nfunction resetId(v) {\n  Document || (Document = __webpack_require__(/*! ../document */ \"(ssr)/./node_modules/mongoose/lib/document.js\"));\n\n  if (this instanceof Document) {\n    if (v === void 0) {\n      const _v = new oid();\n      return _v;\n    }\n  }\n\n  return v;\n}\n\n/*!\n * Module exports.\n */\n\nmodule.exports = SchemaObjectId;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbW9uZ29vc2UvbGliL3NjaGVtYS9vYmplY3RJZC5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7O0FBRWE7O0FBRWIsOEJBQThCLG1CQUFPLENBQUMsNEdBQWtDO0FBQ3hFLG1CQUFtQixtQkFBTyxDQUFDLHNFQUFlO0FBQzFDLHFCQUFxQixtQkFBTyxDQUFDLDRFQUFrQjtBQUMvQywyQkFBMkIsbUJBQU8sQ0FBQyxzR0FBK0I7QUFDbEUsWUFBWSxtQkFBTyxDQUFDLDhFQUFtQjtBQUN2QyxtQkFBbUIsbUJBQU8sQ0FBQyxzRkFBdUI7QUFDbEQsY0FBYyxtQkFBTyxDQUFDLDREQUFVOztBQUVoQztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5REFBeUQ7QUFDekQsMkJBQTJCLFFBQVE7QUFDbkM7QUFDQSxXQUFXLFVBQVU7QUFDckIsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwREFBMEQsa0JBQWtCO0FBQzVFLG9CQUFvQix3Q0FBd0M7QUFDNUQ7QUFDQSxXQUFXLFFBQVE7QUFDbkIsV0FBVyxLQUFLO0FBQ2hCLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsV0FBVyxTQUFTO0FBQ3BCO0FBQ0EsWUFBWSxZQUFZO0FBQ3hCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFVBQVU7QUFDckIsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQyxPQUFPLGdDQUFnQztBQUN6RSxlQUFlLFNBQVMsa0JBQWtCO0FBQzFDO0FBQ0EsV0FBVyxVQUFVO0FBQ3JCLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLEtBQUs7QUFDaEIsV0FBVyxVQUFVO0FBQ3JCLFlBQVk7QUFDWjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsU0FBUztBQUNwQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQSxJQUFJO0FBQ0o7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLDBCQUEwQixtQkFBTyxDQUFDLGtFQUFhOztBQUUvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9hcHAxLy4vbm9kZV9tb2R1bGVzL21vbmdvb3NlL2xpYi9zY2hlbWEvb2JqZWN0SWQuanM/NDg0OCJdLCJzb3VyY2VzQ29udGVudCI6WyIvKiFcbiAqIE1vZHVsZSBkZXBlbmRlbmNpZXMuXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG5jb25zdCBTY2hlbWFPYmplY3RJZE9wdGlvbnMgPSByZXF1aXJlKCcuLi9vcHRpb25zL3NjaGVtYU9iamVjdElkT3B0aW9ucycpO1xuY29uc3QgU2NoZW1hVHlwZSA9IHJlcXVpcmUoJy4uL3NjaGVtYVR5cGUnKTtcbmNvbnN0IGNhc3RPYmplY3RJZCA9IHJlcXVpcmUoJy4uL2Nhc3Qvb2JqZWN0aWQnKTtcbmNvbnN0IGdldENvbnN0cnVjdG9yTmFtZSA9IHJlcXVpcmUoJy4uL2hlbHBlcnMvZ2V0Q29uc3RydWN0b3JOYW1lJyk7XG5jb25zdCBvaWQgPSByZXF1aXJlKCcuLi90eXBlcy9vYmplY3RpZCcpO1xuY29uc3QgaXNCc29uVHlwZSA9IHJlcXVpcmUoJy4uL2hlbHBlcnMvaXNCc29uVHlwZScpO1xuY29uc3QgdXRpbHMgPSByZXF1aXJlKCcuLi91dGlscycpO1xuXG5jb25zdCBDYXN0RXJyb3IgPSBTY2hlbWFUeXBlLkNhc3RFcnJvcjtcbmxldCBEb2N1bWVudDtcblxuLyoqXG4gKiBPYmplY3RJZCBTY2hlbWFUeXBlIGNvbnN0cnVjdG9yLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBrZXlcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zXG4gKiBAaW5oZXJpdHMgU2NoZW1hVHlwZVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5mdW5jdGlvbiBTY2hlbWFPYmplY3RJZChrZXksIG9wdGlvbnMpIHtcbiAgY29uc3QgaXNLZXlIZXhTdHIgPSB0eXBlb2Yga2V5ID09PSAnc3RyaW5nJyAmJiBrZXkubGVuZ3RoID09PSAyNCAmJiAvXlthLWYwLTldKyQvaS50ZXN0KGtleSk7XG4gIGNvbnN0IHN1cHByZXNzV2FybmluZyA9IG9wdGlvbnMgJiYgb3B0aW9ucy5zdXBwcmVzc1dhcm5pbmc7XG4gIGlmICgoaXNLZXlIZXhTdHIgfHwgdHlwZW9mIGtleSA9PT0gJ3VuZGVmaW5lZCcpICYmICFzdXBwcmVzc1dhcm5pbmcpIHtcbiAgICB1dGlscy53YXJuKCdtb25nb29zZTogVG8gY3JlYXRlIGEgbmV3IE9iamVjdElkIHBsZWFzZSB0cnkgJyArXG4gICAgICAnYE1vbmdvb3NlLlR5cGVzLk9iamVjdElkYCBpbnN0ZWFkIG9mIHVzaW5nICcgK1xuICAgICAgJ2BNb25nb29zZS5TY2hlbWEuT2JqZWN0SWRgLiBTZXQgdGhlIGBzdXBwcmVzc1dhcm5pbmdgIG9wdGlvbiBpZiAnICtcbiAgICAgICd5b3VcXCdyZSB0cnlpbmcgdG8gY3JlYXRlIGEgaGV4IGNoYXIgcGF0aCBpbiB5b3VyIHNjaGVtYS4nKTtcbiAgfVxuICBTY2hlbWFUeXBlLmNhbGwodGhpcywga2V5LCBvcHRpb25zLCAnT2JqZWN0SWQnKTtcbn1cblxuLyoqXG4gKiBUaGlzIHNjaGVtYSB0eXBlJ3MgbmFtZSwgdG8gZGVmZW5kIGFnYWluc3QgbWluaWZpZXJzIHRoYXQgbWFuZ2xlXG4gKiBmdW5jdGlvbiBuYW1lcy5cbiAqXG4gKiBAYXBpIHB1YmxpY1xuICovXG5TY2hlbWFPYmplY3RJZC5zY2hlbWFOYW1lID0gJ09iamVjdElkJztcblxuU2NoZW1hT2JqZWN0SWQuZGVmYXVsdE9wdGlvbnMgPSB7fTtcblxuLyohXG4gKiBJbmhlcml0cyBmcm9tIFNjaGVtYVR5cGUuXG4gKi9cblNjaGVtYU9iamVjdElkLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoU2NoZW1hVHlwZS5wcm90b3R5cGUpO1xuU2NoZW1hT2JqZWN0SWQucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gU2NoZW1hT2JqZWN0SWQ7XG5TY2hlbWFPYmplY3RJZC5wcm90b3R5cGUuT3B0aW9uc0NvbnN0cnVjdG9yID0gU2NoZW1hT2JqZWN0SWRPcHRpb25zO1xuXG4vKipcbiAqIEF0dGFjaGVzIGEgZ2V0dGVyIGZvciBhbGwgT2JqZWN0SWQgaW5zdGFuY2VzXG4gKlxuICogIyMjIyBFeGFtcGxlOlxuICpcbiAqICAgICAvLyBBbHdheXMgY29udmVydCB0byBzdHJpbmcgd2hlbiBnZXR0aW5nIGFuIE9iamVjdElkXG4gKiAgICAgbW9uZ29vc2UuT2JqZWN0SWQuZ2V0KHYgPT4gdi50b1N0cmluZygpKTtcbiAqXG4gKiAgICAgY29uc3QgTW9kZWwgPSBtb25nb29zZS5tb2RlbCgnVGVzdCcsIG5ldyBTY2hlbWEoe30pKTtcbiAqICAgICB0eXBlb2YgKG5ldyBNb2RlbCh7fSkuX2lkKTsgLy8gJ3N0cmluZydcbiAqXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBnZXR0ZXJcbiAqIEByZXR1cm4ge3RoaXN9XG4gKiBAZnVuY3Rpb24gZ2V0XG4gKiBAc3RhdGljXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cblNjaGVtYU9iamVjdElkLmdldCA9IFNjaGVtYVR5cGUuZ2V0O1xuXG4vKipcbiAqIFNldHMgYSBkZWZhdWx0IG9wdGlvbiBmb3IgYWxsIE9iamVjdElkIGluc3RhbmNlcy5cbiAqXG4gKiAjIyMjIEV4YW1wbGU6XG4gKlxuICogICAgIC8vIE1ha2UgYWxsIG9iamVjdCBpZHMgaGF2ZSBvcHRpb24gYHJlcXVpcmVkYCBlcXVhbCB0byB0cnVlLlxuICogICAgIG1vbmdvb3NlLlNjaGVtYS5PYmplY3RJZC5zZXQoJ3JlcXVpcmVkJywgdHJ1ZSk7XG4gKlxuICogICAgIGNvbnN0IE9yZGVyID0gbW9uZ29vc2UubW9kZWwoJ09yZGVyJywgbmV3IFNjaGVtYSh7IHVzZXJJZDogT2JqZWN0SWQgfSkpO1xuICogICAgIG5ldyBPcmRlcih7IH0pLnZhbGlkYXRlU3luYygpLmVycm9ycy51c2VySWQubWVzc2FnZTsgLy8gUGF0aCBgdXNlcklkYCBpcyByZXF1aXJlZC5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gb3B0aW9uIFRoZSBvcHRpb24geW91J2QgbGlrZSB0byBzZXQgdGhlIHZhbHVlIGZvclxuICogQHBhcmFtIHtBbnl9IHZhbHVlIHZhbHVlIGZvciBvcHRpb25cbiAqIEByZXR1cm4ge3VuZGVmaW5lZH1cbiAqIEBmdW5jdGlvbiBzZXRcbiAqIEBzdGF0aWNcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuU2NoZW1hT2JqZWN0SWQuc2V0ID0gU2NoZW1hVHlwZS5zZXQ7XG5cblNjaGVtYU9iamVjdElkLnNldHRlcnMgPSBbXTtcblxuLyoqXG4gKiBBZGRzIGFuIGF1dG8tZ2VuZXJhdGVkIE9iamVjdElkIGRlZmF1bHQgaWYgdHVybk9uIGlzIHRydWUuXG4gKiBAcGFyYW0ge0Jvb2xlYW59IHR1cm5PbiBhdXRvIGdlbmVyYXRlZCBPYmplY3RJZCBkZWZhdWx0c1xuICogQGFwaSBwdWJsaWNcbiAqIEByZXR1cm4ge1NjaGVtYVR5cGV9IHRoaXNcbiAqL1xuXG5TY2hlbWFPYmplY3RJZC5wcm90b3R5cGUuYXV0byA9IGZ1bmN0aW9uKHR1cm5Pbikge1xuICBpZiAodHVybk9uKSB7XG4gICAgdGhpcy5kZWZhdWx0KGRlZmF1bHRJZCk7XG4gICAgdGhpcy5zZXQocmVzZXRJZCk7XG4gIH1cblxuICByZXR1cm4gdGhpcztcbn07XG5cbi8qIVxuICogaWdub3JlXG4gKi9cblxuU2NoZW1hT2JqZWN0SWQuX2NoZWNrUmVxdWlyZWQgPSB2ID0+IGlzQnNvblR5cGUodiwgJ09iamVjdElkJyk7XG5cbi8qIVxuICogaWdub3JlXG4gKi9cblxuU2NoZW1hT2JqZWN0SWQuX2Nhc3QgPSBjYXN0T2JqZWN0SWQ7XG5cbi8qKlxuICogR2V0L3NldCB0aGUgZnVuY3Rpb24gdXNlZCB0byBjYXN0IGFyYml0cmFyeSB2YWx1ZXMgdG8gb2JqZWN0aWRzLlxuICpcbiAqICMjIyMgRXhhbXBsZTpcbiAqXG4gKiAgICAgLy8gTWFrZSBNb25nb29zZSBvbmx5IHRyeSB0byBjYXN0IGxlbmd0aCAyNCBzdHJpbmdzLiBCeSBkZWZhdWx0LCBhbnkgMTJcbiAqICAgICAvLyBjaGFyIHN0cmluZyBpcyBhIHZhbGlkIE9iamVjdElkLlxuICogICAgIGNvbnN0IG9yaWdpbmFsID0gbW9uZ29vc2UuT2JqZWN0SWQuY2FzdCgpO1xuICogICAgIG1vbmdvb3NlLk9iamVjdElkLmNhc3QodiA9PiB7XG4gKiAgICAgICBhc3NlcnQub2sodHlwZW9mIHYgIT09ICdzdHJpbmcnIHx8IHYubGVuZ3RoID09PSAyNCk7XG4gKiAgICAgICByZXR1cm4gb3JpZ2luYWwodik7XG4gKiAgICAgfSk7XG4gKlxuICogICAgIC8vIE9yIGRpc2FibGUgY2FzdGluZyBlbnRpcmVseVxuICogICAgIG1vbmdvb3NlLk9iamVjdElkLmNhc3QoZmFsc2UpO1xuICpcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGNhc3RlclxuICogQHJldHVybiB7RnVuY3Rpb259XG4gKiBAZnVuY3Rpb24gZ2V0XG4gKiBAc3RhdGljXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cblNjaGVtYU9iamVjdElkLmNhc3QgPSBmdW5jdGlvbiBjYXN0KGNhc3Rlcikge1xuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMCkge1xuICAgIHJldHVybiB0aGlzLl9jYXN0O1xuICB9XG4gIGlmIChjYXN0ZXIgPT09IGZhbHNlKSB7XG4gICAgY2FzdGVyID0gdGhpcy5fZGVmYXVsdENhc3RlcjtcbiAgfVxuICB0aGlzLl9jYXN0ID0gY2FzdGVyO1xuXG4gIHJldHVybiB0aGlzLl9jYXN0O1xufTtcblxuLyohXG4gKiBpZ25vcmVcbiAqL1xuXG5TY2hlbWFPYmplY3RJZC5fZGVmYXVsdENhc3RlciA9IHYgPT4ge1xuICBpZiAoIShpc0Jzb25UeXBlKHYsICdPYmplY3RJZCcpKSkge1xuICAgIHRocm93IG5ldyBFcnJvcih2ICsgJyBpcyBub3QgYW4gaW5zdGFuY2Ugb2YgT2JqZWN0SWQnKTtcbiAgfVxuICByZXR1cm4gdjtcbn07XG5cbi8qKlxuICogT3ZlcnJpZGUgdGhlIGZ1bmN0aW9uIHRoZSByZXF1aXJlZCB2YWxpZGF0b3IgdXNlcyB0byBjaGVjayB3aGV0aGVyIGEgc3RyaW5nXG4gKiBwYXNzZXMgdGhlIGByZXF1aXJlZGAgY2hlY2suXG4gKlxuICogIyMjIyBFeGFtcGxlOlxuICpcbiAqICAgICAvLyBBbGxvdyBlbXB0eSBzdHJpbmdzIHRvIHBhc3MgYHJlcXVpcmVkYCBjaGVja1xuICogICAgIG1vbmdvb3NlLlNjaGVtYS5UeXBlcy5TdHJpbmcuY2hlY2tSZXF1aXJlZCh2ID0+IHYgIT0gbnVsbCk7XG4gKlxuICogICAgIGNvbnN0IE0gPSBtb25nb29zZS5tb2RlbCh7IHN0cjogeyB0eXBlOiBTdHJpbmcsIHJlcXVpcmVkOiB0cnVlIH0gfSk7XG4gKiAgICAgbmV3IE0oeyBzdHI6ICcnIH0pLnZhbGlkYXRlU3luYygpOyAvLyBgbnVsbGAsIHZhbGlkYXRpb24gcGFzc2VzIVxuICpcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuXG4gKiBAcmV0dXJuIHtGdW5jdGlvbn1cbiAqIEBmdW5jdGlvbiBjaGVja1JlcXVpcmVkXG4gKiBAc3RhdGljXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cblNjaGVtYU9iamVjdElkLmNoZWNrUmVxdWlyZWQgPSBTY2hlbWFUeXBlLmNoZWNrUmVxdWlyZWQ7XG5cbi8qKlxuICogQ2hlY2sgaWYgdGhlIGdpdmVuIHZhbHVlIHNhdGlzZmllcyBhIHJlcXVpcmVkIHZhbGlkYXRvci5cbiAqXG4gKiBAcGFyYW0ge0FueX0gdmFsdWVcbiAqIEBwYXJhbSB7RG9jdW1lbnR9IGRvY1xuICogQHJldHVybiB7Qm9vbGVhbn1cbiAqIEBhcGkgcHVibGljXG4gKi9cblxuU2NoZW1hT2JqZWN0SWQucHJvdG90eXBlLmNoZWNrUmVxdWlyZWQgPSBmdW5jdGlvbiBjaGVja1JlcXVpcmVkKHZhbHVlLCBkb2MpIHtcbiAgaWYgKFNjaGVtYVR5cGUuX2lzUmVmKHRoaXMsIHZhbHVlLCBkb2MsIHRydWUpKSB7XG4gICAgcmV0dXJuICEhdmFsdWU7XG4gIH1cblxuICAvLyBgcmVxdWlyZSgndXRpbCcpLmluaGVyaXRzKClgIGRvZXMgKipub3QqKiBjb3B5IHN0YXRpYyBwcm9wZXJ0aWVzLCBhbmRcbiAgLy8gcGx1Z2lucyBsaWtlIG1vbmdvb3NlLWZsb2F0IHVzZSBgaW5oZXJpdHMoKWAgZm9yIHByZS1FUzYuXG4gIGNvbnN0IF9jaGVja1JlcXVpcmVkID0gdHlwZW9mIHRoaXMuY29uc3RydWN0b3IuY2hlY2tSZXF1aXJlZCA9PT0gJ2Z1bmN0aW9uJyA/XG4gICAgdGhpcy5jb25zdHJ1Y3Rvci5jaGVja1JlcXVpcmVkKCkgOlxuICAgIFNjaGVtYU9iamVjdElkLmNoZWNrUmVxdWlyZWQoKTtcblxuICByZXR1cm4gX2NoZWNrUmVxdWlyZWQodmFsdWUpO1xufTtcblxuLyoqXG4gKiBDYXN0cyB0byBPYmplY3RJZFxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSB2YWx1ZVxuICogQHBhcmFtIHtPYmplY3R9IGRvY1xuICogQHBhcmFtIHtCb29sZWFufSBpbml0IHdoZXRoZXIgdGhpcyBpcyBhbiBpbml0aWFsaXphdGlvbiBjYXN0XG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5TY2hlbWFPYmplY3RJZC5wcm90b3R5cGUuY2FzdCA9IGZ1bmN0aW9uKHZhbHVlLCBkb2MsIGluaXQpIHtcbiAgaWYgKCEoaXNCc29uVHlwZSh2YWx1ZSwgJ09iamVjdElkJykpICYmIFNjaGVtYVR5cGUuX2lzUmVmKHRoaXMsIHZhbHVlLCBkb2MsIGluaXQpKSB7XG4gICAgLy8gd2FpdCEgd2UgbWF5IG5lZWQgdG8gY2FzdCB0aGlzIHRvIGEgZG9jdW1lbnRcbiAgICBpZiAoKGdldENvbnN0cnVjdG9yTmFtZSh2YWx1ZSkgfHwgJycpLnRvTG93ZXJDYXNlKCkgPT09ICdvYmplY3RpZCcpIHtcbiAgICAgIHJldHVybiBuZXcgb2lkKHZhbHVlLnRvSGV4U3RyaW5nKCkpO1xuICAgIH1cblxuICAgIGlmICh2YWx1ZSA9PSBudWxsIHx8IHV0aWxzLmlzTm9uQnVpbHRpbk9iamVjdCh2YWx1ZSkpIHtcbiAgICAgIHJldHVybiB0aGlzLl9jYXN0UmVmKHZhbHVlLCBkb2MsIGluaXQpO1xuICAgIH1cbiAgfVxuXG4gIGxldCBjYXN0T2JqZWN0SWQ7XG4gIGlmICh0eXBlb2YgdGhpcy5fY2FzdEZ1bmN0aW9uID09PSAnZnVuY3Rpb24nKSB7XG4gICAgY2FzdE9iamVjdElkID0gdGhpcy5fY2FzdEZ1bmN0aW9uO1xuICB9IGVsc2UgaWYgKHR5cGVvZiB0aGlzLmNvbnN0cnVjdG9yLmNhc3QgPT09ICdmdW5jdGlvbicpIHtcbiAgICBjYXN0T2JqZWN0SWQgPSB0aGlzLmNvbnN0cnVjdG9yLmNhc3QoKTtcbiAgfSBlbHNlIHtcbiAgICBjYXN0T2JqZWN0SWQgPSBTY2hlbWFPYmplY3RJZC5jYXN0KCk7XG4gIH1cblxuICB0cnkge1xuICAgIHJldHVybiBjYXN0T2JqZWN0SWQodmFsdWUpO1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIHRocm93IG5ldyBDYXN0RXJyb3IoJ09iamVjdElkJywgdmFsdWUsIHRoaXMucGF0aCwgZXJyb3IsIHRoaXMpO1xuICB9XG59O1xuXG4vKiFcbiAqIGlnbm9yZVxuICovXG5cbmZ1bmN0aW9uIGhhbmRsZVNpbmdsZSh2YWwpIHtcbiAgcmV0dXJuIHRoaXMuY2FzdCh2YWwpO1xufVxuXG5TY2hlbWFPYmplY3RJZC5wcm90b3R5cGUuJGNvbmRpdGlvbmFsSGFuZGxlcnMgPVxuICAgIHV0aWxzLm9wdGlvbnMoU2NoZW1hVHlwZS5wcm90b3R5cGUuJGNvbmRpdGlvbmFsSGFuZGxlcnMsIHtcbiAgICAgICRndDogaGFuZGxlU2luZ2xlLFxuICAgICAgJGd0ZTogaGFuZGxlU2luZ2xlLFxuICAgICAgJGx0OiBoYW5kbGVTaW5nbGUsXG4gICAgICAkbHRlOiBoYW5kbGVTaW5nbGVcbiAgICB9KTtcblxuLyohXG4gKiBpZ25vcmVcbiAqL1xuXG5mdW5jdGlvbiBkZWZhdWx0SWQoKSB7XG4gIHJldHVybiBuZXcgb2lkKCk7XG59XG5cbmRlZmF1bHRJZC4kcnVuQmVmb3JlU2V0dGVycyA9IHRydWU7XG5cbmZ1bmN0aW9uIHJlc2V0SWQodikge1xuICBEb2N1bWVudCB8fCAoRG9jdW1lbnQgPSByZXF1aXJlKCcuLi9kb2N1bWVudCcpKTtcblxuICBpZiAodGhpcyBpbnN0YW5jZW9mIERvY3VtZW50KSB7XG4gICAgaWYgKHYgPT09IHZvaWQgMCkge1xuICAgICAgY29uc3QgX3YgPSBuZXcgb2lkKCk7XG4gICAgICByZXR1cm4gX3Y7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHY7XG59XG5cbi8qIVxuICogTW9kdWxlIGV4cG9ydHMuXG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSBTY2hlbWFPYmplY3RJZDtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/mongoose/lib/schema/objectId.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/mongoose/lib/schema/operators/bitwise.js":
/*!***************************************************************!*\
  !*** ./node_modules/mongoose/lib/schema/operators/bitwise.js ***!
  \***************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("/*!\n * Module requirements.\n */\n\n\n\nconst CastError = __webpack_require__(/*! ../../error/cast */ \"(ssr)/./node_modules/mongoose/lib/error/cast.js\");\n\n/*!\n * ignore\n */\n\nfunction handleBitwiseOperator(val) {\n  const _this = this;\n  if (Array.isArray(val)) {\n    return val.map(function(v) {\n      return _castNumber(_this.path, v);\n    });\n  } else if (Buffer.isBuffer(val)) {\n    return val;\n  }\n  // Assume trying to cast to number\n  return _castNumber(_this.path, val);\n}\n\n/*!\n * ignore\n */\n\nfunction _castNumber(path, num) {\n  const v = Number(num);\n  if (isNaN(v)) {\n    throw new CastError('number', num, path);\n  }\n  return v;\n}\n\nmodule.exports = handleBitwiseOperator;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbW9uZ29vc2UvbGliL3NjaGVtYS9vcGVyYXRvcnMvYml0d2lzZS5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7O0FBRWE7O0FBRWIsa0JBQWtCLG1CQUFPLENBQUMseUVBQWtCOztBQUU1QztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9hcHAxLy4vbm9kZV9tb2R1bGVzL21vbmdvb3NlL2xpYi9zY2hlbWEvb3BlcmF0b3JzL2JpdHdpc2UuanM/MWRmOCJdLCJzb3VyY2VzQ29udGVudCI6WyIvKiFcbiAqIE1vZHVsZSByZXF1aXJlbWVudHMuXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG5jb25zdCBDYXN0RXJyb3IgPSByZXF1aXJlKCcuLi8uLi9lcnJvci9jYXN0Jyk7XG5cbi8qIVxuICogaWdub3JlXG4gKi9cblxuZnVuY3Rpb24gaGFuZGxlQml0d2lzZU9wZXJhdG9yKHZhbCkge1xuICBjb25zdCBfdGhpcyA9IHRoaXM7XG4gIGlmIChBcnJheS5pc0FycmF5KHZhbCkpIHtcbiAgICByZXR1cm4gdmFsLm1hcChmdW5jdGlvbih2KSB7XG4gICAgICByZXR1cm4gX2Nhc3ROdW1iZXIoX3RoaXMucGF0aCwgdik7XG4gICAgfSk7XG4gIH0gZWxzZSBpZiAoQnVmZmVyLmlzQnVmZmVyKHZhbCkpIHtcbiAgICByZXR1cm4gdmFsO1xuICB9XG4gIC8vIEFzc3VtZSB0cnlpbmcgdG8gY2FzdCB0byBudW1iZXJcbiAgcmV0dXJuIF9jYXN0TnVtYmVyKF90aGlzLnBhdGgsIHZhbCk7XG59XG5cbi8qIVxuICogaWdub3JlXG4gKi9cblxuZnVuY3Rpb24gX2Nhc3ROdW1iZXIocGF0aCwgbnVtKSB7XG4gIGNvbnN0IHYgPSBOdW1iZXIobnVtKTtcbiAgaWYgKGlzTmFOKHYpKSB7XG4gICAgdGhyb3cgbmV3IENhc3RFcnJvcignbnVtYmVyJywgbnVtLCBwYXRoKTtcbiAgfVxuICByZXR1cm4gdjtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBoYW5kbGVCaXR3aXNlT3BlcmF0b3I7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/mongoose/lib/schema/operators/bitwise.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/mongoose/lib/schema/operators/exists.js":
/*!**************************************************************!*\
  !*** ./node_modules/mongoose/lib/schema/operators/exists.js ***!
  \**************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\n\nconst castBoolean = __webpack_require__(/*! ../../cast/boolean */ \"(ssr)/./node_modules/mongoose/lib/cast/boolean.js\");\n\n/*!\n * ignore\n */\n\nmodule.exports = function(val) {\n  const path = this != null ? this.path : null;\n  return castBoolean(val, path);\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbW9uZ29vc2UvbGliL3NjaGVtYS9vcGVyYXRvcnMvZXhpc3RzLmpzIiwibWFwcGluZ3MiOiJBQUFhOztBQUViLG9CQUFvQixtQkFBTyxDQUFDLDZFQUFvQjs7QUFFaEQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vYXBwMS8uL25vZGVfbW9kdWxlcy9tb25nb29zZS9saWIvc2NoZW1hL29wZXJhdG9ycy9leGlzdHMuanM/OTE5MCJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbmNvbnN0IGNhc3RCb29sZWFuID0gcmVxdWlyZSgnLi4vLi4vY2FzdC9ib29sZWFuJyk7XG5cbi8qIVxuICogaWdub3JlXG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbih2YWwpIHtcbiAgY29uc3QgcGF0aCA9IHRoaXMgIT0gbnVsbCA/IHRoaXMucGF0aCA6IG51bGw7XG4gIHJldHVybiBjYXN0Qm9vbGVhbih2YWwsIHBhdGgpO1xufTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/mongoose/lib/schema/operators/exists.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/mongoose/lib/schema/operators/geospatial.js":
/*!******************************************************************!*\
  !*** ./node_modules/mongoose/lib/schema/operators/geospatial.js ***!
  \******************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("/*!\n * Module requirements.\n */\n\n\n\nconst castArraysOfNumbers = (__webpack_require__(/*! ./helpers */ \"(ssr)/./node_modules/mongoose/lib/schema/operators/helpers.js\").castArraysOfNumbers);\nconst castToNumber = (__webpack_require__(/*! ./helpers */ \"(ssr)/./node_modules/mongoose/lib/schema/operators/helpers.js\").castToNumber);\n\n/*!\n * ignore\n */\n\nexports.cast$geoIntersects = cast$geoIntersects;\nexports.cast$near = cast$near;\nexports.cast$within = cast$within;\n\nfunction cast$near(val) {\n  const SchemaArray = __webpack_require__(/*! ../array */ \"(ssr)/./node_modules/mongoose/lib/schema/array.js\");\n\n  if (Array.isArray(val)) {\n    castArraysOfNumbers(val, this);\n    return val;\n  }\n\n  _castMinMaxDistance(this, val);\n\n  if (val && val.$geometry) {\n    return cast$geometry(val, this);\n  }\n\n  if (!Array.isArray(val)) {\n    throw new TypeError('$near must be either an array or an object ' +\n      'with a $geometry property');\n  }\n\n  return SchemaArray.prototype.castForQuery.call(this, null, val);\n}\n\nfunction cast$geometry(val, self) {\n  switch (val.$geometry.type) {\n    case 'Polygon':\n    case 'LineString':\n    case 'Point':\n      castArraysOfNumbers(val.$geometry.coordinates, self);\n      break;\n    default:\n      // ignore unknowns\n      break;\n  }\n\n  _castMinMaxDistance(self, val);\n\n  return val;\n}\n\nfunction cast$within(val) {\n  _castMinMaxDistance(this, val);\n\n  if (val.$box || val.$polygon) {\n    const type = val.$box ? '$box' : '$polygon';\n    val[type].forEach(arr => {\n      if (!Array.isArray(arr)) {\n        const msg = 'Invalid $within $box argument. '\n            + 'Expected an array, received ' + arr;\n        throw new TypeError(msg);\n      }\n      arr.forEach((v, i) => {\n        arr[i] = castToNumber.call(this, v);\n      });\n    });\n  } else if (val.$center || val.$centerSphere) {\n    const type = val.$center ? '$center' : '$centerSphere';\n    val[type].forEach((item, i) => {\n      if (Array.isArray(item)) {\n        item.forEach((v, j) => {\n          item[j] = castToNumber.call(this, v);\n        });\n      } else {\n        val[type][i] = castToNumber.call(this, item);\n      }\n    });\n  } else if (val.$geometry) {\n    cast$geometry(val, this);\n  }\n\n  return val;\n}\n\nfunction cast$geoIntersects(val) {\n  const geo = val.$geometry;\n  if (!geo) {\n    return;\n  }\n\n  cast$geometry(val, this);\n  return val;\n}\n\nfunction _castMinMaxDistance(self, val) {\n  if (val.$maxDistance) {\n    val.$maxDistance = castToNumber.call(self, val.$maxDistance);\n  }\n  if (val.$minDistance) {\n    val.$minDistance = castToNumber.call(self, val.$minDistance);\n  }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbW9uZ29vc2UvbGliL3NjaGVtYS9vcGVyYXRvcnMvZ2Vvc3BhdGlhbC5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7O0FBRWE7O0FBRWIsNEJBQTRCLDJIQUF3QztBQUNwRSxxQkFBcUIsb0hBQWlDOztBQUV0RDtBQUNBO0FBQ0E7O0FBRUEsMEJBQTBCO0FBQzFCLGlCQUFpQjtBQUNqQixtQkFBbUI7O0FBRW5CO0FBQ0Esc0JBQXNCLG1CQUFPLENBQUMsbUVBQVU7O0FBRXhDO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTCxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxRQUFRO0FBQ1I7QUFDQTtBQUNBLEtBQUs7QUFDTCxJQUFJO0FBQ0o7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9hcHAxLy4vbm9kZV9tb2R1bGVzL21vbmdvb3NlL2xpYi9zY2hlbWEvb3BlcmF0b3JzL2dlb3NwYXRpYWwuanM/YzZkNyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKiFcbiAqIE1vZHVsZSByZXF1aXJlbWVudHMuXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG5jb25zdCBjYXN0QXJyYXlzT2ZOdW1iZXJzID0gcmVxdWlyZSgnLi9oZWxwZXJzJykuY2FzdEFycmF5c09mTnVtYmVycztcbmNvbnN0IGNhc3RUb051bWJlciA9IHJlcXVpcmUoJy4vaGVscGVycycpLmNhc3RUb051bWJlcjtcblxuLyohXG4gKiBpZ25vcmVcbiAqL1xuXG5leHBvcnRzLmNhc3QkZ2VvSW50ZXJzZWN0cyA9IGNhc3QkZ2VvSW50ZXJzZWN0cztcbmV4cG9ydHMuY2FzdCRuZWFyID0gY2FzdCRuZWFyO1xuZXhwb3J0cy5jYXN0JHdpdGhpbiA9IGNhc3Qkd2l0aGluO1xuXG5mdW5jdGlvbiBjYXN0JG5lYXIodmFsKSB7XG4gIGNvbnN0IFNjaGVtYUFycmF5ID0gcmVxdWlyZSgnLi4vYXJyYXknKTtcblxuICBpZiAoQXJyYXkuaXNBcnJheSh2YWwpKSB7XG4gICAgY2FzdEFycmF5c09mTnVtYmVycyh2YWwsIHRoaXMpO1xuICAgIHJldHVybiB2YWw7XG4gIH1cblxuICBfY2FzdE1pbk1heERpc3RhbmNlKHRoaXMsIHZhbCk7XG5cbiAgaWYgKHZhbCAmJiB2YWwuJGdlb21ldHJ5KSB7XG4gICAgcmV0dXJuIGNhc3QkZ2VvbWV0cnkodmFsLCB0aGlzKTtcbiAgfVxuXG4gIGlmICghQXJyYXkuaXNBcnJheSh2YWwpKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignJG5lYXIgbXVzdCBiZSBlaXRoZXIgYW4gYXJyYXkgb3IgYW4gb2JqZWN0ICcgK1xuICAgICAgJ3dpdGggYSAkZ2VvbWV0cnkgcHJvcGVydHknKTtcbiAgfVxuXG4gIHJldHVybiBTY2hlbWFBcnJheS5wcm90b3R5cGUuY2FzdEZvclF1ZXJ5LmNhbGwodGhpcywgbnVsbCwgdmFsKTtcbn1cblxuZnVuY3Rpb24gY2FzdCRnZW9tZXRyeSh2YWwsIHNlbGYpIHtcbiAgc3dpdGNoICh2YWwuJGdlb21ldHJ5LnR5cGUpIHtcbiAgICBjYXNlICdQb2x5Z29uJzpcbiAgICBjYXNlICdMaW5lU3RyaW5nJzpcbiAgICBjYXNlICdQb2ludCc6XG4gICAgICBjYXN0QXJyYXlzT2ZOdW1iZXJzKHZhbC4kZ2VvbWV0cnkuY29vcmRpbmF0ZXMsIHNlbGYpO1xuICAgICAgYnJlYWs7XG4gICAgZGVmYXVsdDpcbiAgICAgIC8vIGlnbm9yZSB1bmtub3duc1xuICAgICAgYnJlYWs7XG4gIH1cblxuICBfY2FzdE1pbk1heERpc3RhbmNlKHNlbGYsIHZhbCk7XG5cbiAgcmV0dXJuIHZhbDtcbn1cblxuZnVuY3Rpb24gY2FzdCR3aXRoaW4odmFsKSB7XG4gIF9jYXN0TWluTWF4RGlzdGFuY2UodGhpcywgdmFsKTtcblxuICBpZiAodmFsLiRib3ggfHwgdmFsLiRwb2x5Z29uKSB7XG4gICAgY29uc3QgdHlwZSA9IHZhbC4kYm94ID8gJyRib3gnIDogJyRwb2x5Z29uJztcbiAgICB2YWxbdHlwZV0uZm9yRWFjaChhcnIgPT4ge1xuICAgICAgaWYgKCFBcnJheS5pc0FycmF5KGFycikpIHtcbiAgICAgICAgY29uc3QgbXNnID0gJ0ludmFsaWQgJHdpdGhpbiAkYm94IGFyZ3VtZW50LiAnXG4gICAgICAgICAgICArICdFeHBlY3RlZCBhbiBhcnJheSwgcmVjZWl2ZWQgJyArIGFycjtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihtc2cpO1xuICAgICAgfVxuICAgICAgYXJyLmZvckVhY2goKHYsIGkpID0+IHtcbiAgICAgICAgYXJyW2ldID0gY2FzdFRvTnVtYmVyLmNhbGwodGhpcywgdik7XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfSBlbHNlIGlmICh2YWwuJGNlbnRlciB8fCB2YWwuJGNlbnRlclNwaGVyZSkge1xuICAgIGNvbnN0IHR5cGUgPSB2YWwuJGNlbnRlciA/ICckY2VudGVyJyA6ICckY2VudGVyU3BoZXJlJztcbiAgICB2YWxbdHlwZV0uZm9yRWFjaCgoaXRlbSwgaSkgPT4ge1xuICAgICAgaWYgKEFycmF5LmlzQXJyYXkoaXRlbSkpIHtcbiAgICAgICAgaXRlbS5mb3JFYWNoKCh2LCBqKSA9PiB7XG4gICAgICAgICAgaXRlbVtqXSA9IGNhc3RUb051bWJlci5jYWxsKHRoaXMsIHYpO1xuICAgICAgICB9KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhbFt0eXBlXVtpXSA9IGNhc3RUb051bWJlci5jYWxsKHRoaXMsIGl0ZW0pO1xuICAgICAgfVxuICAgIH0pO1xuICB9IGVsc2UgaWYgKHZhbC4kZ2VvbWV0cnkpIHtcbiAgICBjYXN0JGdlb21ldHJ5KHZhbCwgdGhpcyk7XG4gIH1cblxuICByZXR1cm4gdmFsO1xufVxuXG5mdW5jdGlvbiBjYXN0JGdlb0ludGVyc2VjdHModmFsKSB7XG4gIGNvbnN0IGdlbyA9IHZhbC4kZ2VvbWV0cnk7XG4gIGlmICghZ2VvKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgY2FzdCRnZW9tZXRyeSh2YWwsIHRoaXMpO1xuICByZXR1cm4gdmFsO1xufVxuXG5mdW5jdGlvbiBfY2FzdE1pbk1heERpc3RhbmNlKHNlbGYsIHZhbCkge1xuICBpZiAodmFsLiRtYXhEaXN0YW5jZSkge1xuICAgIHZhbC4kbWF4RGlzdGFuY2UgPSBjYXN0VG9OdW1iZXIuY2FsbChzZWxmLCB2YWwuJG1heERpc3RhbmNlKTtcbiAgfVxuICBpZiAodmFsLiRtaW5EaXN0YW5jZSkge1xuICAgIHZhbC4kbWluRGlzdGFuY2UgPSBjYXN0VG9OdW1iZXIuY2FsbChzZWxmLCB2YWwuJG1pbkRpc3RhbmNlKTtcbiAgfVxufVxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/mongoose/lib/schema/operators/geospatial.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/mongoose/lib/schema/operators/helpers.js":
/*!***************************************************************!*\
  !*** ./node_modules/mongoose/lib/schema/operators/helpers.js ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n\n/*!\n * Module requirements.\n */\n\nconst SchemaNumber = __webpack_require__(/*! ../number */ \"(ssr)/./node_modules/mongoose/lib/schema/number.js\");\n\n/*!\n * ignore\n */\n\nexports.castToNumber = castToNumber;\nexports.castArraysOfNumbers = castArraysOfNumbers;\n\n/*!\n * ignore\n */\n\nfunction castToNumber(val) {\n  return SchemaNumber.cast()(val);\n}\n\nfunction castArraysOfNumbers(arr, self) {\n  arr.forEach(function(v, i) {\n    if (Array.isArray(v)) {\n      castArraysOfNumbers(v, self);\n    } else {\n      arr[i] = castToNumber.call(self, v);\n    }\n  });\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbW9uZ29vc2UvbGliL3NjaGVtYS9vcGVyYXRvcnMvaGVscGVycy5qcyIsIm1hcHBpbmdzIjoiQUFBYTs7QUFFYjtBQUNBO0FBQ0E7O0FBRUEscUJBQXFCLG1CQUFPLENBQUMscUVBQVc7O0FBRXhDO0FBQ0E7QUFDQTs7QUFFQSxvQkFBb0I7QUFDcEIsMkJBQTJCOztBQUUzQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxHQUFHO0FBQ0giLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9hcHAxLy4vbm9kZV9tb2R1bGVzL21vbmdvb3NlL2xpYi9zY2hlbWEvb3BlcmF0b3JzL2hlbHBlcnMuanM/ZTBiNyJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbi8qIVxuICogTW9kdWxlIHJlcXVpcmVtZW50cy5cbiAqL1xuXG5jb25zdCBTY2hlbWFOdW1iZXIgPSByZXF1aXJlKCcuLi9udW1iZXInKTtcblxuLyohXG4gKiBpZ25vcmVcbiAqL1xuXG5leHBvcnRzLmNhc3RUb051bWJlciA9IGNhc3RUb051bWJlcjtcbmV4cG9ydHMuY2FzdEFycmF5c09mTnVtYmVycyA9IGNhc3RBcnJheXNPZk51bWJlcnM7XG5cbi8qIVxuICogaWdub3JlXG4gKi9cblxuZnVuY3Rpb24gY2FzdFRvTnVtYmVyKHZhbCkge1xuICByZXR1cm4gU2NoZW1hTnVtYmVyLmNhc3QoKSh2YWwpO1xufVxuXG5mdW5jdGlvbiBjYXN0QXJyYXlzT2ZOdW1iZXJzKGFyciwgc2VsZikge1xuICBhcnIuZm9yRWFjaChmdW5jdGlvbih2LCBpKSB7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkodikpIHtcbiAgICAgIGNhc3RBcnJheXNPZk51bWJlcnModiwgc2VsZik7XG4gICAgfSBlbHNlIHtcbiAgICAgIGFycltpXSA9IGNhc3RUb051bWJlci5jYWxsKHNlbGYsIHYpO1xuICAgIH1cbiAgfSk7XG59XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/mongoose/lib/schema/operators/helpers.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/mongoose/lib/schema/operators/text.js":
/*!************************************************************!*\
  !*** ./node_modules/mongoose/lib/schema/operators/text.js ***!
  \************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\n\nconst CastError = __webpack_require__(/*! ../../error/cast */ \"(ssr)/./node_modules/mongoose/lib/error/cast.js\");\nconst castBoolean = __webpack_require__(/*! ../../cast/boolean */ \"(ssr)/./node_modules/mongoose/lib/cast/boolean.js\");\nconst castString = __webpack_require__(/*! ../../cast/string */ \"(ssr)/./node_modules/mongoose/lib/cast/string.js\");\n\n/**\n * Casts val to an object suitable for `$text`. Throws an error if the object\n * can't be casted.\n *\n * @param {Any} val value to cast\n * @param {String} [path] path to associate with any errors that occured\n * @return {Object} casted object\n * @see https://www.mongodb.com/docs/manual/reference/operator/query/text/\n * @api private\n */\n\nmodule.exports = function(val, path) {\n  if (val == null || typeof val !== 'object') {\n    throw new CastError('$text', val, path);\n  }\n\n  if (val.$search != null) {\n    val.$search = castString(val.$search, path + '.$search');\n  }\n  if (val.$language != null) {\n    val.$language = castString(val.$language, path + '.$language');\n  }\n  if (val.$caseSensitive != null) {\n    val.$caseSensitive = castBoolean(val.$caseSensitive,\n      path + '.$castSensitive');\n  }\n  if (val.$diacriticSensitive != null) {\n    val.$diacriticSensitive = castBoolean(val.$diacriticSensitive,\n      path + '.$diacriticSensitive');\n  }\n\n  return val;\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbW9uZ29vc2UvbGliL3NjaGVtYS9vcGVyYXRvcnMvdGV4dC5qcyIsIm1hcHBpbmdzIjoiQUFBYTs7QUFFYixrQkFBa0IsbUJBQU8sQ0FBQyx5RUFBa0I7QUFDNUMsb0JBQW9CLG1CQUFPLENBQUMsNkVBQW9CO0FBQ2hELG1CQUFtQixtQkFBTyxDQUFDLDJFQUFtQjs7QUFFOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLEtBQUs7QUFDaEIsV0FBVyxRQUFRO0FBQ25CLFlBQVksUUFBUTtBQUNwQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vYXBwMS8uL25vZGVfbW9kdWxlcy9tb25nb29zZS9saWIvc2NoZW1hL29wZXJhdG9ycy90ZXh0LmpzPzk1YmUiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG5jb25zdCBDYXN0RXJyb3IgPSByZXF1aXJlKCcuLi8uLi9lcnJvci9jYXN0Jyk7XG5jb25zdCBjYXN0Qm9vbGVhbiA9IHJlcXVpcmUoJy4uLy4uL2Nhc3QvYm9vbGVhbicpO1xuY29uc3QgY2FzdFN0cmluZyA9IHJlcXVpcmUoJy4uLy4uL2Nhc3Qvc3RyaW5nJyk7XG5cbi8qKlxuICogQ2FzdHMgdmFsIHRvIGFuIG9iamVjdCBzdWl0YWJsZSBmb3IgYCR0ZXh0YC4gVGhyb3dzIGFuIGVycm9yIGlmIHRoZSBvYmplY3RcbiAqIGNhbid0IGJlIGNhc3RlZC5cbiAqXG4gKiBAcGFyYW0ge0FueX0gdmFsIHZhbHVlIHRvIGNhc3RcbiAqIEBwYXJhbSB7U3RyaW5nfSBbcGF0aF0gcGF0aCB0byBhc3NvY2lhdGUgd2l0aCBhbnkgZXJyb3JzIHRoYXQgb2NjdXJlZFxuICogQHJldHVybiB7T2JqZWN0fSBjYXN0ZWQgb2JqZWN0XG4gKiBAc2VlIGh0dHBzOi8vd3d3Lm1vbmdvZGIuY29tL2RvY3MvbWFudWFsL3JlZmVyZW5jZS9vcGVyYXRvci9xdWVyeS90ZXh0L1xuICogQGFwaSBwcml2YXRlXG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbih2YWwsIHBhdGgpIHtcbiAgaWYgKHZhbCA9PSBudWxsIHx8IHR5cGVvZiB2YWwgIT09ICdvYmplY3QnKSB7XG4gICAgdGhyb3cgbmV3IENhc3RFcnJvcignJHRleHQnLCB2YWwsIHBhdGgpO1xuICB9XG5cbiAgaWYgKHZhbC4kc2VhcmNoICE9IG51bGwpIHtcbiAgICB2YWwuJHNlYXJjaCA9IGNhc3RTdHJpbmcodmFsLiRzZWFyY2gsIHBhdGggKyAnLiRzZWFyY2gnKTtcbiAgfVxuICBpZiAodmFsLiRsYW5ndWFnZSAhPSBudWxsKSB7XG4gICAgdmFsLiRsYW5ndWFnZSA9IGNhc3RTdHJpbmcodmFsLiRsYW5ndWFnZSwgcGF0aCArICcuJGxhbmd1YWdlJyk7XG4gIH1cbiAgaWYgKHZhbC4kY2FzZVNlbnNpdGl2ZSAhPSBudWxsKSB7XG4gICAgdmFsLiRjYXNlU2Vuc2l0aXZlID0gY2FzdEJvb2xlYW4odmFsLiRjYXNlU2Vuc2l0aXZlLFxuICAgICAgcGF0aCArICcuJGNhc3RTZW5zaXRpdmUnKTtcbiAgfVxuICBpZiAodmFsLiRkaWFjcml0aWNTZW5zaXRpdmUgIT0gbnVsbCkge1xuICAgIHZhbC4kZGlhY3JpdGljU2Vuc2l0aXZlID0gY2FzdEJvb2xlYW4odmFsLiRkaWFjcml0aWNTZW5zaXRpdmUsXG4gICAgICBwYXRoICsgJy4kZGlhY3JpdGljU2Vuc2l0aXZlJyk7XG4gIH1cblxuICByZXR1cm4gdmFsO1xufTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/mongoose/lib/schema/operators/text.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/mongoose/lib/schema/operators/type.js":
/*!************************************************************!*\
  !*** ./node_modules/mongoose/lib/schema/operators/type.js ***!
  \************************************************************/
/***/ ((module) => {

eval("\n\n/*!\n * ignore\n */\n\nmodule.exports = function(val) {\n  if (Array.isArray(val)) {\n    if (!val.every(v => typeof v === 'number' || typeof v === 'string')) {\n      throw new Error('$type array values must be strings or numbers');\n    }\n    return val;\n  }\n\n  if (typeof val !== 'number' && typeof val !== 'string') {\n    throw new Error('$type parameter must be number, string, or array of numbers and strings');\n  }\n\n  return val;\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbW9uZ29vc2UvbGliL3NjaGVtYS9vcGVyYXRvcnMvdHlwZS5qcyIsIm1hcHBpbmdzIjoiQUFBYTs7QUFFYjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9hcHAxLy4vbm9kZV9tb2R1bGVzL21vbmdvb3NlL2xpYi9zY2hlbWEvb3BlcmF0b3JzL3R5cGUuanM/MDM0ZiJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbi8qIVxuICogaWdub3JlXG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbih2YWwpIHtcbiAgaWYgKEFycmF5LmlzQXJyYXkodmFsKSkge1xuICAgIGlmICghdmFsLmV2ZXJ5KHYgPT4gdHlwZW9mIHYgPT09ICdudW1iZXInIHx8IHR5cGVvZiB2ID09PSAnc3RyaW5nJykpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignJHR5cGUgYXJyYXkgdmFsdWVzIG11c3QgYmUgc3RyaW5ncyBvciBudW1iZXJzJyk7XG4gICAgfVxuICAgIHJldHVybiB2YWw7XG4gIH1cblxuICBpZiAodHlwZW9mIHZhbCAhPT0gJ251bWJlcicgJiYgdHlwZW9mIHZhbCAhPT0gJ3N0cmluZycpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJyR0eXBlIHBhcmFtZXRlciBtdXN0IGJlIG51bWJlciwgc3RyaW5nLCBvciBhcnJheSBvZiBudW1iZXJzIGFuZCBzdHJpbmdzJyk7XG4gIH1cblxuICByZXR1cm4gdmFsO1xufTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/mongoose/lib/schema/operators/type.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/mongoose/lib/schema/string.js":
/*!****************************************************!*\
  !*** ./node_modules/mongoose/lib/schema/string.js ***!
  \****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\n\n/*!\n * Module dependencies.\n */\n\nconst SchemaType = __webpack_require__(/*! ../schemaType */ \"(ssr)/./node_modules/mongoose/lib/schemaType.js\");\nconst MongooseError = __webpack_require__(/*! ../error/index */ \"(ssr)/./node_modules/mongoose/lib/error/index.js\");\nconst SchemaStringOptions = __webpack_require__(/*! ../options/schemaStringOptions */ \"(ssr)/./node_modules/mongoose/lib/options/schemaStringOptions.js\");\nconst castString = __webpack_require__(/*! ../cast/string */ \"(ssr)/./node_modules/mongoose/lib/cast/string.js\");\nconst utils = __webpack_require__(/*! ../utils */ \"(ssr)/./node_modules/mongoose/lib/utils.js\");\nconst isBsonType = __webpack_require__(/*! ../helpers/isBsonType */ \"(ssr)/./node_modules/mongoose/lib/helpers/isBsonType.js\");\n\nconst CastError = SchemaType.CastError;\n\n/**\n * String SchemaType constructor.\n *\n * @param {String} key\n * @param {Object} options\n * @inherits SchemaType\n * @api public\n */\n\nfunction SchemaString(key, options) {\n  this.enumValues = [];\n  this.regExp = null;\n  SchemaType.call(this, key, options, 'String');\n}\n\n/**\n * This schema type's name, to defend against minifiers that mangle\n * function names.\n *\n * @api public\n */\nSchemaString.schemaName = 'String';\n\nSchemaString.defaultOptions = {};\n\n/*!\n * Inherits from SchemaType.\n */\nSchemaString.prototype = Object.create(SchemaType.prototype);\nSchemaString.prototype.constructor = SchemaString;\nObject.defineProperty(SchemaString.prototype, 'OptionsConstructor', {\n  configurable: false,\n  enumerable: false,\n  writable: false,\n  value: SchemaStringOptions\n});\n\n/*!\n * ignore\n */\n\nSchemaString._cast = castString;\n\n/**\n * Get/set the function used to cast arbitrary values to strings.\n *\n * #### Example:\n *\n *     // Throw an error if you pass in an object. Normally, Mongoose allows\n *     // objects with custom `toString()` functions.\n *     const original = mongoose.Schema.Types.String.cast();\n *     mongoose.Schema.Types.String.cast(v => {\n *       assert.ok(v == null || typeof v !== 'object');\n *       return original(v);\n *     });\n *\n *     // Or disable casting entirely\n *     mongoose.Schema.Types.String.cast(false);\n *\n * @param {Function} caster\n * @return {Function}\n * @function get\n * @static\n * @api public\n */\n\nSchemaString.cast = function cast(caster) {\n  if (arguments.length === 0) {\n    return this._cast;\n  }\n  if (caster === false) {\n    caster = this._defaultCaster;\n  }\n  this._cast = caster;\n\n  return this._cast;\n};\n\n/*!\n * ignore\n */\n\nSchemaString._defaultCaster = v => {\n  if (v != null && typeof v !== 'string') {\n    throw new Error();\n  }\n  return v;\n};\n\n/**\n * Attaches a getter for all String instances.\n *\n * #### Example:\n *\n *     // Make all numbers round down\n *     mongoose.Schema.String.get(v => v.toLowerCase());\n *\n *     const Model = mongoose.model('Test', new Schema({ test: String }));\n *     new Model({ test: 'FOO' }).test; // 'foo'\n *\n * @param {Function} getter\n * @return {this}\n * @function get\n * @static\n * @api public\n */\n\nSchemaString.get = SchemaType.get;\n\n/**\n * Sets a default option for all String instances.\n *\n * #### Example:\n *\n *     // Make all strings have option `trim` equal to true.\n *     mongoose.Schema.String.set('trim', true);\n *\n *     const User = mongoose.model('User', new Schema({ name: String }));\n *     new User({ name: '   John Doe   ' }).name; // 'John Doe'\n *\n * @param {String} option The option you'd like to set the value for\n * @param {Any} value value for option\n * @return {undefined}\n * @function set\n * @static\n * @api public\n */\n\nSchemaString.set = SchemaType.set;\n\nSchemaString.setters = [];\n\n/*!\n * ignore\n */\n\nSchemaString._checkRequired = v => (v instanceof String || typeof v === 'string') && v.length;\n\n/**\n * Override the function the required validator uses to check whether a string\n * passes the `required` check.\n *\n * #### Example:\n *\n *     // Allow empty strings to pass `required` check\n *     mongoose.Schema.Types.String.checkRequired(v => v != null);\n *\n *     const M = mongoose.model({ str: { type: String, required: true } });\n *     new M({ str: '' }).validateSync(); // `null`, validation passes!\n *\n * @param {Function} fn\n * @return {Function}\n * @function checkRequired\n * @static\n * @api public\n */\n\nSchemaString.checkRequired = SchemaType.checkRequired;\n\n/**\n * Adds an enum validator\n *\n * #### Example:\n *\n *     const states = ['opening', 'open', 'closing', 'closed']\n *     const s = new Schema({ state: { type: String, enum: states }})\n *     const M = db.model('M', s)\n *     const m = new M({ state: 'invalid' })\n *     m.save(function (err) {\n *       console.error(String(err)) // ValidationError: `invalid` is not a valid enum value for path `state`.\n *       m.state = 'open'\n *       m.save(callback) // success\n *     })\n *\n *     // or with custom error messages\n *     const enum = {\n *       values: ['opening', 'open', 'closing', 'closed'],\n *       message: 'enum validator failed for path `{PATH}` with value `{VALUE}`'\n *     }\n *     const s = new Schema({ state: { type: String, enum: enum })\n *     const M = db.model('M', s)\n *     const m = new M({ state: 'invalid' })\n *     m.save(function (err) {\n *       console.error(String(err)) // ValidationError: enum validator failed for path `state` with value `invalid`\n *       m.state = 'open'\n *       m.save(callback) // success\n *     })\n *\n * @param {...String|Object} [args] enumeration values\n * @return {SchemaType} this\n * @see Customized Error Messages https://mongoosejs.com/docs/api/error.html#Error.messages\n * @see Enums in JavaScript https://masteringjs.io/tutorials/fundamentals/enum\n * @api public\n */\n\nSchemaString.prototype.enum = function() {\n  if (this.enumValidator) {\n    this.validators = this.validators.filter(function(v) {\n      return v.validator !== this.enumValidator;\n    }, this);\n    this.enumValidator = false;\n  }\n\n  if (arguments[0] === void 0 || arguments[0] === false) {\n    return this;\n  }\n\n  let values;\n  let errorMessage;\n\n  if (utils.isObject(arguments[0])) {\n    if (Array.isArray(arguments[0].values)) {\n      values = arguments[0].values;\n      errorMessage = arguments[0].message;\n    } else {\n      values = utils.object.vals(arguments[0]);\n      errorMessage = MongooseError.messages.String.enum;\n    }\n  } else {\n    values = arguments;\n    errorMessage = MongooseError.messages.String.enum;\n  }\n\n  for (const value of values) {\n    if (value !== undefined) {\n      this.enumValues.push(this.cast(value));\n    }\n  }\n\n  const vals = this.enumValues;\n  this.enumValidator = function(v) {\n    return null == v || ~vals.indexOf(v);\n  };\n  this.validators.push({\n    validator: this.enumValidator,\n    message: errorMessage,\n    type: 'enum',\n    enumValues: vals\n  });\n\n  return this;\n};\n\n/**\n * Adds a lowercase [setter](https://mongoosejs.com/docs/api/schematype.html#SchemaType.prototype.set()).\n *\n * #### Example:\n *\n *     const s = new Schema({ email: { type: String, lowercase: true }})\n *     const M = db.model('M', s);\n *     const m = new M({ email: 'SomeEmail@example.COM' });\n *     console.log(m.email) // someemail@example.com\n *     M.find({ email: 'SomeEmail@example.com' }); // Queries by 'someemail@example.com'\n *\n * Note that `lowercase` does **not** affect regular expression queries:\n *\n * #### Example:\n *\n *     // Still queries for documents whose `email` matches the regular\n *     // expression /SomeEmail/. Mongoose does **not** convert the RegExp\n *     // to lowercase.\n *     M.find({ email: /SomeEmail/ });\n *\n * @api public\n * @return {SchemaType} this\n */\n\nSchemaString.prototype.lowercase = function(shouldApply) {\n  if (arguments.length > 0 && !shouldApply) {\n    return this;\n  }\n  return this.set(v => {\n    if (typeof v !== 'string') {\n      v = this.cast(v);\n    }\n    if (v) {\n      return v.toLowerCase();\n    }\n    return v;\n  });\n};\n\n/**\n * Adds an uppercase [setter](https://mongoosejs.com/docs/api/schematype.html#SchemaType.prototype.set()).\n *\n * #### Example:\n *\n *     const s = new Schema({ caps: { type: String, uppercase: true }})\n *     const M = db.model('M', s);\n *     const m = new M({ caps: 'an example' });\n *     console.log(m.caps) // AN EXAMPLE\n *     M.find({ caps: 'an example' }) // Matches documents where caps = 'AN EXAMPLE'\n *\n * Note that `uppercase` does **not** affect regular expression queries:\n *\n * #### Example:\n *\n *     // Mongoose does **not** convert the RegExp to uppercase.\n *     M.find({ email: /an example/ });\n *\n * @api public\n * @return {SchemaType} this\n */\n\nSchemaString.prototype.uppercase = function(shouldApply) {\n  if (arguments.length > 0 && !shouldApply) {\n    return this;\n  }\n  return this.set(v => {\n    if (typeof v !== 'string') {\n      v = this.cast(v);\n    }\n    if (v) {\n      return v.toUpperCase();\n    }\n    return v;\n  });\n};\n\n/**\n * Adds a trim [setter](https://mongoosejs.com/docs/api/schematype.html#SchemaType.prototype.set()).\n *\n * The string value will be [trimmed](https://masteringjs.io/tutorials/fundamentals/trim-string) when set.\n *\n * #### Example:\n *\n *     const s = new Schema({ name: { type: String, trim: true }});\n *     const M = db.model('M', s);\n *     const string = ' some name ';\n *     console.log(string.length); // 11\n *     const m = new M({ name: string });\n *     console.log(m.name.length); // 9\n *\n *     // Equivalent to `findOne({ name: string.trim() })`\n *     M.findOne({ name: string });\n *\n * Note that `trim` does **not** affect regular expression queries:\n *\n * #### Example:\n *\n *     // Mongoose does **not** trim whitespace from the RegExp.\n *     M.find({ name: / some name / });\n *\n * @api public\n * @return {SchemaType} this\n */\n\nSchemaString.prototype.trim = function(shouldTrim) {\n  if (arguments.length > 0 && !shouldTrim) {\n    return this;\n  }\n  return this.set(v => {\n    if (typeof v !== 'string') {\n      v = this.cast(v);\n    }\n    if (v) {\n      return v.trim();\n    }\n    return v;\n  });\n};\n\n/**\n * Sets a minimum length validator.\n *\n * #### Example:\n *\n *     const schema = new Schema({ postalCode: { type: String, minlength: 5 })\n *     const Address = db.model('Address', schema)\n *     const address = new Address({ postalCode: '9512' })\n *     address.save(function (err) {\n *       console.error(err) // validator error\n *       address.postalCode = '95125';\n *       address.save() // success\n *     })\n *\n *     // custom error messages\n *     // We can also use the special {MINLENGTH} token which will be replaced with the minimum allowed length\n *     const minlength = [5, 'The value of path `{PATH}` (`{VALUE}`) is shorter than the minimum allowed length ({MINLENGTH}).'];\n *     const schema = new Schema({ postalCode: { type: String, minlength: minlength })\n *     const Address = mongoose.model('Address', schema);\n *     const address = new Address({ postalCode: '9512' });\n *     address.validate(function (err) {\n *       console.log(String(err)) // ValidationError: The value of path `postalCode` (`9512`) is shorter than the minimum length (5).\n *     })\n *\n * @param {Number} value minimum string length\n * @param {String} [message] optional custom error message\n * @return {SchemaType} this\n * @see Customized Error Messages https://mongoosejs.com/docs/api/error.html#Error.messages\n * @api public\n */\n\nSchemaString.prototype.minlength = function(value, message) {\n  if (this.minlengthValidator) {\n    this.validators = this.validators.filter(function(v) {\n      return v.validator !== this.minlengthValidator;\n    }, this);\n  }\n\n  if (value !== null && value !== undefined) {\n    let msg = message || MongooseError.messages.String.minlength;\n    msg = msg.replace(/{MINLENGTH}/, value);\n    this.validators.push({\n      validator: this.minlengthValidator = function(v) {\n        return v === null || v.length >= value;\n      },\n      message: msg,\n      type: 'minlength',\n      minlength: value\n    });\n  }\n\n  return this;\n};\n\nSchemaString.prototype.minLength = SchemaString.prototype.minlength;\n\n/**\n * Sets a maximum length validator.\n *\n * #### Example:\n *\n *     const schema = new Schema({ postalCode: { type: String, maxlength: 9 })\n *     const Address = db.model('Address', schema)\n *     const address = new Address({ postalCode: '9512512345' })\n *     address.save(function (err) {\n *       console.error(err) // validator error\n *       address.postalCode = '95125';\n *       address.save() // success\n *     })\n *\n *     // custom error messages\n *     // We can also use the special {MAXLENGTH} token which will be replaced with the maximum allowed length\n *     const maxlength = [9, 'The value of path `{PATH}` (`{VALUE}`) exceeds the maximum allowed length ({MAXLENGTH}).'];\n *     const schema = new Schema({ postalCode: { type: String, maxlength: maxlength })\n *     const Address = mongoose.model('Address', schema);\n *     const address = new Address({ postalCode: '9512512345' });\n *     address.validate(function (err) {\n *       console.log(String(err)) // ValidationError: The value of path `postalCode` (`9512512345`) exceeds the maximum allowed length (9).\n *     })\n *\n * @param {Number} value maximum string length\n * @param {String} [message] optional custom error message\n * @return {SchemaType} this\n * @see Customized Error Messages https://mongoosejs.com/docs/api/error.html#Error.messages\n * @api public\n */\n\nSchemaString.prototype.maxlength = function(value, message) {\n  if (this.maxlengthValidator) {\n    this.validators = this.validators.filter(function(v) {\n      return v.validator !== this.maxlengthValidator;\n    }, this);\n  }\n\n  if (value !== null && value !== undefined) {\n    let msg = message || MongooseError.messages.String.maxlength;\n    msg = msg.replace(/{MAXLENGTH}/, value);\n    this.validators.push({\n      validator: this.maxlengthValidator = function(v) {\n        return v === null || v.length <= value;\n      },\n      message: msg,\n      type: 'maxlength',\n      maxlength: value\n    });\n  }\n\n  return this;\n};\n\nSchemaString.prototype.maxLength = SchemaString.prototype.maxlength;\n\n/**\n * Sets a regexp validator.\n *\n * Any value that does not pass `regExp`.test(val) will fail validation.\n *\n * #### Example:\n *\n *     const s = new Schema({ name: { type: String, match: /^a/ }})\n *     const M = db.model('M', s)\n *     const m = new M({ name: 'I am invalid' })\n *     m.validate(function (err) {\n *       console.error(String(err)) // \"ValidationError: Path `name` is invalid (I am invalid).\"\n *       m.name = 'apples'\n *       m.validate(function (err) {\n *         assert.ok(err) // success\n *       })\n *     })\n *\n *     // using a custom error message\n *     const match = [ /\\.html$/, \"That file doesn't end in .html ({VALUE})\" ];\n *     const s = new Schema({ file: { type: String, match: match }})\n *     const M = db.model('M', s);\n *     const m = new M({ file: 'invalid' });\n *     m.validate(function (err) {\n *       console.log(String(err)) // \"ValidationError: That file doesn't end in .html (invalid)\"\n *     })\n *\n * Empty strings, `undefined`, and `null` values always pass the match validator. If you require these values, enable the `required` validator also.\n *\n *     const s = new Schema({ name: { type: String, match: /^a/, required: true }})\n *\n * @param {RegExp} regExp regular expression to test against\n * @param {String} [message] optional custom error message\n * @return {SchemaType} this\n * @see Customized Error Messages https://mongoosejs.com/docs/api/error.html#Error.messages\n * @api public\n */\n\nSchemaString.prototype.match = function match(regExp, message) {\n  // yes, we allow multiple match validators\n\n  const msg = message || MongooseError.messages.String.match;\n\n  const matchValidator = function(v) {\n    if (!regExp) {\n      return false;\n    }\n\n    // In case RegExp happens to have `/g` flag set, we need to reset the\n    // `lastIndex`, otherwise `match` will intermittently fail.\n    regExp.lastIndex = 0;\n\n    const ret = ((v != null && v !== '')\n      ? regExp.test(v)\n      : true);\n    return ret;\n  };\n\n  this.validators.push({\n    validator: matchValidator,\n    message: msg,\n    type: 'regexp',\n    regexp: regExp\n  });\n  return this;\n};\n\n/**\n * Check if the given value satisfies the `required` validator. The value is\n * considered valid if it is a string (that is, not `null` or `undefined`) and\n * has positive length. The `required` validator **will** fail for empty\n * strings.\n *\n * @param {Any} value\n * @param {Document} doc\n * @return {Boolean}\n * @api public\n */\n\nSchemaString.prototype.checkRequired = function checkRequired(value, doc) {\n  if (typeof value === 'object' && SchemaType._isRef(this, value, doc, true)) {\n    return value != null;\n  }\n\n  // `require('util').inherits()` does **not** copy static properties, and\n  // plugins like mongoose-float use `inherits()` for pre-ES6.\n  const _checkRequired = typeof this.constructor.checkRequired === 'function' ?\n    this.constructor.checkRequired() :\n    SchemaString.checkRequired();\n\n  return _checkRequired(value);\n};\n\n/**\n * Casts to String\n *\n * @api private\n */\n\nSchemaString.prototype.cast = function(value, doc, init) {\n  if (typeof value !== 'string' && SchemaType._isRef(this, value, doc, init)) {\n    return this._castRef(value, doc, init);\n  }\n\n  let castString;\n  if (typeof this._castFunction === 'function') {\n    castString = this._castFunction;\n  } else if (typeof this.constructor.cast === 'function') {\n    castString = this.constructor.cast();\n  } else {\n    castString = SchemaString.cast();\n  }\n\n  try {\n    return castString(value);\n  } catch (error) {\n    throw new CastError('string', value, this.path, null, this);\n  }\n};\n\n/*!\n * ignore\n */\n\nfunction handleSingle(val, context) {\n  return this.castForQuery(null, val, context);\n}\n\n/*!\n * ignore\n */\n\nfunction handleArray(val, context) {\n  const _this = this;\n  if (!Array.isArray(val)) {\n    return [this.castForQuery(null, val, context)];\n  }\n  return val.map(function(m) {\n    return _this.castForQuery(null, m, context);\n  });\n}\n\n/*!\n * ignore\n */\n\nfunction handleSingleNoSetters(val) {\n  if (val == null) {\n    return this._castNullish(val);\n  }\n\n  return this.cast(val, this);\n}\n\nconst $conditionalHandlers = utils.options(SchemaType.prototype.$conditionalHandlers, {\n  $all: handleArray,\n  $gt: handleSingle,\n  $gte: handleSingle,\n  $lt: handleSingle,\n  $lte: handleSingle,\n  $options: handleSingleNoSetters,\n  $regex: function handle$regex(val) {\n    if (Object.prototype.toString.call(val) === '[object RegExp]') {\n      return val;\n    }\n\n    return handleSingleNoSetters.call(this, val);\n  },\n  $not: handleSingle\n});\n\nObject.defineProperty(SchemaString.prototype, '$conditionalHandlers', {\n  configurable: false,\n  enumerable: false,\n  writable: false,\n  value: Object.freeze($conditionalHandlers)\n});\n\n/**\n * Casts contents for queries.\n *\n * @param {String} $conditional\n * @param {any} [val]\n * @api private\n */\n\nSchemaString.prototype.castForQuery = function($conditional, val, context) {\n  let handler;\n  if ($conditional != null) {\n    handler = this.$conditionalHandlers[$conditional];\n    if (!handler) {\n      throw new Error('Can\\'t use ' + $conditional + ' with String.');\n    }\n    return handler.call(this, val, context);\n  }\n\n  if (Object.prototype.toString.call(val) === '[object RegExp]' || isBsonType(val, 'BSONRegExp')) {\n    return val;\n  }\n\n  return this.applySetters(val, context);\n};\n\n/*!\n * Module exports.\n */\n\nmodule.exports = SchemaString;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbW9uZ29vc2UvbGliL3NjaGVtYS9zdHJpbmcuanMiLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWI7QUFDQTtBQUNBOztBQUVBLG1CQUFtQixtQkFBTyxDQUFDLHNFQUFlO0FBQzFDLHNCQUFzQixtQkFBTyxDQUFDLHdFQUFnQjtBQUM5Qyw0QkFBNEIsbUJBQU8sQ0FBQyx3R0FBZ0M7QUFDcEUsbUJBQW1CLG1CQUFPLENBQUMsd0VBQWdCO0FBQzNDLGNBQWMsbUJBQU8sQ0FBQyw0REFBVTtBQUNoQyxtQkFBbUIsbUJBQU8sQ0FBQyxzRkFBdUI7O0FBRWxEOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxVQUFVO0FBQ3JCLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseURBQXlELGNBQWM7QUFDdkUsbUJBQW1CLGFBQWEsUUFBUTtBQUN4QztBQUNBLFdBQVcsVUFBVTtBQUNyQixZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7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Qzs7QUFFRDtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsV0FBVyxLQUFLO0FBQ2hCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSIsInNvdXJjZXMiOlsid2VicGFjazovL2FwcDEvLi9ub2RlX21vZHVsZXMvbW9uZ29vc2UvbGliL3NjaGVtYS9zdHJpbmcuanM/MTJkOCJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbi8qIVxuICogTW9kdWxlIGRlcGVuZGVuY2llcy5cbiAqL1xuXG5jb25zdCBTY2hlbWFUeXBlID0gcmVxdWlyZSgnLi4vc2NoZW1hVHlwZScpO1xuY29uc3QgTW9uZ29vc2VFcnJvciA9IHJlcXVpcmUoJy4uL2Vycm9yL2luZGV4Jyk7XG5jb25zdCBTY2hlbWFTdHJpbmdPcHRpb25zID0gcmVxdWlyZSgnLi4vb3B0aW9ucy9zY2hlbWFTdHJpbmdPcHRpb25zJyk7XG5jb25zdCBjYXN0U3RyaW5nID0gcmVxdWlyZSgnLi4vY2FzdC9zdHJpbmcnKTtcbmNvbnN0IHV0aWxzID0gcmVxdWlyZSgnLi4vdXRpbHMnKTtcbmNvbnN0IGlzQnNvblR5cGUgPSByZXF1aXJlKCcuLi9oZWxwZXJzL2lzQnNvblR5cGUnKTtcblxuY29uc3QgQ2FzdEVycm9yID0gU2NoZW1hVHlwZS5DYXN0RXJyb3I7XG5cbi8qKlxuICogU3RyaW5nIFNjaGVtYVR5cGUgY29uc3RydWN0b3IuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IGtleVxuICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcbiAqIEBpbmhlcml0cyBTY2hlbWFUeXBlXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmZ1bmN0aW9uIFNjaGVtYVN0cmluZyhrZXksIG9wdGlvbnMpIHtcbiAgdGhpcy5lbnVtVmFsdWVzID0gW107XG4gIHRoaXMucmVnRXhwID0gbnVsbDtcbiAgU2NoZW1hVHlwZS5jYWxsKHRoaXMsIGtleSwgb3B0aW9ucywgJ1N0cmluZycpO1xufVxuXG4vKipcbiAqIFRoaXMgc2NoZW1hIHR5cGUncyBuYW1lLCB0byBkZWZlbmQgYWdhaW5zdCBtaW5pZmllcnMgdGhhdCBtYW5nbGVcbiAqIGZ1bmN0aW9uIG5hbWVzLlxuICpcbiAqIEBhcGkgcHVibGljXG4gKi9cblNjaGVtYVN0cmluZy5zY2hlbWFOYW1lID0gJ1N0cmluZyc7XG5cblNjaGVtYVN0cmluZy5kZWZhdWx0T3B0aW9ucyA9IHt9O1xuXG4vKiFcbiAqIEluaGVyaXRzIGZyb20gU2NoZW1hVHlwZS5cbiAqL1xuU2NoZW1hU3RyaW5nLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoU2NoZW1hVHlwZS5wcm90b3R5cGUpO1xuU2NoZW1hU3RyaW5nLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFNjaGVtYVN0cmluZztcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShTY2hlbWFTdHJpbmcucHJvdG90eXBlLCAnT3B0aW9uc0NvbnN0cnVjdG9yJywge1xuICBjb25maWd1cmFibGU6IGZhbHNlLFxuICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgd3JpdGFibGU6IGZhbHNlLFxuICB2YWx1ZTogU2NoZW1hU3RyaW5nT3B0aW9uc1xufSk7XG5cbi8qIVxuICogaWdub3JlXG4gKi9cblxuU2NoZW1hU3RyaW5nLl9jYXN0ID0gY2FzdFN0cmluZztcblxuLyoqXG4gKiBHZXQvc2V0IHRoZSBmdW5jdGlvbiB1c2VkIHRvIGNhc3QgYXJiaXRyYXJ5IHZhbHVlcyB0byBzdHJpbmdzLlxuICpcbiAqICMjIyMgRXhhbXBsZTpcbiAqXG4gKiAgICAgLy8gVGhyb3cgYW4gZXJyb3IgaWYgeW91IHBhc3MgaW4gYW4gb2JqZWN0LiBOb3JtYWxseSwgTW9uZ29vc2UgYWxsb3dzXG4gKiAgICAgLy8gb2JqZWN0cyB3aXRoIGN1c3RvbSBgdG9TdHJpbmcoKWAgZnVuY3Rpb25zLlxuICogICAgIGNvbnN0IG9yaWdpbmFsID0gbW9uZ29vc2UuU2NoZW1hLlR5cGVzLlN0cmluZy5jYXN0KCk7XG4gKiAgICAgbW9uZ29vc2UuU2NoZW1hLlR5cGVzLlN0cmluZy5jYXN0KHYgPT4ge1xuICogICAgICAgYXNzZXJ0Lm9rKHYgPT0gbnVsbCB8fCB0eXBlb2YgdiAhPT0gJ29iamVjdCcpO1xuICogICAgICAgcmV0dXJuIG9yaWdpbmFsKHYpO1xuICogICAgIH0pO1xuICpcbiAqICAgICAvLyBPciBkaXNhYmxlIGNhc3RpbmcgZW50aXJlbHlcbiAqICAgICBtb25nb29zZS5TY2hlbWEuVHlwZXMuU3RyaW5nLmNhc3QoZmFsc2UpO1xuICpcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGNhc3RlclxuICogQHJldHVybiB7RnVuY3Rpb259XG4gKiBAZnVuY3Rpb24gZ2V0XG4gKiBAc3RhdGljXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cblNjaGVtYVN0cmluZy5jYXN0ID0gZnVuY3Rpb24gY2FzdChjYXN0ZXIpIHtcbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDApIHtcbiAgICByZXR1cm4gdGhpcy5fY2FzdDtcbiAgfVxuICBpZiAoY2FzdGVyID09PSBmYWxzZSkge1xuICAgIGNhc3RlciA9IHRoaXMuX2RlZmF1bHRDYXN0ZXI7XG4gIH1cbiAgdGhpcy5fY2FzdCA9IGNhc3RlcjtcblxuICByZXR1cm4gdGhpcy5fY2FzdDtcbn07XG5cbi8qIVxuICogaWdub3JlXG4gKi9cblxuU2NoZW1hU3RyaW5nLl9kZWZhdWx0Q2FzdGVyID0gdiA9PiB7XG4gIGlmICh2ICE9IG51bGwgJiYgdHlwZW9mIHYgIT09ICdzdHJpbmcnKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCk7XG4gIH1cbiAgcmV0dXJuIHY7XG59O1xuXG4vKipcbiAqIEF0dGFjaGVzIGEgZ2V0dGVyIGZvciBhbGwgU3RyaW5nIGluc3RhbmNlcy5cbiAqXG4gKiAjIyMjIEV4YW1wbGU6XG4gKlxuICogICAgIC8vIE1ha2UgYWxsIG51bWJlcnMgcm91bmQgZG93blxuICogICAgIG1vbmdvb3NlLlNjaGVtYS5TdHJpbmcuZ2V0KHYgPT4gdi50b0xvd2VyQ2FzZSgpKTtcbiAqXG4gKiAgICAgY29uc3QgTW9kZWwgPSBtb25nb29zZS5tb2RlbCgnVGVzdCcsIG5ldyBTY2hlbWEoeyB0ZXN0OiBTdHJpbmcgfSkpO1xuICogICAgIG5ldyBNb2RlbCh7IHRlc3Q6ICdGT08nIH0pLnRlc3Q7IC8vICdmb28nXG4gKlxuICogQHBhcmFtIHtGdW5jdGlvbn0gZ2V0dGVyXG4gKiBAcmV0dXJuIHt0aGlzfVxuICogQGZ1bmN0aW9uIGdldFxuICogQHN0YXRpY1xuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5TY2hlbWFTdHJpbmcuZ2V0ID0gU2NoZW1hVHlwZS5nZXQ7XG5cbi8qKlxuICogU2V0cyBhIGRlZmF1bHQgb3B0aW9uIGZvciBhbGwgU3RyaW5nIGluc3RhbmNlcy5cbiAqXG4gKiAjIyMjIEV4YW1wbGU6XG4gKlxuICogICAgIC8vIE1ha2UgYWxsIHN0cmluZ3MgaGF2ZSBvcHRpb24gYHRyaW1gIGVxdWFsIHRvIHRydWUuXG4gKiAgICAgbW9uZ29vc2UuU2NoZW1hLlN0cmluZy5zZXQoJ3RyaW0nLCB0cnVlKTtcbiAqXG4gKiAgICAgY29uc3QgVXNlciA9IG1vbmdvb3NlLm1vZGVsKCdVc2VyJywgbmV3IFNjaGVtYSh7IG5hbWU6IFN0cmluZyB9KSk7XG4gKiAgICAgbmV3IFVzZXIoeyBuYW1lOiAnICAgSm9obiBEb2UgICAnIH0pLm5hbWU7IC8vICdKb2huIERvZSdcbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gb3B0aW9uIFRoZSBvcHRpb24geW91J2QgbGlrZSB0byBzZXQgdGhlIHZhbHVlIGZvclxuICogQHBhcmFtIHtBbnl9IHZhbHVlIHZhbHVlIGZvciBvcHRpb25cbiAqIEByZXR1cm4ge3VuZGVmaW5lZH1cbiAqIEBmdW5jdGlvbiBzZXRcbiAqIEBzdGF0aWNcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuU2NoZW1hU3RyaW5nLnNldCA9IFNjaGVtYVR5cGUuc2V0O1xuXG5TY2hlbWFTdHJpbmcuc2V0dGVycyA9IFtdO1xuXG4vKiFcbiAqIGlnbm9yZVxuICovXG5cblNjaGVtYVN0cmluZy5fY2hlY2tSZXF1aXJlZCA9IHYgPT4gKHYgaW5zdGFuY2VvZiBTdHJpbmcgfHwgdHlwZW9mIHYgPT09ICdzdHJpbmcnKSAmJiB2Lmxlbmd0aDtcblxuLyoqXG4gKiBPdmVycmlkZSB0aGUgZnVuY3Rpb24gdGhlIHJlcXVpcmVkIHZhbGlkYXRvciB1c2VzIHRvIGNoZWNrIHdoZXRoZXIgYSBzdHJpbmdcbiAqIHBhc3NlcyB0aGUgYHJlcXVpcmVkYCBjaGVjay5cbiAqXG4gKiAjIyMjIEV4YW1wbGU6XG4gKlxuICogICAgIC8vIEFsbG93IGVtcHR5IHN0cmluZ3MgdG8gcGFzcyBgcmVxdWlyZWRgIGNoZWNrXG4gKiAgICAgbW9uZ29vc2UuU2NoZW1hLlR5cGVzLlN0cmluZy5jaGVja1JlcXVpcmVkKHYgPT4gdiAhPSBudWxsKTtcbiAqXG4gKiAgICAgY29uc3QgTSA9IG1vbmdvb3NlLm1vZGVsKHsgc3RyOiB7IHR5cGU6IFN0cmluZywgcmVxdWlyZWQ6IHRydWUgfSB9KTtcbiAqICAgICBuZXcgTSh7IHN0cjogJycgfSkudmFsaWRhdGVTeW5jKCk7IC8vIGBudWxsYCwgdmFsaWRhdGlvbiBwYXNzZXMhXG4gKlxuICogQHBhcmFtIHtGdW5jdGlvbn0gZm5cbiAqIEByZXR1cm4ge0Z1bmN0aW9ufVxuICogQGZ1bmN0aW9uIGNoZWNrUmVxdWlyZWRcbiAqIEBzdGF0aWNcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuU2NoZW1hU3RyaW5nLmNoZWNrUmVxdWlyZWQgPSBTY2hlbWFUeXBlLmNoZWNrUmVxdWlyZWQ7XG5cbi8qKlxuICogQWRkcyBhbiBlbnVtIHZhbGlkYXRvclxuICpcbiAqICMjIyMgRXhhbXBsZTpcbiAqXG4gKiAgICAgY29uc3Qgc3RhdGVzID0gWydvcGVuaW5nJywgJ29wZW4nLCAnY2xvc2luZycsICdjbG9zZWQnXVxuICogICAgIGNvbnN0IHMgPSBuZXcgU2NoZW1hKHsgc3RhdGU6IHsgdHlwZTogU3RyaW5nLCBlbnVtOiBzdGF0ZXMgfX0pXG4gKiAgICAgY29uc3QgTSA9IGRiLm1vZGVsKCdNJywgcylcbiAqICAgICBjb25zdCBtID0gbmV3IE0oeyBzdGF0ZTogJ2ludmFsaWQnIH0pXG4gKiAgICAgbS5zYXZlKGZ1bmN0aW9uIChlcnIpIHtcbiAqICAgICAgIGNvbnNvbGUuZXJyb3IoU3RyaW5nKGVycikpIC8vIFZhbGlkYXRpb25FcnJvcjogYGludmFsaWRgIGlzIG5vdCBhIHZhbGlkIGVudW0gdmFsdWUgZm9yIHBhdGggYHN0YXRlYC5cbiAqICAgICAgIG0uc3RhdGUgPSAnb3BlbidcbiAqICAgICAgIG0uc2F2ZShjYWxsYmFjaykgLy8gc3VjY2Vzc1xuICogICAgIH0pXG4gKlxuICogICAgIC8vIG9yIHdpdGggY3VzdG9tIGVycm9yIG1lc3NhZ2VzXG4gKiAgICAgY29uc3QgZW51bSA9IHtcbiAqICAgICAgIHZhbHVlczogWydvcGVuaW5nJywgJ29wZW4nLCAnY2xvc2luZycsICdjbG9zZWQnXSxcbiAqICAgICAgIG1lc3NhZ2U6ICdlbnVtIHZhbGlkYXRvciBmYWlsZWQgZm9yIHBhdGggYHtQQVRIfWAgd2l0aCB2YWx1ZSBge1ZBTFVFfWAnXG4gKiAgICAgfVxuICogICAgIGNvbnN0IHMgPSBuZXcgU2NoZW1hKHsgc3RhdGU6IHsgdHlwZTogU3RyaW5nLCBlbnVtOiBlbnVtIH0pXG4gKiAgICAgY29uc3QgTSA9IGRiLm1vZGVsKCdNJywgcylcbiAqICAgICBjb25zdCBtID0gbmV3IE0oeyBzdGF0ZTogJ2ludmFsaWQnIH0pXG4gKiAgICAgbS5zYXZlKGZ1bmN0aW9uIChlcnIpIHtcbiAqICAgICAgIGNvbnNvbGUuZXJyb3IoU3RyaW5nKGVycikpIC8vIFZhbGlkYXRpb25FcnJvcjogZW51bSB2YWxpZGF0b3IgZmFpbGVkIGZvciBwYXRoIGBzdGF0ZWAgd2l0aCB2YWx1ZSBgaW52YWxpZGBcbiAqICAgICAgIG0uc3RhdGUgPSAnb3BlbidcbiAqICAgICAgIG0uc2F2ZShjYWxsYmFjaykgLy8gc3VjY2Vzc1xuICogICAgIH0pXG4gKlxuICogQHBhcmFtIHsuLi5TdHJpbmd8T2JqZWN0fSBbYXJnc10gZW51bWVyYXRpb24gdmFsdWVzXG4gKiBAcmV0dXJuIHtTY2hlbWFUeXBlfSB0aGlzXG4gKiBAc2VlIEN1c3RvbWl6ZWQgRXJyb3IgTWVzc2FnZXMgaHR0cHM6Ly9tb25nb29zZWpzLmNvbS9kb2NzL2FwaS9lcnJvci5odG1sI0Vycm9yLm1lc3NhZ2VzXG4gKiBAc2VlIEVudW1zIGluIEphdmFTY3JpcHQgaHR0cHM6Ly9tYXN0ZXJpbmdqcy5pby90dXRvcmlhbHMvZnVuZGFtZW50YWxzL2VudW1cbiAqIEBhcGkgcHVibGljXG4gKi9cblxuU2NoZW1hU3RyaW5nLnByb3RvdHlwZS5lbnVtID0gZnVuY3Rpb24oKSB7XG4gIGlmICh0aGlzLmVudW1WYWxpZGF0b3IpIHtcbiAgICB0aGlzLnZhbGlkYXRvcnMgPSB0aGlzLnZhbGlkYXRvcnMuZmlsdGVyKGZ1bmN0aW9uKHYpIHtcbiAgICAgIHJldHVybiB2LnZhbGlkYXRvciAhPT0gdGhpcy5lbnVtVmFsaWRhdG9yO1xuICAgIH0sIHRoaXMpO1xuICAgIHRoaXMuZW51bVZhbGlkYXRvciA9IGZhbHNlO1xuICB9XG5cbiAgaWYgKGFyZ3VtZW50c1swXSA9PT0gdm9pZCAwIHx8IGFyZ3VtZW50c1swXSA9PT0gZmFsc2UpIHtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIGxldCB2YWx1ZXM7XG4gIGxldCBlcnJvck1lc3NhZ2U7XG5cbiAgaWYgKHV0aWxzLmlzT2JqZWN0KGFyZ3VtZW50c1swXSkpIHtcbiAgICBpZiAoQXJyYXkuaXNBcnJheShhcmd1bWVudHNbMF0udmFsdWVzKSkge1xuICAgICAgdmFsdWVzID0gYXJndW1lbnRzWzBdLnZhbHVlcztcbiAgICAgIGVycm9yTWVzc2FnZSA9IGFyZ3VtZW50c1swXS5tZXNzYWdlO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YWx1ZXMgPSB1dGlscy5vYmplY3QudmFscyhhcmd1bWVudHNbMF0pO1xuICAgICAgZXJyb3JNZXNzYWdlID0gTW9uZ29vc2VFcnJvci5tZXNzYWdlcy5TdHJpbmcuZW51bTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgdmFsdWVzID0gYXJndW1lbnRzO1xuICAgIGVycm9yTWVzc2FnZSA9IE1vbmdvb3NlRXJyb3IubWVzc2FnZXMuU3RyaW5nLmVudW07XG4gIH1cblxuICBmb3IgKGNvbnN0IHZhbHVlIG9mIHZhbHVlcykge1xuICAgIGlmICh2YWx1ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICB0aGlzLmVudW1WYWx1ZXMucHVzaCh0aGlzLmNhc3QodmFsdWUpKTtcbiAgICB9XG4gIH1cblxuICBjb25zdCB2YWxzID0gdGhpcy5lbnVtVmFsdWVzO1xuICB0aGlzLmVudW1WYWxpZGF0b3IgPSBmdW5jdGlvbih2KSB7XG4gICAgcmV0dXJuIG51bGwgPT0gdiB8fCB+dmFscy5pbmRleE9mKHYpO1xuICB9O1xuICB0aGlzLnZhbGlkYXRvcnMucHVzaCh7XG4gICAgdmFsaWRhdG9yOiB0aGlzLmVudW1WYWxpZGF0b3IsXG4gICAgbWVzc2FnZTogZXJyb3JNZXNzYWdlLFxuICAgIHR5cGU6ICdlbnVtJyxcbiAgICBlbnVtVmFsdWVzOiB2YWxzXG4gIH0pO1xuXG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBBZGRzIGEgbG93ZXJjYXNlIFtzZXR0ZXJdKGh0dHBzOi8vbW9uZ29vc2Vqcy5jb20vZG9jcy9hcGkvc2NoZW1hdHlwZS5odG1sI1NjaGVtYVR5cGUucHJvdG90eXBlLnNldCgpKS5cbiAqXG4gKiAjIyMjIEV4YW1wbGU6XG4gKlxuICogICAgIGNvbnN0IHMgPSBuZXcgU2NoZW1hKHsgZW1haWw6IHsgdHlwZTogU3RyaW5nLCBsb3dlcmNhc2U6IHRydWUgfX0pXG4gKiAgICAgY29uc3QgTSA9IGRiLm1vZGVsKCdNJywgcyk7XG4gKiAgICAgY29uc3QgbSA9IG5ldyBNKHsgZW1haWw6ICdTb21lRW1haWxAZXhhbXBsZS5DT00nIH0pO1xuICogICAgIGNvbnNvbGUubG9nKG0uZW1haWwpIC8vIHNvbWVlbWFpbEBleGFtcGxlLmNvbVxuICogICAgIE0uZmluZCh7IGVtYWlsOiAnU29tZUVtYWlsQGV4YW1wbGUuY29tJyB9KTsgLy8gUXVlcmllcyBieSAnc29tZWVtYWlsQGV4YW1wbGUuY29tJ1xuICpcbiAqIE5vdGUgdGhhdCBgbG93ZXJjYXNlYCBkb2VzICoqbm90KiogYWZmZWN0IHJlZ3VsYXIgZXhwcmVzc2lvbiBxdWVyaWVzOlxuICpcbiAqICMjIyMgRXhhbXBsZTpcbiAqXG4gKiAgICAgLy8gU3RpbGwgcXVlcmllcyBmb3IgZG9jdW1lbnRzIHdob3NlIGBlbWFpbGAgbWF0Y2hlcyB0aGUgcmVndWxhclxuICogICAgIC8vIGV4cHJlc3Npb24gL1NvbWVFbWFpbC8uIE1vbmdvb3NlIGRvZXMgKipub3QqKiBjb252ZXJ0IHRoZSBSZWdFeHBcbiAqICAgICAvLyB0byBsb3dlcmNhc2UuXG4gKiAgICAgTS5maW5kKHsgZW1haWw6IC9Tb21lRW1haWwvIH0pO1xuICpcbiAqIEBhcGkgcHVibGljXG4gKiBAcmV0dXJuIHtTY2hlbWFUeXBlfSB0aGlzXG4gKi9cblxuU2NoZW1hU3RyaW5nLnByb3RvdHlwZS5sb3dlcmNhc2UgPSBmdW5jdGlvbihzaG91bGRBcHBseSkge1xuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgIXNob3VsZEFwcGx5KSB7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgcmV0dXJuIHRoaXMuc2V0KHYgPT4ge1xuICAgIGlmICh0eXBlb2YgdiAhPT0gJ3N0cmluZycpIHtcbiAgICAgIHYgPSB0aGlzLmNhc3Qodik7XG4gICAgfVxuICAgIGlmICh2KSB7XG4gICAgICByZXR1cm4gdi50b0xvd2VyQ2FzZSgpO1xuICAgIH1cbiAgICByZXR1cm4gdjtcbiAgfSk7XG59O1xuXG4vKipcbiAqIEFkZHMgYW4gdXBwZXJjYXNlIFtzZXR0ZXJdKGh0dHBzOi8vbW9uZ29vc2Vqcy5jb20vZG9jcy9hcGkvc2NoZW1hdHlwZS5odG1sI1NjaGVtYVR5cGUucHJvdG90eXBlLnNldCgpKS5cbiAqXG4gKiAjIyMjIEV4YW1wbGU6XG4gKlxuICogICAgIGNvbnN0IHMgPSBuZXcgU2NoZW1hKHsgY2FwczogeyB0eXBlOiBTdHJpbmcsIHVwcGVyY2FzZTogdHJ1ZSB9fSlcbiAqICAgICBjb25zdCBNID0gZGIubW9kZWwoJ00nLCBzKTtcbiAqICAgICBjb25zdCBtID0gbmV3IE0oeyBjYXBzOiAnYW4gZXhhbXBsZScgfSk7XG4gKiAgICAgY29uc29sZS5sb2cobS5jYXBzKSAvLyBBTiBFWEFNUExFXG4gKiAgICAgTS5maW5kKHsgY2FwczogJ2FuIGV4YW1wbGUnIH0pIC8vIE1hdGNoZXMgZG9jdW1lbnRzIHdoZXJlIGNhcHMgPSAnQU4gRVhBTVBMRSdcbiAqXG4gKiBOb3RlIHRoYXQgYHVwcGVyY2FzZWAgZG9lcyAqKm5vdCoqIGFmZmVjdCByZWd1bGFyIGV4cHJlc3Npb24gcXVlcmllczpcbiAqXG4gKiAjIyMjIEV4YW1wbGU6XG4gKlxuICogICAgIC8vIE1vbmdvb3NlIGRvZXMgKipub3QqKiBjb252ZXJ0IHRoZSBSZWdFeHAgdG8gdXBwZXJjYXNlLlxuICogICAgIE0uZmluZCh7IGVtYWlsOiAvYW4gZXhhbXBsZS8gfSk7XG4gKlxuICogQGFwaSBwdWJsaWNcbiAqIEByZXR1cm4ge1NjaGVtYVR5cGV9IHRoaXNcbiAqL1xuXG5TY2hlbWFTdHJpbmcucHJvdG90eXBlLnVwcGVyY2FzZSA9IGZ1bmN0aW9uKHNob3VsZEFwcGx5KSB7XG4gIGlmIChhcmd1bWVudHMubGVuZ3RoID4gMCAmJiAhc2hvdWxkQXBwbHkpIHtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICByZXR1cm4gdGhpcy5zZXQodiA9PiB7XG4gICAgaWYgKHR5cGVvZiB2ICE9PSAnc3RyaW5nJykge1xuICAgICAgdiA9IHRoaXMuY2FzdCh2KTtcbiAgICB9XG4gICAgaWYgKHYpIHtcbiAgICAgIHJldHVybiB2LnRvVXBwZXJDYXNlKCk7XG4gICAgfVxuICAgIHJldHVybiB2O1xuICB9KTtcbn07XG5cbi8qKlxuICogQWRkcyBhIHRyaW0gW3NldHRlcl0oaHR0cHM6Ly9tb25nb29zZWpzLmNvbS9kb2NzL2FwaS9zY2hlbWF0eXBlLmh0bWwjU2NoZW1hVHlwZS5wcm90b3R5cGUuc2V0KCkpLlxuICpcbiAqIFRoZSBzdHJpbmcgdmFsdWUgd2lsbCBiZSBbdHJpbW1lZF0oaHR0cHM6Ly9tYXN0ZXJpbmdqcy5pby90dXRvcmlhbHMvZnVuZGFtZW50YWxzL3RyaW0tc3RyaW5nKSB3aGVuIHNldC5cbiAqXG4gKiAjIyMjIEV4YW1wbGU6XG4gKlxuICogICAgIGNvbnN0IHMgPSBuZXcgU2NoZW1hKHsgbmFtZTogeyB0eXBlOiBTdHJpbmcsIHRyaW06IHRydWUgfX0pO1xuICogICAgIGNvbnN0IE0gPSBkYi5tb2RlbCgnTScsIHMpO1xuICogICAgIGNvbnN0IHN0cmluZyA9ICcgc29tZSBuYW1lICc7XG4gKiAgICAgY29uc29sZS5sb2coc3RyaW5nLmxlbmd0aCk7IC8vIDExXG4gKiAgICAgY29uc3QgbSA9IG5ldyBNKHsgbmFtZTogc3RyaW5nIH0pO1xuICogICAgIGNvbnNvbGUubG9nKG0ubmFtZS5sZW5ndGgpOyAvLyA5XG4gKlxuICogICAgIC8vIEVxdWl2YWxlbnQgdG8gYGZpbmRPbmUoeyBuYW1lOiBzdHJpbmcudHJpbSgpIH0pYFxuICogICAgIE0uZmluZE9uZSh7IG5hbWU6IHN0cmluZyB9KTtcbiAqXG4gKiBOb3RlIHRoYXQgYHRyaW1gIGRvZXMgKipub3QqKiBhZmZlY3QgcmVndWxhciBleHByZXNzaW9uIHF1ZXJpZXM6XG4gKlxuICogIyMjIyBFeGFtcGxlOlxuICpcbiAqICAgICAvLyBNb25nb29zZSBkb2VzICoqbm90KiogdHJpbSB3aGl0ZXNwYWNlIGZyb20gdGhlIFJlZ0V4cC5cbiAqICAgICBNLmZpbmQoeyBuYW1lOiAvIHNvbWUgbmFtZSAvIH0pO1xuICpcbiAqIEBhcGkgcHVibGljXG4gKiBAcmV0dXJuIHtTY2hlbWFUeXBlfSB0aGlzXG4gKi9cblxuU2NoZW1hU3RyaW5nLnByb3RvdHlwZS50cmltID0gZnVuY3Rpb24oc2hvdWxkVHJpbSkge1xuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgIXNob3VsZFRyaW0pIHtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICByZXR1cm4gdGhpcy5zZXQodiA9PiB7XG4gICAgaWYgKHR5cGVvZiB2ICE9PSAnc3RyaW5nJykge1xuICAgICAgdiA9IHRoaXMuY2FzdCh2KTtcbiAgICB9XG4gICAgaWYgKHYpIHtcbiAgICAgIHJldHVybiB2LnRyaW0oKTtcbiAgICB9XG4gICAgcmV0dXJuIHY7XG4gIH0pO1xufTtcblxuLyoqXG4gKiBTZXRzIGEgbWluaW11bSBsZW5ndGggdmFsaWRhdG9yLlxuICpcbiAqICMjIyMgRXhhbXBsZTpcbiAqXG4gKiAgICAgY29uc3Qgc2NoZW1hID0gbmV3IFNjaGVtYSh7IHBvc3RhbENvZGU6IHsgdHlwZTogU3RyaW5nLCBtaW5sZW5ndGg6IDUgfSlcbiAqICAgICBjb25zdCBBZGRyZXNzID0gZGIubW9kZWwoJ0FkZHJlc3MnLCBzY2hlbWEpXG4gKiAgICAgY29uc3QgYWRkcmVzcyA9IG5ldyBBZGRyZXNzKHsgcG9zdGFsQ29kZTogJzk1MTInIH0pXG4gKiAgICAgYWRkcmVzcy5zYXZlKGZ1bmN0aW9uIChlcnIpIHtcbiAqICAgICAgIGNvbnNvbGUuZXJyb3IoZXJyKSAvLyB2YWxpZGF0b3IgZXJyb3JcbiAqICAgICAgIGFkZHJlc3MucG9zdGFsQ29kZSA9ICc5NTEyNSc7XG4gKiAgICAgICBhZGRyZXNzLnNhdmUoKSAvLyBzdWNjZXNzXG4gKiAgICAgfSlcbiAqXG4gKiAgICAgLy8gY3VzdG9tIGVycm9yIG1lc3NhZ2VzXG4gKiAgICAgLy8gV2UgY2FuIGFsc28gdXNlIHRoZSBzcGVjaWFsIHtNSU5MRU5HVEh9IHRva2VuIHdoaWNoIHdpbGwgYmUgcmVwbGFjZWQgd2l0aCB0aGUgbWluaW11bSBhbGxvd2VkIGxlbmd0aFxuICogICAgIGNvbnN0IG1pbmxlbmd0aCA9IFs1LCAnVGhlIHZhbHVlIG9mIHBhdGggYHtQQVRIfWAgKGB7VkFMVUV9YCkgaXMgc2hvcnRlciB0aGFuIHRoZSBtaW5pbXVtIGFsbG93ZWQgbGVuZ3RoICh7TUlOTEVOR1RIfSkuJ107XG4gKiAgICAgY29uc3Qgc2NoZW1hID0gbmV3IFNjaGVtYSh7IHBvc3RhbENvZGU6IHsgdHlwZTogU3RyaW5nLCBtaW5sZW5ndGg6IG1pbmxlbmd0aCB9KVxuICogICAgIGNvbnN0IEFkZHJlc3MgPSBtb25nb29zZS5tb2RlbCgnQWRkcmVzcycsIHNjaGVtYSk7XG4gKiAgICAgY29uc3QgYWRkcmVzcyA9IG5ldyBBZGRyZXNzKHsgcG9zdGFsQ29kZTogJzk1MTInIH0pO1xuICogICAgIGFkZHJlc3MudmFsaWRhdGUoZnVuY3Rpb24gKGVycikge1xuICogICAgICAgY29uc29sZS5sb2coU3RyaW5nKGVycikpIC8vIFZhbGlkYXRpb25FcnJvcjogVGhlIHZhbHVlIG9mIHBhdGggYHBvc3RhbENvZGVgIChgOTUxMmApIGlzIHNob3J0ZXIgdGhhbiB0aGUgbWluaW11bSBsZW5ndGggKDUpLlxuICogICAgIH0pXG4gKlxuICogQHBhcmFtIHtOdW1iZXJ9IHZhbHVlIG1pbmltdW0gc3RyaW5nIGxlbmd0aFxuICogQHBhcmFtIHtTdHJpbmd9IFttZXNzYWdlXSBvcHRpb25hbCBjdXN0b20gZXJyb3IgbWVzc2FnZVxuICogQHJldHVybiB7U2NoZW1hVHlwZX0gdGhpc1xuICogQHNlZSBDdXN0b21pemVkIEVycm9yIE1lc3NhZ2VzIGh0dHBzOi8vbW9uZ29vc2Vqcy5jb20vZG9jcy9hcGkvZXJyb3IuaHRtbCNFcnJvci5tZXNzYWdlc1xuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5TY2hlbWFTdHJpbmcucHJvdG90eXBlLm1pbmxlbmd0aCA9IGZ1bmN0aW9uKHZhbHVlLCBtZXNzYWdlKSB7XG4gIGlmICh0aGlzLm1pbmxlbmd0aFZhbGlkYXRvcikge1xuICAgIHRoaXMudmFsaWRhdG9ycyA9IHRoaXMudmFsaWRhdG9ycy5maWx0ZXIoZnVuY3Rpb24odikge1xuICAgICAgcmV0dXJuIHYudmFsaWRhdG9yICE9PSB0aGlzLm1pbmxlbmd0aFZhbGlkYXRvcjtcbiAgICB9LCB0aGlzKTtcbiAgfVxuXG4gIGlmICh2YWx1ZSAhPT0gbnVsbCAmJiB2YWx1ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgbGV0IG1zZyA9IG1lc3NhZ2UgfHwgTW9uZ29vc2VFcnJvci5tZXNzYWdlcy5TdHJpbmcubWlubGVuZ3RoO1xuICAgIG1zZyA9IG1zZy5yZXBsYWNlKC97TUlOTEVOR1RIfS8sIHZhbHVlKTtcbiAgICB0aGlzLnZhbGlkYXRvcnMucHVzaCh7XG4gICAgICB2YWxpZGF0b3I6IHRoaXMubWlubGVuZ3RoVmFsaWRhdG9yID0gZnVuY3Rpb24odikge1xuICAgICAgICByZXR1cm4gdiA9PT0gbnVsbCB8fCB2Lmxlbmd0aCA+PSB2YWx1ZTtcbiAgICAgIH0sXG4gICAgICBtZXNzYWdlOiBtc2csXG4gICAgICB0eXBlOiAnbWlubGVuZ3RoJyxcbiAgICAgIG1pbmxlbmd0aDogdmFsdWVcbiAgICB9KTtcbiAgfVxuXG4gIHJldHVybiB0aGlzO1xufTtcblxuU2NoZW1hU3RyaW5nLnByb3RvdHlwZS5taW5MZW5ndGggPSBTY2hlbWFTdHJpbmcucHJvdG90eXBlLm1pbmxlbmd0aDtcblxuLyoqXG4gKiBTZXRzIGEgbWF4aW11bSBsZW5ndGggdmFsaWRhdG9yLlxuICpcbiAqICMjIyMgRXhhbXBsZTpcbiAqXG4gKiAgICAgY29uc3Qgc2NoZW1hID0gbmV3IFNjaGVtYSh7IHBvc3RhbENvZGU6IHsgdHlwZTogU3RyaW5nLCBtYXhsZW5ndGg6IDkgfSlcbiAqICAgICBjb25zdCBBZGRyZXNzID0gZGIubW9kZWwoJ0FkZHJlc3MnLCBzY2hlbWEpXG4gKiAgICAgY29uc3QgYWRkcmVzcyA9IG5ldyBBZGRyZXNzKHsgcG9zdGFsQ29kZTogJzk1MTI1MTIzNDUnIH0pXG4gKiAgICAgYWRkcmVzcy5zYXZlKGZ1bmN0aW9uIChlcnIpIHtcbiAqICAgICAgIGNvbnNvbGUuZXJyb3IoZXJyKSAvLyB2YWxpZGF0b3IgZXJyb3JcbiAqICAgICAgIGFkZHJlc3MucG9zdGFsQ29kZSA9ICc5NTEyNSc7XG4gKiAgICAgICBhZGRyZXNzLnNhdmUoKSAvLyBzdWNjZXNzXG4gKiAgICAgfSlcbiAqXG4gKiAgICAgLy8gY3VzdG9tIGVycm9yIG1lc3NhZ2VzXG4gKiAgICAgLy8gV2UgY2FuIGFsc28gdXNlIHRoZSBzcGVjaWFsIHtNQVhMRU5HVEh9IHRva2VuIHdoaWNoIHdpbGwgYmUgcmVwbGFjZWQgd2l0aCB0aGUgbWF4aW11bSBhbGxvd2VkIGxlbmd0aFxuICogICAgIGNvbnN0IG1heGxlbmd0aCA9IFs5LCAnVGhlIHZhbHVlIG9mIHBhdGggYHtQQVRIfWAgKGB7VkFMVUV9YCkgZXhjZWVkcyB0aGUgbWF4aW11bSBhbGxvd2VkIGxlbmd0aCAoe01BWExFTkdUSH0pLiddO1xuICogICAgIGNvbnN0IHNjaGVtYSA9IG5ldyBTY2hlbWEoeyBwb3N0YWxDb2RlOiB7IHR5cGU6IFN0cmluZywgbWF4bGVuZ3RoOiBtYXhsZW5ndGggfSlcbiAqICAgICBjb25zdCBBZGRyZXNzID0gbW9uZ29vc2UubW9kZWwoJ0FkZHJlc3MnLCBzY2hlbWEpO1xuICogICAgIGNvbnN0IGFkZHJlc3MgPSBuZXcgQWRkcmVzcyh7IHBvc3RhbENvZGU6ICc5NTEyNTEyMzQ1JyB9KTtcbiAqICAgICBhZGRyZXNzLnZhbGlkYXRlKGZ1bmN0aW9uIChlcnIpIHtcbiAqICAgICAgIGNvbnNvbGUubG9nKFN0cmluZyhlcnIpKSAvLyBWYWxpZGF0aW9uRXJyb3I6IFRoZSB2YWx1ZSBvZiBwYXRoIGBwb3N0YWxDb2RlYCAoYDk1MTI1MTIzNDVgKSBleGNlZWRzIHRoZSBtYXhpbXVtIGFsbG93ZWQgbGVuZ3RoICg5KS5cbiAqICAgICB9KVxuICpcbiAqIEBwYXJhbSB7TnVtYmVyfSB2YWx1ZSBtYXhpbXVtIHN0cmluZyBsZW5ndGhcbiAqIEBwYXJhbSB7U3RyaW5nfSBbbWVzc2FnZV0gb3B0aW9uYWwgY3VzdG9tIGVycm9yIG1lc3NhZ2VcbiAqIEByZXR1cm4ge1NjaGVtYVR5cGV9IHRoaXNcbiAqIEBzZWUgQ3VzdG9taXplZCBFcnJvciBNZXNzYWdlcyBodHRwczovL21vbmdvb3NlanMuY29tL2RvY3MvYXBpL2Vycm9yLmh0bWwjRXJyb3IubWVzc2FnZXNcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuU2NoZW1hU3RyaW5nLnByb3RvdHlwZS5tYXhsZW5ndGggPSBmdW5jdGlvbih2YWx1ZSwgbWVzc2FnZSkge1xuICBpZiAodGhpcy5tYXhsZW5ndGhWYWxpZGF0b3IpIHtcbiAgICB0aGlzLnZhbGlkYXRvcnMgPSB0aGlzLnZhbGlkYXRvcnMuZmlsdGVyKGZ1bmN0aW9uKHYpIHtcbiAgICAgIHJldHVybiB2LnZhbGlkYXRvciAhPT0gdGhpcy5tYXhsZW5ndGhWYWxpZGF0b3I7XG4gICAgfSwgdGhpcyk7XG4gIH1cblxuICBpZiAodmFsdWUgIT09IG51bGwgJiYgdmFsdWUgIT09IHVuZGVmaW5lZCkge1xuICAgIGxldCBtc2cgPSBtZXNzYWdlIHx8IE1vbmdvb3NlRXJyb3IubWVzc2FnZXMuU3RyaW5nLm1heGxlbmd0aDtcbiAgICBtc2cgPSBtc2cucmVwbGFjZSgve01BWExFTkdUSH0vLCB2YWx1ZSk7XG4gICAgdGhpcy52YWxpZGF0b3JzLnB1c2goe1xuICAgICAgdmFsaWRhdG9yOiB0aGlzLm1heGxlbmd0aFZhbGlkYXRvciA9IGZ1bmN0aW9uKHYpIHtcbiAgICAgICAgcmV0dXJuIHYgPT09IG51bGwgfHwgdi5sZW5ndGggPD0gdmFsdWU7XG4gICAgICB9LFxuICAgICAgbWVzc2FnZTogbXNnLFxuICAgICAgdHlwZTogJ21heGxlbmd0aCcsXG4gICAgICBtYXhsZW5ndGg6IHZhbHVlXG4gICAgfSk7XG4gIH1cblxuICByZXR1cm4gdGhpcztcbn07XG5cblNjaGVtYVN0cmluZy5wcm90b3R5cGUubWF4TGVuZ3RoID0gU2NoZW1hU3RyaW5nLnByb3RvdHlwZS5tYXhsZW5ndGg7XG5cbi8qKlxuICogU2V0cyBhIHJlZ2V4cCB2YWxpZGF0b3IuXG4gKlxuICogQW55IHZhbHVlIHRoYXQgZG9lcyBub3QgcGFzcyBgcmVnRXhwYC50ZXN0KHZhbCkgd2lsbCBmYWlsIHZhbGlkYXRpb24uXG4gKlxuICogIyMjIyBFeGFtcGxlOlxuICpcbiAqICAgICBjb25zdCBzID0gbmV3IFNjaGVtYSh7IG5hbWU6IHsgdHlwZTogU3RyaW5nLCBtYXRjaDogL15hLyB9fSlcbiAqICAgICBjb25zdCBNID0gZGIubW9kZWwoJ00nLCBzKVxuICogICAgIGNvbnN0IG0gPSBuZXcgTSh7IG5hbWU6ICdJIGFtIGludmFsaWQnIH0pXG4gKiAgICAgbS52YWxpZGF0ZShmdW5jdGlvbiAoZXJyKSB7XG4gKiAgICAgICBjb25zb2xlLmVycm9yKFN0cmluZyhlcnIpKSAvLyBcIlZhbGlkYXRpb25FcnJvcjogUGF0aCBgbmFtZWAgaXMgaW52YWxpZCAoSSBhbSBpbnZhbGlkKS5cIlxuICogICAgICAgbS5uYW1lID0gJ2FwcGxlcydcbiAqICAgICAgIG0udmFsaWRhdGUoZnVuY3Rpb24gKGVycikge1xuICogICAgICAgICBhc3NlcnQub2soZXJyKSAvLyBzdWNjZXNzXG4gKiAgICAgICB9KVxuICogICAgIH0pXG4gKlxuICogICAgIC8vIHVzaW5nIGEgY3VzdG9tIGVycm9yIG1lc3NhZ2VcbiAqICAgICBjb25zdCBtYXRjaCA9IFsgL1xcLmh0bWwkLywgXCJUaGF0IGZpbGUgZG9lc24ndCBlbmQgaW4gLmh0bWwgKHtWQUxVRX0pXCIgXTtcbiAqICAgICBjb25zdCBzID0gbmV3IFNjaGVtYSh7IGZpbGU6IHsgdHlwZTogU3RyaW5nLCBtYXRjaDogbWF0Y2ggfX0pXG4gKiAgICAgY29uc3QgTSA9IGRiLm1vZGVsKCdNJywgcyk7XG4gKiAgICAgY29uc3QgbSA9IG5ldyBNKHsgZmlsZTogJ2ludmFsaWQnIH0pO1xuICogICAgIG0udmFsaWRhdGUoZnVuY3Rpb24gKGVycikge1xuICogICAgICAgY29uc29sZS5sb2coU3RyaW5nKGVycikpIC8vIFwiVmFsaWRhdGlvbkVycm9yOiBUaGF0IGZpbGUgZG9lc24ndCBlbmQgaW4gLmh0bWwgKGludmFsaWQpXCJcbiAqICAgICB9KVxuICpcbiAqIEVtcHR5IHN0cmluZ3MsIGB1bmRlZmluZWRgLCBhbmQgYG51bGxgIHZhbHVlcyBhbHdheXMgcGFzcyB0aGUgbWF0Y2ggdmFsaWRhdG9yLiBJZiB5b3UgcmVxdWlyZSB0aGVzZSB2YWx1ZXMsIGVuYWJsZSB0aGUgYHJlcXVpcmVkYCB2YWxpZGF0b3IgYWxzby5cbiAqXG4gKiAgICAgY29uc3QgcyA9IG5ldyBTY2hlbWEoeyBuYW1lOiB7IHR5cGU6IFN0cmluZywgbWF0Y2g6IC9eYS8sIHJlcXVpcmVkOiB0cnVlIH19KVxuICpcbiAqIEBwYXJhbSB7UmVnRXhwfSByZWdFeHAgcmVndWxhciBleHByZXNzaW9uIHRvIHRlc3QgYWdhaW5zdFxuICogQHBhcmFtIHtTdHJpbmd9IFttZXNzYWdlXSBvcHRpb25hbCBjdXN0b20gZXJyb3IgbWVzc2FnZVxuICogQHJldHVybiB7U2NoZW1hVHlwZX0gdGhpc1xuICogQHNlZSBDdXN0b21pemVkIEVycm9yIE1lc3NhZ2VzIGh0dHBzOi8vbW9uZ29vc2Vqcy5jb20vZG9jcy9hcGkvZXJyb3IuaHRtbCNFcnJvci5tZXNzYWdlc1xuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5TY2hlbWFTdHJpbmcucHJvdG90eXBlLm1hdGNoID0gZnVuY3Rpb24gbWF0Y2gocmVnRXhwLCBtZXNzYWdlKSB7XG4gIC8vIHllcywgd2UgYWxsb3cgbXVsdGlwbGUgbWF0Y2ggdmFsaWRhdG9yc1xuXG4gIGNvbnN0IG1zZyA9IG1lc3NhZ2UgfHwgTW9uZ29vc2VFcnJvci5tZXNzYWdlcy5TdHJpbmcubWF0Y2g7XG5cbiAgY29uc3QgbWF0Y2hWYWxpZGF0b3IgPSBmdW5jdGlvbih2KSB7XG4gICAgaWYgKCFyZWdFeHApIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICAvLyBJbiBjYXNlIFJlZ0V4cCBoYXBwZW5zIHRvIGhhdmUgYC9nYCBmbGFnIHNldCwgd2UgbmVlZCB0byByZXNldCB0aGVcbiAgICAvLyBgbGFzdEluZGV4YCwgb3RoZXJ3aXNlIGBtYXRjaGAgd2lsbCBpbnRlcm1pdHRlbnRseSBmYWlsLlxuICAgIHJlZ0V4cC5sYXN0SW5kZXggPSAwO1xuXG4gICAgY29uc3QgcmV0ID0gKCh2ICE9IG51bGwgJiYgdiAhPT0gJycpXG4gICAgICA/IHJlZ0V4cC50ZXN0KHYpXG4gICAgICA6IHRydWUpO1xuICAgIHJldHVybiByZXQ7XG4gIH07XG5cbiAgdGhpcy52YWxpZGF0b3JzLnB1c2goe1xuICAgIHZhbGlkYXRvcjogbWF0Y2hWYWxpZGF0b3IsXG4gICAgbWVzc2FnZTogbXNnLFxuICAgIHR5cGU6ICdyZWdleHAnLFxuICAgIHJlZ2V4cDogcmVnRXhwXG4gIH0pO1xuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogQ2hlY2sgaWYgdGhlIGdpdmVuIHZhbHVlIHNhdGlzZmllcyB0aGUgYHJlcXVpcmVkYCB2YWxpZGF0b3IuIFRoZSB2YWx1ZSBpc1xuICogY29uc2lkZXJlZCB2YWxpZCBpZiBpdCBpcyBhIHN0cmluZyAodGhhdCBpcywgbm90IGBudWxsYCBvciBgdW5kZWZpbmVkYCkgYW5kXG4gKiBoYXMgcG9zaXRpdmUgbGVuZ3RoLiBUaGUgYHJlcXVpcmVkYCB2YWxpZGF0b3IgKip3aWxsKiogZmFpbCBmb3IgZW1wdHlcbiAqIHN0cmluZ3MuXG4gKlxuICogQHBhcmFtIHtBbnl9IHZhbHVlXG4gKiBAcGFyYW0ge0RvY3VtZW50fSBkb2NcbiAqIEByZXR1cm4ge0Jvb2xlYW59XG4gKiBAYXBpIHB1YmxpY1xuICovXG5cblNjaGVtYVN0cmluZy5wcm90b3R5cGUuY2hlY2tSZXF1aXJlZCA9IGZ1bmN0aW9uIGNoZWNrUmVxdWlyZWQodmFsdWUsIGRvYykge1xuICBpZiAodHlwZW9mIHZhbHVlID09PSAnb2JqZWN0JyAmJiBTY2hlbWFUeXBlLl9pc1JlZih0aGlzLCB2YWx1ZSwgZG9jLCB0cnVlKSkge1xuICAgIHJldHVybiB2YWx1ZSAhPSBudWxsO1xuICB9XG5cbiAgLy8gYHJlcXVpcmUoJ3V0aWwnKS5pbmhlcml0cygpYCBkb2VzICoqbm90KiogY29weSBzdGF0aWMgcHJvcGVydGllcywgYW5kXG4gIC8vIHBsdWdpbnMgbGlrZSBtb25nb29zZS1mbG9hdCB1c2UgYGluaGVyaXRzKClgIGZvciBwcmUtRVM2LlxuICBjb25zdCBfY2hlY2tSZXF1aXJlZCA9IHR5cGVvZiB0aGlzLmNvbnN0cnVjdG9yLmNoZWNrUmVxdWlyZWQgPT09ICdmdW5jdGlvbicgP1xuICAgIHRoaXMuY29uc3RydWN0b3IuY2hlY2tSZXF1aXJlZCgpIDpcbiAgICBTY2hlbWFTdHJpbmcuY2hlY2tSZXF1aXJlZCgpO1xuXG4gIHJldHVybiBfY2hlY2tSZXF1aXJlZCh2YWx1ZSk7XG59O1xuXG4vKipcbiAqIENhc3RzIHRvIFN0cmluZ1xuICpcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cblNjaGVtYVN0cmluZy5wcm90b3R5cGUuY2FzdCA9IGZ1bmN0aW9uKHZhbHVlLCBkb2MsIGluaXQpIHtcbiAgaWYgKHR5cGVvZiB2YWx1ZSAhPT0gJ3N0cmluZycgJiYgU2NoZW1hVHlwZS5faXNSZWYodGhpcywgdmFsdWUsIGRvYywgaW5pdCkpIHtcbiAgICByZXR1cm4gdGhpcy5fY2FzdFJlZih2YWx1ZSwgZG9jLCBpbml0KTtcbiAgfVxuXG4gIGxldCBjYXN0U3RyaW5nO1xuICBpZiAodHlwZW9mIHRoaXMuX2Nhc3RGdW5jdGlvbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIGNhc3RTdHJpbmcgPSB0aGlzLl9jYXN0RnVuY3Rpb247XG4gIH0gZWxzZSBpZiAodHlwZW9mIHRoaXMuY29uc3RydWN0b3IuY2FzdCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIGNhc3RTdHJpbmcgPSB0aGlzLmNvbnN0cnVjdG9yLmNhc3QoKTtcbiAgfSBlbHNlIHtcbiAgICBjYXN0U3RyaW5nID0gU2NoZW1hU3RyaW5nLmNhc3QoKTtcbiAgfVxuXG4gIHRyeSB7XG4gICAgcmV0dXJuIGNhc3RTdHJpbmcodmFsdWUpO1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIHRocm93IG5ldyBDYXN0RXJyb3IoJ3N0cmluZycsIHZhbHVlLCB0aGlzLnBhdGgsIG51bGwsIHRoaXMpO1xuICB9XG59O1xuXG4vKiFcbiAqIGlnbm9yZVxuICovXG5cbmZ1bmN0aW9uIGhhbmRsZVNpbmdsZSh2YWwsIGNvbnRleHQpIHtcbiAgcmV0dXJuIHRoaXMuY2FzdEZvclF1ZXJ5KG51bGwsIHZhbCwgY29udGV4dCk7XG59XG5cbi8qIVxuICogaWdub3JlXG4gKi9cblxuZnVuY3Rpb24gaGFuZGxlQXJyYXkodmFsLCBjb250ZXh0KSB7XG4gIGNvbnN0IF90aGlzID0gdGhpcztcbiAgaWYgKCFBcnJheS5pc0FycmF5KHZhbCkpIHtcbiAgICByZXR1cm4gW3RoaXMuY2FzdEZvclF1ZXJ5KG51bGwsIHZhbCwgY29udGV4dCldO1xuICB9XG4gIHJldHVybiB2YWwubWFwKGZ1bmN0aW9uKG0pIHtcbiAgICByZXR1cm4gX3RoaXMuY2FzdEZvclF1ZXJ5KG51bGwsIG0sIGNvbnRleHQpO1xuICB9KTtcbn1cblxuLyohXG4gKiBpZ25vcmVcbiAqL1xuXG5mdW5jdGlvbiBoYW5kbGVTaW5nbGVOb1NldHRlcnModmFsKSB7XG4gIGlmICh2YWwgPT0gbnVsbCkge1xuICAgIHJldHVybiB0aGlzLl9jYXN0TnVsbGlzaCh2YWwpO1xuICB9XG5cbiAgcmV0dXJuIHRoaXMuY2FzdCh2YWwsIHRoaXMpO1xufVxuXG5jb25zdCAkY29uZGl0aW9uYWxIYW5kbGVycyA9IHV0aWxzLm9wdGlvbnMoU2NoZW1hVHlwZS5wcm90b3R5cGUuJGNvbmRpdGlvbmFsSGFuZGxlcnMsIHtcbiAgJGFsbDogaGFuZGxlQXJyYXksXG4gICRndDogaGFuZGxlU2luZ2xlLFxuICAkZ3RlOiBoYW5kbGVTaW5nbGUsXG4gICRsdDogaGFuZGxlU2luZ2xlLFxuICAkbHRlOiBoYW5kbGVTaW5nbGUsXG4gICRvcHRpb25zOiBoYW5kbGVTaW5nbGVOb1NldHRlcnMsXG4gICRyZWdleDogZnVuY3Rpb24gaGFuZGxlJHJlZ2V4KHZhbCkge1xuICAgIGlmIChPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwodmFsKSA9PT0gJ1tvYmplY3QgUmVnRXhwXScpIHtcbiAgICAgIHJldHVybiB2YWw7XG4gICAgfVxuXG4gICAgcmV0dXJuIGhhbmRsZVNpbmdsZU5vU2V0dGVycy5jYWxsKHRoaXMsIHZhbCk7XG4gIH0sXG4gICRub3Q6IGhhbmRsZVNpbmdsZVxufSk7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShTY2hlbWFTdHJpbmcucHJvdG90eXBlLCAnJGNvbmRpdGlvbmFsSGFuZGxlcnMnLCB7XG4gIGNvbmZpZ3VyYWJsZTogZmFsc2UsXG4gIGVudW1lcmFibGU6IGZhbHNlLFxuICB3cml0YWJsZTogZmFsc2UsXG4gIHZhbHVlOiBPYmplY3QuZnJlZXplKCRjb25kaXRpb25hbEhhbmRsZXJzKVxufSk7XG5cbi8qKlxuICogQ2FzdHMgY29udGVudHMgZm9yIHF1ZXJpZXMuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9ICRjb25kaXRpb25hbFxuICogQHBhcmFtIHthbnl9IFt2YWxdXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5TY2hlbWFTdHJpbmcucHJvdG90eXBlLmNhc3RGb3JRdWVyeSA9IGZ1bmN0aW9uKCRjb25kaXRpb25hbCwgdmFsLCBjb250ZXh0KSB7XG4gIGxldCBoYW5kbGVyO1xuICBpZiAoJGNvbmRpdGlvbmFsICE9IG51bGwpIHtcbiAgICBoYW5kbGVyID0gdGhpcy4kY29uZGl0aW9uYWxIYW5kbGVyc1skY29uZGl0aW9uYWxdO1xuICAgIGlmICghaGFuZGxlcikge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdDYW5cXCd0IHVzZSAnICsgJGNvbmRpdGlvbmFsICsgJyB3aXRoIFN0cmluZy4nKTtcbiAgICB9XG4gICAgcmV0dXJuIGhhbmRsZXIuY2FsbCh0aGlzLCB2YWwsIGNvbnRleHQpO1xuICB9XG5cbiAgaWYgKE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh2YWwpID09PSAnW29iamVjdCBSZWdFeHBdJyB8fCBpc0Jzb25UeXBlKHZhbCwgJ0JTT05SZWdFeHAnKSkge1xuICAgIHJldHVybiB2YWw7XG4gIH1cblxuICByZXR1cm4gdGhpcy5hcHBseVNldHRlcnModmFsLCBjb250ZXh0KTtcbn07XG5cbi8qIVxuICogTW9kdWxlIGV4cG9ydHMuXG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSBTY2hlbWFTdHJpbmc7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/mongoose/lib/schema/string.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/mongoose/lib/schema/subdocument.js":
/*!*********************************************************!*\
  !*** ./node_modules/mongoose/lib/schema/subdocument.js ***!
  \*********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\n\n/*!\n * Module dependencies.\n */\n\nconst CastError = __webpack_require__(/*! ../error/cast */ \"(ssr)/./node_modules/mongoose/lib/error/cast.js\");\nconst EventEmitter = (__webpack_require__(/*! events */ \"events\").EventEmitter);\nconst ObjectExpectedError = __webpack_require__(/*! ../error/objectExpected */ \"(ssr)/./node_modules/mongoose/lib/error/objectExpected.js\");\nconst SchemaSubdocumentOptions = __webpack_require__(/*! ../options/schemaSubdocumentOptions */ \"(ssr)/./node_modules/mongoose/lib/options/schemaSubdocumentOptions.js\");\nconst SchemaType = __webpack_require__(/*! ../schemaType */ \"(ssr)/./node_modules/mongoose/lib/schemaType.js\");\nconst applyDefaults = __webpack_require__(/*! ../helpers/document/applyDefaults */ \"(ssr)/./node_modules/mongoose/lib/helpers/document/applyDefaults.js\");\nconst $exists = __webpack_require__(/*! ./operators/exists */ \"(ssr)/./node_modules/mongoose/lib/schema/operators/exists.js\");\nconst castToNumber = (__webpack_require__(/*! ./operators/helpers */ \"(ssr)/./node_modules/mongoose/lib/schema/operators/helpers.js\").castToNumber);\nconst discriminator = __webpack_require__(/*! ../helpers/model/discriminator */ \"(ssr)/./node_modules/mongoose/lib/helpers/model/discriminator.js\");\nconst geospatial = __webpack_require__(/*! ./operators/geospatial */ \"(ssr)/./node_modules/mongoose/lib/schema/operators/geospatial.js\");\nconst getConstructor = __webpack_require__(/*! ../helpers/discriminator/getConstructor */ \"(ssr)/./node_modules/mongoose/lib/helpers/discriminator/getConstructor.js\");\nconst handleIdOption = __webpack_require__(/*! ../helpers/schema/handleIdOption */ \"(ssr)/./node_modules/mongoose/lib/helpers/schema/handleIdOption.js\");\nconst internalToObjectOptions = (__webpack_require__(/*! ../options */ \"(ssr)/./node_modules/mongoose/lib/options.js\").internalToObjectOptions);\nconst isExclusive = __webpack_require__(/*! ../helpers/projection/isExclusive */ \"(ssr)/./node_modules/mongoose/lib/helpers/projection/isExclusive.js\");\nconst utils = __webpack_require__(/*! ../utils */ \"(ssr)/./node_modules/mongoose/lib/utils.js\");\nconst InvalidSchemaOptionError = __webpack_require__(/*! ../error/invalidSchemaOption */ \"(ssr)/./node_modules/mongoose/lib/error/invalidSchemaOption.js\");\n\nlet SubdocumentType;\n\nmodule.exports = SchemaSubdocument;\n\n/**\n * Single nested subdocument SchemaType constructor.\n *\n * @param {Schema} schema\n * @param {String} path\n * @param {Object} options\n * @inherits SchemaType\n * @api public\n */\n\nfunction SchemaSubdocument(schema, path, options) {\n  if (schema.options.timeseries) {\n    throw new InvalidSchemaOptionError(path, 'timeseries');\n  }\n  const schemaTypeIdOption = SchemaSubdocument.defaultOptions &&\n    SchemaSubdocument.defaultOptions._id;\n  if (schemaTypeIdOption != null) {\n    options = options || {};\n    options._id = schemaTypeIdOption;\n  }\n\n  schema = handleIdOption(schema, options);\n\n  this.caster = _createConstructor(schema);\n  this.caster.path = path;\n  this.caster.prototype.$basePath = path;\n  this.schema = schema;\n  this.$isSingleNested = true;\n  this.base = schema.base;\n  SchemaType.call(this, path, options, 'Embedded');\n  if (schema._applyDiscriminators != null && !options?._skipApplyDiscriminators) {\n    for (const disc of schema._applyDiscriminators.keys()) {\n      this.discriminator(disc, schema._applyDiscriminators.get(disc));\n    }\n  }\n}\n\n/*!\n * ignore\n */\n\nSchemaSubdocument.prototype = Object.create(SchemaType.prototype);\nSchemaSubdocument.prototype.constructor = SchemaSubdocument;\nSchemaSubdocument.prototype.OptionsConstructor = SchemaSubdocumentOptions;\n\n/*!\n * ignore\n */\n\nfunction _createConstructor(schema, baseClass) {\n  // lazy load\n  SubdocumentType || (SubdocumentType = __webpack_require__(/*! ../types/subdocument */ \"(ssr)/./node_modules/mongoose/lib/types/subdocument.js\"));\n\n  const _embedded = function SingleNested(value, path, parent) {\n    this.$__parent = parent;\n    SubdocumentType.apply(this, arguments);\n\n    if (parent == null) {\n      return;\n    }\n    this.$session(parent.$session());\n  };\n\n  schema._preCompile();\n\n  const proto = baseClass != null ? baseClass.prototype : SubdocumentType.prototype;\n  _embedded.prototype = Object.create(proto);\n  _embedded.prototype.$__setSchema(schema);\n  _embedded.prototype.constructor = _embedded;\n  _embedded.base = schema.base;\n  _embedded.schema = schema;\n  _embedded.$isSingleNested = true;\n  _embedded.events = new EventEmitter();\n  _embedded.prototype.toBSON = function() {\n    return this.toObject(internalToObjectOptions);\n  };\n\n  // apply methods\n  for (const i in schema.methods) {\n    _embedded.prototype[i] = schema.methods[i];\n  }\n\n  // apply statics\n  for (const i in schema.statics) {\n    _embedded[i] = schema.statics[i];\n  }\n\n  for (const i in EventEmitter.prototype) {\n    _embedded[i] = EventEmitter.prototype[i];\n  }\n\n  return _embedded;\n}\n\n/**\n * Special case for when users use a common location schema to represent\n * locations for use with $geoWithin.\n * https://www.mongodb.com/docs/manual/reference/operator/query/geoWithin/\n *\n * @param {Object} val\n * @api private\n */\n\nSchemaSubdocument.prototype.$conditionalHandlers.$geoWithin = function handle$geoWithin(val, context) {\n  return { $geometry: this.castForQuery(null, val.$geometry, context) };\n};\n\n/*!\n * ignore\n */\n\nSchemaSubdocument.prototype.$conditionalHandlers.$near =\nSchemaSubdocument.prototype.$conditionalHandlers.$nearSphere = geospatial.cast$near;\n\nSchemaSubdocument.prototype.$conditionalHandlers.$within =\nSchemaSubdocument.prototype.$conditionalHandlers.$geoWithin = geospatial.cast$within;\n\nSchemaSubdocument.prototype.$conditionalHandlers.$geoIntersects =\n  geospatial.cast$geoIntersects;\n\nSchemaSubdocument.prototype.$conditionalHandlers.$minDistance = castToNumber;\nSchemaSubdocument.prototype.$conditionalHandlers.$maxDistance = castToNumber;\n\nSchemaSubdocument.prototype.$conditionalHandlers.$exists = $exists;\n\n/**\n * Casts contents\n *\n * @param {Object} value\n * @api private\n */\n\nSchemaSubdocument.prototype.cast = function(val, doc, init, priorVal, options) {\n  if (val && val.$isSingleNested && val.parent === doc) {\n    return val;\n  }\n\n  if (val != null && (typeof val !== 'object' || Array.isArray(val))) {\n    throw new ObjectExpectedError(this.path, val);\n  }\n\n  const discriminatorKeyPath = this.schema.path(this.schema.options.discriminatorKey);\n  const defaultDiscriminatorValue = discriminatorKeyPath == null ? null : discriminatorKeyPath.getDefault(doc);\n  const Constructor = getConstructor(this.caster, val, defaultDiscriminatorValue);\n\n  let subdoc;\n\n  // Only pull relevant selected paths and pull out the base path\n  const parentSelected = doc && doc.$__ && doc.$__.selected;\n  const path = this.path;\n  const selected = parentSelected == null ? null : Object.keys(parentSelected).reduce((obj, key) => {\n    if (key.startsWith(path + '.')) {\n      obj = obj || {};\n      obj[key.substring(path.length + 1)] = parentSelected[key];\n    }\n    return obj;\n  }, null);\n  if (init) {\n    subdoc = new Constructor(void 0, selected, doc, false, { defaults: false });\n    delete subdoc.$__.defaults;\n    subdoc.$init(val);\n    const exclude = isExclusive(selected);\n    applyDefaults(subdoc, selected, exclude);\n  } else {\n    options = Object.assign({}, options, { priorDoc: priorVal });\n    if (Object.keys(val).length === 0) {\n      return new Constructor({}, selected, doc, undefined, options);\n    }\n\n    return new Constructor(val, selected, doc, undefined, options);\n  }\n\n  return subdoc;\n};\n\n/**\n * Casts contents for query\n *\n * @param {string} [$conditional] optional query operator (like `$eq` or `$in`)\n * @param {any} value\n * @api private\n */\n\nSchemaSubdocument.prototype.castForQuery = function($conditional, val, context, options) {\n  let handler;\n  if ($conditional != null) {\n    handler = this.$conditionalHandlers[$conditional];\n    if (!handler) {\n      throw new Error('Can\\'t use ' + $conditional);\n    }\n    return handler.call(this, val);\n  }\n  if (val == null) {\n    return val;\n  }\n\n  const Constructor = getConstructor(this.caster, val);\n  if (val instanceof Constructor) {\n    return val;\n  }\n\n  if (this.options.runSetters) {\n    val = this._applySetters(val, context);\n  }\n\n  const overrideStrict = options != null && options.strict != null ?\n    options.strict :\n    void 0;\n\n  try {\n    val = new Constructor(val, overrideStrict);\n  } catch (error) {\n    // Make sure we always wrap in a CastError (gh-6803)\n    if (!(error instanceof CastError)) {\n      throw new CastError('Embedded', val, this.path, error, this);\n    }\n    throw error;\n  }\n  return val;\n};\n\n/**\n * Async validation on this single nested doc.\n *\n * @api private\n */\n\nSchemaSubdocument.prototype.doValidate = function(value, fn, scope, options) {\n  const Constructor = getConstructor(this.caster, value);\n\n  if (value && !(value instanceof Constructor)) {\n    value = new Constructor(value, null, (scope != null && scope.$__ != null) ? scope : null);\n  }\n\n  if (options && options.skipSchemaValidators) {\n    if (!value) {\n      return fn(null);\n    }\n    return value.validate().then(() => fn(null), err => fn(err));\n  }\n\n  SchemaType.prototype.doValidate.call(this, value, function(error) {\n    if (error) {\n      return fn(error);\n    }\n    if (!value) {\n      return fn(null);\n    }\n\n    value.validate().then(() => fn(null), err => fn(err));\n  }, scope, options);\n};\n\n/**\n * Synchronously validate this single nested doc\n *\n * @api private\n */\n\nSchemaSubdocument.prototype.doValidateSync = function(value, scope, options) {\n  if (!options || !options.skipSchemaValidators) {\n    const schemaTypeError = SchemaType.prototype.doValidateSync.call(this, value, scope);\n    if (schemaTypeError) {\n      return schemaTypeError;\n    }\n  }\n  if (!value) {\n    return;\n  }\n  return value.validateSync();\n};\n\n/**\n * Adds a discriminator to this single nested subdocument.\n *\n * #### Example:\n *\n *     const shapeSchema = Schema({ name: String }, { discriminatorKey: 'kind' });\n *     const schema = Schema({ shape: shapeSchema });\n *\n *     const singleNestedPath = parentSchema.path('shape');\n *     singleNestedPath.discriminator('Circle', Schema({ radius: Number }));\n *\n * @param {String} name\n * @param {Schema} schema fields to add to the schema for instances of this sub-class\n * @param {Object|string} [options] If string, same as `options.value`.\n * @param {String} [options.value] the string stored in the `discriminatorKey` property. If not specified, Mongoose uses the `name` parameter.\n * @param {Boolean} [options.clone=true] By default, `discriminator()` clones the given `schema`. Set to `false` to skip cloning.\n * @return {Function} the constructor Mongoose will use for creating instances of this discriminator model\n * @see discriminators https://mongoosejs.com/docs/discriminators.html\n * @api public\n */\n\nSchemaSubdocument.prototype.discriminator = function(name, schema, options) {\n  options = options || {};\n  const value = utils.isPOJO(options) ? options.value : options;\n  const clone = typeof options.clone === 'boolean'\n    ? options.clone\n    : true;\n\n  if (schema.instanceOfSchema && clone) {\n    schema = schema.clone();\n  }\n\n  schema = discriminator(this.caster, name, schema, value);\n\n  this.caster.discriminators[name] = _createConstructor(schema, this.caster);\n\n  return this.caster.discriminators[name];\n};\n\n/*!\n * ignore\n */\n\nSchemaSubdocument.defaultOptions = {};\n\n/**\n * Sets a default option for all Subdocument instances.\n *\n * #### Example:\n *\n *     // Make all numbers have option `min` equal to 0.\n *     mongoose.Schema.Subdocument.set('required', true);\n *\n * @param {String} option The option you'd like to set the value for\n * @param {Any} value value for option\n * @return {void}\n * @function set\n * @static\n * @api public\n */\n\nSchemaSubdocument.set = SchemaType.set;\n\nSchemaSubdocument.setters = [];\n\n/**\n * Attaches a getter for all Subdocument instances\n *\n * @param {Function} getter\n * @return {this}\n * @function get\n * @static\n * @api public\n */\n\nSchemaSubdocument.get = SchemaType.get;\n\n/*!\n * ignore\n */\n\nSchemaSubdocument.prototype.toJSON = function toJSON() {\n  return { path: this.path, options: this.options };\n};\n\n/*!\n * ignore\n */\n\nSchemaSubdocument.prototype.clone = function() {\n  const schematype = new this.constructor(\n    this.schema,\n    this.path,\n    { ...this.options, _skipApplyDiscriminators: true }\n  );\n  schematype.validators = this.validators.slice();\n  if (this.requiredValidator !== undefined) {\n    schematype.requiredValidator = this.requiredValidator;\n  }\n  schematype.caster.discriminators = Object.assign({}, this.caster.discriminators);\n  return schematype;\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbW9uZ29vc2UvbGliL3NjaGVtYS9zdWJkb2N1bWVudC5qcyIsIm1hcHBpbmdzIjoiQUFBYTs7QUFFYjtBQUNBO0FBQ0E7O0FBRUEsa0JBQWtCLG1CQUFPLENBQUMsc0VBQWU7QUFDekMscUJBQXFCLDBEQUE4QjtBQUNuRCw0QkFBNEIsbUJBQU8sQ0FBQywwRkFBeUI7QUFDN0QsaUNBQWlDLG1CQUFPLENBQUMsa0hBQXFDO0FBQzlFLG1CQUFtQixtQkFBTyxDQUFDLHNFQUFlO0FBQzFDLHNCQUFzQixtQkFBTyxDQUFDLDhHQUFtQztBQUNqRSxnQkFBZ0IsbUJBQU8sQ0FBQyx3RkFBb0I7QUFDNUMscUJBQXFCLDhIQUEyQztBQUNoRSxzQkFBc0IsbUJBQU8sQ0FBQyx3R0FBZ0M7QUFDOUQsbUJBQW1CLG1CQUFPLENBQUMsZ0dBQXdCO0FBQ25ELHVCQUF1QixtQkFBTyxDQUFDLDBIQUF5QztBQUN4RSx1QkFBdUIsbUJBQU8sQ0FBQyw0R0FBa0M7QUFDakUsZ0NBQWdDLCtHQUE2QztBQUM3RSxvQkFBb0IsbUJBQU8sQ0FBQyw4R0FBbUM7QUFDL0QsY0FBYyxtQkFBTyxDQUFDLDREQUFVO0FBQ2hDLGlDQUFpQyxtQkFBTyxDQUFDLG9HQUE4Qjs7QUFFdkU7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSx3Q0FBd0MsbUJBQU8sQ0FBQyxvRkFBc0I7O0FBRXRFO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQjtBQUNBOztBQUVBO0FBQ0EsV0FBVztBQUNYOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsNkRBQTZELGlCQUFpQjtBQUM5RTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSiw4QkFBOEIsYUFBYSxvQkFBb0I7QUFDL0Q7QUFDQSwrQkFBK0I7QUFDL0I7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLEtBQUs7QUFDaEI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQyxjQUFjLElBQUksMEJBQTBCO0FBQ2hGLCtCQUErQixvQkFBb0I7QUFDbkQ7QUFDQTtBQUNBLHlEQUF5RCxnQkFBZ0I7QUFDekU7QUFDQSxXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsZUFBZTtBQUMxQixXQUFXLFFBQVE7QUFDbkIsV0FBVyxTQUFTO0FBQ3BCLFlBQVksVUFBVTtBQUN0QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFdBQVcsS0FBSztBQUNoQixZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxVQUFVO0FBQ3JCLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxXQUFXO0FBQ1g7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxREFBcUQ7QUFDckQ7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL2FwcDEvLi9ub2RlX21vZHVsZXMvbW9uZ29vc2UvbGliL3NjaGVtYS9zdWJkb2N1bWVudC5qcz9kMjhjIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxuLyohXG4gKiBNb2R1bGUgZGVwZW5kZW5jaWVzLlxuICovXG5cbmNvbnN0IENhc3RFcnJvciA9IHJlcXVpcmUoJy4uL2Vycm9yL2Nhc3QnKTtcbmNvbnN0IEV2ZW50RW1pdHRlciA9IHJlcXVpcmUoJ2V2ZW50cycpLkV2ZW50RW1pdHRlcjtcbmNvbnN0IE9iamVjdEV4cGVjdGVkRXJyb3IgPSByZXF1aXJlKCcuLi9lcnJvci9vYmplY3RFeHBlY3RlZCcpO1xuY29uc3QgU2NoZW1hU3ViZG9jdW1lbnRPcHRpb25zID0gcmVxdWlyZSgnLi4vb3B0aW9ucy9zY2hlbWFTdWJkb2N1bWVudE9wdGlvbnMnKTtcbmNvbnN0IFNjaGVtYVR5cGUgPSByZXF1aXJlKCcuLi9zY2hlbWFUeXBlJyk7XG5jb25zdCBhcHBseURlZmF1bHRzID0gcmVxdWlyZSgnLi4vaGVscGVycy9kb2N1bWVudC9hcHBseURlZmF1bHRzJyk7XG5jb25zdCAkZXhpc3RzID0gcmVxdWlyZSgnLi9vcGVyYXRvcnMvZXhpc3RzJyk7XG5jb25zdCBjYXN0VG9OdW1iZXIgPSByZXF1aXJlKCcuL29wZXJhdG9ycy9oZWxwZXJzJykuY2FzdFRvTnVtYmVyO1xuY29uc3QgZGlzY3JpbWluYXRvciA9IHJlcXVpcmUoJy4uL2hlbHBlcnMvbW9kZWwvZGlzY3JpbWluYXRvcicpO1xuY29uc3QgZ2Vvc3BhdGlhbCA9IHJlcXVpcmUoJy4vb3BlcmF0b3JzL2dlb3NwYXRpYWwnKTtcbmNvbnN0IGdldENvbnN0cnVjdG9yID0gcmVxdWlyZSgnLi4vaGVscGVycy9kaXNjcmltaW5hdG9yL2dldENvbnN0cnVjdG9yJyk7XG5jb25zdCBoYW5kbGVJZE9wdGlvbiA9IHJlcXVpcmUoJy4uL2hlbHBlcnMvc2NoZW1hL2hhbmRsZUlkT3B0aW9uJyk7XG5jb25zdCBpbnRlcm5hbFRvT2JqZWN0T3B0aW9ucyA9IHJlcXVpcmUoJy4uL29wdGlvbnMnKS5pbnRlcm5hbFRvT2JqZWN0T3B0aW9ucztcbmNvbnN0IGlzRXhjbHVzaXZlID0gcmVxdWlyZSgnLi4vaGVscGVycy9wcm9qZWN0aW9uL2lzRXhjbHVzaXZlJyk7XG5jb25zdCB1dGlscyA9IHJlcXVpcmUoJy4uL3V0aWxzJyk7XG5jb25zdCBJbnZhbGlkU2NoZW1hT3B0aW9uRXJyb3IgPSByZXF1aXJlKCcuLi9lcnJvci9pbnZhbGlkU2NoZW1hT3B0aW9uJyk7XG5cbmxldCBTdWJkb2N1bWVudFR5cGU7XG5cbm1vZHVsZS5leHBvcnRzID0gU2NoZW1hU3ViZG9jdW1lbnQ7XG5cbi8qKlxuICogU2luZ2xlIG5lc3RlZCBzdWJkb2N1bWVudCBTY2hlbWFUeXBlIGNvbnN0cnVjdG9yLlxuICpcbiAqIEBwYXJhbSB7U2NoZW1hfSBzY2hlbWFcbiAqIEBwYXJhbSB7U3RyaW5nfSBwYXRoXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xuICogQGluaGVyaXRzIFNjaGVtYVR5cGVcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZnVuY3Rpb24gU2NoZW1hU3ViZG9jdW1lbnQoc2NoZW1hLCBwYXRoLCBvcHRpb25zKSB7XG4gIGlmIChzY2hlbWEub3B0aW9ucy50aW1lc2VyaWVzKSB7XG4gICAgdGhyb3cgbmV3IEludmFsaWRTY2hlbWFPcHRpb25FcnJvcihwYXRoLCAndGltZXNlcmllcycpO1xuICB9XG4gIGNvbnN0IHNjaGVtYVR5cGVJZE9wdGlvbiA9IFNjaGVtYVN1YmRvY3VtZW50LmRlZmF1bHRPcHRpb25zICYmXG4gICAgU2NoZW1hU3ViZG9jdW1lbnQuZGVmYXVsdE9wdGlvbnMuX2lkO1xuICBpZiAoc2NoZW1hVHlwZUlkT3B0aW9uICE9IG51bGwpIHtcbiAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgICBvcHRpb25zLl9pZCA9IHNjaGVtYVR5cGVJZE9wdGlvbjtcbiAgfVxuXG4gIHNjaGVtYSA9IGhhbmRsZUlkT3B0aW9uKHNjaGVtYSwgb3B0aW9ucyk7XG5cbiAgdGhpcy5jYXN0ZXIgPSBfY3JlYXRlQ29uc3RydWN0b3Ioc2NoZW1hKTtcbiAgdGhpcy5jYXN0ZXIucGF0aCA9IHBhdGg7XG4gIHRoaXMuY2FzdGVyLnByb3RvdHlwZS4kYmFzZVBhdGggPSBwYXRoO1xuICB0aGlzLnNjaGVtYSA9IHNjaGVtYTtcbiAgdGhpcy4kaXNTaW5nbGVOZXN0ZWQgPSB0cnVlO1xuICB0aGlzLmJhc2UgPSBzY2hlbWEuYmFzZTtcbiAgU2NoZW1hVHlwZS5jYWxsKHRoaXMsIHBhdGgsIG9wdGlvbnMsICdFbWJlZGRlZCcpO1xuICBpZiAoc2NoZW1hLl9hcHBseURpc2NyaW1pbmF0b3JzICE9IG51bGwgJiYgIW9wdGlvbnM/Ll9za2lwQXBwbHlEaXNjcmltaW5hdG9ycykge1xuICAgIGZvciAoY29uc3QgZGlzYyBvZiBzY2hlbWEuX2FwcGx5RGlzY3JpbWluYXRvcnMua2V5cygpKSB7XG4gICAgICB0aGlzLmRpc2NyaW1pbmF0b3IoZGlzYywgc2NoZW1hLl9hcHBseURpc2NyaW1pbmF0b3JzLmdldChkaXNjKSk7XG4gICAgfVxuICB9XG59XG5cbi8qIVxuICogaWdub3JlXG4gKi9cblxuU2NoZW1hU3ViZG9jdW1lbnQucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShTY2hlbWFUeXBlLnByb3RvdHlwZSk7XG5TY2hlbWFTdWJkb2N1bWVudC5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBTY2hlbWFTdWJkb2N1bWVudDtcblNjaGVtYVN1YmRvY3VtZW50LnByb3RvdHlwZS5PcHRpb25zQ29uc3RydWN0b3IgPSBTY2hlbWFTdWJkb2N1bWVudE9wdGlvbnM7XG5cbi8qIVxuICogaWdub3JlXG4gKi9cblxuZnVuY3Rpb24gX2NyZWF0ZUNvbnN0cnVjdG9yKHNjaGVtYSwgYmFzZUNsYXNzKSB7XG4gIC8vIGxhenkgbG9hZFxuICBTdWJkb2N1bWVudFR5cGUgfHwgKFN1YmRvY3VtZW50VHlwZSA9IHJlcXVpcmUoJy4uL3R5cGVzL3N1YmRvY3VtZW50JykpO1xuXG4gIGNvbnN0IF9lbWJlZGRlZCA9IGZ1bmN0aW9uIFNpbmdsZU5lc3RlZCh2YWx1ZSwgcGF0aCwgcGFyZW50KSB7XG4gICAgdGhpcy4kX19wYXJlbnQgPSBwYXJlbnQ7XG4gICAgU3ViZG9jdW1lbnRUeXBlLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG5cbiAgICBpZiAocGFyZW50ID09IG51bGwpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy4kc2Vzc2lvbihwYXJlbnQuJHNlc3Npb24oKSk7XG4gIH07XG5cbiAgc2NoZW1hLl9wcmVDb21waWxlKCk7XG5cbiAgY29uc3QgcHJvdG8gPSBiYXNlQ2xhc3MgIT0gbnVsbCA/IGJhc2VDbGFzcy5wcm90b3R5cGUgOiBTdWJkb2N1bWVudFR5cGUucHJvdG90eXBlO1xuICBfZW1iZWRkZWQucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShwcm90byk7XG4gIF9lbWJlZGRlZC5wcm90b3R5cGUuJF9fc2V0U2NoZW1hKHNjaGVtYSk7XG4gIF9lbWJlZGRlZC5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBfZW1iZWRkZWQ7XG4gIF9lbWJlZGRlZC5iYXNlID0gc2NoZW1hLmJhc2U7XG4gIF9lbWJlZGRlZC5zY2hlbWEgPSBzY2hlbWE7XG4gIF9lbWJlZGRlZC4kaXNTaW5nbGVOZXN0ZWQgPSB0cnVlO1xuICBfZW1iZWRkZWQuZXZlbnRzID0gbmV3IEV2ZW50RW1pdHRlcigpO1xuICBfZW1iZWRkZWQucHJvdG90eXBlLnRvQlNPTiA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLnRvT2JqZWN0KGludGVybmFsVG9PYmplY3RPcHRpb25zKTtcbiAgfTtcblxuICAvLyBhcHBseSBtZXRob2RzXG4gIGZvciAoY29uc3QgaSBpbiBzY2hlbWEubWV0aG9kcykge1xuICAgIF9lbWJlZGRlZC5wcm90b3R5cGVbaV0gPSBzY2hlbWEubWV0aG9kc1tpXTtcbiAgfVxuXG4gIC8vIGFwcGx5IHN0YXRpY3NcbiAgZm9yIChjb25zdCBpIGluIHNjaGVtYS5zdGF0aWNzKSB7XG4gICAgX2VtYmVkZGVkW2ldID0gc2NoZW1hLnN0YXRpY3NbaV07XG4gIH1cblxuICBmb3IgKGNvbnN0IGkgaW4gRXZlbnRFbWl0dGVyLnByb3RvdHlwZSkge1xuICAgIF9lbWJlZGRlZFtpXSA9IEV2ZW50RW1pdHRlci5wcm90b3R5cGVbaV07XG4gIH1cblxuICByZXR1cm4gX2VtYmVkZGVkO1xufVxuXG4vKipcbiAqIFNwZWNpYWwgY2FzZSBmb3Igd2hlbiB1c2VycyB1c2UgYSBjb21tb24gbG9jYXRpb24gc2NoZW1hIHRvIHJlcHJlc2VudFxuICogbG9jYXRpb25zIGZvciB1c2Ugd2l0aCAkZ2VvV2l0aGluLlxuICogaHR0cHM6Ly93d3cubW9uZ29kYi5jb20vZG9jcy9tYW51YWwvcmVmZXJlbmNlL29wZXJhdG9yL3F1ZXJ5L2dlb1dpdGhpbi9cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gdmFsXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5TY2hlbWFTdWJkb2N1bWVudC5wcm90b3R5cGUuJGNvbmRpdGlvbmFsSGFuZGxlcnMuJGdlb1dpdGhpbiA9IGZ1bmN0aW9uIGhhbmRsZSRnZW9XaXRoaW4odmFsLCBjb250ZXh0KSB7XG4gIHJldHVybiB7ICRnZW9tZXRyeTogdGhpcy5jYXN0Rm9yUXVlcnkobnVsbCwgdmFsLiRnZW9tZXRyeSwgY29udGV4dCkgfTtcbn07XG5cbi8qIVxuICogaWdub3JlXG4gKi9cblxuU2NoZW1hU3ViZG9jdW1lbnQucHJvdG90eXBlLiRjb25kaXRpb25hbEhhbmRsZXJzLiRuZWFyID1cblNjaGVtYVN1YmRvY3VtZW50LnByb3RvdHlwZS4kY29uZGl0aW9uYWxIYW5kbGVycy4kbmVhclNwaGVyZSA9IGdlb3NwYXRpYWwuY2FzdCRuZWFyO1xuXG5TY2hlbWFTdWJkb2N1bWVudC5wcm90b3R5cGUuJGNvbmRpdGlvbmFsSGFuZGxlcnMuJHdpdGhpbiA9XG5TY2hlbWFTdWJkb2N1bWVudC5wcm90b3R5cGUuJGNvbmRpdGlvbmFsSGFuZGxlcnMuJGdlb1dpdGhpbiA9IGdlb3NwYXRpYWwuY2FzdCR3aXRoaW47XG5cblNjaGVtYVN1YmRvY3VtZW50LnByb3RvdHlwZS4kY29uZGl0aW9uYWxIYW5kbGVycy4kZ2VvSW50ZXJzZWN0cyA9XG4gIGdlb3NwYXRpYWwuY2FzdCRnZW9JbnRlcnNlY3RzO1xuXG5TY2hlbWFTdWJkb2N1bWVudC5wcm90b3R5cGUuJGNvbmRpdGlvbmFsSGFuZGxlcnMuJG1pbkRpc3RhbmNlID0gY2FzdFRvTnVtYmVyO1xuU2NoZW1hU3ViZG9jdW1lbnQucHJvdG90eXBlLiRjb25kaXRpb25hbEhhbmRsZXJzLiRtYXhEaXN0YW5jZSA9IGNhc3RUb051bWJlcjtcblxuU2NoZW1hU3ViZG9jdW1lbnQucHJvdG90eXBlLiRjb25kaXRpb25hbEhhbmRsZXJzLiRleGlzdHMgPSAkZXhpc3RzO1xuXG4vKipcbiAqIENhc3RzIGNvbnRlbnRzXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IHZhbHVlXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5TY2hlbWFTdWJkb2N1bWVudC5wcm90b3R5cGUuY2FzdCA9IGZ1bmN0aW9uKHZhbCwgZG9jLCBpbml0LCBwcmlvclZhbCwgb3B0aW9ucykge1xuICBpZiAodmFsICYmIHZhbC4kaXNTaW5nbGVOZXN0ZWQgJiYgdmFsLnBhcmVudCA9PT0gZG9jKSB7XG4gICAgcmV0dXJuIHZhbDtcbiAgfVxuXG4gIGlmICh2YWwgIT0gbnVsbCAmJiAodHlwZW9mIHZhbCAhPT0gJ29iamVjdCcgfHwgQXJyYXkuaXNBcnJheSh2YWwpKSkge1xuICAgIHRocm93IG5ldyBPYmplY3RFeHBlY3RlZEVycm9yKHRoaXMucGF0aCwgdmFsKTtcbiAgfVxuXG4gIGNvbnN0IGRpc2NyaW1pbmF0b3JLZXlQYXRoID0gdGhpcy5zY2hlbWEucGF0aCh0aGlzLnNjaGVtYS5vcHRpb25zLmRpc2NyaW1pbmF0b3JLZXkpO1xuICBjb25zdCBkZWZhdWx0RGlzY3JpbWluYXRvclZhbHVlID0gZGlzY3JpbWluYXRvcktleVBhdGggPT0gbnVsbCA/IG51bGwgOiBkaXNjcmltaW5hdG9yS2V5UGF0aC5nZXREZWZhdWx0KGRvYyk7XG4gIGNvbnN0IENvbnN0cnVjdG9yID0gZ2V0Q29uc3RydWN0b3IodGhpcy5jYXN0ZXIsIHZhbCwgZGVmYXVsdERpc2NyaW1pbmF0b3JWYWx1ZSk7XG5cbiAgbGV0IHN1YmRvYztcblxuICAvLyBPbmx5IHB1bGwgcmVsZXZhbnQgc2VsZWN0ZWQgcGF0aHMgYW5kIHB1bGwgb3V0IHRoZSBiYXNlIHBhdGhcbiAgY29uc3QgcGFyZW50U2VsZWN0ZWQgPSBkb2MgJiYgZG9jLiRfXyAmJiBkb2MuJF9fLnNlbGVjdGVkO1xuICBjb25zdCBwYXRoID0gdGhpcy5wYXRoO1xuICBjb25zdCBzZWxlY3RlZCA9IHBhcmVudFNlbGVjdGVkID09IG51bGwgPyBudWxsIDogT2JqZWN0LmtleXMocGFyZW50U2VsZWN0ZWQpLnJlZHVjZSgob2JqLCBrZXkpID0+IHtcbiAgICBpZiAoa2V5LnN0YXJ0c1dpdGgocGF0aCArICcuJykpIHtcbiAgICAgIG9iaiA9IG9iaiB8fCB7fTtcbiAgICAgIG9ialtrZXkuc3Vic3RyaW5nKHBhdGgubGVuZ3RoICsgMSldID0gcGFyZW50U2VsZWN0ZWRba2V5XTtcbiAgICB9XG4gICAgcmV0dXJuIG9iajtcbiAgfSwgbnVsbCk7XG4gIGlmIChpbml0KSB7XG4gICAgc3ViZG9jID0gbmV3IENvbnN0cnVjdG9yKHZvaWQgMCwgc2VsZWN0ZWQsIGRvYywgZmFsc2UsIHsgZGVmYXVsdHM6IGZhbHNlIH0pO1xuICAgIGRlbGV0ZSBzdWJkb2MuJF9fLmRlZmF1bHRzO1xuICAgIHN1YmRvYy4kaW5pdCh2YWwpO1xuICAgIGNvbnN0IGV4Y2x1ZGUgPSBpc0V4Y2x1c2l2ZShzZWxlY3RlZCk7XG4gICAgYXBwbHlEZWZhdWx0cyhzdWJkb2MsIHNlbGVjdGVkLCBleGNsdWRlKTtcbiAgfSBlbHNlIHtcbiAgICBvcHRpb25zID0gT2JqZWN0LmFzc2lnbih7fSwgb3B0aW9ucywgeyBwcmlvckRvYzogcHJpb3JWYWwgfSk7XG4gICAgaWYgKE9iamVjdC5rZXlzKHZhbCkubGVuZ3RoID09PSAwKSB7XG4gICAgICByZXR1cm4gbmV3IENvbnN0cnVjdG9yKHt9LCBzZWxlY3RlZCwgZG9jLCB1bmRlZmluZWQsIG9wdGlvbnMpO1xuICAgIH1cblxuICAgIHJldHVybiBuZXcgQ29uc3RydWN0b3IodmFsLCBzZWxlY3RlZCwgZG9jLCB1bmRlZmluZWQsIG9wdGlvbnMpO1xuICB9XG5cbiAgcmV0dXJuIHN1YmRvYztcbn07XG5cbi8qKlxuICogQ2FzdHMgY29udGVudHMgZm9yIHF1ZXJ5XG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IFskY29uZGl0aW9uYWxdIG9wdGlvbmFsIHF1ZXJ5IG9wZXJhdG9yIChsaWtlIGAkZXFgIG9yIGAkaW5gKVxuICogQHBhcmFtIHthbnl9IHZhbHVlXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5TY2hlbWFTdWJkb2N1bWVudC5wcm90b3R5cGUuY2FzdEZvclF1ZXJ5ID0gZnVuY3Rpb24oJGNvbmRpdGlvbmFsLCB2YWwsIGNvbnRleHQsIG9wdGlvbnMpIHtcbiAgbGV0IGhhbmRsZXI7XG4gIGlmICgkY29uZGl0aW9uYWwgIT0gbnVsbCkge1xuICAgIGhhbmRsZXIgPSB0aGlzLiRjb25kaXRpb25hbEhhbmRsZXJzWyRjb25kaXRpb25hbF07XG4gICAgaWYgKCFoYW5kbGVyKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0NhblxcJ3QgdXNlICcgKyAkY29uZGl0aW9uYWwpO1xuICAgIH1cbiAgICByZXR1cm4gaGFuZGxlci5jYWxsKHRoaXMsIHZhbCk7XG4gIH1cbiAgaWYgKHZhbCA9PSBudWxsKSB7XG4gICAgcmV0dXJuIHZhbDtcbiAgfVxuXG4gIGNvbnN0IENvbnN0cnVjdG9yID0gZ2V0Q29uc3RydWN0b3IodGhpcy5jYXN0ZXIsIHZhbCk7XG4gIGlmICh2YWwgaW5zdGFuY2VvZiBDb25zdHJ1Y3Rvcikge1xuICAgIHJldHVybiB2YWw7XG4gIH1cblxuICBpZiAodGhpcy5vcHRpb25zLnJ1blNldHRlcnMpIHtcbiAgICB2YWwgPSB0aGlzLl9hcHBseVNldHRlcnModmFsLCBjb250ZXh0KTtcbiAgfVxuXG4gIGNvbnN0IG92ZXJyaWRlU3RyaWN0ID0gb3B0aW9ucyAhPSBudWxsICYmIG9wdGlvbnMuc3RyaWN0ICE9IG51bGwgP1xuICAgIG9wdGlvbnMuc3RyaWN0IDpcbiAgICB2b2lkIDA7XG5cbiAgdHJ5IHtcbiAgICB2YWwgPSBuZXcgQ29uc3RydWN0b3IodmFsLCBvdmVycmlkZVN0cmljdCk7XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgLy8gTWFrZSBzdXJlIHdlIGFsd2F5cyB3cmFwIGluIGEgQ2FzdEVycm9yIChnaC02ODAzKVxuICAgIGlmICghKGVycm9yIGluc3RhbmNlb2YgQ2FzdEVycm9yKSkge1xuICAgICAgdGhyb3cgbmV3IENhc3RFcnJvcignRW1iZWRkZWQnLCB2YWwsIHRoaXMucGF0aCwgZXJyb3IsIHRoaXMpO1xuICAgIH1cbiAgICB0aHJvdyBlcnJvcjtcbiAgfVxuICByZXR1cm4gdmFsO1xufTtcblxuLyoqXG4gKiBBc3luYyB2YWxpZGF0aW9uIG9uIHRoaXMgc2luZ2xlIG5lc3RlZCBkb2MuXG4gKlxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuU2NoZW1hU3ViZG9jdW1lbnQucHJvdG90eXBlLmRvVmFsaWRhdGUgPSBmdW5jdGlvbih2YWx1ZSwgZm4sIHNjb3BlLCBvcHRpb25zKSB7XG4gIGNvbnN0IENvbnN0cnVjdG9yID0gZ2V0Q29uc3RydWN0b3IodGhpcy5jYXN0ZXIsIHZhbHVlKTtcblxuICBpZiAodmFsdWUgJiYgISh2YWx1ZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkge1xuICAgIHZhbHVlID0gbmV3IENvbnN0cnVjdG9yKHZhbHVlLCBudWxsLCAoc2NvcGUgIT0gbnVsbCAmJiBzY29wZS4kX18gIT0gbnVsbCkgPyBzY29wZSA6IG51bGwpO1xuICB9XG5cbiAgaWYgKG9wdGlvbnMgJiYgb3B0aW9ucy5za2lwU2NoZW1hVmFsaWRhdG9ycykge1xuICAgIGlmICghdmFsdWUpIHtcbiAgICAgIHJldHVybiBmbihudWxsKTtcbiAgICB9XG4gICAgcmV0dXJuIHZhbHVlLnZhbGlkYXRlKCkudGhlbigoKSA9PiBmbihudWxsKSwgZXJyID0+IGZuKGVycikpO1xuICB9XG5cbiAgU2NoZW1hVHlwZS5wcm90b3R5cGUuZG9WYWxpZGF0ZS5jYWxsKHRoaXMsIHZhbHVlLCBmdW5jdGlvbihlcnJvcikge1xuICAgIGlmIChlcnJvcikge1xuICAgICAgcmV0dXJuIGZuKGVycm9yKTtcbiAgICB9XG4gICAgaWYgKCF2YWx1ZSkge1xuICAgICAgcmV0dXJuIGZuKG51bGwpO1xuICAgIH1cblxuICAgIHZhbHVlLnZhbGlkYXRlKCkudGhlbigoKSA9PiBmbihudWxsKSwgZXJyID0+IGZuKGVycikpO1xuICB9LCBzY29wZSwgb3B0aW9ucyk7XG59O1xuXG4vKipcbiAqIFN5bmNocm9ub3VzbHkgdmFsaWRhdGUgdGhpcyBzaW5nbGUgbmVzdGVkIGRvY1xuICpcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cblNjaGVtYVN1YmRvY3VtZW50LnByb3RvdHlwZS5kb1ZhbGlkYXRlU3luYyA9IGZ1bmN0aW9uKHZhbHVlLCBzY29wZSwgb3B0aW9ucykge1xuICBpZiAoIW9wdGlvbnMgfHwgIW9wdGlvbnMuc2tpcFNjaGVtYVZhbGlkYXRvcnMpIHtcbiAgICBjb25zdCBzY2hlbWFUeXBlRXJyb3IgPSBTY2hlbWFUeXBlLnByb3RvdHlwZS5kb1ZhbGlkYXRlU3luYy5jYWxsKHRoaXMsIHZhbHVlLCBzY29wZSk7XG4gICAgaWYgKHNjaGVtYVR5cGVFcnJvcikge1xuICAgICAgcmV0dXJuIHNjaGVtYVR5cGVFcnJvcjtcbiAgICB9XG4gIH1cbiAgaWYgKCF2YWx1ZSkge1xuICAgIHJldHVybjtcbiAgfVxuICByZXR1cm4gdmFsdWUudmFsaWRhdGVTeW5jKCk7XG59O1xuXG4vKipcbiAqIEFkZHMgYSBkaXNjcmltaW5hdG9yIHRvIHRoaXMgc2luZ2xlIG5lc3RlZCBzdWJkb2N1bWVudC5cbiAqXG4gKiAjIyMjIEV4YW1wbGU6XG4gKlxuICogICAgIGNvbnN0IHNoYXBlU2NoZW1hID0gU2NoZW1hKHsgbmFtZTogU3RyaW5nIH0sIHsgZGlzY3JpbWluYXRvcktleTogJ2tpbmQnIH0pO1xuICogICAgIGNvbnN0IHNjaGVtYSA9IFNjaGVtYSh7IHNoYXBlOiBzaGFwZVNjaGVtYSB9KTtcbiAqXG4gKiAgICAgY29uc3Qgc2luZ2xlTmVzdGVkUGF0aCA9IHBhcmVudFNjaGVtYS5wYXRoKCdzaGFwZScpO1xuICogICAgIHNpbmdsZU5lc3RlZFBhdGguZGlzY3JpbWluYXRvcignQ2lyY2xlJywgU2NoZW1hKHsgcmFkaXVzOiBOdW1iZXIgfSkpO1xuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lXG4gKiBAcGFyYW0ge1NjaGVtYX0gc2NoZW1hIGZpZWxkcyB0byBhZGQgdG8gdGhlIHNjaGVtYSBmb3IgaW5zdGFuY2VzIG9mIHRoaXMgc3ViLWNsYXNzXG4gKiBAcGFyYW0ge09iamVjdHxzdHJpbmd9IFtvcHRpb25zXSBJZiBzdHJpbmcsIHNhbWUgYXMgYG9wdGlvbnMudmFsdWVgLlxuICogQHBhcmFtIHtTdHJpbmd9IFtvcHRpb25zLnZhbHVlXSB0aGUgc3RyaW5nIHN0b3JlZCBpbiB0aGUgYGRpc2NyaW1pbmF0b3JLZXlgIHByb3BlcnR5LiBJZiBub3Qgc3BlY2lmaWVkLCBNb25nb29zZSB1c2VzIHRoZSBgbmFtZWAgcGFyYW1ldGVyLlxuICogQHBhcmFtIHtCb29sZWFufSBbb3B0aW9ucy5jbG9uZT10cnVlXSBCeSBkZWZhdWx0LCBgZGlzY3JpbWluYXRvcigpYCBjbG9uZXMgdGhlIGdpdmVuIGBzY2hlbWFgLiBTZXQgdG8gYGZhbHNlYCB0byBza2lwIGNsb25pbmcuXG4gKiBAcmV0dXJuIHtGdW5jdGlvbn0gdGhlIGNvbnN0cnVjdG9yIE1vbmdvb3NlIHdpbGwgdXNlIGZvciBjcmVhdGluZyBpbnN0YW5jZXMgb2YgdGhpcyBkaXNjcmltaW5hdG9yIG1vZGVsXG4gKiBAc2VlIGRpc2NyaW1pbmF0b3JzIGh0dHBzOi8vbW9uZ29vc2Vqcy5jb20vZG9jcy9kaXNjcmltaW5hdG9ycy5odG1sXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cblNjaGVtYVN1YmRvY3VtZW50LnByb3RvdHlwZS5kaXNjcmltaW5hdG9yID0gZnVuY3Rpb24obmFtZSwgc2NoZW1hLCBvcHRpb25zKSB7XG4gIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICBjb25zdCB2YWx1ZSA9IHV0aWxzLmlzUE9KTyhvcHRpb25zKSA/IG9wdGlvbnMudmFsdWUgOiBvcHRpb25zO1xuICBjb25zdCBjbG9uZSA9IHR5cGVvZiBvcHRpb25zLmNsb25lID09PSAnYm9vbGVhbidcbiAgICA/IG9wdGlvbnMuY2xvbmVcbiAgICA6IHRydWU7XG5cbiAgaWYgKHNjaGVtYS5pbnN0YW5jZU9mU2NoZW1hICYmIGNsb25lKSB7XG4gICAgc2NoZW1hID0gc2NoZW1hLmNsb25lKCk7XG4gIH1cblxuICBzY2hlbWEgPSBkaXNjcmltaW5hdG9yKHRoaXMuY2FzdGVyLCBuYW1lLCBzY2hlbWEsIHZhbHVlKTtcblxuICB0aGlzLmNhc3Rlci5kaXNjcmltaW5hdG9yc1tuYW1lXSA9IF9jcmVhdGVDb25zdHJ1Y3RvcihzY2hlbWEsIHRoaXMuY2FzdGVyKTtcblxuICByZXR1cm4gdGhpcy5jYXN0ZXIuZGlzY3JpbWluYXRvcnNbbmFtZV07XG59O1xuXG4vKiFcbiAqIGlnbm9yZVxuICovXG5cblNjaGVtYVN1YmRvY3VtZW50LmRlZmF1bHRPcHRpb25zID0ge307XG5cbi8qKlxuICogU2V0cyBhIGRlZmF1bHQgb3B0aW9uIGZvciBhbGwgU3ViZG9jdW1lbnQgaW5zdGFuY2VzLlxuICpcbiAqICMjIyMgRXhhbXBsZTpcbiAqXG4gKiAgICAgLy8gTWFrZSBhbGwgbnVtYmVycyBoYXZlIG9wdGlvbiBgbWluYCBlcXVhbCB0byAwLlxuICogICAgIG1vbmdvb3NlLlNjaGVtYS5TdWJkb2N1bWVudC5zZXQoJ3JlcXVpcmVkJywgdHJ1ZSk7XG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IG9wdGlvbiBUaGUgb3B0aW9uIHlvdSdkIGxpa2UgdG8gc2V0IHRoZSB2YWx1ZSBmb3JcbiAqIEBwYXJhbSB7QW55fSB2YWx1ZSB2YWx1ZSBmb3Igb3B0aW9uXG4gKiBAcmV0dXJuIHt2b2lkfVxuICogQGZ1bmN0aW9uIHNldFxuICogQHN0YXRpY1xuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5TY2hlbWFTdWJkb2N1bWVudC5zZXQgPSBTY2hlbWFUeXBlLnNldDtcblxuU2NoZW1hU3ViZG9jdW1lbnQuc2V0dGVycyA9IFtdO1xuXG4vKipcbiAqIEF0dGFjaGVzIGEgZ2V0dGVyIGZvciBhbGwgU3ViZG9jdW1lbnQgaW5zdGFuY2VzXG4gKlxuICogQHBhcmFtIHtGdW5jdGlvbn0gZ2V0dGVyXG4gKiBAcmV0dXJuIHt0aGlzfVxuICogQGZ1bmN0aW9uIGdldFxuICogQHN0YXRpY1xuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5TY2hlbWFTdWJkb2N1bWVudC5nZXQgPSBTY2hlbWFUeXBlLmdldDtcblxuLyohXG4gKiBpZ25vcmVcbiAqL1xuXG5TY2hlbWFTdWJkb2N1bWVudC5wcm90b3R5cGUudG9KU09OID0gZnVuY3Rpb24gdG9KU09OKCkge1xuICByZXR1cm4geyBwYXRoOiB0aGlzLnBhdGgsIG9wdGlvbnM6IHRoaXMub3B0aW9ucyB9O1xufTtcblxuLyohXG4gKiBpZ25vcmVcbiAqL1xuXG5TY2hlbWFTdWJkb2N1bWVudC5wcm90b3R5cGUuY2xvbmUgPSBmdW5jdGlvbigpIHtcbiAgY29uc3Qgc2NoZW1hdHlwZSA9IG5ldyB0aGlzLmNvbnN0cnVjdG9yKFxuICAgIHRoaXMuc2NoZW1hLFxuICAgIHRoaXMucGF0aCxcbiAgICB7IC4uLnRoaXMub3B0aW9ucywgX3NraXBBcHBseURpc2NyaW1pbmF0b3JzOiB0cnVlIH1cbiAgKTtcbiAgc2NoZW1hdHlwZS52YWxpZGF0b3JzID0gdGhpcy52YWxpZGF0b3JzLnNsaWNlKCk7XG4gIGlmICh0aGlzLnJlcXVpcmVkVmFsaWRhdG9yICE9PSB1bmRlZmluZWQpIHtcbiAgICBzY2hlbWF0eXBlLnJlcXVpcmVkVmFsaWRhdG9yID0gdGhpcy5yZXF1aXJlZFZhbGlkYXRvcjtcbiAgfVxuICBzY2hlbWF0eXBlLmNhc3Rlci5kaXNjcmltaW5hdG9ycyA9IE9iamVjdC5hc3NpZ24oe30sIHRoaXMuY2FzdGVyLmRpc2NyaW1pbmF0b3JzKTtcbiAgcmV0dXJuIHNjaGVtYXR5cGU7XG59O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/mongoose/lib/schema/subdocument.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/mongoose/lib/schema/symbols.js":
/*!*****************************************************!*\
  !*** ./node_modules/mongoose/lib/schema/symbols.js ***!
  \*****************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\n\nexports.schemaMixedSymbol = Symbol.for('mongoose:schema_mixed');\n\nexports.builtInMiddleware = Symbol.for('mongoose:built-in-middleware');\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbW9uZ29vc2UvbGliL3NjaGVtYS9zeW1ib2xzLmpzIiwibWFwcGluZ3MiOiJBQUFhOztBQUViLHlCQUF5Qjs7QUFFekIseUJBQXlCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vYXBwMS8uL25vZGVfbW9kdWxlcy9tb25nb29zZS9saWIvc2NoZW1hL3N5bWJvbHMuanM/MzQ0ZiJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbmV4cG9ydHMuc2NoZW1hTWl4ZWRTeW1ib2wgPSBTeW1ib2wuZm9yKCdtb25nb29zZTpzY2hlbWFfbWl4ZWQnKTtcblxuZXhwb3J0cy5idWlsdEluTWlkZGxld2FyZSA9IFN5bWJvbC5mb3IoJ21vbmdvb3NlOmJ1aWx0LWluLW1pZGRsZXdhcmUnKTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/mongoose/lib/schema/symbols.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/mongoose/lib/schema/uuid.js":
/*!**************************************************!*\
  !*** ./node_modules/mongoose/lib/schema/uuid.js ***!
  \**************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("/*!\n * Module dependencies.\n */\n\n\n\nconst MongooseBuffer = __webpack_require__(/*! ../types/buffer */ \"(ssr)/./node_modules/mongoose/lib/types/buffer.js\");\nconst SchemaType = __webpack_require__(/*! ../schemaType */ \"(ssr)/./node_modules/mongoose/lib/schemaType.js\");\nconst CastError = SchemaType.CastError;\nconst utils = __webpack_require__(/*! ../utils */ \"(ssr)/./node_modules/mongoose/lib/utils.js\");\nconst handleBitwiseOperator = __webpack_require__(/*! ./operators/bitwise */ \"(ssr)/./node_modules/mongoose/lib/schema/operators/bitwise.js\");\n\nconst UUID_FORMAT = /[0-9a-f]{8}-[0-9a-f]{4}-[0-9][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}/i;\nconst Binary = MongooseBuffer.Binary;\n\n/**\n * Helper function to convert the input hex-string to a buffer\n * @param {String} hex The hex string to convert\n * @returns {Buffer} The hex as buffer\n * @api private\n */\n\nfunction hex2buffer(hex) {\n  // use buffer built-in function to convert from hex-string to buffer\n  const buff = hex != null && Buffer.from(hex, 'hex');\n  return buff;\n}\n\n/**\n * Helper function to convert the buffer input to a string\n * @param {Buffer} buf The buffer to convert to a hex-string\n * @returns {String} The buffer as a hex-string\n * @api private\n */\n\nfunction binary2hex(buf) {\n  // use buffer built-in function to convert from buffer to hex-string\n  const hex = buf != null && buf.toString('hex');\n  return hex;\n}\n\n/**\n * Convert a String to Binary\n * @param {String} uuidStr The value to process\n * @returns {MongooseBuffer} The binary to store\n * @api private\n */\n\nfunction stringToBinary(uuidStr) {\n  // Protect against undefined & throwing err\n  if (typeof uuidStr !== 'string') uuidStr = '';\n  const hex = uuidStr.replace(/[{}-]/g, ''); // remove extra characters\n  const bytes = hex2buffer(hex);\n  const buff = new MongooseBuffer(bytes);\n  buff._subtype = 4;\n\n  return buff;\n}\n\n/**\n * Convert binary to a uuid string\n * @param {Buffer|Binary|String} uuidBin The value to process\n * @returns {String} The completed uuid-string\n * @api private\n */\nfunction binaryToString(uuidBin) {\n  // i(hasezoey) dont quite know why, but \"uuidBin\" may sometimes also be the already processed string\n  let hex;\n  if (typeof uuidBin !== 'string' && uuidBin != null) {\n    hex = binary2hex(uuidBin);\n    const uuidStr = hex.substring(0, 8) + '-' + hex.substring(8, 8 + 4) + '-' + hex.substring(12, 12 + 4) + '-' + hex.substring(16, 16 + 4) + '-' + hex.substring(20, 20 + 12);\n    return uuidStr;\n  }\n  return uuidBin;\n}\n\n/**\n * UUIDv1 SchemaType constructor.\n *\n * @param {String} key\n * @param {Object} options\n * @inherits SchemaType\n * @api public\n */\n\nfunction SchemaUUID(key, options) {\n  SchemaType.call(this, key, options, 'UUID');\n  this.getters.push(function(value) {\n    // For populated\n    if (value != null && value.$__ != null) {\n      return value;\n    }\n    return binaryToString(value);\n  });\n}\n\n/**\n * This schema type's name, to defend against minifiers that mangle\n * function names.\n *\n * @api public\n */\nSchemaUUID.schemaName = 'UUID';\n\nSchemaUUID.defaultOptions = {};\n\n/*!\n * Inherits from SchemaType.\n */\nSchemaUUID.prototype = Object.create(SchemaType.prototype);\nSchemaUUID.prototype.constructor = SchemaUUID;\n\n/*!\n * ignore\n */\n\nSchemaUUID._cast = function(value) {\n  if (value == null) {\n    return value;\n  }\n\n  function newBuffer(initbuff) {\n    const buff = new MongooseBuffer(initbuff);\n    buff._subtype = 4;\n    return buff;\n  }\n\n  if (typeof value === 'string') {\n    if (UUID_FORMAT.test(value)) {\n      return stringToBinary(value);\n    } else {\n      throw new CastError(SchemaUUID.schemaName, value, this.path);\n    }\n  }\n\n  if (Buffer.isBuffer(value)) {\n    return newBuffer(value);\n  }\n\n  if (value instanceof Binary) {\n    return newBuffer(value.value(true));\n  }\n\n  // Re: gh-647 and gh-3030, we're ok with casting using `toString()`\n  // **unless** its the default Object.toString, because \"[object Object]\"\n  // doesn't really qualify as useful data\n  if (value.toString && value.toString !== Object.prototype.toString) {\n    if (UUID_FORMAT.test(value.toString())) {\n      return stringToBinary(value.toString());\n    }\n  }\n\n  throw new CastError(SchemaUUID.schemaName, value, this.path);\n};\n\n/**\n * Attaches a getter for all UUID instances.\n *\n * #### Example:\n *\n *     // Note that `v` is a string by default\n *     mongoose.Schema.UUID.get(v => v.toUpperCase());\n *\n *     const Model = mongoose.model('Test', new Schema({ test: 'UUID' }));\n *     new Model({ test: uuid.v4() }).test; // UUID with all uppercase\n *\n * @param {Function} getter\n * @return {this}\n * @function get\n * @static\n * @api public\n */\n\nSchemaUUID.get = SchemaType.get;\n\n/**\n * Sets a default option for all UUID instances.\n *\n * #### Example:\n *\n *     // Make all UUIDs have `required` of true by default.\n *     mongoose.Schema.UUID.set('required', true);\n *\n *     const User = mongoose.model('User', new Schema({ test: mongoose.UUID }));\n *     new User({ }).validateSync().errors.test.message; // Path `test` is required.\n *\n * @param {String} option The option you'd like to set the value for\n * @param {Any} value value for option\n * @return {undefined}\n * @function set\n * @static\n * @api public\n */\n\nSchemaUUID.set = SchemaType.set;\n\nSchemaUUID.setters = [];\n\n/**\n * Get/set the function used to cast arbitrary values to UUIDs.\n *\n * #### Example:\n *\n *     // Make Mongoose refuse to cast UUIDs with 0 length\n *     const original = mongoose.Schema.Types.UUID.cast();\n *     mongoose.UUID.cast(v => {\n *       assert.ok(typeof v === \"string\" && v.length > 0);\n *       return original(v);\n *     });\n *\n *     // Or disable casting entirely\n *     mongoose.UUID.cast(false);\n *\n * @param {Function} [caster]\n * @return {Function}\n * @function get\n * @static\n * @api public\n */\n\nSchemaUUID.cast = function cast(caster) {\n  if (arguments.length === 0) {\n    return this._cast;\n  }\n  if (caster === false) {\n    caster = this._defaultCaster;\n  }\n  this._cast = caster;\n\n  return this._cast;\n};\n\n/*!\n * ignore\n */\n\nSchemaUUID._checkRequired = v => v != null;\n\n/**\n * Override the function the required validator uses to check whether a string\n * passes the `required` check.\n *\n * @param {Function} fn\n * @return {Function}\n * @function checkRequired\n * @static\n * @api public\n */\n\nSchemaUUID.checkRequired = SchemaType.checkRequired;\n\n/**\n * Check if the given value satisfies a required validator.\n *\n * @param {Any} value\n * @return {Boolean}\n * @api public\n */\n\nSchemaUUID.prototype.checkRequired = function checkRequired(value) {\n  if (Buffer.isBuffer(value)) {\n    value = binaryToString(value);\n  }\n  return value != null && UUID_FORMAT.test(value);\n};\n\n/**\n * Casts to UUID\n *\n * @param {Object} value\n * @param {Object} doc\n * @param {Boolean} init whether this is an initialization cast\n * @api private\n */\n\nSchemaUUID.prototype.cast = function(value, doc, init) {\n  if (utils.isNonBuiltinObject(value) &&\n      SchemaType._isRef(this, value, doc, init)) {\n    return this._castRef(value, doc, init);\n  }\n\n  let castFn;\n  if (typeof this._castFunction === 'function') {\n    castFn = this._castFunction;\n  } else if (typeof this.constructor.cast === 'function') {\n    castFn = this.constructor.cast();\n  } else {\n    castFn = SchemaUUID.cast();\n  }\n\n  try {\n    return castFn(value);\n  } catch (error) {\n    throw new CastError(SchemaUUID.schemaName, value, this.path, error, this);\n  }\n};\n\n/*!\n * ignore\n */\n\nfunction handleSingle(val) {\n  return this.cast(val);\n}\n\n/*!\n * ignore\n */\n\nfunction handleArray(val) {\n  return val.map((m) => {\n    return this.cast(m);\n  });\n}\n\nSchemaUUID.prototype.$conditionalHandlers =\nutils.options(SchemaType.prototype.$conditionalHandlers, {\n  $bitsAllClear: handleBitwiseOperator,\n  $bitsAnyClear: handleBitwiseOperator,\n  $bitsAllSet: handleBitwiseOperator,\n  $bitsAnySet: handleBitwiseOperator,\n  $all: handleArray,\n  $gt: handleSingle,\n  $gte: handleSingle,\n  $in: handleArray,\n  $lt: handleSingle,\n  $lte: handleSingle,\n  $ne: handleSingle,\n  $nin: handleArray\n});\n\n/**\n * Casts contents for queries.\n *\n * @param {String} $conditional\n * @param {any} val\n * @api private\n */\n\nSchemaUUID.prototype.castForQuery = function($conditional, val, context) {\n  let handler;\n  if ($conditional != null) {\n    handler = this.$conditionalHandlers[$conditional];\n    if (!handler)\n      throw new Error('Can\\'t use ' + $conditional + ' with UUID.');\n    return handler.call(this, val, context);\n  } else {\n    return this.cast(val);\n  }\n};\n\n/*!\n * Module exports.\n */\n\nmodule.exports = SchemaUUID;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbW9uZ29vc2UvbGliL3NjaGVtYS91dWlkLmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTs7QUFFYTs7QUFFYix1QkFBdUIsbUJBQU8sQ0FBQywwRUFBaUI7QUFDaEQsbUJBQW1CLG1CQUFPLENBQUMsc0VBQWU7QUFDMUM7QUFDQSxjQUFjLG1CQUFPLENBQUMsNERBQVU7QUFDaEMsOEJBQThCLG1CQUFPLENBQUMsMEZBQXFCOztBQUUzRCw4QkFBOEIsRUFBRSxVQUFVLEVBQUUsZUFBZSxFQUFFLGdCQUFnQixFQUFFLFVBQVUsR0FBRztBQUM1Rjs7QUFFQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLGFBQWEsUUFBUTtBQUNyQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixhQUFhLFFBQVE7QUFDckI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsYUFBYSxnQkFBZ0I7QUFDN0I7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0MsV0FBVztBQUM3QztBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsV0FBVyxzQkFBc0I7QUFDakMsYUFBYSxRQUFRO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseURBQXlELGNBQWM7QUFDdkUsbUJBQW1CLGlCQUFpQixRQUFRO0FBQzVDO0FBQ0EsV0FBVyxVQUFVO0FBQ3JCLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0RBQXdELHFCQUFxQjtBQUM3RSxtQkFBbUIsc0NBQXNDO0FBQ3pEO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFdBQVcsS0FBSztBQUNoQixZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFVBQVU7QUFDckIsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFVBQVU7QUFDckIsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsS0FBSztBQUNoQixZQUFZO0FBQ1o7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixXQUFXLFNBQVM7QUFDcEI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBLElBQUk7QUFDSjtBQUNBOztBQUVBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsV0FBVyxLQUFLO0FBQ2hCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSIsInNvdXJjZXMiOlsid2VicGFjazovL2FwcDEvLi9ub2RlX21vZHVsZXMvbW9uZ29vc2UvbGliL3NjaGVtYS91dWlkLmpzP2YzZTUiXSwic291cmNlc0NvbnRlbnQiOlsiLyohXG4gKiBNb2R1bGUgZGVwZW5kZW5jaWVzLlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxuY29uc3QgTW9uZ29vc2VCdWZmZXIgPSByZXF1aXJlKCcuLi90eXBlcy9idWZmZXInKTtcbmNvbnN0IFNjaGVtYVR5cGUgPSByZXF1aXJlKCcuLi9zY2hlbWFUeXBlJyk7XG5jb25zdCBDYXN0RXJyb3IgPSBTY2hlbWFUeXBlLkNhc3RFcnJvcjtcbmNvbnN0IHV0aWxzID0gcmVxdWlyZSgnLi4vdXRpbHMnKTtcbmNvbnN0IGhhbmRsZUJpdHdpc2VPcGVyYXRvciA9IHJlcXVpcmUoJy4vb3BlcmF0b3JzL2JpdHdpc2UnKTtcblxuY29uc3QgVVVJRF9GT1JNQVQgPSAvWzAtOWEtZl17OH0tWzAtOWEtZl17NH0tWzAtOV1bMC05YS1mXXszfS1bODlhYl1bMC05YS1mXXszfS1bMC05YS1mXXsxMn0vaTtcbmNvbnN0IEJpbmFyeSA9IE1vbmdvb3NlQnVmZmVyLkJpbmFyeTtcblxuLyoqXG4gKiBIZWxwZXIgZnVuY3Rpb24gdG8gY29udmVydCB0aGUgaW5wdXQgaGV4LXN0cmluZyB0byBhIGJ1ZmZlclxuICogQHBhcmFtIHtTdHJpbmd9IGhleCBUaGUgaGV4IHN0cmluZyB0byBjb252ZXJ0XG4gKiBAcmV0dXJucyB7QnVmZmVyfSBUaGUgaGV4IGFzIGJ1ZmZlclxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZnVuY3Rpb24gaGV4MmJ1ZmZlcihoZXgpIHtcbiAgLy8gdXNlIGJ1ZmZlciBidWlsdC1pbiBmdW5jdGlvbiB0byBjb252ZXJ0IGZyb20gaGV4LXN0cmluZyB0byBidWZmZXJcbiAgY29uc3QgYnVmZiA9IGhleCAhPSBudWxsICYmIEJ1ZmZlci5mcm9tKGhleCwgJ2hleCcpO1xuICByZXR1cm4gYnVmZjtcbn1cblxuLyoqXG4gKiBIZWxwZXIgZnVuY3Rpb24gdG8gY29udmVydCB0aGUgYnVmZmVyIGlucHV0IHRvIGEgc3RyaW5nXG4gKiBAcGFyYW0ge0J1ZmZlcn0gYnVmIFRoZSBidWZmZXIgdG8gY29udmVydCB0byBhIGhleC1zdHJpbmdcbiAqIEByZXR1cm5zIHtTdHJpbmd9IFRoZSBidWZmZXIgYXMgYSBoZXgtc3RyaW5nXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5mdW5jdGlvbiBiaW5hcnkyaGV4KGJ1Zikge1xuICAvLyB1c2UgYnVmZmVyIGJ1aWx0LWluIGZ1bmN0aW9uIHRvIGNvbnZlcnQgZnJvbSBidWZmZXIgdG8gaGV4LXN0cmluZ1xuICBjb25zdCBoZXggPSBidWYgIT0gbnVsbCAmJiBidWYudG9TdHJpbmcoJ2hleCcpO1xuICByZXR1cm4gaGV4O1xufVxuXG4vKipcbiAqIENvbnZlcnQgYSBTdHJpbmcgdG8gQmluYXJ5XG4gKiBAcGFyYW0ge1N0cmluZ30gdXVpZFN0ciBUaGUgdmFsdWUgdG8gcHJvY2Vzc1xuICogQHJldHVybnMge01vbmdvb3NlQnVmZmVyfSBUaGUgYmluYXJ5IHRvIHN0b3JlXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5mdW5jdGlvbiBzdHJpbmdUb0JpbmFyeSh1dWlkU3RyKSB7XG4gIC8vIFByb3RlY3QgYWdhaW5zdCB1bmRlZmluZWQgJiB0aHJvd2luZyBlcnJcbiAgaWYgKHR5cGVvZiB1dWlkU3RyICE9PSAnc3RyaW5nJykgdXVpZFN0ciA9ICcnO1xuICBjb25zdCBoZXggPSB1dWlkU3RyLnJlcGxhY2UoL1t7fS1dL2csICcnKTsgLy8gcmVtb3ZlIGV4dHJhIGNoYXJhY3RlcnNcbiAgY29uc3QgYnl0ZXMgPSBoZXgyYnVmZmVyKGhleCk7XG4gIGNvbnN0IGJ1ZmYgPSBuZXcgTW9uZ29vc2VCdWZmZXIoYnl0ZXMpO1xuICBidWZmLl9zdWJ0eXBlID0gNDtcblxuICByZXR1cm4gYnVmZjtcbn1cblxuLyoqXG4gKiBDb252ZXJ0IGJpbmFyeSB0byBhIHV1aWQgc3RyaW5nXG4gKiBAcGFyYW0ge0J1ZmZlcnxCaW5hcnl8U3RyaW5nfSB1dWlkQmluIFRoZSB2YWx1ZSB0byBwcm9jZXNzXG4gKiBAcmV0dXJucyB7U3RyaW5nfSBUaGUgY29tcGxldGVkIHV1aWQtc3RyaW5nXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gYmluYXJ5VG9TdHJpbmcodXVpZEJpbikge1xuICAvLyBpKGhhc2V6b2V5KSBkb250IHF1aXRlIGtub3cgd2h5LCBidXQgXCJ1dWlkQmluXCIgbWF5IHNvbWV0aW1lcyBhbHNvIGJlIHRoZSBhbHJlYWR5IHByb2Nlc3NlZCBzdHJpbmdcbiAgbGV0IGhleDtcbiAgaWYgKHR5cGVvZiB1dWlkQmluICE9PSAnc3RyaW5nJyAmJiB1dWlkQmluICE9IG51bGwpIHtcbiAgICBoZXggPSBiaW5hcnkyaGV4KHV1aWRCaW4pO1xuICAgIGNvbnN0IHV1aWRTdHIgPSBoZXguc3Vic3RyaW5nKDAsIDgpICsgJy0nICsgaGV4LnN1YnN0cmluZyg4LCA4ICsgNCkgKyAnLScgKyBoZXguc3Vic3RyaW5nKDEyLCAxMiArIDQpICsgJy0nICsgaGV4LnN1YnN0cmluZygxNiwgMTYgKyA0KSArICctJyArIGhleC5zdWJzdHJpbmcoMjAsIDIwICsgMTIpO1xuICAgIHJldHVybiB1dWlkU3RyO1xuICB9XG4gIHJldHVybiB1dWlkQmluO1xufVxuXG4vKipcbiAqIFVVSUR2MSBTY2hlbWFUeXBlIGNvbnN0cnVjdG9yLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBrZXlcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zXG4gKiBAaW5oZXJpdHMgU2NoZW1hVHlwZVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5mdW5jdGlvbiBTY2hlbWFVVUlEKGtleSwgb3B0aW9ucykge1xuICBTY2hlbWFUeXBlLmNhbGwodGhpcywga2V5LCBvcHRpb25zLCAnVVVJRCcpO1xuICB0aGlzLmdldHRlcnMucHVzaChmdW5jdGlvbih2YWx1ZSkge1xuICAgIC8vIEZvciBwb3B1bGF0ZWRcbiAgICBpZiAodmFsdWUgIT0gbnVsbCAmJiB2YWx1ZS4kX18gIT0gbnVsbCkge1xuICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH1cbiAgICByZXR1cm4gYmluYXJ5VG9TdHJpbmcodmFsdWUpO1xuICB9KTtcbn1cblxuLyoqXG4gKiBUaGlzIHNjaGVtYSB0eXBlJ3MgbmFtZSwgdG8gZGVmZW5kIGFnYWluc3QgbWluaWZpZXJzIHRoYXQgbWFuZ2xlXG4gKiBmdW5jdGlvbiBuYW1lcy5cbiAqXG4gKiBAYXBpIHB1YmxpY1xuICovXG5TY2hlbWFVVUlELnNjaGVtYU5hbWUgPSAnVVVJRCc7XG5cblNjaGVtYVVVSUQuZGVmYXVsdE9wdGlvbnMgPSB7fTtcblxuLyohXG4gKiBJbmhlcml0cyBmcm9tIFNjaGVtYVR5cGUuXG4gKi9cblNjaGVtYVVVSUQucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShTY2hlbWFUeXBlLnByb3RvdHlwZSk7XG5TY2hlbWFVVUlELnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFNjaGVtYVVVSUQ7XG5cbi8qIVxuICogaWdub3JlXG4gKi9cblxuU2NoZW1hVVVJRC5fY2FzdCA9IGZ1bmN0aW9uKHZhbHVlKSB7XG4gIGlmICh2YWx1ZSA9PSBudWxsKSB7XG4gICAgcmV0dXJuIHZhbHVlO1xuICB9XG5cbiAgZnVuY3Rpb24gbmV3QnVmZmVyKGluaXRidWZmKSB7XG4gICAgY29uc3QgYnVmZiA9IG5ldyBNb25nb29zZUJ1ZmZlcihpbml0YnVmZik7XG4gICAgYnVmZi5fc3VidHlwZSA9IDQ7XG4gICAgcmV0dXJuIGJ1ZmY7XG4gIH1cblxuICBpZiAodHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJykge1xuICAgIGlmIChVVUlEX0ZPUk1BVC50ZXN0KHZhbHVlKSkge1xuICAgICAgcmV0dXJuIHN0cmluZ1RvQmluYXJ5KHZhbHVlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgbmV3IENhc3RFcnJvcihTY2hlbWFVVUlELnNjaGVtYU5hbWUsIHZhbHVlLCB0aGlzLnBhdGgpO1xuICAgIH1cbiAgfVxuXG4gIGlmIChCdWZmZXIuaXNCdWZmZXIodmFsdWUpKSB7XG4gICAgcmV0dXJuIG5ld0J1ZmZlcih2YWx1ZSk7XG4gIH1cblxuICBpZiAodmFsdWUgaW5zdGFuY2VvZiBCaW5hcnkpIHtcbiAgICByZXR1cm4gbmV3QnVmZmVyKHZhbHVlLnZhbHVlKHRydWUpKTtcbiAgfVxuXG4gIC8vIFJlOiBnaC02NDcgYW5kIGdoLTMwMzAsIHdlJ3JlIG9rIHdpdGggY2FzdGluZyB1c2luZyBgdG9TdHJpbmcoKWBcbiAgLy8gKip1bmxlc3MqKiBpdHMgdGhlIGRlZmF1bHQgT2JqZWN0LnRvU3RyaW5nLCBiZWNhdXNlIFwiW29iamVjdCBPYmplY3RdXCJcbiAgLy8gZG9lc24ndCByZWFsbHkgcXVhbGlmeSBhcyB1c2VmdWwgZGF0YVxuICBpZiAodmFsdWUudG9TdHJpbmcgJiYgdmFsdWUudG9TdHJpbmcgIT09IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcpIHtcbiAgICBpZiAoVVVJRF9GT1JNQVQudGVzdCh2YWx1ZS50b1N0cmluZygpKSkge1xuICAgICAgcmV0dXJuIHN0cmluZ1RvQmluYXJ5KHZhbHVlLnRvU3RyaW5nKCkpO1xuICAgIH1cbiAgfVxuXG4gIHRocm93IG5ldyBDYXN0RXJyb3IoU2NoZW1hVVVJRC5zY2hlbWFOYW1lLCB2YWx1ZSwgdGhpcy5wYXRoKTtcbn07XG5cbi8qKlxuICogQXR0YWNoZXMgYSBnZXR0ZXIgZm9yIGFsbCBVVUlEIGluc3RhbmNlcy5cbiAqXG4gKiAjIyMjIEV4YW1wbGU6XG4gKlxuICogICAgIC8vIE5vdGUgdGhhdCBgdmAgaXMgYSBzdHJpbmcgYnkgZGVmYXVsdFxuICogICAgIG1vbmdvb3NlLlNjaGVtYS5VVUlELmdldCh2ID0+IHYudG9VcHBlckNhc2UoKSk7XG4gKlxuICogICAgIGNvbnN0IE1vZGVsID0gbW9uZ29vc2UubW9kZWwoJ1Rlc3QnLCBuZXcgU2NoZW1hKHsgdGVzdDogJ1VVSUQnIH0pKTtcbiAqICAgICBuZXcgTW9kZWwoeyB0ZXN0OiB1dWlkLnY0KCkgfSkudGVzdDsgLy8gVVVJRCB3aXRoIGFsbCB1cHBlcmNhc2VcbiAqXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBnZXR0ZXJcbiAqIEByZXR1cm4ge3RoaXN9XG4gKiBAZnVuY3Rpb24gZ2V0XG4gKiBAc3RhdGljXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cblNjaGVtYVVVSUQuZ2V0ID0gU2NoZW1hVHlwZS5nZXQ7XG5cbi8qKlxuICogU2V0cyBhIGRlZmF1bHQgb3B0aW9uIGZvciBhbGwgVVVJRCBpbnN0YW5jZXMuXG4gKlxuICogIyMjIyBFeGFtcGxlOlxuICpcbiAqICAgICAvLyBNYWtlIGFsbCBVVUlEcyBoYXZlIGByZXF1aXJlZGAgb2YgdHJ1ZSBieSBkZWZhdWx0LlxuICogICAgIG1vbmdvb3NlLlNjaGVtYS5VVUlELnNldCgncmVxdWlyZWQnLCB0cnVlKTtcbiAqXG4gKiAgICAgY29uc3QgVXNlciA9IG1vbmdvb3NlLm1vZGVsKCdVc2VyJywgbmV3IFNjaGVtYSh7IHRlc3Q6IG1vbmdvb3NlLlVVSUQgfSkpO1xuICogICAgIG5ldyBVc2VyKHsgfSkudmFsaWRhdGVTeW5jKCkuZXJyb3JzLnRlc3QubWVzc2FnZTsgLy8gUGF0aCBgdGVzdGAgaXMgcmVxdWlyZWQuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IG9wdGlvbiBUaGUgb3B0aW9uIHlvdSdkIGxpa2UgdG8gc2V0IHRoZSB2YWx1ZSBmb3JcbiAqIEBwYXJhbSB7QW55fSB2YWx1ZSB2YWx1ZSBmb3Igb3B0aW9uXG4gKiBAcmV0dXJuIHt1bmRlZmluZWR9XG4gKiBAZnVuY3Rpb24gc2V0XG4gKiBAc3RhdGljXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cblNjaGVtYVVVSUQuc2V0ID0gU2NoZW1hVHlwZS5zZXQ7XG5cblNjaGVtYVVVSUQuc2V0dGVycyA9IFtdO1xuXG4vKipcbiAqIEdldC9zZXQgdGhlIGZ1bmN0aW9uIHVzZWQgdG8gY2FzdCBhcmJpdHJhcnkgdmFsdWVzIHRvIFVVSURzLlxuICpcbiAqICMjIyMgRXhhbXBsZTpcbiAqXG4gKiAgICAgLy8gTWFrZSBNb25nb29zZSByZWZ1c2UgdG8gY2FzdCBVVUlEcyB3aXRoIDAgbGVuZ3RoXG4gKiAgICAgY29uc3Qgb3JpZ2luYWwgPSBtb25nb29zZS5TY2hlbWEuVHlwZXMuVVVJRC5jYXN0KCk7XG4gKiAgICAgbW9uZ29vc2UuVVVJRC5jYXN0KHYgPT4ge1xuICogICAgICAgYXNzZXJ0Lm9rKHR5cGVvZiB2ID09PSBcInN0cmluZ1wiICYmIHYubGVuZ3RoID4gMCk7XG4gKiAgICAgICByZXR1cm4gb3JpZ2luYWwodik7XG4gKiAgICAgfSk7XG4gKlxuICogICAgIC8vIE9yIGRpc2FibGUgY2FzdGluZyBlbnRpcmVseVxuICogICAgIG1vbmdvb3NlLlVVSUQuY2FzdChmYWxzZSk7XG4gKlxuICogQHBhcmFtIHtGdW5jdGlvbn0gW2Nhc3Rlcl1cbiAqIEByZXR1cm4ge0Z1bmN0aW9ufVxuICogQGZ1bmN0aW9uIGdldFxuICogQHN0YXRpY1xuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5TY2hlbWFVVUlELmNhc3QgPSBmdW5jdGlvbiBjYXN0KGNhc3Rlcikge1xuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMCkge1xuICAgIHJldHVybiB0aGlzLl9jYXN0O1xuICB9XG4gIGlmIChjYXN0ZXIgPT09IGZhbHNlKSB7XG4gICAgY2FzdGVyID0gdGhpcy5fZGVmYXVsdENhc3RlcjtcbiAgfVxuICB0aGlzLl9jYXN0ID0gY2FzdGVyO1xuXG4gIHJldHVybiB0aGlzLl9jYXN0O1xufTtcblxuLyohXG4gKiBpZ25vcmVcbiAqL1xuXG5TY2hlbWFVVUlELl9jaGVja1JlcXVpcmVkID0gdiA9PiB2ICE9IG51bGw7XG5cbi8qKlxuICogT3ZlcnJpZGUgdGhlIGZ1bmN0aW9uIHRoZSByZXF1aXJlZCB2YWxpZGF0b3IgdXNlcyB0byBjaGVjayB3aGV0aGVyIGEgc3RyaW5nXG4gKiBwYXNzZXMgdGhlIGByZXF1aXJlZGAgY2hlY2suXG4gKlxuICogQHBhcmFtIHtGdW5jdGlvbn0gZm5cbiAqIEByZXR1cm4ge0Z1bmN0aW9ufVxuICogQGZ1bmN0aW9uIGNoZWNrUmVxdWlyZWRcbiAqIEBzdGF0aWNcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuU2NoZW1hVVVJRC5jaGVja1JlcXVpcmVkID0gU2NoZW1hVHlwZS5jaGVja1JlcXVpcmVkO1xuXG4vKipcbiAqIENoZWNrIGlmIHRoZSBnaXZlbiB2YWx1ZSBzYXRpc2ZpZXMgYSByZXF1aXJlZCB2YWxpZGF0b3IuXG4gKlxuICogQHBhcmFtIHtBbnl9IHZhbHVlXG4gKiBAcmV0dXJuIHtCb29sZWFufVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5TY2hlbWFVVUlELnByb3RvdHlwZS5jaGVja1JlcXVpcmVkID0gZnVuY3Rpb24gY2hlY2tSZXF1aXJlZCh2YWx1ZSkge1xuICBpZiAoQnVmZmVyLmlzQnVmZmVyKHZhbHVlKSkge1xuICAgIHZhbHVlID0gYmluYXJ5VG9TdHJpbmcodmFsdWUpO1xuICB9XG4gIHJldHVybiB2YWx1ZSAhPSBudWxsICYmIFVVSURfRk9STUFULnRlc3QodmFsdWUpO1xufTtcblxuLyoqXG4gKiBDYXN0cyB0byBVVUlEXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IHZhbHVlXG4gKiBAcGFyYW0ge09iamVjdH0gZG9jXG4gKiBAcGFyYW0ge0Jvb2xlYW59IGluaXQgd2hldGhlciB0aGlzIGlzIGFuIGluaXRpYWxpemF0aW9uIGNhc3RcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cblNjaGVtYVVVSUQucHJvdG90eXBlLmNhc3QgPSBmdW5jdGlvbih2YWx1ZSwgZG9jLCBpbml0KSB7XG4gIGlmICh1dGlscy5pc05vbkJ1aWx0aW5PYmplY3QodmFsdWUpICYmXG4gICAgICBTY2hlbWFUeXBlLl9pc1JlZih0aGlzLCB2YWx1ZSwgZG9jLCBpbml0KSkge1xuICAgIHJldHVybiB0aGlzLl9jYXN0UmVmKHZhbHVlLCBkb2MsIGluaXQpO1xuICB9XG5cbiAgbGV0IGNhc3RGbjtcbiAgaWYgKHR5cGVvZiB0aGlzLl9jYXN0RnVuY3Rpb24gPT09ICdmdW5jdGlvbicpIHtcbiAgICBjYXN0Rm4gPSB0aGlzLl9jYXN0RnVuY3Rpb247XG4gIH0gZWxzZSBpZiAodHlwZW9mIHRoaXMuY29uc3RydWN0b3IuY2FzdCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIGNhc3RGbiA9IHRoaXMuY29uc3RydWN0b3IuY2FzdCgpO1xuICB9IGVsc2Uge1xuICAgIGNhc3RGbiA9IFNjaGVtYVVVSUQuY2FzdCgpO1xuICB9XG5cbiAgdHJ5IHtcbiAgICByZXR1cm4gY2FzdEZuKHZhbHVlKTtcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICB0aHJvdyBuZXcgQ2FzdEVycm9yKFNjaGVtYVVVSUQuc2NoZW1hTmFtZSwgdmFsdWUsIHRoaXMucGF0aCwgZXJyb3IsIHRoaXMpO1xuICB9XG59O1xuXG4vKiFcbiAqIGlnbm9yZVxuICovXG5cbmZ1bmN0aW9uIGhhbmRsZVNpbmdsZSh2YWwpIHtcbiAgcmV0dXJuIHRoaXMuY2FzdCh2YWwpO1xufVxuXG4vKiFcbiAqIGlnbm9yZVxuICovXG5cbmZ1bmN0aW9uIGhhbmRsZUFycmF5KHZhbCkge1xuICByZXR1cm4gdmFsLm1hcCgobSkgPT4ge1xuICAgIHJldHVybiB0aGlzLmNhc3QobSk7XG4gIH0pO1xufVxuXG5TY2hlbWFVVUlELnByb3RvdHlwZS4kY29uZGl0aW9uYWxIYW5kbGVycyA9XG51dGlscy5vcHRpb25zKFNjaGVtYVR5cGUucHJvdG90eXBlLiRjb25kaXRpb25hbEhhbmRsZXJzLCB7XG4gICRiaXRzQWxsQ2xlYXI6IGhhbmRsZUJpdHdpc2VPcGVyYXRvcixcbiAgJGJpdHNBbnlDbGVhcjogaGFuZGxlQml0d2lzZU9wZXJhdG9yLFxuICAkYml0c0FsbFNldDogaGFuZGxlQml0d2lzZU9wZXJhdG9yLFxuICAkYml0c0FueVNldDogaGFuZGxlQml0d2lzZU9wZXJhdG9yLFxuICAkYWxsOiBoYW5kbGVBcnJheSxcbiAgJGd0OiBoYW5kbGVTaW5nbGUsXG4gICRndGU6IGhhbmRsZVNpbmdsZSxcbiAgJGluOiBoYW5kbGVBcnJheSxcbiAgJGx0OiBoYW5kbGVTaW5nbGUsXG4gICRsdGU6IGhhbmRsZVNpbmdsZSxcbiAgJG5lOiBoYW5kbGVTaW5nbGUsXG4gICRuaW46IGhhbmRsZUFycmF5XG59KTtcblxuLyoqXG4gKiBDYXN0cyBjb250ZW50cyBmb3IgcXVlcmllcy5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gJGNvbmRpdGlvbmFsXG4gKiBAcGFyYW0ge2FueX0gdmFsXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5TY2hlbWFVVUlELnByb3RvdHlwZS5jYXN0Rm9yUXVlcnkgPSBmdW5jdGlvbigkY29uZGl0aW9uYWwsIHZhbCwgY29udGV4dCkge1xuICBsZXQgaGFuZGxlcjtcbiAgaWYgKCRjb25kaXRpb25hbCAhPSBudWxsKSB7XG4gICAgaGFuZGxlciA9IHRoaXMuJGNvbmRpdGlvbmFsSGFuZGxlcnNbJGNvbmRpdGlvbmFsXTtcbiAgICBpZiAoIWhhbmRsZXIpXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0NhblxcJ3QgdXNlICcgKyAkY29uZGl0aW9uYWwgKyAnIHdpdGggVVVJRC4nKTtcbiAgICByZXR1cm4gaGFuZGxlci5jYWxsKHRoaXMsIHZhbCwgY29udGV4dCk7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIHRoaXMuY2FzdCh2YWwpO1xuICB9XG59O1xuXG4vKiFcbiAqIE1vZHVsZSBleHBvcnRzLlxuICovXG5cbm1vZHVsZS5leHBvcnRzID0gU2NoZW1hVVVJRDtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/mongoose/lib/schema/uuid.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/mongoose/lib/schemaType.js":
/*!*************************************************!*\
  !*** ./node_modules/mongoose/lib/schemaType.js ***!
  \*************************************************/
/***/ ((module, exports, __webpack_require__) => {

eval("\n\n/*!\n * Module dependencies.\n */\n\nconst MongooseError = __webpack_require__(/*! ./error/index */ \"(ssr)/./node_modules/mongoose/lib/error/index.js\");\nconst SchemaTypeOptions = __webpack_require__(/*! ./options/schemaTypeOptions */ \"(ssr)/./node_modules/mongoose/lib/options/schemaTypeOptions.js\");\nconst $exists = __webpack_require__(/*! ./schema/operators/exists */ \"(ssr)/./node_modules/mongoose/lib/schema/operators/exists.js\");\nconst $type = __webpack_require__(/*! ./schema/operators/type */ \"(ssr)/./node_modules/mongoose/lib/schema/operators/type.js\");\nconst clone = __webpack_require__(/*! ./helpers/clone */ \"(ssr)/./node_modules/mongoose/lib/helpers/clone.js\");\nconst handleImmutable = __webpack_require__(/*! ./helpers/schematype/handleImmutable */ \"(ssr)/./node_modules/mongoose/lib/helpers/schematype/handleImmutable.js\");\nconst isAsyncFunction = __webpack_require__(/*! ./helpers/isAsyncFunction */ \"(ssr)/./node_modules/mongoose/lib/helpers/isAsyncFunction.js\");\nconst isSimpleValidator = __webpack_require__(/*! ./helpers/isSimpleValidator */ \"(ssr)/./node_modules/mongoose/lib/helpers/isSimpleValidator.js\");\nconst immediate = __webpack_require__(/*! ./helpers/immediate */ \"(ssr)/./node_modules/mongoose/lib/helpers/immediate.js\");\nconst schemaTypeSymbol = (__webpack_require__(/*! ./helpers/symbols */ \"(ssr)/./node_modules/mongoose/lib/helpers/symbols.js\").schemaTypeSymbol);\nconst utils = __webpack_require__(/*! ./utils */ \"(ssr)/./node_modules/mongoose/lib/utils.js\");\nconst validatorErrorSymbol = (__webpack_require__(/*! ./helpers/symbols */ \"(ssr)/./node_modules/mongoose/lib/helpers/symbols.js\").validatorErrorSymbol);\nconst documentIsModified = (__webpack_require__(/*! ./helpers/symbols */ \"(ssr)/./node_modules/mongoose/lib/helpers/symbols.js\").documentIsModified);\n\nconst populateModelSymbol = (__webpack_require__(/*! ./helpers/symbols */ \"(ssr)/./node_modules/mongoose/lib/helpers/symbols.js\").populateModelSymbol);\n\nconst CastError = MongooseError.CastError;\nconst ValidatorError = MongooseError.ValidatorError;\n\nconst setOptionsForDefaults = { _skipMarkModified: true };\n\n/**\n * SchemaType constructor. Do **not** instantiate `SchemaType` directly.\n * Mongoose converts your schema paths into SchemaTypes automatically.\n *\n * #### Example:\n *\n *     const schema = new Schema({ name: String });\n *     schema.path('name') instanceof SchemaType; // true\n *\n * @param {String} path\n * @param {SchemaTypeOptions} [options] See [SchemaTypeOptions docs](https://mongoosejs.com/docs/api/schematypeoptions.html)\n * @param {String} [instance]\n * @api public\n */\n\nfunction SchemaType(path, options, instance) {\n  this[schemaTypeSymbol] = true;\n  this.path = path;\n  this.instance = instance;\n  this.validators = [];\n  this.getters = this.constructor.hasOwnProperty('getters') ?\n    this.constructor.getters.slice() :\n    [];\n  this.setters = this.constructor.hasOwnProperty('setters') ?\n    this.constructor.setters.slice() :\n    [];\n\n  this.splitPath();\n\n  options = options || {};\n  const defaultOptions = this.constructor.defaultOptions || {};\n  const defaultOptionsKeys = Object.keys(defaultOptions);\n\n  for (const option of defaultOptionsKeys) {\n    if (defaultOptions.hasOwnProperty(option) && !Object.prototype.hasOwnProperty.call(options, option)) {\n      options[option] = defaultOptions[option];\n    }\n  }\n\n  if (options.select == null) {\n    delete options.select;\n  }\n\n  const Options = this.OptionsConstructor || SchemaTypeOptions;\n  this.options = new Options(options);\n  this._index = null;\n\n\n  if (utils.hasUserDefinedProperty(this.options, 'immutable')) {\n    this.$immutable = this.options.immutable;\n\n    handleImmutable(this);\n  }\n\n  const keys = Object.keys(this.options);\n  for (const prop of keys) {\n    if (prop === 'cast') {\n      if (Array.isArray(this.options[prop])) {\n        this.castFunction.apply(this, this.options[prop]);\n      } else {\n        this.castFunction(this.options[prop]);\n      }\n      continue;\n    }\n    if (utils.hasUserDefinedProperty(this.options, prop) && typeof this[prop] === 'function') {\n      // { unique: true, index: true }\n      if (prop === 'index' && this._index) {\n        if (options.index === false) {\n          const index = this._index;\n          if (typeof index === 'object' && index != null) {\n            if (index.unique) {\n              throw new Error('Path \"' + this.path + '\" may not have `index` ' +\n                'set to false and `unique` set to true');\n            }\n            if (index.sparse) {\n              throw new Error('Path \"' + this.path + '\" may not have `index` ' +\n                'set to false and `sparse` set to true');\n            }\n          }\n\n          this._index = false;\n        }\n        continue;\n      }\n\n      const val = options[prop];\n      // Special case so we don't screw up array defaults, see gh-5780\n      if (prop === 'default') {\n        this.default(val);\n        continue;\n      }\n\n      const opts = Array.isArray(val) ? val : [val];\n\n      this[prop].apply(this, opts);\n    }\n  }\n\n  Object.defineProperty(this, '$$context', {\n    enumerable: false,\n    configurable: false,\n    writable: true,\n    value: null\n  });\n}\n\n/**\n * The class that Mongoose uses internally to instantiate this SchemaType's `options` property.\n * @memberOf SchemaType\n * @instance\n * @api private\n */\n\nSchemaType.prototype.OptionsConstructor = SchemaTypeOptions;\n\n/**\n * The path to this SchemaType in a Schema.\n *\n * #### Example:\n *\n *     const schema = new Schema({ name: String });\n *     schema.path('name').path; // 'name'\n *\n * @property path\n * @api public\n * @memberOf SchemaType\n */\n\nSchemaType.prototype.path;\n\n/**\n * The validators that Mongoose should run to validate properties at this SchemaType's path.\n *\n * #### Example:\n *\n *     const schema = new Schema({ name: { type: String, required: true } });\n *     schema.path('name').validators.length; // 1, the `required` validator\n *\n * @property validators\n * @api public\n * @memberOf SchemaType\n */\n\nSchemaType.prototype.validators;\n\n/**\n * True if this SchemaType has a required validator. False otherwise.\n *\n * #### Example:\n *\n *     const schema = new Schema({ name: { type: String, required: true } });\n *     schema.path('name').isRequired; // true\n *\n *     schema.path('name').required(false);\n *     schema.path('name').isRequired; // false\n *\n * @property isRequired\n * @api public\n * @memberOf SchemaType\n */\n\nSchemaType.prototype.isRequired;\n\n/**\n * Split the current dottet path into segments\n *\n * @return {String[]|undefined}\n * @api private\n */\n\nSchemaType.prototype.splitPath = function() {\n  if (this._presplitPath != null) {\n    return this._presplitPath;\n  }\n  if (this.path == null) {\n    return undefined;\n  }\n\n  this._presplitPath = this.path.indexOf('.') === -1 ? [this.path] : this.path.split('.');\n  return this._presplitPath;\n};\n\n/**\n * Get/set the function used to cast arbitrary values to this type.\n *\n * #### Example:\n *\n *     // Disallow `null` for numbers, and don't try to cast any values to\n *     // numbers, so even strings like '123' will cause a CastError.\n *     mongoose.Number.cast(function(v) {\n *       assert.ok(v === undefined || typeof v === 'number');\n *       return v;\n *     });\n *\n * @param {Function|false} caster Function that casts arbitrary values to this type, or throws an error if casting failed\n * @return {Function}\n * @static\n * @memberOf SchemaType\n * @function cast\n * @api public\n */\n\nSchemaType.cast = function cast(caster) {\n  if (arguments.length === 0) {\n    return this._cast;\n  }\n  if (caster === false) {\n    caster = v => v;\n  }\n  this._cast = caster;\n\n  return this._cast;\n};\n\n/**\n * Get/set the function used to cast arbitrary values to this particular schematype instance.\n * Overrides `SchemaType.cast()`.\n *\n * #### Example:\n *\n *     // Disallow `null` for numbers, and don't try to cast any values to\n *     // numbers, so even strings like '123' will cause a CastError.\n *     const number = new mongoose.Number('mypath', {});\n *     number.cast(function(v) {\n *       assert.ok(v === undefined || typeof v === 'number');\n *       return v;\n *     });\n *\n * @param {Function|false} caster Function that casts arbitrary values to this type, or throws an error if casting failed\n * @return {Function}\n * @memberOf SchemaType\n * @api public\n */\n\nSchemaType.prototype.castFunction = function castFunction(caster, message) {\n  if (arguments.length === 0) {\n    return this._castFunction;\n  }\n\n  if (caster === false) {\n    caster = this.constructor._defaultCaster || (v => v);\n  }\n  if (typeof caster === 'string') {\n    this._castErrorMessage = caster;\n    return this._castFunction;\n  }\n  if (caster != null) {\n    this._castFunction = caster;\n  }\n  if (message != null) {\n    this._castErrorMessage = message;\n  }\n\n  return this._castFunction;\n};\n\n/**\n * The function that Mongoose calls to cast arbitrary values to this SchemaType.\n *\n * @param {Object} value value to cast\n * @param {Document} doc document that triggers the casting\n * @param {Boolean} init\n * @api public\n */\n\nSchemaType.prototype.cast = function cast() {\n  throw new Error('Base SchemaType class does not implement a `cast()` function');\n};\n\n/**\n * Sets a default option for this schema type.\n *\n * #### Example:\n *\n *     // Make all strings be trimmed by default\n *     mongoose.SchemaTypes.String.set('trim', true);\n *\n * @param {String} option The name of the option you'd like to set (e.g. trim, lowercase, etc...)\n * @param {Any} value The value of the option you'd like to set.\n * @return {void}\n * @static\n * @memberOf SchemaType\n * @function set\n * @api public\n */\n\nSchemaType.set = function set(option, value) {\n  if (!this.hasOwnProperty('defaultOptions')) {\n    this.defaultOptions = Object.assign({}, this.defaultOptions);\n  }\n  this.defaultOptions[option] = value;\n};\n\n/**\n * Attaches a getter for all instances of this schema type.\n *\n * #### Example:\n *\n *     // Make all numbers round down\n *     mongoose.Number.get(function(v) { return Math.floor(v); });\n *\n * @param {Function} getter\n * @return {this}\n * @static\n * @memberOf SchemaType\n * @function get\n * @api public\n */\n\nSchemaType.get = function(getter) {\n  this.getters = this.hasOwnProperty('getters') ? this.getters : [];\n  this.getters.push(getter);\n};\n\n/**\n * Sets a default value for this SchemaType.\n *\n * #### Example:\n *\n *     const schema = new Schema({ n: { type: Number, default: 10 })\n *     const M = db.model('M', schema)\n *     const m = new M;\n *     console.log(m.n) // 10\n *\n * Defaults can be either `functions` which return the value to use as the default or the literal value itself. Either way, the value will be cast based on its schema type before being set during document creation.\n *\n * #### Example:\n *\n *     // values are cast:\n *     const schema = new Schema({ aNumber: { type: Number, default: 4.815162342 }})\n *     const M = db.model('M', schema)\n *     const m = new M;\n *     console.log(m.aNumber) // 4.815162342\n *\n *     // default unique objects for Mixed types:\n *     const schema = new Schema({ mixed: Schema.Types.Mixed });\n *     schema.path('mixed').default(function () {\n *       return {};\n *     });\n *\n *     // if we don't use a function to return object literals for Mixed defaults,\n *     // each document will receive a reference to the same object literal creating\n *     // a \"shared\" object instance:\n *     const schema = new Schema({ mixed: Schema.Types.Mixed });\n *     schema.path('mixed').default({});\n *     const M = db.model('M', schema);\n *     const m1 = new M;\n *     m1.mixed.added = 1;\n *     console.log(m1.mixed); // { added: 1 }\n *     const m2 = new M;\n *     console.log(m2.mixed); // { added: 1 }\n *\n * @param {Function|any} val The default value to set\n * @return {Any|undefined} Returns the set default value.\n * @api public\n */\n\nSchemaType.prototype.default = function(val) {\n  if (arguments.length === 1) {\n    if (val === void 0) {\n      this.defaultValue = void 0;\n      return void 0;\n    }\n\n    if (val != null && val.instanceOfSchema) {\n      throw new MongooseError('Cannot set default value of path `' + this.path +\n        '` to a mongoose Schema instance.');\n    }\n\n    this.defaultValue = val;\n    return this.defaultValue;\n  } else if (arguments.length > 1) {\n    this.defaultValue = [...arguments];\n  }\n  return this.defaultValue;\n};\n\n/**\n * Declares the index options for this schematype.\n *\n * #### Example:\n *\n *     const s = new Schema({ name: { type: String, index: true })\n *     const s = new Schema({ name: { type: String, index: -1 })\n *     const s = new Schema({ loc: { type: [Number], index: 'hashed' })\n *     const s = new Schema({ loc: { type: [Number], index: '2d', sparse: true })\n *     const s = new Schema({ loc: { type: [Number], index: { type: '2dsphere', sparse: true }})\n *     const s = new Schema({ date: { type: Date, index: { unique: true, expires: '1d' }})\n *     s.path('my.path').index(true);\n *     s.path('my.date').index({ expires: 60 });\n *     s.path('my.path').index({ unique: true, sparse: true });\n *\n * #### Note:\n *\n * _Indexes are created [in the background](https://www.mongodb.com/docs/manual/core/index-creation/#index-creation-background)\n * by default. If `background` is set to `false`, MongoDB will not execute any\n * read/write operations you send until the index build.\n * Specify `background: false` to override Mongoose's default._\n *\n * @param {Object|Boolean|String|Number} options\n * @return {SchemaType} this\n * @api public\n */\n\nSchemaType.prototype.index = function(options) {\n  this._index = options;\n  utils.expires(this._index);\n  return this;\n};\n\n/**\n * Declares an unique index.\n *\n * #### Example:\n *\n *     const s = new Schema({ name: { type: String, unique: true } });\n *     s.path('name').index({ unique: true });\n *\n * _NOTE: violating the constraint returns an `E11000` error from MongoDB when saving, not a Mongoose validation error._\n *\n * @param {Boolean} bool\n * @return {SchemaType} this\n * @api public\n */\n\nSchemaType.prototype.unique = function(bool) {\n  if (this._index === false) {\n    if (!bool) {\n      return;\n    }\n    throw new Error('Path \"' + this.path + '\" may not have `index` set to ' +\n      'false and `unique` set to true');\n  }\n\n  if (!this.options.hasOwnProperty('index') && bool === false) {\n    return this;\n  }\n\n  if (this._index == null || this._index === true) {\n    this._index = {};\n  } else if (typeof this._index === 'string') {\n    this._index = { type: this._index };\n  }\n\n  this._index.unique = bool;\n  return this;\n};\n\n/**\n * Declares a full text index.\n *\n * ### Example:\n *\n *      const s = new Schema({ name : { type: String, text : true } })\n *      s.path('name').index({ text : true });\n *\n * @param {Boolean} bool\n * @return {SchemaType} this\n * @api public\n */\n\nSchemaType.prototype.text = function(bool) {\n  if (this._index === false) {\n    if (!bool) {\n      return this;\n    }\n    throw new Error('Path \"' + this.path + '\" may not have `index` set to ' +\n      'false and `text` set to true');\n  }\n\n  if (!this.options.hasOwnProperty('index') && bool === false) {\n    return this;\n  }\n\n  if (this._index === null || this._index === undefined ||\n    typeof this._index === 'boolean') {\n    this._index = {};\n  } else if (typeof this._index === 'string') {\n    this._index = { type: this._index };\n  }\n\n  this._index.text = bool;\n  return this;\n};\n\n/**\n * Declares a sparse index.\n *\n * #### Example:\n *\n *     const s = new Schema({ name: { type: String, sparse: true } });\n *     s.path('name').index({ sparse: true });\n *\n * @param {Boolean} bool\n * @return {SchemaType} this\n * @api public\n */\n\nSchemaType.prototype.sparse = function(bool) {\n  if (this._index === false) {\n    if (!bool) {\n      return this;\n    }\n    throw new Error('Path \"' + this.path + '\" may not have `index` set to ' +\n      'false and `sparse` set to true');\n  }\n\n  if (!this.options.hasOwnProperty('index') && bool === false) {\n    return this;\n  }\n\n  if (this._index == null || typeof this._index === 'boolean') {\n    this._index = {};\n  } else if (typeof this._index === 'string') {\n    this._index = { type: this._index };\n  }\n\n  this._index.sparse = bool;\n  return this;\n};\n\n/**\n * Defines this path as immutable. Mongoose prevents you from changing\n * immutable paths unless the parent document has [`isNew: true`](https://mongoosejs.com/docs/api/document.html#Document.prototype.isNew()).\n *\n * #### Example:\n *\n *     const schema = new Schema({\n *       name: { type: String, immutable: true },\n *       age: Number\n *     });\n *     const Model = mongoose.model('Test', schema);\n *\n *     await Model.create({ name: 'test' });\n *     const doc = await Model.findOne();\n *\n *     doc.isNew; // false\n *     doc.name = 'new name';\n *     doc.name; // 'test', because `name` is immutable\n *\n * Mongoose also prevents changing immutable properties using `updateOne()`\n * and `updateMany()` based on [strict mode](https://mongoosejs.com/docs/guide.html#strict).\n *\n * #### Example:\n *\n *     // Mongoose will strip out the `name` update, because `name` is immutable\n *     Model.updateOne({}, { $set: { name: 'test2' }, $inc: { age: 1 } });\n *\n *     // If `strict` is set to 'throw', Mongoose will throw an error if you\n *     // update `name`\n *     const err = await Model.updateOne({}, { name: 'test2' }, { strict: 'throw' }).\n *       then(() => null, err => err);\n *     err.name; // StrictModeError\n *\n *     // If `strict` is `false`, Mongoose allows updating `name` even though\n *     // the property is immutable.\n *     Model.updateOne({}, { name: 'test2' }, { strict: false });\n *\n * @param {Boolean} bool\n * @return {SchemaType} this\n * @see isNew https://mongoosejs.com/docs/api/document.html#Document.prototype.isNew()\n * @api public\n */\n\nSchemaType.prototype.immutable = function(bool) {\n  this.$immutable = bool;\n  handleImmutable(this);\n\n  return this;\n};\n\n/**\n * Defines a custom function for transforming this path when converting a document to JSON.\n *\n * Mongoose calls this function with one parameter: the current `value` of the path. Mongoose\n * then uses the return value in the JSON output.\n *\n * #### Example:\n *\n *     const schema = new Schema({\n *       date: { type: Date, transform: v => v.getFullYear() }\n *     });\n *     const Model = mongoose.model('Test', schema);\n *\n *     await Model.create({ date: new Date('2016-06-01') });\n *     const doc = await Model.findOne();\n *\n *     doc.date instanceof Date; // true\n *\n *     doc.toJSON().date; // 2016 as a number\n *     JSON.stringify(doc); // '{\"_id\":...,\"date\":2016}'\n *\n * @param {Function} fn\n * @return {SchemaType} this\n * @api public\n */\n\nSchemaType.prototype.transform = function(fn) {\n  this.options.transform = fn;\n\n  return this;\n};\n\n/**\n * Adds a setter to this schematype.\n *\n * #### Example:\n *\n *     function capitalize (val) {\n *       if (typeof val !== 'string') val = '';\n *       return val.charAt(0).toUpperCase() + val.substring(1);\n *     }\n *\n *     // defining within the schema\n *     const s = new Schema({ name: { type: String, set: capitalize }});\n *\n *     // or with the SchemaType\n *     const s = new Schema({ name: String })\n *     s.path('name').set(capitalize);\n *\n * Setters allow you to transform the data before it gets to the raw mongodb\n * document or query.\n *\n * Suppose you are implementing user registration for a website. Users provide\n * an email and password, which gets saved to mongodb. The email is a string\n * that you will want to normalize to lower case, in order to avoid one email\n * having more than one account -- e.g., otherwise, avenue@q.com can be registered for 2 accounts via avenue@q.com and AvEnUe@Q.CoM.\n *\n * You can set up email lower case normalization easily via a Mongoose setter.\n *\n *     function toLower(v) {\n *       return v.toLowerCase();\n *     }\n *\n *     const UserSchema = new Schema({\n *       email: { type: String, set: toLower }\n *     });\n *\n *     const User = db.model('User', UserSchema);\n *\n *     const user = new User({email: 'AVENUE@Q.COM'});\n *     console.log(user.email); // 'avenue@q.com'\n *\n *     // or\n *     const user = new User();\n *     user.email = 'Avenue@Q.com';\n *     console.log(user.email); // 'avenue@q.com'\n *     User.updateOne({ _id: _id }, { $set: { email: 'AVENUE@Q.COM' } }); // update to 'avenue@q.com'\n *\n * As you can see above, setters allow you to transform the data before it\n * stored in MongoDB, or before executing a query.\n *\n * _NOTE: we could have also just used the built-in `lowercase: true` SchemaType option instead of defining our own function._\n *\n *     new Schema({ email: { type: String, lowercase: true }})\n *\n * Setters are also passed a second argument, the schematype on which the setter was defined. This allows for tailored behavior based on options passed in the schema.\n *\n *     function inspector (val, priorValue, schematype) {\n *       if (schematype.options.required) {\n *         return schematype.path + ' is required';\n *       } else {\n *         return val;\n *       }\n *     }\n *\n *     const VirusSchema = new Schema({\n *       name: { type: String, required: true, set: inspector },\n *       taxonomy: { type: String, set: inspector }\n *     })\n *\n *     const Virus = db.model('Virus', VirusSchema);\n *     const v = new Virus({ name: 'Parvoviridae', taxonomy: 'Parvovirinae' });\n *\n *     console.log(v.name);     // name is required\n *     console.log(v.taxonomy); // Parvovirinae\n *\n * You can also use setters to modify other properties on the document. If\n * you're setting a property `name` on a document, the setter will run with\n * `this` as the document. Be careful, in mongoose 5 setters will also run\n * when querying by `name` with `this` as the query.\n *\n *     const nameSchema = new Schema({ name: String, keywords: [String] });\n *     nameSchema.path('name').set(function(v) {\n *       // Need to check if `this` is a document, because in mongoose 5\n *       // setters will also run on queries, in which case `this` will be a\n *       // mongoose query object.\n *       if (this instanceof Document && v != null) {\n *         this.keywords = v.split(' ');\n *       }\n *       return v;\n *     });\n *\n * @param {Function} fn\n * @return {SchemaType} this\n * @api public\n */\n\nSchemaType.prototype.set = function(fn) {\n  if (typeof fn !== 'function') {\n    throw new TypeError('A setter must be a function.');\n  }\n  this.setters.push(fn);\n  return this;\n};\n\n/**\n * Adds a getter to this schematype.\n *\n * #### Example:\n *\n *     function dob (val) {\n *       if (!val) return val;\n *       return (val.getMonth() + 1) + \"/\" + val.getDate() + \"/\" + val.getFullYear();\n *     }\n *\n *     // defining within the schema\n *     const s = new Schema({ born: { type: Date, get: dob })\n *\n *     // or by retreiving its SchemaType\n *     const s = new Schema({ born: Date })\n *     s.path('born').get(dob)\n *\n * Getters allow you to transform the representation of the data as it travels from the raw mongodb document to the value that you see.\n *\n * Suppose you are storing credit card numbers and you want to hide everything except the last 4 digits to the mongoose user. You can do so by defining a getter in the following way:\n *\n *     function obfuscate (cc) {\n *       return '****-****-****-' + cc.slice(cc.length-4, cc.length);\n *     }\n *\n *     const AccountSchema = new Schema({\n *       creditCardNumber: { type: String, get: obfuscate }\n *     });\n *\n *     const Account = db.model('Account', AccountSchema);\n *\n *     Account.findById(id, function (err, found) {\n *       console.log(found.creditCardNumber); // '****-****-****-1234'\n *     });\n *\n * Getters are also passed a second argument, the schematype on which the getter was defined. This allows for tailored behavior based on options passed in the schema.\n *\n *     function inspector (val, priorValue, schematype) {\n *       if (schematype.options.required) {\n *         return schematype.path + ' is required';\n *       } else {\n *         return schematype.path + ' is not';\n *       }\n *     }\n *\n *     const VirusSchema = new Schema({\n *       name: { type: String, required: true, get: inspector },\n *       taxonomy: { type: String, get: inspector }\n *     })\n *\n *     const Virus = db.model('Virus', VirusSchema);\n *\n *     Virus.findById(id, function (err, virus) {\n *       console.log(virus.name);     // name is required\n *       console.log(virus.taxonomy); // taxonomy is not\n *     })\n *\n * @param {Function} fn\n * @return {SchemaType} this\n * @api public\n */\n\nSchemaType.prototype.get = function(fn) {\n  if (typeof fn !== 'function') {\n    throw new TypeError('A getter must be a function.');\n  }\n  this.getters.push(fn);\n  return this;\n};\n\n/**\n * Adds validator(s) for this document path.\n *\n * Validators always receive the value to validate as their first argument and\n * must return `Boolean`. Returning `false` or throwing an error means\n * validation failed.\n *\n * The error message argument is optional. If not passed, the [default generic error message template](https://mongoosejs.com/docs/api/error.html#Error.messages) will be used.\n *\n * #### Example:\n *\n *     // make sure every value is equal to \"something\"\n *     function validator (val) {\n *       return val === 'something';\n *     }\n *     new Schema({ name: { type: String, validate: validator }});\n *\n *     // with a custom error message\n *\n *     const custom = [validator, 'Uh oh, {PATH} does not equal \"something\".']\n *     new Schema({ name: { type: String, validate: custom }});\n *\n *     // adding many validators at a time\n *\n *     const many = [\n *         { validator: validator, message: 'uh oh' }\n *       , { validator: anotherValidator, message: 'failed' }\n *     ]\n *     new Schema({ name: { type: String, validate: many }});\n *\n *     // or utilizing SchemaType methods directly:\n *\n *     const schema = new Schema({ name: 'string' });\n *     schema.path('name').validate(validator, 'validation of `{PATH}` failed with value `{VALUE}`');\n *\n * #### Error message templates:\n *\n * Below is a list of supported template keywords:\n *\n * - PATH: The schema path where the error is being triggered.\n * - VALUE: The value assigned to the PATH that is triggering the error.\n * - KIND: The validation property that triggered the error i.e. required.\n * - REASON: The error object that caused this error if there was one.\n *\n * If Mongoose's built-in error message templating isn't enough, Mongoose\n * supports setting the `message` property to a function.\n *\n *     schema.path('name').validate({\n *       validator: function(v) { return v.length > 5; },\n *       // `errors['name']` will be \"name must have length 5, got 'foo'\"\n *       message: function(props) {\n *         return `${props.path} must have length 5, got '${props.value}'`;\n *       }\n *     });\n *\n * To bypass Mongoose's error messages and just copy the error message that\n * the validator throws, do this:\n *\n *     schema.path('name').validate({\n *       validator: function() { throw new Error('Oops!'); },\n *       // `errors['name']` will be \"Oops!\"\n *       message: function(props) { return props.reason.message; }\n *     });\n *\n * #### Asynchronous validation:\n *\n * Mongoose supports validators that return a promise. A validator that returns\n * a promise is called an _async validator_. Async validators run in\n * parallel, and `validate()` will wait until all async validators have settled.\n *\n *     schema.path('name').validate({\n *       validator: function (value) {\n *         return new Promise(function (resolve, reject) {\n *           resolve(false); // validation failed\n *         });\n *       }\n *     });\n *\n * You might use asynchronous validators to retreive other documents from the database to validate against or to meet other I/O bound validation needs.\n *\n * Validation occurs `pre('save')` or whenever you manually execute [document#validate](https://mongoosejs.com/docs/api/document.html#Document.prototype.validate()).\n *\n * If validation fails during `pre('save')` and no callback was passed to receive the error, an `error` event will be emitted on your Models associated db [connection](https://mongoosejs.com/docs/api/connection.html#Connection()), passing the validation error object along.\n *\n *     const conn = mongoose.createConnection(..);\n *     conn.on('error', handleError);\n *\n *     const Product = conn.model('Product', yourSchema);\n *     const dvd = new Product(..);\n *     dvd.save(); // emits error on the `conn` above\n *\n * If you want to handle these errors at the Model level, add an `error`\n * listener to your Model as shown below.\n *\n *     // registering an error listener on the Model lets us handle errors more locally\n *     Product.on('error', handleError);\n *\n * @param {RegExp|Function|Object} obj validator function, or hash describing options\n * @param {Function} [obj.validator] validator function. If the validator function returns `undefined` or a truthy value, validation succeeds. If it returns [falsy](https://masteringjs.io/tutorials/fundamentals/falsy) (except `undefined`) or throws an error, validation fails.\n * @param {String|Function} [obj.message] optional error message. If function, should return the error message as a string\n * @param {Boolean} [obj.propsParameter=false] If true, Mongoose will pass the validator properties object (with the `validator` function, `message`, etc.) as the 2nd arg to the validator function. This is disabled by default because many validators [rely on positional args](https://github.com/chriso/validator.js#validators), so turning this on may cause unpredictable behavior in external validators.\n * @param {String|Function} [errorMsg] optional error message. If function, should return the error message as a string\n * @param {String} [type] optional validator type\n * @return {SchemaType} this\n * @api public\n */\n\nSchemaType.prototype.validate = function(obj, message, type) {\n  if (typeof obj === 'function' || obj && utils.getFunctionName(obj.constructor) === 'RegExp') {\n    let properties;\n    if (typeof message === 'function') {\n      properties = { validator: obj, message: message };\n      properties.type = type || 'user defined';\n    } else if (message instanceof Object && !type) {\n      properties = isSimpleValidator(message) ? Object.assign({}, message) : clone(message);\n      if (!properties.message) {\n        properties.message = properties.msg;\n      }\n      properties.validator = obj;\n      properties.type = properties.type || 'user defined';\n    } else {\n      if (message == null) {\n        message = MongooseError.messages.general.default;\n      }\n      if (!type) {\n        type = 'user defined';\n      }\n      properties = { message: message, type: type, validator: obj };\n    }\n\n    this.validators.push(properties);\n    return this;\n  }\n\n  let i;\n  let length;\n  let arg;\n\n  for (i = 0, length = arguments.length; i < length; i++) {\n    arg = arguments[i];\n    if (!utils.isPOJO(arg)) {\n      const msg = 'Invalid validator. Received (' + typeof arg + ') '\n        + arg\n        + '. See https://mongoosejs.com/docs/api/schematype.html#SchemaType.prototype.validate()';\n\n      throw new Error(msg);\n    }\n    this.validate(arg.validator, arg);\n  }\n\n  return this;\n};\n\n/**\n * Adds a required validator to this SchemaType. The validator gets added\n * to the front of this SchemaType's validators array using `unshift()`.\n *\n * #### Example:\n *\n *     const s = new Schema({ born: { type: Date, required: true })\n *\n *     // or with custom error message\n *\n *     const s = new Schema({ born: { type: Date, required: '{PATH} is required!' })\n *\n *     // or with a function\n *\n *     const s = new Schema({\n *       userId: ObjectId,\n *       username: {\n *         type: String,\n *         required: function() { return this.userId != null; }\n *       }\n *     })\n *\n *     // or with a function and a custom message\n *     const s = new Schema({\n *       userId: ObjectId,\n *       username: {\n *         type: String,\n *         required: [\n *           function() { return this.userId != null; },\n *           'username is required if id is specified'\n *         ]\n *       }\n *     })\n *\n *     // or through the path API\n *\n *     s.path('name').required(true);\n *\n *     // with custom error messaging\n *\n *     s.path('name').required(true, 'grrr :( ');\n *\n *     // or make a path conditionally required based on a function\n *     const isOver18 = function() { return this.age >= 18; };\n *     s.path('voterRegistrationId').required(isOver18);\n *\n * The required validator uses the SchemaType's `checkRequired` function to\n * determine whether a given value satisfies the required validator. By default,\n * a value satisfies the required validator if `val != null` (that is, if\n * the value is not null nor undefined). However, most built-in mongoose schema\n * types override the default `checkRequired` function:\n *\n * @param {Boolean|Function|Object} required enable/disable the validator, or function that returns required boolean, or options object\n * @param {Boolean|Function} [options.isRequired] enable/disable the validator, or function that returns required boolean\n * @param {Function} [options.ErrorConstructor] custom error constructor. The constructor receives 1 parameter, an object containing the validator properties.\n * @param {String} [message] optional custom error message\n * @return {SchemaType} this\n * @see Customized Error Messages https://mongoosejs.com/docs/api/error.html#Error.messages\n * @see SchemaArray#checkRequired https://mongoosejs.com/docs/api/schemaarray.html#SchemaArray.prototype.checkRequired()\n * @see SchemaBoolean#checkRequired https://mongoosejs.com/docs/api/schemaboolean.html#SchemaBoolean.prototype.checkRequired()\n * @see SchemaBuffer#checkRequired https://mongoosejs.com/docs/api/schemabuffer.html#SchemaBuffer.prototype.checkRequired()\n * @see SchemaNumber#checkRequired https://mongoosejs.com/docs/api/schemanumber.html#SchemaNumber.prototype.checkRequired()\n * @see SchemaObjectId#checkRequired https://mongoosejs.com/docs/api/schemaobjectid.html#ObjectId.prototype.checkRequired()\n * @see SchemaString#checkRequired https://mongoosejs.com/docs/api/schemastring.html#SchemaString.prototype.checkRequired()\n * @api public\n */\n\nSchemaType.prototype.required = function(required, message) {\n  let customOptions = {};\n\n  if (arguments.length > 0 && required == null) {\n    this.validators = this.validators.filter(function(v) {\n      return v.validator !== this.requiredValidator;\n    }, this);\n\n    this.isRequired = false;\n    delete this.originalRequiredValue;\n    return this;\n  }\n\n  if (typeof required === 'object') {\n    customOptions = required;\n    message = customOptions.message || message;\n    required = required.isRequired;\n  }\n\n  if (required === false) {\n    this.validators = this.validators.filter(function(v) {\n      return v.validator !== this.requiredValidator;\n    }, this);\n\n    this.isRequired = false;\n    delete this.originalRequiredValue;\n    return this;\n  }\n\n  const _this = this;\n  this.isRequired = true;\n\n  this.requiredValidator = function(v) {\n    const cachedRequired = this && this.$__ && this.$__.cachedRequired;\n\n    // no validation when this path wasn't selected in the query.\n    if (cachedRequired != null && !this.$__isSelected(_this.path) && !this[documentIsModified](_this.path)) {\n      return true;\n    }\n\n    // `$cachedRequired` gets set in `_evaluateRequiredFunctions()` so we\n    // don't call required functions multiple times in one validate call\n    // See gh-6801\n    if (cachedRequired != null && _this.path in cachedRequired) {\n      const res = cachedRequired[_this.path] ?\n        _this.checkRequired(v, this) :\n        true;\n      delete cachedRequired[_this.path];\n      return res;\n    } else if (typeof required === 'function') {\n      return required.apply(this) ? _this.checkRequired(v, this) : true;\n    }\n\n    return _this.checkRequired(v, this);\n  };\n  this.originalRequiredValue = required;\n\n  if (typeof required === 'string') {\n    message = required;\n    required = undefined;\n  }\n\n  const msg = message || MongooseError.messages.general.required;\n  this.validators.unshift(Object.assign({}, customOptions, {\n    validator: this.requiredValidator,\n    message: msg,\n    type: 'required'\n  }));\n\n  return this;\n};\n\n/**\n * Set the model that this path refers to. This is the option that [populate](https://mongoosejs.com/docs/populate.html)\n * looks at to determine the foreign collection it should query.\n *\n * #### Example:\n *\n *     const userSchema = new Schema({ name: String });\n *     const User = mongoose.model('User', userSchema);\n *\n *     const postSchema = new Schema({ user: mongoose.ObjectId });\n *     postSchema.path('user').ref('User'); // Can set ref to a model name\n *     postSchema.path('user').ref(User); // Or a model class\n *     postSchema.path('user').ref(() => 'User'); // Or a function that returns the model name\n *     postSchema.path('user').ref(() => User); // Or a function that returns the model class\n *\n *     // Or you can just declare the `ref` inline in your schema\n *     const postSchema2 = new Schema({\n *       user: { type: mongoose.ObjectId, ref: User }\n *     });\n *\n * @param {String|Model|Function} ref either a model name, a [Model](https://mongoosejs.com/docs/models.html), or a function that returns a model name or model.\n * @return {SchemaType} this\n * @api public\n */\n\nSchemaType.prototype.ref = function(ref) {\n  this.options.ref = ref;\n  return this;\n};\n\n/**\n * Gets the default value\n *\n * @param {Object} scope the scope which callback are executed\n * @param {Boolean} init\n * @return {Any} The Stored default value.\n * @api private\n */\n\nSchemaType.prototype.getDefault = function(scope, init, options) {\n  let ret;\n  if (typeof this.defaultValue === 'function') {\n    if (\n      this.defaultValue === Date.now ||\n      this.defaultValue === Array ||\n      this.defaultValue.name.toLowerCase() === 'objectid'\n    ) {\n      ret = this.defaultValue.call(scope);\n    } else {\n      ret = this.defaultValue.call(scope, scope);\n    }\n  } else {\n    ret = this.defaultValue;\n  }\n\n  if (ret !== null && ret !== undefined) {\n    if (typeof ret === 'object' && (!this.options || !this.options.shared)) {\n      ret = clone(ret);\n    }\n\n    if (options && options.skipCast) {\n      return this._applySetters(ret, scope);\n    }\n\n    const casted = this.applySetters(ret, scope, init, undefined, setOptionsForDefaults);\n    if (casted && !Array.isArray(casted) && casted.$isSingleNested) {\n      casted.$__parent = scope;\n    }\n    return casted;\n  }\n  return ret;\n};\n\n/**\n * Applies setters without casting\n *\n * @param {Any} value\n * @param {Any} scope\n * @param {Boolean} init\n * @param {Any} priorVal\n * @param {Object} [options]\n * @instance\n * @api private\n */\n\nSchemaType.prototype._applySetters = function(value, scope, init, priorVal, options) {\n  let v = value;\n  if (init) {\n    return v;\n  }\n  const setters = this.setters;\n\n  for (let i = setters.length - 1; i >= 0; i--) {\n    v = setters[i].call(scope, v, priorVal, this, options);\n  }\n\n  return v;\n};\n\n/*!\n * ignore\n */\n\nSchemaType.prototype._castNullish = function _castNullish(v) {\n  return v;\n};\n\n/**\n * Applies setters\n *\n * @param {Object} value\n * @param {Object} scope\n * @param {Boolean} init\n * @return {Any}\n * @api private\n */\n\nSchemaType.prototype.applySetters = function(value, scope, init, priorVal, options) {\n  let v = this._applySetters(value, scope, init, priorVal, options);\n  if (v == null) {\n    return this._castNullish(v);\n  }\n  // do not cast until all setters are applied #665\n  v = this.cast(v, scope, init, priorVal, options);\n\n  return v;\n};\n\n/**\n * Applies getters to a value\n *\n * @param {Object} value\n * @param {Object} scope\n * @return {Any}\n * @api private\n */\n\nSchemaType.prototype.applyGetters = function(value, scope) {\n  let v = value;\n  const getters = this.getters;\n  const len = getters.length;\n\n  if (len === 0) {\n    return v;\n  }\n\n  for (let i = 0; i < len; ++i) {\n    v = getters[i].call(scope, v, this);\n  }\n\n  return v;\n};\n\n/**\n * Sets default `select()` behavior for this path.\n *\n * Set to `true` if this path should always be included in the results, `false` if it should be excluded by default. This setting can be overridden at the query level.\n *\n * #### Example:\n *\n *     T = db.model('T', new Schema({ x: { type: String, select: true }}));\n *     T.find(..); // field x will always be selected ..\n *     // .. unless overridden;\n *     T.find().select('-x').exec(callback);\n *\n * @param {Boolean} val\n * @return {SchemaType} this\n * @api public\n */\n\nSchemaType.prototype.select = function select(val) {\n  this.selected = !!val;\n  return this;\n};\n\n/**\n * Performs a validation of `value` using the validators declared for this SchemaType.\n *\n * @param {Any} value\n * @param {Function} callback\n * @param {Object} scope\n * @param {Object} [options]\n * @param {String} [options.path]\n * @return {Any} If no validators, returns the output from calling `fn`, otherwise no return\n * @api public\n */\n\nSchemaType.prototype.doValidate = function(value, fn, scope, options) {\n  let err = false;\n  const path = this.path;\n\n  // Avoid non-object `validators`\n  const validators = this.validators.\n    filter(v => typeof v === 'object' && v !== null);\n\n  let count = validators.length;\n\n  if (!count) {\n    return fn(null);\n  }\n\n  for (let i = 0, len = validators.length; i < len; ++i) {\n    if (err) {\n      break;\n    }\n\n    const v = validators[i];\n    const validator = v.validator;\n    let ok;\n\n    const validatorProperties = isSimpleValidator(v) ? Object.assign({}, v) : clone(v);\n    validatorProperties.path = options && options.path ? options.path : path;\n    validatorProperties.fullPath = this.$fullPath;\n    validatorProperties.value = value;\n\n    if (validator instanceof RegExp) {\n      validate(validator.test(value), validatorProperties, scope);\n      continue;\n    }\n\n    if (typeof validator !== 'function') {\n      continue;\n    }\n\n    if (value === undefined && validator !== this.requiredValidator) {\n      validate(true, validatorProperties, scope);\n      continue;\n    }\n\n    try {\n      if (validatorProperties.propsParameter) {\n        ok = validator.call(scope, value, validatorProperties);\n      } else {\n        ok = validator.call(scope, value);\n      }\n    } catch (error) {\n      ok = false;\n      validatorProperties.reason = error;\n      if (error.message) {\n        validatorProperties.message = error.message;\n      }\n    }\n\n    if (ok != null && typeof ok.then === 'function') {\n      ok.then(\n        function(ok) { validate(ok, validatorProperties, scope); },\n        function(error) {\n          validatorProperties.reason = error;\n          validatorProperties.message = error.message;\n          ok = false;\n          validate(ok, validatorProperties, scope);\n        });\n    } else {\n      validate(ok, validatorProperties, scope);\n    }\n  }\n\n  function validate(ok, validatorProperties, scope) {\n    if (err) {\n      return;\n    }\n    if (ok === undefined || ok) {\n      if (--count <= 0) {\n        immediate(function() {\n          fn(null);\n        });\n      }\n    } else {\n      const ErrorConstructor = validatorProperties.ErrorConstructor || ValidatorError;\n      err = new ErrorConstructor(validatorProperties, scope);\n      err[validatorErrorSymbol] = true;\n      immediate(function() {\n        fn(err);\n      });\n    }\n  }\n};\n\n\nfunction _validate(ok, validatorProperties) {\n  if (ok !== undefined && !ok) {\n    const ErrorConstructor = validatorProperties.ErrorConstructor || ValidatorError;\n    const err = new ErrorConstructor(validatorProperties);\n    err[validatorErrorSymbol] = true;\n    return err;\n  }\n}\n\n/**\n * Performs a validation of `value` using the validators declared for this SchemaType.\n *\n * #### Note:\n *\n * This method ignores the asynchronous validators.\n *\n * @param {Any} value\n * @param {Object} scope\n * @param {Object} [options]\n * @param {Object} [options.path]\n * @return {MongooseError|null}\n * @api private\n */\n\nSchemaType.prototype.doValidateSync = function(value, scope, options) {\n  const path = this.path;\n  const count = this.validators.length;\n\n  if (!count) {\n    return null;\n  }\n\n  let validators = this.validators;\n  if (value === void 0) {\n    if (this.validators.length !== 0 && this.validators[0].type === 'required') {\n      validators = [this.validators[0]];\n    } else {\n      return null;\n    }\n  }\n\n  let err = null;\n  let i = 0;\n  const len = validators.length;\n  for (i = 0; i < len; ++i) {\n\n    const v = validators[i];\n\n    if (v === null || typeof v !== 'object') {\n      continue;\n    }\n\n    const validator = v.validator;\n    const validatorProperties = isSimpleValidator(v) ? Object.assign({}, v) : clone(v);\n    validatorProperties.path = options && options.path ? options.path : path;\n    validatorProperties.fullPath = this.$fullPath;\n    validatorProperties.value = value;\n    let ok = false;\n\n    // Skip any explicit async validators. Validators that return a promise\n    // will still run, but won't trigger any errors.\n    if (isAsyncFunction(validator)) {\n      continue;\n    }\n\n    if (validator instanceof RegExp) {\n      err = _validate(validator.test(value), validatorProperties);\n      continue;\n    }\n\n    if (typeof validator !== 'function') {\n      continue;\n    }\n\n    try {\n      if (validatorProperties.propsParameter) {\n        ok = validator.call(scope, value, validatorProperties);\n      } else {\n        ok = validator.call(scope, value);\n      }\n    } catch (error) {\n      ok = false;\n      validatorProperties.reason = error;\n    }\n\n    // Skip any validators that return a promise, we can't handle those\n    // synchronously\n    if (ok != null && typeof ok.then === 'function') {\n      continue;\n    }\n    err = _validate(ok, validatorProperties);\n    if (err) {\n      break;\n    }\n  }\n\n  return err;\n};\n\n/**\n * Determines if value is a valid Reference.\n *\n * @param {SchemaType} self\n * @param {Object} value\n * @param {Document} doc\n * @param {Boolean} init\n * @return {Boolean}\n * @api private\n */\n\nSchemaType._isRef = function(self, value, doc, init) {\n  // fast path\n  let ref = init && self.options && (self.options.ref || self.options.refPath);\n\n  if (!ref && doc && doc.$__ != null) {\n    // checks for\n    // - this populated with adhoc model and no ref was set in schema OR\n    // - setting / pushing values after population\n    const path = doc.$__fullPath(self.path, true);\n\n    const owner = doc.ownerDocument();\n    ref = (path != null && owner.$populated(path)) || doc.$populated(self.path);\n  }\n\n  if (ref) {\n    if (value == null) {\n      return true;\n    }\n    if (!Buffer.isBuffer(value) && // buffers are objects too\n      value._bsontype !== 'Binary' // raw binary value from the db\n      && utils.isObject(value) // might have deselected _id in population query\n    ) {\n      return true;\n    }\n\n    return init;\n  }\n\n  return false;\n};\n\n/*!\n * ignore\n */\n\nSchemaType.prototype._castRef = function _castRef(value, doc, init) {\n  if (value == null) {\n    return value;\n  }\n\n  if (value.$__ != null) {\n    value.$__.wasPopulated = value.$__.wasPopulated || true;\n    return value;\n  }\n\n  // setting a populated path\n  if (Buffer.isBuffer(value) || !utils.isObject(value)) {\n    if (init) {\n      return value;\n    }\n    throw new CastError(this.instance, value, this.path, null, this);\n  }\n\n  // Handle the case where user directly sets a populated\n  // path to a plain object; cast to the Model used in\n  // the population query.\n  const path = doc.$__fullPath(this.path, true);\n  const owner = doc.ownerDocument();\n  const pop = owner.$populated(path, true);\n\n  let ret = value;\n  if (!doc.$__.populated ||\n    !doc.$__.populated[path] ||\n    !doc.$__.populated[path].options ||\n    !doc.$__.populated[path].options.options ||\n    !doc.$__.populated[path].options.options.lean) {\n    ret = new pop.options[populateModelSymbol](value);\n    ret.$__.wasPopulated = true;\n  }\n\n  return ret;\n};\n\n/*!\n * ignore\n */\n\nfunction handleSingle(val, context) {\n  return this.castForQuery(null, val, context);\n}\n\n/*!\n * ignore\n */\n\nfunction handleArray(val, context) {\n  const _this = this;\n  if (!Array.isArray(val)) {\n    return [this.castForQuery(null, val, context)];\n  }\n  return val.map(function(m) {\n    return _this.castForQuery(null, m, context);\n  });\n}\n\n/**\n * Just like handleArray, except also allows `[]` because surprisingly\n * `$in: [1, []]` works fine\n * @api private\n */\n\nfunction handle$in(val, context) {\n  const _this = this;\n  if (!Array.isArray(val)) {\n    return [this.castForQuery(null, val, context)];\n  }\n  return val.map(function(m) {\n    if (Array.isArray(m) && m.length === 0) {\n      return m;\n    }\n    return _this.castForQuery(null, m, context);\n  });\n}\n\n/*!\n * ignore\n */\n\nSchemaType.prototype.$conditionalHandlers = {\n  $all: handleArray,\n  $eq: handleSingle,\n  $in: handle$in,\n  $ne: handleSingle,\n  $nin: handle$in,\n  $exists: $exists,\n  $type: $type\n};\n\n/**\n * Cast the given value with the given optional query operator.\n *\n * @param {String} [$conditional] query operator, like `$eq` or `$in`\n * @param {Any} val\n * @param {Query} context\n * @return {Any}\n * @api private\n */\n\nSchemaType.prototype.castForQuery = function($conditional, val, context) {\n  let handler;\n  if ($conditional != null) {\n    handler = this.$conditionalHandlers[$conditional];\n    if (!handler) {\n      throw new Error('Can\\'t use ' + $conditional);\n    }\n    return handler.call(this, val, context);\n  }\n\n  return this.applySetters(val, context);\n};\n\n/**\n * Set & Get the `checkRequired` function\n * Override the function the required validator uses to check whether a value\n * passes the `required` check. Override this on the individual SchemaType.\n *\n * #### Example:\n *\n *     // Use this to allow empty strings to pass the `required` validator\n *     mongoose.Schema.Types.String.checkRequired(v => typeof v === 'string');\n *\n * @param {Function} [fn] If set, will overwrite the current set function\n * @return {Function} The input `fn` or the already set function\n * @static\n * @memberOf SchemaType\n * @function checkRequired\n * @api public\n */\n\nSchemaType.checkRequired = function(fn) {\n  if (arguments.length !== 0) {\n    this._checkRequired = fn;\n  }\n\n  return this._checkRequired;\n};\n\n/**\n * Default check for if this path satisfies the `required` validator.\n *\n * @param {Any} val\n * @return {Boolean} `true` when the value is not `null`, `false` otherwise\n * @api private\n */\n\nSchemaType.prototype.checkRequired = function(val) {\n  return val != null;\n};\n\n/**\n * Clone the current SchemaType\n *\n * @return {SchemaType} The cloned SchemaType instance\n * @api private\n */\n\nSchemaType.prototype.clone = function() {\n  const options = Object.assign({}, this.options);\n  const schematype = new this.constructor(this.path, options, this.instance);\n  schematype.validators = this.validators.slice();\n  if (this.requiredValidator !== undefined) schematype.requiredValidator = this.requiredValidator;\n  if (this.defaultValue !== undefined) schematype.defaultValue = this.defaultValue;\n  if (this.$immutable !== undefined && this.options.immutable === undefined) {\n    schematype.$immutable = this.$immutable;\n\n    handleImmutable(schematype);\n  }\n  if (this._index !== undefined) schematype._index = this._index;\n  if (this.selected !== undefined) schematype.selected = this.selected;\n  if (this.isRequired !== undefined) schematype.isRequired = this.isRequired;\n  if (this.originalRequiredValue !== undefined) schematype.originalRequiredValue = this.originalRequiredValue;\n  schematype.getters = this.getters.slice();\n  schematype.setters = this.setters.slice();\n  return schematype;\n};\n\n/*!\n * Module exports.\n */\n\nmodule.exports = exports = SchemaType;\n\nexports.CastError = CastError;\n\nexports.ValidatorError = ValidatorError;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbW9uZ29vc2UvbGliL3NjaGVtYVR5cGUuanMiLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWI7QUFDQTtBQUNBOztBQUVBLHNCQUFzQixtQkFBTyxDQUFDLHVFQUFlO0FBQzdDLDBCQUEwQixtQkFBTyxDQUFDLG1HQUE2QjtBQUMvRCxnQkFBZ0IsbUJBQU8sQ0FBQywrRkFBMkI7QUFDbkQsY0FBYyxtQkFBTyxDQUFDLDJGQUF5QjtBQUMvQyxjQUFjLG1CQUFPLENBQUMsMkVBQWlCO0FBQ3ZDLHdCQUF3QixtQkFBTyxDQUFDLHFIQUFzQztBQUN0RSx3QkFBd0IsbUJBQU8sQ0FBQywrRkFBMkI7QUFDM0QsMEJBQTBCLG1CQUFPLENBQUMsbUdBQTZCO0FBQy9ELGtCQUFrQixtQkFBTyxDQUFDLG1GQUFxQjtBQUMvQyx5QkFBeUIsdUhBQTZDO0FBQ3RFLGNBQWMsbUJBQU8sQ0FBQywyREFBUztBQUMvQiw2QkFBNkIsMkhBQWlEO0FBQzlFLDJCQUEyQix5SEFBK0M7O0FBRTFFLDRCQUE0QiwwSEFBZ0Q7O0FBRTVFO0FBQ0E7O0FBRUEsZ0NBQWdDOztBQUVoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUMsY0FBYztBQUNqRCxrREFBa0Q7QUFDbEQ7QUFDQSxXQUFXLFFBQVE7QUFDbkIsV0FBVyxtQkFBbUI7QUFDOUIsV0FBVyxRQUFRO0FBQ25CO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOzs7QUFHQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtB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QztBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBLGlCQUFpQjs7QUFFakIsc0JBQXNCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vYXBwMS8uL25vZGVfbW9kdWxlcy9tb25nb29zZS9saWIvc2NoZW1hVHlwZS5qcz8xNzdlIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxuLyohXG4gKiBNb2R1bGUgZGVwZW5kZW5jaWVzLlxuICovXG5cbmNvbnN0IE1vbmdvb3NlRXJyb3IgPSByZXF1aXJlKCcuL2Vycm9yL2luZGV4Jyk7XG5jb25zdCBTY2hlbWFUeXBlT3B0aW9ucyA9IHJlcXVpcmUoJy4vb3B0aW9ucy9zY2hlbWFUeXBlT3B0aW9ucycpO1xuY29uc3QgJGV4aXN0cyA9IHJlcXVpcmUoJy4vc2NoZW1hL29wZXJhdG9ycy9leGlzdHMnKTtcbmNvbnN0ICR0eXBlID0gcmVxdWlyZSgnLi9zY2hlbWEvb3BlcmF0b3JzL3R5cGUnKTtcbmNvbnN0IGNsb25lID0gcmVxdWlyZSgnLi9oZWxwZXJzL2Nsb25lJyk7XG5jb25zdCBoYW5kbGVJbW11dGFibGUgPSByZXF1aXJlKCcuL2hlbHBlcnMvc2NoZW1hdHlwZS9oYW5kbGVJbW11dGFibGUnKTtcbmNvbnN0IGlzQXN5bmNGdW5jdGlvbiA9IHJlcXVpcmUoJy4vaGVscGVycy9pc0FzeW5jRnVuY3Rpb24nKTtcbmNvbnN0IGlzU2ltcGxlVmFsaWRhdG9yID0gcmVxdWlyZSgnLi9oZWxwZXJzL2lzU2ltcGxlVmFsaWRhdG9yJyk7XG5jb25zdCBpbW1lZGlhdGUgPSByZXF1aXJlKCcuL2hlbHBlcnMvaW1tZWRpYXRlJyk7XG5jb25zdCBzY2hlbWFUeXBlU3ltYm9sID0gcmVxdWlyZSgnLi9oZWxwZXJzL3N5bWJvbHMnKS5zY2hlbWFUeXBlU3ltYm9sO1xuY29uc3QgdXRpbHMgPSByZXF1aXJlKCcuL3V0aWxzJyk7XG5jb25zdCB2YWxpZGF0b3JFcnJvclN5bWJvbCA9IHJlcXVpcmUoJy4vaGVscGVycy9zeW1ib2xzJykudmFsaWRhdG9yRXJyb3JTeW1ib2w7XG5jb25zdCBkb2N1bWVudElzTW9kaWZpZWQgPSByZXF1aXJlKCcuL2hlbHBlcnMvc3ltYm9scycpLmRvY3VtZW50SXNNb2RpZmllZDtcblxuY29uc3QgcG9wdWxhdGVNb2RlbFN5bWJvbCA9IHJlcXVpcmUoJy4vaGVscGVycy9zeW1ib2xzJykucG9wdWxhdGVNb2RlbFN5bWJvbDtcblxuY29uc3QgQ2FzdEVycm9yID0gTW9uZ29vc2VFcnJvci5DYXN0RXJyb3I7XG5jb25zdCBWYWxpZGF0b3JFcnJvciA9IE1vbmdvb3NlRXJyb3IuVmFsaWRhdG9yRXJyb3I7XG5cbmNvbnN0IHNldE9wdGlvbnNGb3JEZWZhdWx0cyA9IHsgX3NraXBNYXJrTW9kaWZpZWQ6IHRydWUgfTtcblxuLyoqXG4gKiBTY2hlbWFUeXBlIGNvbnN0cnVjdG9yLiBEbyAqKm5vdCoqIGluc3RhbnRpYXRlIGBTY2hlbWFUeXBlYCBkaXJlY3RseS5cbiAqIE1vbmdvb3NlIGNvbnZlcnRzIHlvdXIgc2NoZW1hIHBhdGhzIGludG8gU2NoZW1hVHlwZXMgYXV0b21hdGljYWxseS5cbiAqXG4gKiAjIyMjIEV4YW1wbGU6XG4gKlxuICogICAgIGNvbnN0IHNjaGVtYSA9IG5ldyBTY2hlbWEoeyBuYW1lOiBTdHJpbmcgfSk7XG4gKiAgICAgc2NoZW1hLnBhdGgoJ25hbWUnKSBpbnN0YW5jZW9mIFNjaGVtYVR5cGU7IC8vIHRydWVcbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gcGF0aFxuICogQHBhcmFtIHtTY2hlbWFUeXBlT3B0aW9uc30gW29wdGlvbnNdIFNlZSBbU2NoZW1hVHlwZU9wdGlvbnMgZG9jc10oaHR0cHM6Ly9tb25nb29zZWpzLmNvbS9kb2NzL2FwaS9zY2hlbWF0eXBlb3B0aW9ucy5odG1sKVxuICogQHBhcmFtIHtTdHJpbmd9IFtpbnN0YW5jZV1cbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZnVuY3Rpb24gU2NoZW1hVHlwZShwYXRoLCBvcHRpb25zLCBpbnN0YW5jZSkge1xuICB0aGlzW3NjaGVtYVR5cGVTeW1ib2xdID0gdHJ1ZTtcbiAgdGhpcy5wYXRoID0gcGF0aDtcbiAgdGhpcy5pbnN0YW5jZSA9IGluc3RhbmNlO1xuICB0aGlzLnZhbGlkYXRvcnMgPSBbXTtcbiAgdGhpcy5nZXR0ZXJzID0gdGhpcy5jb25zdHJ1Y3Rvci5oYXNPd25Qcm9wZXJ0eSgnZ2V0dGVycycpID9cbiAgICB0aGlzLmNvbnN0cnVjdG9yLmdldHRlcnMuc2xpY2UoKSA6XG4gICAgW107XG4gIHRoaXMuc2V0dGVycyA9IHRoaXMuY29uc3RydWN0b3IuaGFzT3duUHJvcGVydHkoJ3NldHRlcnMnKSA/XG4gICAgdGhpcy5jb25zdHJ1Y3Rvci5zZXR0ZXJzLnNsaWNlKCkgOlxuICAgIFtdO1xuXG4gIHRoaXMuc3BsaXRQYXRoKCk7XG5cbiAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gIGNvbnN0IGRlZmF1bHRPcHRpb25zID0gdGhpcy5jb25zdHJ1Y3Rvci5kZWZhdWx0T3B0aW9ucyB8fCB7fTtcbiAgY29uc3QgZGVmYXVsdE9wdGlvbnNLZXlzID0gT2JqZWN0LmtleXMoZGVmYXVsdE9wdGlvbnMpO1xuXG4gIGZvciAoY29uc3Qgb3B0aW9uIG9mIGRlZmF1bHRPcHRpb25zS2V5cykge1xuICAgIGlmIChkZWZhdWx0T3B0aW9ucy5oYXNPd25Qcm9wZXJ0eShvcHRpb24pICYmICFPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob3B0aW9ucywgb3B0aW9uKSkge1xuICAgICAgb3B0aW9uc1tvcHRpb25dID0gZGVmYXVsdE9wdGlvbnNbb3B0aW9uXTtcbiAgICB9XG4gIH1cblxuICBpZiAob3B0aW9ucy5zZWxlY3QgPT0gbnVsbCkge1xuICAgIGRlbGV0ZSBvcHRpb25zLnNlbGVjdDtcbiAgfVxuXG4gIGNvbnN0IE9wdGlvbnMgPSB0aGlzLk9wdGlvbnNDb25zdHJ1Y3RvciB8fCBTY2hlbWFUeXBlT3B0aW9ucztcbiAgdGhpcy5vcHRpb25zID0gbmV3IE9wdGlvbnMob3B0aW9ucyk7XG4gIHRoaXMuX2luZGV4ID0gbnVsbDtcblxuXG4gIGlmICh1dGlscy5oYXNVc2VyRGVmaW5lZFByb3BlcnR5KHRoaXMub3B0aW9ucywgJ2ltbXV0YWJsZScpKSB7XG4gICAgdGhpcy4kaW1tdXRhYmxlID0gdGhpcy5vcHRpb25zLmltbXV0YWJsZTtcblxuICAgIGhhbmRsZUltbXV0YWJsZSh0aGlzKTtcbiAgfVxuXG4gIGNvbnN0IGtleXMgPSBPYmplY3Qua2V5cyh0aGlzLm9wdGlvbnMpO1xuICBmb3IgKGNvbnN0IHByb3Agb2Yga2V5cykge1xuICAgIGlmIChwcm9wID09PSAnY2FzdCcpIHtcbiAgICAgIGlmIChBcnJheS5pc0FycmF5KHRoaXMub3B0aW9uc1twcm9wXSkpIHtcbiAgICAgICAgdGhpcy5jYXN0RnVuY3Rpb24uYXBwbHkodGhpcywgdGhpcy5vcHRpb25zW3Byb3BdKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuY2FzdEZ1bmN0aW9uKHRoaXMub3B0aW9uc1twcm9wXSk7XG4gICAgICB9XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgaWYgKHV0aWxzLmhhc1VzZXJEZWZpbmVkUHJvcGVydHkodGhpcy5vcHRpb25zLCBwcm9wKSAmJiB0eXBlb2YgdGhpc1twcm9wXSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgLy8geyB1bmlxdWU6IHRydWUsIGluZGV4OiB0cnVlIH1cbiAgICAgIGlmIChwcm9wID09PSAnaW5kZXgnICYmIHRoaXMuX2luZGV4KSB7XG4gICAgICAgIGlmIChvcHRpb25zLmluZGV4ID09PSBmYWxzZSkge1xuICAgICAgICAgIGNvbnN0IGluZGV4ID0gdGhpcy5faW5kZXg7XG4gICAgICAgICAgaWYgKHR5cGVvZiBpbmRleCA9PT0gJ29iamVjdCcgJiYgaW5kZXggIT0gbnVsbCkge1xuICAgICAgICAgICAgaWYgKGluZGV4LnVuaXF1ZSkge1xuICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1BhdGggXCInICsgdGhpcy5wYXRoICsgJ1wiIG1heSBub3QgaGF2ZSBgaW5kZXhgICcgK1xuICAgICAgICAgICAgICAgICdzZXQgdG8gZmFsc2UgYW5kIGB1bmlxdWVgIHNldCB0byB0cnVlJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoaW5kZXguc3BhcnNlKSB7XG4gICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignUGF0aCBcIicgKyB0aGlzLnBhdGggKyAnXCIgbWF5IG5vdCBoYXZlIGBpbmRleGAgJyArXG4gICAgICAgICAgICAgICAgJ3NldCB0byBmYWxzZSBhbmQgYHNwYXJzZWAgc2V0IHRvIHRydWUnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICB0aGlzLl9pbmRleCA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuXG4gICAgICBjb25zdCB2YWwgPSBvcHRpb25zW3Byb3BdO1xuICAgICAgLy8gU3BlY2lhbCBjYXNlIHNvIHdlIGRvbid0IHNjcmV3IHVwIGFycmF5IGRlZmF1bHRzLCBzZWUgZ2gtNTc4MFxuICAgICAgaWYgKHByb3AgPT09ICdkZWZhdWx0Jykge1xuICAgICAgICB0aGlzLmRlZmF1bHQodmFsKTtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IG9wdHMgPSBBcnJheS5pc0FycmF5KHZhbCkgPyB2YWwgOiBbdmFsXTtcblxuICAgICAgdGhpc1twcm9wXS5hcHBseSh0aGlzLCBvcHRzKTtcbiAgICB9XG4gIH1cblxuICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgJyQkY29udGV4dCcsIHtcbiAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICBjb25maWd1cmFibGU6IGZhbHNlLFxuICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgIHZhbHVlOiBudWxsXG4gIH0pO1xufVxuXG4vKipcbiAqIFRoZSBjbGFzcyB0aGF0IE1vbmdvb3NlIHVzZXMgaW50ZXJuYWxseSB0byBpbnN0YW50aWF0ZSB0aGlzIFNjaGVtYVR5cGUncyBgb3B0aW9uc2AgcHJvcGVydHkuXG4gKiBAbWVtYmVyT2YgU2NoZW1hVHlwZVxuICogQGluc3RhbmNlXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5TY2hlbWFUeXBlLnByb3RvdHlwZS5PcHRpb25zQ29uc3RydWN0b3IgPSBTY2hlbWFUeXBlT3B0aW9ucztcblxuLyoqXG4gKiBUaGUgcGF0aCB0byB0aGlzIFNjaGVtYVR5cGUgaW4gYSBTY2hlbWEuXG4gKlxuICogIyMjIyBFeGFtcGxlOlxuICpcbiAqICAgICBjb25zdCBzY2hlbWEgPSBuZXcgU2NoZW1hKHsgbmFtZTogU3RyaW5nIH0pO1xuICogICAgIHNjaGVtYS5wYXRoKCduYW1lJykucGF0aDsgLy8gJ25hbWUnXG4gKlxuICogQHByb3BlcnR5IHBhdGhcbiAqIEBhcGkgcHVibGljXG4gKiBAbWVtYmVyT2YgU2NoZW1hVHlwZVxuICovXG5cblNjaGVtYVR5cGUucHJvdG90eXBlLnBhdGg7XG5cbi8qKlxuICogVGhlIHZhbGlkYXRvcnMgdGhhdCBNb25nb29zZSBzaG91bGQgcnVuIHRvIHZhbGlkYXRlIHByb3BlcnRpZXMgYXQgdGhpcyBTY2hlbWFUeXBlJ3MgcGF0aC5cbiAqXG4gKiAjIyMjIEV4YW1wbGU6XG4gKlxuICogICAgIGNvbnN0IHNjaGVtYSA9IG5ldyBTY2hlbWEoeyBuYW1lOiB7IHR5cGU6IFN0cmluZywgcmVxdWlyZWQ6IHRydWUgfSB9KTtcbiAqICAgICBzY2hlbWEucGF0aCgnbmFtZScpLnZhbGlkYXRvcnMubGVuZ3RoOyAvLyAxLCB0aGUgYHJlcXVpcmVkYCB2YWxpZGF0b3JcbiAqXG4gKiBAcHJvcGVydHkgdmFsaWRhdG9yc1xuICogQGFwaSBwdWJsaWNcbiAqIEBtZW1iZXJPZiBTY2hlbWFUeXBlXG4gKi9cblxuU2NoZW1hVHlwZS5wcm90b3R5cGUudmFsaWRhdG9ycztcblxuLyoqXG4gKiBUcnVlIGlmIHRoaXMgU2NoZW1hVHlwZSBoYXMgYSByZXF1aXJlZCB2YWxpZGF0b3IuIEZhbHNlIG90aGVyd2lzZS5cbiAqXG4gKiAjIyMjIEV4YW1wbGU6XG4gKlxuICogICAgIGNvbnN0IHNjaGVtYSA9IG5ldyBTY2hlbWEoeyBuYW1lOiB7IHR5cGU6IFN0cmluZywgcmVxdWlyZWQ6IHRydWUgfSB9KTtcbiAqICAgICBzY2hlbWEucGF0aCgnbmFtZScpLmlzUmVxdWlyZWQ7IC8vIHRydWVcbiAqXG4gKiAgICAgc2NoZW1hLnBhdGgoJ25hbWUnKS5yZXF1aXJlZChmYWxzZSk7XG4gKiAgICAgc2NoZW1hLnBhdGgoJ25hbWUnKS5pc1JlcXVpcmVkOyAvLyBmYWxzZVxuICpcbiAqIEBwcm9wZXJ0eSBpc1JlcXVpcmVkXG4gKiBAYXBpIHB1YmxpY1xuICogQG1lbWJlck9mIFNjaGVtYVR5cGVcbiAqL1xuXG5TY2hlbWFUeXBlLnByb3RvdHlwZS5pc1JlcXVpcmVkO1xuXG4vKipcbiAqIFNwbGl0IHRoZSBjdXJyZW50IGRvdHRldCBwYXRoIGludG8gc2VnbWVudHNcbiAqXG4gKiBAcmV0dXJuIHtTdHJpbmdbXXx1bmRlZmluZWR9XG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5TY2hlbWFUeXBlLnByb3RvdHlwZS5zcGxpdFBhdGggPSBmdW5jdGlvbigpIHtcbiAgaWYgKHRoaXMuX3ByZXNwbGl0UGF0aCAhPSBudWxsKSB7XG4gICAgcmV0dXJuIHRoaXMuX3ByZXNwbGl0UGF0aDtcbiAgfVxuICBpZiAodGhpcy5wYXRoID09IG51bGwpIHtcbiAgICByZXR1cm4gdW5kZWZpbmVkO1xuICB9XG5cbiAgdGhpcy5fcHJlc3BsaXRQYXRoID0gdGhpcy5wYXRoLmluZGV4T2YoJy4nKSA9PT0gLTEgPyBbdGhpcy5wYXRoXSA6IHRoaXMucGF0aC5zcGxpdCgnLicpO1xuICByZXR1cm4gdGhpcy5fcHJlc3BsaXRQYXRoO1xufTtcblxuLyoqXG4gKiBHZXQvc2V0IHRoZSBmdW5jdGlvbiB1c2VkIHRvIGNhc3QgYXJiaXRyYXJ5IHZhbHVlcyB0byB0aGlzIHR5cGUuXG4gKlxuICogIyMjIyBFeGFtcGxlOlxuICpcbiAqICAgICAvLyBEaXNhbGxvdyBgbnVsbGAgZm9yIG51bWJlcnMsIGFuZCBkb24ndCB0cnkgdG8gY2FzdCBhbnkgdmFsdWVzIHRvXG4gKiAgICAgLy8gbnVtYmVycywgc28gZXZlbiBzdHJpbmdzIGxpa2UgJzEyMycgd2lsbCBjYXVzZSBhIENhc3RFcnJvci5cbiAqICAgICBtb25nb29zZS5OdW1iZXIuY2FzdChmdW5jdGlvbih2KSB7XG4gKiAgICAgICBhc3NlcnQub2sodiA9PT0gdW5kZWZpbmVkIHx8IHR5cGVvZiB2ID09PSAnbnVtYmVyJyk7XG4gKiAgICAgICByZXR1cm4gdjtcbiAqICAgICB9KTtcbiAqXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufGZhbHNlfSBjYXN0ZXIgRnVuY3Rpb24gdGhhdCBjYXN0cyBhcmJpdHJhcnkgdmFsdWVzIHRvIHRoaXMgdHlwZSwgb3IgdGhyb3dzIGFuIGVycm9yIGlmIGNhc3RpbmcgZmFpbGVkXG4gKiBAcmV0dXJuIHtGdW5jdGlvbn1cbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBTY2hlbWFUeXBlXG4gKiBAZnVuY3Rpb24gY2FzdFxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5TY2hlbWFUeXBlLmNhc3QgPSBmdW5jdGlvbiBjYXN0KGNhc3Rlcikge1xuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMCkge1xuICAgIHJldHVybiB0aGlzLl9jYXN0O1xuICB9XG4gIGlmIChjYXN0ZXIgPT09IGZhbHNlKSB7XG4gICAgY2FzdGVyID0gdiA9PiB2O1xuICB9XG4gIHRoaXMuX2Nhc3QgPSBjYXN0ZXI7XG5cbiAgcmV0dXJuIHRoaXMuX2Nhc3Q7XG59O1xuXG4vKipcbiAqIEdldC9zZXQgdGhlIGZ1bmN0aW9uIHVzZWQgdG8gY2FzdCBhcmJpdHJhcnkgdmFsdWVzIHRvIHRoaXMgcGFydGljdWxhciBzY2hlbWF0eXBlIGluc3RhbmNlLlxuICogT3ZlcnJpZGVzIGBTY2hlbWFUeXBlLmNhc3QoKWAuXG4gKlxuICogIyMjIyBFeGFtcGxlOlxuICpcbiAqICAgICAvLyBEaXNhbGxvdyBgbnVsbGAgZm9yIG51bWJlcnMsIGFuZCBkb24ndCB0cnkgdG8gY2FzdCBhbnkgdmFsdWVzIHRvXG4gKiAgICAgLy8gbnVtYmVycywgc28gZXZlbiBzdHJpbmdzIGxpa2UgJzEyMycgd2lsbCBjYXVzZSBhIENhc3RFcnJvci5cbiAqICAgICBjb25zdCBudW1iZXIgPSBuZXcgbW9uZ29vc2UuTnVtYmVyKCdteXBhdGgnLCB7fSk7XG4gKiAgICAgbnVtYmVyLmNhc3QoZnVuY3Rpb24odikge1xuICogICAgICAgYXNzZXJ0Lm9rKHYgPT09IHVuZGVmaW5lZCB8fCB0eXBlb2YgdiA9PT0gJ251bWJlcicpO1xuICogICAgICAgcmV0dXJuIHY7XG4gKiAgICAgfSk7XG4gKlxuICogQHBhcmFtIHtGdW5jdGlvbnxmYWxzZX0gY2FzdGVyIEZ1bmN0aW9uIHRoYXQgY2FzdHMgYXJiaXRyYXJ5IHZhbHVlcyB0byB0aGlzIHR5cGUsIG9yIHRocm93cyBhbiBlcnJvciBpZiBjYXN0aW5nIGZhaWxlZFxuICogQHJldHVybiB7RnVuY3Rpb259XG4gKiBAbWVtYmVyT2YgU2NoZW1hVHlwZVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5TY2hlbWFUeXBlLnByb3RvdHlwZS5jYXN0RnVuY3Rpb24gPSBmdW5jdGlvbiBjYXN0RnVuY3Rpb24oY2FzdGVyLCBtZXNzYWdlKSB7XG4gIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAwKSB7XG4gICAgcmV0dXJuIHRoaXMuX2Nhc3RGdW5jdGlvbjtcbiAgfVxuXG4gIGlmIChjYXN0ZXIgPT09IGZhbHNlKSB7XG4gICAgY2FzdGVyID0gdGhpcy5jb25zdHJ1Y3Rvci5fZGVmYXVsdENhc3RlciB8fCAodiA9PiB2KTtcbiAgfVxuICBpZiAodHlwZW9mIGNhc3RlciA9PT0gJ3N0cmluZycpIHtcbiAgICB0aGlzLl9jYXN0RXJyb3JNZXNzYWdlID0gY2FzdGVyO1xuICAgIHJldHVybiB0aGlzLl9jYXN0RnVuY3Rpb247XG4gIH1cbiAgaWYgKGNhc3RlciAhPSBudWxsKSB7XG4gICAgdGhpcy5fY2FzdEZ1bmN0aW9uID0gY2FzdGVyO1xuICB9XG4gIGlmIChtZXNzYWdlICE9IG51bGwpIHtcbiAgICB0aGlzLl9jYXN0RXJyb3JNZXNzYWdlID0gbWVzc2FnZTtcbiAgfVxuXG4gIHJldHVybiB0aGlzLl9jYXN0RnVuY3Rpb247XG59O1xuXG4vKipcbiAqIFRoZSBmdW5jdGlvbiB0aGF0IE1vbmdvb3NlIGNhbGxzIHRvIGNhc3QgYXJiaXRyYXJ5IHZhbHVlcyB0byB0aGlzIFNjaGVtYVR5cGUuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IHZhbHVlIHZhbHVlIHRvIGNhc3RcbiAqIEBwYXJhbSB7RG9jdW1lbnR9IGRvYyBkb2N1bWVudCB0aGF0IHRyaWdnZXJzIHRoZSBjYXN0aW5nXG4gKiBAcGFyYW0ge0Jvb2xlYW59IGluaXRcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuU2NoZW1hVHlwZS5wcm90b3R5cGUuY2FzdCA9IGZ1bmN0aW9uIGNhc3QoKSB7XG4gIHRocm93IG5ldyBFcnJvcignQmFzZSBTY2hlbWFUeXBlIGNsYXNzIGRvZXMgbm90IGltcGxlbWVudCBhIGBjYXN0KClgIGZ1bmN0aW9uJyk7XG59O1xuXG4vKipcbiAqIFNldHMgYSBkZWZhdWx0IG9wdGlvbiBmb3IgdGhpcyBzY2hlbWEgdHlwZS5cbiAqXG4gKiAjIyMjIEV4YW1wbGU6XG4gKlxuICogICAgIC8vIE1ha2UgYWxsIHN0cmluZ3MgYmUgdHJpbW1lZCBieSBkZWZhdWx0XG4gKiAgICAgbW9uZ29vc2UuU2NoZW1hVHlwZXMuU3RyaW5nLnNldCgndHJpbScsIHRydWUpO1xuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBvcHRpb24gVGhlIG5hbWUgb2YgdGhlIG9wdGlvbiB5b3UnZCBsaWtlIHRvIHNldCAoZS5nLiB0cmltLCBsb3dlcmNhc2UsIGV0Yy4uLilcbiAqIEBwYXJhbSB7QW55fSB2YWx1ZSBUaGUgdmFsdWUgb2YgdGhlIG9wdGlvbiB5b3UnZCBsaWtlIHRvIHNldC5cbiAqIEByZXR1cm4ge3ZvaWR9XG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgU2NoZW1hVHlwZVxuICogQGZ1bmN0aW9uIHNldFxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5TY2hlbWFUeXBlLnNldCA9IGZ1bmN0aW9uIHNldChvcHRpb24sIHZhbHVlKSB7XG4gIGlmICghdGhpcy5oYXNPd25Qcm9wZXJ0eSgnZGVmYXVsdE9wdGlvbnMnKSkge1xuICAgIHRoaXMuZGVmYXVsdE9wdGlvbnMgPSBPYmplY3QuYXNzaWduKHt9LCB0aGlzLmRlZmF1bHRPcHRpb25zKTtcbiAgfVxuICB0aGlzLmRlZmF1bHRPcHRpb25zW29wdGlvbl0gPSB2YWx1ZTtcbn07XG5cbi8qKlxuICogQXR0YWNoZXMgYSBnZXR0ZXIgZm9yIGFsbCBpbnN0YW5jZXMgb2YgdGhpcyBzY2hlbWEgdHlwZS5cbiAqXG4gKiAjIyMjIEV4YW1wbGU6XG4gKlxuICogICAgIC8vIE1ha2UgYWxsIG51bWJlcnMgcm91bmQgZG93blxuICogICAgIG1vbmdvb3NlLk51bWJlci5nZXQoZnVuY3Rpb24odikgeyByZXR1cm4gTWF0aC5mbG9vcih2KTsgfSk7XG4gKlxuICogQHBhcmFtIHtGdW5jdGlvbn0gZ2V0dGVyXG4gKiBAcmV0dXJuIHt0aGlzfVxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIFNjaGVtYVR5cGVcbiAqIEBmdW5jdGlvbiBnZXRcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuU2NoZW1hVHlwZS5nZXQgPSBmdW5jdGlvbihnZXR0ZXIpIHtcbiAgdGhpcy5nZXR0ZXJzID0gdGhpcy5oYXNPd25Qcm9wZXJ0eSgnZ2V0dGVycycpID8gdGhpcy5nZXR0ZXJzIDogW107XG4gIHRoaXMuZ2V0dGVycy5wdXNoKGdldHRlcik7XG59O1xuXG4vKipcbiAqIFNldHMgYSBkZWZhdWx0IHZhbHVlIGZvciB0aGlzIFNjaGVtYVR5cGUuXG4gKlxuICogIyMjIyBFeGFtcGxlOlxuICpcbiAqICAgICBjb25zdCBzY2hlbWEgPSBuZXcgU2NoZW1hKHsgbjogeyB0eXBlOiBOdW1iZXIsIGRlZmF1bHQ6IDEwIH0pXG4gKiAgICAgY29uc3QgTSA9IGRiLm1vZGVsKCdNJywgc2NoZW1hKVxuICogICAgIGNvbnN0IG0gPSBuZXcgTTtcbiAqICAgICBjb25zb2xlLmxvZyhtLm4pIC8vIDEwXG4gKlxuICogRGVmYXVsdHMgY2FuIGJlIGVpdGhlciBgZnVuY3Rpb25zYCB3aGljaCByZXR1cm4gdGhlIHZhbHVlIHRvIHVzZSBhcyB0aGUgZGVmYXVsdCBvciB0aGUgbGl0ZXJhbCB2YWx1ZSBpdHNlbGYuIEVpdGhlciB3YXksIHRoZSB2YWx1ZSB3aWxsIGJlIGNhc3QgYmFzZWQgb24gaXRzIHNjaGVtYSB0eXBlIGJlZm9yZSBiZWluZyBzZXQgZHVyaW5nIGRvY3VtZW50IGNyZWF0aW9uLlxuICpcbiAqICMjIyMgRXhhbXBsZTpcbiAqXG4gKiAgICAgLy8gdmFsdWVzIGFyZSBjYXN0OlxuICogICAgIGNvbnN0IHNjaGVtYSA9IG5ldyBTY2hlbWEoeyBhTnVtYmVyOiB7IHR5cGU6IE51bWJlciwgZGVmYXVsdDogNC44MTUxNjIzNDIgfX0pXG4gKiAgICAgY29uc3QgTSA9IGRiLm1vZGVsKCdNJywgc2NoZW1hKVxuICogICAgIGNvbnN0IG0gPSBuZXcgTTtcbiAqICAgICBjb25zb2xlLmxvZyhtLmFOdW1iZXIpIC8vIDQuODE1MTYyMzQyXG4gKlxuICogICAgIC8vIGRlZmF1bHQgdW5pcXVlIG9iamVjdHMgZm9yIE1peGVkIHR5cGVzOlxuICogICAgIGNvbnN0IHNjaGVtYSA9IG5ldyBTY2hlbWEoeyBtaXhlZDogU2NoZW1hLlR5cGVzLk1peGVkIH0pO1xuICogICAgIHNjaGVtYS5wYXRoKCdtaXhlZCcpLmRlZmF1bHQoZnVuY3Rpb24gKCkge1xuICogICAgICAgcmV0dXJuIHt9O1xuICogICAgIH0pO1xuICpcbiAqICAgICAvLyBpZiB3ZSBkb24ndCB1c2UgYSBmdW5jdGlvbiB0byByZXR1cm4gb2JqZWN0IGxpdGVyYWxzIGZvciBNaXhlZCBkZWZhdWx0cyxcbiAqICAgICAvLyBlYWNoIGRvY3VtZW50IHdpbGwgcmVjZWl2ZSBhIHJlZmVyZW5jZSB0byB0aGUgc2FtZSBvYmplY3QgbGl0ZXJhbCBjcmVhdGluZ1xuICogICAgIC8vIGEgXCJzaGFyZWRcIiBvYmplY3QgaW5zdGFuY2U6XG4gKiAgICAgY29uc3Qgc2NoZW1hID0gbmV3IFNjaGVtYSh7IG1peGVkOiBTY2hlbWEuVHlwZXMuTWl4ZWQgfSk7XG4gKiAgICAgc2NoZW1hLnBhdGgoJ21peGVkJykuZGVmYXVsdCh7fSk7XG4gKiAgICAgY29uc3QgTSA9IGRiLm1vZGVsKCdNJywgc2NoZW1hKTtcbiAqICAgICBjb25zdCBtMSA9IG5ldyBNO1xuICogICAgIG0xLm1peGVkLmFkZGVkID0gMTtcbiAqICAgICBjb25zb2xlLmxvZyhtMS5taXhlZCk7IC8vIHsgYWRkZWQ6IDEgfVxuICogICAgIGNvbnN0IG0yID0gbmV3IE07XG4gKiAgICAgY29uc29sZS5sb2cobTIubWl4ZWQpOyAvLyB7IGFkZGVkOiAxIH1cbiAqXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufGFueX0gdmFsIFRoZSBkZWZhdWx0IHZhbHVlIHRvIHNldFxuICogQHJldHVybiB7QW55fHVuZGVmaW5lZH0gUmV0dXJucyB0aGUgc2V0IGRlZmF1bHQgdmFsdWUuXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cblNjaGVtYVR5cGUucHJvdG90eXBlLmRlZmF1bHQgPSBmdW5jdGlvbih2YWwpIHtcbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDEpIHtcbiAgICBpZiAodmFsID09PSB2b2lkIDApIHtcbiAgICAgIHRoaXMuZGVmYXVsdFZhbHVlID0gdm9pZCAwO1xuICAgICAgcmV0dXJuIHZvaWQgMDtcbiAgICB9XG5cbiAgICBpZiAodmFsICE9IG51bGwgJiYgdmFsLmluc3RhbmNlT2ZTY2hlbWEpIHtcbiAgICAgIHRocm93IG5ldyBNb25nb29zZUVycm9yKCdDYW5ub3Qgc2V0IGRlZmF1bHQgdmFsdWUgb2YgcGF0aCBgJyArIHRoaXMucGF0aCArXG4gICAgICAgICdgIHRvIGEgbW9uZ29vc2UgU2NoZW1hIGluc3RhbmNlLicpO1xuICAgIH1cblxuICAgIHRoaXMuZGVmYXVsdFZhbHVlID0gdmFsO1xuICAgIHJldHVybiB0aGlzLmRlZmF1bHRWYWx1ZTtcbiAgfSBlbHNlIGlmIChhcmd1bWVudHMubGVuZ3RoID4gMSkge1xuICAgIHRoaXMuZGVmYXVsdFZhbHVlID0gWy4uLmFyZ3VtZW50c107XG4gIH1cbiAgcmV0dXJuIHRoaXMuZGVmYXVsdFZhbHVlO1xufTtcblxuLyoqXG4gKiBEZWNsYXJlcyB0aGUgaW5kZXggb3B0aW9ucyBmb3IgdGhpcyBzY2hlbWF0eXBlLlxuICpcbiAqICMjIyMgRXhhbXBsZTpcbiAqXG4gKiAgICAgY29uc3QgcyA9IG5ldyBTY2hlbWEoeyBuYW1lOiB7IHR5cGU6IFN0cmluZywgaW5kZXg6IHRydWUgfSlcbiAqICAgICBjb25zdCBzID0gbmV3IFNjaGVtYSh7IG5hbWU6IHsgdHlwZTogU3RyaW5nLCBpbmRleDogLTEgfSlcbiAqICAgICBjb25zdCBzID0gbmV3IFNjaGVtYSh7IGxvYzogeyB0eXBlOiBbTnVtYmVyXSwgaW5kZXg6ICdoYXNoZWQnIH0pXG4gKiAgICAgY29uc3QgcyA9IG5ldyBTY2hlbWEoeyBsb2M6IHsgdHlwZTogW051bWJlcl0sIGluZGV4OiAnMmQnLCBzcGFyc2U6IHRydWUgfSlcbiAqICAgICBjb25zdCBzID0gbmV3IFNjaGVtYSh7IGxvYzogeyB0eXBlOiBbTnVtYmVyXSwgaW5kZXg6IHsgdHlwZTogJzJkc3BoZXJlJywgc3BhcnNlOiB0cnVlIH19KVxuICogICAgIGNvbnN0IHMgPSBuZXcgU2NoZW1hKHsgZGF0ZTogeyB0eXBlOiBEYXRlLCBpbmRleDogeyB1bmlxdWU6IHRydWUsIGV4cGlyZXM6ICcxZCcgfX0pXG4gKiAgICAgcy5wYXRoKCdteS5wYXRoJykuaW5kZXgodHJ1ZSk7XG4gKiAgICAgcy5wYXRoKCdteS5kYXRlJykuaW5kZXgoeyBleHBpcmVzOiA2MCB9KTtcbiAqICAgICBzLnBhdGgoJ215LnBhdGgnKS5pbmRleCh7IHVuaXF1ZTogdHJ1ZSwgc3BhcnNlOiB0cnVlIH0pO1xuICpcbiAqICMjIyMgTm90ZTpcbiAqXG4gKiBfSW5kZXhlcyBhcmUgY3JlYXRlZCBbaW4gdGhlIGJhY2tncm91bmRdKGh0dHBzOi8vd3d3Lm1vbmdvZGIuY29tL2RvY3MvbWFudWFsL2NvcmUvaW5kZXgtY3JlYXRpb24vI2luZGV4LWNyZWF0aW9uLWJhY2tncm91bmQpXG4gKiBieSBkZWZhdWx0LiBJZiBgYmFja2dyb3VuZGAgaXMgc2V0IHRvIGBmYWxzZWAsIE1vbmdvREIgd2lsbCBub3QgZXhlY3V0ZSBhbnlcbiAqIHJlYWQvd3JpdGUgb3BlcmF0aW9ucyB5b3Ugc2VuZCB1bnRpbCB0aGUgaW5kZXggYnVpbGQuXG4gKiBTcGVjaWZ5IGBiYWNrZ3JvdW5kOiBmYWxzZWAgdG8gb3ZlcnJpZGUgTW9uZ29vc2UncyBkZWZhdWx0Ll9cbiAqXG4gKiBAcGFyYW0ge09iamVjdHxCb29sZWFufFN0cmluZ3xOdW1iZXJ9IG9wdGlvbnNcbiAqIEByZXR1cm4ge1NjaGVtYVR5cGV9IHRoaXNcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuU2NoZW1hVHlwZS5wcm90b3R5cGUuaW5kZXggPSBmdW5jdGlvbihvcHRpb25zKSB7XG4gIHRoaXMuX2luZGV4ID0gb3B0aW9ucztcbiAgdXRpbHMuZXhwaXJlcyh0aGlzLl9pbmRleCk7XG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBEZWNsYXJlcyBhbiB1bmlxdWUgaW5kZXguXG4gKlxuICogIyMjIyBFeGFtcGxlOlxuICpcbiAqICAgICBjb25zdCBzID0gbmV3IFNjaGVtYSh7IG5hbWU6IHsgdHlwZTogU3RyaW5nLCB1bmlxdWU6IHRydWUgfSB9KTtcbiAqICAgICBzLnBhdGgoJ25hbWUnKS5pbmRleCh7IHVuaXF1ZTogdHJ1ZSB9KTtcbiAqXG4gKiBfTk9URTogdmlvbGF0aW5nIHRoZSBjb25zdHJhaW50IHJldHVybnMgYW4gYEUxMTAwMGAgZXJyb3IgZnJvbSBNb25nb0RCIHdoZW4gc2F2aW5nLCBub3QgYSBNb25nb29zZSB2YWxpZGF0aW9uIGVycm9yLl9cbiAqXG4gKiBAcGFyYW0ge0Jvb2xlYW59IGJvb2xcbiAqIEByZXR1cm4ge1NjaGVtYVR5cGV9IHRoaXNcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuU2NoZW1hVHlwZS5wcm90b3R5cGUudW5pcXVlID0gZnVuY3Rpb24oYm9vbCkge1xuICBpZiAodGhpcy5faW5kZXggPT09IGZhbHNlKSB7XG4gICAgaWYgKCFib29sKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRocm93IG5ldyBFcnJvcignUGF0aCBcIicgKyB0aGlzLnBhdGggKyAnXCIgbWF5IG5vdCBoYXZlIGBpbmRleGAgc2V0IHRvICcgK1xuICAgICAgJ2ZhbHNlIGFuZCBgdW5pcXVlYCBzZXQgdG8gdHJ1ZScpO1xuICB9XG5cbiAgaWYgKCF0aGlzLm9wdGlvbnMuaGFzT3duUHJvcGVydHkoJ2luZGV4JykgJiYgYm9vbCA9PT0gZmFsc2UpIHtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIGlmICh0aGlzLl9pbmRleCA9PSBudWxsIHx8IHRoaXMuX2luZGV4ID09PSB0cnVlKSB7XG4gICAgdGhpcy5faW5kZXggPSB7fTtcbiAgfSBlbHNlIGlmICh0eXBlb2YgdGhpcy5faW5kZXggPT09ICdzdHJpbmcnKSB7XG4gICAgdGhpcy5faW5kZXggPSB7IHR5cGU6IHRoaXMuX2luZGV4IH07XG4gIH1cblxuICB0aGlzLl9pbmRleC51bmlxdWUgPSBib29sO1xuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogRGVjbGFyZXMgYSBmdWxsIHRleHQgaW5kZXguXG4gKlxuICogIyMjIEV4YW1wbGU6XG4gKlxuICogICAgICBjb25zdCBzID0gbmV3IFNjaGVtYSh7IG5hbWUgOiB7IHR5cGU6IFN0cmluZywgdGV4dCA6IHRydWUgfSB9KVxuICogICAgICBzLnBhdGgoJ25hbWUnKS5pbmRleCh7IHRleHQgOiB0cnVlIH0pO1xuICpcbiAqIEBwYXJhbSB7Qm9vbGVhbn0gYm9vbFxuICogQHJldHVybiB7U2NoZW1hVHlwZX0gdGhpc1xuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5TY2hlbWFUeXBlLnByb3RvdHlwZS50ZXh0ID0gZnVuY3Rpb24oYm9vbCkge1xuICBpZiAodGhpcy5faW5kZXggPT09IGZhbHNlKSB7XG4gICAgaWYgKCFib29sKSB7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgdGhyb3cgbmV3IEVycm9yKCdQYXRoIFwiJyArIHRoaXMucGF0aCArICdcIiBtYXkgbm90IGhhdmUgYGluZGV4YCBzZXQgdG8gJyArXG4gICAgICAnZmFsc2UgYW5kIGB0ZXh0YCBzZXQgdG8gdHJ1ZScpO1xuICB9XG5cbiAgaWYgKCF0aGlzLm9wdGlvbnMuaGFzT3duUHJvcGVydHkoJ2luZGV4JykgJiYgYm9vbCA9PT0gZmFsc2UpIHtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIGlmICh0aGlzLl9pbmRleCA9PT0gbnVsbCB8fCB0aGlzLl9pbmRleCA9PT0gdW5kZWZpbmVkIHx8XG4gICAgdHlwZW9mIHRoaXMuX2luZGV4ID09PSAnYm9vbGVhbicpIHtcbiAgICB0aGlzLl9pbmRleCA9IHt9O1xuICB9IGVsc2UgaWYgKHR5cGVvZiB0aGlzLl9pbmRleCA9PT0gJ3N0cmluZycpIHtcbiAgICB0aGlzLl9pbmRleCA9IHsgdHlwZTogdGhpcy5faW5kZXggfTtcbiAgfVxuXG4gIHRoaXMuX2luZGV4LnRleHQgPSBib29sO1xuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogRGVjbGFyZXMgYSBzcGFyc2UgaW5kZXguXG4gKlxuICogIyMjIyBFeGFtcGxlOlxuICpcbiAqICAgICBjb25zdCBzID0gbmV3IFNjaGVtYSh7IG5hbWU6IHsgdHlwZTogU3RyaW5nLCBzcGFyc2U6IHRydWUgfSB9KTtcbiAqICAgICBzLnBhdGgoJ25hbWUnKS5pbmRleCh7IHNwYXJzZTogdHJ1ZSB9KTtcbiAqXG4gKiBAcGFyYW0ge0Jvb2xlYW59IGJvb2xcbiAqIEByZXR1cm4ge1NjaGVtYVR5cGV9IHRoaXNcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuU2NoZW1hVHlwZS5wcm90b3R5cGUuc3BhcnNlID0gZnVuY3Rpb24oYm9vbCkge1xuICBpZiAodGhpcy5faW5kZXggPT09IGZhbHNlKSB7XG4gICAgaWYgKCFib29sKSB7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgdGhyb3cgbmV3IEVycm9yKCdQYXRoIFwiJyArIHRoaXMucGF0aCArICdcIiBtYXkgbm90IGhhdmUgYGluZGV4YCBzZXQgdG8gJyArXG4gICAgICAnZmFsc2UgYW5kIGBzcGFyc2VgIHNldCB0byB0cnVlJyk7XG4gIH1cblxuICBpZiAoIXRoaXMub3B0aW9ucy5oYXNPd25Qcm9wZXJ0eSgnaW5kZXgnKSAmJiBib29sID09PSBmYWxzZSkge1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgaWYgKHRoaXMuX2luZGV4ID09IG51bGwgfHwgdHlwZW9mIHRoaXMuX2luZGV4ID09PSAnYm9vbGVhbicpIHtcbiAgICB0aGlzLl9pbmRleCA9IHt9O1xuICB9IGVsc2UgaWYgKHR5cGVvZiB0aGlzLl9pbmRleCA9PT0gJ3N0cmluZycpIHtcbiAgICB0aGlzLl9pbmRleCA9IHsgdHlwZTogdGhpcy5faW5kZXggfTtcbiAgfVxuXG4gIHRoaXMuX2luZGV4LnNwYXJzZSA9IGJvb2w7XG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBEZWZpbmVzIHRoaXMgcGF0aCBhcyBpbW11dGFibGUuIE1vbmdvb3NlIHByZXZlbnRzIHlvdSBmcm9tIGNoYW5naW5nXG4gKiBpbW11dGFibGUgcGF0aHMgdW5sZXNzIHRoZSBwYXJlbnQgZG9jdW1lbnQgaGFzIFtgaXNOZXc6IHRydWVgXShodHRwczovL21vbmdvb3NlanMuY29tL2RvY3MvYXBpL2RvY3VtZW50Lmh0bWwjRG9jdW1lbnQucHJvdG90eXBlLmlzTmV3KCkpLlxuICpcbiAqICMjIyMgRXhhbXBsZTpcbiAqXG4gKiAgICAgY29uc3Qgc2NoZW1hID0gbmV3IFNjaGVtYSh7XG4gKiAgICAgICBuYW1lOiB7IHR5cGU6IFN0cmluZywgaW1tdXRhYmxlOiB0cnVlIH0sXG4gKiAgICAgICBhZ2U6IE51bWJlclxuICogICAgIH0pO1xuICogICAgIGNvbnN0IE1vZGVsID0gbW9uZ29vc2UubW9kZWwoJ1Rlc3QnLCBzY2hlbWEpO1xuICpcbiAqICAgICBhd2FpdCBNb2RlbC5jcmVhdGUoeyBuYW1lOiAndGVzdCcgfSk7XG4gKiAgICAgY29uc3QgZG9jID0gYXdhaXQgTW9kZWwuZmluZE9uZSgpO1xuICpcbiAqICAgICBkb2MuaXNOZXc7IC8vIGZhbHNlXG4gKiAgICAgZG9jLm5hbWUgPSAnbmV3IG5hbWUnO1xuICogICAgIGRvYy5uYW1lOyAvLyAndGVzdCcsIGJlY2F1c2UgYG5hbWVgIGlzIGltbXV0YWJsZVxuICpcbiAqIE1vbmdvb3NlIGFsc28gcHJldmVudHMgY2hhbmdpbmcgaW1tdXRhYmxlIHByb3BlcnRpZXMgdXNpbmcgYHVwZGF0ZU9uZSgpYFxuICogYW5kIGB1cGRhdGVNYW55KClgIGJhc2VkIG9uIFtzdHJpY3QgbW9kZV0oaHR0cHM6Ly9tb25nb29zZWpzLmNvbS9kb2NzL2d1aWRlLmh0bWwjc3RyaWN0KS5cbiAqXG4gKiAjIyMjIEV4YW1wbGU6XG4gKlxuICogICAgIC8vIE1vbmdvb3NlIHdpbGwgc3RyaXAgb3V0IHRoZSBgbmFtZWAgdXBkYXRlLCBiZWNhdXNlIGBuYW1lYCBpcyBpbW11dGFibGVcbiAqICAgICBNb2RlbC51cGRhdGVPbmUoe30sIHsgJHNldDogeyBuYW1lOiAndGVzdDInIH0sICRpbmM6IHsgYWdlOiAxIH0gfSk7XG4gKlxuICogICAgIC8vIElmIGBzdHJpY3RgIGlzIHNldCB0byAndGhyb3cnLCBNb25nb29zZSB3aWxsIHRocm93IGFuIGVycm9yIGlmIHlvdVxuICogICAgIC8vIHVwZGF0ZSBgbmFtZWBcbiAqICAgICBjb25zdCBlcnIgPSBhd2FpdCBNb2RlbC51cGRhdGVPbmUoe30sIHsgbmFtZTogJ3Rlc3QyJyB9LCB7IHN0cmljdDogJ3Rocm93JyB9KS5cbiAqICAgICAgIHRoZW4oKCkgPT4gbnVsbCwgZXJyID0+IGVycik7XG4gKiAgICAgZXJyLm5hbWU7IC8vIFN0cmljdE1vZGVFcnJvclxuICpcbiAqICAgICAvLyBJZiBgc3RyaWN0YCBpcyBgZmFsc2VgLCBNb25nb29zZSBhbGxvd3MgdXBkYXRpbmcgYG5hbWVgIGV2ZW4gdGhvdWdoXG4gKiAgICAgLy8gdGhlIHByb3BlcnR5IGlzIGltbXV0YWJsZS5cbiAqICAgICBNb2RlbC51cGRhdGVPbmUoe30sIHsgbmFtZTogJ3Rlc3QyJyB9LCB7IHN0cmljdDogZmFsc2UgfSk7XG4gKlxuICogQHBhcmFtIHtCb29sZWFufSBib29sXG4gKiBAcmV0dXJuIHtTY2hlbWFUeXBlfSB0aGlzXG4gKiBAc2VlIGlzTmV3IGh0dHBzOi8vbW9uZ29vc2Vqcy5jb20vZG9jcy9hcGkvZG9jdW1lbnQuaHRtbCNEb2N1bWVudC5wcm90b3R5cGUuaXNOZXcoKVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5TY2hlbWFUeXBlLnByb3RvdHlwZS5pbW11dGFibGUgPSBmdW5jdGlvbihib29sKSB7XG4gIHRoaXMuJGltbXV0YWJsZSA9IGJvb2w7XG4gIGhhbmRsZUltbXV0YWJsZSh0aGlzKTtcblxuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogRGVmaW5lcyBhIGN1c3RvbSBmdW5jdGlvbiBmb3IgdHJhbnNmb3JtaW5nIHRoaXMgcGF0aCB3aGVuIGNvbnZlcnRpbmcgYSBkb2N1bWVudCB0byBKU09OLlxuICpcbiAqIE1vbmdvb3NlIGNhbGxzIHRoaXMgZnVuY3Rpb24gd2l0aCBvbmUgcGFyYW1ldGVyOiB0aGUgY3VycmVudCBgdmFsdWVgIG9mIHRoZSBwYXRoLiBNb25nb29zZVxuICogdGhlbiB1c2VzIHRoZSByZXR1cm4gdmFsdWUgaW4gdGhlIEpTT04gb3V0cHV0LlxuICpcbiAqICMjIyMgRXhhbXBsZTpcbiAqXG4gKiAgICAgY29uc3Qgc2NoZW1hID0gbmV3IFNjaGVtYSh7XG4gKiAgICAgICBkYXRlOiB7IHR5cGU6IERhdGUsIHRyYW5zZm9ybTogdiA9PiB2LmdldEZ1bGxZZWFyKCkgfVxuICogICAgIH0pO1xuICogICAgIGNvbnN0IE1vZGVsID0gbW9uZ29vc2UubW9kZWwoJ1Rlc3QnLCBzY2hlbWEpO1xuICpcbiAqICAgICBhd2FpdCBNb2RlbC5jcmVhdGUoeyBkYXRlOiBuZXcgRGF0ZSgnMjAxNi0wNi0wMScpIH0pO1xuICogICAgIGNvbnN0IGRvYyA9IGF3YWl0IE1vZGVsLmZpbmRPbmUoKTtcbiAqXG4gKiAgICAgZG9jLmRhdGUgaW5zdGFuY2VvZiBEYXRlOyAvLyB0cnVlXG4gKlxuICogICAgIGRvYy50b0pTT04oKS5kYXRlOyAvLyAyMDE2IGFzIGEgbnVtYmVyXG4gKiAgICAgSlNPTi5zdHJpbmdpZnkoZG9jKTsgLy8gJ3tcIl9pZFwiOi4uLixcImRhdGVcIjoyMDE2fSdcbiAqXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmblxuICogQHJldHVybiB7U2NoZW1hVHlwZX0gdGhpc1xuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5TY2hlbWFUeXBlLnByb3RvdHlwZS50cmFuc2Zvcm0gPSBmdW5jdGlvbihmbikge1xuICB0aGlzLm9wdGlvbnMudHJhbnNmb3JtID0gZm47XG5cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIEFkZHMgYSBzZXR0ZXIgdG8gdGhpcyBzY2hlbWF0eXBlLlxuICpcbiAqICMjIyMgRXhhbXBsZTpcbiAqXG4gKiAgICAgZnVuY3Rpb24gY2FwaXRhbGl6ZSAodmFsKSB7XG4gKiAgICAgICBpZiAodHlwZW9mIHZhbCAhPT0gJ3N0cmluZycpIHZhbCA9ICcnO1xuICogICAgICAgcmV0dXJuIHZhbC5jaGFyQXQoMCkudG9VcHBlckNhc2UoKSArIHZhbC5zdWJzdHJpbmcoMSk7XG4gKiAgICAgfVxuICpcbiAqICAgICAvLyBkZWZpbmluZyB3aXRoaW4gdGhlIHNjaGVtYVxuICogICAgIGNvbnN0IHMgPSBuZXcgU2NoZW1hKHsgbmFtZTogeyB0eXBlOiBTdHJpbmcsIHNldDogY2FwaXRhbGl6ZSB9fSk7XG4gKlxuICogICAgIC8vIG9yIHdpdGggdGhlIFNjaGVtYVR5cGVcbiAqICAgICBjb25zdCBzID0gbmV3IFNjaGVtYSh7IG5hbWU6IFN0cmluZyB9KVxuICogICAgIHMucGF0aCgnbmFtZScpLnNldChjYXBpdGFsaXplKTtcbiAqXG4gKiBTZXR0ZXJzIGFsbG93IHlvdSB0byB0cmFuc2Zvcm0gdGhlIGRhdGEgYmVmb3JlIGl0IGdldHMgdG8gdGhlIHJhdyBtb25nb2RiXG4gKiBkb2N1bWVudCBvciBxdWVyeS5cbiAqXG4gKiBTdXBwb3NlIHlvdSBhcmUgaW1wbGVtZW50aW5nIHVzZXIgcmVnaXN0cmF0aW9uIGZvciBhIHdlYnNpdGUuIFVzZXJzIHByb3ZpZGVcbiAqIGFuIGVtYWlsIGFuZCBwYXNzd29yZCwgd2hpY2ggZ2V0cyBzYXZlZCB0byBtb25nb2RiLiBUaGUgZW1haWwgaXMgYSBzdHJpbmdcbiAqIHRoYXQgeW91IHdpbGwgd2FudCB0byBub3JtYWxpemUgdG8gbG93ZXIgY2FzZSwgaW4gb3JkZXIgdG8gYXZvaWQgb25lIGVtYWlsXG4gKiBoYXZpbmcgbW9yZSB0aGFuIG9uZSBhY2NvdW50IC0tIGUuZy4sIG90aGVyd2lzZSwgYXZlbnVlQHEuY29tIGNhbiBiZSByZWdpc3RlcmVkIGZvciAyIGFjY291bnRzIHZpYSBhdmVudWVAcS5jb20gYW5kIEF2RW5VZUBRLkNvTS5cbiAqXG4gKiBZb3UgY2FuIHNldCB1cCBlbWFpbCBsb3dlciBjYXNlIG5vcm1hbGl6YXRpb24gZWFzaWx5IHZpYSBhIE1vbmdvb3NlIHNldHRlci5cbiAqXG4gKiAgICAgZnVuY3Rpb24gdG9Mb3dlcih2KSB7XG4gKiAgICAgICByZXR1cm4gdi50b0xvd2VyQ2FzZSgpO1xuICogICAgIH1cbiAqXG4gKiAgICAgY29uc3QgVXNlclNjaGVtYSA9IG5ldyBTY2hlbWEoe1xuICogICAgICAgZW1haWw6IHsgdHlwZTogU3RyaW5nLCBzZXQ6IHRvTG93ZXIgfVxuICogICAgIH0pO1xuICpcbiAqICAgICBjb25zdCBVc2VyID0gZGIubW9kZWwoJ1VzZXInLCBVc2VyU2NoZW1hKTtcbiAqXG4gKiAgICAgY29uc3QgdXNlciA9IG5ldyBVc2VyKHtlbWFpbDogJ0FWRU5VRUBRLkNPTSd9KTtcbiAqICAgICBjb25zb2xlLmxvZyh1c2VyLmVtYWlsKTsgLy8gJ2F2ZW51ZUBxLmNvbSdcbiAqXG4gKiAgICAgLy8gb3JcbiAqICAgICBjb25zdCB1c2VyID0gbmV3IFVzZXIoKTtcbiAqICAgICB1c2VyLmVtYWlsID0gJ0F2ZW51ZUBRLmNvbSc7XG4gKiAgICAgY29uc29sZS5sb2codXNlci5lbWFpbCk7IC8vICdhdmVudWVAcS5jb20nXG4gKiAgICAgVXNlci51cGRhdGVPbmUoeyBfaWQ6IF9pZCB9LCB7ICRzZXQ6IHsgZW1haWw6ICdBVkVOVUVAUS5DT00nIH0gfSk7IC8vIHVwZGF0ZSB0byAnYXZlbnVlQHEuY29tJ1xuICpcbiAqIEFzIHlvdSBjYW4gc2VlIGFib3ZlLCBzZXR0ZXJzIGFsbG93IHlvdSB0byB0cmFuc2Zvcm0gdGhlIGRhdGEgYmVmb3JlIGl0XG4gKiBzdG9yZWQgaW4gTW9uZ29EQiwgb3IgYmVmb3JlIGV4ZWN1dGluZyBhIHF1ZXJ5LlxuICpcbiAqIF9OT1RFOiB3ZSBjb3VsZCBoYXZlIGFsc28ganVzdCB1c2VkIHRoZSBidWlsdC1pbiBgbG93ZXJjYXNlOiB0cnVlYCBTY2hlbWFUeXBlIG9wdGlvbiBpbnN0ZWFkIG9mIGRlZmluaW5nIG91ciBvd24gZnVuY3Rpb24uX1xuICpcbiAqICAgICBuZXcgU2NoZW1hKHsgZW1haWw6IHsgdHlwZTogU3RyaW5nLCBsb3dlcmNhc2U6IHRydWUgfX0pXG4gKlxuICogU2V0dGVycyBhcmUgYWxzbyBwYXNzZWQgYSBzZWNvbmQgYXJndW1lbnQsIHRoZSBzY2hlbWF0eXBlIG9uIHdoaWNoIHRoZSBzZXR0ZXIgd2FzIGRlZmluZWQuIFRoaXMgYWxsb3dzIGZvciB0YWlsb3JlZCBiZWhhdmlvciBiYXNlZCBvbiBvcHRpb25zIHBhc3NlZCBpbiB0aGUgc2NoZW1hLlxuICpcbiAqICAgICBmdW5jdGlvbiBpbnNwZWN0b3IgKHZhbCwgcHJpb3JWYWx1ZSwgc2NoZW1hdHlwZSkge1xuICogICAgICAgaWYgKHNjaGVtYXR5cGUub3B0aW9ucy5yZXF1aXJlZCkge1xuICogICAgICAgICByZXR1cm4gc2NoZW1hdHlwZS5wYXRoICsgJyBpcyByZXF1aXJlZCc7XG4gKiAgICAgICB9IGVsc2Uge1xuICogICAgICAgICByZXR1cm4gdmFsO1xuICogICAgICAgfVxuICogICAgIH1cbiAqXG4gKiAgICAgY29uc3QgVmlydXNTY2hlbWEgPSBuZXcgU2NoZW1hKHtcbiAqICAgICAgIG5hbWU6IHsgdHlwZTogU3RyaW5nLCByZXF1aXJlZDogdHJ1ZSwgc2V0OiBpbnNwZWN0b3IgfSxcbiAqICAgICAgIHRheG9ub215OiB7IHR5cGU6IFN0cmluZywgc2V0OiBpbnNwZWN0b3IgfVxuICogICAgIH0pXG4gKlxuICogICAgIGNvbnN0IFZpcnVzID0gZGIubW9kZWwoJ1ZpcnVzJywgVmlydXNTY2hlbWEpO1xuICogICAgIGNvbnN0IHYgPSBuZXcgVmlydXMoeyBuYW1lOiAnUGFydm92aXJpZGFlJywgdGF4b25vbXk6ICdQYXJ2b3ZpcmluYWUnIH0pO1xuICpcbiAqICAgICBjb25zb2xlLmxvZyh2Lm5hbWUpOyAgICAgLy8gbmFtZSBpcyByZXF1aXJlZFxuICogICAgIGNvbnNvbGUubG9nKHYudGF4b25vbXkpOyAvLyBQYXJ2b3ZpcmluYWVcbiAqXG4gKiBZb3UgY2FuIGFsc28gdXNlIHNldHRlcnMgdG8gbW9kaWZ5IG90aGVyIHByb3BlcnRpZXMgb24gdGhlIGRvY3VtZW50LiBJZlxuICogeW91J3JlIHNldHRpbmcgYSBwcm9wZXJ0eSBgbmFtZWAgb24gYSBkb2N1bWVudCwgdGhlIHNldHRlciB3aWxsIHJ1biB3aXRoXG4gKiBgdGhpc2AgYXMgdGhlIGRvY3VtZW50LiBCZSBjYXJlZnVsLCBpbiBtb25nb29zZSA1IHNldHRlcnMgd2lsbCBhbHNvIHJ1blxuICogd2hlbiBxdWVyeWluZyBieSBgbmFtZWAgd2l0aCBgdGhpc2AgYXMgdGhlIHF1ZXJ5LlxuICpcbiAqICAgICBjb25zdCBuYW1lU2NoZW1hID0gbmV3IFNjaGVtYSh7IG5hbWU6IFN0cmluZywga2V5d29yZHM6IFtTdHJpbmddIH0pO1xuICogICAgIG5hbWVTY2hlbWEucGF0aCgnbmFtZScpLnNldChmdW5jdGlvbih2KSB7XG4gKiAgICAgICAvLyBOZWVkIHRvIGNoZWNrIGlmIGB0aGlzYCBpcyBhIGRvY3VtZW50LCBiZWNhdXNlIGluIG1vbmdvb3NlIDVcbiAqICAgICAgIC8vIHNldHRlcnMgd2lsbCBhbHNvIHJ1biBvbiBxdWVyaWVzLCBpbiB3aGljaCBjYXNlIGB0aGlzYCB3aWxsIGJlIGFcbiAqICAgICAgIC8vIG1vbmdvb3NlIHF1ZXJ5IG9iamVjdC5cbiAqICAgICAgIGlmICh0aGlzIGluc3RhbmNlb2YgRG9jdW1lbnQgJiYgdiAhPSBudWxsKSB7XG4gKiAgICAgICAgIHRoaXMua2V5d29yZHMgPSB2LnNwbGl0KCcgJyk7XG4gKiAgICAgICB9XG4gKiAgICAgICByZXR1cm4gdjtcbiAqICAgICB9KTtcbiAqXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmblxuICogQHJldHVybiB7U2NoZW1hVHlwZX0gdGhpc1xuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5TY2hlbWFUeXBlLnByb3RvdHlwZS5zZXQgPSBmdW5jdGlvbihmbikge1xuICBpZiAodHlwZW9mIGZuICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignQSBzZXR0ZXIgbXVzdCBiZSBhIGZ1bmN0aW9uLicpO1xuICB9XG4gIHRoaXMuc2V0dGVycy5wdXNoKGZuKTtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIEFkZHMgYSBnZXR0ZXIgdG8gdGhpcyBzY2hlbWF0eXBlLlxuICpcbiAqICMjIyMgRXhhbXBsZTpcbiAqXG4gKiAgICAgZnVuY3Rpb24gZG9iICh2YWwpIHtcbiAqICAgICAgIGlmICghdmFsKSByZXR1cm4gdmFsO1xuICogICAgICAgcmV0dXJuICh2YWwuZ2V0TW9udGgoKSArIDEpICsgXCIvXCIgKyB2YWwuZ2V0RGF0ZSgpICsgXCIvXCIgKyB2YWwuZ2V0RnVsbFllYXIoKTtcbiAqICAgICB9XG4gKlxuICogICAgIC8vIGRlZmluaW5nIHdpdGhpbiB0aGUgc2NoZW1hXG4gKiAgICAgY29uc3QgcyA9IG5ldyBTY2hlbWEoeyBib3JuOiB7IHR5cGU6IERhdGUsIGdldDogZG9iIH0pXG4gKlxuICogICAgIC8vIG9yIGJ5IHJldHJlaXZpbmcgaXRzIFNjaGVtYVR5cGVcbiAqICAgICBjb25zdCBzID0gbmV3IFNjaGVtYSh7IGJvcm46IERhdGUgfSlcbiAqICAgICBzLnBhdGgoJ2Jvcm4nKS5nZXQoZG9iKVxuICpcbiAqIEdldHRlcnMgYWxsb3cgeW91IHRvIHRyYW5zZm9ybSB0aGUgcmVwcmVzZW50YXRpb24gb2YgdGhlIGRhdGEgYXMgaXQgdHJhdmVscyBmcm9tIHRoZSByYXcgbW9uZ29kYiBkb2N1bWVudCB0byB0aGUgdmFsdWUgdGhhdCB5b3Ugc2VlLlxuICpcbiAqIFN1cHBvc2UgeW91IGFyZSBzdG9yaW5nIGNyZWRpdCBjYXJkIG51bWJlcnMgYW5kIHlvdSB3YW50IHRvIGhpZGUgZXZlcnl0aGluZyBleGNlcHQgdGhlIGxhc3QgNCBkaWdpdHMgdG8gdGhlIG1vbmdvb3NlIHVzZXIuIFlvdSBjYW4gZG8gc28gYnkgZGVmaW5pbmcgYSBnZXR0ZXIgaW4gdGhlIGZvbGxvd2luZyB3YXk6XG4gKlxuICogICAgIGZ1bmN0aW9uIG9iZnVzY2F0ZSAoY2MpIHtcbiAqICAgICAgIHJldHVybiAnKioqKi0qKioqLSoqKiotJyArIGNjLnNsaWNlKGNjLmxlbmd0aC00LCBjYy5sZW5ndGgpO1xuICogICAgIH1cbiAqXG4gKiAgICAgY29uc3QgQWNjb3VudFNjaGVtYSA9IG5ldyBTY2hlbWEoe1xuICogICAgICAgY3JlZGl0Q2FyZE51bWJlcjogeyB0eXBlOiBTdHJpbmcsIGdldDogb2JmdXNjYXRlIH1cbiAqICAgICB9KTtcbiAqXG4gKiAgICAgY29uc3QgQWNjb3VudCA9IGRiLm1vZGVsKCdBY2NvdW50JywgQWNjb3VudFNjaGVtYSk7XG4gKlxuICogICAgIEFjY291bnQuZmluZEJ5SWQoaWQsIGZ1bmN0aW9uIChlcnIsIGZvdW5kKSB7XG4gKiAgICAgICBjb25zb2xlLmxvZyhmb3VuZC5jcmVkaXRDYXJkTnVtYmVyKTsgLy8gJyoqKiotKioqKi0qKioqLTEyMzQnXG4gKiAgICAgfSk7XG4gKlxuICogR2V0dGVycyBhcmUgYWxzbyBwYXNzZWQgYSBzZWNvbmQgYXJndW1lbnQsIHRoZSBzY2hlbWF0eXBlIG9uIHdoaWNoIHRoZSBnZXR0ZXIgd2FzIGRlZmluZWQuIFRoaXMgYWxsb3dzIGZvciB0YWlsb3JlZCBiZWhhdmlvciBiYXNlZCBvbiBvcHRpb25zIHBhc3NlZCBpbiB0aGUgc2NoZW1hLlxuICpcbiAqICAgICBmdW5jdGlvbiBpbnNwZWN0b3IgKHZhbCwgcHJpb3JWYWx1ZSwgc2NoZW1hdHlwZSkge1xuICogICAgICAgaWYgKHNjaGVtYXR5cGUub3B0aW9ucy5yZXF1aXJlZCkge1xuICogICAgICAgICByZXR1cm4gc2NoZW1hdHlwZS5wYXRoICsgJyBpcyByZXF1aXJlZCc7XG4gKiAgICAgICB9IGVsc2Uge1xuICogICAgICAgICByZXR1cm4gc2NoZW1hdHlwZS5wYXRoICsgJyBpcyBub3QnO1xuICogICAgICAgfVxuICogICAgIH1cbiAqXG4gKiAgICAgY29uc3QgVmlydXNTY2hlbWEgPSBuZXcgU2NoZW1hKHtcbiAqICAgICAgIG5hbWU6IHsgdHlwZTogU3RyaW5nLCByZXF1aXJlZDogdHJ1ZSwgZ2V0OiBpbnNwZWN0b3IgfSxcbiAqICAgICAgIHRheG9ub215OiB7IHR5cGU6IFN0cmluZywgZ2V0OiBpbnNwZWN0b3IgfVxuICogICAgIH0pXG4gKlxuICogICAgIGNvbnN0IFZpcnVzID0gZGIubW9kZWwoJ1ZpcnVzJywgVmlydXNTY2hlbWEpO1xuICpcbiAqICAgICBWaXJ1cy5maW5kQnlJZChpZCwgZnVuY3Rpb24gKGVyciwgdmlydXMpIHtcbiAqICAgICAgIGNvbnNvbGUubG9nKHZpcnVzLm5hbWUpOyAgICAgLy8gbmFtZSBpcyByZXF1aXJlZFxuICogICAgICAgY29uc29sZS5sb2codmlydXMudGF4b25vbXkpOyAvLyB0YXhvbm9teSBpcyBub3RcbiAqICAgICB9KVxuICpcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuXG4gKiBAcmV0dXJuIHtTY2hlbWFUeXBlfSB0aGlzXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cblNjaGVtYVR5cGUucHJvdG90eXBlLmdldCA9IGZ1bmN0aW9uKGZuKSB7XG4gIGlmICh0eXBlb2YgZm4gIT09ICdmdW5jdGlvbicpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdBIGdldHRlciBtdXN0IGJlIGEgZnVuY3Rpb24uJyk7XG4gIH1cbiAgdGhpcy5nZXR0ZXJzLnB1c2goZm4pO1xuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogQWRkcyB2YWxpZGF0b3IocykgZm9yIHRoaXMgZG9jdW1lbnQgcGF0aC5cbiAqXG4gKiBWYWxpZGF0b3JzIGFsd2F5cyByZWNlaXZlIHRoZSB2YWx1ZSB0byB2YWxpZGF0ZSBhcyB0aGVpciBmaXJzdCBhcmd1bWVudCBhbmRcbiAqIG11c3QgcmV0dXJuIGBCb29sZWFuYC4gUmV0dXJuaW5nIGBmYWxzZWAgb3IgdGhyb3dpbmcgYW4gZXJyb3IgbWVhbnNcbiAqIHZhbGlkYXRpb24gZmFpbGVkLlxuICpcbiAqIFRoZSBlcnJvciBtZXNzYWdlIGFyZ3VtZW50IGlzIG9wdGlvbmFsLiBJZiBub3QgcGFzc2VkLCB0aGUgW2RlZmF1bHQgZ2VuZXJpYyBlcnJvciBtZXNzYWdlIHRlbXBsYXRlXShodHRwczovL21vbmdvb3NlanMuY29tL2RvY3MvYXBpL2Vycm9yLmh0bWwjRXJyb3IubWVzc2FnZXMpIHdpbGwgYmUgdXNlZC5cbiAqXG4gKiAjIyMjIEV4YW1wbGU6XG4gKlxuICogICAgIC8vIG1ha2Ugc3VyZSBldmVyeSB2YWx1ZSBpcyBlcXVhbCB0byBcInNvbWV0aGluZ1wiXG4gKiAgICAgZnVuY3Rpb24gdmFsaWRhdG9yICh2YWwpIHtcbiAqICAgICAgIHJldHVybiB2YWwgPT09ICdzb21ldGhpbmcnO1xuICogICAgIH1cbiAqICAgICBuZXcgU2NoZW1hKHsgbmFtZTogeyB0eXBlOiBTdHJpbmcsIHZhbGlkYXRlOiB2YWxpZGF0b3IgfX0pO1xuICpcbiAqICAgICAvLyB3aXRoIGEgY3VzdG9tIGVycm9yIG1lc3NhZ2VcbiAqXG4gKiAgICAgY29uc3QgY3VzdG9tID0gW3ZhbGlkYXRvciwgJ1VoIG9oLCB7UEFUSH0gZG9lcyBub3QgZXF1YWwgXCJzb21ldGhpbmdcIi4nXVxuICogICAgIG5ldyBTY2hlbWEoeyBuYW1lOiB7IHR5cGU6IFN0cmluZywgdmFsaWRhdGU6IGN1c3RvbSB9fSk7XG4gKlxuICogICAgIC8vIGFkZGluZyBtYW55IHZhbGlkYXRvcnMgYXQgYSB0aW1lXG4gKlxuICogICAgIGNvbnN0IG1hbnkgPSBbXG4gKiAgICAgICAgIHsgdmFsaWRhdG9yOiB2YWxpZGF0b3IsIG1lc3NhZ2U6ICd1aCBvaCcgfVxuICogICAgICAgLCB7IHZhbGlkYXRvcjogYW5vdGhlclZhbGlkYXRvciwgbWVzc2FnZTogJ2ZhaWxlZCcgfVxuICogICAgIF1cbiAqICAgICBuZXcgU2NoZW1hKHsgbmFtZTogeyB0eXBlOiBTdHJpbmcsIHZhbGlkYXRlOiBtYW55IH19KTtcbiAqXG4gKiAgICAgLy8gb3IgdXRpbGl6aW5nIFNjaGVtYVR5cGUgbWV0aG9kcyBkaXJlY3RseTpcbiAqXG4gKiAgICAgY29uc3Qgc2NoZW1hID0gbmV3IFNjaGVtYSh7IG5hbWU6ICdzdHJpbmcnIH0pO1xuICogICAgIHNjaGVtYS5wYXRoKCduYW1lJykudmFsaWRhdGUodmFsaWRhdG9yLCAndmFsaWRhdGlvbiBvZiBge1BBVEh9YCBmYWlsZWQgd2l0aCB2YWx1ZSBge1ZBTFVFfWAnKTtcbiAqXG4gKiAjIyMjIEVycm9yIG1lc3NhZ2UgdGVtcGxhdGVzOlxuICpcbiAqIEJlbG93IGlzIGEgbGlzdCBvZiBzdXBwb3J0ZWQgdGVtcGxhdGUga2V5d29yZHM6XG4gKlxuICogLSBQQVRIOiBUaGUgc2NoZW1hIHBhdGggd2hlcmUgdGhlIGVycm9yIGlzIGJlaW5nIHRyaWdnZXJlZC5cbiAqIC0gVkFMVUU6IFRoZSB2YWx1ZSBhc3NpZ25lZCB0byB0aGUgUEFUSCB0aGF0IGlzIHRyaWdnZXJpbmcgdGhlIGVycm9yLlxuICogLSBLSU5EOiBUaGUgdmFsaWRhdGlvbiBwcm9wZXJ0eSB0aGF0IHRyaWdnZXJlZCB0aGUgZXJyb3IgaS5lLiByZXF1aXJlZC5cbiAqIC0gUkVBU09OOiBUaGUgZXJyb3Igb2JqZWN0IHRoYXQgY2F1c2VkIHRoaXMgZXJyb3IgaWYgdGhlcmUgd2FzIG9uZS5cbiAqXG4gKiBJZiBNb25nb29zZSdzIGJ1aWx0LWluIGVycm9yIG1lc3NhZ2UgdGVtcGxhdGluZyBpc24ndCBlbm91Z2gsIE1vbmdvb3NlXG4gKiBzdXBwb3J0cyBzZXR0aW5nIHRoZSBgbWVzc2FnZWAgcHJvcGVydHkgdG8gYSBmdW5jdGlvbi5cbiAqXG4gKiAgICAgc2NoZW1hLnBhdGgoJ25hbWUnKS52YWxpZGF0ZSh7XG4gKiAgICAgICB2YWxpZGF0b3I6IGZ1bmN0aW9uKHYpIHsgcmV0dXJuIHYubGVuZ3RoID4gNTsgfSxcbiAqICAgICAgIC8vIGBlcnJvcnNbJ25hbWUnXWAgd2lsbCBiZSBcIm5hbWUgbXVzdCBoYXZlIGxlbmd0aCA1LCBnb3QgJ2ZvbydcIlxuICogICAgICAgbWVzc2FnZTogZnVuY3Rpb24ocHJvcHMpIHtcbiAqICAgICAgICAgcmV0dXJuIGAke3Byb3BzLnBhdGh9IG11c3QgaGF2ZSBsZW5ndGggNSwgZ290ICcke3Byb3BzLnZhbHVlfSdgO1xuICogICAgICAgfVxuICogICAgIH0pO1xuICpcbiAqIFRvIGJ5cGFzcyBNb25nb29zZSdzIGVycm9yIG1lc3NhZ2VzIGFuZCBqdXN0IGNvcHkgdGhlIGVycm9yIG1lc3NhZ2UgdGhhdFxuICogdGhlIHZhbGlkYXRvciB0aHJvd3MsIGRvIHRoaXM6XG4gKlxuICogICAgIHNjaGVtYS5wYXRoKCduYW1lJykudmFsaWRhdGUoe1xuICogICAgICAgdmFsaWRhdG9yOiBmdW5jdGlvbigpIHsgdGhyb3cgbmV3IEVycm9yKCdPb3BzIScpOyB9LFxuICogICAgICAgLy8gYGVycm9yc1snbmFtZSddYCB3aWxsIGJlIFwiT29wcyFcIlxuICogICAgICAgbWVzc2FnZTogZnVuY3Rpb24ocHJvcHMpIHsgcmV0dXJuIHByb3BzLnJlYXNvbi5tZXNzYWdlOyB9XG4gKiAgICAgfSk7XG4gKlxuICogIyMjIyBBc3luY2hyb25vdXMgdmFsaWRhdGlvbjpcbiAqXG4gKiBNb25nb29zZSBzdXBwb3J0cyB2YWxpZGF0b3JzIHRoYXQgcmV0dXJuIGEgcHJvbWlzZS4gQSB2YWxpZGF0b3IgdGhhdCByZXR1cm5zXG4gKiBhIHByb21pc2UgaXMgY2FsbGVkIGFuIF9hc3luYyB2YWxpZGF0b3JfLiBBc3luYyB2YWxpZGF0b3JzIHJ1biBpblxuICogcGFyYWxsZWwsIGFuZCBgdmFsaWRhdGUoKWAgd2lsbCB3YWl0IHVudGlsIGFsbCBhc3luYyB2YWxpZGF0b3JzIGhhdmUgc2V0dGxlZC5cbiAqXG4gKiAgICAgc2NoZW1hLnBhdGgoJ25hbWUnKS52YWxpZGF0ZSh7XG4gKiAgICAgICB2YWxpZGF0b3I6IGZ1bmN0aW9uICh2YWx1ZSkge1xuICogICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICogICAgICAgICAgIHJlc29sdmUoZmFsc2UpOyAvLyB2YWxpZGF0aW9uIGZhaWxlZFxuICogICAgICAgICB9KTtcbiAqICAgICAgIH1cbiAqICAgICB9KTtcbiAqXG4gKiBZb3UgbWlnaHQgdXNlIGFzeW5jaHJvbm91cyB2YWxpZGF0b3JzIHRvIHJldHJlaXZlIG90aGVyIGRvY3VtZW50cyBmcm9tIHRoZSBkYXRhYmFzZSB0byB2YWxpZGF0ZSBhZ2FpbnN0IG9yIHRvIG1lZXQgb3RoZXIgSS9PIGJvdW5kIHZhbGlkYXRpb24gbmVlZHMuXG4gKlxuICogVmFsaWRhdGlvbiBvY2N1cnMgYHByZSgnc2F2ZScpYCBvciB3aGVuZXZlciB5b3UgbWFudWFsbHkgZXhlY3V0ZSBbZG9jdW1lbnQjdmFsaWRhdGVdKGh0dHBzOi8vbW9uZ29vc2Vqcy5jb20vZG9jcy9hcGkvZG9jdW1lbnQuaHRtbCNEb2N1bWVudC5wcm90b3R5cGUudmFsaWRhdGUoKSkuXG4gKlxuICogSWYgdmFsaWRhdGlvbiBmYWlscyBkdXJpbmcgYHByZSgnc2F2ZScpYCBhbmQgbm8gY2FsbGJhY2sgd2FzIHBhc3NlZCB0byByZWNlaXZlIHRoZSBlcnJvciwgYW4gYGVycm9yYCBldmVudCB3aWxsIGJlIGVtaXR0ZWQgb24geW91ciBNb2RlbHMgYXNzb2NpYXRlZCBkYiBbY29ubmVjdGlvbl0oaHR0cHM6Ly9tb25nb29zZWpzLmNvbS9kb2NzL2FwaS9jb25uZWN0aW9uLmh0bWwjQ29ubmVjdGlvbigpKSwgcGFzc2luZyB0aGUgdmFsaWRhdGlvbiBlcnJvciBvYmplY3QgYWxvbmcuXG4gKlxuICogICAgIGNvbnN0IGNvbm4gPSBtb25nb29zZS5jcmVhdGVDb25uZWN0aW9uKC4uKTtcbiAqICAgICBjb25uLm9uKCdlcnJvcicsIGhhbmRsZUVycm9yKTtcbiAqXG4gKiAgICAgY29uc3QgUHJvZHVjdCA9IGNvbm4ubW9kZWwoJ1Byb2R1Y3QnLCB5b3VyU2NoZW1hKTtcbiAqICAgICBjb25zdCBkdmQgPSBuZXcgUHJvZHVjdCguLik7XG4gKiAgICAgZHZkLnNhdmUoKTsgLy8gZW1pdHMgZXJyb3Igb24gdGhlIGBjb25uYCBhYm92ZVxuICpcbiAqIElmIHlvdSB3YW50IHRvIGhhbmRsZSB0aGVzZSBlcnJvcnMgYXQgdGhlIE1vZGVsIGxldmVsLCBhZGQgYW4gYGVycm9yYFxuICogbGlzdGVuZXIgdG8geW91ciBNb2RlbCBhcyBzaG93biBiZWxvdy5cbiAqXG4gKiAgICAgLy8gcmVnaXN0ZXJpbmcgYW4gZXJyb3IgbGlzdGVuZXIgb24gdGhlIE1vZGVsIGxldHMgdXMgaGFuZGxlIGVycm9ycyBtb3JlIGxvY2FsbHlcbiAqICAgICBQcm9kdWN0Lm9uKCdlcnJvcicsIGhhbmRsZUVycm9yKTtcbiAqXG4gKiBAcGFyYW0ge1JlZ0V4cHxGdW5jdGlvbnxPYmplY3R9IG9iaiB2YWxpZGF0b3IgZnVuY3Rpb24sIG9yIGhhc2ggZGVzY3JpYmluZyBvcHRpb25zXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbb2JqLnZhbGlkYXRvcl0gdmFsaWRhdG9yIGZ1bmN0aW9uLiBJZiB0aGUgdmFsaWRhdG9yIGZ1bmN0aW9uIHJldHVybnMgYHVuZGVmaW5lZGAgb3IgYSB0cnV0aHkgdmFsdWUsIHZhbGlkYXRpb24gc3VjY2VlZHMuIElmIGl0IHJldHVybnMgW2ZhbHN5XShodHRwczovL21hc3RlcmluZ2pzLmlvL3R1dG9yaWFscy9mdW5kYW1lbnRhbHMvZmFsc3kpIChleGNlcHQgYHVuZGVmaW5lZGApIG9yIHRocm93cyBhbiBlcnJvciwgdmFsaWRhdGlvbiBmYWlscy5cbiAqIEBwYXJhbSB7U3RyaW5nfEZ1bmN0aW9ufSBbb2JqLm1lc3NhZ2VdIG9wdGlvbmFsIGVycm9yIG1lc3NhZ2UuIElmIGZ1bmN0aW9uLCBzaG91bGQgcmV0dXJuIHRoZSBlcnJvciBtZXNzYWdlIGFzIGEgc3RyaW5nXG4gKiBAcGFyYW0ge0Jvb2xlYW59IFtvYmoucHJvcHNQYXJhbWV0ZXI9ZmFsc2VdIElmIHRydWUsIE1vbmdvb3NlIHdpbGwgcGFzcyB0aGUgdmFsaWRhdG9yIHByb3BlcnRpZXMgb2JqZWN0ICh3aXRoIHRoZSBgdmFsaWRhdG9yYCBmdW5jdGlvbiwgYG1lc3NhZ2VgLCBldGMuKSBhcyB0aGUgMm5kIGFyZyB0byB0aGUgdmFsaWRhdG9yIGZ1bmN0aW9uLiBUaGlzIGlzIGRpc2FibGVkIGJ5IGRlZmF1bHQgYmVjYXVzZSBtYW55IHZhbGlkYXRvcnMgW3JlbHkgb24gcG9zaXRpb25hbCBhcmdzXShodHRwczovL2dpdGh1Yi5jb20vY2hyaXNvL3ZhbGlkYXRvci5qcyN2YWxpZGF0b3JzKSwgc28gdHVybmluZyB0aGlzIG9uIG1heSBjYXVzZSB1bnByZWRpY3RhYmxlIGJlaGF2aW9yIGluIGV4dGVybmFsIHZhbGlkYXRvcnMuXG4gKiBAcGFyYW0ge1N0cmluZ3xGdW5jdGlvbn0gW2Vycm9yTXNnXSBvcHRpb25hbCBlcnJvciBtZXNzYWdlLiBJZiBmdW5jdGlvbiwgc2hvdWxkIHJldHVybiB0aGUgZXJyb3IgbWVzc2FnZSBhcyBhIHN0cmluZ1xuICogQHBhcmFtIHtTdHJpbmd9IFt0eXBlXSBvcHRpb25hbCB2YWxpZGF0b3IgdHlwZVxuICogQHJldHVybiB7U2NoZW1hVHlwZX0gdGhpc1xuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5TY2hlbWFUeXBlLnByb3RvdHlwZS52YWxpZGF0ZSA9IGZ1bmN0aW9uKG9iaiwgbWVzc2FnZSwgdHlwZSkge1xuICBpZiAodHlwZW9mIG9iaiA9PT0gJ2Z1bmN0aW9uJyB8fCBvYmogJiYgdXRpbHMuZ2V0RnVuY3Rpb25OYW1lKG9iai5jb25zdHJ1Y3RvcikgPT09ICdSZWdFeHAnKSB7XG4gICAgbGV0IHByb3BlcnRpZXM7XG4gICAgaWYgKHR5cGVvZiBtZXNzYWdlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBwcm9wZXJ0aWVzID0geyB2YWxpZGF0b3I6IG9iaiwgbWVzc2FnZTogbWVzc2FnZSB9O1xuICAgICAgcHJvcGVydGllcy50eXBlID0gdHlwZSB8fCAndXNlciBkZWZpbmVkJztcbiAgICB9IGVsc2UgaWYgKG1lc3NhZ2UgaW5zdGFuY2VvZiBPYmplY3QgJiYgIXR5cGUpIHtcbiAgICAgIHByb3BlcnRpZXMgPSBpc1NpbXBsZVZhbGlkYXRvcihtZXNzYWdlKSA/IE9iamVjdC5hc3NpZ24oe30sIG1lc3NhZ2UpIDogY2xvbmUobWVzc2FnZSk7XG4gICAgICBpZiAoIXByb3BlcnRpZXMubWVzc2FnZSkge1xuICAgICAgICBwcm9wZXJ0aWVzLm1lc3NhZ2UgPSBwcm9wZXJ0aWVzLm1zZztcbiAgICAgIH1cbiAgICAgIHByb3BlcnRpZXMudmFsaWRhdG9yID0gb2JqO1xuICAgICAgcHJvcGVydGllcy50eXBlID0gcHJvcGVydGllcy50eXBlIHx8ICd1c2VyIGRlZmluZWQnO1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAobWVzc2FnZSA9PSBudWxsKSB7XG4gICAgICAgIG1lc3NhZ2UgPSBNb25nb29zZUVycm9yLm1lc3NhZ2VzLmdlbmVyYWwuZGVmYXVsdDtcbiAgICAgIH1cbiAgICAgIGlmICghdHlwZSkge1xuICAgICAgICB0eXBlID0gJ3VzZXIgZGVmaW5lZCc7XG4gICAgICB9XG4gICAgICBwcm9wZXJ0aWVzID0geyBtZXNzYWdlOiBtZXNzYWdlLCB0eXBlOiB0eXBlLCB2YWxpZGF0b3I6IG9iaiB9O1xuICAgIH1cblxuICAgIHRoaXMudmFsaWRhdG9ycy5wdXNoKHByb3BlcnRpZXMpO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgbGV0IGk7XG4gIGxldCBsZW5ndGg7XG4gIGxldCBhcmc7XG5cbiAgZm9yIChpID0gMCwgbGVuZ3RoID0gYXJndW1lbnRzLmxlbmd0aDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgYXJnID0gYXJndW1lbnRzW2ldO1xuICAgIGlmICghdXRpbHMuaXNQT0pPKGFyZykpIHtcbiAgICAgIGNvbnN0IG1zZyA9ICdJbnZhbGlkIHZhbGlkYXRvci4gUmVjZWl2ZWQgKCcgKyB0eXBlb2YgYXJnICsgJykgJ1xuICAgICAgICArIGFyZ1xuICAgICAgICArICcuIFNlZSBodHRwczovL21vbmdvb3NlanMuY29tL2RvY3MvYXBpL3NjaGVtYXR5cGUuaHRtbCNTY2hlbWFUeXBlLnByb3RvdHlwZS52YWxpZGF0ZSgpJztcblxuICAgICAgdGhyb3cgbmV3IEVycm9yKG1zZyk7XG4gICAgfVxuICAgIHRoaXMudmFsaWRhdGUoYXJnLnZhbGlkYXRvciwgYXJnKTtcbiAgfVxuXG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBBZGRzIGEgcmVxdWlyZWQgdmFsaWRhdG9yIHRvIHRoaXMgU2NoZW1hVHlwZS4gVGhlIHZhbGlkYXRvciBnZXRzIGFkZGVkXG4gKiB0byB0aGUgZnJvbnQgb2YgdGhpcyBTY2hlbWFUeXBlJ3MgdmFsaWRhdG9ycyBhcnJheSB1c2luZyBgdW5zaGlmdCgpYC5cbiAqXG4gKiAjIyMjIEV4YW1wbGU6XG4gKlxuICogICAgIGNvbnN0IHMgPSBuZXcgU2NoZW1hKHsgYm9ybjogeyB0eXBlOiBEYXRlLCByZXF1aXJlZDogdHJ1ZSB9KVxuICpcbiAqICAgICAvLyBvciB3aXRoIGN1c3RvbSBlcnJvciBtZXNzYWdlXG4gKlxuICogICAgIGNvbnN0IHMgPSBuZXcgU2NoZW1hKHsgYm9ybjogeyB0eXBlOiBEYXRlLCByZXF1aXJlZDogJ3tQQVRIfSBpcyByZXF1aXJlZCEnIH0pXG4gKlxuICogICAgIC8vIG9yIHdpdGggYSBmdW5jdGlvblxuICpcbiAqICAgICBjb25zdCBzID0gbmV3IFNjaGVtYSh7XG4gKiAgICAgICB1c2VySWQ6IE9iamVjdElkLFxuICogICAgICAgdXNlcm5hbWU6IHtcbiAqICAgICAgICAgdHlwZTogU3RyaW5nLFxuICogICAgICAgICByZXF1aXJlZDogZnVuY3Rpb24oKSB7IHJldHVybiB0aGlzLnVzZXJJZCAhPSBudWxsOyB9XG4gKiAgICAgICB9XG4gKiAgICAgfSlcbiAqXG4gKiAgICAgLy8gb3Igd2l0aCBhIGZ1bmN0aW9uIGFuZCBhIGN1c3RvbSBtZXNzYWdlXG4gKiAgICAgY29uc3QgcyA9IG5ldyBTY2hlbWEoe1xuICogICAgICAgdXNlcklkOiBPYmplY3RJZCxcbiAqICAgICAgIHVzZXJuYW1lOiB7XG4gKiAgICAgICAgIHR5cGU6IFN0cmluZyxcbiAqICAgICAgICAgcmVxdWlyZWQ6IFtcbiAqICAgICAgICAgICBmdW5jdGlvbigpIHsgcmV0dXJuIHRoaXMudXNlcklkICE9IG51bGw7IH0sXG4gKiAgICAgICAgICAgJ3VzZXJuYW1lIGlzIHJlcXVpcmVkIGlmIGlkIGlzIHNwZWNpZmllZCdcbiAqICAgICAgICAgXVxuICogICAgICAgfVxuICogICAgIH0pXG4gKlxuICogICAgIC8vIG9yIHRocm91Z2ggdGhlIHBhdGggQVBJXG4gKlxuICogICAgIHMucGF0aCgnbmFtZScpLnJlcXVpcmVkKHRydWUpO1xuICpcbiAqICAgICAvLyB3aXRoIGN1c3RvbSBlcnJvciBtZXNzYWdpbmdcbiAqXG4gKiAgICAgcy5wYXRoKCduYW1lJykucmVxdWlyZWQodHJ1ZSwgJ2dycnIgOiggJyk7XG4gKlxuICogICAgIC8vIG9yIG1ha2UgYSBwYXRoIGNvbmRpdGlvbmFsbHkgcmVxdWlyZWQgYmFzZWQgb24gYSBmdW5jdGlvblxuICogICAgIGNvbnN0IGlzT3ZlcjE4ID0gZnVuY3Rpb24oKSB7IHJldHVybiB0aGlzLmFnZSA+PSAxODsgfTtcbiAqICAgICBzLnBhdGgoJ3ZvdGVyUmVnaXN0cmF0aW9uSWQnKS5yZXF1aXJlZChpc092ZXIxOCk7XG4gKlxuICogVGhlIHJlcXVpcmVkIHZhbGlkYXRvciB1c2VzIHRoZSBTY2hlbWFUeXBlJ3MgYGNoZWNrUmVxdWlyZWRgIGZ1bmN0aW9uIHRvXG4gKiBkZXRlcm1pbmUgd2hldGhlciBhIGdpdmVuIHZhbHVlIHNhdGlzZmllcyB0aGUgcmVxdWlyZWQgdmFsaWRhdG9yLiBCeSBkZWZhdWx0LFxuICogYSB2YWx1ZSBzYXRpc2ZpZXMgdGhlIHJlcXVpcmVkIHZhbGlkYXRvciBpZiBgdmFsICE9IG51bGxgICh0aGF0IGlzLCBpZlxuICogdGhlIHZhbHVlIGlzIG5vdCBudWxsIG5vciB1bmRlZmluZWQpLiBIb3dldmVyLCBtb3N0IGJ1aWx0LWluIG1vbmdvb3NlIHNjaGVtYVxuICogdHlwZXMgb3ZlcnJpZGUgdGhlIGRlZmF1bHQgYGNoZWNrUmVxdWlyZWRgIGZ1bmN0aW9uOlxuICpcbiAqIEBwYXJhbSB7Qm9vbGVhbnxGdW5jdGlvbnxPYmplY3R9IHJlcXVpcmVkIGVuYWJsZS9kaXNhYmxlIHRoZSB2YWxpZGF0b3IsIG9yIGZ1bmN0aW9uIHRoYXQgcmV0dXJucyByZXF1aXJlZCBib29sZWFuLCBvciBvcHRpb25zIG9iamVjdFxuICogQHBhcmFtIHtCb29sZWFufEZ1bmN0aW9ufSBbb3B0aW9ucy5pc1JlcXVpcmVkXSBlbmFibGUvZGlzYWJsZSB0aGUgdmFsaWRhdG9yLCBvciBmdW5jdGlvbiB0aGF0IHJldHVybnMgcmVxdWlyZWQgYm9vbGVhblxuICogQHBhcmFtIHtGdW5jdGlvbn0gW29wdGlvbnMuRXJyb3JDb25zdHJ1Y3Rvcl0gY3VzdG9tIGVycm9yIGNvbnN0cnVjdG9yLiBUaGUgY29uc3RydWN0b3IgcmVjZWl2ZXMgMSBwYXJhbWV0ZXIsIGFuIG9iamVjdCBjb250YWluaW5nIHRoZSB2YWxpZGF0b3IgcHJvcGVydGllcy5cbiAqIEBwYXJhbSB7U3RyaW5nfSBbbWVzc2FnZV0gb3B0aW9uYWwgY3VzdG9tIGVycm9yIG1lc3NhZ2VcbiAqIEByZXR1cm4ge1NjaGVtYVR5cGV9IHRoaXNcbiAqIEBzZWUgQ3VzdG9taXplZCBFcnJvciBNZXNzYWdlcyBodHRwczovL21vbmdvb3NlanMuY29tL2RvY3MvYXBpL2Vycm9yLmh0bWwjRXJyb3IubWVzc2FnZXNcbiAqIEBzZWUgU2NoZW1hQXJyYXkjY2hlY2tSZXF1aXJlZCBodHRwczovL21vbmdvb3NlanMuY29tL2RvY3MvYXBpL3NjaGVtYWFycmF5Lmh0bWwjU2NoZW1hQXJyYXkucHJvdG90eXBlLmNoZWNrUmVxdWlyZWQoKVxuICogQHNlZSBTY2hlbWFCb29sZWFuI2NoZWNrUmVxdWlyZWQgaHR0cHM6Ly9tb25nb29zZWpzLmNvbS9kb2NzL2FwaS9zY2hlbWFib29sZWFuLmh0bWwjU2NoZW1hQm9vbGVhbi5wcm90b3R5cGUuY2hlY2tSZXF1aXJlZCgpXG4gKiBAc2VlIFNjaGVtYUJ1ZmZlciNjaGVja1JlcXVpcmVkIGh0dHBzOi8vbW9uZ29vc2Vqcy5jb20vZG9jcy9hcGkvc2NoZW1hYnVmZmVyLmh0bWwjU2NoZW1hQnVmZmVyLnByb3RvdHlwZS5jaGVja1JlcXVpcmVkKClcbiAqIEBzZWUgU2NoZW1hTnVtYmVyI2NoZWNrUmVxdWlyZWQgaHR0cHM6Ly9tb25nb29zZWpzLmNvbS9kb2NzL2FwaS9zY2hlbWFudW1iZXIuaHRtbCNTY2hlbWFOdW1iZXIucHJvdG90eXBlLmNoZWNrUmVxdWlyZWQoKVxuICogQHNlZSBTY2hlbWFPYmplY3RJZCNjaGVja1JlcXVpcmVkIGh0dHBzOi8vbW9uZ29vc2Vqcy5jb20vZG9jcy9hcGkvc2NoZW1hb2JqZWN0aWQuaHRtbCNPYmplY3RJZC5wcm90b3R5cGUuY2hlY2tSZXF1aXJlZCgpXG4gKiBAc2VlIFNjaGVtYVN0cmluZyNjaGVja1JlcXVpcmVkIGh0dHBzOi8vbW9uZ29vc2Vqcy5jb20vZG9jcy9hcGkvc2NoZW1hc3RyaW5nLmh0bWwjU2NoZW1hU3RyaW5nLnByb3RvdHlwZS5jaGVja1JlcXVpcmVkKClcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuU2NoZW1hVHlwZS5wcm90b3R5cGUucmVxdWlyZWQgPSBmdW5jdGlvbihyZXF1aXJlZCwgbWVzc2FnZSkge1xuICBsZXQgY3VzdG9tT3B0aW9ucyA9IHt9O1xuXG4gIGlmIChhcmd1bWVudHMubGVuZ3RoID4gMCAmJiByZXF1aXJlZCA9PSBudWxsKSB7XG4gICAgdGhpcy52YWxpZGF0b3JzID0gdGhpcy52YWxpZGF0b3JzLmZpbHRlcihmdW5jdGlvbih2KSB7XG4gICAgICByZXR1cm4gdi52YWxpZGF0b3IgIT09IHRoaXMucmVxdWlyZWRWYWxpZGF0b3I7XG4gICAgfSwgdGhpcyk7XG5cbiAgICB0aGlzLmlzUmVxdWlyZWQgPSBmYWxzZTtcbiAgICBkZWxldGUgdGhpcy5vcmlnaW5hbFJlcXVpcmVkVmFsdWU7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICBpZiAodHlwZW9mIHJlcXVpcmVkID09PSAnb2JqZWN0Jykge1xuICAgIGN1c3RvbU9wdGlvbnMgPSByZXF1aXJlZDtcbiAgICBtZXNzYWdlID0gY3VzdG9tT3B0aW9ucy5tZXNzYWdlIHx8IG1lc3NhZ2U7XG4gICAgcmVxdWlyZWQgPSByZXF1aXJlZC5pc1JlcXVpcmVkO1xuICB9XG5cbiAgaWYgKHJlcXVpcmVkID09PSBmYWxzZSkge1xuICAgIHRoaXMudmFsaWRhdG9ycyA9IHRoaXMudmFsaWRhdG9ycy5maWx0ZXIoZnVuY3Rpb24odikge1xuICAgICAgcmV0dXJuIHYudmFsaWRhdG9yICE9PSB0aGlzLnJlcXVpcmVkVmFsaWRhdG9yO1xuICAgIH0sIHRoaXMpO1xuXG4gICAgdGhpcy5pc1JlcXVpcmVkID0gZmFsc2U7XG4gICAgZGVsZXRlIHRoaXMub3JpZ2luYWxSZXF1aXJlZFZhbHVlO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgY29uc3QgX3RoaXMgPSB0aGlzO1xuICB0aGlzLmlzUmVxdWlyZWQgPSB0cnVlO1xuXG4gIHRoaXMucmVxdWlyZWRWYWxpZGF0b3IgPSBmdW5jdGlvbih2KSB7XG4gICAgY29uc3QgY2FjaGVkUmVxdWlyZWQgPSB0aGlzICYmIHRoaXMuJF9fICYmIHRoaXMuJF9fLmNhY2hlZFJlcXVpcmVkO1xuXG4gICAgLy8gbm8gdmFsaWRhdGlvbiB3aGVuIHRoaXMgcGF0aCB3YXNuJ3Qgc2VsZWN0ZWQgaW4gdGhlIHF1ZXJ5LlxuICAgIGlmIChjYWNoZWRSZXF1aXJlZCAhPSBudWxsICYmICF0aGlzLiRfX2lzU2VsZWN0ZWQoX3RoaXMucGF0aCkgJiYgIXRoaXNbZG9jdW1lbnRJc01vZGlmaWVkXShfdGhpcy5wYXRoKSkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgLy8gYCRjYWNoZWRSZXF1aXJlZGAgZ2V0cyBzZXQgaW4gYF9ldmFsdWF0ZVJlcXVpcmVkRnVuY3Rpb25zKClgIHNvIHdlXG4gICAgLy8gZG9uJ3QgY2FsbCByZXF1aXJlZCBmdW5jdGlvbnMgbXVsdGlwbGUgdGltZXMgaW4gb25lIHZhbGlkYXRlIGNhbGxcbiAgICAvLyBTZWUgZ2gtNjgwMVxuICAgIGlmIChjYWNoZWRSZXF1aXJlZCAhPSBudWxsICYmIF90aGlzLnBhdGggaW4gY2FjaGVkUmVxdWlyZWQpIHtcbiAgICAgIGNvbnN0IHJlcyA9IGNhY2hlZFJlcXVpcmVkW190aGlzLnBhdGhdID9cbiAgICAgICAgX3RoaXMuY2hlY2tSZXF1aXJlZCh2LCB0aGlzKSA6XG4gICAgICAgIHRydWU7XG4gICAgICBkZWxldGUgY2FjaGVkUmVxdWlyZWRbX3RoaXMucGF0aF07XG4gICAgICByZXR1cm4gcmVzO1xuICAgIH0gZWxzZSBpZiAodHlwZW9mIHJlcXVpcmVkID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICByZXR1cm4gcmVxdWlyZWQuYXBwbHkodGhpcykgPyBfdGhpcy5jaGVja1JlcXVpcmVkKHYsIHRoaXMpIDogdHJ1ZTtcbiAgICB9XG5cbiAgICByZXR1cm4gX3RoaXMuY2hlY2tSZXF1aXJlZCh2LCB0aGlzKTtcbiAgfTtcbiAgdGhpcy5vcmlnaW5hbFJlcXVpcmVkVmFsdWUgPSByZXF1aXJlZDtcblxuICBpZiAodHlwZW9mIHJlcXVpcmVkID09PSAnc3RyaW5nJykge1xuICAgIG1lc3NhZ2UgPSByZXF1aXJlZDtcbiAgICByZXF1aXJlZCA9IHVuZGVmaW5lZDtcbiAgfVxuXG4gIGNvbnN0IG1zZyA9IG1lc3NhZ2UgfHwgTW9uZ29vc2VFcnJvci5tZXNzYWdlcy5nZW5lcmFsLnJlcXVpcmVkO1xuICB0aGlzLnZhbGlkYXRvcnMudW5zaGlmdChPYmplY3QuYXNzaWduKHt9LCBjdXN0b21PcHRpb25zLCB7XG4gICAgdmFsaWRhdG9yOiB0aGlzLnJlcXVpcmVkVmFsaWRhdG9yLFxuICAgIG1lc3NhZ2U6IG1zZyxcbiAgICB0eXBlOiAncmVxdWlyZWQnXG4gIH0pKTtcblxuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogU2V0IHRoZSBtb2RlbCB0aGF0IHRoaXMgcGF0aCByZWZlcnMgdG8uIFRoaXMgaXMgdGhlIG9wdGlvbiB0aGF0IFtwb3B1bGF0ZV0oaHR0cHM6Ly9tb25nb29zZWpzLmNvbS9kb2NzL3BvcHVsYXRlLmh0bWwpXG4gKiBsb29rcyBhdCB0byBkZXRlcm1pbmUgdGhlIGZvcmVpZ24gY29sbGVjdGlvbiBpdCBzaG91bGQgcXVlcnkuXG4gKlxuICogIyMjIyBFeGFtcGxlOlxuICpcbiAqICAgICBjb25zdCB1c2VyU2NoZW1hID0gbmV3IFNjaGVtYSh7IG5hbWU6IFN0cmluZyB9KTtcbiAqICAgICBjb25zdCBVc2VyID0gbW9uZ29vc2UubW9kZWwoJ1VzZXInLCB1c2VyU2NoZW1hKTtcbiAqXG4gKiAgICAgY29uc3QgcG9zdFNjaGVtYSA9IG5ldyBTY2hlbWEoeyB1c2VyOiBtb25nb29zZS5PYmplY3RJZCB9KTtcbiAqICAgICBwb3N0U2NoZW1hLnBhdGgoJ3VzZXInKS5yZWYoJ1VzZXInKTsgLy8gQ2FuIHNldCByZWYgdG8gYSBtb2RlbCBuYW1lXG4gKiAgICAgcG9zdFNjaGVtYS5wYXRoKCd1c2VyJykucmVmKFVzZXIpOyAvLyBPciBhIG1vZGVsIGNsYXNzXG4gKiAgICAgcG9zdFNjaGVtYS5wYXRoKCd1c2VyJykucmVmKCgpID0+ICdVc2VyJyk7IC8vIE9yIGEgZnVuY3Rpb24gdGhhdCByZXR1cm5zIHRoZSBtb2RlbCBuYW1lXG4gKiAgICAgcG9zdFNjaGVtYS5wYXRoKCd1c2VyJykucmVmKCgpID0+IFVzZXIpOyAvLyBPciBhIGZ1bmN0aW9uIHRoYXQgcmV0dXJucyB0aGUgbW9kZWwgY2xhc3NcbiAqXG4gKiAgICAgLy8gT3IgeW91IGNhbiBqdXN0IGRlY2xhcmUgdGhlIGByZWZgIGlubGluZSBpbiB5b3VyIHNjaGVtYVxuICogICAgIGNvbnN0IHBvc3RTY2hlbWEyID0gbmV3IFNjaGVtYSh7XG4gKiAgICAgICB1c2VyOiB7IHR5cGU6IG1vbmdvb3NlLk9iamVjdElkLCByZWY6IFVzZXIgfVxuICogICAgIH0pO1xuICpcbiAqIEBwYXJhbSB7U3RyaW5nfE1vZGVsfEZ1bmN0aW9ufSByZWYgZWl0aGVyIGEgbW9kZWwgbmFtZSwgYSBbTW9kZWxdKGh0dHBzOi8vbW9uZ29vc2Vqcy5jb20vZG9jcy9tb2RlbHMuaHRtbCksIG9yIGEgZnVuY3Rpb24gdGhhdCByZXR1cm5zIGEgbW9kZWwgbmFtZSBvciBtb2RlbC5cbiAqIEByZXR1cm4ge1NjaGVtYVR5cGV9IHRoaXNcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuU2NoZW1hVHlwZS5wcm90b3R5cGUucmVmID0gZnVuY3Rpb24ocmVmKSB7XG4gIHRoaXMub3B0aW9ucy5yZWYgPSByZWY7XG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBHZXRzIHRoZSBkZWZhdWx0IHZhbHVlXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IHNjb3BlIHRoZSBzY29wZSB3aGljaCBjYWxsYmFjayBhcmUgZXhlY3V0ZWRcbiAqIEBwYXJhbSB7Qm9vbGVhbn0gaW5pdFxuICogQHJldHVybiB7QW55fSBUaGUgU3RvcmVkIGRlZmF1bHQgdmFsdWUuXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5TY2hlbWFUeXBlLnByb3RvdHlwZS5nZXREZWZhdWx0ID0gZnVuY3Rpb24oc2NvcGUsIGluaXQsIG9wdGlvbnMpIHtcbiAgbGV0IHJldDtcbiAgaWYgKHR5cGVvZiB0aGlzLmRlZmF1bHRWYWx1ZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIGlmIChcbiAgICAgIHRoaXMuZGVmYXVsdFZhbHVlID09PSBEYXRlLm5vdyB8fFxuICAgICAgdGhpcy5kZWZhdWx0VmFsdWUgPT09IEFycmF5IHx8XG4gICAgICB0aGlzLmRlZmF1bHRWYWx1ZS5uYW1lLnRvTG93ZXJDYXNlKCkgPT09ICdvYmplY3RpZCdcbiAgICApIHtcbiAgICAgIHJldCA9IHRoaXMuZGVmYXVsdFZhbHVlLmNhbGwoc2NvcGUpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXQgPSB0aGlzLmRlZmF1bHRWYWx1ZS5jYWxsKHNjb3BlLCBzY29wZSk7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHJldCA9IHRoaXMuZGVmYXVsdFZhbHVlO1xuICB9XG5cbiAgaWYgKHJldCAhPT0gbnVsbCAmJiByZXQgIT09IHVuZGVmaW5lZCkge1xuICAgIGlmICh0eXBlb2YgcmV0ID09PSAnb2JqZWN0JyAmJiAoIXRoaXMub3B0aW9ucyB8fCAhdGhpcy5vcHRpb25zLnNoYXJlZCkpIHtcbiAgICAgIHJldCA9IGNsb25lKHJldCk7XG4gICAgfVxuXG4gICAgaWYgKG9wdGlvbnMgJiYgb3B0aW9ucy5za2lwQ2FzdCkge1xuICAgICAgcmV0dXJuIHRoaXMuX2FwcGx5U2V0dGVycyhyZXQsIHNjb3BlKTtcbiAgICB9XG5cbiAgICBjb25zdCBjYXN0ZWQgPSB0aGlzLmFwcGx5U2V0dGVycyhyZXQsIHNjb3BlLCBpbml0LCB1bmRlZmluZWQsIHNldE9wdGlvbnNGb3JEZWZhdWx0cyk7XG4gICAgaWYgKGNhc3RlZCAmJiAhQXJyYXkuaXNBcnJheShjYXN0ZWQpICYmIGNhc3RlZC4kaXNTaW5nbGVOZXN0ZWQpIHtcbiAgICAgIGNhc3RlZC4kX19wYXJlbnQgPSBzY29wZTtcbiAgICB9XG4gICAgcmV0dXJuIGNhc3RlZDtcbiAgfVxuICByZXR1cm4gcmV0O1xufTtcblxuLyoqXG4gKiBBcHBsaWVzIHNldHRlcnMgd2l0aG91dCBjYXN0aW5nXG4gKlxuICogQHBhcmFtIHtBbnl9IHZhbHVlXG4gKiBAcGFyYW0ge0FueX0gc2NvcGVcbiAqIEBwYXJhbSB7Qm9vbGVhbn0gaW5pdFxuICogQHBhcmFtIHtBbnl9IHByaW9yVmFsXG4gKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdXG4gKiBAaW5zdGFuY2VcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cblNjaGVtYVR5cGUucHJvdG90eXBlLl9hcHBseVNldHRlcnMgPSBmdW5jdGlvbih2YWx1ZSwgc2NvcGUsIGluaXQsIHByaW9yVmFsLCBvcHRpb25zKSB7XG4gIGxldCB2ID0gdmFsdWU7XG4gIGlmIChpbml0KSB7XG4gICAgcmV0dXJuIHY7XG4gIH1cbiAgY29uc3Qgc2V0dGVycyA9IHRoaXMuc2V0dGVycztcblxuICBmb3IgKGxldCBpID0gc2V0dGVycy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgIHYgPSBzZXR0ZXJzW2ldLmNhbGwoc2NvcGUsIHYsIHByaW9yVmFsLCB0aGlzLCBvcHRpb25zKTtcbiAgfVxuXG4gIHJldHVybiB2O1xufTtcblxuLyohXG4gKiBpZ25vcmVcbiAqL1xuXG5TY2hlbWFUeXBlLnByb3RvdHlwZS5fY2FzdE51bGxpc2ggPSBmdW5jdGlvbiBfY2FzdE51bGxpc2godikge1xuICByZXR1cm4gdjtcbn07XG5cbi8qKlxuICogQXBwbGllcyBzZXR0ZXJzXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IHZhbHVlXG4gKiBAcGFyYW0ge09iamVjdH0gc2NvcGVcbiAqIEBwYXJhbSB7Qm9vbGVhbn0gaW5pdFxuICogQHJldHVybiB7QW55fVxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuU2NoZW1hVHlwZS5wcm90b3R5cGUuYXBwbHlTZXR0ZXJzID0gZnVuY3Rpb24odmFsdWUsIHNjb3BlLCBpbml0LCBwcmlvclZhbCwgb3B0aW9ucykge1xuICBsZXQgdiA9IHRoaXMuX2FwcGx5U2V0dGVycyh2YWx1ZSwgc2NvcGUsIGluaXQsIHByaW9yVmFsLCBvcHRpb25zKTtcbiAgaWYgKHYgPT0gbnVsbCkge1xuICAgIHJldHVybiB0aGlzLl9jYXN0TnVsbGlzaCh2KTtcbiAgfVxuICAvLyBkbyBub3QgY2FzdCB1bnRpbCBhbGwgc2V0dGVycyBhcmUgYXBwbGllZCAjNjY1XG4gIHYgPSB0aGlzLmNhc3Qodiwgc2NvcGUsIGluaXQsIHByaW9yVmFsLCBvcHRpb25zKTtcblxuICByZXR1cm4gdjtcbn07XG5cbi8qKlxuICogQXBwbGllcyBnZXR0ZXJzIHRvIGEgdmFsdWVcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gdmFsdWVcbiAqIEBwYXJhbSB7T2JqZWN0fSBzY29wZVxuICogQHJldHVybiB7QW55fVxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuU2NoZW1hVHlwZS5wcm90b3R5cGUuYXBwbHlHZXR0ZXJzID0gZnVuY3Rpb24odmFsdWUsIHNjb3BlKSB7XG4gIGxldCB2ID0gdmFsdWU7XG4gIGNvbnN0IGdldHRlcnMgPSB0aGlzLmdldHRlcnM7XG4gIGNvbnN0IGxlbiA9IGdldHRlcnMubGVuZ3RoO1xuXG4gIGlmIChsZW4gPT09IDApIHtcbiAgICByZXR1cm4gdjtcbiAgfVxuXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgbGVuOyArK2kpIHtcbiAgICB2ID0gZ2V0dGVyc1tpXS5jYWxsKHNjb3BlLCB2LCB0aGlzKTtcbiAgfVxuXG4gIHJldHVybiB2O1xufTtcblxuLyoqXG4gKiBTZXRzIGRlZmF1bHQgYHNlbGVjdCgpYCBiZWhhdmlvciBmb3IgdGhpcyBwYXRoLlxuICpcbiAqIFNldCB0byBgdHJ1ZWAgaWYgdGhpcyBwYXRoIHNob3VsZCBhbHdheXMgYmUgaW5jbHVkZWQgaW4gdGhlIHJlc3VsdHMsIGBmYWxzZWAgaWYgaXQgc2hvdWxkIGJlIGV4Y2x1ZGVkIGJ5IGRlZmF1bHQuIFRoaXMgc2V0dGluZyBjYW4gYmUgb3ZlcnJpZGRlbiBhdCB0aGUgcXVlcnkgbGV2ZWwuXG4gKlxuICogIyMjIyBFeGFtcGxlOlxuICpcbiAqICAgICBUID0gZGIubW9kZWwoJ1QnLCBuZXcgU2NoZW1hKHsgeDogeyB0eXBlOiBTdHJpbmcsIHNlbGVjdDogdHJ1ZSB9fSkpO1xuICogICAgIFQuZmluZCguLik7IC8vIGZpZWxkIHggd2lsbCBhbHdheXMgYmUgc2VsZWN0ZWQgLi5cbiAqICAgICAvLyAuLiB1bmxlc3Mgb3ZlcnJpZGRlbjtcbiAqICAgICBULmZpbmQoKS5zZWxlY3QoJy14JykuZXhlYyhjYWxsYmFjayk7XG4gKlxuICogQHBhcmFtIHtCb29sZWFufSB2YWxcbiAqIEByZXR1cm4ge1NjaGVtYVR5cGV9IHRoaXNcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuU2NoZW1hVHlwZS5wcm90b3R5cGUuc2VsZWN0ID0gZnVuY3Rpb24gc2VsZWN0KHZhbCkge1xuICB0aGlzLnNlbGVjdGVkID0gISF2YWw7XG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBQZXJmb3JtcyBhIHZhbGlkYXRpb24gb2YgYHZhbHVlYCB1c2luZyB0aGUgdmFsaWRhdG9ycyBkZWNsYXJlZCBmb3IgdGhpcyBTY2hlbWFUeXBlLlxuICpcbiAqIEBwYXJhbSB7QW55fSB2YWx1ZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2tcbiAqIEBwYXJhbSB7T2JqZWN0fSBzY29wZVxuICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXVxuICogQHBhcmFtIHtTdHJpbmd9IFtvcHRpb25zLnBhdGhdXG4gKiBAcmV0dXJuIHtBbnl9IElmIG5vIHZhbGlkYXRvcnMsIHJldHVybnMgdGhlIG91dHB1dCBmcm9tIGNhbGxpbmcgYGZuYCwgb3RoZXJ3aXNlIG5vIHJldHVyblxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5TY2hlbWFUeXBlLnByb3RvdHlwZS5kb1ZhbGlkYXRlID0gZnVuY3Rpb24odmFsdWUsIGZuLCBzY29wZSwgb3B0aW9ucykge1xuICBsZXQgZXJyID0gZmFsc2U7XG4gIGNvbnN0IHBhdGggPSB0aGlzLnBhdGg7XG5cbiAgLy8gQXZvaWQgbm9uLW9iamVjdCBgdmFsaWRhdG9yc2BcbiAgY29uc3QgdmFsaWRhdG9ycyA9IHRoaXMudmFsaWRhdG9ycy5cbiAgICBmaWx0ZXIodiA9PiB0eXBlb2YgdiA9PT0gJ29iamVjdCcgJiYgdiAhPT0gbnVsbCk7XG5cbiAgbGV0IGNvdW50ID0gdmFsaWRhdG9ycy5sZW5ndGg7XG5cbiAgaWYgKCFjb3VudCkge1xuICAgIHJldHVybiBmbihudWxsKTtcbiAgfVxuXG4gIGZvciAobGV0IGkgPSAwLCBsZW4gPSB2YWxpZGF0b3JzLmxlbmd0aDsgaSA8IGxlbjsgKytpKSB7XG4gICAgaWYgKGVycikge1xuICAgICAgYnJlYWs7XG4gICAgfVxuXG4gICAgY29uc3QgdiA9IHZhbGlkYXRvcnNbaV07XG4gICAgY29uc3QgdmFsaWRhdG9yID0gdi52YWxpZGF0b3I7XG4gICAgbGV0IG9rO1xuXG4gICAgY29uc3QgdmFsaWRhdG9yUHJvcGVydGllcyA9IGlzU2ltcGxlVmFsaWRhdG9yKHYpID8gT2JqZWN0LmFzc2lnbih7fSwgdikgOiBjbG9uZSh2KTtcbiAgICB2YWxpZGF0b3JQcm9wZXJ0aWVzLnBhdGggPSBvcHRpb25zICYmIG9wdGlvbnMucGF0aCA/IG9wdGlvbnMucGF0aCA6IHBhdGg7XG4gICAgdmFsaWRhdG9yUHJvcGVydGllcy5mdWxsUGF0aCA9IHRoaXMuJGZ1bGxQYXRoO1xuICAgIHZhbGlkYXRvclByb3BlcnRpZXMudmFsdWUgPSB2YWx1ZTtcblxuICAgIGlmICh2YWxpZGF0b3IgaW5zdGFuY2VvZiBSZWdFeHApIHtcbiAgICAgIHZhbGlkYXRlKHZhbGlkYXRvci50ZXN0KHZhbHVlKSwgdmFsaWRhdG9yUHJvcGVydGllcywgc2NvcGUpO1xuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiB2YWxpZGF0b3IgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIGlmICh2YWx1ZSA9PT0gdW5kZWZpbmVkICYmIHZhbGlkYXRvciAhPT0gdGhpcy5yZXF1aXJlZFZhbGlkYXRvcikge1xuICAgICAgdmFsaWRhdGUodHJ1ZSwgdmFsaWRhdG9yUHJvcGVydGllcywgc2NvcGUpO1xuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgdHJ5IHtcbiAgICAgIGlmICh2YWxpZGF0b3JQcm9wZXJ0aWVzLnByb3BzUGFyYW1ldGVyKSB7XG4gICAgICAgIG9rID0gdmFsaWRhdG9yLmNhbGwoc2NvcGUsIHZhbHVlLCB2YWxpZGF0b3JQcm9wZXJ0aWVzKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG9rID0gdmFsaWRhdG9yLmNhbGwoc2NvcGUsIHZhbHVlKTtcbiAgICAgIH1cbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgb2sgPSBmYWxzZTtcbiAgICAgIHZhbGlkYXRvclByb3BlcnRpZXMucmVhc29uID0gZXJyb3I7XG4gICAgICBpZiAoZXJyb3IubWVzc2FnZSkge1xuICAgICAgICB2YWxpZGF0b3JQcm9wZXJ0aWVzLm1lc3NhZ2UgPSBlcnJvci5tZXNzYWdlO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChvayAhPSBudWxsICYmIHR5cGVvZiBvay50aGVuID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBvay50aGVuKFxuICAgICAgICBmdW5jdGlvbihvaykgeyB2YWxpZGF0ZShvaywgdmFsaWRhdG9yUHJvcGVydGllcywgc2NvcGUpOyB9LFxuICAgICAgICBmdW5jdGlvbihlcnJvcikge1xuICAgICAgICAgIHZhbGlkYXRvclByb3BlcnRpZXMucmVhc29uID0gZXJyb3I7XG4gICAgICAgICAgdmFsaWRhdG9yUHJvcGVydGllcy5tZXNzYWdlID0gZXJyb3IubWVzc2FnZTtcbiAgICAgICAgICBvayA9IGZhbHNlO1xuICAgICAgICAgIHZhbGlkYXRlKG9rLCB2YWxpZGF0b3JQcm9wZXJ0aWVzLCBzY29wZSk7XG4gICAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YWxpZGF0ZShvaywgdmFsaWRhdG9yUHJvcGVydGllcywgc2NvcGUpO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHZhbGlkYXRlKG9rLCB2YWxpZGF0b3JQcm9wZXJ0aWVzLCBzY29wZSkge1xuICAgIGlmIChlcnIpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKG9rID09PSB1bmRlZmluZWQgfHwgb2spIHtcbiAgICAgIGlmICgtLWNvdW50IDw9IDApIHtcbiAgICAgICAgaW1tZWRpYXRlKGZ1bmN0aW9uKCkge1xuICAgICAgICAgIGZuKG51bGwpO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3QgRXJyb3JDb25zdHJ1Y3RvciA9IHZhbGlkYXRvclByb3BlcnRpZXMuRXJyb3JDb25zdHJ1Y3RvciB8fCBWYWxpZGF0b3JFcnJvcjtcbiAgICAgIGVyciA9IG5ldyBFcnJvckNvbnN0cnVjdG9yKHZhbGlkYXRvclByb3BlcnRpZXMsIHNjb3BlKTtcbiAgICAgIGVyclt2YWxpZGF0b3JFcnJvclN5bWJvbF0gPSB0cnVlO1xuICAgICAgaW1tZWRpYXRlKGZ1bmN0aW9uKCkge1xuICAgICAgICBmbihlcnIpO1xuICAgICAgfSk7XG4gICAgfVxuICB9XG59O1xuXG5cbmZ1bmN0aW9uIF92YWxpZGF0ZShvaywgdmFsaWRhdG9yUHJvcGVydGllcykge1xuICBpZiAob2sgIT09IHVuZGVmaW5lZCAmJiAhb2spIHtcbiAgICBjb25zdCBFcnJvckNvbnN0cnVjdG9yID0gdmFsaWRhdG9yUHJvcGVydGllcy5FcnJvckNvbnN0cnVjdG9yIHx8IFZhbGlkYXRvckVycm9yO1xuICAgIGNvbnN0IGVyciA9IG5ldyBFcnJvckNvbnN0cnVjdG9yKHZhbGlkYXRvclByb3BlcnRpZXMpO1xuICAgIGVyclt2YWxpZGF0b3JFcnJvclN5bWJvbF0gPSB0cnVlO1xuICAgIHJldHVybiBlcnI7XG4gIH1cbn1cblxuLyoqXG4gKiBQZXJmb3JtcyBhIHZhbGlkYXRpb24gb2YgYHZhbHVlYCB1c2luZyB0aGUgdmFsaWRhdG9ycyBkZWNsYXJlZCBmb3IgdGhpcyBTY2hlbWFUeXBlLlxuICpcbiAqICMjIyMgTm90ZTpcbiAqXG4gKiBUaGlzIG1ldGhvZCBpZ25vcmVzIHRoZSBhc3luY2hyb25vdXMgdmFsaWRhdG9ycy5cbiAqXG4gKiBAcGFyYW0ge0FueX0gdmFsdWVcbiAqIEBwYXJhbSB7T2JqZWN0fSBzY29wZVxuICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXVxuICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zLnBhdGhdXG4gKiBAcmV0dXJuIHtNb25nb29zZUVycm9yfG51bGx9XG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5TY2hlbWFUeXBlLnByb3RvdHlwZS5kb1ZhbGlkYXRlU3luYyA9IGZ1bmN0aW9uKHZhbHVlLCBzY29wZSwgb3B0aW9ucykge1xuICBjb25zdCBwYXRoID0gdGhpcy5wYXRoO1xuICBjb25zdCBjb3VudCA9IHRoaXMudmFsaWRhdG9ycy5sZW5ndGg7XG5cbiAgaWYgKCFjb3VudCkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgbGV0IHZhbGlkYXRvcnMgPSB0aGlzLnZhbGlkYXRvcnM7XG4gIGlmICh2YWx1ZSA9PT0gdm9pZCAwKSB7XG4gICAgaWYgKHRoaXMudmFsaWRhdG9ycy5sZW5ndGggIT09IDAgJiYgdGhpcy52YWxpZGF0b3JzWzBdLnR5cGUgPT09ICdyZXF1aXJlZCcpIHtcbiAgICAgIHZhbGlkYXRvcnMgPSBbdGhpcy52YWxpZGF0b3JzWzBdXTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICB9XG5cbiAgbGV0IGVyciA9IG51bGw7XG4gIGxldCBpID0gMDtcbiAgY29uc3QgbGVuID0gdmFsaWRhdG9ycy5sZW5ndGg7XG4gIGZvciAoaSA9IDA7IGkgPCBsZW47ICsraSkge1xuXG4gICAgY29uc3QgdiA9IHZhbGlkYXRvcnNbaV07XG5cbiAgICBpZiAodiA9PT0gbnVsbCB8fCB0eXBlb2YgdiAhPT0gJ29iamVjdCcpIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIGNvbnN0IHZhbGlkYXRvciA9IHYudmFsaWRhdG9yO1xuICAgIGNvbnN0IHZhbGlkYXRvclByb3BlcnRpZXMgPSBpc1NpbXBsZVZhbGlkYXRvcih2KSA/IE9iamVjdC5hc3NpZ24oe30sIHYpIDogY2xvbmUodik7XG4gICAgdmFsaWRhdG9yUHJvcGVydGllcy5wYXRoID0gb3B0aW9ucyAmJiBvcHRpb25zLnBhdGggPyBvcHRpb25zLnBhdGggOiBwYXRoO1xuICAgIHZhbGlkYXRvclByb3BlcnRpZXMuZnVsbFBhdGggPSB0aGlzLiRmdWxsUGF0aDtcbiAgICB2YWxpZGF0b3JQcm9wZXJ0aWVzLnZhbHVlID0gdmFsdWU7XG4gICAgbGV0IG9rID0gZmFsc2U7XG5cbiAgICAvLyBTa2lwIGFueSBleHBsaWNpdCBhc3luYyB2YWxpZGF0b3JzLiBWYWxpZGF0b3JzIHRoYXQgcmV0dXJuIGEgcHJvbWlzZVxuICAgIC8vIHdpbGwgc3RpbGwgcnVuLCBidXQgd29uJ3QgdHJpZ2dlciBhbnkgZXJyb3JzLlxuICAgIGlmIChpc0FzeW5jRnVuY3Rpb24odmFsaWRhdG9yKSkge1xuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgaWYgKHZhbGlkYXRvciBpbnN0YW5jZW9mIFJlZ0V4cCkge1xuICAgICAgZXJyID0gX3ZhbGlkYXRlKHZhbGlkYXRvci50ZXN0KHZhbHVlKSwgdmFsaWRhdG9yUHJvcGVydGllcyk7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIHZhbGlkYXRvciAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgdHJ5IHtcbiAgICAgIGlmICh2YWxpZGF0b3JQcm9wZXJ0aWVzLnByb3BzUGFyYW1ldGVyKSB7XG4gICAgICAgIG9rID0gdmFsaWRhdG9yLmNhbGwoc2NvcGUsIHZhbHVlLCB2YWxpZGF0b3JQcm9wZXJ0aWVzKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG9rID0gdmFsaWRhdG9yLmNhbGwoc2NvcGUsIHZhbHVlKTtcbiAgICAgIH1cbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgb2sgPSBmYWxzZTtcbiAgICAgIHZhbGlkYXRvclByb3BlcnRpZXMucmVhc29uID0gZXJyb3I7XG4gICAgfVxuXG4gICAgLy8gU2tpcCBhbnkgdmFsaWRhdG9ycyB0aGF0IHJldHVybiBhIHByb21pc2UsIHdlIGNhbid0IGhhbmRsZSB0aG9zZVxuICAgIC8vIHN5bmNocm9ub3VzbHlcbiAgICBpZiAob2sgIT0gbnVsbCAmJiB0eXBlb2Ygb2sudGhlbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIGVyciA9IF92YWxpZGF0ZShvaywgdmFsaWRhdG9yUHJvcGVydGllcyk7XG4gICAgaWYgKGVycikge1xuICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGVycjtcbn07XG5cbi8qKlxuICogRGV0ZXJtaW5lcyBpZiB2YWx1ZSBpcyBhIHZhbGlkIFJlZmVyZW5jZS5cbiAqXG4gKiBAcGFyYW0ge1NjaGVtYVR5cGV9IHNlbGZcbiAqIEBwYXJhbSB7T2JqZWN0fSB2YWx1ZVxuICogQHBhcmFtIHtEb2N1bWVudH0gZG9jXG4gKiBAcGFyYW0ge0Jvb2xlYW59IGluaXRcbiAqIEByZXR1cm4ge0Jvb2xlYW59XG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5TY2hlbWFUeXBlLl9pc1JlZiA9IGZ1bmN0aW9uKHNlbGYsIHZhbHVlLCBkb2MsIGluaXQpIHtcbiAgLy8gZmFzdCBwYXRoXG4gIGxldCByZWYgPSBpbml0ICYmIHNlbGYub3B0aW9ucyAmJiAoc2VsZi5vcHRpb25zLnJlZiB8fCBzZWxmLm9wdGlvbnMucmVmUGF0aCk7XG5cbiAgaWYgKCFyZWYgJiYgZG9jICYmIGRvYy4kX18gIT0gbnVsbCkge1xuICAgIC8vIGNoZWNrcyBmb3JcbiAgICAvLyAtIHRoaXMgcG9wdWxhdGVkIHdpdGggYWRob2MgbW9kZWwgYW5kIG5vIHJlZiB3YXMgc2V0IGluIHNjaGVtYSBPUlxuICAgIC8vIC0gc2V0dGluZyAvIHB1c2hpbmcgdmFsdWVzIGFmdGVyIHBvcHVsYXRpb25cbiAgICBjb25zdCBwYXRoID0gZG9jLiRfX2Z1bGxQYXRoKHNlbGYucGF0aCwgdHJ1ZSk7XG5cbiAgICBjb25zdCBvd25lciA9IGRvYy5vd25lckRvY3VtZW50KCk7XG4gICAgcmVmID0gKHBhdGggIT0gbnVsbCAmJiBvd25lci4kcG9wdWxhdGVkKHBhdGgpKSB8fCBkb2MuJHBvcHVsYXRlZChzZWxmLnBhdGgpO1xuICB9XG5cbiAgaWYgKHJlZikge1xuICAgIGlmICh2YWx1ZSA9PSBudWxsKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgaWYgKCFCdWZmZXIuaXNCdWZmZXIodmFsdWUpICYmIC8vIGJ1ZmZlcnMgYXJlIG9iamVjdHMgdG9vXG4gICAgICB2YWx1ZS5fYnNvbnR5cGUgIT09ICdCaW5hcnknIC8vIHJhdyBiaW5hcnkgdmFsdWUgZnJvbSB0aGUgZGJcbiAgICAgICYmIHV0aWxzLmlzT2JqZWN0KHZhbHVlKSAvLyBtaWdodCBoYXZlIGRlc2VsZWN0ZWQgX2lkIGluIHBvcHVsYXRpb24gcXVlcnlcbiAgICApIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIHJldHVybiBpbml0O1xuICB9XG5cbiAgcmV0dXJuIGZhbHNlO1xufTtcblxuLyohXG4gKiBpZ25vcmVcbiAqL1xuXG5TY2hlbWFUeXBlLnByb3RvdHlwZS5fY2FzdFJlZiA9IGZ1bmN0aW9uIF9jYXN0UmVmKHZhbHVlLCBkb2MsIGluaXQpIHtcbiAgaWYgKHZhbHVlID09IG51bGwpIHtcbiAgICByZXR1cm4gdmFsdWU7XG4gIH1cblxuICBpZiAodmFsdWUuJF9fICE9IG51bGwpIHtcbiAgICB2YWx1ZS4kX18ud2FzUG9wdWxhdGVkID0gdmFsdWUuJF9fLndhc1BvcHVsYXRlZCB8fCB0cnVlO1xuICAgIHJldHVybiB2YWx1ZTtcbiAgfVxuXG4gIC8vIHNldHRpbmcgYSBwb3B1bGF0ZWQgcGF0aFxuICBpZiAoQnVmZmVyLmlzQnVmZmVyKHZhbHVlKSB8fCAhdXRpbHMuaXNPYmplY3QodmFsdWUpKSB7XG4gICAgaWYgKGluaXQpIHtcbiAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9XG4gICAgdGhyb3cgbmV3IENhc3RFcnJvcih0aGlzLmluc3RhbmNlLCB2YWx1ZSwgdGhpcy5wYXRoLCBudWxsLCB0aGlzKTtcbiAgfVxuXG4gIC8vIEhhbmRsZSB0aGUgY2FzZSB3aGVyZSB1c2VyIGRpcmVjdGx5IHNldHMgYSBwb3B1bGF0ZWRcbiAgLy8gcGF0aCB0byBhIHBsYWluIG9iamVjdDsgY2FzdCB0byB0aGUgTW9kZWwgdXNlZCBpblxuICAvLyB0aGUgcG9wdWxhdGlvbiBxdWVyeS5cbiAgY29uc3QgcGF0aCA9IGRvYy4kX19mdWxsUGF0aCh0aGlzLnBhdGgsIHRydWUpO1xuICBjb25zdCBvd25lciA9IGRvYy5vd25lckRvY3VtZW50KCk7XG4gIGNvbnN0IHBvcCA9IG93bmVyLiRwb3B1bGF0ZWQocGF0aCwgdHJ1ZSk7XG5cbiAgbGV0IHJldCA9IHZhbHVlO1xuICBpZiAoIWRvYy4kX18ucG9wdWxhdGVkIHx8XG4gICAgIWRvYy4kX18ucG9wdWxhdGVkW3BhdGhdIHx8XG4gICAgIWRvYy4kX18ucG9wdWxhdGVkW3BhdGhdLm9wdGlvbnMgfHxcbiAgICAhZG9jLiRfXy5wb3B1bGF0ZWRbcGF0aF0ub3B0aW9ucy5vcHRpb25zIHx8XG4gICAgIWRvYy4kX18ucG9wdWxhdGVkW3BhdGhdLm9wdGlvbnMub3B0aW9ucy5sZWFuKSB7XG4gICAgcmV0ID0gbmV3IHBvcC5vcHRpb25zW3BvcHVsYXRlTW9kZWxTeW1ib2xdKHZhbHVlKTtcbiAgICByZXQuJF9fLndhc1BvcHVsYXRlZCA9IHRydWU7XG4gIH1cblxuICByZXR1cm4gcmV0O1xufTtcblxuLyohXG4gKiBpZ25vcmVcbiAqL1xuXG5mdW5jdGlvbiBoYW5kbGVTaW5nbGUodmFsLCBjb250ZXh0KSB7XG4gIHJldHVybiB0aGlzLmNhc3RGb3JRdWVyeShudWxsLCB2YWwsIGNvbnRleHQpO1xufVxuXG4vKiFcbiAqIGlnbm9yZVxuICovXG5cbmZ1bmN0aW9uIGhhbmRsZUFycmF5KHZhbCwgY29udGV4dCkge1xuICBjb25zdCBfdGhpcyA9IHRoaXM7XG4gIGlmICghQXJyYXkuaXNBcnJheSh2YWwpKSB7XG4gICAgcmV0dXJuIFt0aGlzLmNhc3RGb3JRdWVyeShudWxsLCB2YWwsIGNvbnRleHQpXTtcbiAgfVxuICByZXR1cm4gdmFsLm1hcChmdW5jdGlvbihtKSB7XG4gICAgcmV0dXJuIF90aGlzLmNhc3RGb3JRdWVyeShudWxsLCBtLCBjb250ZXh0KTtcbiAgfSk7XG59XG5cbi8qKlxuICogSnVzdCBsaWtlIGhhbmRsZUFycmF5LCBleGNlcHQgYWxzbyBhbGxvd3MgYFtdYCBiZWNhdXNlIHN1cnByaXNpbmdseVxuICogYCRpbjogWzEsIFtdXWAgd29ya3MgZmluZVxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZnVuY3Rpb24gaGFuZGxlJGluKHZhbCwgY29udGV4dCkge1xuICBjb25zdCBfdGhpcyA9IHRoaXM7XG4gIGlmICghQXJyYXkuaXNBcnJheSh2YWwpKSB7XG4gICAgcmV0dXJuIFt0aGlzLmNhc3RGb3JRdWVyeShudWxsLCB2YWwsIGNvbnRleHQpXTtcbiAgfVxuICByZXR1cm4gdmFsLm1hcChmdW5jdGlvbihtKSB7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkobSkgJiYgbS5sZW5ndGggPT09IDApIHtcbiAgICAgIHJldHVybiBtO1xuICAgIH1cbiAgICByZXR1cm4gX3RoaXMuY2FzdEZvclF1ZXJ5KG51bGwsIG0sIGNvbnRleHQpO1xuICB9KTtcbn1cblxuLyohXG4gKiBpZ25vcmVcbiAqL1xuXG5TY2hlbWFUeXBlLnByb3RvdHlwZS4kY29uZGl0aW9uYWxIYW5kbGVycyA9IHtcbiAgJGFsbDogaGFuZGxlQXJyYXksXG4gICRlcTogaGFuZGxlU2luZ2xlLFxuICAkaW46IGhhbmRsZSRpbixcbiAgJG5lOiBoYW5kbGVTaW5nbGUsXG4gICRuaW46IGhhbmRsZSRpbixcbiAgJGV4aXN0czogJGV4aXN0cyxcbiAgJHR5cGU6ICR0eXBlXG59O1xuXG4vKipcbiAqIENhc3QgdGhlIGdpdmVuIHZhbHVlIHdpdGggdGhlIGdpdmVuIG9wdGlvbmFsIHF1ZXJ5IG9wZXJhdG9yLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBbJGNvbmRpdGlvbmFsXSBxdWVyeSBvcGVyYXRvciwgbGlrZSBgJGVxYCBvciBgJGluYFxuICogQHBhcmFtIHtBbnl9IHZhbFxuICogQHBhcmFtIHtRdWVyeX0gY29udGV4dFxuICogQHJldHVybiB7QW55fVxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuU2NoZW1hVHlwZS5wcm90b3R5cGUuY2FzdEZvclF1ZXJ5ID0gZnVuY3Rpb24oJGNvbmRpdGlvbmFsLCB2YWwsIGNvbnRleHQpIHtcbiAgbGV0IGhhbmRsZXI7XG4gIGlmICgkY29uZGl0aW9uYWwgIT0gbnVsbCkge1xuICAgIGhhbmRsZXIgPSB0aGlzLiRjb25kaXRpb25hbEhhbmRsZXJzWyRjb25kaXRpb25hbF07XG4gICAgaWYgKCFoYW5kbGVyKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0NhblxcJ3QgdXNlICcgKyAkY29uZGl0aW9uYWwpO1xuICAgIH1cbiAgICByZXR1cm4gaGFuZGxlci5jYWxsKHRoaXMsIHZhbCwgY29udGV4dCk7XG4gIH1cblxuICByZXR1cm4gdGhpcy5hcHBseVNldHRlcnModmFsLCBjb250ZXh0KTtcbn07XG5cbi8qKlxuICogU2V0ICYgR2V0IHRoZSBgY2hlY2tSZXF1aXJlZGAgZnVuY3Rpb25cbiAqIE92ZXJyaWRlIHRoZSBmdW5jdGlvbiB0aGUgcmVxdWlyZWQgdmFsaWRhdG9yIHVzZXMgdG8gY2hlY2sgd2hldGhlciBhIHZhbHVlXG4gKiBwYXNzZXMgdGhlIGByZXF1aXJlZGAgY2hlY2suIE92ZXJyaWRlIHRoaXMgb24gdGhlIGluZGl2aWR1YWwgU2NoZW1hVHlwZS5cbiAqXG4gKiAjIyMjIEV4YW1wbGU6XG4gKlxuICogICAgIC8vIFVzZSB0aGlzIHRvIGFsbG93IGVtcHR5IHN0cmluZ3MgdG8gcGFzcyB0aGUgYHJlcXVpcmVkYCB2YWxpZGF0b3JcbiAqICAgICBtb25nb29zZS5TY2hlbWEuVHlwZXMuU3RyaW5nLmNoZWNrUmVxdWlyZWQodiA9PiB0eXBlb2YgdiA9PT0gJ3N0cmluZycpO1xuICpcbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtmbl0gSWYgc2V0LCB3aWxsIG92ZXJ3cml0ZSB0aGUgY3VycmVudCBzZXQgZnVuY3Rpb25cbiAqIEByZXR1cm4ge0Z1bmN0aW9ufSBUaGUgaW5wdXQgYGZuYCBvciB0aGUgYWxyZWFkeSBzZXQgZnVuY3Rpb25cbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBTY2hlbWFUeXBlXG4gKiBAZnVuY3Rpb24gY2hlY2tSZXF1aXJlZFxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5TY2hlbWFUeXBlLmNoZWNrUmVxdWlyZWQgPSBmdW5jdGlvbihmbikge1xuICBpZiAoYXJndW1lbnRzLmxlbmd0aCAhPT0gMCkge1xuICAgIHRoaXMuX2NoZWNrUmVxdWlyZWQgPSBmbjtcbiAgfVxuXG4gIHJldHVybiB0aGlzLl9jaGVja1JlcXVpcmVkO1xufTtcblxuLyoqXG4gKiBEZWZhdWx0IGNoZWNrIGZvciBpZiB0aGlzIHBhdGggc2F0aXNmaWVzIHRoZSBgcmVxdWlyZWRgIHZhbGlkYXRvci5cbiAqXG4gKiBAcGFyYW0ge0FueX0gdmFsXG4gKiBAcmV0dXJuIHtCb29sZWFufSBgdHJ1ZWAgd2hlbiB0aGUgdmFsdWUgaXMgbm90IGBudWxsYCwgYGZhbHNlYCBvdGhlcndpc2VcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cblNjaGVtYVR5cGUucHJvdG90eXBlLmNoZWNrUmVxdWlyZWQgPSBmdW5jdGlvbih2YWwpIHtcbiAgcmV0dXJuIHZhbCAhPSBudWxsO1xufTtcblxuLyoqXG4gKiBDbG9uZSB0aGUgY3VycmVudCBTY2hlbWFUeXBlXG4gKlxuICogQHJldHVybiB7U2NoZW1hVHlwZX0gVGhlIGNsb25lZCBTY2hlbWFUeXBlIGluc3RhbmNlXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5TY2hlbWFUeXBlLnByb3RvdHlwZS5jbG9uZSA9IGZ1bmN0aW9uKCkge1xuICBjb25zdCBvcHRpb25zID0gT2JqZWN0LmFzc2lnbih7fSwgdGhpcy5vcHRpb25zKTtcbiAgY29uc3Qgc2NoZW1hdHlwZSA9IG5ldyB0aGlzLmNvbnN0cnVjdG9yKHRoaXMucGF0aCwgb3B0aW9ucywgdGhpcy5pbnN0YW5jZSk7XG4gIHNjaGVtYXR5cGUudmFsaWRhdG9ycyA9IHRoaXMudmFsaWRhdG9ycy5zbGljZSgpO1xuICBpZiAodGhpcy5yZXF1aXJlZFZhbGlkYXRvciAhPT0gdW5kZWZpbmVkKSBzY2hlbWF0eXBlLnJlcXVpcmVkVmFsaWRhdG9yID0gdGhpcy5yZXF1aXJlZFZhbGlkYXRvcjtcbiAgaWYgKHRoaXMuZGVmYXVsdFZhbHVlICE9PSB1bmRlZmluZWQpIHNjaGVtYXR5cGUuZGVmYXVsdFZhbHVlID0gdGhpcy5kZWZhdWx0VmFsdWU7XG4gIGlmICh0aGlzLiRpbW11dGFibGUgIT09IHVuZGVmaW5lZCAmJiB0aGlzLm9wdGlvbnMuaW1tdXRhYmxlID09PSB1bmRlZmluZWQpIHtcbiAgICBzY2hlbWF0eXBlLiRpbW11dGFibGUgPSB0aGlzLiRpbW11dGFibGU7XG5cbiAgICBoYW5kbGVJbW11dGFibGUoc2NoZW1hdHlwZSk7XG4gIH1cbiAgaWYgKHRoaXMuX2luZGV4ICE9PSB1bmRlZmluZWQpIHNjaGVtYXR5cGUuX2luZGV4ID0gdGhpcy5faW5kZXg7XG4gIGlmICh0aGlzLnNlbGVjdGVkICE9PSB1bmRlZmluZWQpIHNjaGVtYXR5cGUuc2VsZWN0ZWQgPSB0aGlzLnNlbGVjdGVkO1xuICBpZiAodGhpcy5pc1JlcXVpcmVkICE9PSB1bmRlZmluZWQpIHNjaGVtYXR5cGUuaXNSZXF1aXJlZCA9IHRoaXMuaXNSZXF1aXJlZDtcbiAgaWYgKHRoaXMub3JpZ2luYWxSZXF1aXJlZFZhbHVlICE9PSB1bmRlZmluZWQpIHNjaGVtYXR5cGUub3JpZ2luYWxSZXF1aXJlZFZhbHVlID0gdGhpcy5vcmlnaW5hbFJlcXVpcmVkVmFsdWU7XG4gIHNjaGVtYXR5cGUuZ2V0dGVycyA9IHRoaXMuZ2V0dGVycy5zbGljZSgpO1xuICBzY2hlbWF0eXBlLnNldHRlcnMgPSB0aGlzLnNldHRlcnMuc2xpY2UoKTtcbiAgcmV0dXJuIHNjaGVtYXR5cGU7XG59O1xuXG4vKiFcbiAqIE1vZHVsZSBleHBvcnRzLlxuICovXG5cbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0cyA9IFNjaGVtYVR5cGU7XG5cbmV4cG9ydHMuQ2FzdEVycm9yID0gQ2FzdEVycm9yO1xuXG5leHBvcnRzLlZhbGlkYXRvckVycm9yID0gVmFsaWRhdG9yRXJyb3I7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/mongoose/lib/schemaType.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/mongoose/lib/stateMachine.js":
/*!***************************************************!*\
  !*** ./node_modules/mongoose/lib/stateMachine.js ***!
  \***************************************************/
/***/ ((module, exports, __webpack_require__) => {

eval("\n/*!\n * Module dependencies.\n */\n\n\n\nconst utils = __webpack_require__(/*! ./utils */ \"(ssr)/./node_modules/mongoose/lib/utils.js\"); // eslint-disable-line no-unused-vars\n\n/**\n * StateMachine represents a minimal `interface` for the\n * constructors it builds via StateMachine.ctor(...).\n *\n * @api private\n */\n\nconst StateMachine = module.exports = exports = function StateMachine() {\n};\n\n/**\n * StateMachine.ctor('state1', 'state2', ...)\n * A factory method for subclassing StateMachine.\n * The arguments are a list of states. For each state,\n * the constructor's prototype gets state transition\n * methods named after each state. These transition methods\n * place their path argument into the given state.\n *\n * @param {String} state\n * @param {String} [state]\n * @return {Function} subclass constructor\n * @api private\n */\n\nStateMachine.ctor = function() {\n  const states = [...arguments];\n\n  const ctor = function() {\n    StateMachine.apply(this, arguments);\n    this.paths = {};\n    this.states = {};\n  };\n\n  ctor.prototype = new StateMachine();\n\n  ctor.prototype.stateNames = states;\n\n  states.forEach(function(state) {\n    // Changes the `path`'s state to `state`.\n    ctor.prototype[state] = function(path) {\n      this._changeState(path, state);\n    };\n  });\n\n  return ctor;\n};\n\n/**\n * This function is wrapped by the state change functions:\n *\n * - `require(path)`\n * - `modify(path)`\n * - `init(path)`\n *\n * @api private\n */\n\nStateMachine.prototype._changeState = function _changeState(path, nextState) {\n  const prevBucket = this.states[this.paths[path]];\n  if (prevBucket) delete prevBucket[path];\n\n  this.paths[path] = nextState;\n  this.states[nextState] = this.states[nextState] || {};\n  this.states[nextState][path] = true;\n};\n\n/*!\n * ignore\n */\n\nStateMachine.prototype.clear = function clear(state) {\n  if (this.states[state] == null) {\n    return;\n  }\n  const keys = Object.keys(this.states[state]);\n  let i = keys.length;\n  let path;\n\n  while (i--) {\n    path = keys[i];\n    delete this.states[state][path];\n    delete this.paths[path];\n  }\n};\n\n/*!\n * ignore\n */\n\nStateMachine.prototype.clearPath = function clearPath(path) {\n  const state = this.paths[path];\n  if (!state) {\n    return;\n  }\n  delete this.paths[path];\n  delete this.states[state][path];\n};\n\n/**\n * Gets the paths for the given state, or empty object `{}` if none.\n * @api private\n */\n\nStateMachine.prototype.getStatePaths = function getStatePaths(state) {\n  if (this.states[state] != null) {\n    return this.states[state];\n  }\n  return {};\n};\n\n/**\n * Checks to see if at least one path is in the states passed in via `arguments`\n * e.g., this.some('required', 'inited')\n *\n * @param {String} state that we want to check for.\n * @api private\n */\n\nStateMachine.prototype.some = function some() {\n  const _this = this;\n  const what = arguments.length ? arguments : this.stateNames;\n  return Array.prototype.some.call(what, function(state) {\n    if (_this.states[state] == null) {\n      return false;\n    }\n    return Object.keys(_this.states[state]).length;\n  });\n};\n\n/**\n * This function builds the functions that get assigned to `forEach` and `map`,\n * since both of those methods share a lot of the same logic.\n *\n * @param {String} iterMethod is either 'forEach' or 'map'\n * @return {Function}\n * @api private\n */\n\nStateMachine.prototype._iter = function _iter(iterMethod) {\n  return function() {\n    let states = [...arguments];\n    const callback = states.pop();\n\n    if (!states.length) states = this.stateNames;\n\n    const _this = this;\n\n    const paths = states.reduce(function(paths, state) {\n      if (_this.states[state] == null) {\n        return paths;\n      }\n      return paths.concat(Object.keys(_this.states[state]));\n    }, []);\n\n    return paths[iterMethod](function(path, i, paths) {\n      return callback(path, i, paths);\n    });\n  };\n};\n\n/**\n * Iterates over the paths that belong to one of the parameter states.\n *\n * The function profile can look like:\n * this.forEach(state1, fn);         // iterates over all paths in state1\n * this.forEach(state1, state2, fn); // iterates over all paths in state1 or state2\n * this.forEach(fn);                 // iterates over all paths in all states\n *\n * @param {String} [state]\n * @param {String} [state]\n * @param {Function} callback\n * @api private\n */\n\nStateMachine.prototype.forEach = function forEach() {\n  this.forEach = this._iter('forEach');\n  return this.forEach.apply(this, arguments);\n};\n\n/**\n * Maps over the paths that belong to one of the parameter states.\n *\n * The function profile can look like:\n * this.forEach(state1, fn);         // iterates over all paths in state1\n * this.forEach(state1, state2, fn); // iterates over all paths in state1 or state2\n * this.forEach(fn);                 // iterates over all paths in all states\n *\n * @param {String} [state]\n * @param {String} [state]\n * @param {Function} callback\n * @return {Array}\n * @api private\n */\n\nStateMachine.prototype.map = function map() {\n  this.map = this._iter('map');\n  return this.map.apply(this, arguments);\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbW9uZ29vc2UvbGliL3N0YXRlTWFjaGluZS5qcyIsIm1hcHBpbmdzIjoiO0FBQ0E7QUFDQTtBQUNBOztBQUVhOztBQUViLGNBQWMsbUJBQU8sQ0FBQywyREFBUyxHQUFHOztBQUVsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixZQUFZLFVBQVU7QUFDdEI7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSwwREFBMEQ7QUFDMUQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFlBQVk7QUFDWjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQztBQUNyQyxxQ0FBcUM7QUFDckMscUNBQXFDO0FBQ3JDO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixXQUFXLFVBQVU7QUFDckI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQztBQUNyQyxxQ0FBcUM7QUFDckMscUNBQXFDO0FBQ3JDO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixXQUFXLFVBQVU7QUFDckIsWUFBWTtBQUNaO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9hcHAxLy4vbm9kZV9tb2R1bGVzL21vbmdvb3NlL2xpYi9zdGF0ZU1hY2hpbmUuanM/OTA3MiJdLCJzb3VyY2VzQ29udGVudCI6WyJcbi8qIVxuICogTW9kdWxlIGRlcGVuZGVuY2llcy5cbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbmNvbnN0IHV0aWxzID0gcmVxdWlyZSgnLi91dGlscycpOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXVudXNlZC12YXJzXG5cbi8qKlxuICogU3RhdGVNYWNoaW5lIHJlcHJlc2VudHMgYSBtaW5pbWFsIGBpbnRlcmZhY2VgIGZvciB0aGVcbiAqIGNvbnN0cnVjdG9ycyBpdCBidWlsZHMgdmlhIFN0YXRlTWFjaGluZS5jdG9yKC4uLikuXG4gKlxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuY29uc3QgU3RhdGVNYWNoaW5lID0gbW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzID0gZnVuY3Rpb24gU3RhdGVNYWNoaW5lKCkge1xufTtcblxuLyoqXG4gKiBTdGF0ZU1hY2hpbmUuY3Rvcignc3RhdGUxJywgJ3N0YXRlMicsIC4uLilcbiAqIEEgZmFjdG9yeSBtZXRob2QgZm9yIHN1YmNsYXNzaW5nIFN0YXRlTWFjaGluZS5cbiAqIFRoZSBhcmd1bWVudHMgYXJlIGEgbGlzdCBvZiBzdGF0ZXMuIEZvciBlYWNoIHN0YXRlLFxuICogdGhlIGNvbnN0cnVjdG9yJ3MgcHJvdG90eXBlIGdldHMgc3RhdGUgdHJhbnNpdGlvblxuICogbWV0aG9kcyBuYW1lZCBhZnRlciBlYWNoIHN0YXRlLiBUaGVzZSB0cmFuc2l0aW9uIG1ldGhvZHNcbiAqIHBsYWNlIHRoZWlyIHBhdGggYXJndW1lbnQgaW50byB0aGUgZ2l2ZW4gc3RhdGUuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IHN0YXRlXG4gKiBAcGFyYW0ge1N0cmluZ30gW3N0YXRlXVxuICogQHJldHVybiB7RnVuY3Rpb259IHN1YmNsYXNzIGNvbnN0cnVjdG9yXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5TdGF0ZU1hY2hpbmUuY3RvciA9IGZ1bmN0aW9uKCkge1xuICBjb25zdCBzdGF0ZXMgPSBbLi4uYXJndW1lbnRzXTtcblxuICBjb25zdCBjdG9yID0gZnVuY3Rpb24oKSB7XG4gICAgU3RhdGVNYWNoaW5lLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgdGhpcy5wYXRocyA9IHt9O1xuICAgIHRoaXMuc3RhdGVzID0ge307XG4gIH07XG5cbiAgY3Rvci5wcm90b3R5cGUgPSBuZXcgU3RhdGVNYWNoaW5lKCk7XG5cbiAgY3Rvci5wcm90b3R5cGUuc3RhdGVOYW1lcyA9IHN0YXRlcztcblxuICBzdGF0ZXMuZm9yRWFjaChmdW5jdGlvbihzdGF0ZSkge1xuICAgIC8vIENoYW5nZXMgdGhlIGBwYXRoYCdzIHN0YXRlIHRvIGBzdGF0ZWAuXG4gICAgY3Rvci5wcm90b3R5cGVbc3RhdGVdID0gZnVuY3Rpb24ocGF0aCkge1xuICAgICAgdGhpcy5fY2hhbmdlU3RhdGUocGF0aCwgc3RhdGUpO1xuICAgIH07XG4gIH0pO1xuXG4gIHJldHVybiBjdG9yO1xufTtcblxuLyoqXG4gKiBUaGlzIGZ1bmN0aW9uIGlzIHdyYXBwZWQgYnkgdGhlIHN0YXRlIGNoYW5nZSBmdW5jdGlvbnM6XG4gKlxuICogLSBgcmVxdWlyZShwYXRoKWBcbiAqIC0gYG1vZGlmeShwYXRoKWBcbiAqIC0gYGluaXQocGF0aClgXG4gKlxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuU3RhdGVNYWNoaW5lLnByb3RvdHlwZS5fY2hhbmdlU3RhdGUgPSBmdW5jdGlvbiBfY2hhbmdlU3RhdGUocGF0aCwgbmV4dFN0YXRlKSB7XG4gIGNvbnN0IHByZXZCdWNrZXQgPSB0aGlzLnN0YXRlc1t0aGlzLnBhdGhzW3BhdGhdXTtcbiAgaWYgKHByZXZCdWNrZXQpIGRlbGV0ZSBwcmV2QnVja2V0W3BhdGhdO1xuXG4gIHRoaXMucGF0aHNbcGF0aF0gPSBuZXh0U3RhdGU7XG4gIHRoaXMuc3RhdGVzW25leHRTdGF0ZV0gPSB0aGlzLnN0YXRlc1tuZXh0U3RhdGVdIHx8IHt9O1xuICB0aGlzLnN0YXRlc1tuZXh0U3RhdGVdW3BhdGhdID0gdHJ1ZTtcbn07XG5cbi8qIVxuICogaWdub3JlXG4gKi9cblxuU3RhdGVNYWNoaW5lLnByb3RvdHlwZS5jbGVhciA9IGZ1bmN0aW9uIGNsZWFyKHN0YXRlKSB7XG4gIGlmICh0aGlzLnN0YXRlc1tzdGF0ZV0gPT0gbnVsbCkge1xuICAgIHJldHVybjtcbiAgfVxuICBjb25zdCBrZXlzID0gT2JqZWN0LmtleXModGhpcy5zdGF0ZXNbc3RhdGVdKTtcbiAgbGV0IGkgPSBrZXlzLmxlbmd0aDtcbiAgbGV0IHBhdGg7XG5cbiAgd2hpbGUgKGktLSkge1xuICAgIHBhdGggPSBrZXlzW2ldO1xuICAgIGRlbGV0ZSB0aGlzLnN0YXRlc1tzdGF0ZV1bcGF0aF07XG4gICAgZGVsZXRlIHRoaXMucGF0aHNbcGF0aF07XG4gIH1cbn07XG5cbi8qIVxuICogaWdub3JlXG4gKi9cblxuU3RhdGVNYWNoaW5lLnByb3RvdHlwZS5jbGVhclBhdGggPSBmdW5jdGlvbiBjbGVhclBhdGgocGF0aCkge1xuICBjb25zdCBzdGF0ZSA9IHRoaXMucGF0aHNbcGF0aF07XG4gIGlmICghc3RhdGUpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgZGVsZXRlIHRoaXMucGF0aHNbcGF0aF07XG4gIGRlbGV0ZSB0aGlzLnN0YXRlc1tzdGF0ZV1bcGF0aF07XG59O1xuXG4vKipcbiAqIEdldHMgdGhlIHBhdGhzIGZvciB0aGUgZ2l2ZW4gc3RhdGUsIG9yIGVtcHR5IG9iamVjdCBge31gIGlmIG5vbmUuXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5TdGF0ZU1hY2hpbmUucHJvdG90eXBlLmdldFN0YXRlUGF0aHMgPSBmdW5jdGlvbiBnZXRTdGF0ZVBhdGhzKHN0YXRlKSB7XG4gIGlmICh0aGlzLnN0YXRlc1tzdGF0ZV0gIT0gbnVsbCkge1xuICAgIHJldHVybiB0aGlzLnN0YXRlc1tzdGF0ZV07XG4gIH1cbiAgcmV0dXJuIHt9O1xufTtcblxuLyoqXG4gKiBDaGVja3MgdG8gc2VlIGlmIGF0IGxlYXN0IG9uZSBwYXRoIGlzIGluIHRoZSBzdGF0ZXMgcGFzc2VkIGluIHZpYSBgYXJndW1lbnRzYFxuICogZS5nLiwgdGhpcy5zb21lKCdyZXF1aXJlZCcsICdpbml0ZWQnKVxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBzdGF0ZSB0aGF0IHdlIHdhbnQgdG8gY2hlY2sgZm9yLlxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuU3RhdGVNYWNoaW5lLnByb3RvdHlwZS5zb21lID0gZnVuY3Rpb24gc29tZSgpIHtcbiAgY29uc3QgX3RoaXMgPSB0aGlzO1xuICBjb25zdCB3aGF0ID0gYXJndW1lbnRzLmxlbmd0aCA/IGFyZ3VtZW50cyA6IHRoaXMuc3RhdGVOYW1lcztcbiAgcmV0dXJuIEFycmF5LnByb3RvdHlwZS5zb21lLmNhbGwod2hhdCwgZnVuY3Rpb24oc3RhdGUpIHtcbiAgICBpZiAoX3RoaXMuc3RhdGVzW3N0YXRlXSA9PSBudWxsKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHJldHVybiBPYmplY3Qua2V5cyhfdGhpcy5zdGF0ZXNbc3RhdGVdKS5sZW5ndGg7XG4gIH0pO1xufTtcblxuLyoqXG4gKiBUaGlzIGZ1bmN0aW9uIGJ1aWxkcyB0aGUgZnVuY3Rpb25zIHRoYXQgZ2V0IGFzc2lnbmVkIHRvIGBmb3JFYWNoYCBhbmQgYG1hcGAsXG4gKiBzaW5jZSBib3RoIG9mIHRob3NlIG1ldGhvZHMgc2hhcmUgYSBsb3Qgb2YgdGhlIHNhbWUgbG9naWMuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IGl0ZXJNZXRob2QgaXMgZWl0aGVyICdmb3JFYWNoJyBvciAnbWFwJ1xuICogQHJldHVybiB7RnVuY3Rpb259XG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5TdGF0ZU1hY2hpbmUucHJvdG90eXBlLl9pdGVyID0gZnVuY3Rpb24gX2l0ZXIoaXRlck1ldGhvZCkge1xuICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgbGV0IHN0YXRlcyA9IFsuLi5hcmd1bWVudHNdO1xuICAgIGNvbnN0IGNhbGxiYWNrID0gc3RhdGVzLnBvcCgpO1xuXG4gICAgaWYgKCFzdGF0ZXMubGVuZ3RoKSBzdGF0ZXMgPSB0aGlzLnN0YXRlTmFtZXM7XG5cbiAgICBjb25zdCBfdGhpcyA9IHRoaXM7XG5cbiAgICBjb25zdCBwYXRocyA9IHN0YXRlcy5yZWR1Y2UoZnVuY3Rpb24ocGF0aHMsIHN0YXRlKSB7XG4gICAgICBpZiAoX3RoaXMuc3RhdGVzW3N0YXRlXSA9PSBudWxsKSB7XG4gICAgICAgIHJldHVybiBwYXRocztcbiAgICAgIH1cbiAgICAgIHJldHVybiBwYXRocy5jb25jYXQoT2JqZWN0LmtleXMoX3RoaXMuc3RhdGVzW3N0YXRlXSkpO1xuICAgIH0sIFtdKTtcblxuICAgIHJldHVybiBwYXRoc1tpdGVyTWV0aG9kXShmdW5jdGlvbihwYXRoLCBpLCBwYXRocykge1xuICAgICAgcmV0dXJuIGNhbGxiYWNrKHBhdGgsIGksIHBhdGhzKTtcbiAgICB9KTtcbiAgfTtcbn07XG5cbi8qKlxuICogSXRlcmF0ZXMgb3ZlciB0aGUgcGF0aHMgdGhhdCBiZWxvbmcgdG8gb25lIG9mIHRoZSBwYXJhbWV0ZXIgc3RhdGVzLlxuICpcbiAqIFRoZSBmdW5jdGlvbiBwcm9maWxlIGNhbiBsb29rIGxpa2U6XG4gKiB0aGlzLmZvckVhY2goc3RhdGUxLCBmbik7ICAgICAgICAgLy8gaXRlcmF0ZXMgb3ZlciBhbGwgcGF0aHMgaW4gc3RhdGUxXG4gKiB0aGlzLmZvckVhY2goc3RhdGUxLCBzdGF0ZTIsIGZuKTsgLy8gaXRlcmF0ZXMgb3ZlciBhbGwgcGF0aHMgaW4gc3RhdGUxIG9yIHN0YXRlMlxuICogdGhpcy5mb3JFYWNoKGZuKTsgICAgICAgICAgICAgICAgIC8vIGl0ZXJhdGVzIG92ZXIgYWxsIHBhdGhzIGluIGFsbCBzdGF0ZXNcbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gW3N0YXRlXVxuICogQHBhcmFtIHtTdHJpbmd9IFtzdGF0ZV1cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5TdGF0ZU1hY2hpbmUucHJvdG90eXBlLmZvckVhY2ggPSBmdW5jdGlvbiBmb3JFYWNoKCkge1xuICB0aGlzLmZvckVhY2ggPSB0aGlzLl9pdGVyKCdmb3JFYWNoJyk7XG4gIHJldHVybiB0aGlzLmZvckVhY2guYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbn07XG5cbi8qKlxuICogTWFwcyBvdmVyIHRoZSBwYXRocyB0aGF0IGJlbG9uZyB0byBvbmUgb2YgdGhlIHBhcmFtZXRlciBzdGF0ZXMuXG4gKlxuICogVGhlIGZ1bmN0aW9uIHByb2ZpbGUgY2FuIGxvb2sgbGlrZTpcbiAqIHRoaXMuZm9yRWFjaChzdGF0ZTEsIGZuKTsgICAgICAgICAvLyBpdGVyYXRlcyBvdmVyIGFsbCBwYXRocyBpbiBzdGF0ZTFcbiAqIHRoaXMuZm9yRWFjaChzdGF0ZTEsIHN0YXRlMiwgZm4pOyAvLyBpdGVyYXRlcyBvdmVyIGFsbCBwYXRocyBpbiBzdGF0ZTEgb3Igc3RhdGUyXG4gKiB0aGlzLmZvckVhY2goZm4pOyAgICAgICAgICAgICAgICAgLy8gaXRlcmF0ZXMgb3ZlciBhbGwgcGF0aHMgaW4gYWxsIHN0YXRlc1xuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBbc3RhdGVdXG4gKiBAcGFyYW0ge1N0cmluZ30gW3N0YXRlXVxuICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2tcbiAqIEByZXR1cm4ge0FycmF5fVxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuU3RhdGVNYWNoaW5lLnByb3RvdHlwZS5tYXAgPSBmdW5jdGlvbiBtYXAoKSB7XG4gIHRoaXMubWFwID0gdGhpcy5faXRlcignbWFwJyk7XG4gIHJldHVybiB0aGlzLm1hcC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xufTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/mongoose/lib/stateMachine.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/mongoose/lib/types/array/index.js":
/*!********************************************************!*\
  !*** ./node_modules/mongoose/lib/types/array/index.js ***!
  \********************************************************/
/***/ ((module, exports, __webpack_require__) => {

eval("/*!\n * Module dependencies.\n */\n\n\n\nconst Document = __webpack_require__(/*! ../../document */ \"(ssr)/./node_modules/mongoose/lib/document.js\");\nconst mongooseArrayMethods = __webpack_require__(/*! ./methods */ \"(ssr)/./node_modules/mongoose/lib/types/array/methods/index.js\");\n\nconst arrayAtomicsSymbol = (__webpack_require__(/*! ../../helpers/symbols */ \"(ssr)/./node_modules/mongoose/lib/helpers/symbols.js\").arrayAtomicsSymbol);\nconst arrayAtomicsBackupSymbol = (__webpack_require__(/*! ../../helpers/symbols */ \"(ssr)/./node_modules/mongoose/lib/helpers/symbols.js\").arrayAtomicsBackupSymbol);\nconst arrayParentSymbol = (__webpack_require__(/*! ../../helpers/symbols */ \"(ssr)/./node_modules/mongoose/lib/helpers/symbols.js\").arrayParentSymbol);\nconst arrayPathSymbol = (__webpack_require__(/*! ../../helpers/symbols */ \"(ssr)/./node_modules/mongoose/lib/helpers/symbols.js\").arrayPathSymbol);\nconst arraySchemaSymbol = (__webpack_require__(/*! ../../helpers/symbols */ \"(ssr)/./node_modules/mongoose/lib/helpers/symbols.js\").arraySchemaSymbol);\n\n/**\n * Mongoose Array constructor.\n *\n * #### Note:\n *\n * _Values always have to be passed to the constructor to initialize, otherwise `MongooseArray#push` will mark the array as modified._\n *\n * @param {Array} values\n * @param {String} path\n * @param {Document} doc parent document\n * @api private\n * @inherits Array https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array\n * @see https://bit.ly/f6CnZU\n */\nconst _basePush = Array.prototype.push;\nconst numberRE = /^\\d+$/;\n\nfunction MongooseArray(values, path, doc, schematype) {\n  let __array;\n\n  if (Array.isArray(values)) {\n    const len = values.length;\n\n    // Perf optimizations for small arrays: much faster to use `...` than `for` + `push`,\n    // but large arrays may cause stack overflows. And for arrays of length 0/1, just\n    // modifying the array is faster. Seems small, but adds up when you have a document\n    // with thousands of nested arrays.\n    if (len === 0) {\n      __array = new Array();\n    } else if (len === 1) {\n      __array = new Array(1);\n      __array[0] = values[0];\n    } else if (len < 10000) {\n      __array = new Array();\n      _basePush.apply(__array, values);\n    } else {\n      __array = new Array();\n      for (let i = 0; i < len; ++i) {\n        _basePush.call(__array, values[i]);\n      }\n    }\n  } else {\n    __array = [];\n  }\n\n  const internals = {\n    [arrayAtomicsSymbol]: {},\n    [arrayAtomicsBackupSymbol]: void 0,\n    [arrayPathSymbol]: path,\n    [arraySchemaSymbol]: schematype,\n    [arrayParentSymbol]: void 0,\n    isMongooseArray: true,\n    isMongooseArrayProxy: true,\n    __array: __array\n  };\n\n  if (values && values[arrayAtomicsSymbol] != null) {\n    internals[arrayAtomicsSymbol] = values[arrayAtomicsSymbol];\n  }\n\n  // Because doc comes from the context of another function, doc === global\n  // can happen if there was a null somewhere up the chain (see #3020)\n  // RB Jun 17, 2015 updated to check for presence of expected paths instead\n  // to make more proof against unusual node environments\n  if (doc != null && doc instanceof Document) {\n    internals[arrayParentSymbol] = doc;\n    internals[arraySchemaSymbol] = schematype || doc.schema.path(path);\n  }\n\n  const proxy = new Proxy(__array, {\n    get: function(target, prop) {\n      if (internals.hasOwnProperty(prop)) {\n        return internals[prop];\n      }\n      if (mongooseArrayMethods.hasOwnProperty(prop)) {\n        return mongooseArrayMethods[prop];\n      }\n      if (typeof prop === 'string' && numberRE.test(prop) && schematype?.$embeddedSchemaType != null) {\n        return schematype.$embeddedSchemaType.applyGetters(__array[prop], doc);\n      }\n\n      return __array[prop];\n    },\n    set: function(target, prop, value) {\n      if (typeof prop === 'string' && numberRE.test(prop)) {\n        mongooseArrayMethods.set.call(proxy, prop, value, false);\n      } else if (internals.hasOwnProperty(prop)) {\n        internals[prop] = value;\n      } else {\n        __array[prop] = value;\n      }\n\n      return true;\n    }\n  });\n\n  return proxy;\n}\n\n/*!\n * Module exports.\n */\n\nmodule.exports = exports = MongooseArray;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbW9uZ29vc2UvbGliL3R5cGVzL2FycmF5L2luZGV4LmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTs7QUFFYTs7QUFFYixpQkFBaUIsbUJBQU8sQ0FBQyxxRUFBZ0I7QUFDekMsNkJBQTZCLG1CQUFPLENBQUMsaUZBQVc7O0FBRWhELDJCQUEyQiw2SEFBbUQ7QUFDOUUsaUNBQWlDLG1JQUF5RDtBQUMxRiwwQkFBMEIsNEhBQWtEO0FBQzVFLHdCQUF3QiwwSEFBZ0Q7QUFDeEUsMEJBQTBCLDRIQUFrRDs7QUFFNUU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE9BQU87QUFDbEIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsVUFBVTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQSxzQkFBc0IsU0FBUztBQUMvQjtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTs7QUFFQTtBQUNBLDRCQUE0QjtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9hcHAxLy4vbm9kZV9tb2R1bGVzL21vbmdvb3NlL2xpYi90eXBlcy9hcnJheS9pbmRleC5qcz81NjJiIl0sInNvdXJjZXNDb250ZW50IjpbIi8qIVxuICogTW9kdWxlIGRlcGVuZGVuY2llcy5cbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbmNvbnN0IERvY3VtZW50ID0gcmVxdWlyZSgnLi4vLi4vZG9jdW1lbnQnKTtcbmNvbnN0IG1vbmdvb3NlQXJyYXlNZXRob2RzID0gcmVxdWlyZSgnLi9tZXRob2RzJyk7XG5cbmNvbnN0IGFycmF5QXRvbWljc1N5bWJvbCA9IHJlcXVpcmUoJy4uLy4uL2hlbHBlcnMvc3ltYm9scycpLmFycmF5QXRvbWljc1N5bWJvbDtcbmNvbnN0IGFycmF5QXRvbWljc0JhY2t1cFN5bWJvbCA9IHJlcXVpcmUoJy4uLy4uL2hlbHBlcnMvc3ltYm9scycpLmFycmF5QXRvbWljc0JhY2t1cFN5bWJvbDtcbmNvbnN0IGFycmF5UGFyZW50U3ltYm9sID0gcmVxdWlyZSgnLi4vLi4vaGVscGVycy9zeW1ib2xzJykuYXJyYXlQYXJlbnRTeW1ib2w7XG5jb25zdCBhcnJheVBhdGhTeW1ib2wgPSByZXF1aXJlKCcuLi8uLi9oZWxwZXJzL3N5bWJvbHMnKS5hcnJheVBhdGhTeW1ib2w7XG5jb25zdCBhcnJheVNjaGVtYVN5bWJvbCA9IHJlcXVpcmUoJy4uLy4uL2hlbHBlcnMvc3ltYm9scycpLmFycmF5U2NoZW1hU3ltYm9sO1xuXG4vKipcbiAqIE1vbmdvb3NlIEFycmF5IGNvbnN0cnVjdG9yLlxuICpcbiAqICMjIyMgTm90ZTpcbiAqXG4gKiBfVmFsdWVzIGFsd2F5cyBoYXZlIHRvIGJlIHBhc3NlZCB0byB0aGUgY29uc3RydWN0b3IgdG8gaW5pdGlhbGl6ZSwgb3RoZXJ3aXNlIGBNb25nb29zZUFycmF5I3B1c2hgIHdpbGwgbWFyayB0aGUgYXJyYXkgYXMgbW9kaWZpZWQuX1xuICpcbiAqIEBwYXJhbSB7QXJyYXl9IHZhbHVlc1xuICogQHBhcmFtIHtTdHJpbmd9IHBhdGhcbiAqIEBwYXJhbSB7RG9jdW1lbnR9IGRvYyBwYXJlbnQgZG9jdW1lbnRcbiAqIEBhcGkgcHJpdmF0ZVxuICogQGluaGVyaXRzIEFycmF5IGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL0FycmF5XG4gKiBAc2VlIGh0dHBzOi8vYml0Lmx5L2Y2Q25aVVxuICovXG5jb25zdCBfYmFzZVB1c2ggPSBBcnJheS5wcm90b3R5cGUucHVzaDtcbmNvbnN0IG51bWJlclJFID0gL15cXGQrJC87XG5cbmZ1bmN0aW9uIE1vbmdvb3NlQXJyYXkodmFsdWVzLCBwYXRoLCBkb2MsIHNjaGVtYXR5cGUpIHtcbiAgbGV0IF9fYXJyYXk7XG5cbiAgaWYgKEFycmF5LmlzQXJyYXkodmFsdWVzKSkge1xuICAgIGNvbnN0IGxlbiA9IHZhbHVlcy5sZW5ndGg7XG5cbiAgICAvLyBQZXJmIG9wdGltaXphdGlvbnMgZm9yIHNtYWxsIGFycmF5czogbXVjaCBmYXN0ZXIgdG8gdXNlIGAuLi5gIHRoYW4gYGZvcmAgKyBgcHVzaGAsXG4gICAgLy8gYnV0IGxhcmdlIGFycmF5cyBtYXkgY2F1c2Ugc3RhY2sgb3ZlcmZsb3dzLiBBbmQgZm9yIGFycmF5cyBvZiBsZW5ndGggMC8xLCBqdXN0XG4gICAgLy8gbW9kaWZ5aW5nIHRoZSBhcnJheSBpcyBmYXN0ZXIuIFNlZW1zIHNtYWxsLCBidXQgYWRkcyB1cCB3aGVuIHlvdSBoYXZlIGEgZG9jdW1lbnRcbiAgICAvLyB3aXRoIHRob3VzYW5kcyBvZiBuZXN0ZWQgYXJyYXlzLlxuICAgIGlmIChsZW4gPT09IDApIHtcbiAgICAgIF9fYXJyYXkgPSBuZXcgQXJyYXkoKTtcbiAgICB9IGVsc2UgaWYgKGxlbiA9PT0gMSkge1xuICAgICAgX19hcnJheSA9IG5ldyBBcnJheSgxKTtcbiAgICAgIF9fYXJyYXlbMF0gPSB2YWx1ZXNbMF07XG4gICAgfSBlbHNlIGlmIChsZW4gPCAxMDAwMCkge1xuICAgICAgX19hcnJheSA9IG5ldyBBcnJheSgpO1xuICAgICAgX2Jhc2VQdXNoLmFwcGx5KF9fYXJyYXksIHZhbHVlcyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIF9fYXJyYXkgPSBuZXcgQXJyYXkoKTtcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGVuOyArK2kpIHtcbiAgICAgICAgX2Jhc2VQdXNoLmNhbGwoX19hcnJheSwgdmFsdWVzW2ldKTtcbiAgICAgIH1cbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgX19hcnJheSA9IFtdO1xuICB9XG5cbiAgY29uc3QgaW50ZXJuYWxzID0ge1xuICAgIFthcnJheUF0b21pY3NTeW1ib2xdOiB7fSxcbiAgICBbYXJyYXlBdG9taWNzQmFja3VwU3ltYm9sXTogdm9pZCAwLFxuICAgIFthcnJheVBhdGhTeW1ib2xdOiBwYXRoLFxuICAgIFthcnJheVNjaGVtYVN5bWJvbF06IHNjaGVtYXR5cGUsXG4gICAgW2FycmF5UGFyZW50U3ltYm9sXTogdm9pZCAwLFxuICAgIGlzTW9uZ29vc2VBcnJheTogdHJ1ZSxcbiAgICBpc01vbmdvb3NlQXJyYXlQcm94eTogdHJ1ZSxcbiAgICBfX2FycmF5OiBfX2FycmF5XG4gIH07XG5cbiAgaWYgKHZhbHVlcyAmJiB2YWx1ZXNbYXJyYXlBdG9taWNzU3ltYm9sXSAhPSBudWxsKSB7XG4gICAgaW50ZXJuYWxzW2FycmF5QXRvbWljc1N5bWJvbF0gPSB2YWx1ZXNbYXJyYXlBdG9taWNzU3ltYm9sXTtcbiAgfVxuXG4gIC8vIEJlY2F1c2UgZG9jIGNvbWVzIGZyb20gdGhlIGNvbnRleHQgb2YgYW5vdGhlciBmdW5jdGlvbiwgZG9jID09PSBnbG9iYWxcbiAgLy8gY2FuIGhhcHBlbiBpZiB0aGVyZSB3YXMgYSBudWxsIHNvbWV3aGVyZSB1cCB0aGUgY2hhaW4gKHNlZSAjMzAyMClcbiAgLy8gUkIgSnVuIDE3LCAyMDE1IHVwZGF0ZWQgdG8gY2hlY2sgZm9yIHByZXNlbmNlIG9mIGV4cGVjdGVkIHBhdGhzIGluc3RlYWRcbiAgLy8gdG8gbWFrZSBtb3JlIHByb29mIGFnYWluc3QgdW51c3VhbCBub2RlIGVudmlyb25tZW50c1xuICBpZiAoZG9jICE9IG51bGwgJiYgZG9jIGluc3RhbmNlb2YgRG9jdW1lbnQpIHtcbiAgICBpbnRlcm5hbHNbYXJyYXlQYXJlbnRTeW1ib2xdID0gZG9jO1xuICAgIGludGVybmFsc1thcnJheVNjaGVtYVN5bWJvbF0gPSBzY2hlbWF0eXBlIHx8IGRvYy5zY2hlbWEucGF0aChwYXRoKTtcbiAgfVxuXG4gIGNvbnN0IHByb3h5ID0gbmV3IFByb3h5KF9fYXJyYXksIHtcbiAgICBnZXQ6IGZ1bmN0aW9uKHRhcmdldCwgcHJvcCkge1xuICAgICAgaWYgKGludGVybmFscy5oYXNPd25Qcm9wZXJ0eShwcm9wKSkge1xuICAgICAgICByZXR1cm4gaW50ZXJuYWxzW3Byb3BdO1xuICAgICAgfVxuICAgICAgaWYgKG1vbmdvb3NlQXJyYXlNZXRob2RzLmhhc093blByb3BlcnR5KHByb3ApKSB7XG4gICAgICAgIHJldHVybiBtb25nb29zZUFycmF5TWV0aG9kc1twcm9wXTtcbiAgICAgIH1cbiAgICAgIGlmICh0eXBlb2YgcHJvcCA9PT0gJ3N0cmluZycgJiYgbnVtYmVyUkUudGVzdChwcm9wKSAmJiBzY2hlbWF0eXBlPy4kZW1iZWRkZWRTY2hlbWFUeXBlICE9IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIHNjaGVtYXR5cGUuJGVtYmVkZGVkU2NoZW1hVHlwZS5hcHBseUdldHRlcnMoX19hcnJheVtwcm9wXSwgZG9jKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIF9fYXJyYXlbcHJvcF07XG4gICAgfSxcbiAgICBzZXQ6IGZ1bmN0aW9uKHRhcmdldCwgcHJvcCwgdmFsdWUpIHtcbiAgICAgIGlmICh0eXBlb2YgcHJvcCA9PT0gJ3N0cmluZycgJiYgbnVtYmVyUkUudGVzdChwcm9wKSkge1xuICAgICAgICBtb25nb29zZUFycmF5TWV0aG9kcy5zZXQuY2FsbChwcm94eSwgcHJvcCwgdmFsdWUsIGZhbHNlKTtcbiAgICAgIH0gZWxzZSBpZiAoaW50ZXJuYWxzLmhhc093blByb3BlcnR5KHByb3ApKSB7XG4gICAgICAgIGludGVybmFsc1twcm9wXSA9IHZhbHVlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgX19hcnJheVtwcm9wXSA9IHZhbHVlO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH0pO1xuXG4gIHJldHVybiBwcm94eTtcbn1cblxuLyohXG4gKiBNb2R1bGUgZXhwb3J0cy5cbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHMgPSBNb25nb29zZUFycmF5O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/mongoose/lib/types/array/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/mongoose/lib/types/array/isMongooseArray.js":
/*!******************************************************************!*\
  !*** ./node_modules/mongoose/lib/types/array/isMongooseArray.js ***!
  \******************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\n\nexports.isMongooseArray = function(mongooseArray) {\n  return Array.isArray(mongooseArray) && mongooseArray.isMongooseArray;\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbW9uZ29vc2UvbGliL3R5cGVzL2FycmF5L2lzTW9uZ29vc2VBcnJheS5qcyIsIm1hcHBpbmdzIjoiQUFBYTs7QUFFYix1QkFBdUI7QUFDdkI7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL2FwcDEvLi9ub2RlX21vZHVsZXMvbW9uZ29vc2UvbGliL3R5cGVzL2FycmF5L2lzTW9uZ29vc2VBcnJheS5qcz8yYjVkIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxuZXhwb3J0cy5pc01vbmdvb3NlQXJyYXkgPSBmdW5jdGlvbihtb25nb29zZUFycmF5KSB7XG4gIHJldHVybiBBcnJheS5pc0FycmF5KG1vbmdvb3NlQXJyYXkpICYmIG1vbmdvb3NlQXJyYXkuaXNNb25nb29zZUFycmF5O1xufTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/mongoose/lib/types/array/isMongooseArray.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/mongoose/lib/types/array/methods/index.js":
/*!****************************************************************!*\
  !*** ./node_modules/mongoose/lib/types/array/methods/index.js ***!
  \****************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\n\nconst Document = __webpack_require__(/*! ../../../document */ \"(ssr)/./node_modules/mongoose/lib/document.js\");\nconst ArraySubdocument = __webpack_require__(/*! ../../arraySubdocument */ \"(ssr)/./node_modules/mongoose/lib/types/arraySubdocument.js\");\nconst MongooseError = __webpack_require__(/*! ../../../error/mongooseError */ \"(ssr)/./node_modules/mongoose/lib/error/mongooseError.js\");\nconst cleanModifiedSubpaths = __webpack_require__(/*! ../../../helpers/document/cleanModifiedSubpaths */ \"(ssr)/./node_modules/mongoose/lib/helpers/document/cleanModifiedSubpaths.js\");\nconst clone = __webpack_require__(/*! ../../../helpers/clone */ \"(ssr)/./node_modules/mongoose/lib/helpers/clone.js\");\nconst internalToObjectOptions = (__webpack_require__(/*! ../../../options */ \"(ssr)/./node_modules/mongoose/lib/options.js\").internalToObjectOptions);\nconst mpath = __webpack_require__(/*! mpath */ \"(ssr)/./node_modules/mpath/index.js\");\nconst utils = __webpack_require__(/*! ../../../utils */ \"(ssr)/./node_modules/mongoose/lib/utils.js\");\nconst isBsonType = __webpack_require__(/*! ../../../helpers/isBsonType */ \"(ssr)/./node_modules/mongoose/lib/helpers/isBsonType.js\");\n\nconst arrayAtomicsSymbol = (__webpack_require__(/*! ../../../helpers/symbols */ \"(ssr)/./node_modules/mongoose/lib/helpers/symbols.js\").arrayAtomicsSymbol);\nconst arrayParentSymbol = (__webpack_require__(/*! ../../../helpers/symbols */ \"(ssr)/./node_modules/mongoose/lib/helpers/symbols.js\").arrayParentSymbol);\nconst arrayPathSymbol = (__webpack_require__(/*! ../../../helpers/symbols */ \"(ssr)/./node_modules/mongoose/lib/helpers/symbols.js\").arrayPathSymbol);\nconst arraySchemaSymbol = (__webpack_require__(/*! ../../../helpers/symbols */ \"(ssr)/./node_modules/mongoose/lib/helpers/symbols.js\").arraySchemaSymbol);\nconst populateModelSymbol = (__webpack_require__(/*! ../../../helpers/symbols */ \"(ssr)/./node_modules/mongoose/lib/helpers/symbols.js\").populateModelSymbol);\nconst slicedSymbol = Symbol('mongoose#Array#sliced');\n\nconst _basePush = Array.prototype.push;\n\n/*!\n * ignore\n */\n\nconst methods = {\n  /**\n   * Depopulates stored atomic operation values as necessary for direct insertion to MongoDB.\n   *\n   * If no atomics exist, we return all array values after conversion.\n   *\n   * @return {Array}\n   * @method $__getAtomics\n   * @memberOf MongooseArray\n   * @instance\n   * @api private\n   */\n\n  $__getAtomics() {\n    const ret = [];\n    const keys = Object.keys(this[arrayAtomicsSymbol] || {});\n    let i = keys.length;\n\n    const opts = Object.assign({}, internalToObjectOptions, { _isNested: true });\n\n    if (i === 0) {\n      ret[0] = ['$set', this.toObject(opts)];\n      return ret;\n    }\n\n    while (i--) {\n      const op = keys[i];\n      let val = this[arrayAtomicsSymbol][op];\n\n      // the atomic values which are arrays are not MongooseArrays. we\n      // need to convert their elements as if they were MongooseArrays\n      // to handle populated arrays versus DocumentArrays properly.\n      if (utils.isMongooseObject(val)) {\n        val = val.toObject(opts);\n      } else if (Array.isArray(val)) {\n        val = this.toObject.call(val, opts);\n      } else if (val != null && Array.isArray(val.$each)) {\n        val.$each = this.toObject.call(val.$each, opts);\n      } else if (val != null && typeof val.valueOf === 'function') {\n        val = val.valueOf();\n      }\n\n      if (op === '$addToSet') {\n        val = { $each: val };\n      }\n\n      ret.push([op, val]);\n    }\n\n    return ret;\n  },\n\n  /*!\n   * ignore\n   */\n\n  $atomics() {\n    return this[arrayAtomicsSymbol];\n  },\n\n  /*!\n   * ignore\n   */\n\n  $parent() {\n    return this[arrayParentSymbol];\n  },\n\n  /*!\n   * ignore\n   */\n\n  $path() {\n    return this[arrayPathSymbol];\n  },\n\n  /**\n   * Atomically shifts the array at most one time per document `save()`.\n   *\n   * #### Note:\n   *\n   * _Calling this multiple times on an array before saving sends the same command as calling it once._\n   * _This update is implemented using the MongoDB [$pop](https://www.mongodb.com/docs/manual/reference/operator/update/pop/) method which enforces this restriction._\n   *\n   *      doc.array = [1,2,3];\n   *\n   *      const shifted = doc.array.$shift();\n   *      console.log(shifted); // 1\n   *      console.log(doc.array); // [2,3]\n   *\n   *      // no affect\n   *      shifted = doc.array.$shift();\n   *      console.log(doc.array); // [2,3]\n   *\n   *      doc.save(function (err) {\n   *        if (err) return handleError(err);\n   *\n   *        // we saved, now $shift works again\n   *        shifted = doc.array.$shift();\n   *        console.log(shifted ); // 2\n   *        console.log(doc.array); // [3]\n   *      })\n   *\n   * @api public\n   * @memberOf MongooseArray\n   * @instance\n   * @method $shift\n   * @see mongodb https://www.mongodb.com/docs/manual/reference/operator/update/pop/\n   */\n\n  $shift() {\n    this._registerAtomic('$pop', -1);\n    this._markModified();\n\n    // only allow shifting once\n    const __array = this.__array;\n    if (__array._shifted) {\n      return;\n    }\n    __array._shifted = true;\n\n    return [].shift.call(__array);\n  },\n\n  /**\n   * Pops the array atomically at most one time per document `save()`.\n   *\n   * #### NOTE:\n   *\n   * _Calling this multiple times on an array before saving sends the same command as calling it once._\n   * _This update is implemented using the MongoDB [$pop](https://www.mongodb.com/docs/manual/reference/operator/update/pop/) method which enforces this restriction._\n   *\n   *      doc.array = [1,2,3];\n   *\n   *      const popped = doc.array.$pop();\n   *      console.log(popped); // 3\n   *      console.log(doc.array); // [1,2]\n   *\n   *      // no affect\n   *      popped = doc.array.$pop();\n   *      console.log(doc.array); // [1,2]\n   *\n   *      doc.save(function (err) {\n   *        if (err) return handleError(err);\n   *\n   *        // we saved, now $pop works again\n   *        popped = doc.array.$pop();\n   *        console.log(popped); // 2\n   *        console.log(doc.array); // [1]\n   *      })\n   *\n   * @api public\n   * @method $pop\n   * @memberOf MongooseArray\n   * @instance\n   * @see mongodb https://www.mongodb.com/docs/manual/reference/operator/update/pop/\n   * @method $pop\n   * @memberOf MongooseArray\n   */\n\n  $pop() {\n    this._registerAtomic('$pop', 1);\n    this._markModified();\n\n    // only allow popping once\n    if (this._popped) {\n      return;\n    }\n    this._popped = true;\n\n    return [].pop.call(this);\n  },\n\n  /*!\n   * ignore\n   */\n\n  $schema() {\n    return this[arraySchemaSymbol];\n  },\n\n  /**\n   * Casts a member based on this arrays schema.\n   *\n   * @param {any} value\n   * @return value the casted value\n   * @method _cast\n   * @api private\n   * @memberOf MongooseArray\n   */\n\n  _cast(value) {\n    let populated = false;\n    let Model;\n\n    const parent = this[arrayParentSymbol];\n    if (parent) {\n      populated = parent.$populated(this[arrayPathSymbol], true);\n    }\n\n    if (populated && value !== null && value !== undefined) {\n      // cast to the populated Models schema\n      Model = populated.options[populateModelSymbol];\n      if (Model == null) {\n        throw new MongooseError('No populated model found for path `' + this[arrayPathSymbol] + '`. This is likely a bug in Mongoose, please report an issue on github.com/Automattic/mongoose.');\n      }\n\n      // only objects are permitted so we can safely assume that\n      // non-objects are to be interpreted as _id\n      if (Buffer.isBuffer(value) ||\n          isBsonType(value, 'ObjectId') || !utils.isObject(value)) {\n        value = { _id: value };\n      }\n\n      // gh-2399\n      // we should cast model only when it's not a discriminator\n      const isDisc = value.schema && value.schema.discriminatorMapping &&\n          value.schema.discriminatorMapping.key !== undefined;\n      if (!isDisc) {\n        value = new Model(value);\n      }\n      return this[arraySchemaSymbol].caster.applySetters(value, parent, true);\n    }\n\n    return this[arraySchemaSymbol].caster.applySetters(value, parent, false);\n  },\n\n  /**\n   * Internal helper for .map()\n   *\n   * @api private\n   * @return {Number}\n   * @method _mapCast\n   * @memberOf MongooseArray\n   */\n\n  _mapCast(val, index) {\n    return this._cast(val, this.length + index);\n  },\n\n  /**\n   * Marks this array as modified.\n   *\n   * If it bubbles up from an embedded document change, then it takes the following arguments (otherwise, takes 0 arguments)\n   *\n   * @param {ArraySubdocument} subdoc the embedded doc that invoked this method on the Array\n   * @param {String} embeddedPath the path which changed in the subdoc\n   * @method _markModified\n   * @api private\n   * @memberOf MongooseArray\n   */\n\n  _markModified(elem) {\n    const parent = this[arrayParentSymbol];\n    let dirtyPath;\n\n    if (parent) {\n      dirtyPath = this[arrayPathSymbol];\n\n      if (arguments.length) {\n        dirtyPath = dirtyPath + '.' + elem;\n      }\n\n      if (dirtyPath != null && dirtyPath.endsWith('.$')) {\n        return this;\n      }\n\n      parent.markModified(dirtyPath, arguments.length !== 0 ? elem : parent);\n    }\n\n    return this;\n  },\n\n  /**\n   * Register an atomic operation with the parent.\n   *\n   * @param {Array} op operation\n   * @param {any} val\n   * @method _registerAtomic\n   * @api private\n   * @memberOf MongooseArray\n   */\n\n  _registerAtomic(op, val) {\n    if (this[slicedSymbol]) {\n      return;\n    }\n    if (op === '$set') {\n      // $set takes precedence over all other ops.\n      // mark entire array modified.\n      this[arrayAtomicsSymbol] = { $set: val };\n      cleanModifiedSubpaths(this[arrayParentSymbol], this[arrayPathSymbol]);\n      this._markModified();\n      return this;\n    }\n\n    const atomics = this[arrayAtomicsSymbol];\n\n    // reset pop/shift after save\n    if (op === '$pop' && !('$pop' in atomics)) {\n      const _this = this;\n      this[arrayParentSymbol].once('save', function() {\n        _this._popped = _this._shifted = null;\n      });\n    }\n\n    // check for impossible $atomic combos (Mongo denies more than one\n    // $atomic op on a single path\n    if (atomics.$set || Object.keys(atomics).length && !(op in atomics)) {\n      // a different op was previously registered.\n      // save the entire thing.\n      this[arrayAtomicsSymbol] = { $set: this };\n      return this;\n    }\n\n    let selector;\n\n    if (op === '$pullAll' || op === '$addToSet') {\n      atomics[op] || (atomics[op] = []);\n      atomics[op] = atomics[op].concat(val);\n    } else if (op === '$pullDocs') {\n      const pullOp = atomics['$pull'] || (atomics['$pull'] = {});\n      if (val[0] instanceof ArraySubdocument) {\n        selector = pullOp['$or'] || (pullOp['$or'] = []);\n        Array.prototype.push.apply(selector, val.map(v => {\n          return v.toObject({\n            transform: (doc, ret) => {\n              if (v == null || v.$__ == null) {\n                return ret;\n              }\n\n              Object.keys(v.$__.activePaths.getStatePaths('default')).forEach(path => {\n                mpath.unset(path, ret);\n\n                _minimizePath(ret, path);\n              });\n\n              return ret;\n            },\n            virtuals: false\n          });\n        }));\n      } else {\n        selector = pullOp['_id'] || (pullOp['_id'] = { $in: [] });\n        selector['$in'] = selector['$in'].concat(val);\n      }\n    } else if (op === '$push') {\n      atomics.$push = atomics.$push || { $each: [] };\n      if (val != null && utils.hasUserDefinedProperty(val, '$each')) {\n        atomics.$push = val;\n      } else {\n        atomics.$push.$each = atomics.$push.$each.concat(val);\n      }\n    } else {\n      atomics[op] = val;\n    }\n\n    return this;\n  },\n\n  /**\n   * Adds values to the array if not already present.\n   *\n   * #### Example:\n   *\n   *     console.log(doc.array) // [2,3,4]\n   *     const added = doc.array.addToSet(4,5);\n   *     console.log(doc.array) // [2,3,4,5]\n   *     console.log(added)     // [5]\n   *\n   * @param {...any} [args]\n   * @return {Array} the values that were added\n   * @memberOf MongooseArray\n   * @api public\n   * @method addToSet\n   */\n\n  addToSet() {\n    _checkManualPopulation(this, arguments);\n\n    let values = [].map.call(arguments, this._mapCast, this);\n    values = this[arraySchemaSymbol].applySetters(values, this[arrayParentSymbol]);\n    const added = [];\n    let type = '';\n    if (values[0] instanceof ArraySubdocument) {\n      type = 'doc';\n    } else if (values[0] instanceof Date) {\n      type = 'date';\n    } else if (isBsonType(values[0], 'ObjectId')) {\n      type = 'ObjectId';\n    }\n\n    const rawValues = utils.isMongooseArray(values) ? values.__array : this;\n    const rawArray = utils.isMongooseArray(this) ? this.__array : this;\n\n    rawValues.forEach(function(v) {\n      let found;\n      const val = +v;\n      switch (type) {\n        case 'doc':\n          found = this.some(function(doc) {\n            return doc.equals(v);\n          });\n          break;\n        case 'date':\n          found = this.some(function(d) {\n            return +d === val;\n          });\n          break;\n        case 'ObjectId':\n          found = this.find(o => o.toString() === v.toString());\n          break;\n        default:\n          found = ~this.indexOf(v);\n          break;\n      }\n\n      if (!found) {\n        this._markModified();\n        rawArray.push(v);\n        this._registerAtomic('$addToSet', v);\n        [].push.call(added, v);\n      }\n    }, this);\n\n    return added;\n  },\n\n  /**\n   * Returns the number of pending atomic operations to send to the db for this array.\n   *\n   * @api private\n   * @return {Number}\n   * @method hasAtomics\n   * @memberOf MongooseArray\n   */\n\n  hasAtomics() {\n    if (!utils.isPOJO(this[arrayAtomicsSymbol])) {\n      return 0;\n    }\n\n    return Object.keys(this[arrayAtomicsSymbol]).length;\n  },\n\n  /**\n   * Return whether or not the `obj` is included in the array.\n   *\n   * @param {Object} obj the item to check\n   * @param {Number} fromIndex\n   * @return {Boolean}\n   * @api public\n   * @method includes\n   * @memberOf MongooseArray\n   */\n\n  includes(obj, fromIndex) {\n    const ret = this.indexOf(obj, fromIndex);\n    return ret !== -1;\n  },\n\n  /**\n   * Return the index of `obj` or `-1` if not found.\n   *\n   * @param {Object} obj the item to look for\n   * @param {Number} fromIndex\n   * @return {Number}\n   * @api public\n   * @method indexOf\n   * @memberOf MongooseArray\n   */\n\n  indexOf(obj, fromIndex) {\n    if (isBsonType(obj, 'ObjectId')) {\n      obj = obj.toString();\n    }\n\n    fromIndex = fromIndex == null ? 0 : fromIndex;\n    const len = this.length;\n    for (let i = fromIndex; i < len; ++i) {\n      if (obj == this[i]) {\n        return i;\n      }\n    }\n    return -1;\n  },\n\n  /**\n   * Helper for console.log\n   *\n   * @api public\n   * @method inspect\n   * @memberOf MongooseArray\n   */\n\n  inspect() {\n    return JSON.stringify(this);\n  },\n\n  /**\n   * Pushes items to the array non-atomically.\n   *\n   * #### Note:\n   *\n   * _marks the entire array as modified, which if saved, will store it as a `$set` operation, potentially overwritting any changes that happen between when you retrieved the object and when you save it._\n   *\n   * @param {...any} [args]\n   * @api public\n   * @method nonAtomicPush\n   * @memberOf MongooseArray\n   */\n\n  nonAtomicPush() {\n    const values = [].map.call(arguments, this._mapCast, this);\n    this._markModified();\n    const ret = [].push.apply(this, values);\n    this._registerAtomic('$set', this);\n    return ret;\n  },\n\n  /**\n   * Wraps [`Array#pop`](https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Array/pop) with proper change tracking.\n   *\n   * #### Note:\n   *\n   * _marks the entire array as modified which will pass the entire thing to $set potentially overwriting any changes that happen between when you retrieved the object and when you save it._\n   *\n   * @see MongooseArray#$pop https://mongoosejs.com/docs/api/array.html#MongooseArray.prototype.$pop()\n   * @api public\n   * @method pop\n   * @memberOf MongooseArray\n   */\n\n  pop() {\n    this._markModified();\n    const ret = [].pop.call(this);\n    this._registerAtomic('$set', this);\n    return ret;\n  },\n\n  /**\n   * Pulls items from the array atomically. Equality is determined by casting\n   * the provided value to an embedded document and comparing using\n   * [the `Document.equals()` function.](https://mongoosejs.com/docs/api/document.html#Document.prototype.equals())\n   *\n   * #### Example:\n   *\n   *     doc.array.pull(ObjectId)\n   *     doc.array.pull({ _id: 'someId' })\n   *     doc.array.pull(36)\n   *     doc.array.pull('tag 1', 'tag 2')\n   *\n   * To remove a document from a subdocument array we may pass an object with a matching `_id`.\n   *\n   *     doc.subdocs.push({ _id: 4815162342 })\n   *     doc.subdocs.pull({ _id: 4815162342 }) // removed\n   *\n   * Or we may passing the _id directly and let mongoose take care of it.\n   *\n   *     doc.subdocs.push({ _id: 4815162342 })\n   *     doc.subdocs.pull(4815162342); // works\n   *\n   * The first pull call will result in a atomic operation on the database, if pull is called repeatedly without saving the document, a $set operation is used on the complete array instead, overwriting possible changes that happened on the database in the meantime.\n   *\n   * @param {...any} [args]\n   * @see mongodb https://www.mongodb.com/docs/manual/reference/operator/update/pull/\n   * @api public\n   * @method pull\n   * @memberOf MongooseArray\n   */\n\n  pull() {\n    const values = [].map.call(arguments, (v, i) => this._cast(v, i, { defaults: false }), this);\n    const cur = this[arrayParentSymbol].get(this[arrayPathSymbol]);\n    let i = cur.length;\n    let mem;\n    this._markModified();\n\n    while (i--) {\n      mem = cur[i];\n      if (mem instanceof Document) {\n        const some = values.some(function(v) {\n          return mem.equals(v);\n        });\n        if (some) {\n          [].splice.call(cur, i, 1);\n        }\n      } else if (~cur.indexOf.call(values, mem)) {\n        [].splice.call(cur, i, 1);\n      }\n    }\n\n    if (values[0] instanceof ArraySubdocument) {\n      this._registerAtomic('$pullDocs', values.map(function(v) {\n        const _id = v.$__getValue('_id');\n        if (_id === undefined || v.$isDefault('_id')) {\n          return v;\n        }\n        return _id;\n      }));\n    } else {\n      this._registerAtomic('$pullAll', values);\n    }\n\n\n    // Might have modified child paths and then pulled, like\n    // `doc.children[1].name = 'test';` followed by\n    // `doc.children.remove(doc.children[0]);`. In this case we fall back\n    // to a `$set` on the whole array. See #3511\n    if (cleanModifiedSubpaths(this[arrayParentSymbol], this[arrayPathSymbol]) > 0) {\n      this._registerAtomic('$set', this);\n    }\n\n    return this;\n  },\n\n  /**\n   * Wraps [`Array#push`](https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Array/push) with proper change tracking.\n   *\n   * #### Example:\n   *\n   *     const schema = Schema({ nums: [Number] });\n   *     const Model = mongoose.model('Test', schema);\n   *\n   *     const doc = await Model.create({ nums: [3, 4] });\n   *     doc.nums.push(5); // Add 5 to the end of the array\n   *     await doc.save();\n   *\n   *     // You can also pass an object with `$each` as the\n   *     // first parameter to use MongoDB's `$position`\n   *     doc.nums.push({\n   *       $each: [1, 2],\n   *       $position: 0\n   *     });\n   *     doc.nums; // [1, 2, 3, 4, 5]\n   *\n   * @param {...Object} [args]\n   * @api public\n   * @method push\n   * @memberOf MongooseArray\n   */\n\n  push() {\n    let values = arguments;\n    let atomic = values;\n    const isOverwrite = values[0] != null &&\n      utils.hasUserDefinedProperty(values[0], '$each');\n    const arr = utils.isMongooseArray(this) ? this.__array : this;\n    if (isOverwrite) {\n      atomic = values[0];\n      values = values[0].$each;\n    }\n\n    if (this[arraySchemaSymbol] == null) {\n      return _basePush.apply(this, values);\n    }\n\n    _checkManualPopulation(this, values);\n\n    const parent = this[arrayParentSymbol];\n    values = [].map.call(values, this._mapCast, this);\n    values = this[arraySchemaSymbol].applySetters(values, parent, undefined,\n      undefined, { skipDocumentArrayCast: true });\n    let ret;\n    const atomics = this[arrayAtomicsSymbol];\n    this._markModified();\n    if (isOverwrite) {\n      atomic.$each = values;\n\n      if ((atomics.$push && atomics.$push.$each && atomics.$push.$each.length || 0) !== 0 &&\n          atomics.$push.$position != atomic.$position) {\n        throw new MongooseError('Cannot call `Array#push()` multiple times ' +\n          'with different `$position`');\n      }\n\n      if (atomic.$position != null) {\n        [].splice.apply(arr, [atomic.$position, 0].concat(values));\n        ret = this.length;\n      } else {\n        ret = [].push.apply(arr, values);\n      }\n    } else {\n      if ((atomics.$push && atomics.$push.$each && atomics.$push.$each.length || 0) !== 0 &&\n          atomics.$push.$position != null) {\n        throw new MongooseError('Cannot call `Array#push()` multiple times ' +\n          'with different `$position`');\n      }\n      atomic = values;\n      ret = [].push.apply(arr, values);\n    }\n\n    this._registerAtomic('$push', atomic);\n    return ret;\n  },\n\n  /**\n   * Alias of [pull](https://mongoosejs.com/docs/api/array.html#MongooseArray.prototype.pull())\n   *\n   * @see MongooseArray#pull https://mongoosejs.com/docs/api/array.html#MongooseArray.prototype.pull()\n   * @see mongodb https://www.mongodb.com/docs/manual/reference/operator/update/pull/\n   * @api public\n   * @memberOf MongooseArray\n   * @instance\n   * @method remove\n   */\n\n  remove() {\n    return this.pull.apply(this, arguments);\n  },\n\n  /**\n   * Sets the casted `val` at index `i` and marks the array modified.\n   *\n   * #### Example:\n   *\n   *     // given documents based on the following\n   *     const Doc = mongoose.model('Doc', new Schema({ array: [Number] }));\n   *\n   *     const doc = new Doc({ array: [2,3,4] })\n   *\n   *     console.log(doc.array) // [2,3,4]\n   *\n   *     doc.array.set(1,\"5\");\n   *     console.log(doc.array); // [2,5,4] // properly cast to number\n   *     doc.save() // the change is saved\n   *\n   *     // VS not using array#set\n   *     doc.array[1] = \"5\";\n   *     console.log(doc.array); // [2,\"5\",4] // no casting\n   *     doc.save() // change is not saved\n   *\n   * @return {Array} this\n   * @api public\n   * @method set\n   * @memberOf MongooseArray\n   */\n\n  set(i, val, skipModified) {\n    const arr = this.__array;\n    if (skipModified) {\n      arr[i] = val;\n      return this;\n    }\n    const value = methods._cast.call(this, val, i);\n    methods._markModified.call(this, i);\n    arr[i] = value;\n    return this;\n  },\n\n  /**\n   * Wraps [`Array#shift`](https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Array/unshift) with proper change tracking.\n   *\n   * #### Example:\n   *\n   *     doc.array = [2,3];\n   *     const res = doc.array.shift();\n   *     console.log(res) // 2\n   *     console.log(doc.array) // [3]\n   *\n   * #### Note:\n   *\n   * _marks the entire array as modified, which if saved, will store it as a `$set` operation, potentially overwritting any changes that happen between when you retrieved the object and when you save it._\n   *\n   * @api public\n   * @method shift\n   * @memberOf MongooseArray\n   */\n\n  shift() {\n    const arr = utils.isMongooseArray(this) ? this.__array : this;\n    this._markModified();\n    const ret = [].shift.call(arr);\n    this._registerAtomic('$set', this);\n    return ret;\n  },\n\n  /**\n   * Wraps [`Array#sort`](https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Array/sort) with proper change tracking.\n   *\n   * #### Note:\n   *\n   * _marks the entire array as modified, which if saved, will store it as a `$set` operation, potentially overwritting any changes that happen between when you retrieved the object and when you save it._\n   *\n   * @api public\n   * @method sort\n   * @memberOf MongooseArray\n   * @see MasteringJS: Array sort https://masteringjs.io/tutorials/fundamentals/array-sort\n   */\n\n  sort() {\n    const arr = utils.isMongooseArray(this) ? this.__array : this;\n    const ret = [].sort.apply(arr, arguments);\n    this._registerAtomic('$set', this);\n    return ret;\n  },\n\n  /**\n   * Wraps [`Array#splice`](https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Array/splice) with proper change tracking and casting.\n   *\n   * #### Note:\n   *\n   * _marks the entire array as modified, which if saved, will store it as a `$set` operation, potentially overwritting any changes that happen between when you retrieved the object and when you save it._\n   *\n   * @api public\n   * @method splice\n   * @memberOf MongooseArray\n   * @see MasteringJS: Array splice https://masteringjs.io/tutorials/fundamentals/array-splice\n   */\n\n  splice() {\n    let ret;\n    const arr = utils.isMongooseArray(this) ? this.__array : this;\n\n    this._markModified();\n    _checkManualPopulation(this, Array.prototype.slice.call(arguments, 2));\n\n    if (arguments.length) {\n      let vals;\n      if (this[arraySchemaSymbol] == null) {\n        vals = arguments;\n      } else {\n        vals = [];\n        for (let i = 0; i < arguments.length; ++i) {\n          vals[i] = i < 2 ?\n            arguments[i] :\n            this._cast(arguments[i], arguments[0] + (i - 2));\n        }\n      }\n\n      ret = [].splice.apply(arr, vals);\n      this._registerAtomic('$set', this);\n    }\n\n    return ret;\n  },\n\n  /*!\n   * ignore\n   */\n\n  toBSON() {\n    return this.toObject(internalToObjectOptions);\n  },\n\n  /**\n   * Returns a native js Array.\n   *\n   * @param {Object} options\n   * @return {Array}\n   * @api public\n   * @method toObject\n   * @memberOf MongooseArray\n   */\n\n  toObject(options) {\n    const arr = utils.isMongooseArray(this) ? this.__array : this;\n    if (options && options.depopulate) {\n      options = clone(options);\n      options._isNested = true;\n      // Ensure return value is a vanilla array, because in Node.js 6+ `map()`\n      // is smart enough to use the inherited array's constructor.\n      return [].concat(arr).map(function(doc) {\n        return doc instanceof Document\n          ? doc.toObject(options)\n          : doc;\n      });\n    }\n\n    return [].concat(arr);\n  },\n\n  $toObject() {\n    return this.constructor.prototype.toObject.apply(this, arguments);\n  },\n  /**\n   * Wraps [`Array#unshift`](https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Array/unshift) with proper change tracking.\n   *\n   * #### Note:\n   *\n   * _marks the entire array as modified, which if saved, will store it as a `$set` operation, potentially overwriting any changes that happen between when you retrieved the object and when you save it._\n   *\n   * @api public\n   * @method unshift\n   * @memberOf MongooseArray\n   */\n\n  unshift() {\n    _checkManualPopulation(this, arguments);\n\n    let values;\n    if (this[arraySchemaSymbol] == null) {\n      values = arguments;\n    } else {\n      values = [].map.call(arguments, this._cast, this);\n      values = this[arraySchemaSymbol].applySetters(values, this[arrayParentSymbol]);\n    }\n\n    const arr = utils.isMongooseArray(this) ? this.__array : this;\n    this._markModified();\n    [].unshift.apply(arr, values);\n    this._registerAtomic('$set', this);\n    return this.length;\n  }\n};\n\n/*!\n * ignore\n */\n\nfunction _isAllSubdocs(docs, ref) {\n  if (!ref) {\n    return false;\n  }\n\n  for (const arg of docs) {\n    if (arg == null) {\n      return false;\n    }\n    const model = arg.constructor;\n    if (!(arg instanceof Document) ||\n      (model.modelName !== ref && model.baseModelName !== ref)) {\n      return false;\n    }\n  }\n\n  return true;\n}\n\n/*!\n * Minimize _just_ empty objects along the path chain specified\n * by `parts`, ignoring all other paths. Useful in cases where\n * you want to minimize after unsetting a path.\n *\n * #### Example:\n *\n *     const obj = { foo: { bar: { baz: {} } }, a: {} };\n *     _minimizePath(obj, 'foo.bar.baz');\n *     obj; // { a: {} }\n */\n\nfunction _minimizePath(obj, parts, i) {\n  if (typeof parts === 'string') {\n    if (parts.indexOf('.') === -1) {\n      return;\n    }\n\n    parts = mpath.stringToParts(parts);\n  }\n  i = i || 0;\n  if (i >= parts.length) {\n    return;\n  }\n  if (obj == null || typeof obj !== 'object') {\n    return;\n  }\n\n  _minimizePath(obj[parts[0]], parts, i + 1);\n  if (obj[parts[0]] != null && typeof obj[parts[0]] === 'object' && Object.keys(obj[parts[0]]).length === 0) {\n    delete obj[parts[0]];\n  }\n}\n\n/*!\n * ignore\n */\n\nfunction _checkManualPopulation(arr, docs) {\n  const ref = arr == null ?\n    null :\n    arr[arraySchemaSymbol] && arr[arraySchemaSymbol].caster && arr[arraySchemaSymbol].caster.options && arr[arraySchemaSymbol].caster.options.ref || null;\n  if (arr.length === 0 &&\n      docs.length !== 0) {\n    if (_isAllSubdocs(docs, ref)) {\n      arr[arrayParentSymbol].$populated(arr[arrayPathSymbol], [], {\n        [populateModelSymbol]: docs[0].constructor\n      });\n    }\n  }\n}\n\nconst returnVanillaArrayMethods = [\n  'filter',\n  'flat',\n  'flatMap',\n  'map',\n  'slice'\n];\nfor (const method of returnVanillaArrayMethods) {\n  if (Array.prototype[method] == null) {\n    continue;\n  }\n\n  methods[method] = function() {\n    const _arr = utils.isMongooseArray(this) ? this.__array : this;\n    const arr = [].concat(_arr);\n\n    return arr[method].apply(arr, arguments);\n  };\n}\n\nmodule.exports = methods;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbW9uZ29vc2UvbGliL3R5cGVzL2FycmF5L21ldGhvZHMvaW5kZXguanMiLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWIsaUJBQWlCLG1CQUFPLENBQUMsd0VBQW1CO0FBQzVDLHlCQUF5QixtQkFBTyxDQUFDLDJGQUF3QjtBQUN6RCxzQkFBc0IsbUJBQU8sQ0FBQyw4RkFBOEI7QUFDNUQsOEJBQThCLG1CQUFPLENBQUMsb0lBQWlEO0FBQ3ZGLGNBQWMsbUJBQU8sQ0FBQyxrRkFBd0I7QUFDOUMsZ0NBQWdDLHFIQUFtRDtBQUNuRixjQUFjLG1CQUFPLENBQUMsa0RBQU87QUFDN0IsY0FBYyxtQkFBTyxDQUFDLGtFQUFnQjtBQUN0QyxtQkFBbUIsbUJBQU8sQ0FBQyw0RkFBNkI7O0FBRXhELDJCQUEyQixnSUFBc0Q7QUFDakYsMEJBQTBCLCtIQUFxRDtBQUMvRSx3QkFBd0IsNkhBQW1EO0FBQzNFLDBCQUEwQiwrSEFBcUQ7QUFDL0UsNEJBQTRCLGlJQUF1RDtBQUNuRjs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLDJEQUEyRDtBQUMzRDs7QUFFQSxpQ0FBaUMsNkJBQTZCLGlCQUFpQjs7QUFFL0U7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQSxRQUFRO0FBQ1I7QUFDQSxRQUFRO0FBQ1I7QUFDQTs7QUFFQTtBQUNBLGdCQUFnQjtBQUNoQjs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDO0FBQ2hDLGtDQUFrQztBQUNsQztBQUNBO0FBQ0E7QUFDQSxrQ0FBa0M7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DO0FBQ25DLG9DQUFvQztBQUNwQyxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQjtBQUMvQixrQ0FBa0M7QUFDbEM7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQztBQUNqQyxvQ0FBb0M7QUFDcEMsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBLGFBQWEsS0FBSztBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsa0JBQWtCO0FBQy9CLGFBQWEsUUFBUTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBLGFBQWEsT0FBTztBQUNwQixhQUFhLEtBQUs7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUM7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DO0FBQ25DO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOLCtEQUErRDtBQUMvRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxlQUFlOztBQUVmO0FBQ0EsYUFBYTtBQUNiO0FBQ0EsV0FBVztBQUNYLFNBQVM7QUFDVCxRQUFRO0FBQ1IsdURBQXVELFNBQVM7QUFDaEU7QUFDQTtBQUNBLE1BQU07QUFDTix5Q0FBeUM7QUFDekM7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7O0FBRUE7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCLGNBQWMsT0FBTztBQUNyQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBLE1BQU07QUFDTjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBLGFBQWEsUUFBUTtBQUNyQixhQUFhLFFBQVE7QUFDckIsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCLGFBQWEsUUFBUTtBQUNyQixjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLDRCQUE0QixTQUFTO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsZUFBZTtBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLGlCQUFpQjtBQUM3Qyw0QkFBNEIsaUJBQWlCO0FBQzdDO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QixpQkFBaUI7QUFDN0MsdUNBQXVDO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBLGFBQWEsUUFBUTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsdUVBQXVFLGlCQUFpQjtBQUN4RjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsTUFBTTtBQUNOO0FBQ0E7OztBQUdBO0FBQ0Esc0NBQXNDO0FBQ3RDLDZDQUE2QztBQUM3QztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQyxnQkFBZ0I7QUFDakQ7QUFDQTtBQUNBLDBDQUEwQyxjQUFjO0FBQ3hELDJCQUEyQjtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVixtQkFBbUI7QUFDbkI7QUFDQSxhQUFhLFdBQVc7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQiw2QkFBNkI7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0RBQXdELGlCQUFpQjtBQUN6RTtBQUNBLCtCQUErQixnQkFBZ0I7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUM7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUM7QUFDakM7QUFDQTtBQUNBLGNBQWMsT0FBTztBQUNyQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBLHdCQUF3QixzQkFBc0I7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQSxhQUFhLFFBQVE7QUFDckIsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7O0FBRUE7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsT0FBTyxPQUFPLFdBQVc7QUFDOUM7QUFDQSxZQUFZLEtBQUs7QUFDakI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9hcHAxLy4vbm9kZV9tb2R1bGVzL21vbmdvb3NlL2xpYi90eXBlcy9hcnJheS9tZXRob2RzL2luZGV4LmpzPzFlMzQiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG5jb25zdCBEb2N1bWVudCA9IHJlcXVpcmUoJy4uLy4uLy4uL2RvY3VtZW50Jyk7XG5jb25zdCBBcnJheVN1YmRvY3VtZW50ID0gcmVxdWlyZSgnLi4vLi4vYXJyYXlTdWJkb2N1bWVudCcpO1xuY29uc3QgTW9uZ29vc2VFcnJvciA9IHJlcXVpcmUoJy4uLy4uLy4uL2Vycm9yL21vbmdvb3NlRXJyb3InKTtcbmNvbnN0IGNsZWFuTW9kaWZpZWRTdWJwYXRocyA9IHJlcXVpcmUoJy4uLy4uLy4uL2hlbHBlcnMvZG9jdW1lbnQvY2xlYW5Nb2RpZmllZFN1YnBhdGhzJyk7XG5jb25zdCBjbG9uZSA9IHJlcXVpcmUoJy4uLy4uLy4uL2hlbHBlcnMvY2xvbmUnKTtcbmNvbnN0IGludGVybmFsVG9PYmplY3RPcHRpb25zID0gcmVxdWlyZSgnLi4vLi4vLi4vb3B0aW9ucycpLmludGVybmFsVG9PYmplY3RPcHRpb25zO1xuY29uc3QgbXBhdGggPSByZXF1aXJlKCdtcGF0aCcpO1xuY29uc3QgdXRpbHMgPSByZXF1aXJlKCcuLi8uLi8uLi91dGlscycpO1xuY29uc3QgaXNCc29uVHlwZSA9IHJlcXVpcmUoJy4uLy4uLy4uL2hlbHBlcnMvaXNCc29uVHlwZScpO1xuXG5jb25zdCBhcnJheUF0b21pY3NTeW1ib2wgPSByZXF1aXJlKCcuLi8uLi8uLi9oZWxwZXJzL3N5bWJvbHMnKS5hcnJheUF0b21pY3NTeW1ib2w7XG5jb25zdCBhcnJheVBhcmVudFN5bWJvbCA9IHJlcXVpcmUoJy4uLy4uLy4uL2hlbHBlcnMvc3ltYm9scycpLmFycmF5UGFyZW50U3ltYm9sO1xuY29uc3QgYXJyYXlQYXRoU3ltYm9sID0gcmVxdWlyZSgnLi4vLi4vLi4vaGVscGVycy9zeW1ib2xzJykuYXJyYXlQYXRoU3ltYm9sO1xuY29uc3QgYXJyYXlTY2hlbWFTeW1ib2wgPSByZXF1aXJlKCcuLi8uLi8uLi9oZWxwZXJzL3N5bWJvbHMnKS5hcnJheVNjaGVtYVN5bWJvbDtcbmNvbnN0IHBvcHVsYXRlTW9kZWxTeW1ib2wgPSByZXF1aXJlKCcuLi8uLi8uLi9oZWxwZXJzL3N5bWJvbHMnKS5wb3B1bGF0ZU1vZGVsU3ltYm9sO1xuY29uc3Qgc2xpY2VkU3ltYm9sID0gU3ltYm9sKCdtb25nb29zZSNBcnJheSNzbGljZWQnKTtcblxuY29uc3QgX2Jhc2VQdXNoID0gQXJyYXkucHJvdG90eXBlLnB1c2g7XG5cbi8qIVxuICogaWdub3JlXG4gKi9cblxuY29uc3QgbWV0aG9kcyA9IHtcbiAgLyoqXG4gICAqIERlcG9wdWxhdGVzIHN0b3JlZCBhdG9taWMgb3BlcmF0aW9uIHZhbHVlcyBhcyBuZWNlc3NhcnkgZm9yIGRpcmVjdCBpbnNlcnRpb24gdG8gTW9uZ29EQi5cbiAgICpcbiAgICogSWYgbm8gYXRvbWljcyBleGlzdCwgd2UgcmV0dXJuIGFsbCBhcnJheSB2YWx1ZXMgYWZ0ZXIgY29udmVyc2lvbi5cbiAgICpcbiAgICogQHJldHVybiB7QXJyYXl9XG4gICAqIEBtZXRob2QgJF9fZ2V0QXRvbWljc1xuICAgKiBAbWVtYmVyT2YgTW9uZ29vc2VBcnJheVxuICAgKiBAaW5zdGFuY2VcbiAgICogQGFwaSBwcml2YXRlXG4gICAqL1xuXG4gICRfX2dldEF0b21pY3MoKSB7XG4gICAgY29uc3QgcmV0ID0gW107XG4gICAgY29uc3Qga2V5cyA9IE9iamVjdC5rZXlzKHRoaXNbYXJyYXlBdG9taWNzU3ltYm9sXSB8fCB7fSk7XG4gICAgbGV0IGkgPSBrZXlzLmxlbmd0aDtcblxuICAgIGNvbnN0IG9wdHMgPSBPYmplY3QuYXNzaWduKHt9LCBpbnRlcm5hbFRvT2JqZWN0T3B0aW9ucywgeyBfaXNOZXN0ZWQ6IHRydWUgfSk7XG5cbiAgICBpZiAoaSA9PT0gMCkge1xuICAgICAgcmV0WzBdID0gWyckc2V0JywgdGhpcy50b09iamVjdChvcHRzKV07XG4gICAgICByZXR1cm4gcmV0O1xuICAgIH1cblxuICAgIHdoaWxlIChpLS0pIHtcbiAgICAgIGNvbnN0IG9wID0ga2V5c1tpXTtcbiAgICAgIGxldCB2YWwgPSB0aGlzW2FycmF5QXRvbWljc1N5bWJvbF1bb3BdO1xuXG4gICAgICAvLyB0aGUgYXRvbWljIHZhbHVlcyB3aGljaCBhcmUgYXJyYXlzIGFyZSBub3QgTW9uZ29vc2VBcnJheXMuIHdlXG4gICAgICAvLyBuZWVkIHRvIGNvbnZlcnQgdGhlaXIgZWxlbWVudHMgYXMgaWYgdGhleSB3ZXJlIE1vbmdvb3NlQXJyYXlzXG4gICAgICAvLyB0byBoYW5kbGUgcG9wdWxhdGVkIGFycmF5cyB2ZXJzdXMgRG9jdW1lbnRBcnJheXMgcHJvcGVybHkuXG4gICAgICBpZiAodXRpbHMuaXNNb25nb29zZU9iamVjdCh2YWwpKSB7XG4gICAgICAgIHZhbCA9IHZhbC50b09iamVjdChvcHRzKTtcbiAgICAgIH0gZWxzZSBpZiAoQXJyYXkuaXNBcnJheSh2YWwpKSB7XG4gICAgICAgIHZhbCA9IHRoaXMudG9PYmplY3QuY2FsbCh2YWwsIG9wdHMpO1xuICAgICAgfSBlbHNlIGlmICh2YWwgIT0gbnVsbCAmJiBBcnJheS5pc0FycmF5KHZhbC4kZWFjaCkpIHtcbiAgICAgICAgdmFsLiRlYWNoID0gdGhpcy50b09iamVjdC5jYWxsKHZhbC4kZWFjaCwgb3B0cyk7XG4gICAgICB9IGVsc2UgaWYgKHZhbCAhPSBudWxsICYmIHR5cGVvZiB2YWwudmFsdWVPZiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICB2YWwgPSB2YWwudmFsdWVPZigpO1xuICAgICAgfVxuXG4gICAgICBpZiAob3AgPT09ICckYWRkVG9TZXQnKSB7XG4gICAgICAgIHZhbCA9IHsgJGVhY2g6IHZhbCB9O1xuICAgICAgfVxuXG4gICAgICByZXQucHVzaChbb3AsIHZhbF0pO1xuICAgIH1cblxuICAgIHJldHVybiByZXQ7XG4gIH0sXG5cbiAgLyohXG4gICAqIGlnbm9yZVxuICAgKi9cblxuICAkYXRvbWljcygpIHtcbiAgICByZXR1cm4gdGhpc1thcnJheUF0b21pY3NTeW1ib2xdO1xuICB9LFxuXG4gIC8qIVxuICAgKiBpZ25vcmVcbiAgICovXG5cbiAgJHBhcmVudCgpIHtcbiAgICByZXR1cm4gdGhpc1thcnJheVBhcmVudFN5bWJvbF07XG4gIH0sXG5cbiAgLyohXG4gICAqIGlnbm9yZVxuICAgKi9cblxuICAkcGF0aCgpIHtcbiAgICByZXR1cm4gdGhpc1thcnJheVBhdGhTeW1ib2xdO1xuICB9LFxuXG4gIC8qKlxuICAgKiBBdG9taWNhbGx5IHNoaWZ0cyB0aGUgYXJyYXkgYXQgbW9zdCBvbmUgdGltZSBwZXIgZG9jdW1lbnQgYHNhdmUoKWAuXG4gICAqXG4gICAqICMjIyMgTm90ZTpcbiAgICpcbiAgICogX0NhbGxpbmcgdGhpcyBtdWx0aXBsZSB0aW1lcyBvbiBhbiBhcnJheSBiZWZvcmUgc2F2aW5nIHNlbmRzIHRoZSBzYW1lIGNvbW1hbmQgYXMgY2FsbGluZyBpdCBvbmNlLl9cbiAgICogX1RoaXMgdXBkYXRlIGlzIGltcGxlbWVudGVkIHVzaW5nIHRoZSBNb25nb0RCIFskcG9wXShodHRwczovL3d3dy5tb25nb2RiLmNvbS9kb2NzL21hbnVhbC9yZWZlcmVuY2Uvb3BlcmF0b3IvdXBkYXRlL3BvcC8pIG1ldGhvZCB3aGljaCBlbmZvcmNlcyB0aGlzIHJlc3RyaWN0aW9uLl9cbiAgICpcbiAgICogICAgICBkb2MuYXJyYXkgPSBbMSwyLDNdO1xuICAgKlxuICAgKiAgICAgIGNvbnN0IHNoaWZ0ZWQgPSBkb2MuYXJyYXkuJHNoaWZ0KCk7XG4gICAqICAgICAgY29uc29sZS5sb2coc2hpZnRlZCk7IC8vIDFcbiAgICogICAgICBjb25zb2xlLmxvZyhkb2MuYXJyYXkpOyAvLyBbMiwzXVxuICAgKlxuICAgKiAgICAgIC8vIG5vIGFmZmVjdFxuICAgKiAgICAgIHNoaWZ0ZWQgPSBkb2MuYXJyYXkuJHNoaWZ0KCk7XG4gICAqICAgICAgY29uc29sZS5sb2coZG9jLmFycmF5KTsgLy8gWzIsM11cbiAgICpcbiAgICogICAgICBkb2Muc2F2ZShmdW5jdGlvbiAoZXJyKSB7XG4gICAqICAgICAgICBpZiAoZXJyKSByZXR1cm4gaGFuZGxlRXJyb3IoZXJyKTtcbiAgICpcbiAgICogICAgICAgIC8vIHdlIHNhdmVkLCBub3cgJHNoaWZ0IHdvcmtzIGFnYWluXG4gICAqICAgICAgICBzaGlmdGVkID0gZG9jLmFycmF5LiRzaGlmdCgpO1xuICAgKiAgICAgICAgY29uc29sZS5sb2coc2hpZnRlZCApOyAvLyAyXG4gICAqICAgICAgICBjb25zb2xlLmxvZyhkb2MuYXJyYXkpOyAvLyBbM11cbiAgICogICAgICB9KVxuICAgKlxuICAgKiBAYXBpIHB1YmxpY1xuICAgKiBAbWVtYmVyT2YgTW9uZ29vc2VBcnJheVxuICAgKiBAaW5zdGFuY2VcbiAgICogQG1ldGhvZCAkc2hpZnRcbiAgICogQHNlZSBtb25nb2RiIGh0dHBzOi8vd3d3Lm1vbmdvZGIuY29tL2RvY3MvbWFudWFsL3JlZmVyZW5jZS9vcGVyYXRvci91cGRhdGUvcG9wL1xuICAgKi9cblxuICAkc2hpZnQoKSB7XG4gICAgdGhpcy5fcmVnaXN0ZXJBdG9taWMoJyRwb3AnLCAtMSk7XG4gICAgdGhpcy5fbWFya01vZGlmaWVkKCk7XG5cbiAgICAvLyBvbmx5IGFsbG93IHNoaWZ0aW5nIG9uY2VcbiAgICBjb25zdCBfX2FycmF5ID0gdGhpcy5fX2FycmF5O1xuICAgIGlmIChfX2FycmF5Ll9zaGlmdGVkKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIF9fYXJyYXkuX3NoaWZ0ZWQgPSB0cnVlO1xuXG4gICAgcmV0dXJuIFtdLnNoaWZ0LmNhbGwoX19hcnJheSk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIFBvcHMgdGhlIGFycmF5IGF0b21pY2FsbHkgYXQgbW9zdCBvbmUgdGltZSBwZXIgZG9jdW1lbnQgYHNhdmUoKWAuXG4gICAqXG4gICAqICMjIyMgTk9URTpcbiAgICpcbiAgICogX0NhbGxpbmcgdGhpcyBtdWx0aXBsZSB0aW1lcyBvbiBhbiBhcnJheSBiZWZvcmUgc2F2aW5nIHNlbmRzIHRoZSBzYW1lIGNvbW1hbmQgYXMgY2FsbGluZyBpdCBvbmNlLl9cbiAgICogX1RoaXMgdXBkYXRlIGlzIGltcGxlbWVudGVkIHVzaW5nIHRoZSBNb25nb0RCIFskcG9wXShodHRwczovL3d3dy5tb25nb2RiLmNvbS9kb2NzL21hbnVhbC9yZWZlcmVuY2Uvb3BlcmF0b3IvdXBkYXRlL3BvcC8pIG1ldGhvZCB3aGljaCBlbmZvcmNlcyB0aGlzIHJlc3RyaWN0aW9uLl9cbiAgICpcbiAgICogICAgICBkb2MuYXJyYXkgPSBbMSwyLDNdO1xuICAgKlxuICAgKiAgICAgIGNvbnN0IHBvcHBlZCA9IGRvYy5hcnJheS4kcG9wKCk7XG4gICAqICAgICAgY29uc29sZS5sb2cocG9wcGVkKTsgLy8gM1xuICAgKiAgICAgIGNvbnNvbGUubG9nKGRvYy5hcnJheSk7IC8vIFsxLDJdXG4gICAqXG4gICAqICAgICAgLy8gbm8gYWZmZWN0XG4gICAqICAgICAgcG9wcGVkID0gZG9jLmFycmF5LiRwb3AoKTtcbiAgICogICAgICBjb25zb2xlLmxvZyhkb2MuYXJyYXkpOyAvLyBbMSwyXVxuICAgKlxuICAgKiAgICAgIGRvYy5zYXZlKGZ1bmN0aW9uIChlcnIpIHtcbiAgICogICAgICAgIGlmIChlcnIpIHJldHVybiBoYW5kbGVFcnJvcihlcnIpO1xuICAgKlxuICAgKiAgICAgICAgLy8gd2Ugc2F2ZWQsIG5vdyAkcG9wIHdvcmtzIGFnYWluXG4gICAqICAgICAgICBwb3BwZWQgPSBkb2MuYXJyYXkuJHBvcCgpO1xuICAgKiAgICAgICAgY29uc29sZS5sb2cocG9wcGVkKTsgLy8gMlxuICAgKiAgICAgICAgY29uc29sZS5sb2coZG9jLmFycmF5KTsgLy8gWzFdXG4gICAqICAgICAgfSlcbiAgICpcbiAgICogQGFwaSBwdWJsaWNcbiAgICogQG1ldGhvZCAkcG9wXG4gICAqIEBtZW1iZXJPZiBNb25nb29zZUFycmF5XG4gICAqIEBpbnN0YW5jZVxuICAgKiBAc2VlIG1vbmdvZGIgaHR0cHM6Ly93d3cubW9uZ29kYi5jb20vZG9jcy9tYW51YWwvcmVmZXJlbmNlL29wZXJhdG9yL3VwZGF0ZS9wb3AvXG4gICAqIEBtZXRob2QgJHBvcFxuICAgKiBAbWVtYmVyT2YgTW9uZ29vc2VBcnJheVxuICAgKi9cblxuICAkcG9wKCkge1xuICAgIHRoaXMuX3JlZ2lzdGVyQXRvbWljKCckcG9wJywgMSk7XG4gICAgdGhpcy5fbWFya01vZGlmaWVkKCk7XG5cbiAgICAvLyBvbmx5IGFsbG93IHBvcHBpbmcgb25jZVxuICAgIGlmICh0aGlzLl9wb3BwZWQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5fcG9wcGVkID0gdHJ1ZTtcblxuICAgIHJldHVybiBbXS5wb3AuY2FsbCh0aGlzKTtcbiAgfSxcblxuICAvKiFcbiAgICogaWdub3JlXG4gICAqL1xuXG4gICRzY2hlbWEoKSB7XG4gICAgcmV0dXJuIHRoaXNbYXJyYXlTY2hlbWFTeW1ib2xdO1xuICB9LFxuXG4gIC8qKlxuICAgKiBDYXN0cyBhIG1lbWJlciBiYXNlZCBvbiB0aGlzIGFycmF5cyBzY2hlbWEuXG4gICAqXG4gICAqIEBwYXJhbSB7YW55fSB2YWx1ZVxuICAgKiBAcmV0dXJuIHZhbHVlIHRoZSBjYXN0ZWQgdmFsdWVcbiAgICogQG1ldGhvZCBfY2FzdFxuICAgKiBAYXBpIHByaXZhdGVcbiAgICogQG1lbWJlck9mIE1vbmdvb3NlQXJyYXlcbiAgICovXG5cbiAgX2Nhc3QodmFsdWUpIHtcbiAgICBsZXQgcG9wdWxhdGVkID0gZmFsc2U7XG4gICAgbGV0IE1vZGVsO1xuXG4gICAgY29uc3QgcGFyZW50ID0gdGhpc1thcnJheVBhcmVudFN5bWJvbF07XG4gICAgaWYgKHBhcmVudCkge1xuICAgICAgcG9wdWxhdGVkID0gcGFyZW50LiRwb3B1bGF0ZWQodGhpc1thcnJheVBhdGhTeW1ib2xdLCB0cnVlKTtcbiAgICB9XG5cbiAgICBpZiAocG9wdWxhdGVkICYmIHZhbHVlICE9PSBudWxsICYmIHZhbHVlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIC8vIGNhc3QgdG8gdGhlIHBvcHVsYXRlZCBNb2RlbHMgc2NoZW1hXG4gICAgICBNb2RlbCA9IHBvcHVsYXRlZC5vcHRpb25zW3BvcHVsYXRlTW9kZWxTeW1ib2xdO1xuICAgICAgaWYgKE1vZGVsID09IG51bGwpIHtcbiAgICAgICAgdGhyb3cgbmV3IE1vbmdvb3NlRXJyb3IoJ05vIHBvcHVsYXRlZCBtb2RlbCBmb3VuZCBmb3IgcGF0aCBgJyArIHRoaXNbYXJyYXlQYXRoU3ltYm9sXSArICdgLiBUaGlzIGlzIGxpa2VseSBhIGJ1ZyBpbiBNb25nb29zZSwgcGxlYXNlIHJlcG9ydCBhbiBpc3N1ZSBvbiBnaXRodWIuY29tL0F1dG9tYXR0aWMvbW9uZ29vc2UuJyk7XG4gICAgICB9XG5cbiAgICAgIC8vIG9ubHkgb2JqZWN0cyBhcmUgcGVybWl0dGVkIHNvIHdlIGNhbiBzYWZlbHkgYXNzdW1lIHRoYXRcbiAgICAgIC8vIG5vbi1vYmplY3RzIGFyZSB0byBiZSBpbnRlcnByZXRlZCBhcyBfaWRcbiAgICAgIGlmIChCdWZmZXIuaXNCdWZmZXIodmFsdWUpIHx8XG4gICAgICAgICAgaXNCc29uVHlwZSh2YWx1ZSwgJ09iamVjdElkJykgfHwgIXV0aWxzLmlzT2JqZWN0KHZhbHVlKSkge1xuICAgICAgICB2YWx1ZSA9IHsgX2lkOiB2YWx1ZSB9O1xuICAgICAgfVxuXG4gICAgICAvLyBnaC0yMzk5XG4gICAgICAvLyB3ZSBzaG91bGQgY2FzdCBtb2RlbCBvbmx5IHdoZW4gaXQncyBub3QgYSBkaXNjcmltaW5hdG9yXG4gICAgICBjb25zdCBpc0Rpc2MgPSB2YWx1ZS5zY2hlbWEgJiYgdmFsdWUuc2NoZW1hLmRpc2NyaW1pbmF0b3JNYXBwaW5nICYmXG4gICAgICAgICAgdmFsdWUuc2NoZW1hLmRpc2NyaW1pbmF0b3JNYXBwaW5nLmtleSAhPT0gdW5kZWZpbmVkO1xuICAgICAgaWYgKCFpc0Rpc2MpIHtcbiAgICAgICAgdmFsdWUgPSBuZXcgTW9kZWwodmFsdWUpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXNbYXJyYXlTY2hlbWFTeW1ib2xdLmNhc3Rlci5hcHBseVNldHRlcnModmFsdWUsIHBhcmVudCwgdHJ1ZSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXNbYXJyYXlTY2hlbWFTeW1ib2xdLmNhc3Rlci5hcHBseVNldHRlcnModmFsdWUsIHBhcmVudCwgZmFsc2UpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBJbnRlcm5hbCBoZWxwZXIgZm9yIC5tYXAoKVxuICAgKlxuICAgKiBAYXBpIHByaXZhdGVcbiAgICogQHJldHVybiB7TnVtYmVyfVxuICAgKiBAbWV0aG9kIF9tYXBDYXN0XG4gICAqIEBtZW1iZXJPZiBNb25nb29zZUFycmF5XG4gICAqL1xuXG4gIF9tYXBDYXN0KHZhbCwgaW5kZXgpIHtcbiAgICByZXR1cm4gdGhpcy5fY2FzdCh2YWwsIHRoaXMubGVuZ3RoICsgaW5kZXgpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBNYXJrcyB0aGlzIGFycmF5IGFzIG1vZGlmaWVkLlxuICAgKlxuICAgKiBJZiBpdCBidWJibGVzIHVwIGZyb20gYW4gZW1iZWRkZWQgZG9jdW1lbnQgY2hhbmdlLCB0aGVuIGl0IHRha2VzIHRoZSBmb2xsb3dpbmcgYXJndW1lbnRzIChvdGhlcndpc2UsIHRha2VzIDAgYXJndW1lbnRzKVxuICAgKlxuICAgKiBAcGFyYW0ge0FycmF5U3ViZG9jdW1lbnR9IHN1YmRvYyB0aGUgZW1iZWRkZWQgZG9jIHRoYXQgaW52b2tlZCB0aGlzIG1ldGhvZCBvbiB0aGUgQXJyYXlcbiAgICogQHBhcmFtIHtTdHJpbmd9IGVtYmVkZGVkUGF0aCB0aGUgcGF0aCB3aGljaCBjaGFuZ2VkIGluIHRoZSBzdWJkb2NcbiAgICogQG1ldGhvZCBfbWFya01vZGlmaWVkXG4gICAqIEBhcGkgcHJpdmF0ZVxuICAgKiBAbWVtYmVyT2YgTW9uZ29vc2VBcnJheVxuICAgKi9cblxuICBfbWFya01vZGlmaWVkKGVsZW0pIHtcbiAgICBjb25zdCBwYXJlbnQgPSB0aGlzW2FycmF5UGFyZW50U3ltYm9sXTtcbiAgICBsZXQgZGlydHlQYXRoO1xuXG4gICAgaWYgKHBhcmVudCkge1xuICAgICAgZGlydHlQYXRoID0gdGhpc1thcnJheVBhdGhTeW1ib2xdO1xuXG4gICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCkge1xuICAgICAgICBkaXJ0eVBhdGggPSBkaXJ0eVBhdGggKyAnLicgKyBlbGVtO1xuICAgICAgfVxuXG4gICAgICBpZiAoZGlydHlQYXRoICE9IG51bGwgJiYgZGlydHlQYXRoLmVuZHNXaXRoKCcuJCcpKSB7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfVxuXG4gICAgICBwYXJlbnQubWFya01vZGlmaWVkKGRpcnR5UGF0aCwgYXJndW1lbnRzLmxlbmd0aCAhPT0gMCA/IGVsZW0gOiBwYXJlbnQpO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzO1xuICB9LFxuXG4gIC8qKlxuICAgKiBSZWdpc3RlciBhbiBhdG9taWMgb3BlcmF0aW9uIHdpdGggdGhlIHBhcmVudC5cbiAgICpcbiAgICogQHBhcmFtIHtBcnJheX0gb3Agb3BlcmF0aW9uXG4gICAqIEBwYXJhbSB7YW55fSB2YWxcbiAgICogQG1ldGhvZCBfcmVnaXN0ZXJBdG9taWNcbiAgICogQGFwaSBwcml2YXRlXG4gICAqIEBtZW1iZXJPZiBNb25nb29zZUFycmF5XG4gICAqL1xuXG4gIF9yZWdpc3RlckF0b21pYyhvcCwgdmFsKSB7XG4gICAgaWYgKHRoaXNbc2xpY2VkU3ltYm9sXSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAob3AgPT09ICckc2V0Jykge1xuICAgICAgLy8gJHNldCB0YWtlcyBwcmVjZWRlbmNlIG92ZXIgYWxsIG90aGVyIG9wcy5cbiAgICAgIC8vIG1hcmsgZW50aXJlIGFycmF5IG1vZGlmaWVkLlxuICAgICAgdGhpc1thcnJheUF0b21pY3NTeW1ib2xdID0geyAkc2V0OiB2YWwgfTtcbiAgICAgIGNsZWFuTW9kaWZpZWRTdWJwYXRocyh0aGlzW2FycmF5UGFyZW50U3ltYm9sXSwgdGhpc1thcnJheVBhdGhTeW1ib2xdKTtcbiAgICAgIHRoaXMuX21hcmtNb2RpZmllZCgpO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgY29uc3QgYXRvbWljcyA9IHRoaXNbYXJyYXlBdG9taWNzU3ltYm9sXTtcblxuICAgIC8vIHJlc2V0IHBvcC9zaGlmdCBhZnRlciBzYXZlXG4gICAgaWYgKG9wID09PSAnJHBvcCcgJiYgISgnJHBvcCcgaW4gYXRvbWljcykpIHtcbiAgICAgIGNvbnN0IF90aGlzID0gdGhpcztcbiAgICAgIHRoaXNbYXJyYXlQYXJlbnRTeW1ib2xdLm9uY2UoJ3NhdmUnLCBmdW5jdGlvbigpIHtcbiAgICAgICAgX3RoaXMuX3BvcHBlZCA9IF90aGlzLl9zaGlmdGVkID0gbnVsbDtcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIC8vIGNoZWNrIGZvciBpbXBvc3NpYmxlICRhdG9taWMgY29tYm9zIChNb25nbyBkZW5pZXMgbW9yZSB0aGFuIG9uZVxuICAgIC8vICRhdG9taWMgb3Agb24gYSBzaW5nbGUgcGF0aFxuICAgIGlmIChhdG9taWNzLiRzZXQgfHwgT2JqZWN0LmtleXMoYXRvbWljcykubGVuZ3RoICYmICEob3AgaW4gYXRvbWljcykpIHtcbiAgICAgIC8vIGEgZGlmZmVyZW50IG9wIHdhcyBwcmV2aW91c2x5IHJlZ2lzdGVyZWQuXG4gICAgICAvLyBzYXZlIHRoZSBlbnRpcmUgdGhpbmcuXG4gICAgICB0aGlzW2FycmF5QXRvbWljc1N5bWJvbF0gPSB7ICRzZXQ6IHRoaXMgfTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIGxldCBzZWxlY3RvcjtcblxuICAgIGlmIChvcCA9PT0gJyRwdWxsQWxsJyB8fCBvcCA9PT0gJyRhZGRUb1NldCcpIHtcbiAgICAgIGF0b21pY3Nbb3BdIHx8IChhdG9taWNzW29wXSA9IFtdKTtcbiAgICAgIGF0b21pY3Nbb3BdID0gYXRvbWljc1tvcF0uY29uY2F0KHZhbCk7XG4gICAgfSBlbHNlIGlmIChvcCA9PT0gJyRwdWxsRG9jcycpIHtcbiAgICAgIGNvbnN0IHB1bGxPcCA9IGF0b21pY3NbJyRwdWxsJ10gfHwgKGF0b21pY3NbJyRwdWxsJ10gPSB7fSk7XG4gICAgICBpZiAodmFsWzBdIGluc3RhbmNlb2YgQXJyYXlTdWJkb2N1bWVudCkge1xuICAgICAgICBzZWxlY3RvciA9IHB1bGxPcFsnJG9yJ10gfHwgKHB1bGxPcFsnJG9yJ10gPSBbXSk7XG4gICAgICAgIEFycmF5LnByb3RvdHlwZS5wdXNoLmFwcGx5KHNlbGVjdG9yLCB2YWwubWFwKHYgPT4ge1xuICAgICAgICAgIHJldHVybiB2LnRvT2JqZWN0KHtcbiAgICAgICAgICAgIHRyYW5zZm9ybTogKGRvYywgcmV0KSA9PiB7XG4gICAgICAgICAgICAgIGlmICh2ID09IG51bGwgfHwgdi4kX18gPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHJldHVybiByZXQ7XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICBPYmplY3Qua2V5cyh2LiRfXy5hY3RpdmVQYXRocy5nZXRTdGF0ZVBhdGhzKCdkZWZhdWx0JykpLmZvckVhY2gocGF0aCA9PiB7XG4gICAgICAgICAgICAgICAgbXBhdGgudW5zZXQocGF0aCwgcmV0KTtcblxuICAgICAgICAgICAgICAgIF9taW5pbWl6ZVBhdGgocmV0LCBwYXRoKTtcbiAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgcmV0dXJuIHJldDtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB2aXJ0dWFsczogZmFsc2VcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSkpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc2VsZWN0b3IgPSBwdWxsT3BbJ19pZCddIHx8IChwdWxsT3BbJ19pZCddID0geyAkaW46IFtdIH0pO1xuICAgICAgICBzZWxlY3RvclsnJGluJ10gPSBzZWxlY3RvclsnJGluJ10uY29uY2F0KHZhbCk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChvcCA9PT0gJyRwdXNoJykge1xuICAgICAgYXRvbWljcy4kcHVzaCA9IGF0b21pY3MuJHB1c2ggfHwgeyAkZWFjaDogW10gfTtcbiAgICAgIGlmICh2YWwgIT0gbnVsbCAmJiB1dGlscy5oYXNVc2VyRGVmaW5lZFByb3BlcnR5KHZhbCwgJyRlYWNoJykpIHtcbiAgICAgICAgYXRvbWljcy4kcHVzaCA9IHZhbDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGF0b21pY3MuJHB1c2guJGVhY2ggPSBhdG9taWNzLiRwdXNoLiRlYWNoLmNvbmNhdCh2YWwpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBhdG9taWNzW29wXSA9IHZhbDtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfSxcblxuICAvKipcbiAgICogQWRkcyB2YWx1ZXMgdG8gdGhlIGFycmF5IGlmIG5vdCBhbHJlYWR5IHByZXNlbnQuXG4gICAqXG4gICAqICMjIyMgRXhhbXBsZTpcbiAgICpcbiAgICogICAgIGNvbnNvbGUubG9nKGRvYy5hcnJheSkgLy8gWzIsMyw0XVxuICAgKiAgICAgY29uc3QgYWRkZWQgPSBkb2MuYXJyYXkuYWRkVG9TZXQoNCw1KTtcbiAgICogICAgIGNvbnNvbGUubG9nKGRvYy5hcnJheSkgLy8gWzIsMyw0LDVdXG4gICAqICAgICBjb25zb2xlLmxvZyhhZGRlZCkgICAgIC8vIFs1XVxuICAgKlxuICAgKiBAcGFyYW0gey4uLmFueX0gW2FyZ3NdXG4gICAqIEByZXR1cm4ge0FycmF5fSB0aGUgdmFsdWVzIHRoYXQgd2VyZSBhZGRlZFxuICAgKiBAbWVtYmVyT2YgTW9uZ29vc2VBcnJheVxuICAgKiBAYXBpIHB1YmxpY1xuICAgKiBAbWV0aG9kIGFkZFRvU2V0XG4gICAqL1xuXG4gIGFkZFRvU2V0KCkge1xuICAgIF9jaGVja01hbnVhbFBvcHVsYXRpb24odGhpcywgYXJndW1lbnRzKTtcblxuICAgIGxldCB2YWx1ZXMgPSBbXS5tYXAuY2FsbChhcmd1bWVudHMsIHRoaXMuX21hcENhc3QsIHRoaXMpO1xuICAgIHZhbHVlcyA9IHRoaXNbYXJyYXlTY2hlbWFTeW1ib2xdLmFwcGx5U2V0dGVycyh2YWx1ZXMsIHRoaXNbYXJyYXlQYXJlbnRTeW1ib2xdKTtcbiAgICBjb25zdCBhZGRlZCA9IFtdO1xuICAgIGxldCB0eXBlID0gJyc7XG4gICAgaWYgKHZhbHVlc1swXSBpbnN0YW5jZW9mIEFycmF5U3ViZG9jdW1lbnQpIHtcbiAgICAgIHR5cGUgPSAnZG9jJztcbiAgICB9IGVsc2UgaWYgKHZhbHVlc1swXSBpbnN0YW5jZW9mIERhdGUpIHtcbiAgICAgIHR5cGUgPSAnZGF0ZSc7XG4gICAgfSBlbHNlIGlmIChpc0Jzb25UeXBlKHZhbHVlc1swXSwgJ09iamVjdElkJykpIHtcbiAgICAgIHR5cGUgPSAnT2JqZWN0SWQnO1xuICAgIH1cblxuICAgIGNvbnN0IHJhd1ZhbHVlcyA9IHV0aWxzLmlzTW9uZ29vc2VBcnJheSh2YWx1ZXMpID8gdmFsdWVzLl9fYXJyYXkgOiB0aGlzO1xuICAgIGNvbnN0IHJhd0FycmF5ID0gdXRpbHMuaXNNb25nb29zZUFycmF5KHRoaXMpID8gdGhpcy5fX2FycmF5IDogdGhpcztcblxuICAgIHJhd1ZhbHVlcy5mb3JFYWNoKGZ1bmN0aW9uKHYpIHtcbiAgICAgIGxldCBmb3VuZDtcbiAgICAgIGNvbnN0IHZhbCA9ICt2O1xuICAgICAgc3dpdGNoICh0eXBlKSB7XG4gICAgICAgIGNhc2UgJ2RvYyc6XG4gICAgICAgICAgZm91bmQgPSB0aGlzLnNvbWUoZnVuY3Rpb24oZG9jKSB7XG4gICAgICAgICAgICByZXR1cm4gZG9jLmVxdWFscyh2KTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAnZGF0ZSc6XG4gICAgICAgICAgZm91bmQgPSB0aGlzLnNvbWUoZnVuY3Rpb24oZCkge1xuICAgICAgICAgICAgcmV0dXJuICtkID09PSB2YWw7XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ09iamVjdElkJzpcbiAgICAgICAgICBmb3VuZCA9IHRoaXMuZmluZChvID0+IG8udG9TdHJpbmcoKSA9PT0gdi50b1N0cmluZygpKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICBmb3VuZCA9IH50aGlzLmluZGV4T2Yodik7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICB9XG5cbiAgICAgIGlmICghZm91bmQpIHtcbiAgICAgICAgdGhpcy5fbWFya01vZGlmaWVkKCk7XG4gICAgICAgIHJhd0FycmF5LnB1c2godik7XG4gICAgICAgIHRoaXMuX3JlZ2lzdGVyQXRvbWljKCckYWRkVG9TZXQnLCB2KTtcbiAgICAgICAgW10ucHVzaC5jYWxsKGFkZGVkLCB2KTtcbiAgICAgIH1cbiAgICB9LCB0aGlzKTtcblxuICAgIHJldHVybiBhZGRlZDtcbiAgfSxcblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgbnVtYmVyIG9mIHBlbmRpbmcgYXRvbWljIG9wZXJhdGlvbnMgdG8gc2VuZCB0byB0aGUgZGIgZm9yIHRoaXMgYXJyYXkuXG4gICAqXG4gICAqIEBhcGkgcHJpdmF0ZVxuICAgKiBAcmV0dXJuIHtOdW1iZXJ9XG4gICAqIEBtZXRob2QgaGFzQXRvbWljc1xuICAgKiBAbWVtYmVyT2YgTW9uZ29vc2VBcnJheVxuICAgKi9cblxuICBoYXNBdG9taWNzKCkge1xuICAgIGlmICghdXRpbHMuaXNQT0pPKHRoaXNbYXJyYXlBdG9taWNzU3ltYm9sXSkpIHtcbiAgICAgIHJldHVybiAwO1xuICAgIH1cblxuICAgIHJldHVybiBPYmplY3Qua2V5cyh0aGlzW2FycmF5QXRvbWljc1N5bWJvbF0pLmxlbmd0aDtcbiAgfSxcblxuICAvKipcbiAgICogUmV0dXJuIHdoZXRoZXIgb3Igbm90IHRoZSBgb2JqYCBpcyBpbmNsdWRlZCBpbiB0aGUgYXJyYXkuXG4gICAqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvYmogdGhlIGl0ZW0gdG8gY2hlY2tcbiAgICogQHBhcmFtIHtOdW1iZXJ9IGZyb21JbmRleFxuICAgKiBAcmV0dXJuIHtCb29sZWFufVxuICAgKiBAYXBpIHB1YmxpY1xuICAgKiBAbWV0aG9kIGluY2x1ZGVzXG4gICAqIEBtZW1iZXJPZiBNb25nb29zZUFycmF5XG4gICAqL1xuXG4gIGluY2x1ZGVzKG9iaiwgZnJvbUluZGV4KSB7XG4gICAgY29uc3QgcmV0ID0gdGhpcy5pbmRleE9mKG9iaiwgZnJvbUluZGV4KTtcbiAgICByZXR1cm4gcmV0ICE9PSAtMTtcbiAgfSxcblxuICAvKipcbiAgICogUmV0dXJuIHRoZSBpbmRleCBvZiBgb2JqYCBvciBgLTFgIGlmIG5vdCBmb3VuZC5cbiAgICpcbiAgICogQHBhcmFtIHtPYmplY3R9IG9iaiB0aGUgaXRlbSB0byBsb29rIGZvclxuICAgKiBAcGFyYW0ge051bWJlcn0gZnJvbUluZGV4XG4gICAqIEByZXR1cm4ge051bWJlcn1cbiAgICogQGFwaSBwdWJsaWNcbiAgICogQG1ldGhvZCBpbmRleE9mXG4gICAqIEBtZW1iZXJPZiBNb25nb29zZUFycmF5XG4gICAqL1xuXG4gIGluZGV4T2Yob2JqLCBmcm9tSW5kZXgpIHtcbiAgICBpZiAoaXNCc29uVHlwZShvYmosICdPYmplY3RJZCcpKSB7XG4gICAgICBvYmogPSBvYmoudG9TdHJpbmcoKTtcbiAgICB9XG5cbiAgICBmcm9tSW5kZXggPSBmcm9tSW5kZXggPT0gbnVsbCA/IDAgOiBmcm9tSW5kZXg7XG4gICAgY29uc3QgbGVuID0gdGhpcy5sZW5ndGg7XG4gICAgZm9yIChsZXQgaSA9IGZyb21JbmRleDsgaSA8IGxlbjsgKytpKSB7XG4gICAgICBpZiAob2JqID09IHRoaXNbaV0pIHtcbiAgICAgICAgcmV0dXJuIGk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiAtMTtcbiAgfSxcblxuICAvKipcbiAgICogSGVscGVyIGZvciBjb25zb2xlLmxvZ1xuICAgKlxuICAgKiBAYXBpIHB1YmxpY1xuICAgKiBAbWV0aG9kIGluc3BlY3RcbiAgICogQG1lbWJlck9mIE1vbmdvb3NlQXJyYXlcbiAgICovXG5cbiAgaW5zcGVjdCgpIHtcbiAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkodGhpcyk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIFB1c2hlcyBpdGVtcyB0byB0aGUgYXJyYXkgbm9uLWF0b21pY2FsbHkuXG4gICAqXG4gICAqICMjIyMgTm90ZTpcbiAgICpcbiAgICogX21hcmtzIHRoZSBlbnRpcmUgYXJyYXkgYXMgbW9kaWZpZWQsIHdoaWNoIGlmIHNhdmVkLCB3aWxsIHN0b3JlIGl0IGFzIGEgYCRzZXRgIG9wZXJhdGlvbiwgcG90ZW50aWFsbHkgb3ZlcndyaXR0aW5nIGFueSBjaGFuZ2VzIHRoYXQgaGFwcGVuIGJldHdlZW4gd2hlbiB5b3UgcmV0cmlldmVkIHRoZSBvYmplY3QgYW5kIHdoZW4geW91IHNhdmUgaXQuX1xuICAgKlxuICAgKiBAcGFyYW0gey4uLmFueX0gW2FyZ3NdXG4gICAqIEBhcGkgcHVibGljXG4gICAqIEBtZXRob2Qgbm9uQXRvbWljUHVzaFxuICAgKiBAbWVtYmVyT2YgTW9uZ29vc2VBcnJheVxuICAgKi9cblxuICBub25BdG9taWNQdXNoKCkge1xuICAgIGNvbnN0IHZhbHVlcyA9IFtdLm1hcC5jYWxsKGFyZ3VtZW50cywgdGhpcy5fbWFwQ2FzdCwgdGhpcyk7XG4gICAgdGhpcy5fbWFya01vZGlmaWVkKCk7XG4gICAgY29uc3QgcmV0ID0gW10ucHVzaC5hcHBseSh0aGlzLCB2YWx1ZXMpO1xuICAgIHRoaXMuX3JlZ2lzdGVyQXRvbWljKCckc2V0JywgdGhpcyk7XG4gICAgcmV0dXJuIHJldDtcbiAgfSxcblxuICAvKipcbiAgICogV3JhcHMgW2BBcnJheSNwb3BgXShodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9BcnJheS9wb3ApIHdpdGggcHJvcGVyIGNoYW5nZSB0cmFja2luZy5cbiAgICpcbiAgICogIyMjIyBOb3RlOlxuICAgKlxuICAgKiBfbWFya3MgdGhlIGVudGlyZSBhcnJheSBhcyBtb2RpZmllZCB3aGljaCB3aWxsIHBhc3MgdGhlIGVudGlyZSB0aGluZyB0byAkc2V0IHBvdGVudGlhbGx5IG92ZXJ3cml0aW5nIGFueSBjaGFuZ2VzIHRoYXQgaGFwcGVuIGJldHdlZW4gd2hlbiB5b3UgcmV0cmlldmVkIHRoZSBvYmplY3QgYW5kIHdoZW4geW91IHNhdmUgaXQuX1xuICAgKlxuICAgKiBAc2VlIE1vbmdvb3NlQXJyYXkjJHBvcCBodHRwczovL21vbmdvb3NlanMuY29tL2RvY3MvYXBpL2FycmF5Lmh0bWwjTW9uZ29vc2VBcnJheS5wcm90b3R5cGUuJHBvcCgpXG4gICAqIEBhcGkgcHVibGljXG4gICAqIEBtZXRob2QgcG9wXG4gICAqIEBtZW1iZXJPZiBNb25nb29zZUFycmF5XG4gICAqL1xuXG4gIHBvcCgpIHtcbiAgICB0aGlzLl9tYXJrTW9kaWZpZWQoKTtcbiAgICBjb25zdCByZXQgPSBbXS5wb3AuY2FsbCh0aGlzKTtcbiAgICB0aGlzLl9yZWdpc3RlckF0b21pYygnJHNldCcsIHRoaXMpO1xuICAgIHJldHVybiByZXQ7XG4gIH0sXG5cbiAgLyoqXG4gICAqIFB1bGxzIGl0ZW1zIGZyb20gdGhlIGFycmF5IGF0b21pY2FsbHkuIEVxdWFsaXR5IGlzIGRldGVybWluZWQgYnkgY2FzdGluZ1xuICAgKiB0aGUgcHJvdmlkZWQgdmFsdWUgdG8gYW4gZW1iZWRkZWQgZG9jdW1lbnQgYW5kIGNvbXBhcmluZyB1c2luZ1xuICAgKiBbdGhlIGBEb2N1bWVudC5lcXVhbHMoKWAgZnVuY3Rpb24uXShodHRwczovL21vbmdvb3NlanMuY29tL2RvY3MvYXBpL2RvY3VtZW50Lmh0bWwjRG9jdW1lbnQucHJvdG90eXBlLmVxdWFscygpKVxuICAgKlxuICAgKiAjIyMjIEV4YW1wbGU6XG4gICAqXG4gICAqICAgICBkb2MuYXJyYXkucHVsbChPYmplY3RJZClcbiAgICogICAgIGRvYy5hcnJheS5wdWxsKHsgX2lkOiAnc29tZUlkJyB9KVxuICAgKiAgICAgZG9jLmFycmF5LnB1bGwoMzYpXG4gICAqICAgICBkb2MuYXJyYXkucHVsbCgndGFnIDEnLCAndGFnIDInKVxuICAgKlxuICAgKiBUbyByZW1vdmUgYSBkb2N1bWVudCBmcm9tIGEgc3ViZG9jdW1lbnQgYXJyYXkgd2UgbWF5IHBhc3MgYW4gb2JqZWN0IHdpdGggYSBtYXRjaGluZyBgX2lkYC5cbiAgICpcbiAgICogICAgIGRvYy5zdWJkb2NzLnB1c2goeyBfaWQ6IDQ4MTUxNjIzNDIgfSlcbiAgICogICAgIGRvYy5zdWJkb2NzLnB1bGwoeyBfaWQ6IDQ4MTUxNjIzNDIgfSkgLy8gcmVtb3ZlZFxuICAgKlxuICAgKiBPciB3ZSBtYXkgcGFzc2luZyB0aGUgX2lkIGRpcmVjdGx5IGFuZCBsZXQgbW9uZ29vc2UgdGFrZSBjYXJlIG9mIGl0LlxuICAgKlxuICAgKiAgICAgZG9jLnN1YmRvY3MucHVzaCh7IF9pZDogNDgxNTE2MjM0MiB9KVxuICAgKiAgICAgZG9jLnN1YmRvY3MucHVsbCg0ODE1MTYyMzQyKTsgLy8gd29ya3NcbiAgICpcbiAgICogVGhlIGZpcnN0IHB1bGwgY2FsbCB3aWxsIHJlc3VsdCBpbiBhIGF0b21pYyBvcGVyYXRpb24gb24gdGhlIGRhdGFiYXNlLCBpZiBwdWxsIGlzIGNhbGxlZCByZXBlYXRlZGx5IHdpdGhvdXQgc2F2aW5nIHRoZSBkb2N1bWVudCwgYSAkc2V0IG9wZXJhdGlvbiBpcyB1c2VkIG9uIHRoZSBjb21wbGV0ZSBhcnJheSBpbnN0ZWFkLCBvdmVyd3JpdGluZyBwb3NzaWJsZSBjaGFuZ2VzIHRoYXQgaGFwcGVuZWQgb24gdGhlIGRhdGFiYXNlIGluIHRoZSBtZWFudGltZS5cbiAgICpcbiAgICogQHBhcmFtIHsuLi5hbnl9IFthcmdzXVxuICAgKiBAc2VlIG1vbmdvZGIgaHR0cHM6Ly93d3cubW9uZ29kYi5jb20vZG9jcy9tYW51YWwvcmVmZXJlbmNlL29wZXJhdG9yL3VwZGF0ZS9wdWxsL1xuICAgKiBAYXBpIHB1YmxpY1xuICAgKiBAbWV0aG9kIHB1bGxcbiAgICogQG1lbWJlck9mIE1vbmdvb3NlQXJyYXlcbiAgICovXG5cbiAgcHVsbCgpIHtcbiAgICBjb25zdCB2YWx1ZXMgPSBbXS5tYXAuY2FsbChhcmd1bWVudHMsICh2LCBpKSA9PiB0aGlzLl9jYXN0KHYsIGksIHsgZGVmYXVsdHM6IGZhbHNlIH0pLCB0aGlzKTtcbiAgICBjb25zdCBjdXIgPSB0aGlzW2FycmF5UGFyZW50U3ltYm9sXS5nZXQodGhpc1thcnJheVBhdGhTeW1ib2xdKTtcbiAgICBsZXQgaSA9IGN1ci5sZW5ndGg7XG4gICAgbGV0IG1lbTtcbiAgICB0aGlzLl9tYXJrTW9kaWZpZWQoKTtcblxuICAgIHdoaWxlIChpLS0pIHtcbiAgICAgIG1lbSA9IGN1cltpXTtcbiAgICAgIGlmIChtZW0gaW5zdGFuY2VvZiBEb2N1bWVudCkge1xuICAgICAgICBjb25zdCBzb21lID0gdmFsdWVzLnNvbWUoZnVuY3Rpb24odikge1xuICAgICAgICAgIHJldHVybiBtZW0uZXF1YWxzKHYpO1xuICAgICAgICB9KTtcbiAgICAgICAgaWYgKHNvbWUpIHtcbiAgICAgICAgICBbXS5zcGxpY2UuY2FsbChjdXIsIGksIDEpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKH5jdXIuaW5kZXhPZi5jYWxsKHZhbHVlcywgbWVtKSkge1xuICAgICAgICBbXS5zcGxpY2UuY2FsbChjdXIsIGksIDEpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmICh2YWx1ZXNbMF0gaW5zdGFuY2VvZiBBcnJheVN1YmRvY3VtZW50KSB7XG4gICAgICB0aGlzLl9yZWdpc3RlckF0b21pYygnJHB1bGxEb2NzJywgdmFsdWVzLm1hcChmdW5jdGlvbih2KSB7XG4gICAgICAgIGNvbnN0IF9pZCA9IHYuJF9fZ2V0VmFsdWUoJ19pZCcpO1xuICAgICAgICBpZiAoX2lkID09PSB1bmRlZmluZWQgfHwgdi4kaXNEZWZhdWx0KCdfaWQnKSkge1xuICAgICAgICAgIHJldHVybiB2O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBfaWQ7XG4gICAgICB9KSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuX3JlZ2lzdGVyQXRvbWljKCckcHVsbEFsbCcsIHZhbHVlcyk7XG4gICAgfVxuXG5cbiAgICAvLyBNaWdodCBoYXZlIG1vZGlmaWVkIGNoaWxkIHBhdGhzIGFuZCB0aGVuIHB1bGxlZCwgbGlrZVxuICAgIC8vIGBkb2MuY2hpbGRyZW5bMV0ubmFtZSA9ICd0ZXN0JztgIGZvbGxvd2VkIGJ5XG4gICAgLy8gYGRvYy5jaGlsZHJlbi5yZW1vdmUoZG9jLmNoaWxkcmVuWzBdKTtgLiBJbiB0aGlzIGNhc2Ugd2UgZmFsbCBiYWNrXG4gICAgLy8gdG8gYSBgJHNldGAgb24gdGhlIHdob2xlIGFycmF5LiBTZWUgIzM1MTFcbiAgICBpZiAoY2xlYW5Nb2RpZmllZFN1YnBhdGhzKHRoaXNbYXJyYXlQYXJlbnRTeW1ib2xdLCB0aGlzW2FycmF5UGF0aFN5bWJvbF0pID4gMCkge1xuICAgICAgdGhpcy5fcmVnaXN0ZXJBdG9taWMoJyRzZXQnLCB0aGlzKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfSxcblxuICAvKipcbiAgICogV3JhcHMgW2BBcnJheSNwdXNoYF0oaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4vSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvQXJyYXkvcHVzaCkgd2l0aCBwcm9wZXIgY2hhbmdlIHRyYWNraW5nLlxuICAgKlxuICAgKiAjIyMjIEV4YW1wbGU6XG4gICAqXG4gICAqICAgICBjb25zdCBzY2hlbWEgPSBTY2hlbWEoeyBudW1zOiBbTnVtYmVyXSB9KTtcbiAgICogICAgIGNvbnN0IE1vZGVsID0gbW9uZ29vc2UubW9kZWwoJ1Rlc3QnLCBzY2hlbWEpO1xuICAgKlxuICAgKiAgICAgY29uc3QgZG9jID0gYXdhaXQgTW9kZWwuY3JlYXRlKHsgbnVtczogWzMsIDRdIH0pO1xuICAgKiAgICAgZG9jLm51bXMucHVzaCg1KTsgLy8gQWRkIDUgdG8gdGhlIGVuZCBvZiB0aGUgYXJyYXlcbiAgICogICAgIGF3YWl0IGRvYy5zYXZlKCk7XG4gICAqXG4gICAqICAgICAvLyBZb3UgY2FuIGFsc28gcGFzcyBhbiBvYmplY3Qgd2l0aCBgJGVhY2hgIGFzIHRoZVxuICAgKiAgICAgLy8gZmlyc3QgcGFyYW1ldGVyIHRvIHVzZSBNb25nb0RCJ3MgYCRwb3NpdGlvbmBcbiAgICogICAgIGRvYy5udW1zLnB1c2goe1xuICAgKiAgICAgICAkZWFjaDogWzEsIDJdLFxuICAgKiAgICAgICAkcG9zaXRpb246IDBcbiAgICogICAgIH0pO1xuICAgKiAgICAgZG9jLm51bXM7IC8vIFsxLCAyLCAzLCA0LCA1XVxuICAgKlxuICAgKiBAcGFyYW0gey4uLk9iamVjdH0gW2FyZ3NdXG4gICAqIEBhcGkgcHVibGljXG4gICAqIEBtZXRob2QgcHVzaFxuICAgKiBAbWVtYmVyT2YgTW9uZ29vc2VBcnJheVxuICAgKi9cblxuICBwdXNoKCkge1xuICAgIGxldCB2YWx1ZXMgPSBhcmd1bWVudHM7XG4gICAgbGV0IGF0b21pYyA9IHZhbHVlcztcbiAgICBjb25zdCBpc092ZXJ3cml0ZSA9IHZhbHVlc1swXSAhPSBudWxsICYmXG4gICAgICB1dGlscy5oYXNVc2VyRGVmaW5lZFByb3BlcnR5KHZhbHVlc1swXSwgJyRlYWNoJyk7XG4gICAgY29uc3QgYXJyID0gdXRpbHMuaXNNb25nb29zZUFycmF5KHRoaXMpID8gdGhpcy5fX2FycmF5IDogdGhpcztcbiAgICBpZiAoaXNPdmVyd3JpdGUpIHtcbiAgICAgIGF0b21pYyA9IHZhbHVlc1swXTtcbiAgICAgIHZhbHVlcyA9IHZhbHVlc1swXS4kZWFjaDtcbiAgICB9XG5cbiAgICBpZiAodGhpc1thcnJheVNjaGVtYVN5bWJvbF0gPT0gbnVsbCkge1xuICAgICAgcmV0dXJuIF9iYXNlUHVzaC5hcHBseSh0aGlzLCB2YWx1ZXMpO1xuICAgIH1cblxuICAgIF9jaGVja01hbnVhbFBvcHVsYXRpb24odGhpcywgdmFsdWVzKTtcblxuICAgIGNvbnN0IHBhcmVudCA9IHRoaXNbYXJyYXlQYXJlbnRTeW1ib2xdO1xuICAgIHZhbHVlcyA9IFtdLm1hcC5jYWxsKHZhbHVlcywgdGhpcy5fbWFwQ2FzdCwgdGhpcyk7XG4gICAgdmFsdWVzID0gdGhpc1thcnJheVNjaGVtYVN5bWJvbF0uYXBwbHlTZXR0ZXJzKHZhbHVlcywgcGFyZW50LCB1bmRlZmluZWQsXG4gICAgICB1bmRlZmluZWQsIHsgc2tpcERvY3VtZW50QXJyYXlDYXN0OiB0cnVlIH0pO1xuICAgIGxldCByZXQ7XG4gICAgY29uc3QgYXRvbWljcyA9IHRoaXNbYXJyYXlBdG9taWNzU3ltYm9sXTtcbiAgICB0aGlzLl9tYXJrTW9kaWZpZWQoKTtcbiAgICBpZiAoaXNPdmVyd3JpdGUpIHtcbiAgICAgIGF0b21pYy4kZWFjaCA9IHZhbHVlcztcblxuICAgICAgaWYgKChhdG9taWNzLiRwdXNoICYmIGF0b21pY3MuJHB1c2guJGVhY2ggJiYgYXRvbWljcy4kcHVzaC4kZWFjaC5sZW5ndGggfHwgMCkgIT09IDAgJiZcbiAgICAgICAgICBhdG9taWNzLiRwdXNoLiRwb3NpdGlvbiAhPSBhdG9taWMuJHBvc2l0aW9uKSB7XG4gICAgICAgIHRocm93IG5ldyBNb25nb29zZUVycm9yKCdDYW5ub3QgY2FsbCBgQXJyYXkjcHVzaCgpYCBtdWx0aXBsZSB0aW1lcyAnICtcbiAgICAgICAgICAnd2l0aCBkaWZmZXJlbnQgYCRwb3NpdGlvbmAnKTtcbiAgICAgIH1cblxuICAgICAgaWYgKGF0b21pYy4kcG9zaXRpb24gIT0gbnVsbCkge1xuICAgICAgICBbXS5zcGxpY2UuYXBwbHkoYXJyLCBbYXRvbWljLiRwb3NpdGlvbiwgMF0uY29uY2F0KHZhbHVlcykpO1xuICAgICAgICByZXQgPSB0aGlzLmxlbmd0aDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldCA9IFtdLnB1c2guYXBwbHkoYXJyLCB2YWx1ZXMpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoKGF0b21pY3MuJHB1c2ggJiYgYXRvbWljcy4kcHVzaC4kZWFjaCAmJiBhdG9taWNzLiRwdXNoLiRlYWNoLmxlbmd0aCB8fCAwKSAhPT0gMCAmJlxuICAgICAgICAgIGF0b21pY3MuJHB1c2guJHBvc2l0aW9uICE9IG51bGwpIHtcbiAgICAgICAgdGhyb3cgbmV3IE1vbmdvb3NlRXJyb3IoJ0Nhbm5vdCBjYWxsIGBBcnJheSNwdXNoKClgIG11bHRpcGxlIHRpbWVzICcgK1xuICAgICAgICAgICd3aXRoIGRpZmZlcmVudCBgJHBvc2l0aW9uYCcpO1xuICAgICAgfVxuICAgICAgYXRvbWljID0gdmFsdWVzO1xuICAgICAgcmV0ID0gW10ucHVzaC5hcHBseShhcnIsIHZhbHVlcyk7XG4gICAgfVxuXG4gICAgdGhpcy5fcmVnaXN0ZXJBdG9taWMoJyRwdXNoJywgYXRvbWljKTtcbiAgICByZXR1cm4gcmV0O1xuICB9LFxuXG4gIC8qKlxuICAgKiBBbGlhcyBvZiBbcHVsbF0oaHR0cHM6Ly9tb25nb29zZWpzLmNvbS9kb2NzL2FwaS9hcnJheS5odG1sI01vbmdvb3NlQXJyYXkucHJvdG90eXBlLnB1bGwoKSlcbiAgICpcbiAgICogQHNlZSBNb25nb29zZUFycmF5I3B1bGwgaHR0cHM6Ly9tb25nb29zZWpzLmNvbS9kb2NzL2FwaS9hcnJheS5odG1sI01vbmdvb3NlQXJyYXkucHJvdG90eXBlLnB1bGwoKVxuICAgKiBAc2VlIG1vbmdvZGIgaHR0cHM6Ly93d3cubW9uZ29kYi5jb20vZG9jcy9tYW51YWwvcmVmZXJlbmNlL29wZXJhdG9yL3VwZGF0ZS9wdWxsL1xuICAgKiBAYXBpIHB1YmxpY1xuICAgKiBAbWVtYmVyT2YgTW9uZ29vc2VBcnJheVxuICAgKiBAaW5zdGFuY2VcbiAgICogQG1ldGhvZCByZW1vdmVcbiAgICovXG5cbiAgcmVtb3ZlKCkge1xuICAgIHJldHVybiB0aGlzLnB1bGwuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgfSxcblxuICAvKipcbiAgICogU2V0cyB0aGUgY2FzdGVkIGB2YWxgIGF0IGluZGV4IGBpYCBhbmQgbWFya3MgdGhlIGFycmF5IG1vZGlmaWVkLlxuICAgKlxuICAgKiAjIyMjIEV4YW1wbGU6XG4gICAqXG4gICAqICAgICAvLyBnaXZlbiBkb2N1bWVudHMgYmFzZWQgb24gdGhlIGZvbGxvd2luZ1xuICAgKiAgICAgY29uc3QgRG9jID0gbW9uZ29vc2UubW9kZWwoJ0RvYycsIG5ldyBTY2hlbWEoeyBhcnJheTogW051bWJlcl0gfSkpO1xuICAgKlxuICAgKiAgICAgY29uc3QgZG9jID0gbmV3IERvYyh7IGFycmF5OiBbMiwzLDRdIH0pXG4gICAqXG4gICAqICAgICBjb25zb2xlLmxvZyhkb2MuYXJyYXkpIC8vIFsyLDMsNF1cbiAgICpcbiAgICogICAgIGRvYy5hcnJheS5zZXQoMSxcIjVcIik7XG4gICAqICAgICBjb25zb2xlLmxvZyhkb2MuYXJyYXkpOyAvLyBbMiw1LDRdIC8vIHByb3Blcmx5IGNhc3QgdG8gbnVtYmVyXG4gICAqICAgICBkb2Muc2F2ZSgpIC8vIHRoZSBjaGFuZ2UgaXMgc2F2ZWRcbiAgICpcbiAgICogICAgIC8vIFZTIG5vdCB1c2luZyBhcnJheSNzZXRcbiAgICogICAgIGRvYy5hcnJheVsxXSA9IFwiNVwiO1xuICAgKiAgICAgY29uc29sZS5sb2coZG9jLmFycmF5KTsgLy8gWzIsXCI1XCIsNF0gLy8gbm8gY2FzdGluZ1xuICAgKiAgICAgZG9jLnNhdmUoKSAvLyBjaGFuZ2UgaXMgbm90IHNhdmVkXG4gICAqXG4gICAqIEByZXR1cm4ge0FycmF5fSB0aGlzXG4gICAqIEBhcGkgcHVibGljXG4gICAqIEBtZXRob2Qgc2V0XG4gICAqIEBtZW1iZXJPZiBNb25nb29zZUFycmF5XG4gICAqL1xuXG4gIHNldChpLCB2YWwsIHNraXBNb2RpZmllZCkge1xuICAgIGNvbnN0IGFyciA9IHRoaXMuX19hcnJheTtcbiAgICBpZiAoc2tpcE1vZGlmaWVkKSB7XG4gICAgICBhcnJbaV0gPSB2YWw7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgY29uc3QgdmFsdWUgPSBtZXRob2RzLl9jYXN0LmNhbGwodGhpcywgdmFsLCBpKTtcbiAgICBtZXRob2RzLl9tYXJrTW9kaWZpZWQuY2FsbCh0aGlzLCBpKTtcbiAgICBhcnJbaV0gPSB2YWx1ZTtcbiAgICByZXR1cm4gdGhpcztcbiAgfSxcblxuICAvKipcbiAgICogV3JhcHMgW2BBcnJheSNzaGlmdGBdKGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL0FycmF5L3Vuc2hpZnQpIHdpdGggcHJvcGVyIGNoYW5nZSB0cmFja2luZy5cbiAgICpcbiAgICogIyMjIyBFeGFtcGxlOlxuICAgKlxuICAgKiAgICAgZG9jLmFycmF5ID0gWzIsM107XG4gICAqICAgICBjb25zdCByZXMgPSBkb2MuYXJyYXkuc2hpZnQoKTtcbiAgICogICAgIGNvbnNvbGUubG9nKHJlcykgLy8gMlxuICAgKiAgICAgY29uc29sZS5sb2coZG9jLmFycmF5KSAvLyBbM11cbiAgICpcbiAgICogIyMjIyBOb3RlOlxuICAgKlxuICAgKiBfbWFya3MgdGhlIGVudGlyZSBhcnJheSBhcyBtb2RpZmllZCwgd2hpY2ggaWYgc2F2ZWQsIHdpbGwgc3RvcmUgaXQgYXMgYSBgJHNldGAgb3BlcmF0aW9uLCBwb3RlbnRpYWxseSBvdmVyd3JpdHRpbmcgYW55IGNoYW5nZXMgdGhhdCBoYXBwZW4gYmV0d2VlbiB3aGVuIHlvdSByZXRyaWV2ZWQgdGhlIG9iamVjdCBhbmQgd2hlbiB5b3Ugc2F2ZSBpdC5fXG4gICAqXG4gICAqIEBhcGkgcHVibGljXG4gICAqIEBtZXRob2Qgc2hpZnRcbiAgICogQG1lbWJlck9mIE1vbmdvb3NlQXJyYXlcbiAgICovXG5cbiAgc2hpZnQoKSB7XG4gICAgY29uc3QgYXJyID0gdXRpbHMuaXNNb25nb29zZUFycmF5KHRoaXMpID8gdGhpcy5fX2FycmF5IDogdGhpcztcbiAgICB0aGlzLl9tYXJrTW9kaWZpZWQoKTtcbiAgICBjb25zdCByZXQgPSBbXS5zaGlmdC5jYWxsKGFycik7XG4gICAgdGhpcy5fcmVnaXN0ZXJBdG9taWMoJyRzZXQnLCB0aGlzKTtcbiAgICByZXR1cm4gcmV0O1xuICB9LFxuXG4gIC8qKlxuICAgKiBXcmFwcyBbYEFycmF5I3NvcnRgXShodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9BcnJheS9zb3J0KSB3aXRoIHByb3BlciBjaGFuZ2UgdHJhY2tpbmcuXG4gICAqXG4gICAqICMjIyMgTm90ZTpcbiAgICpcbiAgICogX21hcmtzIHRoZSBlbnRpcmUgYXJyYXkgYXMgbW9kaWZpZWQsIHdoaWNoIGlmIHNhdmVkLCB3aWxsIHN0b3JlIGl0IGFzIGEgYCRzZXRgIG9wZXJhdGlvbiwgcG90ZW50aWFsbHkgb3ZlcndyaXR0aW5nIGFueSBjaGFuZ2VzIHRoYXQgaGFwcGVuIGJldHdlZW4gd2hlbiB5b3UgcmV0cmlldmVkIHRoZSBvYmplY3QgYW5kIHdoZW4geW91IHNhdmUgaXQuX1xuICAgKlxuICAgKiBAYXBpIHB1YmxpY1xuICAgKiBAbWV0aG9kIHNvcnRcbiAgICogQG1lbWJlck9mIE1vbmdvb3NlQXJyYXlcbiAgICogQHNlZSBNYXN0ZXJpbmdKUzogQXJyYXkgc29ydCBodHRwczovL21hc3RlcmluZ2pzLmlvL3R1dG9yaWFscy9mdW5kYW1lbnRhbHMvYXJyYXktc29ydFxuICAgKi9cblxuICBzb3J0KCkge1xuICAgIGNvbnN0IGFyciA9IHV0aWxzLmlzTW9uZ29vc2VBcnJheSh0aGlzKSA/IHRoaXMuX19hcnJheSA6IHRoaXM7XG4gICAgY29uc3QgcmV0ID0gW10uc29ydC5hcHBseShhcnIsIGFyZ3VtZW50cyk7XG4gICAgdGhpcy5fcmVnaXN0ZXJBdG9taWMoJyRzZXQnLCB0aGlzKTtcbiAgICByZXR1cm4gcmV0O1xuICB9LFxuXG4gIC8qKlxuICAgKiBXcmFwcyBbYEFycmF5I3NwbGljZWBdKGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL0FycmF5L3NwbGljZSkgd2l0aCBwcm9wZXIgY2hhbmdlIHRyYWNraW5nIGFuZCBjYXN0aW5nLlxuICAgKlxuICAgKiAjIyMjIE5vdGU6XG4gICAqXG4gICAqIF9tYXJrcyB0aGUgZW50aXJlIGFycmF5IGFzIG1vZGlmaWVkLCB3aGljaCBpZiBzYXZlZCwgd2lsbCBzdG9yZSBpdCBhcyBhIGAkc2V0YCBvcGVyYXRpb24sIHBvdGVudGlhbGx5IG92ZXJ3cml0dGluZyBhbnkgY2hhbmdlcyB0aGF0IGhhcHBlbiBiZXR3ZWVuIHdoZW4geW91IHJldHJpZXZlZCB0aGUgb2JqZWN0IGFuZCB3aGVuIHlvdSBzYXZlIGl0Ll9cbiAgICpcbiAgICogQGFwaSBwdWJsaWNcbiAgICogQG1ldGhvZCBzcGxpY2VcbiAgICogQG1lbWJlck9mIE1vbmdvb3NlQXJyYXlcbiAgICogQHNlZSBNYXN0ZXJpbmdKUzogQXJyYXkgc3BsaWNlIGh0dHBzOi8vbWFzdGVyaW5nanMuaW8vdHV0b3JpYWxzL2Z1bmRhbWVudGFscy9hcnJheS1zcGxpY2VcbiAgICovXG5cbiAgc3BsaWNlKCkge1xuICAgIGxldCByZXQ7XG4gICAgY29uc3QgYXJyID0gdXRpbHMuaXNNb25nb29zZUFycmF5KHRoaXMpID8gdGhpcy5fX2FycmF5IDogdGhpcztcblxuICAgIHRoaXMuX21hcmtNb2RpZmllZCgpO1xuICAgIF9jaGVja01hbnVhbFBvcHVsYXRpb24odGhpcywgQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAyKSk7XG5cbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCkge1xuICAgICAgbGV0IHZhbHM7XG4gICAgICBpZiAodGhpc1thcnJheVNjaGVtYVN5bWJvbF0gPT0gbnVsbCkge1xuICAgICAgICB2YWxzID0gYXJndW1lbnRzO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFscyA9IFtdO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7ICsraSkge1xuICAgICAgICAgIHZhbHNbaV0gPSBpIDwgMiA/XG4gICAgICAgICAgICBhcmd1bWVudHNbaV0gOlxuICAgICAgICAgICAgdGhpcy5fY2FzdChhcmd1bWVudHNbaV0sIGFyZ3VtZW50c1swXSArIChpIC0gMikpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldCA9IFtdLnNwbGljZS5hcHBseShhcnIsIHZhbHMpO1xuICAgICAgdGhpcy5fcmVnaXN0ZXJBdG9taWMoJyRzZXQnLCB0aGlzKTtcbiAgICB9XG5cbiAgICByZXR1cm4gcmV0O1xuICB9LFxuXG4gIC8qIVxuICAgKiBpZ25vcmVcbiAgICovXG5cbiAgdG9CU09OKCkge1xuICAgIHJldHVybiB0aGlzLnRvT2JqZWN0KGludGVybmFsVG9PYmplY3RPcHRpb25zKTtcbiAgfSxcblxuICAvKipcbiAgICogUmV0dXJucyBhIG5hdGl2ZSBqcyBBcnJheS5cbiAgICpcbiAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcbiAgICogQHJldHVybiB7QXJyYXl9XG4gICAqIEBhcGkgcHVibGljXG4gICAqIEBtZXRob2QgdG9PYmplY3RcbiAgICogQG1lbWJlck9mIE1vbmdvb3NlQXJyYXlcbiAgICovXG5cbiAgdG9PYmplY3Qob3B0aW9ucykge1xuICAgIGNvbnN0IGFyciA9IHV0aWxzLmlzTW9uZ29vc2VBcnJheSh0aGlzKSA/IHRoaXMuX19hcnJheSA6IHRoaXM7XG4gICAgaWYgKG9wdGlvbnMgJiYgb3B0aW9ucy5kZXBvcHVsYXRlKSB7XG4gICAgICBvcHRpb25zID0gY2xvbmUob3B0aW9ucyk7XG4gICAgICBvcHRpb25zLl9pc05lc3RlZCA9IHRydWU7XG4gICAgICAvLyBFbnN1cmUgcmV0dXJuIHZhbHVlIGlzIGEgdmFuaWxsYSBhcnJheSwgYmVjYXVzZSBpbiBOb2RlLmpzIDYrIGBtYXAoKWBcbiAgICAgIC8vIGlzIHNtYXJ0IGVub3VnaCB0byB1c2UgdGhlIGluaGVyaXRlZCBhcnJheSdzIGNvbnN0cnVjdG9yLlxuICAgICAgcmV0dXJuIFtdLmNvbmNhdChhcnIpLm1hcChmdW5jdGlvbihkb2MpIHtcbiAgICAgICAgcmV0dXJuIGRvYyBpbnN0YW5jZW9mIERvY3VtZW50XG4gICAgICAgICAgPyBkb2MudG9PYmplY3Qob3B0aW9ucylcbiAgICAgICAgICA6IGRvYztcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIHJldHVybiBbXS5jb25jYXQoYXJyKTtcbiAgfSxcblxuICAkdG9PYmplY3QoKSB7XG4gICAgcmV0dXJuIHRoaXMuY29uc3RydWN0b3IucHJvdG90eXBlLnRvT2JqZWN0LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gIH0sXG4gIC8qKlxuICAgKiBXcmFwcyBbYEFycmF5I3Vuc2hpZnRgXShodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9BcnJheS91bnNoaWZ0KSB3aXRoIHByb3BlciBjaGFuZ2UgdHJhY2tpbmcuXG4gICAqXG4gICAqICMjIyMgTm90ZTpcbiAgICpcbiAgICogX21hcmtzIHRoZSBlbnRpcmUgYXJyYXkgYXMgbW9kaWZpZWQsIHdoaWNoIGlmIHNhdmVkLCB3aWxsIHN0b3JlIGl0IGFzIGEgYCRzZXRgIG9wZXJhdGlvbiwgcG90ZW50aWFsbHkgb3ZlcndyaXRpbmcgYW55IGNoYW5nZXMgdGhhdCBoYXBwZW4gYmV0d2VlbiB3aGVuIHlvdSByZXRyaWV2ZWQgdGhlIG9iamVjdCBhbmQgd2hlbiB5b3Ugc2F2ZSBpdC5fXG4gICAqXG4gICAqIEBhcGkgcHVibGljXG4gICAqIEBtZXRob2QgdW5zaGlmdFxuICAgKiBAbWVtYmVyT2YgTW9uZ29vc2VBcnJheVxuICAgKi9cblxuICB1bnNoaWZ0KCkge1xuICAgIF9jaGVja01hbnVhbFBvcHVsYXRpb24odGhpcywgYXJndW1lbnRzKTtcblxuICAgIGxldCB2YWx1ZXM7XG4gICAgaWYgKHRoaXNbYXJyYXlTY2hlbWFTeW1ib2xdID09IG51bGwpIHtcbiAgICAgIHZhbHVlcyA9IGFyZ3VtZW50cztcbiAgICB9IGVsc2Uge1xuICAgICAgdmFsdWVzID0gW10ubWFwLmNhbGwoYXJndW1lbnRzLCB0aGlzLl9jYXN0LCB0aGlzKTtcbiAgICAgIHZhbHVlcyA9IHRoaXNbYXJyYXlTY2hlbWFTeW1ib2xdLmFwcGx5U2V0dGVycyh2YWx1ZXMsIHRoaXNbYXJyYXlQYXJlbnRTeW1ib2xdKTtcbiAgICB9XG5cbiAgICBjb25zdCBhcnIgPSB1dGlscy5pc01vbmdvb3NlQXJyYXkodGhpcykgPyB0aGlzLl9fYXJyYXkgOiB0aGlzO1xuICAgIHRoaXMuX21hcmtNb2RpZmllZCgpO1xuICAgIFtdLnVuc2hpZnQuYXBwbHkoYXJyLCB2YWx1ZXMpO1xuICAgIHRoaXMuX3JlZ2lzdGVyQXRvbWljKCckc2V0JywgdGhpcyk7XG4gICAgcmV0dXJuIHRoaXMubGVuZ3RoO1xuICB9XG59O1xuXG4vKiFcbiAqIGlnbm9yZVxuICovXG5cbmZ1bmN0aW9uIF9pc0FsbFN1YmRvY3MoZG9jcywgcmVmKSB7XG4gIGlmICghcmVmKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgZm9yIChjb25zdCBhcmcgb2YgZG9jcykge1xuICAgIGlmIChhcmcgPT0gbnVsbCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBjb25zdCBtb2RlbCA9IGFyZy5jb25zdHJ1Y3RvcjtcbiAgICBpZiAoIShhcmcgaW5zdGFuY2VvZiBEb2N1bWVudCkgfHxcbiAgICAgIChtb2RlbC5tb2RlbE5hbWUgIT09IHJlZiAmJiBtb2RlbC5iYXNlTW9kZWxOYW1lICE9PSByZWYpKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHRydWU7XG59XG5cbi8qIVxuICogTWluaW1pemUgX2p1c3RfIGVtcHR5IG9iamVjdHMgYWxvbmcgdGhlIHBhdGggY2hhaW4gc3BlY2lmaWVkXG4gKiBieSBgcGFydHNgLCBpZ25vcmluZyBhbGwgb3RoZXIgcGF0aHMuIFVzZWZ1bCBpbiBjYXNlcyB3aGVyZVxuICogeW91IHdhbnQgdG8gbWluaW1pemUgYWZ0ZXIgdW5zZXR0aW5nIGEgcGF0aC5cbiAqXG4gKiAjIyMjIEV4YW1wbGU6XG4gKlxuICogICAgIGNvbnN0IG9iaiA9IHsgZm9vOiB7IGJhcjogeyBiYXo6IHt9IH0gfSwgYToge30gfTtcbiAqICAgICBfbWluaW1pemVQYXRoKG9iaiwgJ2Zvby5iYXIuYmF6Jyk7XG4gKiAgICAgb2JqOyAvLyB7IGE6IHt9IH1cbiAqL1xuXG5mdW5jdGlvbiBfbWluaW1pemVQYXRoKG9iaiwgcGFydHMsIGkpIHtcbiAgaWYgKHR5cGVvZiBwYXJ0cyA9PT0gJ3N0cmluZycpIHtcbiAgICBpZiAocGFydHMuaW5kZXhPZignLicpID09PSAtMSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHBhcnRzID0gbXBhdGguc3RyaW5nVG9QYXJ0cyhwYXJ0cyk7XG4gIH1cbiAgaSA9IGkgfHwgMDtcbiAgaWYgKGkgPj0gcGFydHMubGVuZ3RoKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGlmIChvYmogPT0gbnVsbCB8fCB0eXBlb2Ygb2JqICE9PSAnb2JqZWN0Jykge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIF9taW5pbWl6ZVBhdGgob2JqW3BhcnRzWzBdXSwgcGFydHMsIGkgKyAxKTtcbiAgaWYgKG9ialtwYXJ0c1swXV0gIT0gbnVsbCAmJiB0eXBlb2Ygb2JqW3BhcnRzWzBdXSA9PT0gJ29iamVjdCcgJiYgT2JqZWN0LmtleXMob2JqW3BhcnRzWzBdXSkubGVuZ3RoID09PSAwKSB7XG4gICAgZGVsZXRlIG9ialtwYXJ0c1swXV07XG4gIH1cbn1cblxuLyohXG4gKiBpZ25vcmVcbiAqL1xuXG5mdW5jdGlvbiBfY2hlY2tNYW51YWxQb3B1bGF0aW9uKGFyciwgZG9jcykge1xuICBjb25zdCByZWYgPSBhcnIgPT0gbnVsbCA/XG4gICAgbnVsbCA6XG4gICAgYXJyW2FycmF5U2NoZW1hU3ltYm9sXSAmJiBhcnJbYXJyYXlTY2hlbWFTeW1ib2xdLmNhc3RlciAmJiBhcnJbYXJyYXlTY2hlbWFTeW1ib2xdLmNhc3Rlci5vcHRpb25zICYmIGFyclthcnJheVNjaGVtYVN5bWJvbF0uY2FzdGVyLm9wdGlvbnMucmVmIHx8IG51bGw7XG4gIGlmIChhcnIubGVuZ3RoID09PSAwICYmXG4gICAgICBkb2NzLmxlbmd0aCAhPT0gMCkge1xuICAgIGlmIChfaXNBbGxTdWJkb2NzKGRvY3MsIHJlZikpIHtcbiAgICAgIGFyclthcnJheVBhcmVudFN5bWJvbF0uJHBvcHVsYXRlZChhcnJbYXJyYXlQYXRoU3ltYm9sXSwgW10sIHtcbiAgICAgICAgW3BvcHVsYXRlTW9kZWxTeW1ib2xdOiBkb2NzWzBdLmNvbnN0cnVjdG9yXG4gICAgICB9KTtcbiAgICB9XG4gIH1cbn1cblxuY29uc3QgcmV0dXJuVmFuaWxsYUFycmF5TWV0aG9kcyA9IFtcbiAgJ2ZpbHRlcicsXG4gICdmbGF0JyxcbiAgJ2ZsYXRNYXAnLFxuICAnbWFwJyxcbiAgJ3NsaWNlJ1xuXTtcbmZvciAoY29uc3QgbWV0aG9kIG9mIHJldHVyblZhbmlsbGFBcnJheU1ldGhvZHMpIHtcbiAgaWYgKEFycmF5LnByb3RvdHlwZVttZXRob2RdID09IG51bGwpIHtcbiAgICBjb250aW51ZTtcbiAgfVxuXG4gIG1ldGhvZHNbbWV0aG9kXSA9IGZ1bmN0aW9uKCkge1xuICAgIGNvbnN0IF9hcnIgPSB1dGlscy5pc01vbmdvb3NlQXJyYXkodGhpcykgPyB0aGlzLl9fYXJyYXkgOiB0aGlzO1xuICAgIGNvbnN0IGFyciA9IFtdLmNvbmNhdChfYXJyKTtcblxuICAgIHJldHVybiBhcnJbbWV0aG9kXS5hcHBseShhcnIsIGFyZ3VtZW50cyk7XG4gIH07XG59XG5cbm1vZHVsZS5leHBvcnRzID0gbWV0aG9kcztcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/mongoose/lib/types/array/methods/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/mongoose/lib/types/arraySubdocument.js":
/*!*************************************************************!*\
  !*** ./node_modules/mongoose/lib/types/arraySubdocument.js ***!
  \*************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("/*!\n * Module dependencies.\n */\n\n\n\nconst EventEmitter = (__webpack_require__(/*! events */ \"events\").EventEmitter);\nconst Subdocument = __webpack_require__(/*! ./subdocument */ \"(ssr)/./node_modules/mongoose/lib/types/subdocument.js\");\nconst utils = __webpack_require__(/*! ../utils */ \"(ssr)/./node_modules/mongoose/lib/utils.js\");\n\nconst documentArrayParent = (__webpack_require__(/*! ../helpers/symbols */ \"(ssr)/./node_modules/mongoose/lib/helpers/symbols.js\").documentArrayParent);\n\n/**\n * A constructor.\n *\n * @param {Object} obj js object returned from the db\n * @param {MongooseDocumentArray} parentArr the parent array of this document\n * @param {Boolean} skipId\n * @param {Object} fields\n * @param {Number} index\n * @inherits Document\n * @api private\n */\n\nfunction ArraySubdocument(obj, parentArr, skipId, fields, index) {\n  if (utils.isMongooseDocumentArray(parentArr)) {\n    this.__parentArray = parentArr;\n    this[documentArrayParent] = parentArr.$parent();\n  } else {\n    this.__parentArray = undefined;\n    this[documentArrayParent] = undefined;\n  }\n  this.$setIndex(index);\n  this.$__parent = this[documentArrayParent];\n\n  let options;\n  if (typeof skipId === 'object' && skipId != null) {\n    options = { isNew: true, ...skipId };\n    skipId = undefined;\n  } else {\n    options = { isNew: true };\n  }\n\n  Subdocument.call(this, obj, fields, this[documentArrayParent], skipId, options);\n}\n\n/*!\n * Inherit from Subdocument\n */\nArraySubdocument.prototype = Object.create(Subdocument.prototype);\nArraySubdocument.prototype.constructor = ArraySubdocument;\n\nObject.defineProperty(ArraySubdocument.prototype, '$isSingleNested', {\n  configurable: false,\n  writable: false,\n  value: false\n});\n\nObject.defineProperty(ArraySubdocument.prototype, '$isDocumentArrayElement', {\n  configurable: false,\n  writable: false,\n  value: true\n});\n\nfor (const i in EventEmitter.prototype) {\n  ArraySubdocument[i] = EventEmitter.prototype[i];\n}\n\n/*!\n * ignore\n */\n\nArraySubdocument.prototype.$setIndex = function(index) {\n  this.__index = index;\n\n  if (this.$__ != null && this.$__.validationError != null) {\n    const keys = Object.keys(this.$__.validationError.errors);\n    for (const key of keys) {\n      this.invalidate(key, this.$__.validationError.errors[key]);\n    }\n  }\n};\n\n/*!\n * ignore\n */\n\nArraySubdocument.prototype.populate = function() {\n  throw new Error('Mongoose does not support calling populate() on nested ' +\n    'docs. Instead of `doc.arr[0].populate(\"path\")`, use ' +\n    '`doc.populate(\"arr.0.path\")`');\n};\n\n/*!\n * ignore\n */\n\nArraySubdocument.prototype.$__removeFromParent = function() {\n  const _id = this._doc._id;\n  if (!_id) {\n    throw new Error('For your own good, Mongoose does not know ' +\n      'how to remove an ArraySubdocument that has no _id');\n  }\n  this.__parentArray.pull({ _id: _id });\n};\n\n/**\n * Returns the full path to this document. If optional `path` is passed, it is appended to the full path.\n *\n * @param {String} [path]\n * @param {Boolean} [skipIndex] Skip adding the array index. For example `arr.foo` instead of `arr.0.foo`.\n * @return {String}\n * @api private\n * @method $__fullPath\n * @memberOf ArraySubdocument\n * @instance\n */\n\nArraySubdocument.prototype.$__fullPath = function(path, skipIndex) {\n  if (this.__index == null) {\n    return null;\n  }\n  if (!this.$__.fullPath) {\n    this.ownerDocument();\n  }\n\n  if (skipIndex) {\n    return path ?\n      this.$__.fullPath + '.' + path :\n      this.$__.fullPath;\n  }\n\n  return path ?\n    this.$__.fullPath + '.' + this.__index + '.' + path :\n    this.$__.fullPath + '.' + this.__index;\n};\n\n/**\n * Given a path relative to this document, return the path relative\n * to the top-level document.\n * @method $__pathRelativeToParent\n * @memberOf ArraySubdocument\n * @instance\n * @api private\n */\n\nArraySubdocument.prototype.$__pathRelativeToParent = function(path, skipIndex) {\n  if (this.__index == null) {\n    return null;\n  }\n  if (skipIndex) {\n    return path == null ? this.__parentArray.$path() : this.__parentArray.$path() + '.' + path;\n  }\n  if (path == null) {\n    return this.__parentArray.$path() + '.' + this.__index;\n  }\n  return this.__parentArray.$path() + '.' + this.__index + '.' + path;\n};\n\n/**\n * Returns this sub-documents parent document.\n * @method $parent\n * @memberOf ArraySubdocument\n * @instance\n * @api public\n */\n\nArraySubdocument.prototype.$parent = function() {\n  return this[documentArrayParent];\n};\n\n/**\n * Returns this subdocument's parent array.\n *\n * #### Example:\n *\n *     const Test = mongoose.model('Test', new Schema({\n *       docArr: [{ name: String }]\n *     }));\n *     const doc = new Test({ docArr: [{ name: 'test subdoc' }] });\n *\n *     doc.docArr[0].parentArray() === doc.docArr; // true\n *\n * @api public\n * @method parentArray\n * @returns DocumentArray\n */\n\nArraySubdocument.prototype.parentArray = function() {\n  return this.__parentArray;\n};\n\n/*!\n * Module exports.\n */\n\nmodule.exports = ArraySubdocument;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbW9uZ29vc2UvbGliL3R5cGVzL2FycmF5U3ViZG9jdW1lbnQuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBOztBQUVhOztBQUViLHFCQUFxQiwwREFBOEI7QUFDbkQsb0JBQW9CLG1CQUFPLENBQUMsNkVBQWU7QUFDM0MsY0FBYyxtQkFBTyxDQUFDLDREQUFVOztBQUVoQyw0QkFBNEIsMkhBQWlEOztBQUU3RTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsV0FBVyx1QkFBdUI7QUFDbEMsV0FBVyxTQUFTO0FBQ3BCLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBLElBQUk7QUFDSixnQkFBZ0I7QUFDaEI7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsVUFBVTtBQUN0Qzs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsV0FBVyxTQUFTO0FBQ3BCLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixjQUFjO0FBQ2xDLFFBQVE7QUFDUiw4QkFBOEIsV0FBVyxxQkFBcUIsR0FBRztBQUNqRTtBQUNBLG1EQUFtRDtBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9hcHAxLy4vbm9kZV9tb2R1bGVzL21vbmdvb3NlL2xpYi90eXBlcy9hcnJheVN1YmRvY3VtZW50LmpzPzlhOWUiXSwic291cmNlc0NvbnRlbnQiOlsiLyohXG4gKiBNb2R1bGUgZGVwZW5kZW5jaWVzLlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxuY29uc3QgRXZlbnRFbWl0dGVyID0gcmVxdWlyZSgnZXZlbnRzJykuRXZlbnRFbWl0dGVyO1xuY29uc3QgU3ViZG9jdW1lbnQgPSByZXF1aXJlKCcuL3N1YmRvY3VtZW50Jyk7XG5jb25zdCB1dGlscyA9IHJlcXVpcmUoJy4uL3V0aWxzJyk7XG5cbmNvbnN0IGRvY3VtZW50QXJyYXlQYXJlbnQgPSByZXF1aXJlKCcuLi9oZWxwZXJzL3N5bWJvbHMnKS5kb2N1bWVudEFycmF5UGFyZW50O1xuXG4vKipcbiAqIEEgY29uc3RydWN0b3IuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IG9iaiBqcyBvYmplY3QgcmV0dXJuZWQgZnJvbSB0aGUgZGJcbiAqIEBwYXJhbSB7TW9uZ29vc2VEb2N1bWVudEFycmF5fSBwYXJlbnRBcnIgdGhlIHBhcmVudCBhcnJheSBvZiB0aGlzIGRvY3VtZW50XG4gKiBAcGFyYW0ge0Jvb2xlYW59IHNraXBJZFxuICogQHBhcmFtIHtPYmplY3R9IGZpZWxkc1xuICogQHBhcmFtIHtOdW1iZXJ9IGluZGV4XG4gKiBAaW5oZXJpdHMgRG9jdW1lbnRcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmZ1bmN0aW9uIEFycmF5U3ViZG9jdW1lbnQob2JqLCBwYXJlbnRBcnIsIHNraXBJZCwgZmllbGRzLCBpbmRleCkge1xuICBpZiAodXRpbHMuaXNNb25nb29zZURvY3VtZW50QXJyYXkocGFyZW50QXJyKSkge1xuICAgIHRoaXMuX19wYXJlbnRBcnJheSA9IHBhcmVudEFycjtcbiAgICB0aGlzW2RvY3VtZW50QXJyYXlQYXJlbnRdID0gcGFyZW50QXJyLiRwYXJlbnQoKTtcbiAgfSBlbHNlIHtcbiAgICB0aGlzLl9fcGFyZW50QXJyYXkgPSB1bmRlZmluZWQ7XG4gICAgdGhpc1tkb2N1bWVudEFycmF5UGFyZW50XSA9IHVuZGVmaW5lZDtcbiAgfVxuICB0aGlzLiRzZXRJbmRleChpbmRleCk7XG4gIHRoaXMuJF9fcGFyZW50ID0gdGhpc1tkb2N1bWVudEFycmF5UGFyZW50XTtcblxuICBsZXQgb3B0aW9ucztcbiAgaWYgKHR5cGVvZiBza2lwSWQgPT09ICdvYmplY3QnICYmIHNraXBJZCAhPSBudWxsKSB7XG4gICAgb3B0aW9ucyA9IHsgaXNOZXc6IHRydWUsIC4uLnNraXBJZCB9O1xuICAgIHNraXBJZCA9IHVuZGVmaW5lZDtcbiAgfSBlbHNlIHtcbiAgICBvcHRpb25zID0geyBpc05ldzogdHJ1ZSB9O1xuICB9XG5cbiAgU3ViZG9jdW1lbnQuY2FsbCh0aGlzLCBvYmosIGZpZWxkcywgdGhpc1tkb2N1bWVudEFycmF5UGFyZW50XSwgc2tpcElkLCBvcHRpb25zKTtcbn1cblxuLyohXG4gKiBJbmhlcml0IGZyb20gU3ViZG9jdW1lbnRcbiAqL1xuQXJyYXlTdWJkb2N1bWVudC5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKFN1YmRvY3VtZW50LnByb3RvdHlwZSk7XG5BcnJheVN1YmRvY3VtZW50LnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IEFycmF5U3ViZG9jdW1lbnQ7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShBcnJheVN1YmRvY3VtZW50LnByb3RvdHlwZSwgJyRpc1NpbmdsZU5lc3RlZCcsIHtcbiAgY29uZmlndXJhYmxlOiBmYWxzZSxcbiAgd3JpdGFibGU6IGZhbHNlLFxuICB2YWx1ZTogZmFsc2Vcbn0pO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoQXJyYXlTdWJkb2N1bWVudC5wcm90b3R5cGUsICckaXNEb2N1bWVudEFycmF5RWxlbWVudCcsIHtcbiAgY29uZmlndXJhYmxlOiBmYWxzZSxcbiAgd3JpdGFibGU6IGZhbHNlLFxuICB2YWx1ZTogdHJ1ZVxufSk7XG5cbmZvciAoY29uc3QgaSBpbiBFdmVudEVtaXR0ZXIucHJvdG90eXBlKSB7XG4gIEFycmF5U3ViZG9jdW1lbnRbaV0gPSBFdmVudEVtaXR0ZXIucHJvdG90eXBlW2ldO1xufVxuXG4vKiFcbiAqIGlnbm9yZVxuICovXG5cbkFycmF5U3ViZG9jdW1lbnQucHJvdG90eXBlLiRzZXRJbmRleCA9IGZ1bmN0aW9uKGluZGV4KSB7XG4gIHRoaXMuX19pbmRleCA9IGluZGV4O1xuXG4gIGlmICh0aGlzLiRfXyAhPSBudWxsICYmIHRoaXMuJF9fLnZhbGlkYXRpb25FcnJvciAhPSBudWxsKSB7XG4gICAgY29uc3Qga2V5cyA9IE9iamVjdC5rZXlzKHRoaXMuJF9fLnZhbGlkYXRpb25FcnJvci5lcnJvcnMpO1xuICAgIGZvciAoY29uc3Qga2V5IG9mIGtleXMpIHtcbiAgICAgIHRoaXMuaW52YWxpZGF0ZShrZXksIHRoaXMuJF9fLnZhbGlkYXRpb25FcnJvci5lcnJvcnNba2V5XSk7XG4gICAgfVxuICB9XG59O1xuXG4vKiFcbiAqIGlnbm9yZVxuICovXG5cbkFycmF5U3ViZG9jdW1lbnQucHJvdG90eXBlLnBvcHVsYXRlID0gZnVuY3Rpb24oKSB7XG4gIHRocm93IG5ldyBFcnJvcignTW9uZ29vc2UgZG9lcyBub3Qgc3VwcG9ydCBjYWxsaW5nIHBvcHVsYXRlKCkgb24gbmVzdGVkICcgK1xuICAgICdkb2NzLiBJbnN0ZWFkIG9mIGBkb2MuYXJyWzBdLnBvcHVsYXRlKFwicGF0aFwiKWAsIHVzZSAnICtcbiAgICAnYGRvYy5wb3B1bGF0ZShcImFyci4wLnBhdGhcIilgJyk7XG59O1xuXG4vKiFcbiAqIGlnbm9yZVxuICovXG5cbkFycmF5U3ViZG9jdW1lbnQucHJvdG90eXBlLiRfX3JlbW92ZUZyb21QYXJlbnQgPSBmdW5jdGlvbigpIHtcbiAgY29uc3QgX2lkID0gdGhpcy5fZG9jLl9pZDtcbiAgaWYgKCFfaWQpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0ZvciB5b3VyIG93biBnb29kLCBNb25nb29zZSBkb2VzIG5vdCBrbm93ICcgK1xuICAgICAgJ2hvdyB0byByZW1vdmUgYW4gQXJyYXlTdWJkb2N1bWVudCB0aGF0IGhhcyBubyBfaWQnKTtcbiAgfVxuICB0aGlzLl9fcGFyZW50QXJyYXkucHVsbCh7IF9pZDogX2lkIH0pO1xufTtcblxuLyoqXG4gKiBSZXR1cm5zIHRoZSBmdWxsIHBhdGggdG8gdGhpcyBkb2N1bWVudC4gSWYgb3B0aW9uYWwgYHBhdGhgIGlzIHBhc3NlZCwgaXQgaXMgYXBwZW5kZWQgdG8gdGhlIGZ1bGwgcGF0aC5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gW3BhdGhdXG4gKiBAcGFyYW0ge0Jvb2xlYW59IFtza2lwSW5kZXhdIFNraXAgYWRkaW5nIHRoZSBhcnJheSBpbmRleC4gRm9yIGV4YW1wbGUgYGFyci5mb29gIGluc3RlYWQgb2YgYGFyci4wLmZvb2AuXG4gKiBAcmV0dXJuIHtTdHJpbmd9XG4gKiBAYXBpIHByaXZhdGVcbiAqIEBtZXRob2QgJF9fZnVsbFBhdGhcbiAqIEBtZW1iZXJPZiBBcnJheVN1YmRvY3VtZW50XG4gKiBAaW5zdGFuY2VcbiAqL1xuXG5BcnJheVN1YmRvY3VtZW50LnByb3RvdHlwZS4kX19mdWxsUGF0aCA9IGZ1bmN0aW9uKHBhdGgsIHNraXBJbmRleCkge1xuICBpZiAodGhpcy5fX2luZGV4ID09IG51bGwpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICBpZiAoIXRoaXMuJF9fLmZ1bGxQYXRoKSB7XG4gICAgdGhpcy5vd25lckRvY3VtZW50KCk7XG4gIH1cblxuICBpZiAoc2tpcEluZGV4KSB7XG4gICAgcmV0dXJuIHBhdGggP1xuICAgICAgdGhpcy4kX18uZnVsbFBhdGggKyAnLicgKyBwYXRoIDpcbiAgICAgIHRoaXMuJF9fLmZ1bGxQYXRoO1xuICB9XG5cbiAgcmV0dXJuIHBhdGggP1xuICAgIHRoaXMuJF9fLmZ1bGxQYXRoICsgJy4nICsgdGhpcy5fX2luZGV4ICsgJy4nICsgcGF0aCA6XG4gICAgdGhpcy4kX18uZnVsbFBhdGggKyAnLicgKyB0aGlzLl9faW5kZXg7XG59O1xuXG4vKipcbiAqIEdpdmVuIGEgcGF0aCByZWxhdGl2ZSB0byB0aGlzIGRvY3VtZW50LCByZXR1cm4gdGhlIHBhdGggcmVsYXRpdmVcbiAqIHRvIHRoZSB0b3AtbGV2ZWwgZG9jdW1lbnQuXG4gKiBAbWV0aG9kICRfX3BhdGhSZWxhdGl2ZVRvUGFyZW50XG4gKiBAbWVtYmVyT2YgQXJyYXlTdWJkb2N1bWVudFxuICogQGluc3RhbmNlXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5BcnJheVN1YmRvY3VtZW50LnByb3RvdHlwZS4kX19wYXRoUmVsYXRpdmVUb1BhcmVudCA9IGZ1bmN0aW9uKHBhdGgsIHNraXBJbmRleCkge1xuICBpZiAodGhpcy5fX2luZGV4ID09IG51bGwpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICBpZiAoc2tpcEluZGV4KSB7XG4gICAgcmV0dXJuIHBhdGggPT0gbnVsbCA/IHRoaXMuX19wYXJlbnRBcnJheS4kcGF0aCgpIDogdGhpcy5fX3BhcmVudEFycmF5LiRwYXRoKCkgKyAnLicgKyBwYXRoO1xuICB9XG4gIGlmIChwYXRoID09IG51bGwpIHtcbiAgICByZXR1cm4gdGhpcy5fX3BhcmVudEFycmF5LiRwYXRoKCkgKyAnLicgKyB0aGlzLl9faW5kZXg7XG4gIH1cbiAgcmV0dXJuIHRoaXMuX19wYXJlbnRBcnJheS4kcGF0aCgpICsgJy4nICsgdGhpcy5fX2luZGV4ICsgJy4nICsgcGF0aDtcbn07XG5cbi8qKlxuICogUmV0dXJucyB0aGlzIHN1Yi1kb2N1bWVudHMgcGFyZW50IGRvY3VtZW50LlxuICogQG1ldGhvZCAkcGFyZW50XG4gKiBAbWVtYmVyT2YgQXJyYXlTdWJkb2N1bWVudFxuICogQGluc3RhbmNlXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbkFycmF5U3ViZG9jdW1lbnQucHJvdG90eXBlLiRwYXJlbnQgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHRoaXNbZG9jdW1lbnRBcnJheVBhcmVudF07XG59O1xuXG4vKipcbiAqIFJldHVybnMgdGhpcyBzdWJkb2N1bWVudCdzIHBhcmVudCBhcnJheS5cbiAqXG4gKiAjIyMjIEV4YW1wbGU6XG4gKlxuICogICAgIGNvbnN0IFRlc3QgPSBtb25nb29zZS5tb2RlbCgnVGVzdCcsIG5ldyBTY2hlbWEoe1xuICogICAgICAgZG9jQXJyOiBbeyBuYW1lOiBTdHJpbmcgfV1cbiAqICAgICB9KSk7XG4gKiAgICAgY29uc3QgZG9jID0gbmV3IFRlc3QoeyBkb2NBcnI6IFt7IG5hbWU6ICd0ZXN0IHN1YmRvYycgfV0gfSk7XG4gKlxuICogICAgIGRvYy5kb2NBcnJbMF0ucGFyZW50QXJyYXkoKSA9PT0gZG9jLmRvY0FycjsgLy8gdHJ1ZVxuICpcbiAqIEBhcGkgcHVibGljXG4gKiBAbWV0aG9kIHBhcmVudEFycmF5XG4gKiBAcmV0dXJucyBEb2N1bWVudEFycmF5XG4gKi9cblxuQXJyYXlTdWJkb2N1bWVudC5wcm90b3R5cGUucGFyZW50QXJyYXkgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHRoaXMuX19wYXJlbnRBcnJheTtcbn07XG5cbi8qIVxuICogTW9kdWxlIGV4cG9ydHMuXG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSBBcnJheVN1YmRvY3VtZW50O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/mongoose/lib/types/arraySubdocument.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/mongoose/lib/types/buffer.js":
/*!***************************************************!*\
  !*** ./node_modules/mongoose/lib/types/buffer.js ***!
  \***************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("/*!\n * Module dependencies.\n */\n\n\n\nconst Binary = (__webpack_require__(/*! bson */ \"(ssr)/./node_modules/bson/lib/bson.cjs\").Binary);\nconst utils = __webpack_require__(/*! ../utils */ \"(ssr)/./node_modules/mongoose/lib/utils.js\");\n\n/**\n * Mongoose Buffer constructor.\n *\n * Values always have to be passed to the constructor to initialize.\n *\n * @param {Buffer} value\n * @param {String} encode\n * @param {Number} offset\n * @api private\n * @inherits Buffer https://nodejs.org/api/buffer.html\n * @see https://bit.ly/f6CnZU\n */\n\nfunction MongooseBuffer(value, encode, offset) {\n  let val = value;\n  if (value == null) {\n    val = 0;\n  }\n\n  let encoding;\n  let path;\n  let doc;\n\n  if (Array.isArray(encode)) {\n    // internal casting\n    path = encode[0];\n    doc = encode[1];\n  } else {\n    encoding = encode;\n  }\n\n  let buf;\n  if (typeof val === 'number' || val instanceof Number) {\n    buf = Buffer.alloc(val);\n  } else { // string, array or object { type: 'Buffer', data: [...] }\n    buf = Buffer.from(val, encoding, offset);\n  }\n  utils.decorate(buf, MongooseBuffer.mixin);\n  buf.isMongooseBuffer = true;\n\n  // make sure these internal props don't show up in Object.keys()\n  buf[MongooseBuffer.pathSymbol] = path;\n  buf[parentSymbol] = doc;\n\n  buf._subtype = 0;\n  return buf;\n}\n\nconst pathSymbol = Symbol.for('mongoose#Buffer#_path');\nconst parentSymbol = Symbol.for('mongoose#Buffer#_parent');\nMongooseBuffer.pathSymbol = pathSymbol;\n\n/*!\n * Inherit from Buffer.\n */\n\nMongooseBuffer.mixin = {\n\n  /**\n   * Default subtype for the Binary representing this Buffer\n   *\n   * @api private\n   * @property _subtype\n   * @memberOf MongooseBuffer.mixin\n   * @static\n   */\n\n  _subtype: undefined,\n\n  /**\n   * Marks this buffer as modified.\n   *\n   * @api private\n   * @method _markModified\n   * @memberOf MongooseBuffer.mixin\n   * @static\n   */\n\n  _markModified: function() {\n    const parent = this[parentSymbol];\n\n    if (parent) {\n      parent.markModified(this[MongooseBuffer.pathSymbol]);\n    }\n    return this;\n  },\n\n  /**\n   * Writes the buffer.\n   *\n   * @api public\n   * @method write\n   * @memberOf MongooseBuffer.mixin\n   * @static\n   */\n\n  write: function() {\n    const written = Buffer.prototype.write.apply(this, arguments);\n\n    if (written > 0) {\n      this._markModified();\n    }\n\n    return written;\n  },\n\n  /**\n   * Copies the buffer.\n   *\n   * #### Note:\n   *\n   * `Buffer#copy` does not mark `target` as modified so you must copy from a `MongooseBuffer` for it to work as expected. This is a work around since `copy` modifies the target, not this.\n   *\n   * @return {Number} The number of bytes copied.\n   * @param {Buffer} target\n   * @method copy\n   * @memberOf MongooseBuffer.mixin\n   * @static\n   */\n\n  copy: function(target) {\n    const ret = Buffer.prototype.copy.apply(this, arguments);\n\n    if (target && target.isMongooseBuffer) {\n      target._markModified();\n    }\n\n    return ret;\n  }\n};\n\n/*!\n * Compile other Buffer methods marking this buffer as modified.\n */\n\nutils.each(\n  [\n    // node < 0.5\n    'writeUInt8', 'writeUInt16', 'writeUInt32', 'writeInt8', 'writeInt16', 'writeInt32',\n    'writeFloat', 'writeDouble', 'fill',\n    'utf8Write', 'binaryWrite', 'asciiWrite', 'set',\n\n    // node >= 0.5\n    'writeUInt16LE', 'writeUInt16BE', 'writeUInt32LE', 'writeUInt32BE',\n    'writeInt16LE', 'writeInt16BE', 'writeInt32LE', 'writeInt32BE', 'writeFloatLE', 'writeFloatBE', 'writeDoubleLE', 'writeDoubleBE']\n  , function(method) {\n    if (!Buffer.prototype[method]) {\n      return;\n    }\n    MongooseBuffer.mixin[method] = function() {\n      const ret = Buffer.prototype[method].apply(this, arguments);\n      this._markModified();\n      return ret;\n    };\n  });\n\n/**\n * Converts this buffer to its Binary type representation.\n *\n * #### SubTypes:\n *\n *     const bson = require('bson')\n *     bson.BSON_BINARY_SUBTYPE_DEFAULT\n *     bson.BSON_BINARY_SUBTYPE_FUNCTION\n *     bson.BSON_BINARY_SUBTYPE_BYTE_ARRAY\n *     bson.BSON_BINARY_SUBTYPE_UUID\n *     bson.BSON_BINARY_SUBTYPE_MD5\n *     bson.BSON_BINARY_SUBTYPE_USER_DEFINED\n *     doc.buffer.toObject(bson.BSON_BINARY_SUBTYPE_USER_DEFINED);\n *\n * @see bsonspec https://bsonspec.org/#/specification\n * @param {Hex} [subtype]\n * @return {Binary}\n * @api public\n * @method toObject\n * @memberOf MongooseBuffer\n */\n\nMongooseBuffer.mixin.toObject = function(options) {\n  const subtype = typeof options === 'number'\n    ? options\n    : (this._subtype || 0);\n  return new Binary(Buffer.from(this), subtype);\n};\n\nMongooseBuffer.mixin.$toObject = MongooseBuffer.mixin.toObject;\n\n/**\n * Converts this buffer for storage in MongoDB, including subtype\n *\n * @return {Binary}\n * @api public\n * @method toBSON\n * @memberOf MongooseBuffer\n */\n\nMongooseBuffer.mixin.toBSON = function() {\n  return new Binary(this, this._subtype || 0);\n};\n\n/**\n * Determines if this buffer is equals to `other` buffer\n *\n * @param {Buffer} other\n * @return {Boolean}\n * @method equals\n * @memberOf MongooseBuffer\n */\n\nMongooseBuffer.mixin.equals = function(other) {\n  if (!Buffer.isBuffer(other)) {\n    return false;\n  }\n\n  if (this.length !== other.length) {\n    return false;\n  }\n\n  for (let i = 0; i < this.length; ++i) {\n    if (this[i] !== other[i]) {\n      return false;\n    }\n  }\n\n  return true;\n};\n\n/**\n * Sets the subtype option and marks the buffer modified.\n *\n * #### SubTypes:\n *\n *     const bson = require('bson')\n *     bson.BSON_BINARY_SUBTYPE_DEFAULT\n *     bson.BSON_BINARY_SUBTYPE_FUNCTION\n *     bson.BSON_BINARY_SUBTYPE_BYTE_ARRAY\n *     bson.BSON_BINARY_SUBTYPE_UUID\n *     bson.BSON_BINARY_SUBTYPE_MD5\n *     bson.BSON_BINARY_SUBTYPE_USER_DEFINED\n *\n *     doc.buffer.subtype(bson.BSON_BINARY_SUBTYPE_UUID);\n *\n * @see bsonspec https://bsonspec.org/#/specification\n * @param {Hex} subtype\n * @api public\n * @method subtype\n * @memberOf MongooseBuffer\n */\n\nMongooseBuffer.mixin.subtype = function(subtype) {\n  if (typeof subtype !== 'number') {\n    throw new TypeError('Invalid subtype. Expected a number');\n  }\n\n  if (this._subtype !== subtype) {\n    this._markModified();\n  }\n\n  this._subtype = subtype;\n};\n\n/*!\n * Module exports.\n */\n\nMongooseBuffer.Binary = Binary;\n\nmodule.exports = MongooseBuffer;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbW9uZ29vc2UvbGliL3R5cGVzL2J1ZmZlci5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7O0FBRWE7O0FBRWIsZUFBZSxrRkFBc0I7QUFDckMsY0FBYyxtQkFBTyxDQUFDLDREQUFVOztBQUVoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFJLE9BQU8sNkJBQTZCO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLFFBQVE7QUFDdEIsYUFBYSxRQUFRO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxLQUFLO0FBQ2hCLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsWUFBWTtBQUNaO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsa0JBQWtCLGlCQUFpQjtBQUNuQztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxLQUFLO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSIsInNvdXJjZXMiOlsid2VicGFjazovL2FwcDEvLi9ub2RlX21vZHVsZXMvbW9uZ29vc2UvbGliL3R5cGVzL2J1ZmZlci5qcz84MzJhIl0sInNvdXJjZXNDb250ZW50IjpbIi8qIVxuICogTW9kdWxlIGRlcGVuZGVuY2llcy5cbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbmNvbnN0IEJpbmFyeSA9IHJlcXVpcmUoJ2Jzb24nKS5CaW5hcnk7XG5jb25zdCB1dGlscyA9IHJlcXVpcmUoJy4uL3V0aWxzJyk7XG5cbi8qKlxuICogTW9uZ29vc2UgQnVmZmVyIGNvbnN0cnVjdG9yLlxuICpcbiAqIFZhbHVlcyBhbHdheXMgaGF2ZSB0byBiZSBwYXNzZWQgdG8gdGhlIGNvbnN0cnVjdG9yIHRvIGluaXRpYWxpemUuXG4gKlxuICogQHBhcmFtIHtCdWZmZXJ9IHZhbHVlXG4gKiBAcGFyYW0ge1N0cmluZ30gZW5jb2RlXG4gKiBAcGFyYW0ge051bWJlcn0gb2Zmc2V0XG4gKiBAYXBpIHByaXZhdGVcbiAqIEBpbmhlcml0cyBCdWZmZXIgaHR0cHM6Ly9ub2RlanMub3JnL2FwaS9idWZmZXIuaHRtbFxuICogQHNlZSBodHRwczovL2JpdC5seS9mNkNuWlVcbiAqL1xuXG5mdW5jdGlvbiBNb25nb29zZUJ1ZmZlcih2YWx1ZSwgZW5jb2RlLCBvZmZzZXQpIHtcbiAgbGV0IHZhbCA9IHZhbHVlO1xuICBpZiAodmFsdWUgPT0gbnVsbCkge1xuICAgIHZhbCA9IDA7XG4gIH1cblxuICBsZXQgZW5jb2Rpbmc7XG4gIGxldCBwYXRoO1xuICBsZXQgZG9jO1xuXG4gIGlmIChBcnJheS5pc0FycmF5KGVuY29kZSkpIHtcbiAgICAvLyBpbnRlcm5hbCBjYXN0aW5nXG4gICAgcGF0aCA9IGVuY29kZVswXTtcbiAgICBkb2MgPSBlbmNvZGVbMV07XG4gIH0gZWxzZSB7XG4gICAgZW5jb2RpbmcgPSBlbmNvZGU7XG4gIH1cblxuICBsZXQgYnVmO1xuICBpZiAodHlwZW9mIHZhbCA9PT0gJ251bWJlcicgfHwgdmFsIGluc3RhbmNlb2YgTnVtYmVyKSB7XG4gICAgYnVmID0gQnVmZmVyLmFsbG9jKHZhbCk7XG4gIH0gZWxzZSB7IC8vIHN0cmluZywgYXJyYXkgb3Igb2JqZWN0IHsgdHlwZTogJ0J1ZmZlcicsIGRhdGE6IFsuLi5dIH1cbiAgICBidWYgPSBCdWZmZXIuZnJvbSh2YWwsIGVuY29kaW5nLCBvZmZzZXQpO1xuICB9XG4gIHV0aWxzLmRlY29yYXRlKGJ1ZiwgTW9uZ29vc2VCdWZmZXIubWl4aW4pO1xuICBidWYuaXNNb25nb29zZUJ1ZmZlciA9IHRydWU7XG5cbiAgLy8gbWFrZSBzdXJlIHRoZXNlIGludGVybmFsIHByb3BzIGRvbid0IHNob3cgdXAgaW4gT2JqZWN0LmtleXMoKVxuICBidWZbTW9uZ29vc2VCdWZmZXIucGF0aFN5bWJvbF0gPSBwYXRoO1xuICBidWZbcGFyZW50U3ltYm9sXSA9IGRvYztcblxuICBidWYuX3N1YnR5cGUgPSAwO1xuICByZXR1cm4gYnVmO1xufVxuXG5jb25zdCBwYXRoU3ltYm9sID0gU3ltYm9sLmZvcignbW9uZ29vc2UjQnVmZmVyI19wYXRoJyk7XG5jb25zdCBwYXJlbnRTeW1ib2wgPSBTeW1ib2wuZm9yKCdtb25nb29zZSNCdWZmZXIjX3BhcmVudCcpO1xuTW9uZ29vc2VCdWZmZXIucGF0aFN5bWJvbCA9IHBhdGhTeW1ib2w7XG5cbi8qIVxuICogSW5oZXJpdCBmcm9tIEJ1ZmZlci5cbiAqL1xuXG5Nb25nb29zZUJ1ZmZlci5taXhpbiA9IHtcblxuICAvKipcbiAgICogRGVmYXVsdCBzdWJ0eXBlIGZvciB0aGUgQmluYXJ5IHJlcHJlc2VudGluZyB0aGlzIEJ1ZmZlclxuICAgKlxuICAgKiBAYXBpIHByaXZhdGVcbiAgICogQHByb3BlcnR5IF9zdWJ0eXBlXG4gICAqIEBtZW1iZXJPZiBNb25nb29zZUJ1ZmZlci5taXhpblxuICAgKiBAc3RhdGljXG4gICAqL1xuXG4gIF9zdWJ0eXBlOiB1bmRlZmluZWQsXG5cbiAgLyoqXG4gICAqIE1hcmtzIHRoaXMgYnVmZmVyIGFzIG1vZGlmaWVkLlxuICAgKlxuICAgKiBAYXBpIHByaXZhdGVcbiAgICogQG1ldGhvZCBfbWFya01vZGlmaWVkXG4gICAqIEBtZW1iZXJPZiBNb25nb29zZUJ1ZmZlci5taXhpblxuICAgKiBAc3RhdGljXG4gICAqL1xuXG4gIF9tYXJrTW9kaWZpZWQ6IGZ1bmN0aW9uKCkge1xuICAgIGNvbnN0IHBhcmVudCA9IHRoaXNbcGFyZW50U3ltYm9sXTtcblxuICAgIGlmIChwYXJlbnQpIHtcbiAgICAgIHBhcmVudC5tYXJrTW9kaWZpZWQodGhpc1tNb25nb29zZUJ1ZmZlci5wYXRoU3ltYm9sXSk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xuICB9LFxuXG4gIC8qKlxuICAgKiBXcml0ZXMgdGhlIGJ1ZmZlci5cbiAgICpcbiAgICogQGFwaSBwdWJsaWNcbiAgICogQG1ldGhvZCB3cml0ZVxuICAgKiBAbWVtYmVyT2YgTW9uZ29vc2VCdWZmZXIubWl4aW5cbiAgICogQHN0YXRpY1xuICAgKi9cblxuICB3cml0ZTogZnVuY3Rpb24oKSB7XG4gICAgY29uc3Qgd3JpdHRlbiA9IEJ1ZmZlci5wcm90b3R5cGUud3JpdGUuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcblxuICAgIGlmICh3cml0dGVuID4gMCkge1xuICAgICAgdGhpcy5fbWFya01vZGlmaWVkKCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHdyaXR0ZW47XG4gIH0sXG5cbiAgLyoqXG4gICAqIENvcGllcyB0aGUgYnVmZmVyLlxuICAgKlxuICAgKiAjIyMjIE5vdGU6XG4gICAqXG4gICAqIGBCdWZmZXIjY29weWAgZG9lcyBub3QgbWFyayBgdGFyZ2V0YCBhcyBtb2RpZmllZCBzbyB5b3UgbXVzdCBjb3B5IGZyb20gYSBgTW9uZ29vc2VCdWZmZXJgIGZvciBpdCB0byB3b3JrIGFzIGV4cGVjdGVkLiBUaGlzIGlzIGEgd29yayBhcm91bmQgc2luY2UgYGNvcHlgIG1vZGlmaWVzIHRoZSB0YXJnZXQsIG5vdCB0aGlzLlxuICAgKlxuICAgKiBAcmV0dXJuIHtOdW1iZXJ9IFRoZSBudW1iZXIgb2YgYnl0ZXMgY29waWVkLlxuICAgKiBAcGFyYW0ge0J1ZmZlcn0gdGFyZ2V0XG4gICAqIEBtZXRob2QgY29weVxuICAgKiBAbWVtYmVyT2YgTW9uZ29vc2VCdWZmZXIubWl4aW5cbiAgICogQHN0YXRpY1xuICAgKi9cblxuICBjb3B5OiBmdW5jdGlvbih0YXJnZXQpIHtcbiAgICBjb25zdCByZXQgPSBCdWZmZXIucHJvdG90eXBlLmNvcHkuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcblxuICAgIGlmICh0YXJnZXQgJiYgdGFyZ2V0LmlzTW9uZ29vc2VCdWZmZXIpIHtcbiAgICAgIHRhcmdldC5fbWFya01vZGlmaWVkKCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHJldDtcbiAgfVxufTtcblxuLyohXG4gKiBDb21waWxlIG90aGVyIEJ1ZmZlciBtZXRob2RzIG1hcmtpbmcgdGhpcyBidWZmZXIgYXMgbW9kaWZpZWQuXG4gKi9cblxudXRpbHMuZWFjaChcbiAgW1xuICAgIC8vIG5vZGUgPCAwLjVcbiAgICAnd3JpdGVVSW50OCcsICd3cml0ZVVJbnQxNicsICd3cml0ZVVJbnQzMicsICd3cml0ZUludDgnLCAnd3JpdGVJbnQxNicsICd3cml0ZUludDMyJyxcbiAgICAnd3JpdGVGbG9hdCcsICd3cml0ZURvdWJsZScsICdmaWxsJyxcbiAgICAndXRmOFdyaXRlJywgJ2JpbmFyeVdyaXRlJywgJ2FzY2lpV3JpdGUnLCAnc2V0JyxcblxuICAgIC8vIG5vZGUgPj0gMC41XG4gICAgJ3dyaXRlVUludDE2TEUnLCAnd3JpdGVVSW50MTZCRScsICd3cml0ZVVJbnQzMkxFJywgJ3dyaXRlVUludDMyQkUnLFxuICAgICd3cml0ZUludDE2TEUnLCAnd3JpdGVJbnQxNkJFJywgJ3dyaXRlSW50MzJMRScsICd3cml0ZUludDMyQkUnLCAnd3JpdGVGbG9hdExFJywgJ3dyaXRlRmxvYXRCRScsICd3cml0ZURvdWJsZUxFJywgJ3dyaXRlRG91YmxlQkUnXVxuICAsIGZ1bmN0aW9uKG1ldGhvZCkge1xuICAgIGlmICghQnVmZmVyLnByb3RvdHlwZVttZXRob2RdKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIE1vbmdvb3NlQnVmZmVyLm1peGluW21ldGhvZF0gPSBmdW5jdGlvbigpIHtcbiAgICAgIGNvbnN0IHJldCA9IEJ1ZmZlci5wcm90b3R5cGVbbWV0aG9kXS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgdGhpcy5fbWFya01vZGlmaWVkKCk7XG4gICAgICByZXR1cm4gcmV0O1xuICAgIH07XG4gIH0pO1xuXG4vKipcbiAqIENvbnZlcnRzIHRoaXMgYnVmZmVyIHRvIGl0cyBCaW5hcnkgdHlwZSByZXByZXNlbnRhdGlvbi5cbiAqXG4gKiAjIyMjIFN1YlR5cGVzOlxuICpcbiAqICAgICBjb25zdCBic29uID0gcmVxdWlyZSgnYnNvbicpXG4gKiAgICAgYnNvbi5CU09OX0JJTkFSWV9TVUJUWVBFX0RFRkFVTFRcbiAqICAgICBic29uLkJTT05fQklOQVJZX1NVQlRZUEVfRlVOQ1RJT05cbiAqICAgICBic29uLkJTT05fQklOQVJZX1NVQlRZUEVfQllURV9BUlJBWVxuICogICAgIGJzb24uQlNPTl9CSU5BUllfU1VCVFlQRV9VVUlEXG4gKiAgICAgYnNvbi5CU09OX0JJTkFSWV9TVUJUWVBFX01ENVxuICogICAgIGJzb24uQlNPTl9CSU5BUllfU1VCVFlQRV9VU0VSX0RFRklORURcbiAqICAgICBkb2MuYnVmZmVyLnRvT2JqZWN0KGJzb24uQlNPTl9CSU5BUllfU1VCVFlQRV9VU0VSX0RFRklORUQpO1xuICpcbiAqIEBzZWUgYnNvbnNwZWMgaHR0cHM6Ly9ic29uc3BlYy5vcmcvIy9zcGVjaWZpY2F0aW9uXG4gKiBAcGFyYW0ge0hleH0gW3N1YnR5cGVdXG4gKiBAcmV0dXJuIHtCaW5hcnl9XG4gKiBAYXBpIHB1YmxpY1xuICogQG1ldGhvZCB0b09iamVjdFxuICogQG1lbWJlck9mIE1vbmdvb3NlQnVmZmVyXG4gKi9cblxuTW9uZ29vc2VCdWZmZXIubWl4aW4udG9PYmplY3QgPSBmdW5jdGlvbihvcHRpb25zKSB7XG4gIGNvbnN0IHN1YnR5cGUgPSB0eXBlb2Ygb3B0aW9ucyA9PT0gJ251bWJlcidcbiAgICA/IG9wdGlvbnNcbiAgICA6ICh0aGlzLl9zdWJ0eXBlIHx8IDApO1xuICByZXR1cm4gbmV3IEJpbmFyeShCdWZmZXIuZnJvbSh0aGlzKSwgc3VidHlwZSk7XG59O1xuXG5Nb25nb29zZUJ1ZmZlci5taXhpbi4kdG9PYmplY3QgPSBNb25nb29zZUJ1ZmZlci5taXhpbi50b09iamVjdDtcblxuLyoqXG4gKiBDb252ZXJ0cyB0aGlzIGJ1ZmZlciBmb3Igc3RvcmFnZSBpbiBNb25nb0RCLCBpbmNsdWRpbmcgc3VidHlwZVxuICpcbiAqIEByZXR1cm4ge0JpbmFyeX1cbiAqIEBhcGkgcHVibGljXG4gKiBAbWV0aG9kIHRvQlNPTlxuICogQG1lbWJlck9mIE1vbmdvb3NlQnVmZmVyXG4gKi9cblxuTW9uZ29vc2VCdWZmZXIubWl4aW4udG9CU09OID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiBuZXcgQmluYXJ5KHRoaXMsIHRoaXMuX3N1YnR5cGUgfHwgMCk7XG59O1xuXG4vKipcbiAqIERldGVybWluZXMgaWYgdGhpcyBidWZmZXIgaXMgZXF1YWxzIHRvIGBvdGhlcmAgYnVmZmVyXG4gKlxuICogQHBhcmFtIHtCdWZmZXJ9IG90aGVyXG4gKiBAcmV0dXJuIHtCb29sZWFufVxuICogQG1ldGhvZCBlcXVhbHNcbiAqIEBtZW1iZXJPZiBNb25nb29zZUJ1ZmZlclxuICovXG5cbk1vbmdvb3NlQnVmZmVyLm1peGluLmVxdWFscyA9IGZ1bmN0aW9uKG90aGVyKSB7XG4gIGlmICghQnVmZmVyLmlzQnVmZmVyKG90aGVyKSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIGlmICh0aGlzLmxlbmd0aCAhPT0gb3RoZXIubGVuZ3RoKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLmxlbmd0aDsgKytpKSB7XG4gICAgaWYgKHRoaXNbaV0gIT09IG90aGVyW2ldKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHRydWU7XG59O1xuXG4vKipcbiAqIFNldHMgdGhlIHN1YnR5cGUgb3B0aW9uIGFuZCBtYXJrcyB0aGUgYnVmZmVyIG1vZGlmaWVkLlxuICpcbiAqICMjIyMgU3ViVHlwZXM6XG4gKlxuICogICAgIGNvbnN0IGJzb24gPSByZXF1aXJlKCdic29uJylcbiAqICAgICBic29uLkJTT05fQklOQVJZX1NVQlRZUEVfREVGQVVMVFxuICogICAgIGJzb24uQlNPTl9CSU5BUllfU1VCVFlQRV9GVU5DVElPTlxuICogICAgIGJzb24uQlNPTl9CSU5BUllfU1VCVFlQRV9CWVRFX0FSUkFZXG4gKiAgICAgYnNvbi5CU09OX0JJTkFSWV9TVUJUWVBFX1VVSURcbiAqICAgICBic29uLkJTT05fQklOQVJZX1NVQlRZUEVfTUQ1XG4gKiAgICAgYnNvbi5CU09OX0JJTkFSWV9TVUJUWVBFX1VTRVJfREVGSU5FRFxuICpcbiAqICAgICBkb2MuYnVmZmVyLnN1YnR5cGUoYnNvbi5CU09OX0JJTkFSWV9TVUJUWVBFX1VVSUQpO1xuICpcbiAqIEBzZWUgYnNvbnNwZWMgaHR0cHM6Ly9ic29uc3BlYy5vcmcvIy9zcGVjaWZpY2F0aW9uXG4gKiBAcGFyYW0ge0hleH0gc3VidHlwZVxuICogQGFwaSBwdWJsaWNcbiAqIEBtZXRob2Qgc3VidHlwZVxuICogQG1lbWJlck9mIE1vbmdvb3NlQnVmZmVyXG4gKi9cblxuTW9uZ29vc2VCdWZmZXIubWl4aW4uc3VidHlwZSA9IGZ1bmN0aW9uKHN1YnR5cGUpIHtcbiAgaWYgKHR5cGVvZiBzdWJ0eXBlICE9PSAnbnVtYmVyJykge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0ludmFsaWQgc3VidHlwZS4gRXhwZWN0ZWQgYSBudW1iZXInKTtcbiAgfVxuXG4gIGlmICh0aGlzLl9zdWJ0eXBlICE9PSBzdWJ0eXBlKSB7XG4gICAgdGhpcy5fbWFya01vZGlmaWVkKCk7XG4gIH1cblxuICB0aGlzLl9zdWJ0eXBlID0gc3VidHlwZTtcbn07XG5cbi8qIVxuICogTW9kdWxlIGV4cG9ydHMuXG4gKi9cblxuTW9uZ29vc2VCdWZmZXIuQmluYXJ5ID0gQmluYXJ5O1xuXG5tb2R1bGUuZXhwb3J0cyA9IE1vbmdvb3NlQnVmZmVyO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/mongoose/lib/types/buffer.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/mongoose/lib/types/decimal128.js":
/*!*******************************************************!*\
  !*** ./node_modules/mongoose/lib/types/decimal128.js ***!
  \*******************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("/**\n * Decimal128 type constructor\n *\n * #### Example:\n *\n *     const id = new mongoose.Types.Decimal128('3.1415');\n *\n * @constructor Decimal128\n */\n\n\n\nmodule.exports = __webpack_require__(/*! bson */ \"(ssr)/./node_modules/bson/lib/bson.cjs\").Decimal128;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbW9uZ29vc2UvbGliL3R5cGVzL2RlY2ltYWwxMjguanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVhOztBQUViLHFHQUEyQyIsInNvdXJjZXMiOlsid2VicGFjazovL2FwcDEvLi9ub2RlX21vZHVsZXMvbW9uZ29vc2UvbGliL3R5cGVzL2RlY2ltYWwxMjguanM/MTVlNCJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIERlY2ltYWwxMjggdHlwZSBjb25zdHJ1Y3RvclxuICpcbiAqICMjIyMgRXhhbXBsZTpcbiAqXG4gKiAgICAgY29uc3QgaWQgPSBuZXcgbW9uZ29vc2UuVHlwZXMuRGVjaW1hbDEyOCgnMy4xNDE1Jyk7XG4gKlxuICogQGNvbnN0cnVjdG9yIERlY2ltYWwxMjhcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnYnNvbicpLkRlY2ltYWwxMjg7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/mongoose/lib/types/decimal128.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/mongoose/lib/types/documentArray/index.js":
/*!****************************************************************!*\
  !*** ./node_modules/mongoose/lib/types/documentArray/index.js ***!
  \****************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\n\n/*!\n * Module dependencies.\n */\n\nconst ArrayMethods = __webpack_require__(/*! ../array/methods */ \"(ssr)/./node_modules/mongoose/lib/types/array/methods/index.js\");\nconst DocumentArrayMethods = __webpack_require__(/*! ./methods */ \"(ssr)/./node_modules/mongoose/lib/types/documentArray/methods/index.js\");\nconst Document = __webpack_require__(/*! ../../document */ \"(ssr)/./node_modules/mongoose/lib/document.js\");\n\nconst arrayAtomicsSymbol = (__webpack_require__(/*! ../../helpers/symbols */ \"(ssr)/./node_modules/mongoose/lib/helpers/symbols.js\").arrayAtomicsSymbol);\nconst arrayAtomicsBackupSymbol = (__webpack_require__(/*! ../../helpers/symbols */ \"(ssr)/./node_modules/mongoose/lib/helpers/symbols.js\").arrayAtomicsBackupSymbol);\nconst arrayParentSymbol = (__webpack_require__(/*! ../../helpers/symbols */ \"(ssr)/./node_modules/mongoose/lib/helpers/symbols.js\").arrayParentSymbol);\nconst arrayPathSymbol = (__webpack_require__(/*! ../../helpers/symbols */ \"(ssr)/./node_modules/mongoose/lib/helpers/symbols.js\").arrayPathSymbol);\nconst arraySchemaSymbol = (__webpack_require__(/*! ../../helpers/symbols */ \"(ssr)/./node_modules/mongoose/lib/helpers/symbols.js\").arraySchemaSymbol);\n\nconst _basePush = Array.prototype.push;\nconst numberRE = /^\\d+$/;\n/**\n * DocumentArray constructor\n *\n * @param {Array} values\n * @param {String} path the path to this array\n * @param {Document} doc parent document\n * @api private\n * @return {MongooseDocumentArray}\n * @inherits MongooseArray\n * @see https://bit.ly/f6CnZU\n */\n\nfunction MongooseDocumentArray(values, path, doc) {\n  const __array = [];\n\n  const internals = {\n    [arrayAtomicsSymbol]: {},\n    [arrayAtomicsBackupSymbol]: void 0,\n    [arrayPathSymbol]: path,\n    [arraySchemaSymbol]: void 0,\n    [arrayParentSymbol]: void 0\n  };\n\n  if (Array.isArray(values)) {\n    if (values[arrayPathSymbol] === path &&\n        values[arrayParentSymbol] === doc) {\n      internals[arrayAtomicsSymbol] = Object.assign({}, values[arrayAtomicsSymbol]);\n    }\n    values.forEach(v => {\n      _basePush.call(__array, v);\n    });\n  }\n  internals[arrayPathSymbol] = path;\n  internals.__array = __array;\n\n  // Because doc comes from the context of another function, doc === global\n  // can happen if there was a null somewhere up the chain (see #3020 && #3034)\n  // RB Jun 17, 2015 updated to check for presence of expected paths instead\n  // to make more proof against unusual node environments\n  if (doc && doc instanceof Document) {\n    internals[arrayParentSymbol] = doc;\n    internals[arraySchemaSymbol] = doc.$__schema.path(path);\n\n    // `schema.path()` doesn't drill into nested arrays properly yet, see\n    // gh-6398, gh-6602. This is a workaround because nested arrays are\n    // always plain non-document arrays, so once you get to a document array\n    // nesting is done. Matryoshka code.\n    while (internals[arraySchemaSymbol] != null &&\n        internals[arraySchemaSymbol].$isMongooseArray &&\n        !internals[arraySchemaSymbol].$isMongooseDocumentArray) {\n      internals[arraySchemaSymbol] = internals[arraySchemaSymbol].casterConstructor;\n    }\n  }\n\n  const proxy = new Proxy(__array, {\n    get: function(target, prop) {\n      if (prop === 'isMongooseArray' ||\n          prop === 'isMongooseArrayProxy' ||\n          prop === 'isMongooseDocumentArray' ||\n          prop === 'isMongooseDocumentArrayProxy') {\n        return true;\n      }\n      if (internals.hasOwnProperty(prop)) {\n        return internals[prop];\n      }\n      if (DocumentArrayMethods.hasOwnProperty(prop)) {\n        return DocumentArrayMethods[prop];\n      }\n      if (ArrayMethods.hasOwnProperty(prop)) {\n        return ArrayMethods[prop];\n      }\n\n      return __array[prop];\n    },\n    set: function(target, prop, value) {\n      if (typeof prop === 'string' && numberRE.test(prop)) {\n        DocumentArrayMethods.set.call(proxy, prop, value, false);\n      } else if (internals.hasOwnProperty(prop)) {\n        internals[prop] = value;\n      } else {\n        __array[prop] = value;\n      }\n\n      return true;\n    }\n  });\n\n  return proxy;\n}\n\n/*!\n * Module exports.\n */\n\nmodule.exports = MongooseDocumentArray;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbW9uZ29vc2UvbGliL3R5cGVzL2RvY3VtZW50QXJyYXkvaW5kZXguanMiLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWI7QUFDQTtBQUNBOztBQUVBLHFCQUFxQixtQkFBTyxDQUFDLHdGQUFrQjtBQUMvQyw2QkFBNkIsbUJBQU8sQ0FBQyx5RkFBVztBQUNoRCxpQkFBaUIsbUJBQU8sQ0FBQyxxRUFBZ0I7O0FBRXpDLDJCQUEyQiw2SEFBbUQ7QUFDOUUsaUNBQWlDLG1JQUF5RDtBQUMxRiwwQkFBMEIsNEhBQWtEO0FBQzVFLHdCQUF3QiwwSEFBZ0Q7QUFDeEUsMEJBQTBCLDRIQUFrRDs7QUFFNUU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQixXQUFXLFFBQVE7QUFDbkIsV0FBVyxVQUFVO0FBQ3JCO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsNEJBQTRCO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esc0RBQXNEO0FBQ3REO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQSxRQUFRO0FBQ1I7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSIsInNvdXJjZXMiOlsid2VicGFjazovL2FwcDEvLi9ub2RlX21vZHVsZXMvbW9uZ29vc2UvbGliL3R5cGVzL2RvY3VtZW50QXJyYXkvaW5kZXguanM/OTQzNSJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbi8qIVxuICogTW9kdWxlIGRlcGVuZGVuY2llcy5cbiAqL1xuXG5jb25zdCBBcnJheU1ldGhvZHMgPSByZXF1aXJlKCcuLi9hcnJheS9tZXRob2RzJyk7XG5jb25zdCBEb2N1bWVudEFycmF5TWV0aG9kcyA9IHJlcXVpcmUoJy4vbWV0aG9kcycpO1xuY29uc3QgRG9jdW1lbnQgPSByZXF1aXJlKCcuLi8uLi9kb2N1bWVudCcpO1xuXG5jb25zdCBhcnJheUF0b21pY3NTeW1ib2wgPSByZXF1aXJlKCcuLi8uLi9oZWxwZXJzL3N5bWJvbHMnKS5hcnJheUF0b21pY3NTeW1ib2w7XG5jb25zdCBhcnJheUF0b21pY3NCYWNrdXBTeW1ib2wgPSByZXF1aXJlKCcuLi8uLi9oZWxwZXJzL3N5bWJvbHMnKS5hcnJheUF0b21pY3NCYWNrdXBTeW1ib2w7XG5jb25zdCBhcnJheVBhcmVudFN5bWJvbCA9IHJlcXVpcmUoJy4uLy4uL2hlbHBlcnMvc3ltYm9scycpLmFycmF5UGFyZW50U3ltYm9sO1xuY29uc3QgYXJyYXlQYXRoU3ltYm9sID0gcmVxdWlyZSgnLi4vLi4vaGVscGVycy9zeW1ib2xzJykuYXJyYXlQYXRoU3ltYm9sO1xuY29uc3QgYXJyYXlTY2hlbWFTeW1ib2wgPSByZXF1aXJlKCcuLi8uLi9oZWxwZXJzL3N5bWJvbHMnKS5hcnJheVNjaGVtYVN5bWJvbDtcblxuY29uc3QgX2Jhc2VQdXNoID0gQXJyYXkucHJvdG90eXBlLnB1c2g7XG5jb25zdCBudW1iZXJSRSA9IC9eXFxkKyQvO1xuLyoqXG4gKiBEb2N1bWVudEFycmF5IGNvbnN0cnVjdG9yXG4gKlxuICogQHBhcmFtIHtBcnJheX0gdmFsdWVzXG4gKiBAcGFyYW0ge1N0cmluZ30gcGF0aCB0aGUgcGF0aCB0byB0aGlzIGFycmF5XG4gKiBAcGFyYW0ge0RvY3VtZW50fSBkb2MgcGFyZW50IGRvY3VtZW50XG4gKiBAYXBpIHByaXZhdGVcbiAqIEByZXR1cm4ge01vbmdvb3NlRG9jdW1lbnRBcnJheX1cbiAqIEBpbmhlcml0cyBNb25nb29zZUFycmF5XG4gKiBAc2VlIGh0dHBzOi8vYml0Lmx5L2Y2Q25aVVxuICovXG5cbmZ1bmN0aW9uIE1vbmdvb3NlRG9jdW1lbnRBcnJheSh2YWx1ZXMsIHBhdGgsIGRvYykge1xuICBjb25zdCBfX2FycmF5ID0gW107XG5cbiAgY29uc3QgaW50ZXJuYWxzID0ge1xuICAgIFthcnJheUF0b21pY3NTeW1ib2xdOiB7fSxcbiAgICBbYXJyYXlBdG9taWNzQmFja3VwU3ltYm9sXTogdm9pZCAwLFxuICAgIFthcnJheVBhdGhTeW1ib2xdOiBwYXRoLFxuICAgIFthcnJheVNjaGVtYVN5bWJvbF06IHZvaWQgMCxcbiAgICBbYXJyYXlQYXJlbnRTeW1ib2xdOiB2b2lkIDBcbiAgfTtcblxuICBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZXMpKSB7XG4gICAgaWYgKHZhbHVlc1thcnJheVBhdGhTeW1ib2xdID09PSBwYXRoICYmXG4gICAgICAgIHZhbHVlc1thcnJheVBhcmVudFN5bWJvbF0gPT09IGRvYykge1xuICAgICAgaW50ZXJuYWxzW2FycmF5QXRvbWljc1N5bWJvbF0gPSBPYmplY3QuYXNzaWduKHt9LCB2YWx1ZXNbYXJyYXlBdG9taWNzU3ltYm9sXSk7XG4gICAgfVxuICAgIHZhbHVlcy5mb3JFYWNoKHYgPT4ge1xuICAgICAgX2Jhc2VQdXNoLmNhbGwoX19hcnJheSwgdik7XG4gICAgfSk7XG4gIH1cbiAgaW50ZXJuYWxzW2FycmF5UGF0aFN5bWJvbF0gPSBwYXRoO1xuICBpbnRlcm5hbHMuX19hcnJheSA9IF9fYXJyYXk7XG5cbiAgLy8gQmVjYXVzZSBkb2MgY29tZXMgZnJvbSB0aGUgY29udGV4dCBvZiBhbm90aGVyIGZ1bmN0aW9uLCBkb2MgPT09IGdsb2JhbFxuICAvLyBjYW4gaGFwcGVuIGlmIHRoZXJlIHdhcyBhIG51bGwgc29tZXdoZXJlIHVwIHRoZSBjaGFpbiAoc2VlICMzMDIwICYmICMzMDM0KVxuICAvLyBSQiBKdW4gMTcsIDIwMTUgdXBkYXRlZCB0byBjaGVjayBmb3IgcHJlc2VuY2Ugb2YgZXhwZWN0ZWQgcGF0aHMgaW5zdGVhZFxuICAvLyB0byBtYWtlIG1vcmUgcHJvb2YgYWdhaW5zdCB1bnVzdWFsIG5vZGUgZW52aXJvbm1lbnRzXG4gIGlmIChkb2MgJiYgZG9jIGluc3RhbmNlb2YgRG9jdW1lbnQpIHtcbiAgICBpbnRlcm5hbHNbYXJyYXlQYXJlbnRTeW1ib2xdID0gZG9jO1xuICAgIGludGVybmFsc1thcnJheVNjaGVtYVN5bWJvbF0gPSBkb2MuJF9fc2NoZW1hLnBhdGgocGF0aCk7XG5cbiAgICAvLyBgc2NoZW1hLnBhdGgoKWAgZG9lc24ndCBkcmlsbCBpbnRvIG5lc3RlZCBhcnJheXMgcHJvcGVybHkgeWV0LCBzZWVcbiAgICAvLyBnaC02Mzk4LCBnaC02NjAyLiBUaGlzIGlzIGEgd29ya2Fyb3VuZCBiZWNhdXNlIG5lc3RlZCBhcnJheXMgYXJlXG4gICAgLy8gYWx3YXlzIHBsYWluIG5vbi1kb2N1bWVudCBhcnJheXMsIHNvIG9uY2UgeW91IGdldCB0byBhIGRvY3VtZW50IGFycmF5XG4gICAgLy8gbmVzdGluZyBpcyBkb25lLiBNYXRyeW9zaGthIGNvZGUuXG4gICAgd2hpbGUgKGludGVybmFsc1thcnJheVNjaGVtYVN5bWJvbF0gIT0gbnVsbCAmJlxuICAgICAgICBpbnRlcm5hbHNbYXJyYXlTY2hlbWFTeW1ib2xdLiRpc01vbmdvb3NlQXJyYXkgJiZcbiAgICAgICAgIWludGVybmFsc1thcnJheVNjaGVtYVN5bWJvbF0uJGlzTW9uZ29vc2VEb2N1bWVudEFycmF5KSB7XG4gICAgICBpbnRlcm5hbHNbYXJyYXlTY2hlbWFTeW1ib2xdID0gaW50ZXJuYWxzW2FycmF5U2NoZW1hU3ltYm9sXS5jYXN0ZXJDb25zdHJ1Y3RvcjtcbiAgICB9XG4gIH1cblxuICBjb25zdCBwcm94eSA9IG5ldyBQcm94eShfX2FycmF5LCB7XG4gICAgZ2V0OiBmdW5jdGlvbih0YXJnZXQsIHByb3ApIHtcbiAgICAgIGlmIChwcm9wID09PSAnaXNNb25nb29zZUFycmF5JyB8fFxuICAgICAgICAgIHByb3AgPT09ICdpc01vbmdvb3NlQXJyYXlQcm94eScgfHxcbiAgICAgICAgICBwcm9wID09PSAnaXNNb25nb29zZURvY3VtZW50QXJyYXknIHx8XG4gICAgICAgICAgcHJvcCA9PT0gJ2lzTW9uZ29vc2VEb2N1bWVudEFycmF5UHJveHknKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgICAgaWYgKGludGVybmFscy5oYXNPd25Qcm9wZXJ0eShwcm9wKSkge1xuICAgICAgICByZXR1cm4gaW50ZXJuYWxzW3Byb3BdO1xuICAgICAgfVxuICAgICAgaWYgKERvY3VtZW50QXJyYXlNZXRob2RzLmhhc093blByb3BlcnR5KHByb3ApKSB7XG4gICAgICAgIHJldHVybiBEb2N1bWVudEFycmF5TWV0aG9kc1twcm9wXTtcbiAgICAgIH1cbiAgICAgIGlmIChBcnJheU1ldGhvZHMuaGFzT3duUHJvcGVydHkocHJvcCkpIHtcbiAgICAgICAgcmV0dXJuIEFycmF5TWV0aG9kc1twcm9wXTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIF9fYXJyYXlbcHJvcF07XG4gICAgfSxcbiAgICBzZXQ6IGZ1bmN0aW9uKHRhcmdldCwgcHJvcCwgdmFsdWUpIHtcbiAgICAgIGlmICh0eXBlb2YgcHJvcCA9PT0gJ3N0cmluZycgJiYgbnVtYmVyUkUudGVzdChwcm9wKSkge1xuICAgICAgICBEb2N1bWVudEFycmF5TWV0aG9kcy5zZXQuY2FsbChwcm94eSwgcHJvcCwgdmFsdWUsIGZhbHNlKTtcbiAgICAgIH0gZWxzZSBpZiAoaW50ZXJuYWxzLmhhc093blByb3BlcnR5KHByb3ApKSB7XG4gICAgICAgIGludGVybmFsc1twcm9wXSA9IHZhbHVlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgX19hcnJheVtwcm9wXSA9IHZhbHVlO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH0pO1xuXG4gIHJldHVybiBwcm94eTtcbn1cblxuLyohXG4gKiBNb2R1bGUgZXhwb3J0cy5cbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IE1vbmdvb3NlRG9jdW1lbnRBcnJheTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/mongoose/lib/types/documentArray/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/mongoose/lib/types/documentArray/isMongooseDocumentArray.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/mongoose/lib/types/documentArray/isMongooseDocumentArray.js ***!
  \**********************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\n\nexports.isMongooseDocumentArray = function(mongooseDocumentArray) {\n  return Array.isArray(mongooseDocumentArray) && mongooseDocumentArray.isMongooseDocumentArray;\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbW9uZ29vc2UvbGliL3R5cGVzL2RvY3VtZW50QXJyYXkvaXNNb25nb29zZURvY3VtZW50QXJyYXkuanMiLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWIsK0JBQStCO0FBQy9CO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9hcHAxLy4vbm9kZV9tb2R1bGVzL21vbmdvb3NlL2xpYi90eXBlcy9kb2N1bWVudEFycmF5L2lzTW9uZ29vc2VEb2N1bWVudEFycmF5LmpzPzY4MGMiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG5leHBvcnRzLmlzTW9uZ29vc2VEb2N1bWVudEFycmF5ID0gZnVuY3Rpb24obW9uZ29vc2VEb2N1bWVudEFycmF5KSB7XG4gIHJldHVybiBBcnJheS5pc0FycmF5KG1vbmdvb3NlRG9jdW1lbnRBcnJheSkgJiYgbW9uZ29vc2VEb2N1bWVudEFycmF5LmlzTW9uZ29vc2VEb2N1bWVudEFycmF5O1xufTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/mongoose/lib/types/documentArray/isMongooseDocumentArray.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/mongoose/lib/types/documentArray/methods/index.js":
/*!************************************************************************!*\
  !*** ./node_modules/mongoose/lib/types/documentArray/methods/index.js ***!
  \************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\n\nconst ArrayMethods = __webpack_require__(/*! ../../array/methods */ \"(ssr)/./node_modules/mongoose/lib/types/array/methods/index.js\");\nconst Document = __webpack_require__(/*! ../../../document */ \"(ssr)/./node_modules/mongoose/lib/document.js\");\nconst castObjectId = __webpack_require__(/*! ../../../cast/objectid */ \"(ssr)/./node_modules/mongoose/lib/cast/objectid.js\");\nconst getDiscriminatorByValue = __webpack_require__(/*! ../../../helpers/discriminator/getDiscriminatorByValue */ \"(ssr)/./node_modules/mongoose/lib/helpers/discriminator/getDiscriminatorByValue.js\");\nconst internalToObjectOptions = (__webpack_require__(/*! ../../../options */ \"(ssr)/./node_modules/mongoose/lib/options.js\").internalToObjectOptions);\nconst utils = __webpack_require__(/*! ../../../utils */ \"(ssr)/./node_modules/mongoose/lib/utils.js\");\nconst isBsonType = __webpack_require__(/*! ../../../helpers/isBsonType */ \"(ssr)/./node_modules/mongoose/lib/helpers/isBsonType.js\");\n\nconst arrayParentSymbol = (__webpack_require__(/*! ../../../helpers/symbols */ \"(ssr)/./node_modules/mongoose/lib/helpers/symbols.js\").arrayParentSymbol);\nconst arrayPathSymbol = (__webpack_require__(/*! ../../../helpers/symbols */ \"(ssr)/./node_modules/mongoose/lib/helpers/symbols.js\").arrayPathSymbol);\nconst arraySchemaSymbol = (__webpack_require__(/*! ../../../helpers/symbols */ \"(ssr)/./node_modules/mongoose/lib/helpers/symbols.js\").arraySchemaSymbol);\nconst documentArrayParent = (__webpack_require__(/*! ../../../helpers/symbols */ \"(ssr)/./node_modules/mongoose/lib/helpers/symbols.js\").documentArrayParent);\n\nconst methods = {\n  /*!\n   * ignore\n   */\n\n  toBSON() {\n    return this.toObject(internalToObjectOptions);\n  },\n\n  /*!\n   * ignore\n   */\n\n  getArrayParent() {\n    return this[arrayParentSymbol];\n  },\n\n  /**\n   * Overrides MongooseArray#cast\n   *\n   * @method _cast\n   * @api private\n   * @memberOf MongooseDocumentArray\n   */\n\n  _cast(value, index, options) {\n    if (this[arraySchemaSymbol] == null) {\n      return value;\n    }\n    let Constructor = this[arraySchemaSymbol].casterConstructor;\n    const isInstance = Constructor.$isMongooseDocumentArray ?\n      utils.isMongooseDocumentArray(value) :\n      value instanceof Constructor;\n    if (isInstance ||\n        // Hack re: #5001, see #5005\n        (value && value.constructor && value.constructor.baseCasterConstructor === Constructor)) {\n      if (!(value[documentArrayParent] && value.__parentArray)) {\n        // value may have been created using array.create()\n        value[documentArrayParent] = this[arrayParentSymbol];\n        value.__parentArray = this;\n      }\n      value.$setIndex(index);\n      return value;\n    }\n\n    if (value === undefined || value === null) {\n      return null;\n    }\n\n    // handle cast('string') or cast(ObjectId) etc.\n    // only objects are permitted so we can safely assume that\n    // non-objects are to be interpreted as _id\n    if (Buffer.isBuffer(value) ||\n        isBsonType(value, 'ObjectId') || !utils.isObject(value)) {\n      value = { _id: value };\n    }\n\n    if (value &&\n        Constructor.discriminators &&\n        Constructor.schema &&\n        Constructor.schema.options &&\n        Constructor.schema.options.discriminatorKey) {\n      if (typeof value[Constructor.schema.options.discriminatorKey] === 'string' &&\n          Constructor.discriminators[value[Constructor.schema.options.discriminatorKey]]) {\n        Constructor = Constructor.discriminators[value[Constructor.schema.options.discriminatorKey]];\n      } else {\n        const constructorByValue = getDiscriminatorByValue(Constructor.discriminators, value[Constructor.schema.options.discriminatorKey]);\n        if (constructorByValue) {\n          Constructor = constructorByValue;\n        }\n      }\n    }\n\n    if (Constructor.$isMongooseDocumentArray) {\n      return Constructor.cast(value, this, undefined, undefined, index);\n    }\n    const ret = new Constructor(value, this, options, undefined, index);\n    ret.isNew = true;\n    return ret;\n  },\n\n  /**\n   * Searches array items for the first document with a matching _id.\n   *\n   * #### Example:\n   *\n   *     const embeddedDoc = m.array.id(some_id);\n   *\n   * @return {EmbeddedDocument|null} the subdocument or null if not found.\n   * @param {ObjectId|String|Number|Buffer} id\n   * @TODO cast to the _id based on schema for proper comparison\n   * @method id\n   * @api public\n   * @memberOf MongooseDocumentArray\n   */\n\n  id(id) {\n    let casted;\n    let sid;\n    let _id;\n\n    try {\n      casted = castObjectId(id).toString();\n    } catch (e) {\n      casted = null;\n    }\n\n    for (const val of this) {\n      if (!val) {\n        continue;\n      }\n\n      _id = val.get('_id');\n\n      if (_id === null || typeof _id === 'undefined') {\n        continue;\n      } else if (_id instanceof Document) {\n        sid || (sid = String(id));\n        if (sid == _id._id) {\n          return val;\n        }\n      } else if (!isBsonType(id, 'ObjectId') && !isBsonType(_id, 'ObjectId')) {\n        if (id == _id || utils.deepEqual(id, _id)) {\n          return val;\n        }\n      } else if (casted == _id) {\n        return val;\n      }\n    }\n\n    return null;\n  },\n\n  /**\n   * Returns a native js Array of plain js objects\n   *\n   * #### Note:\n   *\n   * _Each sub-document is converted to a plain object by calling its `#toObject` method._\n   *\n   * @param {Object} [options] optional options to pass to each documents `toObject` method call during conversion\n   * @return {Array}\n   * @method toObject\n   * @api public\n   * @memberOf MongooseDocumentArray\n   */\n\n  toObject(options) {\n    // `[].concat` coerces the return value into a vanilla JS array, rather\n    // than a Mongoose array.\n    return [].concat(this.map(function(doc) {\n      if (doc == null) {\n        return null;\n      }\n      if (typeof doc.toObject !== 'function') {\n        return doc;\n      }\n      return doc.toObject(options);\n    }));\n  },\n\n  $toObject() {\n    return this.constructor.prototype.toObject.apply(this, arguments);\n  },\n\n  /**\n   * Wraps [`Array#push`](https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Array/push) with proper change tracking.\n   *\n   * @param {...Object} [args]\n   * @api public\n   * @method push\n   * @memberOf MongooseDocumentArray\n   */\n\n  push() {\n    const ret = ArrayMethods.push.apply(this, arguments);\n\n    _updateParentPopulated(this);\n\n    return ret;\n  },\n\n  /**\n   * Pulls items from the array atomically.\n   *\n   * @param {...Object} [args]\n   * @api public\n   * @method pull\n   * @memberOf MongooseDocumentArray\n   */\n\n  pull() {\n    const ret = ArrayMethods.pull.apply(this, arguments);\n\n    _updateParentPopulated(this);\n\n    return ret;\n  },\n\n  /**\n   * Wraps [`Array#shift`](https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Array/unshift) with proper change tracking.\n   * @api private\n   */\n\n  shift() {\n    const ret = ArrayMethods.shift.apply(this, arguments);\n\n    _updateParentPopulated(this);\n\n    return ret;\n  },\n\n  /**\n   * Wraps [`Array#splice`](https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Array/splice) with proper change tracking and casting.\n   * @api private\n   */\n\n  splice() {\n    const ret = ArrayMethods.splice.apply(this, arguments);\n\n    _updateParentPopulated(this);\n\n    return ret;\n  },\n\n  /**\n   * Helper for console.log\n   *\n   * @method inspect\n   * @api public\n   * @memberOf MongooseDocumentArray\n   */\n\n  inspect() {\n    return this.toObject();\n  },\n\n  /**\n   * Creates a subdocument casted to this schema.\n   *\n   * This is the same subdocument constructor used for casting.\n   *\n   * @param {Object} obj the value to cast to this arrays SubDocument schema\n   * @method create\n   * @api public\n   * @memberOf MongooseDocumentArray\n   */\n\n  create(obj) {\n    let Constructor = this[arraySchemaSymbol].casterConstructor;\n    if (obj &&\n        Constructor.discriminators &&\n        Constructor.schema &&\n        Constructor.schema.options &&\n        Constructor.schema.options.discriminatorKey) {\n      if (typeof obj[Constructor.schema.options.discriminatorKey] === 'string' &&\n          Constructor.discriminators[obj[Constructor.schema.options.discriminatorKey]]) {\n        Constructor = Constructor.discriminators[obj[Constructor.schema.options.discriminatorKey]];\n      } else {\n        const constructorByValue = getDiscriminatorByValue(Constructor.discriminators, obj[Constructor.schema.options.discriminatorKey]);\n        if (constructorByValue) {\n          Constructor = constructorByValue;\n        }\n      }\n    }\n\n    return new Constructor(obj, this);\n  },\n\n  /*!\n   * ignore\n   */\n\n  notify(event) {\n    const _this = this;\n    return function notify(val, _arr) {\n      _arr = _arr || _this;\n      let i = _arr.length;\n      while (i--) {\n        if (_arr[i] == null) {\n          continue;\n        }\n        switch (event) {\n          // only swap for save event for now, we may change this to all event types later\n          case 'save':\n            val = _this[i];\n            break;\n          default:\n            // NO-OP\n            break;\n        }\n\n        if (utils.isMongooseArray(_arr[i])) {\n          notify(val, _arr[i]);\n        } else if (_arr[i]) {\n          _arr[i].emit(event, val);\n        }\n      }\n    };\n  },\n\n  set(i, val, skipModified) {\n    const arr = this.__array;\n    if (skipModified) {\n      arr[i] = val;\n      return this;\n    }\n    const value = methods._cast.call(this, val, i);\n    methods._markModified.call(this, i);\n    arr[i] = value;\n    return this;\n  },\n\n  _markModified(elem, embeddedPath) {\n    const parent = this[arrayParentSymbol];\n    let dirtyPath;\n\n    if (parent) {\n      dirtyPath = this[arrayPathSymbol];\n\n      if (arguments.length) {\n        if (embeddedPath != null) {\n          // an embedded doc bubbled up the change\n          const index = elem.__index;\n          dirtyPath = dirtyPath + '.' + index + '.' + embeddedPath;\n        } else {\n          // directly set an index\n          dirtyPath = dirtyPath + '.' + elem;\n        }\n      }\n\n      if (dirtyPath != null && dirtyPath.endsWith('.$')) {\n        return this;\n      }\n\n      parent.markModified(dirtyPath, arguments.length !== 0 ? elem : parent);\n    }\n\n    return this;\n  }\n};\n\nmodule.exports = methods;\n\n/**\n * If this is a document array, each element may contain single\n * populated paths, so we need to modify the top-level document's\n * populated cache. See gh-8247, gh-8265.\n * @param {Array} arr\n * @api private\n */\n\nfunction _updateParentPopulated(arr) {\n  const parent = arr[arrayParentSymbol];\n  if (!parent || parent.$__.populated == null) return;\n\n  const populatedPaths = Object.keys(parent.$__.populated).\n    filter(p => p.startsWith(arr[arrayPathSymbol] + '.'));\n\n  for (const path of populatedPaths) {\n    const remnant = path.slice((arr[arrayPathSymbol] + '.').length);\n    if (!Array.isArray(parent.$__.populated[path].value)) {\n      continue;\n    }\n\n    parent.$__.populated[path].value = arr.map(val => val.$populated(remnant));\n  }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbW9uZ29vc2UvbGliL3R5cGVzL2RvY3VtZW50QXJyYXkvbWV0aG9kcy9pbmRleC5qcyIsIm1hcHBpbmdzIjoiQUFBYTs7QUFFYixxQkFBcUIsbUJBQU8sQ0FBQywyRkFBcUI7QUFDbEQsaUJBQWlCLG1CQUFPLENBQUMsd0VBQW1CO0FBQzVDLHFCQUFxQixtQkFBTyxDQUFDLGtGQUF3QjtBQUNyRCxnQ0FBZ0MsbUJBQU8sQ0FBQyxrSkFBd0Q7QUFDaEcsZ0NBQWdDLHFIQUFtRDtBQUNuRixjQUFjLG1CQUFPLENBQUMsa0VBQWdCO0FBQ3RDLG1CQUFtQixtQkFBTyxDQUFDLDRGQUE2Qjs7QUFFeEQsMEJBQTBCLCtIQUFxRDtBQUMvRSx3QkFBd0IsNkhBQW1EO0FBQzNFLDBCQUEwQiwrSEFBcUQ7QUFDL0UsNEJBQTRCLGlJQUF1RDs7QUFFbkY7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLHVCQUF1QjtBQUNyQyxhQUFhLCtCQUErQjtBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLEdBQUc7O0FBRUg7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0EsYUFBYSxXQUFXO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBLGFBQWEsV0FBVztBQUN4QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE9BQU87QUFDbEI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL2FwcDEvLi9ub2RlX21vZHVsZXMvbW9uZ29vc2UvbGliL3R5cGVzL2RvY3VtZW50QXJyYXkvbWV0aG9kcy9pbmRleC5qcz9mMGM5Il0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxuY29uc3QgQXJyYXlNZXRob2RzID0gcmVxdWlyZSgnLi4vLi4vYXJyYXkvbWV0aG9kcycpO1xuY29uc3QgRG9jdW1lbnQgPSByZXF1aXJlKCcuLi8uLi8uLi9kb2N1bWVudCcpO1xuY29uc3QgY2FzdE9iamVjdElkID0gcmVxdWlyZSgnLi4vLi4vLi4vY2FzdC9vYmplY3RpZCcpO1xuY29uc3QgZ2V0RGlzY3JpbWluYXRvckJ5VmFsdWUgPSByZXF1aXJlKCcuLi8uLi8uLi9oZWxwZXJzL2Rpc2NyaW1pbmF0b3IvZ2V0RGlzY3JpbWluYXRvckJ5VmFsdWUnKTtcbmNvbnN0IGludGVybmFsVG9PYmplY3RPcHRpb25zID0gcmVxdWlyZSgnLi4vLi4vLi4vb3B0aW9ucycpLmludGVybmFsVG9PYmplY3RPcHRpb25zO1xuY29uc3QgdXRpbHMgPSByZXF1aXJlKCcuLi8uLi8uLi91dGlscycpO1xuY29uc3QgaXNCc29uVHlwZSA9IHJlcXVpcmUoJy4uLy4uLy4uL2hlbHBlcnMvaXNCc29uVHlwZScpO1xuXG5jb25zdCBhcnJheVBhcmVudFN5bWJvbCA9IHJlcXVpcmUoJy4uLy4uLy4uL2hlbHBlcnMvc3ltYm9scycpLmFycmF5UGFyZW50U3ltYm9sO1xuY29uc3QgYXJyYXlQYXRoU3ltYm9sID0gcmVxdWlyZSgnLi4vLi4vLi4vaGVscGVycy9zeW1ib2xzJykuYXJyYXlQYXRoU3ltYm9sO1xuY29uc3QgYXJyYXlTY2hlbWFTeW1ib2wgPSByZXF1aXJlKCcuLi8uLi8uLi9oZWxwZXJzL3N5bWJvbHMnKS5hcnJheVNjaGVtYVN5bWJvbDtcbmNvbnN0IGRvY3VtZW50QXJyYXlQYXJlbnQgPSByZXF1aXJlKCcuLi8uLi8uLi9oZWxwZXJzL3N5bWJvbHMnKS5kb2N1bWVudEFycmF5UGFyZW50O1xuXG5jb25zdCBtZXRob2RzID0ge1xuICAvKiFcbiAgICogaWdub3JlXG4gICAqL1xuXG4gIHRvQlNPTigpIHtcbiAgICByZXR1cm4gdGhpcy50b09iamVjdChpbnRlcm5hbFRvT2JqZWN0T3B0aW9ucyk7XG4gIH0sXG5cbiAgLyohXG4gICAqIGlnbm9yZVxuICAgKi9cblxuICBnZXRBcnJheVBhcmVudCgpIHtcbiAgICByZXR1cm4gdGhpc1thcnJheVBhcmVudFN5bWJvbF07XG4gIH0sXG5cbiAgLyoqXG4gICAqIE92ZXJyaWRlcyBNb25nb29zZUFycmF5I2Nhc3RcbiAgICpcbiAgICogQG1ldGhvZCBfY2FzdFxuICAgKiBAYXBpIHByaXZhdGVcbiAgICogQG1lbWJlck9mIE1vbmdvb3NlRG9jdW1lbnRBcnJheVxuICAgKi9cblxuICBfY2FzdCh2YWx1ZSwgaW5kZXgsIG9wdGlvbnMpIHtcbiAgICBpZiAodGhpc1thcnJheVNjaGVtYVN5bWJvbF0gPT0gbnVsbCkge1xuICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH1cbiAgICBsZXQgQ29uc3RydWN0b3IgPSB0aGlzW2FycmF5U2NoZW1hU3ltYm9sXS5jYXN0ZXJDb25zdHJ1Y3RvcjtcbiAgICBjb25zdCBpc0luc3RhbmNlID0gQ29uc3RydWN0b3IuJGlzTW9uZ29vc2VEb2N1bWVudEFycmF5ID9cbiAgICAgIHV0aWxzLmlzTW9uZ29vc2VEb2N1bWVudEFycmF5KHZhbHVlKSA6XG4gICAgICB2YWx1ZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yO1xuICAgIGlmIChpc0luc3RhbmNlIHx8XG4gICAgICAgIC8vIEhhY2sgcmU6ICM1MDAxLCBzZWUgIzUwMDVcbiAgICAgICAgKHZhbHVlICYmIHZhbHVlLmNvbnN0cnVjdG9yICYmIHZhbHVlLmNvbnN0cnVjdG9yLmJhc2VDYXN0ZXJDb25zdHJ1Y3RvciA9PT0gQ29uc3RydWN0b3IpKSB7XG4gICAgICBpZiAoISh2YWx1ZVtkb2N1bWVudEFycmF5UGFyZW50XSAmJiB2YWx1ZS5fX3BhcmVudEFycmF5KSkge1xuICAgICAgICAvLyB2YWx1ZSBtYXkgaGF2ZSBiZWVuIGNyZWF0ZWQgdXNpbmcgYXJyYXkuY3JlYXRlKClcbiAgICAgICAgdmFsdWVbZG9jdW1lbnRBcnJheVBhcmVudF0gPSB0aGlzW2FycmF5UGFyZW50U3ltYm9sXTtcbiAgICAgICAgdmFsdWUuX19wYXJlbnRBcnJheSA9IHRoaXM7XG4gICAgICB9XG4gICAgICB2YWx1ZS4kc2V0SW5kZXgoaW5kZXgpO1xuICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH1cblxuICAgIGlmICh2YWx1ZSA9PT0gdW5kZWZpbmVkIHx8IHZhbHVlID09PSBudWxsKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICAvLyBoYW5kbGUgY2FzdCgnc3RyaW5nJykgb3IgY2FzdChPYmplY3RJZCkgZXRjLlxuICAgIC8vIG9ubHkgb2JqZWN0cyBhcmUgcGVybWl0dGVkIHNvIHdlIGNhbiBzYWZlbHkgYXNzdW1lIHRoYXRcbiAgICAvLyBub24tb2JqZWN0cyBhcmUgdG8gYmUgaW50ZXJwcmV0ZWQgYXMgX2lkXG4gICAgaWYgKEJ1ZmZlci5pc0J1ZmZlcih2YWx1ZSkgfHxcbiAgICAgICAgaXNCc29uVHlwZSh2YWx1ZSwgJ09iamVjdElkJykgfHwgIXV0aWxzLmlzT2JqZWN0KHZhbHVlKSkge1xuICAgICAgdmFsdWUgPSB7IF9pZDogdmFsdWUgfTtcbiAgICB9XG5cbiAgICBpZiAodmFsdWUgJiZcbiAgICAgICAgQ29uc3RydWN0b3IuZGlzY3JpbWluYXRvcnMgJiZcbiAgICAgICAgQ29uc3RydWN0b3Iuc2NoZW1hICYmXG4gICAgICAgIENvbnN0cnVjdG9yLnNjaGVtYS5vcHRpb25zICYmXG4gICAgICAgIENvbnN0cnVjdG9yLnNjaGVtYS5vcHRpb25zLmRpc2NyaW1pbmF0b3JLZXkpIHtcbiAgICAgIGlmICh0eXBlb2YgdmFsdWVbQ29uc3RydWN0b3Iuc2NoZW1hLm9wdGlvbnMuZGlzY3JpbWluYXRvcktleV0gPT09ICdzdHJpbmcnICYmXG4gICAgICAgICAgQ29uc3RydWN0b3IuZGlzY3JpbWluYXRvcnNbdmFsdWVbQ29uc3RydWN0b3Iuc2NoZW1hLm9wdGlvbnMuZGlzY3JpbWluYXRvcktleV1dKSB7XG4gICAgICAgIENvbnN0cnVjdG9yID0gQ29uc3RydWN0b3IuZGlzY3JpbWluYXRvcnNbdmFsdWVbQ29uc3RydWN0b3Iuc2NoZW1hLm9wdGlvbnMuZGlzY3JpbWluYXRvcktleV1dO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc3QgY29uc3RydWN0b3JCeVZhbHVlID0gZ2V0RGlzY3JpbWluYXRvckJ5VmFsdWUoQ29uc3RydWN0b3IuZGlzY3JpbWluYXRvcnMsIHZhbHVlW0NvbnN0cnVjdG9yLnNjaGVtYS5vcHRpb25zLmRpc2NyaW1pbmF0b3JLZXldKTtcbiAgICAgICAgaWYgKGNvbnN0cnVjdG9yQnlWYWx1ZSkge1xuICAgICAgICAgIENvbnN0cnVjdG9yID0gY29uc3RydWN0b3JCeVZhbHVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKENvbnN0cnVjdG9yLiRpc01vbmdvb3NlRG9jdW1lbnRBcnJheSkge1xuICAgICAgcmV0dXJuIENvbnN0cnVjdG9yLmNhc3QodmFsdWUsIHRoaXMsIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCBpbmRleCk7XG4gICAgfVxuICAgIGNvbnN0IHJldCA9IG5ldyBDb25zdHJ1Y3Rvcih2YWx1ZSwgdGhpcywgb3B0aW9ucywgdW5kZWZpbmVkLCBpbmRleCk7XG4gICAgcmV0LmlzTmV3ID0gdHJ1ZTtcbiAgICByZXR1cm4gcmV0O1xuICB9LFxuXG4gIC8qKlxuICAgKiBTZWFyY2hlcyBhcnJheSBpdGVtcyBmb3IgdGhlIGZpcnN0IGRvY3VtZW50IHdpdGggYSBtYXRjaGluZyBfaWQuXG4gICAqXG4gICAqICMjIyMgRXhhbXBsZTpcbiAgICpcbiAgICogICAgIGNvbnN0IGVtYmVkZGVkRG9jID0gbS5hcnJheS5pZChzb21lX2lkKTtcbiAgICpcbiAgICogQHJldHVybiB7RW1iZWRkZWREb2N1bWVudHxudWxsfSB0aGUgc3ViZG9jdW1lbnQgb3IgbnVsbCBpZiBub3QgZm91bmQuXG4gICAqIEBwYXJhbSB7T2JqZWN0SWR8U3RyaW5nfE51bWJlcnxCdWZmZXJ9IGlkXG4gICAqIEBUT0RPIGNhc3QgdG8gdGhlIF9pZCBiYXNlZCBvbiBzY2hlbWEgZm9yIHByb3BlciBjb21wYXJpc29uXG4gICAqIEBtZXRob2QgaWRcbiAgICogQGFwaSBwdWJsaWNcbiAgICogQG1lbWJlck9mIE1vbmdvb3NlRG9jdW1lbnRBcnJheVxuICAgKi9cblxuICBpZChpZCkge1xuICAgIGxldCBjYXN0ZWQ7XG4gICAgbGV0IHNpZDtcbiAgICBsZXQgX2lkO1xuXG4gICAgdHJ5IHtcbiAgICAgIGNhc3RlZCA9IGNhc3RPYmplY3RJZChpZCkudG9TdHJpbmcoKTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICBjYXN0ZWQgPSBudWxsO1xuICAgIH1cblxuICAgIGZvciAoY29uc3QgdmFsIG9mIHRoaXMpIHtcbiAgICAgIGlmICghdmFsKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuXG4gICAgICBfaWQgPSB2YWwuZ2V0KCdfaWQnKTtcblxuICAgICAgaWYgKF9pZCA9PT0gbnVsbCB8fCB0eXBlb2YgX2lkID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH0gZWxzZSBpZiAoX2lkIGluc3RhbmNlb2YgRG9jdW1lbnQpIHtcbiAgICAgICAgc2lkIHx8IChzaWQgPSBTdHJpbmcoaWQpKTtcbiAgICAgICAgaWYgKHNpZCA9PSBfaWQuX2lkKSB7XG4gICAgICAgICAgcmV0dXJuIHZhbDtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmICghaXNCc29uVHlwZShpZCwgJ09iamVjdElkJykgJiYgIWlzQnNvblR5cGUoX2lkLCAnT2JqZWN0SWQnKSkge1xuICAgICAgICBpZiAoaWQgPT0gX2lkIHx8IHV0aWxzLmRlZXBFcXVhbChpZCwgX2lkKSkge1xuICAgICAgICAgIHJldHVybiB2YWw7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoY2FzdGVkID09IF9pZCkge1xuICAgICAgICByZXR1cm4gdmFsO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBudWxsO1xuICB9LFxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGEgbmF0aXZlIGpzIEFycmF5IG9mIHBsYWluIGpzIG9iamVjdHNcbiAgICpcbiAgICogIyMjIyBOb3RlOlxuICAgKlxuICAgKiBfRWFjaCBzdWItZG9jdW1lbnQgaXMgY29udmVydGVkIHRvIGEgcGxhaW4gb2JqZWN0IGJ5IGNhbGxpbmcgaXRzIGAjdG9PYmplY3RgIG1ldGhvZC5fXG4gICAqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gb3B0aW9uYWwgb3B0aW9ucyB0byBwYXNzIHRvIGVhY2ggZG9jdW1lbnRzIGB0b09iamVjdGAgbWV0aG9kIGNhbGwgZHVyaW5nIGNvbnZlcnNpb25cbiAgICogQHJldHVybiB7QXJyYXl9XG4gICAqIEBtZXRob2QgdG9PYmplY3RcbiAgICogQGFwaSBwdWJsaWNcbiAgICogQG1lbWJlck9mIE1vbmdvb3NlRG9jdW1lbnRBcnJheVxuICAgKi9cblxuICB0b09iamVjdChvcHRpb25zKSB7XG4gICAgLy8gYFtdLmNvbmNhdGAgY29lcmNlcyB0aGUgcmV0dXJuIHZhbHVlIGludG8gYSB2YW5pbGxhIEpTIGFycmF5LCByYXRoZXJcbiAgICAvLyB0aGFuIGEgTW9uZ29vc2UgYXJyYXkuXG4gICAgcmV0dXJuIFtdLmNvbmNhdCh0aGlzLm1hcChmdW5jdGlvbihkb2MpIHtcbiAgICAgIGlmIChkb2MgPT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cbiAgICAgIGlmICh0eXBlb2YgZG9jLnRvT2JqZWN0ICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHJldHVybiBkb2M7XG4gICAgICB9XG4gICAgICByZXR1cm4gZG9jLnRvT2JqZWN0KG9wdGlvbnMpO1xuICAgIH0pKTtcbiAgfSxcblxuICAkdG9PYmplY3QoKSB7XG4gICAgcmV0dXJuIHRoaXMuY29uc3RydWN0b3IucHJvdG90eXBlLnRvT2JqZWN0LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIFdyYXBzIFtgQXJyYXkjcHVzaGBdKGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL0FycmF5L3B1c2gpIHdpdGggcHJvcGVyIGNoYW5nZSB0cmFja2luZy5cbiAgICpcbiAgICogQHBhcmFtIHsuLi5PYmplY3R9IFthcmdzXVxuICAgKiBAYXBpIHB1YmxpY1xuICAgKiBAbWV0aG9kIHB1c2hcbiAgICogQG1lbWJlck9mIE1vbmdvb3NlRG9jdW1lbnRBcnJheVxuICAgKi9cblxuICBwdXNoKCkge1xuICAgIGNvbnN0IHJldCA9IEFycmF5TWV0aG9kcy5wdXNoLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG5cbiAgICBfdXBkYXRlUGFyZW50UG9wdWxhdGVkKHRoaXMpO1xuXG4gICAgcmV0dXJuIHJldDtcbiAgfSxcblxuICAvKipcbiAgICogUHVsbHMgaXRlbXMgZnJvbSB0aGUgYXJyYXkgYXRvbWljYWxseS5cbiAgICpcbiAgICogQHBhcmFtIHsuLi5PYmplY3R9IFthcmdzXVxuICAgKiBAYXBpIHB1YmxpY1xuICAgKiBAbWV0aG9kIHB1bGxcbiAgICogQG1lbWJlck9mIE1vbmdvb3NlRG9jdW1lbnRBcnJheVxuICAgKi9cblxuICBwdWxsKCkge1xuICAgIGNvbnN0IHJldCA9IEFycmF5TWV0aG9kcy5wdWxsLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG5cbiAgICBfdXBkYXRlUGFyZW50UG9wdWxhdGVkKHRoaXMpO1xuXG4gICAgcmV0dXJuIHJldDtcbiAgfSxcblxuICAvKipcbiAgICogV3JhcHMgW2BBcnJheSNzaGlmdGBdKGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL0FycmF5L3Vuc2hpZnQpIHdpdGggcHJvcGVyIGNoYW5nZSB0cmFja2luZy5cbiAgICogQGFwaSBwcml2YXRlXG4gICAqL1xuXG4gIHNoaWZ0KCkge1xuICAgIGNvbnN0IHJldCA9IEFycmF5TWV0aG9kcy5zaGlmdC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuXG4gICAgX3VwZGF0ZVBhcmVudFBvcHVsYXRlZCh0aGlzKTtcblxuICAgIHJldHVybiByZXQ7XG4gIH0sXG5cbiAgLyoqXG4gICAqIFdyYXBzIFtgQXJyYXkjc3BsaWNlYF0oaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4vSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvQXJyYXkvc3BsaWNlKSB3aXRoIHByb3BlciBjaGFuZ2UgdHJhY2tpbmcgYW5kIGNhc3RpbmcuXG4gICAqIEBhcGkgcHJpdmF0ZVxuICAgKi9cblxuICBzcGxpY2UoKSB7XG4gICAgY29uc3QgcmV0ID0gQXJyYXlNZXRob2RzLnNwbGljZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuXG4gICAgX3VwZGF0ZVBhcmVudFBvcHVsYXRlZCh0aGlzKTtcblxuICAgIHJldHVybiByZXQ7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEhlbHBlciBmb3IgY29uc29sZS5sb2dcbiAgICpcbiAgICogQG1ldGhvZCBpbnNwZWN0XG4gICAqIEBhcGkgcHVibGljXG4gICAqIEBtZW1iZXJPZiBNb25nb29zZURvY3VtZW50QXJyYXlcbiAgICovXG5cbiAgaW5zcGVjdCgpIHtcbiAgICByZXR1cm4gdGhpcy50b09iamVjdCgpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBDcmVhdGVzIGEgc3ViZG9jdW1lbnQgY2FzdGVkIHRvIHRoaXMgc2NoZW1hLlxuICAgKlxuICAgKiBUaGlzIGlzIHRoZSBzYW1lIHN1YmRvY3VtZW50IGNvbnN0cnVjdG9yIHVzZWQgZm9yIGNhc3RpbmcuXG4gICAqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvYmogdGhlIHZhbHVlIHRvIGNhc3QgdG8gdGhpcyBhcnJheXMgU3ViRG9jdW1lbnQgc2NoZW1hXG4gICAqIEBtZXRob2QgY3JlYXRlXG4gICAqIEBhcGkgcHVibGljXG4gICAqIEBtZW1iZXJPZiBNb25nb29zZURvY3VtZW50QXJyYXlcbiAgICovXG5cbiAgY3JlYXRlKG9iaikge1xuICAgIGxldCBDb25zdHJ1Y3RvciA9IHRoaXNbYXJyYXlTY2hlbWFTeW1ib2xdLmNhc3RlckNvbnN0cnVjdG9yO1xuICAgIGlmIChvYmogJiZcbiAgICAgICAgQ29uc3RydWN0b3IuZGlzY3JpbWluYXRvcnMgJiZcbiAgICAgICAgQ29uc3RydWN0b3Iuc2NoZW1hICYmXG4gICAgICAgIENvbnN0cnVjdG9yLnNjaGVtYS5vcHRpb25zICYmXG4gICAgICAgIENvbnN0cnVjdG9yLnNjaGVtYS5vcHRpb25zLmRpc2NyaW1pbmF0b3JLZXkpIHtcbiAgICAgIGlmICh0eXBlb2Ygb2JqW0NvbnN0cnVjdG9yLnNjaGVtYS5vcHRpb25zLmRpc2NyaW1pbmF0b3JLZXldID09PSAnc3RyaW5nJyAmJlxuICAgICAgICAgIENvbnN0cnVjdG9yLmRpc2NyaW1pbmF0b3JzW29ialtDb25zdHJ1Y3Rvci5zY2hlbWEub3B0aW9ucy5kaXNjcmltaW5hdG9yS2V5XV0pIHtcbiAgICAgICAgQ29uc3RydWN0b3IgPSBDb25zdHJ1Y3Rvci5kaXNjcmltaW5hdG9yc1tvYmpbQ29uc3RydWN0b3Iuc2NoZW1hLm9wdGlvbnMuZGlzY3JpbWluYXRvcktleV1dO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc3QgY29uc3RydWN0b3JCeVZhbHVlID0gZ2V0RGlzY3JpbWluYXRvckJ5VmFsdWUoQ29uc3RydWN0b3IuZGlzY3JpbWluYXRvcnMsIG9ialtDb25zdHJ1Y3Rvci5zY2hlbWEub3B0aW9ucy5kaXNjcmltaW5hdG9yS2V5XSk7XG4gICAgICAgIGlmIChjb25zdHJ1Y3RvckJ5VmFsdWUpIHtcbiAgICAgICAgICBDb25zdHJ1Y3RvciA9IGNvbnN0cnVjdG9yQnlWYWx1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBuZXcgQ29uc3RydWN0b3Iob2JqLCB0aGlzKTtcbiAgfSxcblxuICAvKiFcbiAgICogaWdub3JlXG4gICAqL1xuXG4gIG5vdGlmeShldmVudCkge1xuICAgIGNvbnN0IF90aGlzID0gdGhpcztcbiAgICByZXR1cm4gZnVuY3Rpb24gbm90aWZ5KHZhbCwgX2Fycikge1xuICAgICAgX2FyciA9IF9hcnIgfHwgX3RoaXM7XG4gICAgICBsZXQgaSA9IF9hcnIubGVuZ3RoO1xuICAgICAgd2hpbGUgKGktLSkge1xuICAgICAgICBpZiAoX2FycltpXSA9PSBudWxsKSB7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgc3dpdGNoIChldmVudCkge1xuICAgICAgICAgIC8vIG9ubHkgc3dhcCBmb3Igc2F2ZSBldmVudCBmb3Igbm93LCB3ZSBtYXkgY2hhbmdlIHRoaXMgdG8gYWxsIGV2ZW50IHR5cGVzIGxhdGVyXG4gICAgICAgICAgY2FzZSAnc2F2ZSc6XG4gICAgICAgICAgICB2YWwgPSBfdGhpc1tpXTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAvLyBOTy1PUFxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodXRpbHMuaXNNb25nb29zZUFycmF5KF9hcnJbaV0pKSB7XG4gICAgICAgICAgbm90aWZ5KHZhbCwgX2FycltpXSk7XG4gICAgICAgIH0gZWxzZSBpZiAoX2FycltpXSkge1xuICAgICAgICAgIF9hcnJbaV0uZW1pdChldmVudCwgdmFsKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH07XG4gIH0sXG5cbiAgc2V0KGksIHZhbCwgc2tpcE1vZGlmaWVkKSB7XG4gICAgY29uc3QgYXJyID0gdGhpcy5fX2FycmF5O1xuICAgIGlmIChza2lwTW9kaWZpZWQpIHtcbiAgICAgIGFycltpXSA9IHZhbDtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICBjb25zdCB2YWx1ZSA9IG1ldGhvZHMuX2Nhc3QuY2FsbCh0aGlzLCB2YWwsIGkpO1xuICAgIG1ldGhvZHMuX21hcmtNb2RpZmllZC5jYWxsKHRoaXMsIGkpO1xuICAgIGFycltpXSA9IHZhbHVlO1xuICAgIHJldHVybiB0aGlzO1xuICB9LFxuXG4gIF9tYXJrTW9kaWZpZWQoZWxlbSwgZW1iZWRkZWRQYXRoKSB7XG4gICAgY29uc3QgcGFyZW50ID0gdGhpc1thcnJheVBhcmVudFN5bWJvbF07XG4gICAgbGV0IGRpcnR5UGF0aDtcblxuICAgIGlmIChwYXJlbnQpIHtcbiAgICAgIGRpcnR5UGF0aCA9IHRoaXNbYXJyYXlQYXRoU3ltYm9sXTtcblxuICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGgpIHtcbiAgICAgICAgaWYgKGVtYmVkZGVkUGF0aCAhPSBudWxsKSB7XG4gICAgICAgICAgLy8gYW4gZW1iZWRkZWQgZG9jIGJ1YmJsZWQgdXAgdGhlIGNoYW5nZVxuICAgICAgICAgIGNvbnN0IGluZGV4ID0gZWxlbS5fX2luZGV4O1xuICAgICAgICAgIGRpcnR5UGF0aCA9IGRpcnR5UGF0aCArICcuJyArIGluZGV4ICsgJy4nICsgZW1iZWRkZWRQYXRoO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIGRpcmVjdGx5IHNldCBhbiBpbmRleFxuICAgICAgICAgIGRpcnR5UGF0aCA9IGRpcnR5UGF0aCArICcuJyArIGVsZW07XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKGRpcnR5UGF0aCAhPSBudWxsICYmIGRpcnR5UGF0aC5lbmRzV2l0aCgnLiQnKSkge1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH1cblxuICAgICAgcGFyZW50Lm1hcmtNb2RpZmllZChkaXJ0eVBhdGgsIGFyZ3VtZW50cy5sZW5ndGggIT09IDAgPyBlbGVtIDogcGFyZW50KTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfVxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBtZXRob2RzO1xuXG4vKipcbiAqIElmIHRoaXMgaXMgYSBkb2N1bWVudCBhcnJheSwgZWFjaCBlbGVtZW50IG1heSBjb250YWluIHNpbmdsZVxuICogcG9wdWxhdGVkIHBhdGhzLCBzbyB3ZSBuZWVkIHRvIG1vZGlmeSB0aGUgdG9wLWxldmVsIGRvY3VtZW50J3NcbiAqIHBvcHVsYXRlZCBjYWNoZS4gU2VlIGdoLTgyNDcsIGdoLTgyNjUuXG4gKiBAcGFyYW0ge0FycmF5fSBhcnJcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmZ1bmN0aW9uIF91cGRhdGVQYXJlbnRQb3B1bGF0ZWQoYXJyKSB7XG4gIGNvbnN0IHBhcmVudCA9IGFyclthcnJheVBhcmVudFN5bWJvbF07XG4gIGlmICghcGFyZW50IHx8IHBhcmVudC4kX18ucG9wdWxhdGVkID09IG51bGwpIHJldHVybjtcblxuICBjb25zdCBwb3B1bGF0ZWRQYXRocyA9IE9iamVjdC5rZXlzKHBhcmVudC4kX18ucG9wdWxhdGVkKS5cbiAgICBmaWx0ZXIocCA9PiBwLnN0YXJ0c1dpdGgoYXJyW2FycmF5UGF0aFN5bWJvbF0gKyAnLicpKTtcblxuICBmb3IgKGNvbnN0IHBhdGggb2YgcG9wdWxhdGVkUGF0aHMpIHtcbiAgICBjb25zdCByZW1uYW50ID0gcGF0aC5zbGljZSgoYXJyW2FycmF5UGF0aFN5bWJvbF0gKyAnLicpLmxlbmd0aCk7XG4gICAgaWYgKCFBcnJheS5pc0FycmF5KHBhcmVudC4kX18ucG9wdWxhdGVkW3BhdGhdLnZhbHVlKSkge1xuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgcGFyZW50LiRfXy5wb3B1bGF0ZWRbcGF0aF0udmFsdWUgPSBhcnIubWFwKHZhbCA9PiB2YWwuJHBvcHVsYXRlZChyZW1uYW50KSk7XG4gIH1cbn1cbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/mongoose/lib/types/documentArray/methods/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/mongoose/lib/types/index.js":
/*!**************************************************!*\
  !*** ./node_modules/mongoose/lib/types/index.js ***!
  \**************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n/*!\n * Module exports.\n */\n\n\n\nexports.Array = __webpack_require__(/*! ./array */ \"(ssr)/./node_modules/mongoose/lib/types/array/index.js\");\nexports.Buffer = __webpack_require__(/*! ./buffer */ \"(ssr)/./node_modules/mongoose/lib/types/buffer.js\");\n\nexports.Document = // @deprecate\nexports.Embedded = __webpack_require__(/*! ./arraySubdocument */ \"(ssr)/./node_modules/mongoose/lib/types/arraySubdocument.js\");\n\nexports.DocumentArray = __webpack_require__(/*! ./documentArray */ \"(ssr)/./node_modules/mongoose/lib/types/documentArray/index.js\");\nexports.Decimal128 = __webpack_require__(/*! ./decimal128 */ \"(ssr)/./node_modules/mongoose/lib/types/decimal128.js\");\nexports.ObjectId = __webpack_require__(/*! ./objectid */ \"(ssr)/./node_modules/mongoose/lib/types/objectid.js\");\n\nexports.Map = __webpack_require__(/*! ./map */ \"(ssr)/./node_modules/mongoose/lib/types/map.js\");\n\nexports.Subdocument = __webpack_require__(/*! ./subdocument */ \"(ssr)/./node_modules/mongoose/lib/types/subdocument.js\");\n\nexports.UUID = __webpack_require__(/*! ./uuid */ \"(ssr)/./node_modules/mongoose/lib/types/uuid.js\");\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbW9uZ29vc2UvbGliL3R5cGVzL2luZGV4LmpzIiwibWFwcGluZ3MiOiI7QUFDQTtBQUNBO0FBQ0E7O0FBRWE7O0FBRWIsNEdBQWtDO0FBQ2xDLHlHQUFvQzs7QUFFcEMsZ0JBQWdCO0FBQ2hCLCtIQUFnRDs7QUFFaEQsb0lBQWtEO0FBQ2xELHFIQUE0QztBQUM1QywrR0FBd0M7O0FBRXhDLGdHQUE4Qjs7QUFFOUIsd0hBQThDOztBQUU5QyxtR0FBZ0MiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9hcHAxLy4vbm9kZV9tb2R1bGVzL21vbmdvb3NlL2xpYi90eXBlcy9pbmRleC5qcz9lMTRjIl0sInNvdXJjZXNDb250ZW50IjpbIlxuLyohXG4gKiBNb2R1bGUgZXhwb3J0cy5cbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbmV4cG9ydHMuQXJyYXkgPSByZXF1aXJlKCcuL2FycmF5Jyk7XG5leHBvcnRzLkJ1ZmZlciA9IHJlcXVpcmUoJy4vYnVmZmVyJyk7XG5cbmV4cG9ydHMuRG9jdW1lbnQgPSAvLyBAZGVwcmVjYXRlXG5leHBvcnRzLkVtYmVkZGVkID0gcmVxdWlyZSgnLi9hcnJheVN1YmRvY3VtZW50Jyk7XG5cbmV4cG9ydHMuRG9jdW1lbnRBcnJheSA9IHJlcXVpcmUoJy4vZG9jdW1lbnRBcnJheScpO1xuZXhwb3J0cy5EZWNpbWFsMTI4ID0gcmVxdWlyZSgnLi9kZWNpbWFsMTI4Jyk7XG5leHBvcnRzLk9iamVjdElkID0gcmVxdWlyZSgnLi9vYmplY3RpZCcpO1xuXG5leHBvcnRzLk1hcCA9IHJlcXVpcmUoJy4vbWFwJyk7XG5cbmV4cG9ydHMuU3ViZG9jdW1lbnQgPSByZXF1aXJlKCcuL3N1YmRvY3VtZW50Jyk7XG5cbmV4cG9ydHMuVVVJRCA9IHJlcXVpcmUoJy4vdXVpZCcpO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/mongoose/lib/types/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/mongoose/lib/types/map.js":
/*!************************************************!*\
  !*** ./node_modules/mongoose/lib/types/map.js ***!
  \************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\n\nconst Mixed = __webpack_require__(/*! ../schema/mixed */ \"(ssr)/./node_modules/mongoose/lib/schema/mixed.js\");\nconst MongooseError = __webpack_require__(/*! ../error/mongooseError */ \"(ssr)/./node_modules/mongoose/lib/error/mongooseError.js\");\nconst clone = __webpack_require__(/*! ../helpers/clone */ \"(ssr)/./node_modules/mongoose/lib/helpers/clone.js\");\nconst deepEqual = (__webpack_require__(/*! ../utils */ \"(ssr)/./node_modules/mongoose/lib/utils.js\").deepEqual);\nconst getConstructorName = __webpack_require__(/*! ../helpers/getConstructorName */ \"(ssr)/./node_modules/mongoose/lib/helpers/getConstructorName.js\");\nconst handleSpreadDoc = __webpack_require__(/*! ../helpers/document/handleSpreadDoc */ \"(ssr)/./node_modules/mongoose/lib/helpers/document/handleSpreadDoc.js\");\nconst util = __webpack_require__(/*! util */ \"util\");\nconst specialProperties = __webpack_require__(/*! ../helpers/specialProperties */ \"(ssr)/./node_modules/mongoose/lib/helpers/specialProperties.js\");\nconst isBsonType = __webpack_require__(/*! ../helpers/isBsonType */ \"(ssr)/./node_modules/mongoose/lib/helpers/isBsonType.js\");\n\nconst populateModelSymbol = (__webpack_require__(/*! ../helpers/symbols */ \"(ssr)/./node_modules/mongoose/lib/helpers/symbols.js\").populateModelSymbol);\n\n/*!\n * ignore\n */\n\nclass MongooseMap extends Map {\n  constructor(v, path, doc, schemaType) {\n    if (getConstructorName(v) === 'Object') {\n      v = Object.keys(v).reduce((arr, key) => arr.concat([[key, v[key]]]), []);\n    }\n    super(v);\n    this.$__parent = doc != null && doc.$__ != null ? doc : null;\n    this.$__path = path;\n    this.$__schemaType = schemaType == null ? new Mixed(path) : schemaType;\n\n    this.$__runDeferred();\n  }\n\n  $init(key, value) {\n    checkValidKey(key);\n\n    super.set(key, value);\n\n    if (value != null && value.$isSingleNested) {\n      value.$basePath = this.$__path + '.' + key;\n    }\n  }\n\n  $__set(key, value) {\n    super.set(key, value);\n  }\n\n  /**\n   * Overwrites native Map's `get()` function to support Mongoose getters.\n   *\n   * @api public\n   * @method get\n   * @memberOf Map\n   */\n\n  get(key, options) {\n    if (isBsonType(key, 'ObjectId')) {\n      key = key.toString();\n    }\n\n    options = options || {};\n    if (options.getters === false) {\n      return super.get(key);\n    }\n    return this.$__schemaType.applyGetters(super.get(key), this.$__parent);\n  }\n\n  /**\n   * Overwrites native Map's `set()` function to support setters, `populate()`,\n   * and change tracking. Note that Mongoose maps _only_ support strings and\n   * ObjectIds as keys.\n   *\n   * #### Example:\n   *\n   *     doc.myMap.set('test', 42); // works\n   *     doc.myMap.set({ obj: 42 }, 42); // Throws \"Mongoose maps only support string keys\"\n   *\n   * @api public\n   * @method set\n   * @memberOf Map\n   */\n\n  set(key, value) {\n    if (isBsonType(key, 'ObjectId')) {\n      key = key.toString();\n    }\n\n    checkValidKey(key);\n    value = handleSpreadDoc(value);\n\n    // Weird, but because you can't assign to `this` before calling `super()`\n    // you can't get access to `$__schemaType` to cast in the initial call to\n    // `set()` from the `super()` constructor.\n\n    if (this.$__schemaType == null) {\n      this.$__deferred = this.$__deferred || [];\n      this.$__deferred.push({ key: key, value: value });\n      return;\n    }\n\n    let _fullPath;\n    const parent = this.$__parent;\n    const populated = parent != null && parent.$__ && parent.$__.populated ?\n      parent.$populated(fullPath.call(this), true) || parent.$populated(this.$__path, true) :\n      null;\n    const priorVal = this.get(key);\n\n    if (populated != null) {\n      if (this.$__schemaType.$isSingleNested) {\n        throw new MongooseError(\n          'Cannot manually populate single nested subdoc underneath Map ' +\n          `at path \"${this.$__path}\". Try using an array instead of a Map.`\n        );\n      }\n      if (Array.isArray(value) && this.$__schemaType.$isMongooseArray) {\n        value = value.map(v => {\n          if (v.$__ == null) {\n            v = new populated.options[populateModelSymbol](v);\n          }\n          // Doesn't support single nested \"in-place\" populate\n          v.$__.wasPopulated = { value: v._id };\n          return v;\n        });\n      } else {\n        if (value.$__ == null) {\n          value = new populated.options[populateModelSymbol](value);\n        }\n        // Doesn't support single nested \"in-place\" populate\n        value.$__.wasPopulated = { value: value._id };\n      }\n    } else {\n      try {\n        const options = this.$__schemaType.$isMongooseDocumentArray || this.$__schemaType.$isSingleNested ?\n          { path: fullPath.call(this) } :\n          null;\n        value = this.$__schemaType.applySetters(\n          value,\n          this.$__parent,\n          false,\n          this.get(key),\n          options\n        );\n      } catch (error) {\n        if (this.$__parent != null && this.$__parent.$__ != null) {\n          this.$__parent.invalidate(fullPath.call(this), error);\n          return;\n        }\n        throw error;\n      }\n    }\n\n    super.set(key, value);\n\n    if (parent != null && parent.$__ != null && !deepEqual(value, priorVal)) {\n      parent.markModified(fullPath.call(this));\n    }\n\n    // Delay calculating full path unless absolutely necessary, because string\n    // concatenation is a bottleneck re: #13171\n    function fullPath() {\n      if (_fullPath) {\n        return _fullPath;\n      }\n      _fullPath = this.$__path + '.' + key;\n      return _fullPath;\n    }\n  }\n\n  /**\n   * Overwrites native Map's `clear()` function to support change tracking.\n   *\n   * @api public\n   * @method clear\n   * @memberOf Map\n   */\n\n  clear() {\n    super.clear();\n    const parent = this.$__parent;\n    if (parent != null) {\n      parent.markModified(this.$__path);\n    }\n  }\n\n  /**\n   * Overwrites native Map's `delete()` function to support change tracking.\n   *\n   * @api public\n   * @method delete\n   * @memberOf Map\n   */\n\n  delete(key) {\n    if (isBsonType(key, 'ObjectId')) {\n      key = key.toString();\n    }\n\n    this.set(key, undefined);\n    return super.delete(key);\n  }\n\n  /**\n   * Converts this map to a native JavaScript Map so the MongoDB driver can serialize it.\n   *\n   * @api public\n   * @method toBSON\n   * @memberOf Map\n   */\n\n  toBSON() {\n    return new Map(this);\n  }\n\n  toObject(options) {\n    if (options && options.flattenMaps) {\n      const ret = {};\n      const keys = this.keys();\n      for (const key of keys) {\n        ret[key] = clone(this.get(key), options);\n      }\n      return ret;\n    }\n\n    return new Map(this);\n  }\n\n  $toObject() {\n    return this.constructor.prototype.toObject.apply(this, arguments);\n  }\n\n  /**\n   * Converts this map to a native JavaScript Map for `JSON.stringify()`. Set\n   * the `flattenMaps` option to convert this map to a POJO instead.\n   *\n   * #### Example:\n   *\n   *     doc.myMap.toJSON() instanceof Map; // true\n   *     doc.myMap.toJSON({ flattenMaps: true }) instanceof Map; // false\n   *\n   * @api public\n   * @method toJSON\n   * @param {Object} [options]\n   * @param {Boolean} [options.flattenMaps=false] set to `true` to convert the map to a POJO rather than a native JavaScript map\n   * @memberOf Map\n   */\n\n  toJSON(options) {\n    if (typeof (options && options.flattenMaps) === 'boolean' ? options.flattenMaps : true) {\n      const ret = {};\n      const keys = this.keys();\n      for (const key of keys) {\n        ret[key] = clone(this.get(key), options);\n      }\n      return ret;\n    }\n\n    return new Map(this);\n  }\n\n  inspect() {\n    return new Map(this);\n  }\n\n  $__runDeferred() {\n    if (!this.$__deferred) {\n      return;\n    }\n\n    for (const keyValueObject of this.$__deferred) {\n      this.set(keyValueObject.key, keyValueObject.value);\n    }\n\n    this.$__deferred = null;\n  }\n}\n\nif (util.inspect.custom) {\n  Object.defineProperty(MongooseMap.prototype, util.inspect.custom, {\n    enumerable: false,\n    writable: false,\n    configurable: false,\n    value: MongooseMap.prototype.inspect\n  });\n}\n\nObject.defineProperty(MongooseMap.prototype, '$__set', {\n  enumerable: false,\n  writable: true,\n  configurable: false\n});\n\nObject.defineProperty(MongooseMap.prototype, '$__parent', {\n  enumerable: false,\n  writable: true,\n  configurable: false\n});\n\nObject.defineProperty(MongooseMap.prototype, '$__path', {\n  enumerable: false,\n  writable: true,\n  configurable: false\n});\n\nObject.defineProperty(MongooseMap.prototype, '$__schemaType', {\n  enumerable: false,\n  writable: true,\n  configurable: false\n});\n\n/**\n * Set to `true` for all Mongoose map instances\n *\n * @api public\n * @property $isMongooseMap\n * @memberOf MongooseMap\n * @instance\n */\n\nObject.defineProperty(MongooseMap.prototype, '$isMongooseMap', {\n  enumerable: false,\n  writable: false,\n  configurable: false,\n  value: true\n});\n\nObject.defineProperty(MongooseMap.prototype, '$__deferredCalls', {\n  enumerable: false,\n  writable: false,\n  configurable: false,\n  value: true\n});\n\n/**\n * Since maps are stored as objects under the hood, keys must be strings\n * and can't contain any invalid characters\n * @param {String} key\n * @api private\n */\n\nfunction checkValidKey(key) {\n  const keyType = typeof key;\n  if (keyType !== 'string') {\n    throw new TypeError(`Mongoose maps only support string keys, got ${keyType}`);\n  }\n  if (key.startsWith('$')) {\n    throw new Error(`Mongoose maps do not support keys that start with \"$\", got \"${key}\"`);\n  }\n  if (key.includes('.')) {\n    throw new Error(`Mongoose maps do not support keys that contain \".\", got \"${key}\"`);\n  }\n  if (specialProperties.has(key)) {\n    throw new Error(`Mongoose maps do not support reserved key name \"${key}\"`);\n  }\n}\n\nmodule.exports = MongooseMap;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbW9uZ29vc2UvbGliL3R5cGVzL21hcC5qcyIsIm1hcHBpbmdzIjoiQUFBYTs7QUFFYixjQUFjLG1CQUFPLENBQUMsMEVBQWlCO0FBQ3ZDLHNCQUFzQixtQkFBTyxDQUFDLHdGQUF3QjtBQUN0RCxjQUFjLG1CQUFPLENBQUMsNEVBQWtCO0FBQ3hDLGtCQUFrQiw2RkFBNkI7QUFDL0MsMkJBQTJCLG1CQUFPLENBQUMsc0dBQStCO0FBQ2xFLHdCQUF3QixtQkFBTyxDQUFDLGtIQUFxQztBQUNyRSxhQUFhLG1CQUFPLENBQUMsa0JBQU07QUFDM0IsMEJBQTBCLG1CQUFPLENBQUMsb0dBQThCO0FBQ2hFLG1CQUFtQixtQkFBTyxDQUFDLHNGQUF1Qjs7QUFFbEQsNEJBQTRCLDJIQUFpRDs7QUFFN0U7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQztBQUNwQyx5QkFBeUIsU0FBUyxPQUFPO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLDhCQUE4Qix3QkFBd0I7QUFDdEQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsYUFBYTtBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDO0FBQ2pDO0FBQ0EsU0FBUztBQUNULFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQztBQUNuQztBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsWUFBWSw0QkFBNEI7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNENBQTRDO0FBQzVDLDRCQUE0QixtQkFBbUIsa0JBQWtCO0FBQ2pFO0FBQ0E7QUFDQTtBQUNBLGFBQWEsUUFBUTtBQUNyQixhQUFhLFNBQVM7QUFDdEI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsdUVBQXVFLFFBQVE7QUFDL0U7QUFDQTtBQUNBLG1GQUFtRixJQUFJO0FBQ3ZGO0FBQ0E7QUFDQSxnRkFBZ0YsSUFBSTtBQUNwRjtBQUNBO0FBQ0EsdUVBQXVFLElBQUk7QUFDM0U7QUFDQTs7QUFFQSIsInNvdXJjZXMiOlsid2VicGFjazovL2FwcDEvLi9ub2RlX21vZHVsZXMvbW9uZ29vc2UvbGliL3R5cGVzL21hcC5qcz8wMDU3Il0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxuY29uc3QgTWl4ZWQgPSByZXF1aXJlKCcuLi9zY2hlbWEvbWl4ZWQnKTtcbmNvbnN0IE1vbmdvb3NlRXJyb3IgPSByZXF1aXJlKCcuLi9lcnJvci9tb25nb29zZUVycm9yJyk7XG5jb25zdCBjbG9uZSA9IHJlcXVpcmUoJy4uL2hlbHBlcnMvY2xvbmUnKTtcbmNvbnN0IGRlZXBFcXVhbCA9IHJlcXVpcmUoJy4uL3V0aWxzJykuZGVlcEVxdWFsO1xuY29uc3QgZ2V0Q29uc3RydWN0b3JOYW1lID0gcmVxdWlyZSgnLi4vaGVscGVycy9nZXRDb25zdHJ1Y3Rvck5hbWUnKTtcbmNvbnN0IGhhbmRsZVNwcmVhZERvYyA9IHJlcXVpcmUoJy4uL2hlbHBlcnMvZG9jdW1lbnQvaGFuZGxlU3ByZWFkRG9jJyk7XG5jb25zdCB1dGlsID0gcmVxdWlyZSgndXRpbCcpO1xuY29uc3Qgc3BlY2lhbFByb3BlcnRpZXMgPSByZXF1aXJlKCcuLi9oZWxwZXJzL3NwZWNpYWxQcm9wZXJ0aWVzJyk7XG5jb25zdCBpc0Jzb25UeXBlID0gcmVxdWlyZSgnLi4vaGVscGVycy9pc0Jzb25UeXBlJyk7XG5cbmNvbnN0IHBvcHVsYXRlTW9kZWxTeW1ib2wgPSByZXF1aXJlKCcuLi9oZWxwZXJzL3N5bWJvbHMnKS5wb3B1bGF0ZU1vZGVsU3ltYm9sO1xuXG4vKiFcbiAqIGlnbm9yZVxuICovXG5cbmNsYXNzIE1vbmdvb3NlTWFwIGV4dGVuZHMgTWFwIHtcbiAgY29uc3RydWN0b3IodiwgcGF0aCwgZG9jLCBzY2hlbWFUeXBlKSB7XG4gICAgaWYgKGdldENvbnN0cnVjdG9yTmFtZSh2KSA9PT0gJ09iamVjdCcpIHtcbiAgICAgIHYgPSBPYmplY3Qua2V5cyh2KS5yZWR1Y2UoKGFyciwga2V5KSA9PiBhcnIuY29uY2F0KFtba2V5LCB2W2tleV1dXSksIFtdKTtcbiAgICB9XG4gICAgc3VwZXIodik7XG4gICAgdGhpcy4kX19wYXJlbnQgPSBkb2MgIT0gbnVsbCAmJiBkb2MuJF9fICE9IG51bGwgPyBkb2MgOiBudWxsO1xuICAgIHRoaXMuJF9fcGF0aCA9IHBhdGg7XG4gICAgdGhpcy4kX19zY2hlbWFUeXBlID0gc2NoZW1hVHlwZSA9PSBudWxsID8gbmV3IE1peGVkKHBhdGgpIDogc2NoZW1hVHlwZTtcblxuICAgIHRoaXMuJF9fcnVuRGVmZXJyZWQoKTtcbiAgfVxuXG4gICRpbml0KGtleSwgdmFsdWUpIHtcbiAgICBjaGVja1ZhbGlkS2V5KGtleSk7XG5cbiAgICBzdXBlci5zZXQoa2V5LCB2YWx1ZSk7XG5cbiAgICBpZiAodmFsdWUgIT0gbnVsbCAmJiB2YWx1ZS4kaXNTaW5nbGVOZXN0ZWQpIHtcbiAgICAgIHZhbHVlLiRiYXNlUGF0aCA9IHRoaXMuJF9fcGF0aCArICcuJyArIGtleTtcbiAgICB9XG4gIH1cblxuICAkX19zZXQoa2V5LCB2YWx1ZSkge1xuICAgIHN1cGVyLnNldChrZXksIHZhbHVlKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBPdmVyd3JpdGVzIG5hdGl2ZSBNYXAncyBgZ2V0KClgIGZ1bmN0aW9uIHRvIHN1cHBvcnQgTW9uZ29vc2UgZ2V0dGVycy5cbiAgICpcbiAgICogQGFwaSBwdWJsaWNcbiAgICogQG1ldGhvZCBnZXRcbiAgICogQG1lbWJlck9mIE1hcFxuICAgKi9cblxuICBnZXQoa2V5LCBvcHRpb25zKSB7XG4gICAgaWYgKGlzQnNvblR5cGUoa2V5LCAnT2JqZWN0SWQnKSkge1xuICAgICAga2V5ID0ga2V5LnRvU3RyaW5nKCk7XG4gICAgfVxuXG4gICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gICAgaWYgKG9wdGlvbnMuZ2V0dGVycyA9PT0gZmFsc2UpIHtcbiAgICAgIHJldHVybiBzdXBlci5nZXQoa2V5KTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuJF9fc2NoZW1hVHlwZS5hcHBseUdldHRlcnMoc3VwZXIuZ2V0KGtleSksIHRoaXMuJF9fcGFyZW50KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBPdmVyd3JpdGVzIG5hdGl2ZSBNYXAncyBgc2V0KClgIGZ1bmN0aW9uIHRvIHN1cHBvcnQgc2V0dGVycywgYHBvcHVsYXRlKClgLFxuICAgKiBhbmQgY2hhbmdlIHRyYWNraW5nLiBOb3RlIHRoYXQgTW9uZ29vc2UgbWFwcyBfb25seV8gc3VwcG9ydCBzdHJpbmdzIGFuZFxuICAgKiBPYmplY3RJZHMgYXMga2V5cy5cbiAgICpcbiAgICogIyMjIyBFeGFtcGxlOlxuICAgKlxuICAgKiAgICAgZG9jLm15TWFwLnNldCgndGVzdCcsIDQyKTsgLy8gd29ya3NcbiAgICogICAgIGRvYy5teU1hcC5zZXQoeyBvYmo6IDQyIH0sIDQyKTsgLy8gVGhyb3dzIFwiTW9uZ29vc2UgbWFwcyBvbmx5IHN1cHBvcnQgc3RyaW5nIGtleXNcIlxuICAgKlxuICAgKiBAYXBpIHB1YmxpY1xuICAgKiBAbWV0aG9kIHNldFxuICAgKiBAbWVtYmVyT2YgTWFwXG4gICAqL1xuXG4gIHNldChrZXksIHZhbHVlKSB7XG4gICAgaWYgKGlzQnNvblR5cGUoa2V5LCAnT2JqZWN0SWQnKSkge1xuICAgICAga2V5ID0ga2V5LnRvU3RyaW5nKCk7XG4gICAgfVxuXG4gICAgY2hlY2tWYWxpZEtleShrZXkpO1xuICAgIHZhbHVlID0gaGFuZGxlU3ByZWFkRG9jKHZhbHVlKTtcblxuICAgIC8vIFdlaXJkLCBidXQgYmVjYXVzZSB5b3UgY2FuJ3QgYXNzaWduIHRvIGB0aGlzYCBiZWZvcmUgY2FsbGluZyBgc3VwZXIoKWBcbiAgICAvLyB5b3UgY2FuJ3QgZ2V0IGFjY2VzcyB0byBgJF9fc2NoZW1hVHlwZWAgdG8gY2FzdCBpbiB0aGUgaW5pdGlhbCBjYWxsIHRvXG4gICAgLy8gYHNldCgpYCBmcm9tIHRoZSBgc3VwZXIoKWAgY29uc3RydWN0b3IuXG5cbiAgICBpZiAodGhpcy4kX19zY2hlbWFUeXBlID09IG51bGwpIHtcbiAgICAgIHRoaXMuJF9fZGVmZXJyZWQgPSB0aGlzLiRfX2RlZmVycmVkIHx8IFtdO1xuICAgICAgdGhpcy4kX19kZWZlcnJlZC5wdXNoKHsga2V5OiBrZXksIHZhbHVlOiB2YWx1ZSB9KTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBsZXQgX2Z1bGxQYXRoO1xuICAgIGNvbnN0IHBhcmVudCA9IHRoaXMuJF9fcGFyZW50O1xuICAgIGNvbnN0IHBvcHVsYXRlZCA9IHBhcmVudCAhPSBudWxsICYmIHBhcmVudC4kX18gJiYgcGFyZW50LiRfXy5wb3B1bGF0ZWQgP1xuICAgICAgcGFyZW50LiRwb3B1bGF0ZWQoZnVsbFBhdGguY2FsbCh0aGlzKSwgdHJ1ZSkgfHwgcGFyZW50LiRwb3B1bGF0ZWQodGhpcy4kX19wYXRoLCB0cnVlKSA6XG4gICAgICBudWxsO1xuICAgIGNvbnN0IHByaW9yVmFsID0gdGhpcy5nZXQoa2V5KTtcblxuICAgIGlmIChwb3B1bGF0ZWQgIT0gbnVsbCkge1xuICAgICAgaWYgKHRoaXMuJF9fc2NoZW1hVHlwZS4kaXNTaW5nbGVOZXN0ZWQpIHtcbiAgICAgICAgdGhyb3cgbmV3IE1vbmdvb3NlRXJyb3IoXG4gICAgICAgICAgJ0Nhbm5vdCBtYW51YWxseSBwb3B1bGF0ZSBzaW5nbGUgbmVzdGVkIHN1YmRvYyB1bmRlcm5lYXRoIE1hcCAnICtcbiAgICAgICAgICBgYXQgcGF0aCBcIiR7dGhpcy4kX19wYXRofVwiLiBUcnkgdXNpbmcgYW4gYXJyYXkgaW5zdGVhZCBvZiBhIE1hcC5gXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgICBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZSkgJiYgdGhpcy4kX19zY2hlbWFUeXBlLiRpc01vbmdvb3NlQXJyYXkpIHtcbiAgICAgICAgdmFsdWUgPSB2YWx1ZS5tYXAodiA9PiB7XG4gICAgICAgICAgaWYgKHYuJF9fID09IG51bGwpIHtcbiAgICAgICAgICAgIHYgPSBuZXcgcG9wdWxhdGVkLm9wdGlvbnNbcG9wdWxhdGVNb2RlbFN5bWJvbF0odik7XG4gICAgICAgICAgfVxuICAgICAgICAgIC8vIERvZXNuJ3Qgc3VwcG9ydCBzaW5nbGUgbmVzdGVkIFwiaW4tcGxhY2VcIiBwb3B1bGF0ZVxuICAgICAgICAgIHYuJF9fLndhc1BvcHVsYXRlZCA9IHsgdmFsdWU6IHYuX2lkIH07XG4gICAgICAgICAgcmV0dXJuIHY7XG4gICAgICAgIH0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKHZhbHVlLiRfXyA9PSBudWxsKSB7XG4gICAgICAgICAgdmFsdWUgPSBuZXcgcG9wdWxhdGVkLm9wdGlvbnNbcG9wdWxhdGVNb2RlbFN5bWJvbF0odmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIC8vIERvZXNuJ3Qgc3VwcG9ydCBzaW5nbGUgbmVzdGVkIFwiaW4tcGxhY2VcIiBwb3B1bGF0ZVxuICAgICAgICB2YWx1ZS4kX18ud2FzUG9wdWxhdGVkID0geyB2YWx1ZTogdmFsdWUuX2lkIH07XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IG9wdGlvbnMgPSB0aGlzLiRfX3NjaGVtYVR5cGUuJGlzTW9uZ29vc2VEb2N1bWVudEFycmF5IHx8IHRoaXMuJF9fc2NoZW1hVHlwZS4kaXNTaW5nbGVOZXN0ZWQgP1xuICAgICAgICAgIHsgcGF0aDogZnVsbFBhdGguY2FsbCh0aGlzKSB9IDpcbiAgICAgICAgICBudWxsO1xuICAgICAgICB2YWx1ZSA9IHRoaXMuJF9fc2NoZW1hVHlwZS5hcHBseVNldHRlcnMoXG4gICAgICAgICAgdmFsdWUsXG4gICAgICAgICAgdGhpcy4kX19wYXJlbnQsXG4gICAgICAgICAgZmFsc2UsXG4gICAgICAgICAgdGhpcy5nZXQoa2V5KSxcbiAgICAgICAgICBvcHRpb25zXG4gICAgICAgICk7XG4gICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICBpZiAodGhpcy4kX19wYXJlbnQgIT0gbnVsbCAmJiB0aGlzLiRfX3BhcmVudC4kX18gIT0gbnVsbCkge1xuICAgICAgICAgIHRoaXMuJF9fcGFyZW50LmludmFsaWRhdGUoZnVsbFBhdGguY2FsbCh0aGlzKSwgZXJyb3IpO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBzdXBlci5zZXQoa2V5LCB2YWx1ZSk7XG5cbiAgICBpZiAocGFyZW50ICE9IG51bGwgJiYgcGFyZW50LiRfXyAhPSBudWxsICYmICFkZWVwRXF1YWwodmFsdWUsIHByaW9yVmFsKSkge1xuICAgICAgcGFyZW50Lm1hcmtNb2RpZmllZChmdWxsUGF0aC5jYWxsKHRoaXMpKTtcbiAgICB9XG5cbiAgICAvLyBEZWxheSBjYWxjdWxhdGluZyBmdWxsIHBhdGggdW5sZXNzIGFic29sdXRlbHkgbmVjZXNzYXJ5LCBiZWNhdXNlIHN0cmluZ1xuICAgIC8vIGNvbmNhdGVuYXRpb24gaXMgYSBib3R0bGVuZWNrIHJlOiAjMTMxNzFcbiAgICBmdW5jdGlvbiBmdWxsUGF0aCgpIHtcbiAgICAgIGlmIChfZnVsbFBhdGgpIHtcbiAgICAgICAgcmV0dXJuIF9mdWxsUGF0aDtcbiAgICAgIH1cbiAgICAgIF9mdWxsUGF0aCA9IHRoaXMuJF9fcGF0aCArICcuJyArIGtleTtcbiAgICAgIHJldHVybiBfZnVsbFBhdGg7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIE92ZXJ3cml0ZXMgbmF0aXZlIE1hcCdzIGBjbGVhcigpYCBmdW5jdGlvbiB0byBzdXBwb3J0IGNoYW5nZSB0cmFja2luZy5cbiAgICpcbiAgICogQGFwaSBwdWJsaWNcbiAgICogQG1ldGhvZCBjbGVhclxuICAgKiBAbWVtYmVyT2YgTWFwXG4gICAqL1xuXG4gIGNsZWFyKCkge1xuICAgIHN1cGVyLmNsZWFyKCk7XG4gICAgY29uc3QgcGFyZW50ID0gdGhpcy4kX19wYXJlbnQ7XG4gICAgaWYgKHBhcmVudCAhPSBudWxsKSB7XG4gICAgICBwYXJlbnQubWFya01vZGlmaWVkKHRoaXMuJF9fcGF0aCk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIE92ZXJ3cml0ZXMgbmF0aXZlIE1hcCdzIGBkZWxldGUoKWAgZnVuY3Rpb24gdG8gc3VwcG9ydCBjaGFuZ2UgdHJhY2tpbmcuXG4gICAqXG4gICAqIEBhcGkgcHVibGljXG4gICAqIEBtZXRob2QgZGVsZXRlXG4gICAqIEBtZW1iZXJPZiBNYXBcbiAgICovXG5cbiAgZGVsZXRlKGtleSkge1xuICAgIGlmIChpc0Jzb25UeXBlKGtleSwgJ09iamVjdElkJykpIHtcbiAgICAgIGtleSA9IGtleS50b1N0cmluZygpO1xuICAgIH1cblxuICAgIHRoaXMuc2V0KGtleSwgdW5kZWZpbmVkKTtcbiAgICByZXR1cm4gc3VwZXIuZGVsZXRlKGtleSk7XG4gIH1cblxuICAvKipcbiAgICogQ29udmVydHMgdGhpcyBtYXAgdG8gYSBuYXRpdmUgSmF2YVNjcmlwdCBNYXAgc28gdGhlIE1vbmdvREIgZHJpdmVyIGNhbiBzZXJpYWxpemUgaXQuXG4gICAqXG4gICAqIEBhcGkgcHVibGljXG4gICAqIEBtZXRob2QgdG9CU09OXG4gICAqIEBtZW1iZXJPZiBNYXBcbiAgICovXG5cbiAgdG9CU09OKCkge1xuICAgIHJldHVybiBuZXcgTWFwKHRoaXMpO1xuICB9XG5cbiAgdG9PYmplY3Qob3B0aW9ucykge1xuICAgIGlmIChvcHRpb25zICYmIG9wdGlvbnMuZmxhdHRlbk1hcHMpIHtcbiAgICAgIGNvbnN0IHJldCA9IHt9O1xuICAgICAgY29uc3Qga2V5cyA9IHRoaXMua2V5cygpO1xuICAgICAgZm9yIChjb25zdCBrZXkgb2Yga2V5cykge1xuICAgICAgICByZXRba2V5XSA9IGNsb25lKHRoaXMuZ2V0KGtleSksIG9wdGlvbnMpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHJldDtcbiAgICB9XG5cbiAgICByZXR1cm4gbmV3IE1hcCh0aGlzKTtcbiAgfVxuXG4gICR0b09iamVjdCgpIHtcbiAgICByZXR1cm4gdGhpcy5jb25zdHJ1Y3Rvci5wcm90b3R5cGUudG9PYmplY3QuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDb252ZXJ0cyB0aGlzIG1hcCB0byBhIG5hdGl2ZSBKYXZhU2NyaXB0IE1hcCBmb3IgYEpTT04uc3RyaW5naWZ5KClgLiBTZXRcbiAgICogdGhlIGBmbGF0dGVuTWFwc2Agb3B0aW9uIHRvIGNvbnZlcnQgdGhpcyBtYXAgdG8gYSBQT0pPIGluc3RlYWQuXG4gICAqXG4gICAqICMjIyMgRXhhbXBsZTpcbiAgICpcbiAgICogICAgIGRvYy5teU1hcC50b0pTT04oKSBpbnN0YW5jZW9mIE1hcDsgLy8gdHJ1ZVxuICAgKiAgICAgZG9jLm15TWFwLnRvSlNPTih7IGZsYXR0ZW5NYXBzOiB0cnVlIH0pIGluc3RhbmNlb2YgTWFwOyAvLyBmYWxzZVxuICAgKlxuICAgKiBAYXBpIHB1YmxpY1xuICAgKiBAbWV0aG9kIHRvSlNPTlxuICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gW29wdGlvbnMuZmxhdHRlbk1hcHM9ZmFsc2VdIHNldCB0byBgdHJ1ZWAgdG8gY29udmVydCB0aGUgbWFwIHRvIGEgUE9KTyByYXRoZXIgdGhhbiBhIG5hdGl2ZSBKYXZhU2NyaXB0IG1hcFxuICAgKiBAbWVtYmVyT2YgTWFwXG4gICAqL1xuXG4gIHRvSlNPTihvcHRpb25zKSB7XG4gICAgaWYgKHR5cGVvZiAob3B0aW9ucyAmJiBvcHRpb25zLmZsYXR0ZW5NYXBzKSA9PT0gJ2Jvb2xlYW4nID8gb3B0aW9ucy5mbGF0dGVuTWFwcyA6IHRydWUpIHtcbiAgICAgIGNvbnN0IHJldCA9IHt9O1xuICAgICAgY29uc3Qga2V5cyA9IHRoaXMua2V5cygpO1xuICAgICAgZm9yIChjb25zdCBrZXkgb2Yga2V5cykge1xuICAgICAgICByZXRba2V5XSA9IGNsb25lKHRoaXMuZ2V0KGtleSksIG9wdGlvbnMpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHJldDtcbiAgICB9XG5cbiAgICByZXR1cm4gbmV3IE1hcCh0aGlzKTtcbiAgfVxuXG4gIGluc3BlY3QoKSB7XG4gICAgcmV0dXJuIG5ldyBNYXAodGhpcyk7XG4gIH1cblxuICAkX19ydW5EZWZlcnJlZCgpIHtcbiAgICBpZiAoIXRoaXMuJF9fZGVmZXJyZWQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBmb3IgKGNvbnN0IGtleVZhbHVlT2JqZWN0IG9mIHRoaXMuJF9fZGVmZXJyZWQpIHtcbiAgICAgIHRoaXMuc2V0KGtleVZhbHVlT2JqZWN0LmtleSwga2V5VmFsdWVPYmplY3QudmFsdWUpO1xuICAgIH1cblxuICAgIHRoaXMuJF9fZGVmZXJyZWQgPSBudWxsO1xuICB9XG59XG5cbmlmICh1dGlsLmluc3BlY3QuY3VzdG9tKSB7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShNb25nb29zZU1hcC5wcm90b3R5cGUsIHV0aWwuaW5zcGVjdC5jdXN0b20sIHtcbiAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICB3cml0YWJsZTogZmFsc2UsXG4gICAgY29uZmlndXJhYmxlOiBmYWxzZSxcbiAgICB2YWx1ZTogTW9uZ29vc2VNYXAucHJvdG90eXBlLmluc3BlY3RcbiAgfSk7XG59XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShNb25nb29zZU1hcC5wcm90b3R5cGUsICckX19zZXQnLCB7XG4gIGVudW1lcmFibGU6IGZhbHNlLFxuICB3cml0YWJsZTogdHJ1ZSxcbiAgY29uZmlndXJhYmxlOiBmYWxzZVxufSk7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShNb25nb29zZU1hcC5wcm90b3R5cGUsICckX19wYXJlbnQnLCB7XG4gIGVudW1lcmFibGU6IGZhbHNlLFxuICB3cml0YWJsZTogdHJ1ZSxcbiAgY29uZmlndXJhYmxlOiBmYWxzZVxufSk7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShNb25nb29zZU1hcC5wcm90b3R5cGUsICckX19wYXRoJywge1xuICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgd3JpdGFibGU6IHRydWUsXG4gIGNvbmZpZ3VyYWJsZTogZmFsc2Vcbn0pO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoTW9uZ29vc2VNYXAucHJvdG90eXBlLCAnJF9fc2NoZW1hVHlwZScsIHtcbiAgZW51bWVyYWJsZTogZmFsc2UsXG4gIHdyaXRhYmxlOiB0cnVlLFxuICBjb25maWd1cmFibGU6IGZhbHNlXG59KTtcblxuLyoqXG4gKiBTZXQgdG8gYHRydWVgIGZvciBhbGwgTW9uZ29vc2UgbWFwIGluc3RhbmNlc1xuICpcbiAqIEBhcGkgcHVibGljXG4gKiBAcHJvcGVydHkgJGlzTW9uZ29vc2VNYXBcbiAqIEBtZW1iZXJPZiBNb25nb29zZU1hcFxuICogQGluc3RhbmNlXG4gKi9cblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KE1vbmdvb3NlTWFwLnByb3RvdHlwZSwgJyRpc01vbmdvb3NlTWFwJywge1xuICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgd3JpdGFibGU6IGZhbHNlLFxuICBjb25maWd1cmFibGU6IGZhbHNlLFxuICB2YWx1ZTogdHJ1ZVxufSk7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShNb25nb29zZU1hcC5wcm90b3R5cGUsICckX19kZWZlcnJlZENhbGxzJywge1xuICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgd3JpdGFibGU6IGZhbHNlLFxuICBjb25maWd1cmFibGU6IGZhbHNlLFxuICB2YWx1ZTogdHJ1ZVxufSk7XG5cbi8qKlxuICogU2luY2UgbWFwcyBhcmUgc3RvcmVkIGFzIG9iamVjdHMgdW5kZXIgdGhlIGhvb2QsIGtleXMgbXVzdCBiZSBzdHJpbmdzXG4gKiBhbmQgY2FuJ3QgY29udGFpbiBhbnkgaW52YWxpZCBjaGFyYWN0ZXJzXG4gKiBAcGFyYW0ge1N0cmluZ30ga2V5XG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5mdW5jdGlvbiBjaGVja1ZhbGlkS2V5KGtleSkge1xuICBjb25zdCBrZXlUeXBlID0gdHlwZW9mIGtleTtcbiAgaWYgKGtleVR5cGUgIT09ICdzdHJpbmcnKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgTW9uZ29vc2UgbWFwcyBvbmx5IHN1cHBvcnQgc3RyaW5nIGtleXMsIGdvdCAke2tleVR5cGV9YCk7XG4gIH1cbiAgaWYgKGtleS5zdGFydHNXaXRoKCckJykpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYE1vbmdvb3NlIG1hcHMgZG8gbm90IHN1cHBvcnQga2V5cyB0aGF0IHN0YXJ0IHdpdGggXCIkXCIsIGdvdCBcIiR7a2V5fVwiYCk7XG4gIH1cbiAgaWYgKGtleS5pbmNsdWRlcygnLicpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBNb25nb29zZSBtYXBzIGRvIG5vdCBzdXBwb3J0IGtleXMgdGhhdCBjb250YWluIFwiLlwiLCBnb3QgXCIke2tleX1cImApO1xuICB9XG4gIGlmIChzcGVjaWFsUHJvcGVydGllcy5oYXMoa2V5KSkge1xuICAgIHRocm93IG5ldyBFcnJvcihgTW9uZ29vc2UgbWFwcyBkbyBub3Qgc3VwcG9ydCByZXNlcnZlZCBrZXkgbmFtZSBcIiR7a2V5fVwiYCk7XG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBNb25nb29zZU1hcDtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/mongoose/lib/types/map.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/mongoose/lib/types/objectid.js":
/*!*****************************************************!*\
  !*** ./node_modules/mongoose/lib/types/objectid.js ***!
  \*****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("/**\n * ObjectId type constructor\n *\n * #### Example:\n *\n *     const id = new mongoose.Types.ObjectId;\n *\n * @constructor ObjectId\n */\n\n\n\nconst ObjectId = (__webpack_require__(/*! bson */ \"(ssr)/./node_modules/bson/lib/bson.cjs\").ObjectId);\nconst objectIdSymbol = (__webpack_require__(/*! ../helpers/symbols */ \"(ssr)/./node_modules/mongoose/lib/helpers/symbols.js\").objectIdSymbol);\n\n/**\n * Getter for convenience with populate, see gh-6115\n * @api private\n */\n\nObject.defineProperty(ObjectId.prototype, '_id', {\n  enumerable: false,\n  configurable: true,\n  get: function() {\n    return this;\n  }\n});\n\n/*!\n * Convenience `valueOf()` to allow comparing ObjectIds using double equals re: gh-7299\n */\n\nif (!ObjectId.prototype.hasOwnProperty('valueOf')) {\n  ObjectId.prototype.valueOf = function objectIdValueOf() {\n    return this.toString();\n  };\n}\n\nObjectId.prototype[objectIdSymbol] = true;\n\nmodule.exports = ObjectId;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbW9uZ29vc2UvbGliL3R5cGVzL29iamVjdGlkLmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFYTs7QUFFYixpQkFBaUIsb0ZBQXdCO0FBQ3pDLHVCQUF1QixzSEFBNEM7O0FBRW5FO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9hcHAxLy4vbm9kZV9tb2R1bGVzL21vbmdvb3NlL2xpYi90eXBlcy9vYmplY3RpZC5qcz8xMjU5Il0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogT2JqZWN0SWQgdHlwZSBjb25zdHJ1Y3RvclxuICpcbiAqICMjIyMgRXhhbXBsZTpcbiAqXG4gKiAgICAgY29uc3QgaWQgPSBuZXcgbW9uZ29vc2UuVHlwZXMuT2JqZWN0SWQ7XG4gKlxuICogQGNvbnN0cnVjdG9yIE9iamVjdElkXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG5jb25zdCBPYmplY3RJZCA9IHJlcXVpcmUoJ2Jzb24nKS5PYmplY3RJZDtcbmNvbnN0IG9iamVjdElkU3ltYm9sID0gcmVxdWlyZSgnLi4vaGVscGVycy9zeW1ib2xzJykub2JqZWN0SWRTeW1ib2w7XG5cbi8qKlxuICogR2V0dGVyIGZvciBjb252ZW5pZW5jZSB3aXRoIHBvcHVsYXRlLCBzZWUgZ2gtNjExNVxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KE9iamVjdElkLnByb3RvdHlwZSwgJ19pZCcsIHtcbiAgZW51bWVyYWJsZTogZmFsc2UsXG4gIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxufSk7XG5cbi8qIVxuICogQ29udmVuaWVuY2UgYHZhbHVlT2YoKWAgdG8gYWxsb3cgY29tcGFyaW5nIE9iamVjdElkcyB1c2luZyBkb3VibGUgZXF1YWxzIHJlOiBnaC03Mjk5XG4gKi9cblxuaWYgKCFPYmplY3RJZC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkoJ3ZhbHVlT2YnKSkge1xuICBPYmplY3RJZC5wcm90b3R5cGUudmFsdWVPZiA9IGZ1bmN0aW9uIG9iamVjdElkVmFsdWVPZigpIHtcbiAgICByZXR1cm4gdGhpcy50b1N0cmluZygpO1xuICB9O1xufVxuXG5PYmplY3RJZC5wcm90b3R5cGVbb2JqZWN0SWRTeW1ib2xdID0gdHJ1ZTtcblxubW9kdWxlLmV4cG9ydHMgPSBPYmplY3RJZDtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/mongoose/lib/types/objectid.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/mongoose/lib/types/subdocument.js":
/*!********************************************************!*\
  !*** ./node_modules/mongoose/lib/types/subdocument.js ***!
  \********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\n\nconst Document = __webpack_require__(/*! ../document */ \"(ssr)/./node_modules/mongoose/lib/document.js\");\nconst immediate = __webpack_require__(/*! ../helpers/immediate */ \"(ssr)/./node_modules/mongoose/lib/helpers/immediate.js\");\nconst internalToObjectOptions = (__webpack_require__(/*! ../options */ \"(ssr)/./node_modules/mongoose/lib/options.js\").internalToObjectOptions);\nconst util = __webpack_require__(/*! util */ \"util\");\nconst utils = __webpack_require__(/*! ../utils */ \"(ssr)/./node_modules/mongoose/lib/utils.js\");\n\nmodule.exports = Subdocument;\n\n/**\n * Subdocument constructor.\n *\n * @inherits Document\n * @api private\n */\n\nfunction Subdocument(value, fields, parent, skipId, options) {\n  if (typeof skipId === 'object' && skipId != null && options == null) {\n    options = skipId;\n    skipId = undefined;\n  }\n  if (parent != null) {\n    // If setting a nested path, should copy isNew from parent re: gh-7048\n    const parentOptions = { isNew: parent.isNew };\n    if ('defaults' in parent.$__) {\n      parentOptions.defaults = parent.$__.defaults;\n    }\n    options = Object.assign(parentOptions, options);\n  }\n  if (options != null && options.path != null) {\n    this.$basePath = options.path;\n  }\n  Document.call(this, value, fields, skipId, options);\n\n  delete this.$__.priorDoc;\n}\n\nSubdocument.prototype = Object.create(Document.prototype);\n\nObject.defineProperty(Subdocument.prototype, '$isSubdocument', {\n  configurable: false,\n  writable: false,\n  value: true\n});\n\nObject.defineProperty(Subdocument.prototype, '$isSingleNested', {\n  configurable: false,\n  writable: false,\n  value: true\n});\n\n/*!\n * ignore\n */\n\nSubdocument.prototype.toBSON = function() {\n  return this.toObject(internalToObjectOptions);\n};\n\n/**\n * Used as a stub for middleware\n *\n * #### Note:\n *\n * _This is a no-op. Does not actually save the doc to the db._\n *\n * @param {Function} [fn]\n * @return {Promise} resolved Promise\n * @api private\n */\n\nSubdocument.prototype.save = async function save(options) {\n  options = options || {};\n\n  if (!options.suppressWarning) {\n    utils.warn('mongoose: calling `save()` on a subdoc does **not** save ' +\n      'the document to MongoDB, it only runs save middleware. ' +\n      'Use `subdoc.save({ suppressWarning: true })` to hide this warning ' +\n      'if you\\'re sure this behavior is right for your app.');\n  }\n\n  return new Promise((resolve, reject) => {\n    this.$__save((err) => {\n      if (err != null) {\n        return reject(err);\n      }\n      resolve(this);\n    });\n  });\n};\n\n/**\n * Given a path relative to this document, return the path relative\n * to the top-level document.\n * @param {String} path\n * @method $__fullPath\n * @memberOf Subdocument\n * @instance\n * @returns {String}\n * @api private\n */\n\nSubdocument.prototype.$__fullPath = function(path) {\n  if (!this.$__.fullPath) {\n    this.ownerDocument();\n  }\n\n  return path ?\n    this.$__.fullPath + '.' + path :\n    this.$__.fullPath;\n};\n\n/**\n * Given a path relative to this document, return the path relative\n * to the top-level document.\n * @param {String} p\n * @returns {String}\n * @method $__pathRelativeToParent\n * @memberOf Subdocument\n * @instance\n * @api private\n */\n\nSubdocument.prototype.$__pathRelativeToParent = function(p) {\n  if (p == null) {\n    return this.$basePath;\n  }\n  return [this.$basePath, p].join('.');\n};\n\n/**\n * Used as a stub for middleware\n *\n * #### Note:\n *\n * _This is a no-op. Does not actually save the doc to the db._\n *\n * @param {Function} [fn]\n * @method $__save\n * @api private\n */\n\nSubdocument.prototype.$__save = function(fn) {\n  return immediate(() => fn(null, this));\n};\n\n/*!\n * ignore\n */\n\nSubdocument.prototype.$isValid = function(path) {\n  const parent = this.$parent();\n  const fullPath = this.$__pathRelativeToParent(path);\n  if (parent != null && fullPath != null) {\n    return parent.$isValid(fullPath);\n  }\n  return Document.prototype.$isValid.call(this, path);\n};\n\n/*!\n * ignore\n */\n\nSubdocument.prototype.markModified = function(path) {\n  Document.prototype.markModified.call(this, path);\n  const parent = this.$parent();\n  const fullPath = this.$__pathRelativeToParent(path);\n\n  if (parent == null || fullPath == null) {\n    return;\n  }\n\n  const myPath = this.$__pathRelativeToParent().replace(/\\.$/, '');\n  if (parent.isDirectModified(myPath) || this.isNew) {\n    return;\n  }\n  this.$__parent.markModified(fullPath, this);\n};\n\n/*!\n * ignore\n */\n\nSubdocument.prototype.isModified = function(paths, modifiedPaths) {\n  const parent = this.$parent();\n  if (parent != null) {\n    if (Array.isArray(paths) || typeof paths === 'string') {\n      paths = (Array.isArray(paths) ? paths : paths.split(' '));\n      paths = paths.map(p => this.$__pathRelativeToParent(p)).filter(p => p != null);\n    } else if (!paths) {\n      paths = this.$__pathRelativeToParent();\n    }\n\n    return parent.$isModified(paths, modifiedPaths);\n  }\n\n  return Document.prototype.isModified.call(this, paths, modifiedPaths);\n};\n\n/**\n * Marks a path as valid, removing existing validation errors.\n *\n * @param {String} path the field to mark as valid\n * @api private\n * @method $markValid\n * @memberOf Subdocument\n */\n\nSubdocument.prototype.$markValid = function(path) {\n  Document.prototype.$markValid.call(this, path);\n  const parent = this.$parent();\n  const fullPath = this.$__pathRelativeToParent(path);\n  if (parent != null && fullPath != null) {\n    parent.$markValid(fullPath);\n  }\n};\n\n/*!\n * ignore\n */\n\nSubdocument.prototype.invalidate = function(path, err, val) {\n  Document.prototype.invalidate.call(this, path, err, val);\n\n  const parent = this.$parent();\n  const fullPath = this.$__pathRelativeToParent(path);\n  if (parent != null && fullPath != null) {\n    parent.invalidate(fullPath, err, val);\n  } else if (err.kind === 'cast' || err.name === 'CastError' || fullPath == null) {\n    throw err;\n  }\n\n  return this.ownerDocument().$__.validationError;\n};\n\n/*!\n * ignore\n */\n\nSubdocument.prototype.$ignore = function(path) {\n  Document.prototype.$ignore.call(this, path);\n  const parent = this.$parent();\n  const fullPath = this.$__pathRelativeToParent(path);\n  if (parent != null && fullPath != null) {\n    parent.$ignore(fullPath);\n  }\n};\n\n/**\n * Returns the top level document of this sub-document.\n *\n * @return {Document}\n */\n\nSubdocument.prototype.ownerDocument = function() {\n  if (this.$__.ownerDocument) {\n    return this.$__.ownerDocument;\n  }\n\n  let parent = this; // eslint-disable-line consistent-this\n  const paths = [];\n  const seenDocs = new Set([parent]);\n\n  while (true) {\n    if (typeof parent.$__pathRelativeToParent !== 'function') {\n      break;\n    }\n    paths.unshift(parent.$__pathRelativeToParent(void 0, true));\n    const _parent = parent.$parent();\n    if (_parent == null) {\n      break;\n    }\n    parent = _parent;\n    if (seenDocs.has(parent)) {\n      throw new Error('Infinite subdocument loop: subdoc with _id ' + parent._id + ' is a parent of itself');\n    }\n\n    seenDocs.add(parent);\n  }\n\n  this.$__.fullPath = paths.join('.');\n\n  this.$__.ownerDocument = parent;\n  return this.$__.ownerDocument;\n};\n\n/*!\n * ignore\n */\n\nSubdocument.prototype.$__fullPathWithIndexes = function() {\n  let parent = this; // eslint-disable-line consistent-this\n  const paths = [];\n  const seenDocs = new Set([parent]);\n\n  while (true) {\n    if (typeof parent.$__pathRelativeToParent !== 'function') {\n      break;\n    }\n    paths.unshift(parent.$__pathRelativeToParent(void 0, false));\n    const _parent = parent.$parent();\n    if (_parent == null) {\n      break;\n    }\n    parent = _parent;\n    if (seenDocs.has(parent)) {\n      throw new Error('Infinite subdocument loop: subdoc with _id ' + parent._id + ' is a parent of itself');\n    }\n\n    seenDocs.add(parent);\n  }\n\n  return paths.join('.');\n};\n\n/**\n * Returns this sub-documents parent document.\n *\n * @api public\n */\n\nSubdocument.prototype.parent = function() {\n  return this.$__parent;\n};\n\n/**\n * Returns this sub-documents parent document.\n *\n * @api public\n * @method $parent\n */\n\nSubdocument.prototype.$parent = Subdocument.prototype.parent;\n\n/**\n * no-op for hooks\n * @param {Function} cb\n * @method $__deleteOne\n * @memberOf Subdocument\n * @instance\n * @api private\n */\n\nSubdocument.prototype.$__deleteOne = function(cb) {\n  if (cb == null) {\n    return;\n  }\n  return cb(null, this);\n};\n\n/**\n * ignore\n * @method $__removeFromParent\n * @memberOf Subdocument\n * @instance\n * @api private\n */\n\nSubdocument.prototype.$__removeFromParent = function() {\n  this.$__parent.set(this.$basePath, null);\n};\n\n/**\n * Null-out this subdoc\n *\n * @param {Object} [options]\n * @param {Function} [callback] optional callback for compatibility with Document.prototype.remove\n */\n\nSubdocument.prototype.deleteOne = function(options, callback) {\n  if (typeof options === 'function') {\n    callback = options;\n    options = null;\n  }\n  registerRemoveListener(this);\n\n  // If removing entire doc, no need to remove subdoc\n  if (!options || !options.noop) {\n    this.$__removeFromParent();\n  }\n\n  return this.$__deleteOne(callback);\n};\n\n/*!\n * ignore\n */\n\nSubdocument.prototype.populate = function() {\n  throw new Error('Mongoose does not support calling populate() on nested ' +\n    'docs. Instead of `doc.nested.populate(\"path\")`, use ' +\n    '`doc.populate(\"nested.path\")`');\n};\n\n/**\n * Helper for console.log\n *\n * @api public\n */\n\nSubdocument.prototype.inspect = function() {\n  return this.toObject({\n    transform: false,\n    virtuals: false,\n    flattenDecimals: false\n  });\n};\n\nif (util.inspect.custom) {\n  // Avoid Node deprecation warning DEP0079\n  Subdocument.prototype[util.inspect.custom] = Subdocument.prototype.inspect;\n}\n\n/**\n * Registers remove event listeners for triggering\n * on subdocuments.\n *\n * @param {Subdocument} sub\n * @api private\n */\n\nfunction registerRemoveListener(sub) {\n  let owner = sub.ownerDocument();\n\n  function emitRemove() {\n    owner.$removeListener('save', emitRemove);\n    owner.$removeListener('deleteOne', emitRemove);\n    sub.emit('deleteOne', sub);\n    sub.constructor.emit('deleteOne', sub);\n    owner = sub = null;\n  }\n\n  owner.$on('save', emitRemove);\n  owner.$on('deleteOne', emitRemove);\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbW9uZ29vc2UvbGliL3R5cGVzL3N1YmRvY3VtZW50LmpzIiwibWFwcGluZ3MiOiJBQUFhOztBQUViLGlCQUFpQixtQkFBTyxDQUFDLGtFQUFhO0FBQ3RDLGtCQUFrQixtQkFBTyxDQUFDLG9GQUFzQjtBQUNoRCxnQ0FBZ0MsK0dBQTZDO0FBQzdFLGFBQWEsbUJBQU8sQ0FBQyxrQkFBTTtBQUMzQixjQUFjLG1CQUFPLENBQUMsNERBQVU7O0FBRWhDOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QjtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFVBQVU7QUFDckIsWUFBWSxTQUFTO0FBQ3JCO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsdUJBQXVCO0FBQ2pEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkI7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsVUFBVTtBQUNyQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxxQkFBcUI7QUFDckI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxXQUFXLFVBQVU7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLFVBQVU7QUFDckI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxhQUFhO0FBQ3hCO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9hcHAxLy4vbm9kZV9tb2R1bGVzL21vbmdvb3NlL2xpYi90eXBlcy9zdWJkb2N1bWVudC5qcz82NjE2Il0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxuY29uc3QgRG9jdW1lbnQgPSByZXF1aXJlKCcuLi9kb2N1bWVudCcpO1xuY29uc3QgaW1tZWRpYXRlID0gcmVxdWlyZSgnLi4vaGVscGVycy9pbW1lZGlhdGUnKTtcbmNvbnN0IGludGVybmFsVG9PYmplY3RPcHRpb25zID0gcmVxdWlyZSgnLi4vb3B0aW9ucycpLmludGVybmFsVG9PYmplY3RPcHRpb25zO1xuY29uc3QgdXRpbCA9IHJlcXVpcmUoJ3V0aWwnKTtcbmNvbnN0IHV0aWxzID0gcmVxdWlyZSgnLi4vdXRpbHMnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBTdWJkb2N1bWVudDtcblxuLyoqXG4gKiBTdWJkb2N1bWVudCBjb25zdHJ1Y3Rvci5cbiAqXG4gKiBAaW5oZXJpdHMgRG9jdW1lbnRcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmZ1bmN0aW9uIFN1YmRvY3VtZW50KHZhbHVlLCBmaWVsZHMsIHBhcmVudCwgc2tpcElkLCBvcHRpb25zKSB7XG4gIGlmICh0eXBlb2Ygc2tpcElkID09PSAnb2JqZWN0JyAmJiBza2lwSWQgIT0gbnVsbCAmJiBvcHRpb25zID09IG51bGwpIHtcbiAgICBvcHRpb25zID0gc2tpcElkO1xuICAgIHNraXBJZCA9IHVuZGVmaW5lZDtcbiAgfVxuICBpZiAocGFyZW50ICE9IG51bGwpIHtcbiAgICAvLyBJZiBzZXR0aW5nIGEgbmVzdGVkIHBhdGgsIHNob3VsZCBjb3B5IGlzTmV3IGZyb20gcGFyZW50IHJlOiBnaC03MDQ4XG4gICAgY29uc3QgcGFyZW50T3B0aW9ucyA9IHsgaXNOZXc6IHBhcmVudC5pc05ldyB9O1xuICAgIGlmICgnZGVmYXVsdHMnIGluIHBhcmVudC4kX18pIHtcbiAgICAgIHBhcmVudE9wdGlvbnMuZGVmYXVsdHMgPSBwYXJlbnQuJF9fLmRlZmF1bHRzO1xuICAgIH1cbiAgICBvcHRpb25zID0gT2JqZWN0LmFzc2lnbihwYXJlbnRPcHRpb25zLCBvcHRpb25zKTtcbiAgfVxuICBpZiAob3B0aW9ucyAhPSBudWxsICYmIG9wdGlvbnMucGF0aCAhPSBudWxsKSB7XG4gICAgdGhpcy4kYmFzZVBhdGggPSBvcHRpb25zLnBhdGg7XG4gIH1cbiAgRG9jdW1lbnQuY2FsbCh0aGlzLCB2YWx1ZSwgZmllbGRzLCBza2lwSWQsIG9wdGlvbnMpO1xuXG4gIGRlbGV0ZSB0aGlzLiRfXy5wcmlvckRvYztcbn1cblxuU3ViZG9jdW1lbnQucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShEb2N1bWVudC5wcm90b3R5cGUpO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoU3ViZG9jdW1lbnQucHJvdG90eXBlLCAnJGlzU3ViZG9jdW1lbnQnLCB7XG4gIGNvbmZpZ3VyYWJsZTogZmFsc2UsXG4gIHdyaXRhYmxlOiBmYWxzZSxcbiAgdmFsdWU6IHRydWVcbn0pO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoU3ViZG9jdW1lbnQucHJvdG90eXBlLCAnJGlzU2luZ2xlTmVzdGVkJywge1xuICBjb25maWd1cmFibGU6IGZhbHNlLFxuICB3cml0YWJsZTogZmFsc2UsXG4gIHZhbHVlOiB0cnVlXG59KTtcblxuLyohXG4gKiBpZ25vcmVcbiAqL1xuXG5TdWJkb2N1bWVudC5wcm90b3R5cGUudG9CU09OID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiB0aGlzLnRvT2JqZWN0KGludGVybmFsVG9PYmplY3RPcHRpb25zKTtcbn07XG5cbi8qKlxuICogVXNlZCBhcyBhIHN0dWIgZm9yIG1pZGRsZXdhcmVcbiAqXG4gKiAjIyMjIE5vdGU6XG4gKlxuICogX1RoaXMgaXMgYSBuby1vcC4gRG9lcyBub3QgYWN0dWFsbHkgc2F2ZSB0aGUgZG9jIHRvIHRoZSBkYi5fXG4gKlxuICogQHBhcmFtIHtGdW5jdGlvbn0gW2ZuXVxuICogQHJldHVybiB7UHJvbWlzZX0gcmVzb2x2ZWQgUHJvbWlzZVxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuU3ViZG9jdW1lbnQucHJvdG90eXBlLnNhdmUgPSBhc3luYyBmdW5jdGlvbiBzYXZlKG9wdGlvbnMpIHtcbiAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG5cbiAgaWYgKCFvcHRpb25zLnN1cHByZXNzV2FybmluZykge1xuICAgIHV0aWxzLndhcm4oJ21vbmdvb3NlOiBjYWxsaW5nIGBzYXZlKClgIG9uIGEgc3ViZG9jIGRvZXMgKipub3QqKiBzYXZlICcgK1xuICAgICAgJ3RoZSBkb2N1bWVudCB0byBNb25nb0RCLCBpdCBvbmx5IHJ1bnMgc2F2ZSBtaWRkbGV3YXJlLiAnICtcbiAgICAgICdVc2UgYHN1YmRvYy5zYXZlKHsgc3VwcHJlc3NXYXJuaW5nOiB0cnVlIH0pYCB0byBoaWRlIHRoaXMgd2FybmluZyAnICtcbiAgICAgICdpZiB5b3VcXCdyZSBzdXJlIHRoaXMgYmVoYXZpb3IgaXMgcmlnaHQgZm9yIHlvdXIgYXBwLicpO1xuICB9XG5cbiAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICB0aGlzLiRfX3NhdmUoKGVycikgPT4ge1xuICAgICAgaWYgKGVyciAhPSBudWxsKSB7XG4gICAgICAgIHJldHVybiByZWplY3QoZXJyKTtcbiAgICAgIH1cbiAgICAgIHJlc29sdmUodGhpcyk7XG4gICAgfSk7XG4gIH0pO1xufTtcblxuLyoqXG4gKiBHaXZlbiBhIHBhdGggcmVsYXRpdmUgdG8gdGhpcyBkb2N1bWVudCwgcmV0dXJuIHRoZSBwYXRoIHJlbGF0aXZlXG4gKiB0byB0aGUgdG9wLWxldmVsIGRvY3VtZW50LlxuICogQHBhcmFtIHtTdHJpbmd9IHBhdGhcbiAqIEBtZXRob2QgJF9fZnVsbFBhdGhcbiAqIEBtZW1iZXJPZiBTdWJkb2N1bWVudFxuICogQGluc3RhbmNlXG4gKiBAcmV0dXJucyB7U3RyaW5nfVxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuU3ViZG9jdW1lbnQucHJvdG90eXBlLiRfX2Z1bGxQYXRoID0gZnVuY3Rpb24ocGF0aCkge1xuICBpZiAoIXRoaXMuJF9fLmZ1bGxQYXRoKSB7XG4gICAgdGhpcy5vd25lckRvY3VtZW50KCk7XG4gIH1cblxuICByZXR1cm4gcGF0aCA/XG4gICAgdGhpcy4kX18uZnVsbFBhdGggKyAnLicgKyBwYXRoIDpcbiAgICB0aGlzLiRfXy5mdWxsUGF0aDtcbn07XG5cbi8qKlxuICogR2l2ZW4gYSBwYXRoIHJlbGF0aXZlIHRvIHRoaXMgZG9jdW1lbnQsIHJldHVybiB0aGUgcGF0aCByZWxhdGl2ZVxuICogdG8gdGhlIHRvcC1sZXZlbCBkb2N1bWVudC5cbiAqIEBwYXJhbSB7U3RyaW5nfSBwXG4gKiBAcmV0dXJucyB7U3RyaW5nfVxuICogQG1ldGhvZCAkX19wYXRoUmVsYXRpdmVUb1BhcmVudFxuICogQG1lbWJlck9mIFN1YmRvY3VtZW50XG4gKiBAaW5zdGFuY2VcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cblN1YmRvY3VtZW50LnByb3RvdHlwZS4kX19wYXRoUmVsYXRpdmVUb1BhcmVudCA9IGZ1bmN0aW9uKHApIHtcbiAgaWYgKHAgPT0gbnVsbCkge1xuICAgIHJldHVybiB0aGlzLiRiYXNlUGF0aDtcbiAgfVxuICByZXR1cm4gW3RoaXMuJGJhc2VQYXRoLCBwXS5qb2luKCcuJyk7XG59O1xuXG4vKipcbiAqIFVzZWQgYXMgYSBzdHViIGZvciBtaWRkbGV3YXJlXG4gKlxuICogIyMjIyBOb3RlOlxuICpcbiAqIF9UaGlzIGlzIGEgbm8tb3AuIERvZXMgbm90IGFjdHVhbGx5IHNhdmUgdGhlIGRvYyB0byB0aGUgZGIuX1xuICpcbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtmbl1cbiAqIEBtZXRob2QgJF9fc2F2ZVxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuU3ViZG9jdW1lbnQucHJvdG90eXBlLiRfX3NhdmUgPSBmdW5jdGlvbihmbikge1xuICByZXR1cm4gaW1tZWRpYXRlKCgpID0+IGZuKG51bGwsIHRoaXMpKTtcbn07XG5cbi8qIVxuICogaWdub3JlXG4gKi9cblxuU3ViZG9jdW1lbnQucHJvdG90eXBlLiRpc1ZhbGlkID0gZnVuY3Rpb24ocGF0aCkge1xuICBjb25zdCBwYXJlbnQgPSB0aGlzLiRwYXJlbnQoKTtcbiAgY29uc3QgZnVsbFBhdGggPSB0aGlzLiRfX3BhdGhSZWxhdGl2ZVRvUGFyZW50KHBhdGgpO1xuICBpZiAocGFyZW50ICE9IG51bGwgJiYgZnVsbFBhdGggIT0gbnVsbCkge1xuICAgIHJldHVybiBwYXJlbnQuJGlzVmFsaWQoZnVsbFBhdGgpO1xuICB9XG4gIHJldHVybiBEb2N1bWVudC5wcm90b3R5cGUuJGlzVmFsaWQuY2FsbCh0aGlzLCBwYXRoKTtcbn07XG5cbi8qIVxuICogaWdub3JlXG4gKi9cblxuU3ViZG9jdW1lbnQucHJvdG90eXBlLm1hcmtNb2RpZmllZCA9IGZ1bmN0aW9uKHBhdGgpIHtcbiAgRG9jdW1lbnQucHJvdG90eXBlLm1hcmtNb2RpZmllZC5jYWxsKHRoaXMsIHBhdGgpO1xuICBjb25zdCBwYXJlbnQgPSB0aGlzLiRwYXJlbnQoKTtcbiAgY29uc3QgZnVsbFBhdGggPSB0aGlzLiRfX3BhdGhSZWxhdGl2ZVRvUGFyZW50KHBhdGgpO1xuXG4gIGlmIChwYXJlbnQgPT0gbnVsbCB8fCBmdWxsUGF0aCA9PSBudWxsKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgY29uc3QgbXlQYXRoID0gdGhpcy4kX19wYXRoUmVsYXRpdmVUb1BhcmVudCgpLnJlcGxhY2UoL1xcLiQvLCAnJyk7XG4gIGlmIChwYXJlbnQuaXNEaXJlY3RNb2RpZmllZChteVBhdGgpIHx8IHRoaXMuaXNOZXcpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgdGhpcy4kX19wYXJlbnQubWFya01vZGlmaWVkKGZ1bGxQYXRoLCB0aGlzKTtcbn07XG5cbi8qIVxuICogaWdub3JlXG4gKi9cblxuU3ViZG9jdW1lbnQucHJvdG90eXBlLmlzTW9kaWZpZWQgPSBmdW5jdGlvbihwYXRocywgbW9kaWZpZWRQYXRocykge1xuICBjb25zdCBwYXJlbnQgPSB0aGlzLiRwYXJlbnQoKTtcbiAgaWYgKHBhcmVudCAhPSBudWxsKSB7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkocGF0aHMpIHx8IHR5cGVvZiBwYXRocyA9PT0gJ3N0cmluZycpIHtcbiAgICAgIHBhdGhzID0gKEFycmF5LmlzQXJyYXkocGF0aHMpID8gcGF0aHMgOiBwYXRocy5zcGxpdCgnICcpKTtcbiAgICAgIHBhdGhzID0gcGF0aHMubWFwKHAgPT4gdGhpcy4kX19wYXRoUmVsYXRpdmVUb1BhcmVudChwKSkuZmlsdGVyKHAgPT4gcCAhPSBudWxsKTtcbiAgICB9IGVsc2UgaWYgKCFwYXRocykge1xuICAgICAgcGF0aHMgPSB0aGlzLiRfX3BhdGhSZWxhdGl2ZVRvUGFyZW50KCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHBhcmVudC4kaXNNb2RpZmllZChwYXRocywgbW9kaWZpZWRQYXRocyk7XG4gIH1cblxuICByZXR1cm4gRG9jdW1lbnQucHJvdG90eXBlLmlzTW9kaWZpZWQuY2FsbCh0aGlzLCBwYXRocywgbW9kaWZpZWRQYXRocyk7XG59O1xuXG4vKipcbiAqIE1hcmtzIGEgcGF0aCBhcyB2YWxpZCwgcmVtb3ZpbmcgZXhpc3RpbmcgdmFsaWRhdGlvbiBlcnJvcnMuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IHBhdGggdGhlIGZpZWxkIHRvIG1hcmsgYXMgdmFsaWRcbiAqIEBhcGkgcHJpdmF0ZVxuICogQG1ldGhvZCAkbWFya1ZhbGlkXG4gKiBAbWVtYmVyT2YgU3ViZG9jdW1lbnRcbiAqL1xuXG5TdWJkb2N1bWVudC5wcm90b3R5cGUuJG1hcmtWYWxpZCA9IGZ1bmN0aW9uKHBhdGgpIHtcbiAgRG9jdW1lbnQucHJvdG90eXBlLiRtYXJrVmFsaWQuY2FsbCh0aGlzLCBwYXRoKTtcbiAgY29uc3QgcGFyZW50ID0gdGhpcy4kcGFyZW50KCk7XG4gIGNvbnN0IGZ1bGxQYXRoID0gdGhpcy4kX19wYXRoUmVsYXRpdmVUb1BhcmVudChwYXRoKTtcbiAgaWYgKHBhcmVudCAhPSBudWxsICYmIGZ1bGxQYXRoICE9IG51bGwpIHtcbiAgICBwYXJlbnQuJG1hcmtWYWxpZChmdWxsUGF0aCk7XG4gIH1cbn07XG5cbi8qIVxuICogaWdub3JlXG4gKi9cblxuU3ViZG9jdW1lbnQucHJvdG90eXBlLmludmFsaWRhdGUgPSBmdW5jdGlvbihwYXRoLCBlcnIsIHZhbCkge1xuICBEb2N1bWVudC5wcm90b3R5cGUuaW52YWxpZGF0ZS5jYWxsKHRoaXMsIHBhdGgsIGVyciwgdmFsKTtcblxuICBjb25zdCBwYXJlbnQgPSB0aGlzLiRwYXJlbnQoKTtcbiAgY29uc3QgZnVsbFBhdGggPSB0aGlzLiRfX3BhdGhSZWxhdGl2ZVRvUGFyZW50KHBhdGgpO1xuICBpZiAocGFyZW50ICE9IG51bGwgJiYgZnVsbFBhdGggIT0gbnVsbCkge1xuICAgIHBhcmVudC5pbnZhbGlkYXRlKGZ1bGxQYXRoLCBlcnIsIHZhbCk7XG4gIH0gZWxzZSBpZiAoZXJyLmtpbmQgPT09ICdjYXN0JyB8fCBlcnIubmFtZSA9PT0gJ0Nhc3RFcnJvcicgfHwgZnVsbFBhdGggPT0gbnVsbCkge1xuICAgIHRocm93IGVycjtcbiAgfVxuXG4gIHJldHVybiB0aGlzLm93bmVyRG9jdW1lbnQoKS4kX18udmFsaWRhdGlvbkVycm9yO1xufTtcblxuLyohXG4gKiBpZ25vcmVcbiAqL1xuXG5TdWJkb2N1bWVudC5wcm90b3R5cGUuJGlnbm9yZSA9IGZ1bmN0aW9uKHBhdGgpIHtcbiAgRG9jdW1lbnQucHJvdG90eXBlLiRpZ25vcmUuY2FsbCh0aGlzLCBwYXRoKTtcbiAgY29uc3QgcGFyZW50ID0gdGhpcy4kcGFyZW50KCk7XG4gIGNvbnN0IGZ1bGxQYXRoID0gdGhpcy4kX19wYXRoUmVsYXRpdmVUb1BhcmVudChwYXRoKTtcbiAgaWYgKHBhcmVudCAhPSBudWxsICYmIGZ1bGxQYXRoICE9IG51bGwpIHtcbiAgICBwYXJlbnQuJGlnbm9yZShmdWxsUGF0aCk7XG4gIH1cbn07XG5cbi8qKlxuICogUmV0dXJucyB0aGUgdG9wIGxldmVsIGRvY3VtZW50IG9mIHRoaXMgc3ViLWRvY3VtZW50LlxuICpcbiAqIEByZXR1cm4ge0RvY3VtZW50fVxuICovXG5cblN1YmRvY3VtZW50LnByb3RvdHlwZS5vd25lckRvY3VtZW50ID0gZnVuY3Rpb24oKSB7XG4gIGlmICh0aGlzLiRfXy5vd25lckRvY3VtZW50KSB7XG4gICAgcmV0dXJuIHRoaXMuJF9fLm93bmVyRG9jdW1lbnQ7XG4gIH1cblxuICBsZXQgcGFyZW50ID0gdGhpczsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBjb25zaXN0ZW50LXRoaXNcbiAgY29uc3QgcGF0aHMgPSBbXTtcbiAgY29uc3Qgc2VlbkRvY3MgPSBuZXcgU2V0KFtwYXJlbnRdKTtcblxuICB3aGlsZSAodHJ1ZSkge1xuICAgIGlmICh0eXBlb2YgcGFyZW50LiRfX3BhdGhSZWxhdGl2ZVRvUGFyZW50ICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICBicmVhaztcbiAgICB9XG4gICAgcGF0aHMudW5zaGlmdChwYXJlbnQuJF9fcGF0aFJlbGF0aXZlVG9QYXJlbnQodm9pZCAwLCB0cnVlKSk7XG4gICAgY29uc3QgX3BhcmVudCA9IHBhcmVudC4kcGFyZW50KCk7XG4gICAgaWYgKF9wYXJlbnQgPT0gbnVsbCkge1xuICAgICAgYnJlYWs7XG4gICAgfVxuICAgIHBhcmVudCA9IF9wYXJlbnQ7XG4gICAgaWYgKHNlZW5Eb2NzLmhhcyhwYXJlbnQpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0luZmluaXRlIHN1YmRvY3VtZW50IGxvb3A6IHN1YmRvYyB3aXRoIF9pZCAnICsgcGFyZW50Ll9pZCArICcgaXMgYSBwYXJlbnQgb2YgaXRzZWxmJyk7XG4gICAgfVxuXG4gICAgc2VlbkRvY3MuYWRkKHBhcmVudCk7XG4gIH1cblxuICB0aGlzLiRfXy5mdWxsUGF0aCA9IHBhdGhzLmpvaW4oJy4nKTtcblxuICB0aGlzLiRfXy5vd25lckRvY3VtZW50ID0gcGFyZW50O1xuICByZXR1cm4gdGhpcy4kX18ub3duZXJEb2N1bWVudDtcbn07XG5cbi8qIVxuICogaWdub3JlXG4gKi9cblxuU3ViZG9jdW1lbnQucHJvdG90eXBlLiRfX2Z1bGxQYXRoV2l0aEluZGV4ZXMgPSBmdW5jdGlvbigpIHtcbiAgbGV0IHBhcmVudCA9IHRoaXM7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgY29uc2lzdGVudC10aGlzXG4gIGNvbnN0IHBhdGhzID0gW107XG4gIGNvbnN0IHNlZW5Eb2NzID0gbmV3IFNldChbcGFyZW50XSk7XG5cbiAgd2hpbGUgKHRydWUpIHtcbiAgICBpZiAodHlwZW9mIHBhcmVudC4kX19wYXRoUmVsYXRpdmVUb1BhcmVudCAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgYnJlYWs7XG4gICAgfVxuICAgIHBhdGhzLnVuc2hpZnQocGFyZW50LiRfX3BhdGhSZWxhdGl2ZVRvUGFyZW50KHZvaWQgMCwgZmFsc2UpKTtcbiAgICBjb25zdCBfcGFyZW50ID0gcGFyZW50LiRwYXJlbnQoKTtcbiAgICBpZiAoX3BhcmVudCA9PSBudWxsKSB7XG4gICAgICBicmVhaztcbiAgICB9XG4gICAgcGFyZW50ID0gX3BhcmVudDtcbiAgICBpZiAoc2VlbkRvY3MuaGFzKHBhcmVudCkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignSW5maW5pdGUgc3ViZG9jdW1lbnQgbG9vcDogc3ViZG9jIHdpdGggX2lkICcgKyBwYXJlbnQuX2lkICsgJyBpcyBhIHBhcmVudCBvZiBpdHNlbGYnKTtcbiAgICB9XG5cbiAgICBzZWVuRG9jcy5hZGQocGFyZW50KTtcbiAgfVxuXG4gIHJldHVybiBwYXRocy5qb2luKCcuJyk7XG59O1xuXG4vKipcbiAqIFJldHVybnMgdGhpcyBzdWItZG9jdW1lbnRzIHBhcmVudCBkb2N1bWVudC5cbiAqXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cblN1YmRvY3VtZW50LnByb3RvdHlwZS5wYXJlbnQgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHRoaXMuJF9fcGFyZW50O1xufTtcblxuLyoqXG4gKiBSZXR1cm5zIHRoaXMgc3ViLWRvY3VtZW50cyBwYXJlbnQgZG9jdW1lbnQuXG4gKlxuICogQGFwaSBwdWJsaWNcbiAqIEBtZXRob2QgJHBhcmVudFxuICovXG5cblN1YmRvY3VtZW50LnByb3RvdHlwZS4kcGFyZW50ID0gU3ViZG9jdW1lbnQucHJvdG90eXBlLnBhcmVudDtcblxuLyoqXG4gKiBuby1vcCBmb3IgaG9va3NcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGNiXG4gKiBAbWV0aG9kICRfX2RlbGV0ZU9uZVxuICogQG1lbWJlck9mIFN1YmRvY3VtZW50XG4gKiBAaW5zdGFuY2VcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cblN1YmRvY3VtZW50LnByb3RvdHlwZS4kX19kZWxldGVPbmUgPSBmdW5jdGlvbihjYikge1xuICBpZiAoY2IgPT0gbnVsbCkge1xuICAgIHJldHVybjtcbiAgfVxuICByZXR1cm4gY2IobnVsbCwgdGhpcyk7XG59O1xuXG4vKipcbiAqIGlnbm9yZVxuICogQG1ldGhvZCAkX19yZW1vdmVGcm9tUGFyZW50XG4gKiBAbWVtYmVyT2YgU3ViZG9jdW1lbnRcbiAqIEBpbnN0YW5jZVxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuU3ViZG9jdW1lbnQucHJvdG90eXBlLiRfX3JlbW92ZUZyb21QYXJlbnQgPSBmdW5jdGlvbigpIHtcbiAgdGhpcy4kX19wYXJlbnQuc2V0KHRoaXMuJGJhc2VQYXRoLCBudWxsKTtcbn07XG5cbi8qKlxuICogTnVsbC1vdXQgdGhpcyBzdWJkb2NcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY2FsbGJhY2tdIG9wdGlvbmFsIGNhbGxiYWNrIGZvciBjb21wYXRpYmlsaXR5IHdpdGggRG9jdW1lbnQucHJvdG90eXBlLnJlbW92ZVxuICovXG5cblN1YmRvY3VtZW50LnByb3RvdHlwZS5kZWxldGVPbmUgPSBmdW5jdGlvbihvcHRpb25zLCBjYWxsYmFjaykge1xuICBpZiAodHlwZW9mIG9wdGlvbnMgPT09ICdmdW5jdGlvbicpIHtcbiAgICBjYWxsYmFjayA9IG9wdGlvbnM7XG4gICAgb3B0aW9ucyA9IG51bGw7XG4gIH1cbiAgcmVnaXN0ZXJSZW1vdmVMaXN0ZW5lcih0aGlzKTtcblxuICAvLyBJZiByZW1vdmluZyBlbnRpcmUgZG9jLCBubyBuZWVkIHRvIHJlbW92ZSBzdWJkb2NcbiAgaWYgKCFvcHRpb25zIHx8ICFvcHRpb25zLm5vb3ApIHtcbiAgICB0aGlzLiRfX3JlbW92ZUZyb21QYXJlbnQoKTtcbiAgfVxuXG4gIHJldHVybiB0aGlzLiRfX2RlbGV0ZU9uZShjYWxsYmFjayk7XG59O1xuXG4vKiFcbiAqIGlnbm9yZVxuICovXG5cblN1YmRvY3VtZW50LnByb3RvdHlwZS5wb3B1bGF0ZSA9IGZ1bmN0aW9uKCkge1xuICB0aHJvdyBuZXcgRXJyb3IoJ01vbmdvb3NlIGRvZXMgbm90IHN1cHBvcnQgY2FsbGluZyBwb3B1bGF0ZSgpIG9uIG5lc3RlZCAnICtcbiAgICAnZG9jcy4gSW5zdGVhZCBvZiBgZG9jLm5lc3RlZC5wb3B1bGF0ZShcInBhdGhcIilgLCB1c2UgJyArXG4gICAgJ2Bkb2MucG9wdWxhdGUoXCJuZXN0ZWQucGF0aFwiKWAnKTtcbn07XG5cbi8qKlxuICogSGVscGVyIGZvciBjb25zb2xlLmxvZ1xuICpcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuU3ViZG9jdW1lbnQucHJvdG90eXBlLmluc3BlY3QgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHRoaXMudG9PYmplY3Qoe1xuICAgIHRyYW5zZm9ybTogZmFsc2UsXG4gICAgdmlydHVhbHM6IGZhbHNlLFxuICAgIGZsYXR0ZW5EZWNpbWFsczogZmFsc2VcbiAgfSk7XG59O1xuXG5pZiAodXRpbC5pbnNwZWN0LmN1c3RvbSkge1xuICAvLyBBdm9pZCBOb2RlIGRlcHJlY2F0aW9uIHdhcm5pbmcgREVQMDA3OVxuICBTdWJkb2N1bWVudC5wcm90b3R5cGVbdXRpbC5pbnNwZWN0LmN1c3RvbV0gPSBTdWJkb2N1bWVudC5wcm90b3R5cGUuaW5zcGVjdDtcbn1cblxuLyoqXG4gKiBSZWdpc3RlcnMgcmVtb3ZlIGV2ZW50IGxpc3RlbmVycyBmb3IgdHJpZ2dlcmluZ1xuICogb24gc3ViZG9jdW1lbnRzLlxuICpcbiAqIEBwYXJhbSB7U3ViZG9jdW1lbnR9IHN1YlxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZnVuY3Rpb24gcmVnaXN0ZXJSZW1vdmVMaXN0ZW5lcihzdWIpIHtcbiAgbGV0IG93bmVyID0gc3ViLm93bmVyRG9jdW1lbnQoKTtcblxuICBmdW5jdGlvbiBlbWl0UmVtb3ZlKCkge1xuICAgIG93bmVyLiRyZW1vdmVMaXN0ZW5lcignc2F2ZScsIGVtaXRSZW1vdmUpO1xuICAgIG93bmVyLiRyZW1vdmVMaXN0ZW5lcignZGVsZXRlT25lJywgZW1pdFJlbW92ZSk7XG4gICAgc3ViLmVtaXQoJ2RlbGV0ZU9uZScsIHN1Yik7XG4gICAgc3ViLmNvbnN0cnVjdG9yLmVtaXQoJ2RlbGV0ZU9uZScsIHN1Yik7XG4gICAgb3duZXIgPSBzdWIgPSBudWxsO1xuICB9XG5cbiAgb3duZXIuJG9uKCdzYXZlJywgZW1pdFJlbW92ZSk7XG4gIG93bmVyLiRvbignZGVsZXRlT25lJywgZW1pdFJlbW92ZSk7XG59XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/mongoose/lib/types/subdocument.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/mongoose/lib/types/uuid.js":
/*!*************************************************!*\
  !*** ./node_modules/mongoose/lib/types/uuid.js ***!
  \*************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("/**\n * UUID type constructor\n *\n * #### Example:\n *\n *     const id = new mongoose.Types.UUID();\n *\n * @constructor UUID\n */\n\n\n\nmodule.exports = __webpack_require__(/*! bson */ \"(ssr)/./node_modules/bson/lib/bson.cjs\").UUID;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbW9uZ29vc2UvbGliL3R5cGVzL3V1aWQuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVhOztBQUViLCtGQUFxQyIsInNvdXJjZXMiOlsid2VicGFjazovL2FwcDEvLi9ub2RlX21vZHVsZXMvbW9uZ29vc2UvbGliL3R5cGVzL3V1aWQuanM/ODAzZSJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIFVVSUQgdHlwZSBjb25zdHJ1Y3RvclxuICpcbiAqICMjIyMgRXhhbXBsZTpcbiAqXG4gKiAgICAgY29uc3QgaWQgPSBuZXcgbW9uZ29vc2UuVHlwZXMuVVVJRCgpO1xuICpcbiAqIEBjb25zdHJ1Y3RvciBVVUlEXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJ2Jzb24nKS5VVUlEO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/mongoose/lib/types/uuid.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/mongoose/lib/utils.js":
/*!********************************************!*\
  !*** ./node_modules/mongoose/lib/utils.js ***!
  \********************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n\n/*!\n * Module dependencies.\n */\n\nconst UUID = (__webpack_require__(/*! bson */ \"(ssr)/./node_modules/bson/lib/bson.cjs\").UUID);\nconst ms = __webpack_require__(/*! ms */ \"(ssr)/./node_modules/ms/index.js\");\nconst mpath = __webpack_require__(/*! mpath */ \"(ssr)/./node_modules/mpath/index.js\");\nconst ObjectId = __webpack_require__(/*! ./types/objectid */ \"(ssr)/./node_modules/mongoose/lib/types/objectid.js\");\nconst PopulateOptions = __webpack_require__(/*! ./options/populateOptions */ \"(ssr)/./node_modules/mongoose/lib/options/populateOptions.js\");\nconst clone = __webpack_require__(/*! ./helpers/clone */ \"(ssr)/./node_modules/mongoose/lib/helpers/clone.js\");\nconst immediate = __webpack_require__(/*! ./helpers/immediate */ \"(ssr)/./node_modules/mongoose/lib/helpers/immediate.js\");\nconst isObject = __webpack_require__(/*! ./helpers/isObject */ \"(ssr)/./node_modules/mongoose/lib/helpers/isObject.js\");\nconst isMongooseArray = __webpack_require__(/*! ./types/array/isMongooseArray */ \"(ssr)/./node_modules/mongoose/lib/types/array/isMongooseArray.js\");\nconst isMongooseDocumentArray = __webpack_require__(/*! ./types/documentArray/isMongooseDocumentArray */ \"(ssr)/./node_modules/mongoose/lib/types/documentArray/isMongooseDocumentArray.js\");\nconst isBsonType = __webpack_require__(/*! ./helpers/isBsonType */ \"(ssr)/./node_modules/mongoose/lib/helpers/isBsonType.js\");\nconst getFunctionName = __webpack_require__(/*! ./helpers/getFunctionName */ \"(ssr)/./node_modules/mongoose/lib/helpers/getFunctionName.js\");\nconst isMongooseObject = __webpack_require__(/*! ./helpers/isMongooseObject */ \"(ssr)/./node_modules/mongoose/lib/helpers/isMongooseObject.js\");\nconst promiseOrCallback = __webpack_require__(/*! ./helpers/promiseOrCallback */ \"(ssr)/./node_modules/mongoose/lib/helpers/promiseOrCallback.js\");\nconst schemaMerge = __webpack_require__(/*! ./helpers/schema/merge */ \"(ssr)/./node_modules/mongoose/lib/helpers/schema/merge.js\");\nconst specialProperties = __webpack_require__(/*! ./helpers/specialProperties */ \"(ssr)/./node_modules/mongoose/lib/helpers/specialProperties.js\");\nconst { trustedSymbol } = __webpack_require__(/*! ./helpers/query/trusted */ \"(ssr)/./node_modules/mongoose/lib/helpers/query/trusted.js\");\n\nlet Document;\n\nexports.specialProperties = specialProperties;\n\nexports.isMongooseArray = isMongooseArray.isMongooseArray;\nexports.isMongooseDocumentArray = isMongooseDocumentArray.isMongooseDocumentArray;\nexports.registerMongooseArray = isMongooseArray.registerMongooseArray;\nexports.registerMongooseDocumentArray = isMongooseDocumentArray.registerMongooseDocumentArray;\n\nconst oneSpaceRE = /\\s/;\nconst manySpaceRE = /\\s+/;\n\n/**\n * Produces a collection name from model `name`. By default, just returns\n * the model name\n *\n * @param {String} name a model name\n * @param {Function} pluralize function that pluralizes the collection name\n * @return {String} a collection name\n * @api private\n */\n\nexports.toCollectionName = function(name, pluralize) {\n  if (name === 'system.profile') {\n    return name;\n  }\n  if (name === 'system.indexes') {\n    return name;\n  }\n  if (typeof pluralize === 'function') {\n    return pluralize(name);\n  }\n  return name;\n};\n\n/**\n * Determines if `a` and `b` are deep equal.\n *\n * Modified from node/lib/assert.js\n *\n * @param {any} a a value to compare to `b`\n * @param {any} b a value to compare to `a`\n * @return {Boolean}\n * @api private\n */\n\nexports.deepEqual = function deepEqual(a, b) {\n  if (a === b) {\n    return true;\n  }\n\n  if (typeof a !== 'object' || typeof b !== 'object') {\n    return a === b;\n  }\n\n  if (a instanceof Date && b instanceof Date) {\n    return a.getTime() === b.getTime();\n  }\n\n  if ((isBsonType(a, 'ObjectId') && isBsonType(b, 'ObjectId')) ||\n      (isBsonType(a, 'Decimal128') && isBsonType(b, 'Decimal128'))) {\n    return a.toString() === b.toString();\n  }\n\n  if (a instanceof RegExp && b instanceof RegExp) {\n    return a.source === b.source &&\n        a.ignoreCase === b.ignoreCase &&\n        a.multiline === b.multiline &&\n        a.global === b.global &&\n        a.dotAll === b.dotAll &&\n        a.unicode === b.unicode &&\n        a.sticky === b.sticky &&\n        a.hasIndices === b.hasIndices;\n  }\n\n  if (a == null || b == null) {\n    return false;\n  }\n\n  if (a.prototype !== b.prototype) {\n    return false;\n  }\n\n  if (a instanceof Map || b instanceof Map) {\n    if (!(a instanceof Map) || !(b instanceof Map)) {\n      return false;\n    }\n    return deepEqual(Array.from(a.keys()), Array.from(b.keys())) &&\n      deepEqual(Array.from(a.values()), Array.from(b.values()));\n  }\n\n  // Handle MongooseNumbers\n  if (a instanceof Number && b instanceof Number) {\n    return a.valueOf() === b.valueOf();\n  }\n\n  if (Buffer.isBuffer(a)) {\n    return exports.buffer.areEqual(a, b);\n  }\n\n  if (Array.isArray(a) || Array.isArray(b)) {\n    if (!Array.isArray(a) || !Array.isArray(b)) {\n      return false;\n    }\n    const len = a.length;\n    if (len !== b.length) {\n      return false;\n    }\n    for (let i = 0; i < len; ++i) {\n      if (!deepEqual(a[i], b[i])) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  if (a.$__ != null) {\n    a = a._doc;\n  } else if (isMongooseObject(a)) {\n    a = a.toObject();\n  }\n\n  if (b.$__ != null) {\n    b = b._doc;\n  } else if (isMongooseObject(b)) {\n    b = b.toObject();\n  }\n\n  const ka = Object.keys(a);\n  const kb = Object.keys(b);\n  const kaLength = ka.length;\n\n  // having the same number of owned properties (keys incorporates\n  // hasOwnProperty)\n  if (kaLength !== kb.length) {\n    return false;\n  }\n\n  // ~~~cheap key test\n  for (let i = kaLength - 1; i >= 0; i--) {\n    if (ka[i] !== kb[i]) {\n      return false;\n    }\n  }\n\n  // equivalent values for every corresponding key, and\n  // ~~~possibly expensive deep test\n  for (const key of ka) {\n    if (!deepEqual(a[key], b[key])) {\n      return false;\n    }\n  }\n\n  return true;\n};\n\n/**\n * Get the last element of an array\n * @param {Array} arr\n */\n\nexports.last = function(arr) {\n  if (arr.length > 0) {\n    return arr[arr.length - 1];\n  }\n  return void 0;\n};\n\n/*!\n * ignore\n */\n\nexports.promiseOrCallback = promiseOrCallback;\n\n/*!\n * ignore\n */\n\nexports.cloneArrays = function cloneArrays(arr) {\n  if (!Array.isArray(arr)) {\n    return arr;\n  }\n\n  return arr.map(el => exports.cloneArrays(el));\n};\n\n/*!\n * ignore\n */\n\nexports.omit = function omit(obj, keys) {\n  if (keys == null) {\n    return Object.assign({}, obj);\n  }\n  if (!Array.isArray(keys)) {\n    keys = [keys];\n  }\n\n  const ret = Object.assign({}, obj);\n  for (const key of keys) {\n    delete ret[key];\n  }\n  return ret;\n};\n\n\n/**\n * Shallow copies defaults into options.\n *\n * @param {Object} defaults\n * @param {Object} [options]\n * @return {Object} the merged object\n * @api private\n */\n\nexports.options = function(defaults, options) {\n  const keys = Object.keys(defaults);\n  let i = keys.length;\n  let k;\n\n  options = options || {};\n\n  while (i--) {\n    k = keys[i];\n    if (!(k in options)) {\n      options[k] = defaults[k];\n    }\n  }\n\n  return options;\n};\n\n/**\n * Merges `from` into `to` without overwriting existing properties.\n *\n * @param {Object} to\n * @param {Object} from\n * @param {Object} [options]\n * @param {String} [path]\n * @api private\n */\n\nexports.merge = function merge(to, from, options, path) {\n  options = options || {};\n\n  const keys = Object.keys(from);\n  let i = 0;\n  const len = keys.length;\n  let key;\n\n  if (from[trustedSymbol]) {\n    to[trustedSymbol] = from[trustedSymbol];\n  }\n\n  path = path || '';\n  const omitNested = options.omitNested || {};\n\n  while (i < len) {\n    key = keys[i++];\n    if (options.omit && options.omit[key]) {\n      continue;\n    }\n    if (omitNested[path]) {\n      continue;\n    }\n    if (specialProperties.has(key)) {\n      continue;\n    }\n    if (to[key] == null) {\n      to[key] = from[key];\n    } else if (exports.isObject(from[key])) {\n      if (!exports.isObject(to[key])) {\n        to[key] = {};\n      }\n      if (from[key] != null) {\n        // Skip merging schemas if we're creating a discriminator schema and\n        // base schema has a given path as a single nested but discriminator schema\n        // has the path as a document array, or vice versa (gh-9534)\n        if (options.isDiscriminatorSchemaMerge &&\n            (from[key].$isSingleNested && to[key].$isMongooseDocumentArray) ||\n            (from[key].$isMongooseDocumentArray && to[key].$isSingleNested)) {\n          continue;\n        } else if (from[key].instanceOfSchema) {\n          if (to[key].instanceOfSchema) {\n            schemaMerge(to[key], from[key].clone(), options.isDiscriminatorSchemaMerge);\n          } else {\n            to[key] = from[key].clone();\n          }\n          continue;\n        } else if (isBsonType(from[key], 'ObjectId')) {\n          to[key] = new ObjectId(from[key]);\n          continue;\n        }\n      }\n      merge(to[key], from[key], options, path ? path + '.' + key : key);\n    } else if (options.overwrite) {\n      to[key] = from[key];\n    }\n  }\n};\n\n/**\n * Applies toObject recursively.\n *\n * @param {Document|Array|Object} obj\n * @return {Object}\n * @api private\n */\n\nexports.toObject = function toObject(obj) {\n  Document || (Document = __webpack_require__(/*! ./document */ \"(ssr)/./node_modules/mongoose/lib/document.js\"));\n  let ret;\n\n  if (obj == null) {\n    return obj;\n  }\n\n  if (obj instanceof Document) {\n    return obj.toObject();\n  }\n\n  if (Array.isArray(obj)) {\n    ret = [];\n\n    for (const doc of obj) {\n      ret.push(toObject(doc));\n    }\n\n    return ret;\n  }\n\n  if (exports.isPOJO(obj)) {\n    ret = {};\n\n    if (obj[trustedSymbol]) {\n      ret[trustedSymbol] = obj[trustedSymbol];\n    }\n\n    for (const k of Object.keys(obj)) {\n      if (specialProperties.has(k)) {\n        continue;\n      }\n      ret[k] = toObject(obj[k]);\n    }\n\n    return ret;\n  }\n\n  return obj;\n};\n\nexports.isObject = isObject;\n\n/**\n * Determines if `arg` is a plain old JavaScript object (POJO). Specifically,\n * `arg` must be an object but not an instance of any special class, like String,\n * ObjectId, etc.\n *\n * `Object.getPrototypeOf()` is part of ES5: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/getPrototypeOf\n *\n * @param {Object|Array|String|Function|RegExp|any} arg\n * @api private\n * @return {Boolean}\n */\n\nexports.isPOJO = __webpack_require__(/*! ./helpers/isPOJO */ \"(ssr)/./node_modules/mongoose/lib/helpers/isPOJO.js\");\n\n/**\n * Determines if `arg` is an object that isn't an instance of a built-in value\n * class, like Array, Buffer, ObjectId, etc.\n * @param {Any} val\n */\n\nexports.isNonBuiltinObject = function isNonBuiltinObject(val) {\n  return typeof val === 'object' &&\n    !exports.isNativeObject(val) &&\n    !exports.isMongooseType(val) &&\n    !(val instanceof UUID) &&\n    val != null;\n};\n\n/**\n * Determines if `obj` is a built-in object like an array, date, boolean,\n * etc.\n * @param {Any} arg\n */\n\nexports.isNativeObject = function(arg) {\n  return Array.isArray(arg) ||\n    arg instanceof Date ||\n    arg instanceof Boolean ||\n    arg instanceof Number ||\n    arg instanceof String;\n};\n\n/**\n * Determines if `val` is an object that has no own keys\n * @param {Any} val\n */\n\nexports.isEmptyObject = function(val) {\n  return val != null &&\n    typeof val === 'object' &&\n    Object.keys(val).length === 0;\n};\n\n/**\n * Search if `obj` or any POJOs nested underneath `obj` has a property named\n * `key`\n * @param {Object} obj\n * @param {String} key\n */\n\nexports.hasKey = function hasKey(obj, key) {\n  const props = Object.keys(obj);\n  for (const prop of props) {\n    if (prop === key) {\n      return true;\n    }\n    if (exports.isPOJO(obj[prop]) && exports.hasKey(obj[prop], key)) {\n      return true;\n    }\n  }\n  return false;\n};\n\n/**\n * process.nextTick helper.\n *\n * Wraps `callback` in a try/catch + nextTick.\n *\n * node-mongodb-native has a habit of state corruption when an error is immediately thrown from within a collection callback.\n *\n * @param {Function} callback\n * @api private\n */\n\nexports.tick = function tick(callback) {\n  if (typeof callback !== 'function') {\n    return;\n  }\n  return function() {\n    try {\n      callback.apply(this, arguments);\n    } catch (err) {\n      // only nextTick on err to get out of\n      // the event loop and avoid state corruption.\n      immediate(function() {\n        throw err;\n      });\n    }\n  };\n};\n\n/**\n * Returns true if `v` is an object that can be serialized as a primitive in\n * MongoDB\n * @param {Any} v\n */\n\nexports.isMongooseType = function(v) {\n  return isBsonType(v, 'ObjectId') || isBsonType(v, 'Decimal128') || v instanceof Buffer;\n};\n\nexports.isMongooseObject = isMongooseObject;\n\n/**\n * Converts `expires` options of index objects to `expiresAfterSeconds` options for MongoDB.\n *\n * @param {Object} object\n * @api private\n */\n\nexports.expires = function expires(object) {\n  if (!(object && object.constructor.name === 'Object')) {\n    return;\n  }\n  if (!('expires' in object)) {\n    return;\n  }\n\n  object.expireAfterSeconds = (typeof object.expires !== 'string')\n    ? object.expires\n    : Math.round(ms(object.expires) / 1000);\n  delete object.expires;\n};\n\n/**\n * populate helper\n * @param {String} path\n * @param {String} select\n * @param {Model} model\n * @param {Object} match\n * @param {Object} options\n * @param {Any} subPopulate\n * @param {Boolean} justOne\n * @param {Boolean} count\n */\n\nexports.populate = function populate(path, select, model, match, options, subPopulate, justOne, count) {\n  // might have passed an object specifying all arguments\n  let obj = null;\n  if (arguments.length === 1) {\n    if (path instanceof PopulateOptions) {\n      // If reusing old populate docs, avoid reusing `_docs` because that may\n      // lead to bugs and memory leaks. See gh-11641\n      path._docs = [];\n      path._childDocs = [];\n      return [path];\n    }\n\n    if (Array.isArray(path)) {\n      const singles = makeSingles(path);\n      return singles.map(o => exports.populate(o)[0]);\n    }\n\n    if (exports.isObject(path)) {\n      obj = Object.assign({}, path);\n    } else {\n      obj = { path: path };\n    }\n  } else if (typeof model === 'object') {\n    obj = {\n      path: path,\n      select: select,\n      match: model,\n      options: match\n    };\n  } else {\n    obj = {\n      path: path,\n      select: select,\n      model: model,\n      match: match,\n      options: options,\n      populate: subPopulate,\n      justOne: justOne,\n      count: count\n    };\n  }\n\n  if (typeof obj.path !== 'string') {\n    throw new TypeError('utils.populate: invalid path. Expected string. Got typeof `' + typeof path + '`');\n  }\n\n  return _populateObj(obj);\n\n  // The order of select/conditions args is opposite Model.find but\n  // necessary to keep backward compatibility (select could be\n  // an array, string, or object literal).\n  function makeSingles(arr) {\n    const ret = [];\n    arr.forEach(function(obj) {\n      if (oneSpaceRE.test(obj.path)) {\n        const paths = obj.path.split(manySpaceRE);\n        paths.forEach(function(p) {\n          const copy = Object.assign({}, obj);\n          copy.path = p;\n          ret.push(copy);\n        });\n      } else {\n        ret.push(obj);\n      }\n    });\n\n    return ret;\n  }\n};\n\nfunction _populateObj(obj) {\n  if (Array.isArray(obj.populate)) {\n    const ret = [];\n    obj.populate.forEach(function(obj) {\n      if (oneSpaceRE.test(obj.path)) {\n        const copy = Object.assign({}, obj);\n        const paths = copy.path.split(manySpaceRE);\n        paths.forEach(function(p) {\n          copy.path = p;\n          ret.push(exports.populate(copy)[0]);\n        });\n      } else {\n        ret.push(exports.populate(obj)[0]);\n      }\n    });\n    obj.populate = exports.populate(ret);\n  } else if (obj.populate != null && typeof obj.populate === 'object') {\n    obj.populate = exports.populate(obj.populate);\n  }\n\n  const ret = [];\n  const paths = oneSpaceRE.test(obj.path) ? obj.path.split(manySpaceRE) : [obj.path];\n  if (obj.options != null) {\n    obj.options = clone(obj.options);\n  }\n\n  for (const path of paths) {\n    ret.push(new PopulateOptions(Object.assign({}, obj, { path: path })));\n  }\n\n  return ret;\n}\n\n/**\n * Return the value of `obj` at the given `path`.\n *\n * @param {String} path\n * @param {Object} obj\n * @param {Any} map\n */\n\nexports.getValue = function(path, obj, map) {\n  return mpath.get(path, obj, getValueLookup, map);\n};\n\n/*!\n * ignore\n */\n\nconst mapGetterOptions = Object.freeze({ getters: false });\n\nfunction getValueLookup(obj, part) {\n  let _from = obj?._doc || obj;\n  if (_from != null && _from.isMongooseArrayProxy) {\n    _from = _from.__array;\n  }\n  return _from instanceof Map ?\n    _from.get(part, mapGetterOptions) :\n    _from[part];\n}\n\n/**\n * Sets the value of `obj` at the given `path`.\n *\n * @param {String} path\n * @param {Anything} val\n * @param {Object} obj\n * @param {Any} map\n * @param {Any} _copying\n */\n\nexports.setValue = function(path, val, obj, map, _copying) {\n  mpath.set(path, val, obj, '_doc', map, _copying);\n};\n\n/**\n * Returns an array of values from object `o`.\n *\n * @param {Object} o\n * @return {Array}\n * @api private\n */\n\nexports.object = {};\nexports.object.vals = function vals(o) {\n  const keys = Object.keys(o);\n  let i = keys.length;\n  const ret = [];\n\n  while (i--) {\n    ret.push(o[keys[i]]);\n  }\n\n  return ret;\n};\n\n/**\n * @see exports.options\n */\n\nexports.object.shallowCopy = exports.options;\n\nconst hop = Object.prototype.hasOwnProperty;\n\n/**\n * Safer helper for hasOwnProperty checks\n *\n * @param {Object} obj\n * @param {String} prop\n */\n\nexports.object.hasOwnProperty = function(obj, prop) {\n  return hop.call(obj, prop);\n};\n\n/**\n * Determine if `val` is null or undefined\n *\n * @param {Any} val\n * @return {Boolean}\n */\n\nexports.isNullOrUndefined = function(val) {\n  return val === null || val === undefined;\n};\n\n/*!\n * ignore\n */\n\nexports.array = {};\n\n/**\n * Flattens an array.\n *\n * [ 1, [ 2, 3, [4] ]] -> [1,2,3,4]\n *\n * @param {Array} arr\n * @param {Function} [filter] If passed, will be invoked with each item in the array. If `filter` returns a falsy value, the item will not be included in the results.\n * @param {Array} ret\n * @return {Array}\n * @api private\n */\n\nexports.array.flatten = function flatten(arr, filter, ret) {\n  ret || (ret = []);\n\n  arr.forEach(function(item) {\n    if (Array.isArray(item)) {\n      flatten(item, filter, ret);\n    } else {\n      if (!filter || filter(item)) {\n        ret.push(item);\n      }\n    }\n  });\n\n  return ret;\n};\n\n/*!\n * ignore\n */\n\nconst _hasOwnProperty = Object.prototype.hasOwnProperty;\n\nexports.hasUserDefinedProperty = function(obj, key) {\n  if (obj == null) {\n    return false;\n  }\n\n  if (Array.isArray(key)) {\n    for (const k of key) {\n      if (exports.hasUserDefinedProperty(obj, k)) {\n        return true;\n      }\n    }\n    return false;\n  }\n\n  if (_hasOwnProperty.call(obj, key)) {\n    return true;\n  }\n  if (typeof obj === 'object' && key in obj) {\n    const v = obj[key];\n    return v !== Object.prototype[key] && v !== Array.prototype[key];\n  }\n\n  return false;\n};\n\n/*!\n * ignore\n */\n\nconst MAX_ARRAY_INDEX = Math.pow(2, 32) - 1;\n\nexports.isArrayIndex = function(val) {\n  if (typeof val === 'number') {\n    return val >= 0 && val <= MAX_ARRAY_INDEX;\n  }\n  if (typeof val === 'string') {\n    if (!/^\\d+$/.test(val)) {\n      return false;\n    }\n    val = +val;\n    return val >= 0 && val <= MAX_ARRAY_INDEX;\n  }\n\n  return false;\n};\n\n/**\n * Removes duplicate values from an array\n *\n * [1, 2, 3, 3, 5] => [1, 2, 3, 5]\n * [ ObjectId(\"550988ba0c19d57f697dc45e\"), ObjectId(\"550988ba0c19d57f697dc45e\") ]\n *    => [ObjectId(\"550988ba0c19d57f697dc45e\")]\n *\n * @param {Array} arr\n * @return {Array}\n * @api private\n */\n\nexports.array.unique = function(arr) {\n  const primitives = new Set();\n  const ids = new Set();\n  const ret = [];\n\n  for (const item of arr) {\n    if (typeof item === 'number' || typeof item === 'string' || item == null) {\n      if (primitives.has(item)) {\n        continue;\n      }\n      ret.push(item);\n      primitives.add(item);\n    } else if (isBsonType(item, 'ObjectId')) {\n      if (ids.has(item.toString())) {\n        continue;\n      }\n      ret.push(item);\n      ids.add(item.toString());\n    } else {\n      ret.push(item);\n    }\n  }\n\n  return ret;\n};\n\nexports.buffer = {};\n\n/**\n * Determines if two buffers are equal.\n *\n * @param {Buffer} a\n * @param {Object} b\n */\n\nexports.buffer.areEqual = function(a, b) {\n  if (!Buffer.isBuffer(a)) {\n    return false;\n  }\n  if (!Buffer.isBuffer(b)) {\n    return false;\n  }\n  if (a.length !== b.length) {\n    return false;\n  }\n  for (let i = 0, len = a.length; i < len; ++i) {\n    if (a[i] !== b[i]) {\n      return false;\n    }\n  }\n  return true;\n};\n\nexports.getFunctionName = getFunctionName;\n\n/**\n * Decorate buffers\n * @param {Object} destination\n * @param {Object} source\n */\n\nexports.decorate = function(destination, source) {\n  for (const key in source) {\n    if (specialProperties.has(key)) {\n      continue;\n    }\n    destination[key] = source[key];\n  }\n};\n\n/**\n * merges to with a copy of from\n *\n * @param {Object} to\n * @param {Object} fromObj\n * @api private\n */\n\nexports.mergeClone = function(to, fromObj) {\n  if (isMongooseObject(fromObj)) {\n    fromObj = fromObj.toObject({\n      transform: false,\n      virtuals: false,\n      depopulate: true,\n      getters: false,\n      flattenDecimals: false\n    });\n  }\n  const keys = Object.keys(fromObj);\n  const len = keys.length;\n  let i = 0;\n  let key;\n\n  while (i < len) {\n    key = keys[i++];\n    if (specialProperties.has(key)) {\n      continue;\n    }\n    if (typeof to[key] === 'undefined') {\n      to[key] = clone(fromObj[key], {\n        transform: false,\n        virtuals: false,\n        depopulate: true,\n        getters: false,\n        flattenDecimals: false\n      });\n    } else {\n      let val = fromObj[key];\n      if (val != null && val.valueOf && !(val instanceof Date)) {\n        val = val.valueOf();\n      }\n      if (exports.isObject(val)) {\n        let obj = val;\n        if (isMongooseObject(val) && !val.isMongooseBuffer) {\n          obj = obj.toObject({\n            transform: false,\n            virtuals: false,\n            depopulate: true,\n            getters: false,\n            flattenDecimals: false\n          });\n        }\n        if (val.isMongooseBuffer) {\n          obj = Buffer.from(obj);\n        }\n        exports.mergeClone(to[key], obj);\n      } else {\n        to[key] = clone(val, {\n          flattenDecimals: false\n        });\n      }\n    }\n  }\n};\n\n/**\n * Executes a function on each element of an array (like _.each)\n *\n * @param {Array} arr\n * @param {Function} fn\n * @api private\n */\n\nexports.each = function(arr, fn) {\n  for (const item of arr) {\n    fn(item);\n  }\n};\n\n/**\n * Rename an object key, while preserving its position in the object\n *\n * @param {Object} oldObj\n * @param {String|Number} oldKey\n * @param {String|Number} newKey\n * @api private\n */\nexports.renameObjKey = function(oldObj, oldKey, newKey) {\n  const keys = Object.keys(oldObj);\n  return keys.reduce(\n    (acc, val) => {\n      if (val === oldKey) {\n        acc[newKey] = oldObj[oldKey];\n      } else {\n        acc[val] = oldObj[val];\n      }\n      return acc;\n    },\n    {}\n  );\n};\n\n/*!\n * ignore\n */\n\nexports.getOption = function(name) {\n  const sources = Array.prototype.slice.call(arguments, 1);\n\n  for (const source of sources) {\n    if (source == null) {\n      continue;\n    }\n    if (source[name] != null) {\n      return source[name];\n    }\n  }\n\n  return null;\n};\n\n/*!\n * ignore\n */\n\nexports.noop = function() {};\n\nexports.errorToPOJO = function errorToPOJO(error) {\n  const isError = error instanceof Error;\n  if (!isError) {\n    throw new Error('`error` must be `instanceof Error`.');\n  }\n\n  const ret = {};\n  for (const properyName of Object.getOwnPropertyNames(error)) {\n    ret[properyName] = error[properyName];\n  }\n  return ret;\n};\n\n/*!\n * ignore\n */\n\nexports.warn = function warn(message) {\n  return process.emitWarning(message, { code: 'MONGOOSE' });\n};\n\n\nexports.injectTimestampsOption = function injectTimestampsOption(writeOperation, timestampsOption) {\n  if (timestampsOption == null) {\n    return;\n  }\n  writeOperation.timestamps = timestampsOption;\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbW9uZ29vc2UvbGliL3V0aWxzLmpzIiwibWFwcGluZ3MiOiJBQUFhOztBQUViO0FBQ0E7QUFDQTs7QUFFQSxhQUFhLGdGQUFvQjtBQUNqQyxXQUFXLG1CQUFPLENBQUMsNENBQUk7QUFDdkIsY0FBYyxtQkFBTyxDQUFDLGtEQUFPO0FBQzdCLGlCQUFpQixtQkFBTyxDQUFDLDZFQUFrQjtBQUMzQyx3QkFBd0IsbUJBQU8sQ0FBQywrRkFBMkI7QUFDM0QsY0FBYyxtQkFBTyxDQUFDLDJFQUFpQjtBQUN2QyxrQkFBa0IsbUJBQU8sQ0FBQyxtRkFBcUI7QUFDL0MsaUJBQWlCLG1CQUFPLENBQUMsaUZBQW9CO0FBQzdDLHdCQUF3QixtQkFBTyxDQUFDLHVHQUErQjtBQUMvRCxnQ0FBZ0MsbUJBQU8sQ0FBQyx1SUFBK0M7QUFDdkYsbUJBQW1CLG1CQUFPLENBQUMscUZBQXNCO0FBQ2pELHdCQUF3QixtQkFBTyxDQUFDLCtGQUEyQjtBQUMzRCx5QkFBeUIsbUJBQU8sQ0FBQyxpR0FBNEI7QUFDN0QsMEJBQTBCLG1CQUFPLENBQUMsbUdBQTZCO0FBQy9ELG9CQUFvQixtQkFBTyxDQUFDLHlGQUF3QjtBQUNwRCwwQkFBMEIsbUJBQU8sQ0FBQyxtR0FBNkI7QUFDL0QsUUFBUSxnQkFBZ0IsRUFBRSxtQkFBTyxDQUFDLDJGQUF5Qjs7QUFFM0Q7O0FBRUEseUJBQXlCOztBQUV6Qix1QkFBdUI7QUFDdkIsK0JBQStCO0FBQy9CLDZCQUE2QjtBQUM3QixxQ0FBcUM7O0FBRXJDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsV0FBVyxVQUFVO0FBQ3JCLFlBQVksUUFBUTtBQUNwQjtBQUNBOztBQUVBLHdCQUF3QjtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLEtBQUs7QUFDaEIsV0FBVyxLQUFLO0FBQ2hCLFlBQVk7QUFDWjtBQUNBOztBQUVBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLFNBQVM7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSw2QkFBNkIsUUFBUTtBQUNyQztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxXQUFXLE9BQU87QUFDbEI7O0FBRUEsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLHlCQUF5Qjs7QUFFekI7QUFDQTtBQUNBOztBQUVBLG1CQUFtQjtBQUNuQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsWUFBWTtBQUNaO0FBQ0EsMkJBQTJCO0FBQzNCO0FBQ0E7QUFDQTtBQUNBOztBQUVBLDhCQUE4QjtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLFlBQVksUUFBUTtBQUNwQjtBQUNBOztBQUVBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CO0FBQ0E7O0FBRUEsYUFBYTtBQUNiOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLHVCQUF1QjtBQUNsQyxZQUFZO0FBQ1o7QUFDQTs7QUFFQSxnQkFBZ0I7QUFDaEIsMEJBQTBCLG1CQUFPLENBQUMsaUVBQVk7QUFDOUM7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsZ0JBQWdCOztBQUVoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcseUNBQXlDO0FBQ3BEO0FBQ0EsWUFBWTtBQUNaOztBQUVBLG1IQUE0Qzs7QUFFNUM7QUFDQTtBQUNBO0FBQ0EsV0FBVyxLQUFLO0FBQ2hCOztBQUVBLDBCQUEwQjtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxLQUFLO0FBQ2hCOztBQUVBLHNCQUFzQjtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFdBQVcsS0FBSztBQUNoQjs7QUFFQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQjs7QUFFQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsVUFBVTtBQUNyQjtBQUNBOztBQUVBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsS0FBSztBQUNoQjs7QUFFQSxzQkFBc0I7QUFDdEI7QUFDQTs7QUFFQSx3QkFBd0I7O0FBRXhCO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQjtBQUNBOztBQUVBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixXQUFXLE9BQU87QUFDbEIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixXQUFXLEtBQUs7QUFDaEIsV0FBVyxTQUFTO0FBQ3BCLFdBQVcsU0FBUztBQUNwQjs7QUFFQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSw0QkFBNEI7QUFDNUIsTUFBTTtBQUNOLGNBQWM7QUFDZDtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDO0FBQ3ZDO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsUUFBUTtBQUNSO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUNBQXFDO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULFFBQVE7QUFDUjtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGlEQUFpRCxTQUFTLFlBQVk7QUFDdEU7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsS0FBSztBQUNoQjs7QUFFQSxnQkFBZ0I7QUFDaEI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEseUNBQXlDLGdCQUFnQjs7QUFFekQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLFVBQVU7QUFDckIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsS0FBSztBQUNoQixXQUFXLEtBQUs7QUFDaEI7O0FBRUEsZ0JBQWdCO0FBQ2hCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFlBQVk7QUFDWjtBQUNBOztBQUVBLGNBQWM7QUFDZCxtQkFBbUI7QUFDbkI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSwwQkFBMEI7O0FBRTFCOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkI7O0FBRUEsNkJBQTZCO0FBQzdCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxLQUFLO0FBQ2hCLFlBQVk7QUFDWjs7QUFFQSx5QkFBeUI7QUFDekI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsYUFBYTs7QUFFYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsVUFBVTtBQUNyQixXQUFXLE9BQU87QUFDbEIsWUFBWTtBQUNaO0FBQ0E7O0FBRUEscUJBQXFCO0FBQ3JCOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsOEJBQThCO0FBQzlCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCLFlBQVk7QUFDWjtBQUNBOztBQUVBLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxjQUFjOztBQUVkO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkI7O0FBRUEsdUJBQXVCO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQyxTQUFTO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSx1QkFBdUI7O0FBRXZCO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25COztBQUVBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CO0FBQ0E7O0FBRUEsa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsVUFBVTtBQUNyQjtBQUNBOztBQUVBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsV0FBVyxlQUFlO0FBQzFCLFdBQVcsZUFBZTtBQUMxQjtBQUNBO0FBQ0Esb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsaUJBQWlCO0FBQ2pCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsWUFBWTs7QUFFWixtQkFBbUI7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxZQUFZO0FBQ1osd0NBQXdDLGtCQUFrQjtBQUMxRDs7O0FBR0EsOEJBQThCO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9hcHAxLy4vbm9kZV9tb2R1bGVzL21vbmdvb3NlL2xpYi91dGlscy5qcz83ZjBjIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxuLyohXG4gKiBNb2R1bGUgZGVwZW5kZW5jaWVzLlxuICovXG5cbmNvbnN0IFVVSUQgPSByZXF1aXJlKCdic29uJykuVVVJRDtcbmNvbnN0IG1zID0gcmVxdWlyZSgnbXMnKTtcbmNvbnN0IG1wYXRoID0gcmVxdWlyZSgnbXBhdGgnKTtcbmNvbnN0IE9iamVjdElkID0gcmVxdWlyZSgnLi90eXBlcy9vYmplY3RpZCcpO1xuY29uc3QgUG9wdWxhdGVPcHRpb25zID0gcmVxdWlyZSgnLi9vcHRpb25zL3BvcHVsYXRlT3B0aW9ucycpO1xuY29uc3QgY2xvbmUgPSByZXF1aXJlKCcuL2hlbHBlcnMvY2xvbmUnKTtcbmNvbnN0IGltbWVkaWF0ZSA9IHJlcXVpcmUoJy4vaGVscGVycy9pbW1lZGlhdGUnKTtcbmNvbnN0IGlzT2JqZWN0ID0gcmVxdWlyZSgnLi9oZWxwZXJzL2lzT2JqZWN0Jyk7XG5jb25zdCBpc01vbmdvb3NlQXJyYXkgPSByZXF1aXJlKCcuL3R5cGVzL2FycmF5L2lzTW9uZ29vc2VBcnJheScpO1xuY29uc3QgaXNNb25nb29zZURvY3VtZW50QXJyYXkgPSByZXF1aXJlKCcuL3R5cGVzL2RvY3VtZW50QXJyYXkvaXNNb25nb29zZURvY3VtZW50QXJyYXknKTtcbmNvbnN0IGlzQnNvblR5cGUgPSByZXF1aXJlKCcuL2hlbHBlcnMvaXNCc29uVHlwZScpO1xuY29uc3QgZ2V0RnVuY3Rpb25OYW1lID0gcmVxdWlyZSgnLi9oZWxwZXJzL2dldEZ1bmN0aW9uTmFtZScpO1xuY29uc3QgaXNNb25nb29zZU9iamVjdCA9IHJlcXVpcmUoJy4vaGVscGVycy9pc01vbmdvb3NlT2JqZWN0Jyk7XG5jb25zdCBwcm9taXNlT3JDYWxsYmFjayA9IHJlcXVpcmUoJy4vaGVscGVycy9wcm9taXNlT3JDYWxsYmFjaycpO1xuY29uc3Qgc2NoZW1hTWVyZ2UgPSByZXF1aXJlKCcuL2hlbHBlcnMvc2NoZW1hL21lcmdlJyk7XG5jb25zdCBzcGVjaWFsUHJvcGVydGllcyA9IHJlcXVpcmUoJy4vaGVscGVycy9zcGVjaWFsUHJvcGVydGllcycpO1xuY29uc3QgeyB0cnVzdGVkU3ltYm9sIH0gPSByZXF1aXJlKCcuL2hlbHBlcnMvcXVlcnkvdHJ1c3RlZCcpO1xuXG5sZXQgRG9jdW1lbnQ7XG5cbmV4cG9ydHMuc3BlY2lhbFByb3BlcnRpZXMgPSBzcGVjaWFsUHJvcGVydGllcztcblxuZXhwb3J0cy5pc01vbmdvb3NlQXJyYXkgPSBpc01vbmdvb3NlQXJyYXkuaXNNb25nb29zZUFycmF5O1xuZXhwb3J0cy5pc01vbmdvb3NlRG9jdW1lbnRBcnJheSA9IGlzTW9uZ29vc2VEb2N1bWVudEFycmF5LmlzTW9uZ29vc2VEb2N1bWVudEFycmF5O1xuZXhwb3J0cy5yZWdpc3Rlck1vbmdvb3NlQXJyYXkgPSBpc01vbmdvb3NlQXJyYXkucmVnaXN0ZXJNb25nb29zZUFycmF5O1xuZXhwb3J0cy5yZWdpc3Rlck1vbmdvb3NlRG9jdW1lbnRBcnJheSA9IGlzTW9uZ29vc2VEb2N1bWVudEFycmF5LnJlZ2lzdGVyTW9uZ29vc2VEb2N1bWVudEFycmF5O1xuXG5jb25zdCBvbmVTcGFjZVJFID0gL1xccy87XG5jb25zdCBtYW55U3BhY2VSRSA9IC9cXHMrLztcblxuLyoqXG4gKiBQcm9kdWNlcyBhIGNvbGxlY3Rpb24gbmFtZSBmcm9tIG1vZGVsIGBuYW1lYC4gQnkgZGVmYXVsdCwganVzdCByZXR1cm5zXG4gKiB0aGUgbW9kZWwgbmFtZVxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lIGEgbW9kZWwgbmFtZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gcGx1cmFsaXplIGZ1bmN0aW9uIHRoYXQgcGx1cmFsaXplcyB0aGUgY29sbGVjdGlvbiBuYW1lXG4gKiBAcmV0dXJuIHtTdHJpbmd9IGEgY29sbGVjdGlvbiBuYW1lXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5leHBvcnRzLnRvQ29sbGVjdGlvbk5hbWUgPSBmdW5jdGlvbihuYW1lLCBwbHVyYWxpemUpIHtcbiAgaWYgKG5hbWUgPT09ICdzeXN0ZW0ucHJvZmlsZScpIHtcbiAgICByZXR1cm4gbmFtZTtcbiAgfVxuICBpZiAobmFtZSA9PT0gJ3N5c3RlbS5pbmRleGVzJykge1xuICAgIHJldHVybiBuYW1lO1xuICB9XG4gIGlmICh0eXBlb2YgcGx1cmFsaXplID09PSAnZnVuY3Rpb24nKSB7XG4gICAgcmV0dXJuIHBsdXJhbGl6ZShuYW1lKTtcbiAgfVxuICByZXR1cm4gbmFtZTtcbn07XG5cbi8qKlxuICogRGV0ZXJtaW5lcyBpZiBgYWAgYW5kIGBiYCBhcmUgZGVlcCBlcXVhbC5cbiAqXG4gKiBNb2RpZmllZCBmcm9tIG5vZGUvbGliL2Fzc2VydC5qc1xuICpcbiAqIEBwYXJhbSB7YW55fSBhIGEgdmFsdWUgdG8gY29tcGFyZSB0byBgYmBcbiAqIEBwYXJhbSB7YW55fSBiIGEgdmFsdWUgdG8gY29tcGFyZSB0byBgYWBcbiAqIEByZXR1cm4ge0Jvb2xlYW59XG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5leHBvcnRzLmRlZXBFcXVhbCA9IGZ1bmN0aW9uIGRlZXBFcXVhbChhLCBiKSB7XG4gIGlmIChhID09PSBiKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICBpZiAodHlwZW9mIGEgIT09ICdvYmplY3QnIHx8IHR5cGVvZiBiICE9PSAnb2JqZWN0Jykge1xuICAgIHJldHVybiBhID09PSBiO1xuICB9XG5cbiAgaWYgKGEgaW5zdGFuY2VvZiBEYXRlICYmIGIgaW5zdGFuY2VvZiBEYXRlKSB7XG4gICAgcmV0dXJuIGEuZ2V0VGltZSgpID09PSBiLmdldFRpbWUoKTtcbiAgfVxuXG4gIGlmICgoaXNCc29uVHlwZShhLCAnT2JqZWN0SWQnKSAmJiBpc0Jzb25UeXBlKGIsICdPYmplY3RJZCcpKSB8fFxuICAgICAgKGlzQnNvblR5cGUoYSwgJ0RlY2ltYWwxMjgnKSAmJiBpc0Jzb25UeXBlKGIsICdEZWNpbWFsMTI4JykpKSB7XG4gICAgcmV0dXJuIGEudG9TdHJpbmcoKSA9PT0gYi50b1N0cmluZygpO1xuICB9XG5cbiAgaWYgKGEgaW5zdGFuY2VvZiBSZWdFeHAgJiYgYiBpbnN0YW5jZW9mIFJlZ0V4cCkge1xuICAgIHJldHVybiBhLnNvdXJjZSA9PT0gYi5zb3VyY2UgJiZcbiAgICAgICAgYS5pZ25vcmVDYXNlID09PSBiLmlnbm9yZUNhc2UgJiZcbiAgICAgICAgYS5tdWx0aWxpbmUgPT09IGIubXVsdGlsaW5lICYmXG4gICAgICAgIGEuZ2xvYmFsID09PSBiLmdsb2JhbCAmJlxuICAgICAgICBhLmRvdEFsbCA9PT0gYi5kb3RBbGwgJiZcbiAgICAgICAgYS51bmljb2RlID09PSBiLnVuaWNvZGUgJiZcbiAgICAgICAgYS5zdGlja3kgPT09IGIuc3RpY2t5ICYmXG4gICAgICAgIGEuaGFzSW5kaWNlcyA9PT0gYi5oYXNJbmRpY2VzO1xuICB9XG5cbiAgaWYgKGEgPT0gbnVsbCB8fCBiID09IG51bGwpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBpZiAoYS5wcm90b3R5cGUgIT09IGIucHJvdG90eXBlKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgaWYgKGEgaW5zdGFuY2VvZiBNYXAgfHwgYiBpbnN0YW5jZW9mIE1hcCkge1xuICAgIGlmICghKGEgaW5zdGFuY2VvZiBNYXApIHx8ICEoYiBpbnN0YW5jZW9mIE1hcCkpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgcmV0dXJuIGRlZXBFcXVhbChBcnJheS5mcm9tKGEua2V5cygpKSwgQXJyYXkuZnJvbShiLmtleXMoKSkpICYmXG4gICAgICBkZWVwRXF1YWwoQXJyYXkuZnJvbShhLnZhbHVlcygpKSwgQXJyYXkuZnJvbShiLnZhbHVlcygpKSk7XG4gIH1cblxuICAvLyBIYW5kbGUgTW9uZ29vc2VOdW1iZXJzXG4gIGlmIChhIGluc3RhbmNlb2YgTnVtYmVyICYmIGIgaW5zdGFuY2VvZiBOdW1iZXIpIHtcbiAgICByZXR1cm4gYS52YWx1ZU9mKCkgPT09IGIudmFsdWVPZigpO1xuICB9XG5cbiAgaWYgKEJ1ZmZlci5pc0J1ZmZlcihhKSkge1xuICAgIHJldHVybiBleHBvcnRzLmJ1ZmZlci5hcmVFcXVhbChhLCBiKTtcbiAgfVxuXG4gIGlmIChBcnJheS5pc0FycmF5KGEpIHx8IEFycmF5LmlzQXJyYXkoYikpIHtcbiAgICBpZiAoIUFycmF5LmlzQXJyYXkoYSkgfHwgIUFycmF5LmlzQXJyYXkoYikpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgY29uc3QgbGVuID0gYS5sZW5ndGg7XG4gICAgaWYgKGxlbiAhPT0gYi5sZW5ndGgpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZW47ICsraSkge1xuICAgICAgaWYgKCFkZWVwRXF1YWwoYVtpXSwgYltpXSkpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIGlmIChhLiRfXyAhPSBudWxsKSB7XG4gICAgYSA9IGEuX2RvYztcbiAgfSBlbHNlIGlmIChpc01vbmdvb3NlT2JqZWN0KGEpKSB7XG4gICAgYSA9IGEudG9PYmplY3QoKTtcbiAgfVxuXG4gIGlmIChiLiRfXyAhPSBudWxsKSB7XG4gICAgYiA9IGIuX2RvYztcbiAgfSBlbHNlIGlmIChpc01vbmdvb3NlT2JqZWN0KGIpKSB7XG4gICAgYiA9IGIudG9PYmplY3QoKTtcbiAgfVxuXG4gIGNvbnN0IGthID0gT2JqZWN0LmtleXMoYSk7XG4gIGNvbnN0IGtiID0gT2JqZWN0LmtleXMoYik7XG4gIGNvbnN0IGthTGVuZ3RoID0ga2EubGVuZ3RoO1xuXG4gIC8vIGhhdmluZyB0aGUgc2FtZSBudW1iZXIgb2Ygb3duZWQgcHJvcGVydGllcyAoa2V5cyBpbmNvcnBvcmF0ZXNcbiAgLy8gaGFzT3duUHJvcGVydHkpXG4gIGlmIChrYUxlbmd0aCAhPT0ga2IubGVuZ3RoKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgLy8gfn5+Y2hlYXAga2V5IHRlc3RcbiAgZm9yIChsZXQgaSA9IGthTGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICBpZiAoa2FbaV0gIT09IGtiW2ldKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG5cbiAgLy8gZXF1aXZhbGVudCB2YWx1ZXMgZm9yIGV2ZXJ5IGNvcnJlc3BvbmRpbmcga2V5LCBhbmRcbiAgLy8gfn5+cG9zc2libHkgZXhwZW5zaXZlIGRlZXAgdGVzdFxuICBmb3IgKGNvbnN0IGtleSBvZiBrYSkge1xuICAgIGlmICghZGVlcEVxdWFsKGFba2V5XSwgYltrZXldKSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiB0cnVlO1xufTtcblxuLyoqXG4gKiBHZXQgdGhlIGxhc3QgZWxlbWVudCBvZiBhbiBhcnJheVxuICogQHBhcmFtIHtBcnJheX0gYXJyXG4gKi9cblxuZXhwb3J0cy5sYXN0ID0gZnVuY3Rpb24oYXJyKSB7XG4gIGlmIChhcnIubGVuZ3RoID4gMCkge1xuICAgIHJldHVybiBhcnJbYXJyLmxlbmd0aCAtIDFdO1xuICB9XG4gIHJldHVybiB2b2lkIDA7XG59O1xuXG4vKiFcbiAqIGlnbm9yZVxuICovXG5cbmV4cG9ydHMucHJvbWlzZU9yQ2FsbGJhY2sgPSBwcm9taXNlT3JDYWxsYmFjaztcblxuLyohXG4gKiBpZ25vcmVcbiAqL1xuXG5leHBvcnRzLmNsb25lQXJyYXlzID0gZnVuY3Rpb24gY2xvbmVBcnJheXMoYXJyKSB7XG4gIGlmICghQXJyYXkuaXNBcnJheShhcnIpKSB7XG4gICAgcmV0dXJuIGFycjtcbiAgfVxuXG4gIHJldHVybiBhcnIubWFwKGVsID0+IGV4cG9ydHMuY2xvbmVBcnJheXMoZWwpKTtcbn07XG5cbi8qIVxuICogaWdub3JlXG4gKi9cblxuZXhwb3J0cy5vbWl0ID0gZnVuY3Rpb24gb21pdChvYmosIGtleXMpIHtcbiAgaWYgKGtleXMgPT0gbnVsbCkge1xuICAgIHJldHVybiBPYmplY3QuYXNzaWduKHt9LCBvYmopO1xuICB9XG4gIGlmICghQXJyYXkuaXNBcnJheShrZXlzKSkge1xuICAgIGtleXMgPSBba2V5c107XG4gIH1cblxuICBjb25zdCByZXQgPSBPYmplY3QuYXNzaWduKHt9LCBvYmopO1xuICBmb3IgKGNvbnN0IGtleSBvZiBrZXlzKSB7XG4gICAgZGVsZXRlIHJldFtrZXldO1xuICB9XG4gIHJldHVybiByZXQ7XG59O1xuXG5cbi8qKlxuICogU2hhbGxvdyBjb3BpZXMgZGVmYXVsdHMgaW50byBvcHRpb25zLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBkZWZhdWx0c1xuICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXVxuICogQHJldHVybiB7T2JqZWN0fSB0aGUgbWVyZ2VkIG9iamVjdFxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZXhwb3J0cy5vcHRpb25zID0gZnVuY3Rpb24oZGVmYXVsdHMsIG9wdGlvbnMpIHtcbiAgY29uc3Qga2V5cyA9IE9iamVjdC5rZXlzKGRlZmF1bHRzKTtcbiAgbGV0IGkgPSBrZXlzLmxlbmd0aDtcbiAgbGV0IGs7XG5cbiAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG5cbiAgd2hpbGUgKGktLSkge1xuICAgIGsgPSBrZXlzW2ldO1xuICAgIGlmICghKGsgaW4gb3B0aW9ucykpIHtcbiAgICAgIG9wdGlvbnNba10gPSBkZWZhdWx0c1trXTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gb3B0aW9ucztcbn07XG5cbi8qKlxuICogTWVyZ2VzIGBmcm9tYCBpbnRvIGB0b2Agd2l0aG91dCBvdmVyd3JpdGluZyBleGlzdGluZyBwcm9wZXJ0aWVzLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSB0b1xuICogQHBhcmFtIHtPYmplY3R9IGZyb21cbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc11cbiAqIEBwYXJhbSB7U3RyaW5nfSBbcGF0aF1cbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmV4cG9ydHMubWVyZ2UgPSBmdW5jdGlvbiBtZXJnZSh0bywgZnJvbSwgb3B0aW9ucywgcGF0aCkge1xuICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcblxuICBjb25zdCBrZXlzID0gT2JqZWN0LmtleXMoZnJvbSk7XG4gIGxldCBpID0gMDtcbiAgY29uc3QgbGVuID0ga2V5cy5sZW5ndGg7XG4gIGxldCBrZXk7XG5cbiAgaWYgKGZyb21bdHJ1c3RlZFN5bWJvbF0pIHtcbiAgICB0b1t0cnVzdGVkU3ltYm9sXSA9IGZyb21bdHJ1c3RlZFN5bWJvbF07XG4gIH1cblxuICBwYXRoID0gcGF0aCB8fCAnJztcbiAgY29uc3Qgb21pdE5lc3RlZCA9IG9wdGlvbnMub21pdE5lc3RlZCB8fCB7fTtcblxuICB3aGlsZSAoaSA8IGxlbikge1xuICAgIGtleSA9IGtleXNbaSsrXTtcbiAgICBpZiAob3B0aW9ucy5vbWl0ICYmIG9wdGlvbnMub21pdFtrZXldKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgaWYgKG9taXROZXN0ZWRbcGF0aF0pIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICBpZiAoc3BlY2lhbFByb3BlcnRpZXMuaGFzKGtleSkpIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICBpZiAodG9ba2V5XSA9PSBudWxsKSB7XG4gICAgICB0b1trZXldID0gZnJvbVtrZXldO1xuICAgIH0gZWxzZSBpZiAoZXhwb3J0cy5pc09iamVjdChmcm9tW2tleV0pKSB7XG4gICAgICBpZiAoIWV4cG9ydHMuaXNPYmplY3QodG9ba2V5XSkpIHtcbiAgICAgICAgdG9ba2V5XSA9IHt9O1xuICAgICAgfVxuICAgICAgaWYgKGZyb21ba2V5XSAhPSBudWxsKSB7XG4gICAgICAgIC8vIFNraXAgbWVyZ2luZyBzY2hlbWFzIGlmIHdlJ3JlIGNyZWF0aW5nIGEgZGlzY3JpbWluYXRvciBzY2hlbWEgYW5kXG4gICAgICAgIC8vIGJhc2Ugc2NoZW1hIGhhcyBhIGdpdmVuIHBhdGggYXMgYSBzaW5nbGUgbmVzdGVkIGJ1dCBkaXNjcmltaW5hdG9yIHNjaGVtYVxuICAgICAgICAvLyBoYXMgdGhlIHBhdGggYXMgYSBkb2N1bWVudCBhcnJheSwgb3IgdmljZSB2ZXJzYSAoZ2gtOTUzNClcbiAgICAgICAgaWYgKG9wdGlvbnMuaXNEaXNjcmltaW5hdG9yU2NoZW1hTWVyZ2UgJiZcbiAgICAgICAgICAgIChmcm9tW2tleV0uJGlzU2luZ2xlTmVzdGVkICYmIHRvW2tleV0uJGlzTW9uZ29vc2VEb2N1bWVudEFycmF5KSB8fFxuICAgICAgICAgICAgKGZyb21ba2V5XS4kaXNNb25nb29zZURvY3VtZW50QXJyYXkgJiYgdG9ba2V5XS4kaXNTaW5nbGVOZXN0ZWQpKSB7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH0gZWxzZSBpZiAoZnJvbVtrZXldLmluc3RhbmNlT2ZTY2hlbWEpIHtcbiAgICAgICAgICBpZiAodG9ba2V5XS5pbnN0YW5jZU9mU2NoZW1hKSB7XG4gICAgICAgICAgICBzY2hlbWFNZXJnZSh0b1trZXldLCBmcm9tW2tleV0uY2xvbmUoKSwgb3B0aW9ucy5pc0Rpc2NyaW1pbmF0b3JTY2hlbWFNZXJnZSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRvW2tleV0gPSBmcm9tW2tleV0uY2xvbmUoKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH0gZWxzZSBpZiAoaXNCc29uVHlwZShmcm9tW2tleV0sICdPYmplY3RJZCcpKSB7XG4gICAgICAgICAgdG9ba2V5XSA9IG5ldyBPYmplY3RJZChmcm9tW2tleV0pO1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBtZXJnZSh0b1trZXldLCBmcm9tW2tleV0sIG9wdGlvbnMsIHBhdGggPyBwYXRoICsgJy4nICsga2V5IDoga2V5KTtcbiAgICB9IGVsc2UgaWYgKG9wdGlvbnMub3ZlcndyaXRlKSB7XG4gICAgICB0b1trZXldID0gZnJvbVtrZXldO1xuICAgIH1cbiAgfVxufTtcblxuLyoqXG4gKiBBcHBsaWVzIHRvT2JqZWN0IHJlY3Vyc2l2ZWx5LlxuICpcbiAqIEBwYXJhbSB7RG9jdW1lbnR8QXJyYXl8T2JqZWN0fSBvYmpcbiAqIEByZXR1cm4ge09iamVjdH1cbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmV4cG9ydHMudG9PYmplY3QgPSBmdW5jdGlvbiB0b09iamVjdChvYmopIHtcbiAgRG9jdW1lbnQgfHwgKERvY3VtZW50ID0gcmVxdWlyZSgnLi9kb2N1bWVudCcpKTtcbiAgbGV0IHJldDtcblxuICBpZiAob2JqID09IG51bGwpIHtcbiAgICByZXR1cm4gb2JqO1xuICB9XG5cbiAgaWYgKG9iaiBpbnN0YW5jZW9mIERvY3VtZW50KSB7XG4gICAgcmV0dXJuIG9iai50b09iamVjdCgpO1xuICB9XG5cbiAgaWYgKEFycmF5LmlzQXJyYXkob2JqKSkge1xuICAgIHJldCA9IFtdO1xuXG4gICAgZm9yIChjb25zdCBkb2Mgb2Ygb2JqKSB7XG4gICAgICByZXQucHVzaCh0b09iamVjdChkb2MpKTtcbiAgICB9XG5cbiAgICByZXR1cm4gcmV0O1xuICB9XG5cbiAgaWYgKGV4cG9ydHMuaXNQT0pPKG9iaikpIHtcbiAgICByZXQgPSB7fTtcblxuICAgIGlmIChvYmpbdHJ1c3RlZFN5bWJvbF0pIHtcbiAgICAgIHJldFt0cnVzdGVkU3ltYm9sXSA9IG9ialt0cnVzdGVkU3ltYm9sXTtcbiAgICB9XG5cbiAgICBmb3IgKGNvbnN0IGsgb2YgT2JqZWN0LmtleXMob2JqKSkge1xuICAgICAgaWYgKHNwZWNpYWxQcm9wZXJ0aWVzLmhhcyhrKSkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIHJldFtrXSA9IHRvT2JqZWN0KG9ialtrXSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHJldDtcbiAgfVxuXG4gIHJldHVybiBvYmo7XG59O1xuXG5leHBvcnRzLmlzT2JqZWN0ID0gaXNPYmplY3Q7XG5cbi8qKlxuICogRGV0ZXJtaW5lcyBpZiBgYXJnYCBpcyBhIHBsYWluIG9sZCBKYXZhU2NyaXB0IG9iamVjdCAoUE9KTykuIFNwZWNpZmljYWxseSxcbiAqIGBhcmdgIG11c3QgYmUgYW4gb2JqZWN0IGJ1dCBub3QgYW4gaW5zdGFuY2Ugb2YgYW55IHNwZWNpYWwgY2xhc3MsIGxpa2UgU3RyaW5nLFxuICogT2JqZWN0SWQsIGV0Yy5cbiAqXG4gKiBgT2JqZWN0LmdldFByb3RvdHlwZU9mKClgIGlzIHBhcnQgb2YgRVM1OiBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9PYmplY3QvZ2V0UHJvdG90eXBlT2ZcbiAqXG4gKiBAcGFyYW0ge09iamVjdHxBcnJheXxTdHJpbmd8RnVuY3Rpb258UmVnRXhwfGFueX0gYXJnXG4gKiBAYXBpIHByaXZhdGVcbiAqIEByZXR1cm4ge0Jvb2xlYW59XG4gKi9cblxuZXhwb3J0cy5pc1BPSk8gPSByZXF1aXJlKCcuL2hlbHBlcnMvaXNQT0pPJyk7XG5cbi8qKlxuICogRGV0ZXJtaW5lcyBpZiBgYXJnYCBpcyBhbiBvYmplY3QgdGhhdCBpc24ndCBhbiBpbnN0YW5jZSBvZiBhIGJ1aWx0LWluIHZhbHVlXG4gKiBjbGFzcywgbGlrZSBBcnJheSwgQnVmZmVyLCBPYmplY3RJZCwgZXRjLlxuICogQHBhcmFtIHtBbnl9IHZhbFxuICovXG5cbmV4cG9ydHMuaXNOb25CdWlsdGluT2JqZWN0ID0gZnVuY3Rpb24gaXNOb25CdWlsdGluT2JqZWN0KHZhbCkge1xuICByZXR1cm4gdHlwZW9mIHZhbCA9PT0gJ29iamVjdCcgJiZcbiAgICAhZXhwb3J0cy5pc05hdGl2ZU9iamVjdCh2YWwpICYmXG4gICAgIWV4cG9ydHMuaXNNb25nb29zZVR5cGUodmFsKSAmJlxuICAgICEodmFsIGluc3RhbmNlb2YgVVVJRCkgJiZcbiAgICB2YWwgIT0gbnVsbDtcbn07XG5cbi8qKlxuICogRGV0ZXJtaW5lcyBpZiBgb2JqYCBpcyBhIGJ1aWx0LWluIG9iamVjdCBsaWtlIGFuIGFycmF5LCBkYXRlLCBib29sZWFuLFxuICogZXRjLlxuICogQHBhcmFtIHtBbnl9IGFyZ1xuICovXG5cbmV4cG9ydHMuaXNOYXRpdmVPYmplY3QgPSBmdW5jdGlvbihhcmcpIHtcbiAgcmV0dXJuIEFycmF5LmlzQXJyYXkoYXJnKSB8fFxuICAgIGFyZyBpbnN0YW5jZW9mIERhdGUgfHxcbiAgICBhcmcgaW5zdGFuY2VvZiBCb29sZWFuIHx8XG4gICAgYXJnIGluc3RhbmNlb2YgTnVtYmVyIHx8XG4gICAgYXJnIGluc3RhbmNlb2YgU3RyaW5nO1xufTtcblxuLyoqXG4gKiBEZXRlcm1pbmVzIGlmIGB2YWxgIGlzIGFuIG9iamVjdCB0aGF0IGhhcyBubyBvd24ga2V5c1xuICogQHBhcmFtIHtBbnl9IHZhbFxuICovXG5cbmV4cG9ydHMuaXNFbXB0eU9iamVjdCA9IGZ1bmN0aW9uKHZhbCkge1xuICByZXR1cm4gdmFsICE9IG51bGwgJiZcbiAgICB0eXBlb2YgdmFsID09PSAnb2JqZWN0JyAmJlxuICAgIE9iamVjdC5rZXlzKHZhbCkubGVuZ3RoID09PSAwO1xufTtcblxuLyoqXG4gKiBTZWFyY2ggaWYgYG9iamAgb3IgYW55IFBPSk9zIG5lc3RlZCB1bmRlcm5lYXRoIGBvYmpgIGhhcyBhIHByb3BlcnR5IG5hbWVkXG4gKiBga2V5YFxuICogQHBhcmFtIHtPYmplY3R9IG9ialxuICogQHBhcmFtIHtTdHJpbmd9IGtleVxuICovXG5cbmV4cG9ydHMuaGFzS2V5ID0gZnVuY3Rpb24gaGFzS2V5KG9iaiwga2V5KSB7XG4gIGNvbnN0IHByb3BzID0gT2JqZWN0LmtleXMob2JqKTtcbiAgZm9yIChjb25zdCBwcm9wIG9mIHByb3BzKSB7XG4gICAgaWYgKHByb3AgPT09IGtleSkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGlmIChleHBvcnRzLmlzUE9KTyhvYmpbcHJvcF0pICYmIGV4cG9ydHMuaGFzS2V5KG9ialtwcm9wXSwga2V5KSkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICB9XG4gIHJldHVybiBmYWxzZTtcbn07XG5cbi8qKlxuICogcHJvY2Vzcy5uZXh0VGljayBoZWxwZXIuXG4gKlxuICogV3JhcHMgYGNhbGxiYWNrYCBpbiBhIHRyeS9jYXRjaCArIG5leHRUaWNrLlxuICpcbiAqIG5vZGUtbW9uZ29kYi1uYXRpdmUgaGFzIGEgaGFiaXQgb2Ygc3RhdGUgY29ycnVwdGlvbiB3aGVuIGFuIGVycm9yIGlzIGltbWVkaWF0ZWx5IHRocm93biBmcm9tIHdpdGhpbiBhIGNvbGxlY3Rpb24gY2FsbGJhY2suXG4gKlxuICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2tcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmV4cG9ydHMudGljayA9IGZ1bmN0aW9uIHRpY2soY2FsbGJhY2spIHtcbiAgaWYgKHR5cGVvZiBjYWxsYmFjayAhPT0gJ2Z1bmN0aW9uJykge1xuICAgIHJldHVybjtcbiAgfVxuICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgdHJ5IHtcbiAgICAgIGNhbGxiYWNrLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAvLyBvbmx5IG5leHRUaWNrIG9uIGVyciB0byBnZXQgb3V0IG9mXG4gICAgICAvLyB0aGUgZXZlbnQgbG9vcCBhbmQgYXZvaWQgc3RhdGUgY29ycnVwdGlvbi5cbiAgICAgIGltbWVkaWF0ZShmdW5jdGlvbigpIHtcbiAgICAgICAgdGhyb3cgZXJyO1xuICAgICAgfSk7XG4gICAgfVxuICB9O1xufTtcblxuLyoqXG4gKiBSZXR1cm5zIHRydWUgaWYgYHZgIGlzIGFuIG9iamVjdCB0aGF0IGNhbiBiZSBzZXJpYWxpemVkIGFzIGEgcHJpbWl0aXZlIGluXG4gKiBNb25nb0RCXG4gKiBAcGFyYW0ge0FueX0gdlxuICovXG5cbmV4cG9ydHMuaXNNb25nb29zZVR5cGUgPSBmdW5jdGlvbih2KSB7XG4gIHJldHVybiBpc0Jzb25UeXBlKHYsICdPYmplY3RJZCcpIHx8IGlzQnNvblR5cGUodiwgJ0RlY2ltYWwxMjgnKSB8fCB2IGluc3RhbmNlb2YgQnVmZmVyO1xufTtcblxuZXhwb3J0cy5pc01vbmdvb3NlT2JqZWN0ID0gaXNNb25nb29zZU9iamVjdDtcblxuLyoqXG4gKiBDb252ZXJ0cyBgZXhwaXJlc2Agb3B0aW9ucyBvZiBpbmRleCBvYmplY3RzIHRvIGBleHBpcmVzQWZ0ZXJTZWNvbmRzYCBvcHRpb25zIGZvciBNb25nb0RCLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3RcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmV4cG9ydHMuZXhwaXJlcyA9IGZ1bmN0aW9uIGV4cGlyZXMob2JqZWN0KSB7XG4gIGlmICghKG9iamVjdCAmJiBvYmplY3QuY29uc3RydWN0b3IubmFtZSA9PT0gJ09iamVjdCcpKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGlmICghKCdleHBpcmVzJyBpbiBvYmplY3QpKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgb2JqZWN0LmV4cGlyZUFmdGVyU2Vjb25kcyA9ICh0eXBlb2Ygb2JqZWN0LmV4cGlyZXMgIT09ICdzdHJpbmcnKVxuICAgID8gb2JqZWN0LmV4cGlyZXNcbiAgICA6IE1hdGgucm91bmQobXMob2JqZWN0LmV4cGlyZXMpIC8gMTAwMCk7XG4gIGRlbGV0ZSBvYmplY3QuZXhwaXJlcztcbn07XG5cbi8qKlxuICogcG9wdWxhdGUgaGVscGVyXG4gKiBAcGFyYW0ge1N0cmluZ30gcGF0aFxuICogQHBhcmFtIHtTdHJpbmd9IHNlbGVjdFxuICogQHBhcmFtIHtNb2RlbH0gbW9kZWxcbiAqIEBwYXJhbSB7T2JqZWN0fSBtYXRjaFxuICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcbiAqIEBwYXJhbSB7QW55fSBzdWJQb3B1bGF0ZVxuICogQHBhcmFtIHtCb29sZWFufSBqdXN0T25lXG4gKiBAcGFyYW0ge0Jvb2xlYW59IGNvdW50XG4gKi9cblxuZXhwb3J0cy5wb3B1bGF0ZSA9IGZ1bmN0aW9uIHBvcHVsYXRlKHBhdGgsIHNlbGVjdCwgbW9kZWwsIG1hdGNoLCBvcHRpb25zLCBzdWJQb3B1bGF0ZSwganVzdE9uZSwgY291bnQpIHtcbiAgLy8gbWlnaHQgaGF2ZSBwYXNzZWQgYW4gb2JqZWN0IHNwZWNpZnlpbmcgYWxsIGFyZ3VtZW50c1xuICBsZXQgb2JqID0gbnVsbDtcbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDEpIHtcbiAgICBpZiAocGF0aCBpbnN0YW5jZW9mIFBvcHVsYXRlT3B0aW9ucykge1xuICAgICAgLy8gSWYgcmV1c2luZyBvbGQgcG9wdWxhdGUgZG9jcywgYXZvaWQgcmV1c2luZyBgX2RvY3NgIGJlY2F1c2UgdGhhdCBtYXlcbiAgICAgIC8vIGxlYWQgdG8gYnVncyBhbmQgbWVtb3J5IGxlYWtzLiBTZWUgZ2gtMTE2NDFcbiAgICAgIHBhdGguX2RvY3MgPSBbXTtcbiAgICAgIHBhdGguX2NoaWxkRG9jcyA9IFtdO1xuICAgICAgcmV0dXJuIFtwYXRoXTtcbiAgICB9XG5cbiAgICBpZiAoQXJyYXkuaXNBcnJheShwYXRoKSkge1xuICAgICAgY29uc3Qgc2luZ2xlcyA9IG1ha2VTaW5nbGVzKHBhdGgpO1xuICAgICAgcmV0dXJuIHNpbmdsZXMubWFwKG8gPT4gZXhwb3J0cy5wb3B1bGF0ZShvKVswXSk7XG4gICAgfVxuXG4gICAgaWYgKGV4cG9ydHMuaXNPYmplY3QocGF0aCkpIHtcbiAgICAgIG9iaiA9IE9iamVjdC5hc3NpZ24oe30sIHBhdGgpO1xuICAgIH0gZWxzZSB7XG4gICAgICBvYmogPSB7IHBhdGg6IHBhdGggfTtcbiAgICB9XG4gIH0gZWxzZSBpZiAodHlwZW9mIG1vZGVsID09PSAnb2JqZWN0Jykge1xuICAgIG9iaiA9IHtcbiAgICAgIHBhdGg6IHBhdGgsXG4gICAgICBzZWxlY3Q6IHNlbGVjdCxcbiAgICAgIG1hdGNoOiBtb2RlbCxcbiAgICAgIG9wdGlvbnM6IG1hdGNoXG4gICAgfTtcbiAgfSBlbHNlIHtcbiAgICBvYmogPSB7XG4gICAgICBwYXRoOiBwYXRoLFxuICAgICAgc2VsZWN0OiBzZWxlY3QsXG4gICAgICBtb2RlbDogbW9kZWwsXG4gICAgICBtYXRjaDogbWF0Y2gsXG4gICAgICBvcHRpb25zOiBvcHRpb25zLFxuICAgICAgcG9wdWxhdGU6IHN1YlBvcHVsYXRlLFxuICAgICAganVzdE9uZToganVzdE9uZSxcbiAgICAgIGNvdW50OiBjb3VudFxuICAgIH07XG4gIH1cblxuICBpZiAodHlwZW9mIG9iai5wYXRoICE9PSAnc3RyaW5nJykge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ3V0aWxzLnBvcHVsYXRlOiBpbnZhbGlkIHBhdGguIEV4cGVjdGVkIHN0cmluZy4gR290IHR5cGVvZiBgJyArIHR5cGVvZiBwYXRoICsgJ2AnKTtcbiAgfVxuXG4gIHJldHVybiBfcG9wdWxhdGVPYmoob2JqKTtcblxuICAvLyBUaGUgb3JkZXIgb2Ygc2VsZWN0L2NvbmRpdGlvbnMgYXJncyBpcyBvcHBvc2l0ZSBNb2RlbC5maW5kIGJ1dFxuICAvLyBuZWNlc3NhcnkgdG8ga2VlcCBiYWNrd2FyZCBjb21wYXRpYmlsaXR5IChzZWxlY3QgY291bGQgYmVcbiAgLy8gYW4gYXJyYXksIHN0cmluZywgb3Igb2JqZWN0IGxpdGVyYWwpLlxuICBmdW5jdGlvbiBtYWtlU2luZ2xlcyhhcnIpIHtcbiAgICBjb25zdCByZXQgPSBbXTtcbiAgICBhcnIuZm9yRWFjaChmdW5jdGlvbihvYmopIHtcbiAgICAgIGlmIChvbmVTcGFjZVJFLnRlc3Qob2JqLnBhdGgpKSB7XG4gICAgICAgIGNvbnN0IHBhdGhzID0gb2JqLnBhdGguc3BsaXQobWFueVNwYWNlUkUpO1xuICAgICAgICBwYXRocy5mb3JFYWNoKGZ1bmN0aW9uKHApIHtcbiAgICAgICAgICBjb25zdCBjb3B5ID0gT2JqZWN0LmFzc2lnbih7fSwgb2JqKTtcbiAgICAgICAgICBjb3B5LnBhdGggPSBwO1xuICAgICAgICAgIHJldC5wdXNoKGNvcHkpO1xuICAgICAgICB9KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldC5wdXNoKG9iaik7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICByZXR1cm4gcmV0O1xuICB9XG59O1xuXG5mdW5jdGlvbiBfcG9wdWxhdGVPYmoob2JqKSB7XG4gIGlmIChBcnJheS5pc0FycmF5KG9iai5wb3B1bGF0ZSkpIHtcbiAgICBjb25zdCByZXQgPSBbXTtcbiAgICBvYmoucG9wdWxhdGUuZm9yRWFjaChmdW5jdGlvbihvYmopIHtcbiAgICAgIGlmIChvbmVTcGFjZVJFLnRlc3Qob2JqLnBhdGgpKSB7XG4gICAgICAgIGNvbnN0IGNvcHkgPSBPYmplY3QuYXNzaWduKHt9LCBvYmopO1xuICAgICAgICBjb25zdCBwYXRocyA9IGNvcHkucGF0aC5zcGxpdChtYW55U3BhY2VSRSk7XG4gICAgICAgIHBhdGhzLmZvckVhY2goZnVuY3Rpb24ocCkge1xuICAgICAgICAgIGNvcHkucGF0aCA9IHA7XG4gICAgICAgICAgcmV0LnB1c2goZXhwb3J0cy5wb3B1bGF0ZShjb3B5KVswXSk7XG4gICAgICAgIH0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0LnB1c2goZXhwb3J0cy5wb3B1bGF0ZShvYmopWzBdKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICBvYmoucG9wdWxhdGUgPSBleHBvcnRzLnBvcHVsYXRlKHJldCk7XG4gIH0gZWxzZSBpZiAob2JqLnBvcHVsYXRlICE9IG51bGwgJiYgdHlwZW9mIG9iai5wb3B1bGF0ZSA9PT0gJ29iamVjdCcpIHtcbiAgICBvYmoucG9wdWxhdGUgPSBleHBvcnRzLnBvcHVsYXRlKG9iai5wb3B1bGF0ZSk7XG4gIH1cblxuICBjb25zdCByZXQgPSBbXTtcbiAgY29uc3QgcGF0aHMgPSBvbmVTcGFjZVJFLnRlc3Qob2JqLnBhdGgpID8gb2JqLnBhdGguc3BsaXQobWFueVNwYWNlUkUpIDogW29iai5wYXRoXTtcbiAgaWYgKG9iai5vcHRpb25zICE9IG51bGwpIHtcbiAgICBvYmoub3B0aW9ucyA9IGNsb25lKG9iai5vcHRpb25zKTtcbiAgfVxuXG4gIGZvciAoY29uc3QgcGF0aCBvZiBwYXRocykge1xuICAgIHJldC5wdXNoKG5ldyBQb3B1bGF0ZU9wdGlvbnMoT2JqZWN0LmFzc2lnbih7fSwgb2JqLCB7IHBhdGg6IHBhdGggfSkpKTtcbiAgfVxuXG4gIHJldHVybiByZXQ7XG59XG5cbi8qKlxuICogUmV0dXJuIHRoZSB2YWx1ZSBvZiBgb2JqYCBhdCB0aGUgZ2l2ZW4gYHBhdGhgLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBwYXRoXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqXG4gKiBAcGFyYW0ge0FueX0gbWFwXG4gKi9cblxuZXhwb3J0cy5nZXRWYWx1ZSA9IGZ1bmN0aW9uKHBhdGgsIG9iaiwgbWFwKSB7XG4gIHJldHVybiBtcGF0aC5nZXQocGF0aCwgb2JqLCBnZXRWYWx1ZUxvb2t1cCwgbWFwKTtcbn07XG5cbi8qIVxuICogaWdub3JlXG4gKi9cblxuY29uc3QgbWFwR2V0dGVyT3B0aW9ucyA9IE9iamVjdC5mcmVlemUoeyBnZXR0ZXJzOiBmYWxzZSB9KTtcblxuZnVuY3Rpb24gZ2V0VmFsdWVMb29rdXAob2JqLCBwYXJ0KSB7XG4gIGxldCBfZnJvbSA9IG9iaj8uX2RvYyB8fCBvYmo7XG4gIGlmIChfZnJvbSAhPSBudWxsICYmIF9mcm9tLmlzTW9uZ29vc2VBcnJheVByb3h5KSB7XG4gICAgX2Zyb20gPSBfZnJvbS5fX2FycmF5O1xuICB9XG4gIHJldHVybiBfZnJvbSBpbnN0YW5jZW9mIE1hcCA/XG4gICAgX2Zyb20uZ2V0KHBhcnQsIG1hcEdldHRlck9wdGlvbnMpIDpcbiAgICBfZnJvbVtwYXJ0XTtcbn1cblxuLyoqXG4gKiBTZXRzIHRoZSB2YWx1ZSBvZiBgb2JqYCBhdCB0aGUgZ2l2ZW4gYHBhdGhgLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBwYXRoXG4gKiBAcGFyYW0ge0FueXRoaW5nfSB2YWxcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmpcbiAqIEBwYXJhbSB7QW55fSBtYXBcbiAqIEBwYXJhbSB7QW55fSBfY29weWluZ1xuICovXG5cbmV4cG9ydHMuc2V0VmFsdWUgPSBmdW5jdGlvbihwYXRoLCB2YWwsIG9iaiwgbWFwLCBfY29weWluZykge1xuICBtcGF0aC5zZXQocGF0aCwgdmFsLCBvYmosICdfZG9jJywgbWFwLCBfY29weWluZyk7XG59O1xuXG4vKipcbiAqIFJldHVybnMgYW4gYXJyYXkgb2YgdmFsdWVzIGZyb20gb2JqZWN0IGBvYC5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gb1xuICogQHJldHVybiB7QXJyYXl9XG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5leHBvcnRzLm9iamVjdCA9IHt9O1xuZXhwb3J0cy5vYmplY3QudmFscyA9IGZ1bmN0aW9uIHZhbHMobykge1xuICBjb25zdCBrZXlzID0gT2JqZWN0LmtleXMobyk7XG4gIGxldCBpID0ga2V5cy5sZW5ndGg7XG4gIGNvbnN0IHJldCA9IFtdO1xuXG4gIHdoaWxlIChpLS0pIHtcbiAgICByZXQucHVzaChvW2tleXNbaV1dKTtcbiAgfVxuXG4gIHJldHVybiByZXQ7XG59O1xuXG4vKipcbiAqIEBzZWUgZXhwb3J0cy5vcHRpb25zXG4gKi9cblxuZXhwb3J0cy5vYmplY3Quc2hhbGxvd0NvcHkgPSBleHBvcnRzLm9wdGlvbnM7XG5cbmNvbnN0IGhvcCA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHk7XG5cbi8qKlxuICogU2FmZXIgaGVscGVyIGZvciBoYXNPd25Qcm9wZXJ0eSBjaGVja3NcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqXG4gKiBAcGFyYW0ge1N0cmluZ30gcHJvcFxuICovXG5cbmV4cG9ydHMub2JqZWN0Lmhhc093blByb3BlcnR5ID0gZnVuY3Rpb24ob2JqLCBwcm9wKSB7XG4gIHJldHVybiBob3AuY2FsbChvYmosIHByb3ApO1xufTtcblxuLyoqXG4gKiBEZXRlcm1pbmUgaWYgYHZhbGAgaXMgbnVsbCBvciB1bmRlZmluZWRcbiAqXG4gKiBAcGFyYW0ge0FueX0gdmFsXG4gKiBAcmV0dXJuIHtCb29sZWFufVxuICovXG5cbmV4cG9ydHMuaXNOdWxsT3JVbmRlZmluZWQgPSBmdW5jdGlvbih2YWwpIHtcbiAgcmV0dXJuIHZhbCA9PT0gbnVsbCB8fCB2YWwgPT09IHVuZGVmaW5lZDtcbn07XG5cbi8qIVxuICogaWdub3JlXG4gKi9cblxuZXhwb3J0cy5hcnJheSA9IHt9O1xuXG4vKipcbiAqIEZsYXR0ZW5zIGFuIGFycmF5LlxuICpcbiAqIFsgMSwgWyAyLCAzLCBbNF0gXV0gLT4gWzEsMiwzLDRdXG4gKlxuICogQHBhcmFtIHtBcnJheX0gYXJyXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbZmlsdGVyXSBJZiBwYXNzZWQsIHdpbGwgYmUgaW52b2tlZCB3aXRoIGVhY2ggaXRlbSBpbiB0aGUgYXJyYXkuIElmIGBmaWx0ZXJgIHJldHVybnMgYSBmYWxzeSB2YWx1ZSwgdGhlIGl0ZW0gd2lsbCBub3QgYmUgaW5jbHVkZWQgaW4gdGhlIHJlc3VsdHMuXG4gKiBAcGFyYW0ge0FycmF5fSByZXRcbiAqIEByZXR1cm4ge0FycmF5fVxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZXhwb3J0cy5hcnJheS5mbGF0dGVuID0gZnVuY3Rpb24gZmxhdHRlbihhcnIsIGZpbHRlciwgcmV0KSB7XG4gIHJldCB8fCAocmV0ID0gW10pO1xuXG4gIGFyci5mb3JFYWNoKGZ1bmN0aW9uKGl0ZW0pIHtcbiAgICBpZiAoQXJyYXkuaXNBcnJheShpdGVtKSkge1xuICAgICAgZmxhdHRlbihpdGVtLCBmaWx0ZXIsIHJldCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmICghZmlsdGVyIHx8IGZpbHRlcihpdGVtKSkge1xuICAgICAgICByZXQucHVzaChpdGVtKTtcbiAgICAgIH1cbiAgICB9XG4gIH0pO1xuXG4gIHJldHVybiByZXQ7XG59O1xuXG4vKiFcbiAqIGlnbm9yZVxuICovXG5cbmNvbnN0IF9oYXNPd25Qcm9wZXJ0eSA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHk7XG5cbmV4cG9ydHMuaGFzVXNlckRlZmluZWRQcm9wZXJ0eSA9IGZ1bmN0aW9uKG9iaiwga2V5KSB7XG4gIGlmIChvYmogPT0gbnVsbCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIGlmIChBcnJheS5pc0FycmF5KGtleSkpIHtcbiAgICBmb3IgKGNvbnN0IGsgb2Yga2V5KSB7XG4gICAgICBpZiAoZXhwb3J0cy5oYXNVc2VyRGVmaW5lZFByb3BlcnR5KG9iaiwgaykpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIGlmIChfaGFzT3duUHJvcGVydHkuY2FsbChvYmosIGtleSkpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICBpZiAodHlwZW9mIG9iaiA9PT0gJ29iamVjdCcgJiYga2V5IGluIG9iaikge1xuICAgIGNvbnN0IHYgPSBvYmpba2V5XTtcbiAgICByZXR1cm4gdiAhPT0gT2JqZWN0LnByb3RvdHlwZVtrZXldICYmIHYgIT09IEFycmF5LnByb3RvdHlwZVtrZXldO1xuICB9XG5cbiAgcmV0dXJuIGZhbHNlO1xufTtcblxuLyohXG4gKiBpZ25vcmVcbiAqL1xuXG5jb25zdCBNQVhfQVJSQVlfSU5ERVggPSBNYXRoLnBvdygyLCAzMikgLSAxO1xuXG5leHBvcnRzLmlzQXJyYXlJbmRleCA9IGZ1bmN0aW9uKHZhbCkge1xuICBpZiAodHlwZW9mIHZhbCA9PT0gJ251bWJlcicpIHtcbiAgICByZXR1cm4gdmFsID49IDAgJiYgdmFsIDw9IE1BWF9BUlJBWV9JTkRFWDtcbiAgfVxuICBpZiAodHlwZW9mIHZhbCA9PT0gJ3N0cmluZycpIHtcbiAgICBpZiAoIS9eXFxkKyQvLnRlc3QodmFsKSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICB2YWwgPSArdmFsO1xuICAgIHJldHVybiB2YWwgPj0gMCAmJiB2YWwgPD0gTUFYX0FSUkFZX0lOREVYO1xuICB9XG5cbiAgcmV0dXJuIGZhbHNlO1xufTtcblxuLyoqXG4gKiBSZW1vdmVzIGR1cGxpY2F0ZSB2YWx1ZXMgZnJvbSBhbiBhcnJheVxuICpcbiAqIFsxLCAyLCAzLCAzLCA1XSA9PiBbMSwgMiwgMywgNV1cbiAqIFsgT2JqZWN0SWQoXCI1NTA5ODhiYTBjMTlkNTdmNjk3ZGM0NWVcIiksIE9iamVjdElkKFwiNTUwOTg4YmEwYzE5ZDU3ZjY5N2RjNDVlXCIpIF1cbiAqICAgID0+IFtPYmplY3RJZChcIjU1MDk4OGJhMGMxOWQ1N2Y2OTdkYzQ1ZVwiKV1cbiAqXG4gKiBAcGFyYW0ge0FycmF5fSBhcnJcbiAqIEByZXR1cm4ge0FycmF5fVxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZXhwb3J0cy5hcnJheS51bmlxdWUgPSBmdW5jdGlvbihhcnIpIHtcbiAgY29uc3QgcHJpbWl0aXZlcyA9IG5ldyBTZXQoKTtcbiAgY29uc3QgaWRzID0gbmV3IFNldCgpO1xuICBjb25zdCByZXQgPSBbXTtcblxuICBmb3IgKGNvbnN0IGl0ZW0gb2YgYXJyKSB7XG4gICAgaWYgKHR5cGVvZiBpdGVtID09PSAnbnVtYmVyJyB8fCB0eXBlb2YgaXRlbSA9PT0gJ3N0cmluZycgfHwgaXRlbSA9PSBudWxsKSB7XG4gICAgICBpZiAocHJpbWl0aXZlcy5oYXMoaXRlbSkpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICByZXQucHVzaChpdGVtKTtcbiAgICAgIHByaW1pdGl2ZXMuYWRkKGl0ZW0pO1xuICAgIH0gZWxzZSBpZiAoaXNCc29uVHlwZShpdGVtLCAnT2JqZWN0SWQnKSkge1xuICAgICAgaWYgKGlkcy5oYXMoaXRlbS50b1N0cmluZygpKSkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIHJldC5wdXNoKGl0ZW0pO1xuICAgICAgaWRzLmFkZChpdGVtLnRvU3RyaW5nKCkpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXQucHVzaChpdGVtKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gcmV0O1xufTtcblxuZXhwb3J0cy5idWZmZXIgPSB7fTtcblxuLyoqXG4gKiBEZXRlcm1pbmVzIGlmIHR3byBidWZmZXJzIGFyZSBlcXVhbC5cbiAqXG4gKiBAcGFyYW0ge0J1ZmZlcn0gYVxuICogQHBhcmFtIHtPYmplY3R9IGJcbiAqL1xuXG5leHBvcnRzLmJ1ZmZlci5hcmVFcXVhbCA9IGZ1bmN0aW9uKGEsIGIpIHtcbiAgaWYgKCFCdWZmZXIuaXNCdWZmZXIoYSkpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgaWYgKCFCdWZmZXIuaXNCdWZmZXIoYikpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgaWYgKGEubGVuZ3RoICE9PSBiLmxlbmd0aCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBmb3IgKGxldCBpID0gMCwgbGVuID0gYS5sZW5ndGg7IGkgPCBsZW47ICsraSkge1xuICAgIGlmIChhW2ldICE9PSBiW2ldKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG4gIHJldHVybiB0cnVlO1xufTtcblxuZXhwb3J0cy5nZXRGdW5jdGlvbk5hbWUgPSBnZXRGdW5jdGlvbk5hbWU7XG5cbi8qKlxuICogRGVjb3JhdGUgYnVmZmVyc1xuICogQHBhcmFtIHtPYmplY3R9IGRlc3RpbmF0aW9uXG4gKiBAcGFyYW0ge09iamVjdH0gc291cmNlXG4gKi9cblxuZXhwb3J0cy5kZWNvcmF0ZSA9IGZ1bmN0aW9uKGRlc3RpbmF0aW9uLCBzb3VyY2UpIHtcbiAgZm9yIChjb25zdCBrZXkgaW4gc291cmNlKSB7XG4gICAgaWYgKHNwZWNpYWxQcm9wZXJ0aWVzLmhhcyhrZXkpKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgZGVzdGluYXRpb25ba2V5XSA9IHNvdXJjZVtrZXldO1xuICB9XG59O1xuXG4vKipcbiAqIG1lcmdlcyB0byB3aXRoIGEgY29weSBvZiBmcm9tXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IHRvXG4gKiBAcGFyYW0ge09iamVjdH0gZnJvbU9ialxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZXhwb3J0cy5tZXJnZUNsb25lID0gZnVuY3Rpb24odG8sIGZyb21PYmopIHtcbiAgaWYgKGlzTW9uZ29vc2VPYmplY3QoZnJvbU9iaikpIHtcbiAgICBmcm9tT2JqID0gZnJvbU9iai50b09iamVjdCh7XG4gICAgICB0cmFuc2Zvcm06IGZhbHNlLFxuICAgICAgdmlydHVhbHM6IGZhbHNlLFxuICAgICAgZGVwb3B1bGF0ZTogdHJ1ZSxcbiAgICAgIGdldHRlcnM6IGZhbHNlLFxuICAgICAgZmxhdHRlbkRlY2ltYWxzOiBmYWxzZVxuICAgIH0pO1xuICB9XG4gIGNvbnN0IGtleXMgPSBPYmplY3Qua2V5cyhmcm9tT2JqKTtcbiAgY29uc3QgbGVuID0ga2V5cy5sZW5ndGg7XG4gIGxldCBpID0gMDtcbiAgbGV0IGtleTtcblxuICB3aGlsZSAoaSA8IGxlbikge1xuICAgIGtleSA9IGtleXNbaSsrXTtcbiAgICBpZiAoc3BlY2lhbFByb3BlcnRpZXMuaGFzKGtleSkpIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIHRvW2tleV0gPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICB0b1trZXldID0gY2xvbmUoZnJvbU9ialtrZXldLCB7XG4gICAgICAgIHRyYW5zZm9ybTogZmFsc2UsXG4gICAgICAgIHZpcnR1YWxzOiBmYWxzZSxcbiAgICAgICAgZGVwb3B1bGF0ZTogdHJ1ZSxcbiAgICAgICAgZ2V0dGVyczogZmFsc2UsXG4gICAgICAgIGZsYXR0ZW5EZWNpbWFsczogZmFsc2VcbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICBsZXQgdmFsID0gZnJvbU9ialtrZXldO1xuICAgICAgaWYgKHZhbCAhPSBudWxsICYmIHZhbC52YWx1ZU9mICYmICEodmFsIGluc3RhbmNlb2YgRGF0ZSkpIHtcbiAgICAgICAgdmFsID0gdmFsLnZhbHVlT2YoKTtcbiAgICAgIH1cbiAgICAgIGlmIChleHBvcnRzLmlzT2JqZWN0KHZhbCkpIHtcbiAgICAgICAgbGV0IG9iaiA9IHZhbDtcbiAgICAgICAgaWYgKGlzTW9uZ29vc2VPYmplY3QodmFsKSAmJiAhdmFsLmlzTW9uZ29vc2VCdWZmZXIpIHtcbiAgICAgICAgICBvYmogPSBvYmoudG9PYmplY3Qoe1xuICAgICAgICAgICAgdHJhbnNmb3JtOiBmYWxzZSxcbiAgICAgICAgICAgIHZpcnR1YWxzOiBmYWxzZSxcbiAgICAgICAgICAgIGRlcG9wdWxhdGU6IHRydWUsXG4gICAgICAgICAgICBnZXR0ZXJzOiBmYWxzZSxcbiAgICAgICAgICAgIGZsYXR0ZW5EZWNpbWFsczogZmFsc2VcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodmFsLmlzTW9uZ29vc2VCdWZmZXIpIHtcbiAgICAgICAgICBvYmogPSBCdWZmZXIuZnJvbShvYmopO1xuICAgICAgICB9XG4gICAgICAgIGV4cG9ydHMubWVyZ2VDbG9uZSh0b1trZXldLCBvYmopO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdG9ba2V5XSA9IGNsb25lKHZhbCwge1xuICAgICAgICAgIGZsYXR0ZW5EZWNpbWFsczogZmFsc2VcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuICB9XG59O1xuXG4vKipcbiAqIEV4ZWN1dGVzIGEgZnVuY3Rpb24gb24gZWFjaCBlbGVtZW50IG9mIGFuIGFycmF5IChsaWtlIF8uZWFjaClcbiAqXG4gKiBAcGFyYW0ge0FycmF5fSBhcnJcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5leHBvcnRzLmVhY2ggPSBmdW5jdGlvbihhcnIsIGZuKSB7XG4gIGZvciAoY29uc3QgaXRlbSBvZiBhcnIpIHtcbiAgICBmbihpdGVtKTtcbiAgfVxufTtcblxuLyoqXG4gKiBSZW5hbWUgYW4gb2JqZWN0IGtleSwgd2hpbGUgcHJlc2VydmluZyBpdHMgcG9zaXRpb24gaW4gdGhlIG9iamVjdFxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBvbGRPYmpcbiAqIEBwYXJhbSB7U3RyaW5nfE51bWJlcn0gb2xkS2V5XG4gKiBAcGFyYW0ge1N0cmluZ3xOdW1iZXJ9IG5ld0tleVxuICogQGFwaSBwcml2YXRlXG4gKi9cbmV4cG9ydHMucmVuYW1lT2JqS2V5ID0gZnVuY3Rpb24ob2xkT2JqLCBvbGRLZXksIG5ld0tleSkge1xuICBjb25zdCBrZXlzID0gT2JqZWN0LmtleXMob2xkT2JqKTtcbiAgcmV0dXJuIGtleXMucmVkdWNlKFxuICAgIChhY2MsIHZhbCkgPT4ge1xuICAgICAgaWYgKHZhbCA9PT0gb2xkS2V5KSB7XG4gICAgICAgIGFjY1tuZXdLZXldID0gb2xkT2JqW29sZEtleV07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBhY2NbdmFsXSA9IG9sZE9ialt2YWxdO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGFjYztcbiAgICB9LFxuICAgIHt9XG4gICk7XG59O1xuXG4vKiFcbiAqIGlnbm9yZVxuICovXG5cbmV4cG9ydHMuZ2V0T3B0aW9uID0gZnVuY3Rpb24obmFtZSkge1xuICBjb25zdCBzb3VyY2VzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAxKTtcblxuICBmb3IgKGNvbnN0IHNvdXJjZSBvZiBzb3VyY2VzKSB7XG4gICAgaWYgKHNvdXJjZSA9PSBudWxsKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgaWYgKHNvdXJjZVtuYW1lXSAhPSBudWxsKSB7XG4gICAgICByZXR1cm4gc291cmNlW25hbWVdO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBudWxsO1xufTtcblxuLyohXG4gKiBpZ25vcmVcbiAqL1xuXG5leHBvcnRzLm5vb3AgPSBmdW5jdGlvbigpIHt9O1xuXG5leHBvcnRzLmVycm9yVG9QT0pPID0gZnVuY3Rpb24gZXJyb3JUb1BPSk8oZXJyb3IpIHtcbiAgY29uc3QgaXNFcnJvciA9IGVycm9yIGluc3RhbmNlb2YgRXJyb3I7XG4gIGlmICghaXNFcnJvcikge1xuICAgIHRocm93IG5ldyBFcnJvcignYGVycm9yYCBtdXN0IGJlIGBpbnN0YW5jZW9mIEVycm9yYC4nKTtcbiAgfVxuXG4gIGNvbnN0IHJldCA9IHt9O1xuICBmb3IgKGNvbnN0IHByb3BlcnlOYW1lIG9mIE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKGVycm9yKSkge1xuICAgIHJldFtwcm9wZXJ5TmFtZV0gPSBlcnJvcltwcm9wZXJ5TmFtZV07XG4gIH1cbiAgcmV0dXJuIHJldDtcbn07XG5cbi8qIVxuICogaWdub3JlXG4gKi9cblxuZXhwb3J0cy53YXJuID0gZnVuY3Rpb24gd2FybihtZXNzYWdlKSB7XG4gIHJldHVybiBwcm9jZXNzLmVtaXRXYXJuaW5nKG1lc3NhZ2UsIHsgY29kZTogJ01PTkdPT1NFJyB9KTtcbn07XG5cblxuZXhwb3J0cy5pbmplY3RUaW1lc3RhbXBzT3B0aW9uID0gZnVuY3Rpb24gaW5qZWN0VGltZXN0YW1wc09wdGlvbih3cml0ZU9wZXJhdGlvbiwgdGltZXN0YW1wc09wdGlvbikge1xuICBpZiAodGltZXN0YW1wc09wdGlvbiA9PSBudWxsKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIHdyaXRlT3BlcmF0aW9uLnRpbWVzdGFtcHMgPSB0aW1lc3RhbXBzT3B0aW9uO1xufTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/mongoose/lib/utils.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/mongoose/lib/validOptions.js":
/*!***************************************************!*\
  !*** ./node_modules/mongoose/lib/validOptions.js ***!
  \***************************************************/
/***/ ((module) => {

eval("\n/*!\n * Valid mongoose options\n */\n\n\n\nconst VALID_OPTIONS = Object.freeze([\n  'allowDiskUse',\n  'applyPluginsToChildSchemas',\n  'applyPluginsToDiscriminators',\n  'autoCreate',\n  'autoIndex',\n  'bufferCommands',\n  'bufferTimeoutMS',\n  'cloneSchemas',\n  'debug',\n  'id',\n  'timestamps.createdAt.immutable',\n  'maxTimeMS',\n  'objectIdGetter',\n  'overwriteModels',\n  'returnOriginal',\n  'runValidators',\n  'sanitizeFilter',\n  'sanitizeProjection',\n  'selectPopulatedPaths',\n  'setDefaultsOnInsert',\n  'strict',\n  'strictPopulate',\n  'strictQuery',\n  'toJSON',\n  'toObject',\n  'translateAliases'\n]);\n\nmodule.exports = VALID_OPTIONS;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbW9uZ29vc2UvbGliL3ZhbGlkT3B0aW9ucy5qcyIsIm1hcHBpbmdzIjoiO0FBQ0E7QUFDQTtBQUNBOztBQUVhOztBQUViO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vYXBwMS8uL25vZGVfbW9kdWxlcy9tb25nb29zZS9saWIvdmFsaWRPcHRpb25zLmpzPzJkMzkiXSwic291cmNlc0NvbnRlbnQiOlsiXG4vKiFcbiAqIFZhbGlkIG1vbmdvb3NlIG9wdGlvbnNcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbmNvbnN0IFZBTElEX09QVElPTlMgPSBPYmplY3QuZnJlZXplKFtcbiAgJ2FsbG93RGlza1VzZScsXG4gICdhcHBseVBsdWdpbnNUb0NoaWxkU2NoZW1hcycsXG4gICdhcHBseVBsdWdpbnNUb0Rpc2NyaW1pbmF0b3JzJyxcbiAgJ2F1dG9DcmVhdGUnLFxuICAnYXV0b0luZGV4JyxcbiAgJ2J1ZmZlckNvbW1hbmRzJyxcbiAgJ2J1ZmZlclRpbWVvdXRNUycsXG4gICdjbG9uZVNjaGVtYXMnLFxuICAnZGVidWcnLFxuICAnaWQnLFxuICAndGltZXN0YW1wcy5jcmVhdGVkQXQuaW1tdXRhYmxlJyxcbiAgJ21heFRpbWVNUycsXG4gICdvYmplY3RJZEdldHRlcicsXG4gICdvdmVyd3JpdGVNb2RlbHMnLFxuICAncmV0dXJuT3JpZ2luYWwnLFxuICAncnVuVmFsaWRhdG9ycycsXG4gICdzYW5pdGl6ZUZpbHRlcicsXG4gICdzYW5pdGl6ZVByb2plY3Rpb24nLFxuICAnc2VsZWN0UG9wdWxhdGVkUGF0aHMnLFxuICAnc2V0RGVmYXVsdHNPbkluc2VydCcsXG4gICdzdHJpY3QnLFxuICAnc3RyaWN0UG9wdWxhdGUnLFxuICAnc3RyaWN0UXVlcnknLFxuICAndG9KU09OJyxcbiAgJ3RvT2JqZWN0JyxcbiAgJ3RyYW5zbGF0ZUFsaWFzZXMnXG5dKTtcblxubW9kdWxlLmV4cG9ydHMgPSBWQUxJRF9PUFRJT05TO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/mongoose/lib/validOptions.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/mongoose/lib/virtualType.js":
/*!**************************************************!*\
  !*** ./node_modules/mongoose/lib/virtualType.js ***!
  \**************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\n\nconst utils = __webpack_require__(/*! ./utils */ \"(ssr)/./node_modules/mongoose/lib/utils.js\");\n\n/**\n * VirtualType constructor\n *\n * This is what mongoose uses to define virtual attributes via `Schema.prototype.virtual`.\n *\n * #### Example:\n *\n *     const fullname = schema.virtual('fullname');\n *     fullname instanceof mongoose.VirtualType // true\n *\n * @param {Object} options\n * @param {String|Function} [options.ref] if `ref` is not nullish, this becomes a [populated virtual](https://mongoosejs.com/docs/populate.html#populate-virtuals)\n * @param {String|Function} [options.localField] the local field to populate on if this is a populated virtual.\n * @param {String|Function} [options.foreignField] the foreign field to populate on if this is a populated virtual.\n * @param {Boolean} [options.justOne=false] by default, a populated virtual is an array. If you set `justOne`, the populated virtual will be a single doc or `null`.\n * @param {Boolean} [options.getters=false] if you set this to `true`, Mongoose will call any custom getters you defined on this virtual\n * @param {Boolean} [options.count=false] if you set this to `true`, `populate()` will set this virtual to the number of populated documents, as opposed to the documents themselves, using [`Query#countDocuments()`](https://mongoosejs.com/docs/api/query.html#Query.prototype.countDocuments())\n * @param {Object|Function} [options.match=null] add an extra match condition to `populate()`\n * @param {Number} [options.limit=null] add a default `limit` to the `populate()` query\n * @param {Number} [options.skip=null] add a default `skip` to the `populate()` query\n * @param {Number} [options.perDocumentLimit=null] For legacy reasons, `limit` with `populate()` may give incorrect results because it only executes a single query for every document being populated. If you set `perDocumentLimit`, Mongoose will ensure correct `limit` per document by executing a separate query for each document to `populate()`. For example, `.find().populate({ path: 'test', perDocumentLimit: 2 })` will execute 2 additional queries if `.find()` returns 2 documents.\n * @param {Object} [options.options=null] Additional options like `limit` and `lean`.\n * @param {String} name\n * @api public\n */\n\nfunction VirtualType(options, name) {\n  this.path = name;\n  this.getters = [];\n  this.setters = [];\n  this.options = Object.assign({}, options);\n}\n\n/**\n * If no getters/setters, add a default\n *\n * @api private\n */\n\nVirtualType.prototype._applyDefaultGetters = function() {\n  if (this.getters.length > 0 || this.setters.length > 0) {\n    return;\n  }\n\n  const path = this.path;\n  const internalProperty = '$' + path;\n  this.getters.push(function() {\n    return this.$locals[internalProperty];\n  });\n  this.setters.push(function(v) {\n    this.$locals[internalProperty] = v;\n  });\n};\n\n/*!\n * ignore\n */\n\nVirtualType.prototype.clone = function() {\n  const clone = new VirtualType(this.options, this.path);\n  clone.getters = [].concat(this.getters);\n  clone.setters = [].concat(this.setters);\n  return clone;\n};\n\n/**\n * Adds a custom getter to this virtual.\n *\n * Mongoose calls the getter function with the below 3 parameters.\n *\n * - `value`: the value returned by the previous getter. If there is only one getter, `value` will be `undefined`.\n * - `virtual`: the virtual object you called `.get()` on.\n * - `doc`: the document this virtual is attached to. Equivalent to `this`.\n *\n * #### Example:\n *\n *     const virtual = schema.virtual('fullname');\n *     virtual.get(function(value, virtual, doc) {\n *       return this.name.first + ' ' + this.name.last;\n *     });\n *\n * @param {Function} fn\n * @return {VirtualType} this\n * @api public\n */\n\nVirtualType.prototype.get = function(fn) {\n  this.getters.push(fn);\n  return this;\n};\n\n/**\n * Adds a custom setter to this virtual.\n *\n * Mongoose calls the setter function with the below 3 parameters.\n *\n * - `value`: the value being set.\n * - `virtual`: the virtual object you're calling `.set()` on.\n * - `doc`: the document this virtual is attached to. Equivalent to `this`.\n *\n * #### Example:\n *\n *     const virtual = schema.virtual('fullname');\n *     virtual.set(function(value, virtual, doc) {\n *       const parts = value.split(' ');\n *       this.name.first = parts[0];\n *       this.name.last = parts[1];\n *     });\n *\n *     const Model = mongoose.model('Test', schema);\n *     const doc = new Model();\n *     // Calls the setter with `value = 'Jean-Luc Picard'`\n *     doc.fullname = 'Jean-Luc Picard';\n *     doc.name.first; // 'Jean-Luc'\n *     doc.name.last; // 'Picard'\n *\n * @param {Function} fn\n * @return {VirtualType} this\n * @api public\n */\n\nVirtualType.prototype.set = function(fn) {\n  this.setters.push(fn);\n  return this;\n};\n\n/**\n * Applies getters to `value`.\n *\n * @param {Object} value\n * @param {Document} doc The document this virtual is attached to\n * @return {Any} the value after applying all getters\n * @api public\n */\n\nVirtualType.prototype.applyGetters = function(value, doc) {\n  if (utils.hasUserDefinedProperty(this.options, ['ref', 'refPath']) &&\n      doc.$$populatedVirtuals &&\n      doc.$$populatedVirtuals.hasOwnProperty(this.path)) {\n    value = doc.$$populatedVirtuals[this.path];\n  }\n\n  let v = value;\n  for (const getter of this.getters) {\n    v = getter.call(doc, v, this, doc);\n  }\n  return v;\n};\n\n/**\n * Applies setters to `value`.\n *\n * @param {Object} value\n * @param {Document} doc\n * @return {Any} the value after applying all setters\n * @api public\n */\n\nVirtualType.prototype.applySetters = function(value, doc) {\n  let v = value;\n  for (const setter of this.setters) {\n    v = setter.call(doc, v, this, doc);\n  }\n  return v;\n};\n\n/*!\n * exports\n */\n\nmodule.exports = VirtualType;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbW9uZ29vc2UvbGliL3ZpcnR1YWxUeXBlLmpzIiwibWFwcGluZ3MiOiJBQUFhOztBQUViLGNBQWMsbUJBQU8sQ0FBQywyREFBUzs7QUFFL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsV0FBVyxpQkFBaUI7QUFDNUIsV0FBVyxpQkFBaUI7QUFDNUIsV0FBVyxpQkFBaUI7QUFDNUIsV0FBVyxTQUFTO0FBQ3BCLFdBQVcsU0FBUztBQUNwQixXQUFXLFNBQVM7QUFDcEIsV0FBVyxpQkFBaUI7QUFDNUIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVEsd1dBQXdXLG1DQUFtQztBQUM5WixXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUM7QUFDakM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBLFdBQVcsVUFBVTtBQUNyQixZQUFZLGFBQWE7QUFDekI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCO0FBQ3ZCLHNCQUFzQjtBQUN0QjtBQUNBLFdBQVcsVUFBVTtBQUNyQixZQUFZLGFBQWE7QUFDekI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsV0FBVyxVQUFVO0FBQ3JCLFlBQVksS0FBSztBQUNqQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFdBQVcsVUFBVTtBQUNyQixZQUFZLEtBQUs7QUFDakI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9hcHAxLy4vbm9kZV9tb2R1bGVzL21vbmdvb3NlL2xpYi92aXJ0dWFsVHlwZS5qcz8zOGI0Il0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxuY29uc3QgdXRpbHMgPSByZXF1aXJlKCcuL3V0aWxzJyk7XG5cbi8qKlxuICogVmlydHVhbFR5cGUgY29uc3RydWN0b3JcbiAqXG4gKiBUaGlzIGlzIHdoYXQgbW9uZ29vc2UgdXNlcyB0byBkZWZpbmUgdmlydHVhbCBhdHRyaWJ1dGVzIHZpYSBgU2NoZW1hLnByb3RvdHlwZS52aXJ0dWFsYC5cbiAqXG4gKiAjIyMjIEV4YW1wbGU6XG4gKlxuICogICAgIGNvbnN0IGZ1bGxuYW1lID0gc2NoZW1hLnZpcnR1YWwoJ2Z1bGxuYW1lJyk7XG4gKiAgICAgZnVsbG5hbWUgaW5zdGFuY2VvZiBtb25nb29zZS5WaXJ0dWFsVHlwZSAvLyB0cnVlXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcbiAqIEBwYXJhbSB7U3RyaW5nfEZ1bmN0aW9ufSBbb3B0aW9ucy5yZWZdIGlmIGByZWZgIGlzIG5vdCBudWxsaXNoLCB0aGlzIGJlY29tZXMgYSBbcG9wdWxhdGVkIHZpcnR1YWxdKGh0dHBzOi8vbW9uZ29vc2Vqcy5jb20vZG9jcy9wb3B1bGF0ZS5odG1sI3BvcHVsYXRlLXZpcnR1YWxzKVxuICogQHBhcmFtIHtTdHJpbmd8RnVuY3Rpb259IFtvcHRpb25zLmxvY2FsRmllbGRdIHRoZSBsb2NhbCBmaWVsZCB0byBwb3B1bGF0ZSBvbiBpZiB0aGlzIGlzIGEgcG9wdWxhdGVkIHZpcnR1YWwuXG4gKiBAcGFyYW0ge1N0cmluZ3xGdW5jdGlvbn0gW29wdGlvbnMuZm9yZWlnbkZpZWxkXSB0aGUgZm9yZWlnbiBmaWVsZCB0byBwb3B1bGF0ZSBvbiBpZiB0aGlzIGlzIGEgcG9wdWxhdGVkIHZpcnR1YWwuXG4gKiBAcGFyYW0ge0Jvb2xlYW59IFtvcHRpb25zLmp1c3RPbmU9ZmFsc2VdIGJ5IGRlZmF1bHQsIGEgcG9wdWxhdGVkIHZpcnR1YWwgaXMgYW4gYXJyYXkuIElmIHlvdSBzZXQgYGp1c3RPbmVgLCB0aGUgcG9wdWxhdGVkIHZpcnR1YWwgd2lsbCBiZSBhIHNpbmdsZSBkb2Mgb3IgYG51bGxgLlxuICogQHBhcmFtIHtCb29sZWFufSBbb3B0aW9ucy5nZXR0ZXJzPWZhbHNlXSBpZiB5b3Ugc2V0IHRoaXMgdG8gYHRydWVgLCBNb25nb29zZSB3aWxsIGNhbGwgYW55IGN1c3RvbSBnZXR0ZXJzIHlvdSBkZWZpbmVkIG9uIHRoaXMgdmlydHVhbFxuICogQHBhcmFtIHtCb29sZWFufSBbb3B0aW9ucy5jb3VudD1mYWxzZV0gaWYgeW91IHNldCB0aGlzIHRvIGB0cnVlYCwgYHBvcHVsYXRlKClgIHdpbGwgc2V0IHRoaXMgdmlydHVhbCB0byB0aGUgbnVtYmVyIG9mIHBvcHVsYXRlZCBkb2N1bWVudHMsIGFzIG9wcG9zZWQgdG8gdGhlIGRvY3VtZW50cyB0aGVtc2VsdmVzLCB1c2luZyBbYFF1ZXJ5I2NvdW50RG9jdW1lbnRzKClgXShodHRwczovL21vbmdvb3NlanMuY29tL2RvY3MvYXBpL3F1ZXJ5Lmh0bWwjUXVlcnkucHJvdG90eXBlLmNvdW50RG9jdW1lbnRzKCkpXG4gKiBAcGFyYW0ge09iamVjdHxGdW5jdGlvbn0gW29wdGlvbnMubWF0Y2g9bnVsbF0gYWRkIGFuIGV4dHJhIG1hdGNoIGNvbmRpdGlvbiB0byBgcG9wdWxhdGUoKWBcbiAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy5saW1pdD1udWxsXSBhZGQgYSBkZWZhdWx0IGBsaW1pdGAgdG8gdGhlIGBwb3B1bGF0ZSgpYCBxdWVyeVxuICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLnNraXA9bnVsbF0gYWRkIGEgZGVmYXVsdCBgc2tpcGAgdG8gdGhlIGBwb3B1bGF0ZSgpYCBxdWVyeVxuICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLnBlckRvY3VtZW50TGltaXQ9bnVsbF0gRm9yIGxlZ2FjeSByZWFzb25zLCBgbGltaXRgIHdpdGggYHBvcHVsYXRlKClgIG1heSBnaXZlIGluY29ycmVjdCByZXN1bHRzIGJlY2F1c2UgaXQgb25seSBleGVjdXRlcyBhIHNpbmdsZSBxdWVyeSBmb3IgZXZlcnkgZG9jdW1lbnQgYmVpbmcgcG9wdWxhdGVkLiBJZiB5b3Ugc2V0IGBwZXJEb2N1bWVudExpbWl0YCwgTW9uZ29vc2Ugd2lsbCBlbnN1cmUgY29ycmVjdCBgbGltaXRgIHBlciBkb2N1bWVudCBieSBleGVjdXRpbmcgYSBzZXBhcmF0ZSBxdWVyeSBmb3IgZWFjaCBkb2N1bWVudCB0byBgcG9wdWxhdGUoKWAuIEZvciBleGFtcGxlLCBgLmZpbmQoKS5wb3B1bGF0ZSh7IHBhdGg6ICd0ZXN0JywgcGVyRG9jdW1lbnRMaW1pdDogMiB9KWAgd2lsbCBleGVjdXRlIDIgYWRkaXRpb25hbCBxdWVyaWVzIGlmIGAuZmluZCgpYCByZXR1cm5zIDIgZG9jdW1lbnRzLlxuICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zLm9wdGlvbnM9bnVsbF0gQWRkaXRpb25hbCBvcHRpb25zIGxpa2UgYGxpbWl0YCBhbmQgYGxlYW5gLlxuICogQHBhcmFtIHtTdHJpbmd9IG5hbWVcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZnVuY3Rpb24gVmlydHVhbFR5cGUob3B0aW9ucywgbmFtZSkge1xuICB0aGlzLnBhdGggPSBuYW1lO1xuICB0aGlzLmdldHRlcnMgPSBbXTtcbiAgdGhpcy5zZXR0ZXJzID0gW107XG4gIHRoaXMub3B0aW9ucyA9IE9iamVjdC5hc3NpZ24oe30sIG9wdGlvbnMpO1xufVxuXG4vKipcbiAqIElmIG5vIGdldHRlcnMvc2V0dGVycywgYWRkIGEgZGVmYXVsdFxuICpcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cblZpcnR1YWxUeXBlLnByb3RvdHlwZS5fYXBwbHlEZWZhdWx0R2V0dGVycyA9IGZ1bmN0aW9uKCkge1xuICBpZiAodGhpcy5nZXR0ZXJzLmxlbmd0aCA+IDAgfHwgdGhpcy5zZXR0ZXJzLmxlbmd0aCA+IDApIHtcbiAgICByZXR1cm47XG4gIH1cblxuICBjb25zdCBwYXRoID0gdGhpcy5wYXRoO1xuICBjb25zdCBpbnRlcm5hbFByb3BlcnR5ID0gJyQnICsgcGF0aDtcbiAgdGhpcy5nZXR0ZXJzLnB1c2goZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMuJGxvY2Fsc1tpbnRlcm5hbFByb3BlcnR5XTtcbiAgfSk7XG4gIHRoaXMuc2V0dGVycy5wdXNoKGZ1bmN0aW9uKHYpIHtcbiAgICB0aGlzLiRsb2NhbHNbaW50ZXJuYWxQcm9wZXJ0eV0gPSB2O1xuICB9KTtcbn07XG5cbi8qIVxuICogaWdub3JlXG4gKi9cblxuVmlydHVhbFR5cGUucHJvdG90eXBlLmNsb25lID0gZnVuY3Rpb24oKSB7XG4gIGNvbnN0IGNsb25lID0gbmV3IFZpcnR1YWxUeXBlKHRoaXMub3B0aW9ucywgdGhpcy5wYXRoKTtcbiAgY2xvbmUuZ2V0dGVycyA9IFtdLmNvbmNhdCh0aGlzLmdldHRlcnMpO1xuICBjbG9uZS5zZXR0ZXJzID0gW10uY29uY2F0KHRoaXMuc2V0dGVycyk7XG4gIHJldHVybiBjbG9uZTtcbn07XG5cbi8qKlxuICogQWRkcyBhIGN1c3RvbSBnZXR0ZXIgdG8gdGhpcyB2aXJ0dWFsLlxuICpcbiAqIE1vbmdvb3NlIGNhbGxzIHRoZSBnZXR0ZXIgZnVuY3Rpb24gd2l0aCB0aGUgYmVsb3cgMyBwYXJhbWV0ZXJzLlxuICpcbiAqIC0gYHZhbHVlYDogdGhlIHZhbHVlIHJldHVybmVkIGJ5IHRoZSBwcmV2aW91cyBnZXR0ZXIuIElmIHRoZXJlIGlzIG9ubHkgb25lIGdldHRlciwgYHZhbHVlYCB3aWxsIGJlIGB1bmRlZmluZWRgLlxuICogLSBgdmlydHVhbGA6IHRoZSB2aXJ0dWFsIG9iamVjdCB5b3UgY2FsbGVkIGAuZ2V0KClgIG9uLlxuICogLSBgZG9jYDogdGhlIGRvY3VtZW50IHRoaXMgdmlydHVhbCBpcyBhdHRhY2hlZCB0by4gRXF1aXZhbGVudCB0byBgdGhpc2AuXG4gKlxuICogIyMjIyBFeGFtcGxlOlxuICpcbiAqICAgICBjb25zdCB2aXJ0dWFsID0gc2NoZW1hLnZpcnR1YWwoJ2Z1bGxuYW1lJyk7XG4gKiAgICAgdmlydHVhbC5nZXQoZnVuY3Rpb24odmFsdWUsIHZpcnR1YWwsIGRvYykge1xuICogICAgICAgcmV0dXJuIHRoaXMubmFtZS5maXJzdCArICcgJyArIHRoaXMubmFtZS5sYXN0O1xuICogICAgIH0pO1xuICpcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuXG4gKiBAcmV0dXJuIHtWaXJ0dWFsVHlwZX0gdGhpc1xuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5WaXJ0dWFsVHlwZS5wcm90b3R5cGUuZ2V0ID0gZnVuY3Rpb24oZm4pIHtcbiAgdGhpcy5nZXR0ZXJzLnB1c2goZm4pO1xuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogQWRkcyBhIGN1c3RvbSBzZXR0ZXIgdG8gdGhpcyB2aXJ0dWFsLlxuICpcbiAqIE1vbmdvb3NlIGNhbGxzIHRoZSBzZXR0ZXIgZnVuY3Rpb24gd2l0aCB0aGUgYmVsb3cgMyBwYXJhbWV0ZXJzLlxuICpcbiAqIC0gYHZhbHVlYDogdGhlIHZhbHVlIGJlaW5nIHNldC5cbiAqIC0gYHZpcnR1YWxgOiB0aGUgdmlydHVhbCBvYmplY3QgeW91J3JlIGNhbGxpbmcgYC5zZXQoKWAgb24uXG4gKiAtIGBkb2NgOiB0aGUgZG9jdW1lbnQgdGhpcyB2aXJ0dWFsIGlzIGF0dGFjaGVkIHRvLiBFcXVpdmFsZW50IHRvIGB0aGlzYC5cbiAqXG4gKiAjIyMjIEV4YW1wbGU6XG4gKlxuICogICAgIGNvbnN0IHZpcnR1YWwgPSBzY2hlbWEudmlydHVhbCgnZnVsbG5hbWUnKTtcbiAqICAgICB2aXJ0dWFsLnNldChmdW5jdGlvbih2YWx1ZSwgdmlydHVhbCwgZG9jKSB7XG4gKiAgICAgICBjb25zdCBwYXJ0cyA9IHZhbHVlLnNwbGl0KCcgJyk7XG4gKiAgICAgICB0aGlzLm5hbWUuZmlyc3QgPSBwYXJ0c1swXTtcbiAqICAgICAgIHRoaXMubmFtZS5sYXN0ID0gcGFydHNbMV07XG4gKiAgICAgfSk7XG4gKlxuICogICAgIGNvbnN0IE1vZGVsID0gbW9uZ29vc2UubW9kZWwoJ1Rlc3QnLCBzY2hlbWEpO1xuICogICAgIGNvbnN0IGRvYyA9IG5ldyBNb2RlbCgpO1xuICogICAgIC8vIENhbGxzIHRoZSBzZXR0ZXIgd2l0aCBgdmFsdWUgPSAnSmVhbi1MdWMgUGljYXJkJ2BcbiAqICAgICBkb2MuZnVsbG5hbWUgPSAnSmVhbi1MdWMgUGljYXJkJztcbiAqICAgICBkb2MubmFtZS5maXJzdDsgLy8gJ0plYW4tTHVjJ1xuICogICAgIGRvYy5uYW1lLmxhc3Q7IC8vICdQaWNhcmQnXG4gKlxuICogQHBhcmFtIHtGdW5jdGlvbn0gZm5cbiAqIEByZXR1cm4ge1ZpcnR1YWxUeXBlfSB0aGlzXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cblZpcnR1YWxUeXBlLnByb3RvdHlwZS5zZXQgPSBmdW5jdGlvbihmbikge1xuICB0aGlzLnNldHRlcnMucHVzaChmbik7XG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBBcHBsaWVzIGdldHRlcnMgdG8gYHZhbHVlYC5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gdmFsdWVcbiAqIEBwYXJhbSB7RG9jdW1lbnR9IGRvYyBUaGUgZG9jdW1lbnQgdGhpcyB2aXJ0dWFsIGlzIGF0dGFjaGVkIHRvXG4gKiBAcmV0dXJuIHtBbnl9IHRoZSB2YWx1ZSBhZnRlciBhcHBseWluZyBhbGwgZ2V0dGVyc1xuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5WaXJ0dWFsVHlwZS5wcm90b3R5cGUuYXBwbHlHZXR0ZXJzID0gZnVuY3Rpb24odmFsdWUsIGRvYykge1xuICBpZiAodXRpbHMuaGFzVXNlckRlZmluZWRQcm9wZXJ0eSh0aGlzLm9wdGlvbnMsIFsncmVmJywgJ3JlZlBhdGgnXSkgJiZcbiAgICAgIGRvYy4kJHBvcHVsYXRlZFZpcnR1YWxzICYmXG4gICAgICBkb2MuJCRwb3B1bGF0ZWRWaXJ0dWFscy5oYXNPd25Qcm9wZXJ0eSh0aGlzLnBhdGgpKSB7XG4gICAgdmFsdWUgPSBkb2MuJCRwb3B1bGF0ZWRWaXJ0dWFsc1t0aGlzLnBhdGhdO1xuICB9XG5cbiAgbGV0IHYgPSB2YWx1ZTtcbiAgZm9yIChjb25zdCBnZXR0ZXIgb2YgdGhpcy5nZXR0ZXJzKSB7XG4gICAgdiA9IGdldHRlci5jYWxsKGRvYywgdiwgdGhpcywgZG9jKTtcbiAgfVxuICByZXR1cm4gdjtcbn07XG5cbi8qKlxuICogQXBwbGllcyBzZXR0ZXJzIHRvIGB2YWx1ZWAuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IHZhbHVlXG4gKiBAcGFyYW0ge0RvY3VtZW50fSBkb2NcbiAqIEByZXR1cm4ge0FueX0gdGhlIHZhbHVlIGFmdGVyIGFwcGx5aW5nIGFsbCBzZXR0ZXJzXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cblZpcnR1YWxUeXBlLnByb3RvdHlwZS5hcHBseVNldHRlcnMgPSBmdW5jdGlvbih2YWx1ZSwgZG9jKSB7XG4gIGxldCB2ID0gdmFsdWU7XG4gIGZvciAoY29uc3Qgc2V0dGVyIG9mIHRoaXMuc2V0dGVycykge1xuICAgIHYgPSBzZXR0ZXIuY2FsbChkb2MsIHYsIHRoaXMsIGRvYyk7XG4gIH1cbiAgcmV0dXJuIHY7XG59O1xuXG4vKiFcbiAqIGV4cG9ydHNcbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IFZpcnR1YWxUeXBlO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/mongoose/lib/virtualType.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/mongoose/package.json":
/*!********************************************!*\
  !*** ./node_modules/mongoose/package.json ***!
  \********************************************/
/***/ ((module) => {

module.exports = JSON.parse('{"name":"mongoose","description":"Mongoose MongoDB ODM","version":"8.0.1","author":"Guillermo Rauch <guillermo@learnboost.com>","keywords":["mongodb","document","model","schema","database","odm","data","datastore","query","nosql","orm","db"],"license":"MIT","dependencies":{"bson":"^6.2.0","kareem":"2.5.1","mongodb":"6.2.0","mpath":"0.9.0","mquery":"5.0.0","ms":"2.1.3","sift":"16.0.1"},"devDependencies":{"@babel/core":"7.23.2","@babel/preset-env":"7.22.20","@typescript-eslint/eslint-plugin":"^6.2.1","@typescript-eslint/parser":"^6.2.1","acquit":"1.3.0","acquit-ignore":"0.2.1","acquit-require":"0.1.1","assert-browserify":"2.0.0","axios":"1.1.3","babel-loader":"8.2.5","benchmark":"2.1.4","broken-link-checker":"^0.7.8","buffer":"^5.6.0","cheerio":"1.0.0-rc.12","crypto-browserify":"3.12.0","dotenv":"16.3.1","dox":"1.0.0","eslint":"8.52.0","eslint-plugin-markdown":"^3.0.1","eslint-plugin-mocha-no-only":"1.1.1","express":"^4.18.1","fs-extra":"~11.1.1","highlight.js":"11.8.0","lodash.isequal":"4.5.0","lodash.isequalwith":"4.4.0","markdownlint-cli2":"^0.10.0","marked":"4.3.0","mkdirp":"^3.0.1","mocha":"10.2.0","moment":"2.x","mongodb-memory-server":"8.15.1","ncp":"^2.0.0","nyc":"15.1.0","pug":"3.0.2","q":"1.5.1","sinon":"17.0.1","stream-browserify":"3.0.0","tsd":"0.29.0","typescript":"5.2.2","uuid":"9.0.1","webpack":"5.89.0"},"directories":{"lib":"./lib/mongoose"},"scripts":{"docs:clean":"npm run docs:clean:stable","docs:clean:stable":"rimraf index.html && rimraf -rf ./docs/*.html  && rimraf -rf ./docs/api && rimraf -rf ./docs/tutorials/*.html && rimraf -rf ./docs/typescript/*.html && rimraf -rf ./docs/*.html && rimraf -rf ./docs/source/_docs && rimraf -rf ./tmp","docs:clean:5x":"rimraf index.html && rimraf -rf ./docs/5.x && rimraf -rf ./docs/source/_docs && rimraf -rf ./tmp","docs:clean:6x":"rimraf index.html && rimraf -rf ./docs/6.x && rimraf -rf ./docs/source/_docs && rimraf -rf ./tmp","docs:copy:tmp":"mkdirp ./tmp/docs/css && mkdirp ./tmp/docs/js && mkdirp ./tmp/docs/images && mkdirp ./tmp/docs/tutorials && mkdirp ./tmp/docs/typescript && mkdirp ./tmp/docs/api && ncp ./docs/css ./tmp/docs/css --filter=.css$ && ncp ./docs/js ./tmp/docs/js --filter=.js$ && ncp ./docs/images ./tmp/docs/images && ncp ./docs/tutorials ./tmp/docs/tutorials && ncp ./docs/typescript ./tmp/docs/typescript && ncp ./docs/api ./tmp/docs/api && cp index.html ./tmp && cp docs/*.html ./tmp/docs/","docs:copy:tmp:5x":"rimraf ./docs/5.x && ncp ./tmp ./docs/5.x","docs:move:6x:tmp":"mv ./docs/6.x ./tmp","docs:copy:tmp:6x":"rimraf ./docs/6.x && ncp ./tmp ./docs/6.x","docs:checkout:gh-pages":"git checkout gh-pages","docs:checkout:5x":"git checkout 5.x","docs:checkout:6x":"git checkout 6.x","docs:generate":"node ./scripts/website.js","docs:generate:search":"node ./scripts/generateSearch.js","docs:generate:sponsorData":"node ./scripts/loadSponsorData.js","docs:merge:stable":"git merge master","docs:merge:5x":"git merge 5.x","docs:merge:6x":"git merge 6.x","docs:test":"npm run docs:generate && npm run docs:generate:search","docs:view":"node ./scripts/static.js","docs:prepare:publish:stable":"npm run docs:checkout:gh-pages && npm run docs:merge:stable && npm run docs:clean:stable && npm run docs:generate && npm run docs:generate:search","docs:prepare:publish:5x":"npm run docs:checkout:5x && npm run docs:merge:5x && npm run docs:clean:stable && npm run docs:generate && npm run docs:copy:tmp && npm run docs:checkout:gh-pages && npm run docs:copy:tmp:5x","docs:prepare:publish:6x":"npm run docs:checkout:6x && npm run docs:merge:6x && npm run docs:clean:stable && env DOCS_DEPLOY=true npm run docs:generate && npm run docs:move:6x:tmp && npm run docs:checkout:gh-pages && npm run docs:copy:tmp:6x","docs:prepare:publish:7x":"git checkout 7.x && npm run docs:clean:stable && env DOCS_DEPLOY=true npm run docs:generate && mv ./docs/7.x ./tmp && npm run docs:checkout:gh-pages && rimraf ./docs/7.x && ncp ./tmp ./docs/7.x","docs:check-links":"blc http://127.0.0.1:8089 -ro","lint":"eslint .","lint-js":"eslint . --ext .js --ext .cjs","lint-ts":"eslint . --ext .ts","lint-md":"markdownlint-cli2 \\"**/*.md\\"","build-browser":"(rm ./dist/* || true) && node ./scripts/build-browser.js","prepublishOnly":"npm run build-browser","release":"git pull && git push origin master --tags && npm publish","release-5x":"git pull origin 5.x && git push origin 5.x && git push origin 5.x --tags && npm publish --tag 5x","release-6x":"git pull origin 6.x && git push origin 6.x && git push origin 6.x --tags && npm publish --tag 6x","mongo":"node ./tools/repl.js","publish-7x":"npm publish --tag 7x","test":"mocha --exit ./test/*.test.js","test-deno":"deno run --allow-env --allow-read --allow-net --allow-run --allow-sys --allow-write ./test/deno.js","test-rs":"START_REPLICA_SET=1 mocha --timeout 30000 --exit ./test/*.test.js","test-tsd":"node ./test/types/check-types-filename && tsd","tdd":"mocha ./test/*.test.js --inspect --watch --recursive --watch-files ./**/*.{js,ts}","test-coverage":"nyc --reporter=html --reporter=text npm test","ts-benchmark":"cd ./benchmarks/typescript/simple && npm install && npm run benchmark | node ../../../scripts/tsc-diagnostics-check"},"main":"./index.js","types":"./types/index.d.ts","engines":{"node":">=16.20.1"},"bugs":{"url":"https://github.com/Automattic/mongoose/issues/new"},"repository":{"type":"git","url":"git://github.com/Automattic/mongoose.git"},"homepage":"https://mongoosejs.com","browser":"./dist/browser.umd.js","config":{"mongodbMemoryServer":{"disablePostinstall":true}},"funding":{"type":"opencollective","url":"https://opencollective.com/mongoose"},"tsd":{"directory":"test/types","compilerOptions":{"esModuleInterop":false,"strict":true,"allowSyntheticDefaultImports":true,"strictPropertyInitialization":false,"noImplicitAny":false,"strictNullChecks":true,"module":"commonjs","target":"ES2017"}}}');

/***/ })

};
;